(function() {
    'use strict';
    !function(e) {
        ("object" != typeof exports || "undefined" == typeof module) && "function" == typeof define && define.amd ? define(e) : e();
    }(function() {
        function e(n) {
            var t = this.constructor;
            return this.then(function(e) {
                return t.resolve(n()).then(function() {
                    return e;
                });
            }, function(e) {
                return t.resolve(n()).then(function() {
                    return t.reject(e);
                });
            });
        }
        var n = setTimeout;
        function a(e) {
            return e && "undefined" != typeof e.length;
        }
        function o() {}
        function i(e) {
            if (!(this instanceof i))
                throw new TypeError("Promises must be constructed via new");
            if ("function" != typeof e)
                throw new TypeError("not a function");
            this._state = 0,
            this._handled = !1,
            this._value = undefined,
            this._deferreds = [],
            s(e, this);
        }
        function r(o, r) {
            for (; 3 === o._state;)
                o = o._value;
            0 !== o._state ? (o._handled = !0, i._immediateFn(function() {
                var e = 1 === o._state ? r.onFulfilled : r.onRejected;
                if (null !== e) {
                    var n;
                    try {
                        n = e(o._value);
                    } catch (t) {
                        return void u(r.promise, t);
                    }
                    f(r.promise, n);
                } else
                    (1 === o._state ? f : u)(r.promise, o._value);
            })) : o._deferreds.push(r);
        }
        function f(e, n) {
            try {
                if (n === e)
                    throw new TypeError("A promise cannot be resolved with itself.");
                if (n && ("object" == typeof n || "function" == typeof n)) {
                    var t = n.then;
                    if (n instanceof i)
                        return e._state = 3, e._value = n, void c(e);
                    if ("function" == typeof t)
                        return void s(function o(e, n) {
                            return function() {
                                e.apply(n, arguments);
                            };
                        }(t, n), e);
                }
                e._state = 1,
                e._value = n,
                c(e);
            } catch (r) {
                u(e, r);
            }
        }
        function u(e, n) {
            e._state = 2,
            e._value = n,
            c(e);
        }
        function c(e) {
            2 === e._state && 0 === e._deferreds.length && i._immediateFn(function() {
                e._handled || i._unhandledRejectionFn(e._value);
            });
            for (var n = 0, t = e._deferreds.length; n < t; n++)
                r(e, e._deferreds[n]);
            e._deferreds = null;
        }
        function l(e, n, t) {
            this.onFulfilled = "function" == typeof e ? e : null,
            this.onRejected = "function" == typeof n ? n : null,
            this.promise = t;
        }
        function s(e, n) {
            var t = !1;
            try {
                e(function(e) {
                    t || (t = !0, f(n, e));
                }, function(e) {
                    t || (t = !0, u(n, e));
                });
            } catch (o) {
                if (t)
                    return;
                t = !0,
                u(n, o);
            }
        }
        i.prototype["catch"] = function(e) {
            return this.then(null, e);
        },
        i.prototype.then = function(e, n) {
            var t = new this.constructor(o);
            return r(this, new l(e, n, t)), t;
        },
        i.prototype["finally"] = e,
        i.all = function(n) {
            return new i(function(r, i) {
                if (!a(n))
                    return i(new TypeError("Promise.all accepts an array"));
                var f = Array.prototype.slice.call(n);
                if (0 === f.length)
                    return r([]);
                var u = f.length;
                function c(n, e) {
                    try {
                        if (e && ("object" == typeof e || "function" == typeof e)) {
                            var t = e.then;
                            if ("function" == typeof t)
                                return void t.call(e, function(e) {
                                    c(n, e);
                                }, i);
                        }
                        f[n] = e,
                        0 == --u && r(f);
                    } catch (o) {
                        i(o);
                    }
                }
                for (var e = 0; e < f.length; e++)
                    c(e, f[e]);
            });
        },
        i.resolve = function(n) {
            return n && "object" == typeof n && n.constructor === i ? n : new i(function(e) {
                e(n);
            });
        },
        i.reject = function(t) {
            return new i(function(e, n) {
                n(t);
            });
        },
        i.race = function(r) {
            return new i(function(e, n) {
                if (!a(r))
                    return n(new TypeError("Promise.race accepts an array"));
                for (var t = 0, o = r.length; t < o; t++)
                    i.resolve(r[t]).then(e, n);
            });
        },
        i._immediateFn = "function" == typeof setImmediate ? function(e) {
            setImmediate(e);
        } : function(e) {
            n(e, 0);
        },
        i._unhandledRejectionFn = function(e) {
            void 0 !== console && console && console.warn("Possible Unhandled Promise Rejection:", e);
        };
        var t = function() {
            if ("undefined" != typeof self)
                return self;
            if ("undefined" != typeof window)
                return window;
            if ("undefined" != typeof global)
                return global;
            throw Error("unable to locate global object");
        }();
        "function" != typeof t.Promise ? t.Promise = i : t.Promise.prototype["finally"] || (t.Promise.prototype["finally"] = e);
    });
    "function" != typeof Object.assign && Object.defineProperty(Object, "assign", {
        value: function(e, t) {
            if (null == e)
                throw new TypeError("Cannot convert undefined or null to object");
            for (var n = Object(e), r = 1; r < arguments.length; r++) {
                var o = arguments[r];
                if (null != o)
                    for (var c in o)
                        Object.prototype.hasOwnProperty.call(o, c) && (n[c] = o[c]);
            }
            return n;
        },
        writable: !0,
        configurable: !0
    });
    [Element.prototype, CharacterData.prototype, DocumentType.prototype].forEach(function(e) {
        e.hasOwnProperty("remove") || Object.defineProperty(e, "remove", {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: function() {
                null !== this.parentNode && this.parentNode.removeChild(this);
            }
        });
    });
    class Text {
        constructor() {}
        lineAt(pos)
        {
            if (pos < 0 || pos > this.length)
                throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
            return this.lineInner(pos, false, 1, 0);
        }
        line(n)
        {
            if (n < 1 || n > this.lines)
                throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
            return this.lineInner(n, true, 1, 0);
        }
        replace(from, to, text)
        {
            let parts = [];
            this.decompose(0, from, parts, 2);
            if (text.length)
                text.decompose(0, text.length, parts, 1 | 2);
            this.decompose(to, this.length, parts, 1);
            return TextNode.from(parts, this.length - (to - from) + text.length);
        }
        append(other)
        {
            return this.replace(this.length, this.length, other);
        }
        slice(from, to=this.length)
        {
            let parts = [];
            this.decompose(from, to, parts, 0);
            return TextNode.from(parts, to - from);
        }
        eq(other)
        {
            if (other == this)
                return true;
            if (other.length != this.length || other.lines != this.lines)
                return false;
            let start = this.scanIdentical(other, 1),
                end = this.length - this.scanIdentical(other, -1);
            let a = new RawTextCursor(this),
                b = new RawTextCursor(other);
            for (let skip = start, pos = start; ;) {
                a.next(skip);
                b.next(skip);
                skip = 0;
                if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
                    return false;
                pos += a.value.length;
                if (a.done || pos >= end)
                    return true;
            }
        }
        iter(dir=1)
        {
            return new RawTextCursor(this, dir);
        }
        iterRange(from, to=this.length)
        {
            return new PartialTextCursor(this, from, to);
        }
        iterLines(from, to)
        {
            let inner;
            if (from == null) {
                inner = this.iter();
            } else {
                if (to == null)
                    to = this.lines + 1;
                let start = this.line(from).from;
                inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
            }
            return new LineCursor(inner);
        }
        toString()
        {
            return this.sliceString(0);
        }
        toJSON()
        {
            let lines = [];
            this.flatten(lines);
            return lines;
        }
        static of(text)
        {
            if (text.length == 0)
                throw new RangeError("A document must have at least one line");
            if (text.length == 1 && !text[0])
                return Text.empty;
            return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
        }
    }
    class TextLeaf extends Text {
        constructor(text, length=textLength(text))
        {
            super();
            this.text = text;
            this.length = length;
        }
        get lines()
        {
            return this.text.length;
        }
        get children()
        {
            return null;
        }
        lineInner(target, isLine, line, offset)
        {
            for (let i = 0; ; i++) {
                let string = this.text[i],
                    end = offset + string.length;
                if ((isLine ? line : end) >= target)
                    return new Line$1(offset, end, line, string);
                offset = end + 1;
                line++;
            }
        }
        decompose(from, to, target, open)
        {
            let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
            if (open & 1) {
                let prev = target.pop();
                let joined = appendText(text.text, prev.text.slice(), 0, text.length);
                if (joined.length <= 32) {
                    target.push(new TextLeaf(joined, prev.length + text.length));
                } else {
                    let mid = joined.length >> 1;
                    target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
                }
            } else {
                target.push(text);
            }
        }
        replace(from, to, text)
        {
            if (!(text instanceof TextLeaf))
                return super.replace(from, to, text);
            let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
            let newLen = this.length + text.length - (to - from);
            if (lines.length <= 32)
                return new TextLeaf(lines, newLen);
            return TextNode.from(TextLeaf.split(lines, []), newLen);
        }
        sliceString(from, to=this.length, lineSep="\n")
        {
            let result = "";
            for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
                let line = this.text[i],
                    end = pos + line.length;
                if (pos > from && i)
                    result += lineSep;
                if (from < end && to > pos)
                    result += line.slice(Math.max(0, from - pos), to - pos);
                pos = end + 1;
            }
            return result;
        }
        flatten(target)
        {
            for (let _i = 0, _this$text = this.text, _length = _this$text.length; _i < _length; _i++) {
                let line = _this$text[_i];
                target.push(line);
            }
        }
        scanIdentical()
        {
            return 0;
        }
        static split(text, target)
        {
            let part = [],
                len = -1;
            for (let _i2 = 0, _length2 = text.length; _i2 < _length2; _i2++) {
                let line = text[_i2];
                part.push(line);
                len += line.length + 1;
                if (part.length == 32) {
                    target.push(new TextLeaf(part, len));
                    part = [];
                    len = -1;
                }
            }
            if (len > -1)
                target.push(new TextLeaf(part, len));
            return target;
        }
    }
    class TextNode extends Text {
        constructor(children, length)
        {
            super();
            this.children = children;
            this.length = length;
            this.lines = 0;
            for (let _i3 = 0, _length3 = children.length; _i3 < _length3; _i3++) {
                let child = children[_i3];
                this.lines += child.lines;
            }
        }
        lineInner(target, isLine, line, offset)
        {
            for (let i = 0; ; i++) {
                let child = this.children[i],
                    end = offset + child.length,
                    endLine = line + child.lines - 1;
                if ((isLine ? endLine : end) >= target)
                    return child.lineInner(target, isLine, line, offset);
                offset = end + 1;
                line = endLine + 1;
            }
        }
        decompose(from, to, target, open)
        {
            for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
                let child = this.children[i],
                    end = pos + child.length;
                if (from <= end && to >= pos) {
                    let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
                    if (pos >= from && end <= to && !childOpen)
                        target.push(child);
                    else
                        child.decompose(from - pos, to - pos, target, childOpen);
                }
                pos = end + 1;
            }
        }
        replace(from, to, text)
        {
            if (text.lines < this.lines)
                for (let i = 0, pos = 0; i < this.children.length; i++) {
                    let child = this.children[i],
                        end = pos + child.length;
                    if (from >= pos && to <= end) {
                        let updated = child.replace(from - pos, to - pos, text);
                        let totalLines = this.lines - child.lines + updated.lines;
                        if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
                            let copy = this.children.slice();
                            copy[i] = updated;
                            return new TextNode(copy, this.length - (to - from) + text.length);
                        }
                        return super.replace(pos, end, updated);
                    }
                    pos = end + 1;
                }
            return super.replace(from, to, text);
        }
        sliceString(from, to=this.length, lineSep="\n")
        {
            let result = "";
            for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
                let child = this.children[i],
                    end = pos + child.length;
                if (pos > from && i)
                    result += lineSep;
                if (from < end && to > pos)
                    result += child.sliceString(from - pos, to - pos, lineSep);
                pos = end + 1;
            }
            return result;
        }
        flatten(target)
        {
            for (let _i4 = 0, _this$children = this.children, _length4 = _this$children.length; _i4 < _length4; _i4++) {
                let child = _this$children[_i4];
                child.flatten(target);
            }
        }
        scanIdentical(other, dir)
        {
            if (!(other instanceof TextNode))
                return 0;
            let length = 0;
            let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
            for (;; iA += dir, iB += dir) {
                if (iA == eA || iB == eB)
                    return length;
                let chA = this.children[iA],
                    chB = other.children[iB];
                if (chA != chB)
                    return length + chA.scanIdentical(chB, dir);
                length += chA.length + 1;
            }
        }
        static from(children, length=children.reduce((l, ch) => l + ch.length + 1, -1))
        {
            let lines = 0;
            for (let _i5 = 0, _length5 = children.length; _i5 < _length5; _i5++) {
                let ch = children[_i5];
                lines += ch.lines;
            }
            if (lines < 32) {
                let flat = [];
                for (let _i6 = 0, _length6 = children.length; _i6 < _length6; _i6++) {
                    let ch = children[_i6];
                    ch.flatten(flat);
                }
                return new TextLeaf(flat, length);
            }
            let chunk = Math.max(32, lines >> 5),
                maxChunk = chunk << 1,
                minChunk = chunk >> 1;
            let chunked = [],
                currentLines = 0,
                currentLen = -1,
                currentChunk = [];
            function add(child) {
                let last;
                if (child.lines > maxChunk && child instanceof TextNode) {
                    for (let _i7 = 0, _child$children = child.children, _length7 = _child$children.length; _i7 < _length7; _i7++) {
                        let node = _child$children[_i7];
                        add(node);
                    }
                } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
                    flush();
                    chunked.push(child);
                } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
                    currentLines += child.lines;
                    currentLen += child.length + 1;
                    currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
                } else {
                    if (currentLines + child.lines > chunk)
                        flush();
                    currentLines += child.lines;
                    currentLen += child.length + 1;
                    currentChunk.push(child);
                }
            }
            function flush() {
                if (currentLines == 0)
                    return;
                chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
                currentLen = -1;
                currentLines = currentChunk.length = 0;
            }
            for (let _i8 = 0, _length8 = children.length; _i8 < _length8; _i8++) {
                let child = children[_i8];
                add(child);
            }
            flush();
            return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
        }
    }
    Text.empty = new TextLeaf([""], 0);
    function textLength(text) {
        let length = -1;
        for (let _i9 = 0, _length9 = text.length; _i9 < _length9; _i9++) {
            let line = text[_i9];
            length += line.length + 1;
        }
        return length;
    }
    function appendText(text, target, from=0, to=1e9) {
        for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
            let line = text[i],
                end = pos + line.length;
            if (end >= from) {
                if (end > to)
                    line = line.slice(0, to - pos);
                if (pos < from)
                    line = line.slice(from - pos);
                if (first) {
                    target[target.length - 1] += line;
                    first = false;
                } else
                    target.push(line);
            }
            pos = end + 1;
        }
        return target;
    }
    function sliceText(text, from, to) {
        return appendText(text, [""], from, to);
    }
    class RawTextCursor {
        constructor(text, dir=1)
        {
            this.dir = dir;
            this.done = false;
            this.lineBreak = false;
            this.value = "";
            this.nodes = [text];
            this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
        }
        nextInner(skip, dir)
        {
            this.done = this.lineBreak = false;
            for (;;) {
                let last = this.nodes.length - 1;
                let top = this.nodes[last],
                    offsetValue = this.offsets[last],
                    offset = offsetValue >> 1;
                let size = top instanceof TextLeaf ? top.text.length : top.children.length;
                if (offset == (dir > 0 ? size : 0)) {
                    if (last == 0) {
                        this.done = true;
                        this.value = "";
                        return this;
                    }
                    if (dir > 0)
                        this.offsets[last - 1]++;
                    this.nodes.pop();
                    this.offsets.pop();
                } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
                    this.offsets[last] += dir;
                    if (skip == 0) {
                        this.lineBreak = true;
                        this.value = "\n";
                        return this;
                    }
                    skip--;
                } else if (top instanceof TextLeaf) {
                    let next = top.text[offset + (dir < 0 ? -1 : 0)];
                    this.offsets[last] += dir;
                    if (next.length > Math.max(0, skip)) {
                        this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                        return this;
                    }
                    skip -= next.length;
                } else {
                    let next = top.children[offset + (dir < 0 ? -1 : 0)];
                    if (skip > next.length) {
                        skip -= next.length;
                        this.offsets[last] += dir;
                    } else {
                        if (dir < 0)
                            this.offsets[last]--;
                        this.nodes.push(next);
                        this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
                    }
                }
            }
        }
        next(skip=0)
        {
            if (skip < 0) {
                this.nextInner(-skip, -this.dir);
                skip = this.value.length;
            }
            return this.nextInner(skip, this.dir);
        }
    }
    class PartialTextCursor {
        constructor(text, start, end)
        {
            this.value = "";
            this.done = false;
            this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
            this.pos = start > end ? text.length : 0;
            this.from = Math.min(start, end);
            this.to = Math.max(start, end);
        }
        nextInner(skip, dir)
        {
            if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
                this.value = "";
                this.done = true;
                return this;
            }
            skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
            let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
            if (skip > limit)
                skip = limit;
            limit -= skip;
            let {value} = this.cursor.next(skip);
            this.pos += (value.length + skip) * dir;
            this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
            this.done = !this.value;
            return this;
        }
        next(skip=0)
        {
            if (skip < 0)
                skip = Math.max(skip, this.from - this.pos);
            else if (skip > 0)
                skip = Math.min(skip, this.to - this.pos);
            return this.nextInner(skip, this.cursor.dir);
        }
        get lineBreak()
        {
            return this.cursor.lineBreak && this.value != "";
        }
    }
    class LineCursor {
        constructor(inner)
        {
            this.inner = inner;
            this.afterBreak = true;
            this.value = "";
            this.done = false;
        }
        next(skip=0)
        {
            let {done, lineBreak, value} = this.inner.next(skip);
            if (done) {
                this.done = true;
                this.value = "";
            } else if (lineBreak) {
                if (this.afterBreak) {
                    this.value = "";
                } else {
                    this.afterBreak = true;
                    this.next();
                }
            } else {
                this.value = value;
                this.afterBreak = false;
            }
            return this;
        }
        get lineBreak()
        {
            return false;
        }
    }
    if (typeof Symbol != "undefined") {
        Text.prototype[Symbol.iterator] = function() {
            return this.iter();
        };
        RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
            return this;
        };
    }
    class Line$1 {
        constructor(from, to, number, text)
        {
            this.from = from;
            this.to = to;
            this.number = number;
            this.text = text;
        }
        get length()
        {
            return this.to - this.from;
        }
    }
    let extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1);
    for (let i = 1; i < extend.length; i++)
        extend[i] += extend[i - 1];
    function isExtendingChar(code) {
        for (let i = 1; i < extend.length; i += 2)
            if (extend[i] > code)
                return extend[i - 1] <= code;
        return false;
    }
    function isRegionalIndicator(code) {
        return code >= 0x1F1E6 && code <= 0x1F1FF;
    }
    const ZWJ = 0x200d;
    function findClusterBreak(str, pos, forward=true, includeExtending=true) {
        return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
    }
    function nextClusterBreak(str, pos, includeExtending) {
        if (pos == str.length)
            return pos;
        if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
            pos--;
        let prev = codePointAt(str, pos);
        pos += codePointSize(prev);
        while (pos < str.length) {
            let next = codePointAt(str, pos);
            if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
                pos += codePointSize(next);
                prev = next;
            } else if (isRegionalIndicator(next)) {
                let countBefore = 0,
                    i = pos - 2;
                while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
                    countBefore++;
                    i -= 2;
                }
                if (countBefore % 2 == 0)
                    break;
                else
                    pos += 2;
            } else {
                break;
            }
        }
        return pos;
    }
    function prevClusterBreak(str, pos, includeExtending) {
        while (pos > 0) {
            let found = nextClusterBreak(str, pos - 2, includeExtending);
            if (found < pos)
                return found;
            pos--;
        }
        return 0;
    }
    function surrogateLow(ch) {
        return ch >= 0xDC00 && ch < 0xE000;
    }
    function surrogateHigh(ch) {
        return ch >= 0xD800 && ch < 0xDC00;
    }
    function codePointAt(str, pos) {
        let code0 = str.charCodeAt(pos);
        if (!surrogateHigh(code0) || pos + 1 == str.length)
            return code0;
        let code1 = str.charCodeAt(pos + 1);
        if (!surrogateLow(code1))
            return code0;
        return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;
    }
    function fromCodePoint(code) {
        if (code <= 0xffff)
            return String.fromCharCode(code);
        code -= 0x10000;
        return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
    }
    function codePointSize(code) {
        return code < 0x10000 ? 1 : 2;
    }
    const DefaultSplit = /\r\n?|\n/;
    var MapMode = function(MapMode) {
        MapMode[MapMode["Simple"] = 0] = "Simple";
        MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
        MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
        MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
        return MapMode;
    }(MapMode || (MapMode = {}));
    class ChangeDesc {
        constructor(sections)
        {
            this.sections = sections;
        }
        get length()
        {
            let result = 0;
            for (let i = 0; i < this.sections.length; i += 2)
                result += this.sections[i];
            return result;
        }
        get newLength()
        {
            let result = 0;
            for (let i = 0; i < this.sections.length; i += 2) {
                let ins = this.sections[i + 1];
                result += ins < 0 ? this.sections[i] : ins;
            }
            return result;
        }
        get empty()
        {
            return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
        }
        iterGaps(f)
        {
            for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
                let len = this.sections[i++],
                    ins = this.sections[i++];
                if (ins < 0) {
                    f(posA, posB, len);
                    posB += len;
                } else {
                    posB += ins;
                }
                posA += len;
            }
        }
        iterChangedRanges(f, individual=false)
        {
            iterChanges(this, f, individual);
        }
        get invertedDesc()
        {
            let sections = [];
            for (let i = 0; i < this.sections.length;) {
                let len = this.sections[i++],
                    ins = this.sections[i++];
                if (ins < 0)
                    sections.push(len, ins);
                else
                    sections.push(ins, len);
            }
            return new ChangeDesc(sections);
        }
        composeDesc(other)
        {
            return this.empty ? other : other.empty ? this : composeSets(this, other);
        }
        mapDesc(other, before=false)
        {
            return other.empty ? this : mapSet(this, other, before);
        }
        mapPos(pos, assoc=-1, mode=MapMode.Simple)
        {
            let posA = 0,
                posB = 0;
            for (let i = 0; i < this.sections.length;) {
                let len = this.sections[i++],
                    ins = this.sections[i++],
                    endA = posA + len;
                if (ins < 0) {
                    if (endA > pos)
                        return posB + (pos - posA);
                    posB += len;
                } else {
                    if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
                        return null;
                    if (endA > pos || endA == pos && assoc < 0 && !len)
                        return pos == posA || assoc < 0 ? posB : posB + ins;
                    posB += ins;
                }
                posA = endA;
            }
            if (pos > posA)
                throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
            return posB;
        }
        touchesRange(from, to=from)
        {
            for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
                let len = this.sections[i++],
                    ins = this.sections[i++],
                    end = pos + len;
                if (ins >= 0 && pos <= to && end >= from)
                    return pos < from && end > to ? "cover" : true;
                pos = end;
            }
            return false;
        }
        toString()
        {
            let result = "";
            for (let i = 0; i < this.sections.length;) {
                let len = this.sections[i++],
                    ins = this.sections[i++];
                result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
            }
            return result;
        }
        toJSON()
        {
            return this.sections;
        }
        static fromJSON(json)
        {
            if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number"))
                throw new RangeError("Invalid JSON representation of ChangeDesc");
            return new ChangeDesc(json);
        }
        static create(sections)
        {
            return new ChangeDesc(sections);
        }
    }
    class ChangeSet extends ChangeDesc {
        constructor(sections, inserted)
        {
            super(sections);
            this.inserted = inserted;
        }
        apply(doc)
        {
            if (this.length != doc.length)
                throw new RangeError("Applying change set to a document with the wrong length");
            iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
            return doc;
        }
        mapDesc(other, before=false)
        {
            return mapSet(this, other, before, true);
        }
        invert(doc)
        {
            let sections = this.sections.slice(),
                inserted = [];
            for (let i = 0, pos = 0; i < sections.length; i += 2) {
                let len = sections[i],
                    ins = sections[i + 1];
                if (ins >= 0) {
                    sections[i] = ins;
                    sections[i + 1] = len;
                    let index = i >> 1;
                    while (inserted.length < index)
                        inserted.push(Text.empty);
                    inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
                }
                pos += len;
            }
            return new ChangeSet(sections, inserted);
        }
        compose(other)
        {
            return this.empty ? other : other.empty ? this : composeSets(this, other, true);
        }
        map(other, before=false)
        {
            return other.empty ? this : mapSet(this, other, before, true);
        }
        iterChanges(f, individual=false)
        {
            iterChanges(this, f, individual);
        }
        get desc()
        {
            return ChangeDesc.create(this.sections);
        }
        filter(ranges)
        {
            let resultSections = [],
                resultInserted = [],
                filteredSections = [];
            let iter = new SectionIter(this);
            done:
            for (let i = 0, pos = 0; ;) {
                let next = i == ranges.length ? 1e9 : ranges[i++];
                while (pos < next || pos == next && iter.len == 0) {
                    if (iter.done)
                        break done;
                    let len = Math.min(iter.len, next - pos);
                    addSection(filteredSections, len, -1);
                    let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                    addSection(resultSections, len, ins);
                    if (ins > 0)
                        addInsert(resultInserted, resultSections, iter.text);
                    iter.forward(len);
                    pos += len;
                }
                let end = ranges[i++];
                while (pos < end) {
                    if (iter.done)
                        break done;
                    let len = Math.min(iter.len, end - pos);
                    addSection(resultSections, len, -1);
                    addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                    iter.forward(len);
                    pos += len;
                }
            }
            return {
                changes: new ChangeSet(resultSections, resultInserted),
                filtered: ChangeDesc.create(filteredSections)
            };
        }
        toJSON()
        {
            let parts = [];
            for (let i = 0; i < this.sections.length; i += 2) {
                let len = this.sections[i],
                    ins = this.sections[i + 1];
                if (ins < 0)
                    parts.push(len);
                else if (ins == 0)
                    parts.push([len]);
                else
                    parts.push([len].concat(this.inserted[i >> 1].toJSON()));
            }
            return parts;
        }
        static of(changes, length, lineSep)
        {
            let sections = [],
                inserted = [],
                pos = 0;
            let total = null;
            function flush(force=false) {
                if (!force && !sections.length)
                    return;
                if (pos < length)
                    addSection(sections, length - pos, -1);
                let set = new ChangeSet(sections, inserted);
                total = total ? total.compose(set.map(total)) : set;
                sections = [];
                inserted = [];
                pos = 0;
            }
            function process(spec) {
                if (Array.isArray(spec)) {
                    for (let _i10 = 0, _length10 = spec.length; _i10 < _length10; _i10++) {
                        let sub = spec[_i10];
                        process(sub);
                    }
                } else if (spec instanceof ChangeSet) {
                    if (spec.length != length)
                        throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
                    flush();
                    total = total ? total.compose(spec.map(total)) : spec;
                } else {
                    let {from, to=from, insert} = spec;
                    if (from > to || from < 0 || to > length)
                        throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
                    let insText = !insert ? Text.empty : typeof insert == "string" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;
                    let insLen = insText.length;
                    if (from == to && insLen == 0)
                        return;
                    if (from < pos)
                        flush();
                    if (from > pos)
                        addSection(sections, from - pos, -1);
                    addSection(sections, to - from, insLen);
                    addInsert(inserted, sections, insText);
                    pos = to;
                }
            }
            process(changes);
            flush(!total);
            return total;
        }
        static empty(length)
        {
            return new ChangeSet(length ? [length, -1] : [], []);
        }
        static fromJSON(json)
        {
            if (!Array.isArray(json))
                throw new RangeError("Invalid JSON representation of ChangeSet");
            let sections = [],
                inserted = [];
            for (let i = 0; i < json.length; i++) {
                let part = json[i];
                if (typeof part == "number") {
                    sections.push(part, -1);
                } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
                    throw new RangeError("Invalid JSON representation of ChangeSet");
                } else if (part.length == 1) {
                    sections.push(part[0], 0);
                } else {
                    while (inserted.length < i)
                        inserted.push(Text.empty);
                    inserted[i] = Text.of(part.slice(1));
                    sections.push(part[0], inserted[i].length);
                }
            }
            return new ChangeSet(sections, inserted);
        }
        static createSet(sections, inserted)
        {
            return new ChangeSet(sections, inserted);
        }
    }
    function addSection(sections, len, ins, forceJoin=false) {
        if (len == 0 && ins <= 0)
            return;
        let last = sections.length - 2;
        if (last >= 0 && ins <= 0 && ins == sections[last + 1])
            sections[last] += len;
        else if (len == 0 && sections[last] == 0)
            sections[last + 1] += ins;
        else if (forceJoin) {
            sections[last] += len;
            sections[last + 1] += ins;
        } else
            sections.push(len, ins);
    }
    function addInsert(values, sections, value) {
        if (value.length == 0)
            return;
        let index = sections.length - 2 >> 1;
        if (index < values.length) {
            values[values.length - 1] = values[values.length - 1].append(value);
        } else {
            while (values.length < index)
                values.push(Text.empty);
            values.push(value);
        }
    }
    function iterChanges(desc, f, individual) {
        let inserted = desc.inserted;
        for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
            let len = desc.sections[i++],
                ins = desc.sections[i++];
            if (ins < 0) {
                posA += len;
                posB += len;
            } else {
                let endA = posA,
                    endB = posB,
                    text = Text.empty;
                for (;;) {
                    endA += len;
                    endB += ins;
                    if (ins && inserted)
                        text = text.append(inserted[i - 2 >> 1]);
                    if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                        break;
                    len = desc.sections[i++];
                    ins = desc.sections[i++];
                }
                f(posA, endA, posB, endB, text);
                posA = endA;
                posB = endB;
            }
        }
    }
    function mapSet(setA, setB, before, mkSet=false) {
        let sections = [],
            insert = mkSet ? [] : null;
        let a = new SectionIter(setA),
            b = new SectionIter(setB);
        for (let inserted = -1; ;) {
            if (a.ins == -1 && b.ins == -1) {
                let len = Math.min(a.len, b.len);
                addSection(sections, len, -1);
                a.forward(len);
                b.forward(len);
            } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
                let len = b.len;
                addSection(sections, b.ins, -1);
                while (len) {
                    let piece = Math.min(a.len, len);
                    if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
                        addSection(sections, 0, a.ins);
                        if (insert)
                            addInsert(insert, sections, a.text);
                        inserted = a.i;
                    }
                    a.forward(piece);
                    len -= piece;
                }
                b.next();
            } else if (a.ins >= 0) {
                let len = 0,
                    left = a.len;
                while (left) {
                    if (b.ins == -1) {
                        let piece = Math.min(left, b.len);
                        len += piece;
                        left -= piece;
                        b.forward(piece);
                    } else if (b.ins == 0 && b.len < left) {
                        left -= b.len;
                        b.next();
                    } else {
                        break;
                    }
                }
                addSection(sections, len, inserted < a.i ? a.ins : 0);
                if (insert && inserted < a.i)
                    addInsert(insert, sections, a.text);
                inserted = a.i;
                a.forward(a.len - left);
            } else if (a.done && b.done) {
                return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
            } else {
                throw new Error("Mismatched change set lengths");
            }
        }
    }
    function composeSets(setA, setB, mkSet=false) {
        let sections = [];
        let insert = mkSet ? [] : null;
        let a = new SectionIter(setA),
            b = new SectionIter(setB);
        for (let open = false; ;) {
            if (a.done && b.done) {
                return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
            } else if (a.ins == 0) {
                addSection(sections, a.len, 0, open);
                a.next();
            } else if (b.len == 0 && !b.done) {
                addSection(sections, 0, b.ins, open);
                if (insert)
                    addInsert(insert, sections, b.text);
                b.next();
            } else if (a.done || b.done) {
                throw new Error("Mismatched change set lengths");
            } else {
                let len = Math.min(a.len2, b.len),
                    sectionLen = sections.length;
                if (a.ins == -1) {
                    let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
                    addSection(sections, len, insB, open);
                    if (insert && insB)
                        addInsert(insert, sections, b.text);
                } else if (b.ins == -1) {
                    addSection(sections, a.off ? 0 : a.len, len, open);
                    if (insert)
                        addInsert(insert, sections, a.textBit(len));
                } else {
                    addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
                    if (insert && !b.off)
                        addInsert(insert, sections, b.text);
                }
                open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
                a.forward2(len);
                b.forward(len);
            }
        }
    }
    class SectionIter {
        constructor(set)
        {
            this.set = set;
            this.i = 0;
            this.next();
        }
        next()
        {
            let {sections} = this.set;
            if (this.i < sections.length) {
                this.len = sections[this.i++];
                this.ins = sections[this.i++];
            } else {
                this.len = 0;
                this.ins = -2;
            }
            this.off = 0;
        }
        get done()
        {
            return this.ins == -2;
        }
        get len2()
        {
            return this.ins < 0 ? this.len : this.ins;
        }
        get text()
        {
            let {inserted} = this.set,
                index = this.i - 2 >> 1;
            return index >= inserted.length ? Text.empty : inserted[index];
        }
        textBit(len)
        {
            let {inserted} = this.set,
                index = this.i - 2 >> 1;
            return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
        }
        forward(len)
        {
            if (len == this.len)
                this.next();
            else {
                this.len -= len;
                this.off += len;
            }
        }
        forward2(len)
        {
            if (this.ins == -1)
                this.forward(len);
            else if (len == this.ins)
                this.next();
            else {
                this.ins -= len;
                this.off += len;
            }
        }
    }
    class SelectionRange {
        constructor(from, to, flags)
        {
            this.from = from;
            this.to = to;
            this.flags = flags;
        }
        get anchor()
        {
            return this.flags & 16 ? this.to : this.from;
        }
        get head()
        {
            return this.flags & 16 ? this.from : this.to;
        }
        get empty()
        {
            return this.from == this.to;
        }
        get assoc()
        {
            return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
        }
        get bidiLevel()
        {
            let level = this.flags & 3;
            return level == 3 ? null : level;
        }
        get goalColumn()
        {
            let value = this.flags >> 5;
            return value == 33554431 ? undefined : value;
        }
        map(change, assoc=-1)
        {
            let from,
                to;
            if (this.empty) {
                from = to = change.mapPos(this.from, assoc);
            } else {
                from = change.mapPos(this.from, 1);
                to = change.mapPos(this.to, -1);
            }
            return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
        }
        extend(from, to=from)
        {
            if (from <= this.anchor && to >= this.anchor)
                return EditorSelection.range(from, to);
            let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
            return EditorSelection.range(this.anchor, head);
        }
        eq(other)
        {
            return this.anchor == other.anchor && this.head == other.head;
        }
        toJSON()
        {
            return {
                anchor: this.anchor,
                head: this.head
            };
        }
        static fromJSON(json)
        {
            if (!json || typeof json.anchor != "number" || typeof json.head != "number")
                throw new RangeError("Invalid JSON representation for SelectionRange");
            return EditorSelection.range(json.anchor, json.head);
        }
        static create(from, to, flags)
        {
            return new SelectionRange(from, to, flags);
        }
    }
    class EditorSelection {
        constructor(ranges, mainIndex)
        {
            this.ranges = ranges;
            this.mainIndex = mainIndex;
        }
        map(change, assoc=-1)
        {
            if (change.empty)
                return this;
            return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
        }
        eq(other)
        {
            if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
                return false;
            for (let i = 0; i < this.ranges.length; i++)
                if (!this.ranges[i].eq(other.ranges[i]))
                    return false;
            return true;
        }
        get main()
        {
            return this.ranges[this.mainIndex];
        }
        asSingle()
        {
            return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
        }
        addRange(range, main=true)
        {
            return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
        }
        replaceRange(range, which=this.mainIndex)
        {
            let ranges = this.ranges.slice();
            ranges[which] = range;
            return EditorSelection.create(ranges, this.mainIndex);
        }
        toJSON()
        {
            return {
                ranges: this.ranges.map(r => r.toJSON()),
                main: this.mainIndex
            };
        }
        static fromJSON(json)
        {
            if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
                throw new RangeError("Invalid JSON representation for EditorSelection");
            return new EditorSelection(json.ranges.map(r => SelectionRange.fromJSON(r)), json.main);
        }
        static single(anchor, head=anchor)
        {
            return new EditorSelection([EditorSelection.range(anchor, head)], 0);
        }
        static create(ranges, mainIndex=0)
        {
            if (ranges.length == 0)
                throw new RangeError("A selection needs at least one range");
            for (let pos = 0, i = 0; i < ranges.length; i++) {
                let range = ranges[i];
                if (range.empty ? range.from <= pos : range.from < pos)
                    return EditorSelection.normalized(ranges.slice(), mainIndex);
                pos = range.to;
            }
            return new EditorSelection(ranges, mainIndex);
        }
        static cursor(pos, assoc=0, bidiLevel, goalColumn)
        {
            return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
        }
        static range(anchor, head, goalColumn, bidiLevel)
        {
            let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5 | (bidiLevel == null ? 3 : Math.min(2, bidiLevel));
            return head < anchor ? SelectionRange.create(head, anchor, 16 | 8 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 4 : 0) | flags);
        }
        static normalized(ranges, mainIndex=0)
        {
            let main = ranges[mainIndex];
            ranges.sort((a, b) => a.from - b.from);
            mainIndex = ranges.indexOf(main);
            for (let i = 1; i < ranges.length; i++) {
                let range = ranges[i],
                    prev = ranges[i - 1];
                if (range.empty ? range.from <= prev.to : range.from < prev.to) {
                    let from = prev.from,
                        to = Math.max(range.to, prev.to);
                    if (i <= mainIndex)
                        mainIndex--;
                    ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
                }
            }
            return new EditorSelection(ranges, mainIndex);
        }
    }
    function checkSelection(selection, docLength) {
        for (let _i11 = 0, _selection$ranges = selection.ranges, _length11 = _selection$ranges.length; _i11 < _length11; _i11++) {
            let range = _selection$ranges[_i11];
            if (range.to > docLength)
                throw new RangeError("Selection points outside of document");
        }
    }
    let nextID = 0;
    class Facet {
        constructor(combine, compareInput, compare, isStatic, enables)
        {
            this.combine = combine;
            this.compareInput = compareInput;
            this.compare = compare;
            this.isStatic = isStatic;
            this.id = nextID++;
            this.default = combine([]);
            this.extensions = typeof enables == "function" ? enables(this) : enables;
        }
        static define(config={})
        {
            return new Facet(config.combine || (a => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray$1 : (a, b) => a === b), !!config.static, config.enables);
        }
        of(value)
        {
            return new FacetProvider([], this, 0, value);
        }
        compute(deps, get)
        {
            if (this.isStatic)
                throw new Error("Can't compute a static facet");
            return new FacetProvider(deps, this, 1, get);
        }
        computeN(deps, get)
        {
            if (this.isStatic)
                throw new Error("Can't compute a static facet");
            return new FacetProvider(deps, this, 2, get);
        }
        from(field, get)
        {
            if (!get)
                get = x => x;
            return this.compute([field], state => get(state.field(field)));
        }
    }
    function sameArray$1(a, b) {
        return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
    }
    class FacetProvider {
        constructor(dependencies, facet, type, value)
        {
            this.dependencies = dependencies;
            this.facet = facet;
            this.type = type;
            this.value = value;
            this.id = nextID++;
        }
        dynamicSlot(addresses)
        {
            var _a;
            let getter = this.value;
            let compare = this.facet.compareInput;
            let id = this.id,
                idx = addresses[id] >> 1,
                multi = this.type == 2;
            let depDoc = false,
                depSel = false,
                depAddrs = [];
            for (let _i12 = 0, _this$dependencies = this.dependencies, _length12 = _this$dependencies.length; _i12 < _length12; _i12++) {
                let dep = _this$dependencies[_i12];
                if (dep == "doc")
                    depDoc = true;
                else if (dep == "selection")
                    depSel = true;
                else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
                    depAddrs.push(addresses[dep.id]);
            }
            return {
                create(state) {
                    state.values[idx] = getter(state);
                    return 1;
                },
                update(state, tr) {
                    if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
                        let newVal = getter(state);
                        if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {
                            state.values[idx] = newVal;
                            return 1;
                        }
                    }
                    return 0;
                },
                reconfigure: (state, oldState) => {
                    let newVal,
                        oldAddr = oldState.config.address[id];
                    if (oldAddr != null) {
                        let oldVal = getAddr(oldState, oldAddr);
                        if (this.dependencies.every(dep => {
                            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
                        }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {
                            state.values[idx] = oldVal;
                            return 0;
                        }
                    } else {
                        newVal = getter(state);
                    }
                    state.values[idx] = newVal;
                    return 1;
                }
            };
        }
    }
    function compareArray(a, b, compare) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++)
            if (!compare(a[i], b[i]))
                return false;
        return true;
    }
    function ensureAll(state, addrs) {
        let changed = false;
        for (let _i13 = 0, _length13 = addrs.length; _i13 < _length13; _i13++) {
            let addr = addrs[_i13];
            if (ensureAddr(state, addr) & 1)
                changed = true;
        }
        return changed;
    }
    function dynamicFacetSlot(addresses, facet, providers) {
        let providerAddrs = providers.map(p => addresses[p.id]);
        let providerTypes = providers.map(p => p.type);
        let dynamic = providerAddrs.filter(p => !(p & 1));
        let idx = addresses[facet.id] >> 1;
        function get(state) {
            let values = [];
            for (let i = 0; i < providerAddrs.length; i++) {
                let value = getAddr(state, providerAddrs[i]);
                if (providerTypes[i] == 2)
                    for (let _i14 = 0, _length14 = value.length; _i14 < _length14; _i14++) {
                        let val = value[_i14];
                        values.push(val);
                    }
                else
                    values.push(value);
            }
            return facet.combine(values);
        }
        return {
            create(state) {
                for (let _i15 = 0, _length15 = providerAddrs.length; _i15 < _length15; _i15++) {
                    let addr = providerAddrs[_i15];
                    ensureAddr(state, addr);
                }
                state.values[idx] = get(state);
                return 1;
            },
            update(state, tr) {
                if (!ensureAll(state, dynamic))
                    return 0;
                let value = get(state);
                if (facet.compare(value, state.values[idx]))
                    return 0;
                state.values[idx] = value;
                return 1;
            },
            reconfigure(state, oldState) {
                let depChanged = ensureAll(state, providerAddrs);
                let oldProviders = oldState.config.facets[facet.id],
                    oldValue = oldState.facet(facet);
                if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
                    state.values[idx] = oldValue;
                    return 0;
                }
                let value = get(state);
                if (facet.compare(value, oldValue)) {
                    state.values[idx] = oldValue;
                    return 0;
                }
                state.values[idx] = value;
                return 1;
            }
        };
    }
    const initField = Facet.define({
        static: true
    });
    class StateField {
        constructor(id, createF, updateF, compareF, spec)
        {
            this.id = id;
            this.createF = createF;
            this.updateF = updateF;
            this.compareF = compareF;
            this.spec = spec;
            this.provides = undefined;
        }
        static define(config)
        {
            let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
            if (config.provide)
                field.provides = config.provide(field);
            return field;
        }
        create(state)
        {
            let init = state.facet(initField).find(i => i.field == this);
            return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
        }
        slot(addresses)
        {
            let idx = addresses[this.id] >> 1;
            return {
                create: state => {
                    state.values[idx] = this.create(state);
                    return 1;
                },
                update: (state, tr) => {
                    let oldVal = state.values[idx];
                    let value = this.updateF(oldVal, tr);
                    if (this.compareF(oldVal, value))
                        return 0;
                    state.values[idx] = value;
                    return 1;
                },
                reconfigure: (state, oldState) => {
                    if (oldState.config.address[this.id] != null) {
                        state.values[idx] = oldState.field(this);
                        return 0;
                    }
                    state.values[idx] = this.create(state);
                    return 1;
                }
            };
        }
        init(create)
        {
            return [this, initField.of({
                field: this,
                create
            })];
        }
        get extension()
        {
            return this;
        }
    }
    const Prec_ = {
        lowest: 4,
        low: 3,
        default: 2,
        high: 1,
        highest: 0
    };
    function prec(value) {
        return ext => new PrecExtension(ext, value);
    }
    const Prec = {
        highest: prec(Prec_.highest),
        high: prec(Prec_.high),
        default: prec(Prec_.default),
        low: prec(Prec_.low),
        lowest: prec(Prec_.lowest)
    };
    class PrecExtension {
        constructor(inner, prec)
        {
            this.inner = inner;
            this.prec = prec;
        }
    }
    class Compartment {
        of(ext)
        {
            return new CompartmentInstance(this, ext);
        }
        reconfigure(content)
        {
            return Compartment.reconfigure.of({
                compartment: this,
                extension: content
            });
        }
        get(state)
        {
            return state.config.compartments.get(this);
        }
    }
    class CompartmentInstance {
        constructor(compartment, inner)
        {
            this.compartment = compartment;
            this.inner = inner;
        }
    }
    class Configuration {
        constructor(base, compartments, dynamicSlots, address, staticValues, facets)
        {
            this.base = base;
            this.compartments = compartments;
            this.dynamicSlots = dynamicSlots;
            this.address = address;
            this.staticValues = staticValues;
            this.facets = facets;
            this.statusTemplate = [];
            while (this.statusTemplate.length < dynamicSlots.length)
                this.statusTemplate.push(0);
        }
        staticFacet(facet)
        {
            let addr = this.address[facet.id];
            return addr == null ? facet.default : this.staticValues[addr >> 1];
        }
        static resolve(base, compartments, oldState)
        {
            let fields = [];
            let facets = Object.create(null);
            let newCompartments = new Map();
            for (let _i16 = 0, _flatten = flatten(base, compartments, newCompartments), _length16 = _flatten.length; _i16 < _length16; _i16++) {
                let ext = _flatten[_i16];
                if (ext instanceof StateField)
                    fields.push(ext);
                else
                    (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
            }
            let address = Object.create(null);
            let staticValues = [];
            let dynamicSlots = [];
            for (let _i17 = 0, _length17 = fields.length; _i17 < _length17; _i17++) {
                let field = fields[_i17];
                address[field.id] = dynamicSlots.length << 1;
                dynamicSlots.push(a => field.slot(a));
            }
            let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
            for (let id in facets) {
                let providers = facets[id],
                    facet = providers[0].facet;
                let oldProviders = oldFacets && oldFacets[id] || [];
                if (providers.every(p => p.type == 0)) {
                    address[facet.id] = staticValues.length << 1 | 1;
                    if (sameArray$1(oldProviders, providers)) {
                        staticValues.push(oldState.facet(facet));
                    } else {
                        let value = facet.combine(providers.map(p => p.value));
                        staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
                    }
                } else {
                    for (let _i18 = 0, _length18 = providers.length; _i18 < _length18; _i18++) {
                        let p = providers[_i18];
                        if (p.type == 0) {
                            address[p.id] = staticValues.length << 1 | 1;
                            staticValues.push(p.value);
                        } else {
                            address[p.id] = dynamicSlots.length << 1;
                            dynamicSlots.push(a => p.dynamicSlot(a));
                        }
                    }
                    address[facet.id] = dynamicSlots.length << 1;
                    dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
                }
            }
            let dynamic = dynamicSlots.map(f => f(address));
            return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
        }
    }
    function flatten(extension, compartments, newCompartments) {
        let result = [[], [], [], [], []];
        let seen = new Map();
        function inner(ext, prec) {
            let known = seen.get(ext);
            if (known != null) {
                if (known <= prec)
                    return;
                let found = result[known].indexOf(ext);
                if (found > -1)
                    result[known].splice(found, 1);
                if (ext instanceof CompartmentInstance)
                    newCompartments.delete(ext.compartment);
            }
            seen.set(ext, prec);
            if (Array.isArray(ext)) {
                for (let _i19 = 0, _length19 = ext.length; _i19 < _length19; _i19++) {
                    let e = ext[_i19];
                    inner(e, prec);
                }
            } else if (ext instanceof CompartmentInstance) {
                if (newCompartments.has(ext.compartment))
                    throw new RangeError(`Duplicate use of compartment in extensions`);
                let content = compartments.get(ext.compartment) || ext.inner;
                newCompartments.set(ext.compartment, content);
                inner(content, prec);
            } else if (ext instanceof PrecExtension) {
                inner(ext.inner, ext.prec);
            } else if (ext instanceof StateField) {
                result[prec].push(ext);
                if (ext.provides)
                    inner(ext.provides, prec);
            } else if (ext instanceof FacetProvider) {
                result[prec].push(ext);
                if (ext.facet.extensions)
                    inner(ext.facet.extensions, Prec_.default);
            } else {
                let content = ext.extension;
                if (!content)
                    throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
                inner(content, prec);
            }
        }
        inner(extension, Prec_.default);
        return result.reduce((a, b) => a.concat(b));
    }
    function ensureAddr(state, addr) {
        if (addr & 1)
            return 2;
        let idx = addr >> 1;
        let status = state.status[idx];
        if (status == 4)
            throw new Error("Cyclic dependency between fields and/or facets");
        if (status & 2)
            return status;
        state.status[idx] = 4;
        let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
        return state.status[idx] = 2 | changed;
    }
    function getAddr(state, addr) {
        return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
    }
    const languageData = Facet.define();
    const allowMultipleSelections = Facet.define({
        combine: values => values.some(v => v),
        static: true
    });
    const lineSeparator = Facet.define({
        combine: values => values.length ? values[0] : undefined,
        static: true
    });
    const changeFilter = Facet.define();
    const transactionFilter = Facet.define();
    const transactionExtender = Facet.define();
    const readOnly = Facet.define({
        combine: values => values.length ? values[0] : false
    });
    class Annotation {
        constructor(type, value)
        {
            this.type = type;
            this.value = value;
        }
        static define()
        {
            return new AnnotationType();
        }
    }
    class AnnotationType {
        of(value)
        {
            return new Annotation(this, value);
        }
    }
    class StateEffectType {
        constructor(map)
        {
            this.map = map;
        }
        of(value)
        {
            return new StateEffect(this, value);
        }
    }
    class StateEffect {
        constructor(type, value)
        {
            this.type = type;
            this.value = value;
        }
        map(mapping)
        {
            let mapped = this.type.map(this.value, mapping);
            return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
        }
        is(type)
        {
            return this.type == type;
        }
        static define(spec={})
        {
            return new StateEffectType(spec.map || (v => v));
        }
        static mapEffects(effects, mapping)
        {
            if (!effects.length)
                return effects;
            let result = [];
            for (let _i20 = 0, _length20 = effects.length; _i20 < _length20; _i20++) {
                let effect = effects[_i20];
                let mapped = effect.map(mapping);
                if (mapped)
                    result.push(mapped);
            }
            return result;
        }
    }
    StateEffect.reconfigure = StateEffect.define();
    StateEffect.appendConfig = StateEffect.define();
    class Transaction {
        constructor(startState, changes, selection, effects, annotations, scrollIntoView)
        {
            this.startState = startState;
            this.changes = changes;
            this.selection = selection;
            this.effects = effects;
            this.annotations = annotations;
            this.scrollIntoView = scrollIntoView;
            this._doc = null;
            this._state = null;
            if (selection)
                checkSelection(selection, changes.newLength);
            if (!annotations.some(a => a.type == Transaction.time))
                this.annotations = annotations.concat(Transaction.time.of(Date.now()));
        }
        static create(startState, changes, selection, effects, annotations, scrollIntoView)
        {
            return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
        }
        get newDoc()
        {
            return this._doc || (this._doc = this.changes.apply(this.startState.doc));
        }
        get newSelection()
        {
            return this.selection || this.startState.selection.map(this.changes);
        }
        get state()
        {
            if (!this._state)
                this.startState.applyTransaction(this);
            return this._state;
        }
        annotation(type)
        {
            for (let _i21 = 0, _this$annotations = this.annotations, _length21 = _this$annotations.length; _i21 < _length21; _i21++) {
                let ann = _this$annotations[_i21];
                if (ann.type == type)
                    return ann.value;
            }
            return undefined;
        }
        get docChanged()
        {
            return !this.changes.empty;
        }
        get reconfigured()
        {
            return this.startState.config != this.state.config;
        }
        isUserEvent(event)
        {
            let e = this.annotation(Transaction.userEvent);
            return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
        }
    }
    Transaction.time = Annotation.define();
    Transaction.userEvent = Annotation.define();
    Transaction.addToHistory = Annotation.define();
    Transaction.remote = Annotation.define();
    function joinRanges(a, b) {
        let result = [];
        for (let iA = 0, iB = 0; ;) {
            let from,
                to;
            if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
                from = a[iA++];
                to = a[iA++];
            } else if (iB < b.length) {
                from = b[iB++];
                to = b[iB++];
            } else
                return result;
            if (!result.length || result[result.length - 1] < from)
                result.push(from, to);
            else if (result[result.length - 1] < to)
                result[result.length - 1] = to;
        }
    }
    function mergeTransaction(a, b, sequential) {
        var _a;
        let mapForA,
            mapForB,
            changes;
        if (sequential) {
            mapForA = b.changes;
            mapForB = ChangeSet.empty(b.changes.length);
            changes = a.changes.compose(b.changes);
        } else {
            mapForA = b.changes.map(a.changes);
            mapForB = a.changes.mapDesc(b.changes, true);
            changes = a.changes.compose(mapForA);
        }
        return {
            changes,
            selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
            effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
            annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
            scrollIntoView: a.scrollIntoView || b.scrollIntoView
        };
    }
    function resolveTransactionInner(state, spec, docSize) {
        let sel = spec.selection,
            annotations = asArray$1(spec.annotations);
        if (spec.userEvent)
            annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
        return {
            changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
            selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
            effects: asArray$1(spec.effects),
            annotations,
            scrollIntoView: !!spec.scrollIntoView
        };
    }
    function resolveTransaction(state, specs, filter) {
        let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
        if (specs.length && specs[0].filter === false)
            filter = false;
        for (let i = 1; i < specs.length; i++) {
            if (specs[i].filter === false)
                filter = false;
            let seq = !!specs[i].sequential;
            s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
        }
        let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
        return extendTransaction(filter ? filterTransaction(tr) : tr);
    }
    function filterTransaction(tr) {
        let state = tr.startState;
        let result = true;
        for (let _i22 = 0, _state$facet = state.facet(changeFilter), _length22 = _state$facet.length; _i22 < _length22; _i22++) {
            let filter = _state$facet[_i22];
            let value = filter(tr);
            if (value === false) {
                result = false;
                break;
            }
            if (Array.isArray(value))
                result = result === true ? value : joinRanges(result, value);
        }
        if (result !== true) {
            let changes,
                back;
            if (result === false) {
                back = tr.changes.invertedDesc;
                changes = ChangeSet.empty(state.doc.length);
            } else {
                let filtered = tr.changes.filter(result);
                changes = filtered.changes;
                back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
            }
            tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
        }
        let filters = state.facet(transactionFilter);
        for (let i = filters.length - 1; i >= 0; i--) {
            let filtered = filters[i](tr);
            if (filtered instanceof Transaction)
                tr = filtered;
            else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
                tr = filtered[0];
            else
                tr = resolveTransaction(state, asArray$1(filtered), false);
        }
        return tr;
    }
    function extendTransaction(tr) {
        let state = tr.startState,
            extenders = state.facet(transactionExtender),
            spec = tr;
        for (let i = extenders.length - 1; i >= 0; i--) {
            let extension = extenders[i](tr);
            if (extension && Object.keys(extension).length)
                spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
        }
        return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
    }
    const none$3 = [];
    function asArray$1(value) {
        return value == null ? none$3 : Array.isArray(value) ? value : [value];
    }
    var CharCategory = function(CharCategory) {
        CharCategory[CharCategory["Word"] = 0] = "Word";
        CharCategory[CharCategory["Space"] = 1] = "Space";
        CharCategory[CharCategory["Other"] = 2] = "Other";
        return CharCategory;
    }(CharCategory || (CharCategory = {}));
    const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    let wordChar$1;
    try {
        wordChar$1 = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
    } catch (_) {}
    function hasWordChar(str) {
        if (wordChar$1)
            return wordChar$1.test(str);
        for (let i = 0; i < str.length; i++) {
            let ch = str[i];
            if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
                return true;
        }
        return false;
    }
    function makeCategorizer(wordChars) {
        return char => {
            if (!/\S/.test(char))
                return CharCategory.Space;
            if (hasWordChar(char))
                return CharCategory.Word;
            for (let i = 0; i < wordChars.length; i++)
                if (char.indexOf(wordChars[i]) > -1)
                    return CharCategory.Word;
            return CharCategory.Other;
        };
    }
    class EditorState {
        constructor(config, doc, selection, values, computeSlot, tr)
        {
            this.config = config;
            this.doc = doc;
            this.selection = selection;
            this.values = values;
            this.status = config.statusTemplate.slice();
            this.computeSlot = computeSlot;
            if (tr)
                tr._state = this;
            for (let i = 0; i < this.config.dynamicSlots.length; i++)
                ensureAddr(this, i << 1);
            this.computeSlot = null;
        }
        field(field, require=true)
        {
            let addr = this.config.address[field.id];
            if (addr == null) {
                if (require)
                    throw new RangeError("Field is not present in this state");
                return undefined;
            }
            ensureAddr(this, addr);
            return getAddr(this, addr);
        }
        update(...specs)
        {
            return resolveTransaction(this, specs, true);
        }
        applyTransaction(tr)
        {
            let conf = this.config,
                {base, compartments} = conf;
            for (let _i23 = 0, _tr$effects = tr.effects, _length23 = _tr$effects.length; _i23 < _length23; _i23++) {
                let effect = _tr$effects[_i23];
                if (effect.is(Compartment.reconfigure)) {
                    if (conf) {
                        compartments = new Map();
                        conf.compartments.forEach((val, key) => compartments.set(key, val));
                        conf = null;
                    }
                    compartments.set(effect.value.compartment, effect.value.extension);
                } else if (effect.is(StateEffect.reconfigure)) {
                    conf = null;
                    base = effect.value;
                } else if (effect.is(StateEffect.appendConfig)) {
                    conf = null;
                    base = asArray$1(base).concat(effect.value);
                }
            }
            let startValues;
            if (!conf) {
                conf = Configuration.resolve(base, compartments, this);
                let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
                startValues = intermediateState.values;
            } else {
                startValues = tr.startState.values.slice();
            }
            new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
        }
        replaceSelection(text)
        {
            if (typeof text == "string")
                text = this.toText(text);
            return this.changeByRange(range => ({
                changes: {
                    from: range.from,
                    to: range.to,
                    insert: text
                },
                range: EditorSelection.cursor(range.from + text.length)
            }));
        }
        changeByRange(f)
        {
            let sel = this.selection;
            let result1 = f(sel.ranges[0]);
            let changes = this.changes(result1.changes),
                ranges = [result1.range];
            let effects = asArray$1(result1.effects);
            for (let i = 1; i < sel.ranges.length; i++) {
                let result = f(sel.ranges[i]);
                let newChanges = this.changes(result.changes),
                    newMapped = newChanges.map(changes);
                for (let j = 0; j < i; j++)
                    ranges[j] = ranges[j].map(newMapped);
                let mapBy = changes.mapDesc(newChanges, true);
                ranges.push(result.range.map(mapBy));
                changes = changes.compose(newMapped);
                effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray$1(result.effects), mapBy));
            }
            return {
                changes,
                selection: EditorSelection.create(ranges, sel.mainIndex),
                effects
            };
        }
        changes(spec=[])
        {
            if (spec instanceof ChangeSet)
                return spec;
            return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
        }
        toText(string)
        {
            return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
        }
        sliceDoc(from=0, to=this.doc.length)
        {
            return this.doc.sliceString(from, to, this.lineBreak);
        }
        facet(facet)
        {
            let addr = this.config.address[facet.id];
            if (addr == null)
                return facet.default;
            ensureAddr(this, addr);
            return getAddr(this, addr);
        }
        toJSON(fields)
        {
            let result = {
                doc: this.sliceDoc(),
                selection: this.selection.toJSON()
            };
            if (fields)
                for (let prop in fields) {
                    let value = fields[prop];
                    if (value instanceof StateField && this.config.address[value.id] != null)
                        result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
                }
            return result;
        }
        static fromJSON(json, config={}, fields)
        {
            if (!json || typeof json.doc != "string")
                throw new RangeError("Invalid JSON representation for EditorState");
            let fieldInit = [];
            if (fields)
                for (let prop in fields) {
                    if (Object.prototype.hasOwnProperty.call(json, prop)) {
                        let field = fields[prop],
                            value = json[prop];
                        fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
                    }
                }
            return EditorState.create({
                doc: json.doc,
                selection: EditorSelection.fromJSON(json.selection),
                extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
            });
        }
        static create(config={})
        {
            let configuration = Configuration.resolve(config.extensions || [], new Map());
            let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
            let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
            checkSelection(selection, doc.length);
            if (!configuration.staticFacet(allowMultipleSelections))
                selection = selection.asSingle();
            return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
        }
        get tabSize()
        {
            return this.facet(EditorState.tabSize);
        }
        get lineBreak()
        {
            return this.facet(EditorState.lineSeparator) || "\n";
        }
        get readOnly()
        {
            return this.facet(readOnly);
        }
        phrase(phrase, ...insert)
        {
            for (let _i24 = 0, _this$facet = this.facet(EditorState.phrases), _length24 = _this$facet.length; _i24 < _length24; _i24++) {
                let map = _this$facet[_i24];
                if (Object.prototype.hasOwnProperty.call(map, phrase)) {
                    phrase = map[phrase];
                    break;
                }
            }
            if (insert.length)
                phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
                    if (i == "$")
                        return "$";
                    let n = +(i || 1);
                    return !n || n > insert.length ? m : insert[n - 1];
                });
            return phrase;
        }
        languageDataAt(name, pos, side=-1)
        {
            let values = [];
            for (let _i25 = 0, _this$facet2 = this.facet(languageData), _length25 = _this$facet2.length; _i25 < _length25; _i25++) {
                let provider = _this$facet2[_i25];
                for (let _i26 = 0, _provider = provider(this, pos, side), _length26 = _provider.length; _i26 < _length26; _i26++) {
                    let result = _provider[_i26];
                    if (Object.prototype.hasOwnProperty.call(result, name))
                        values.push(result[name]);
                }
            }
            return values;
        }
        charCategorizer(at)
        {
            return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
        }
        wordAt(pos)
        {
            let {text, from, length} = this.doc.lineAt(pos);
            let cat = this.charCategorizer(pos);
            let start = pos - from,
                end = pos - from;
            while (start > 0) {
                let prev = findClusterBreak(text, start, false);
                if (cat(text.slice(prev, start)) != CharCategory.Word)
                    break;
                start = prev;
            }
            while (end < length) {
                let next = findClusterBreak(text, end);
                if (cat(text.slice(end, next)) != CharCategory.Word)
                    break;
                end = next;
            }
            return start == end ? null : EditorSelection.range(start + from, end + from);
        }
    }
    EditorState.allowMultipleSelections = allowMultipleSelections;
    EditorState.tabSize = Facet.define({
        combine: values => values.length ? values[0] : 4
    });
    EditorState.lineSeparator = lineSeparator;
    EditorState.readOnly = readOnly;
    EditorState.phrases = Facet.define({
        compare(a, b) {
            let kA = Object.keys(a),
                kB = Object.keys(b);
            return kA.length == kB.length && kA.every(k => a[k] == b[k]);
        }
    });
    EditorState.languageData = languageData;
    EditorState.changeFilter = changeFilter;
    EditorState.transactionFilter = transactionFilter;
    EditorState.transactionExtender = transactionExtender;
    Compartment.reconfigure = StateEffect.define();
    function combineConfig(configs, defaults, combine={}) {
        let result = {};
        for (let _i27 = 0, _length27 = configs.length; _i27 < _length27; _i27++) {
            let config = configs[_i27];
            for (let _i28 = 0, _Object$keys = Object.keys(config), _length28 = _Object$keys.length; _i28 < _length28; _i28++) {
                let key = _Object$keys[_i28];
                let value = config[key],
                    current = result[key];
                if (current === undefined)
                    result[key] = value;
                else if (current === value || value === undefined)
                    ;
                else if (Object.hasOwnProperty.call(combine, key))
                    result[key] = combine[key](current, value);
                else
                    throw new Error("Config merge conflict for field " + key);
            }
        }
        for (let key in defaults)
            if (result[key] === undefined)
                result[key] = defaults[key];
        return result;
    }
    class RangeValue {
        eq(other)
        {
            return this == other;
        }
        range(from, to=from)
        {
            return Range$1.create(from, to, this);
        }
    }
    RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
    RangeValue.prototype.point = false;
    RangeValue.prototype.mapMode = MapMode.TrackDel;
    class Range$1 {
        constructor(from, to, value)
        {
            this.from = from;
            this.to = to;
            this.value = value;
        }
        static create(from, to, value)
        {
            return new Range$1(from, to, value);
        }
    }
    function cmpRange(a, b) {
        return a.from - b.from || a.value.startSide - b.value.startSide;
    }
    class Chunk$1 {
        constructor(from, to, value, maxPoint)
        {
            this.from = from;
            this.to = to;
            this.value = value;
            this.maxPoint = maxPoint;
        }
        get length()
        {
            return this.to[this.to.length - 1];
        }
        findIndex(pos, side, end, startAt=0)
        {
            let arr = end ? this.to : this.from;
            for (let lo = startAt, hi = arr.length; ;) {
                if (lo == hi)
                    return lo;
                let mid = lo + hi >> 1;
                let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
                if (mid == lo)
                    return diff >= 0 ? lo : hi;
                if (diff >= 0)
                    hi = mid;
                else
                    lo = mid + 1;
            }
        }
        between(offset, from, to, f)
        {
            for (let i = this.findIndex(from, -1000000000, true), e = this.findIndex(to, 1000000000, false, i); i < e; i++)
                if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
                    return false;
        }
        map(offset, changes)
        {
            let value = [],
                from = [],
                to = [],
                newPos = -1,
                maxPoint = -1;
            for (let i = 0; i < this.value.length; i++) {
                let val = this.value[i],
                    curFrom = this.from[i] + offset,
                    curTo = this.to[i] + offset,
                    newFrom,
                    newTo;
                if (curFrom == curTo) {
                    let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
                    if (mapped == null)
                        continue;
                    newFrom = newTo = mapped;
                    if (val.startSide != val.endSide) {
                        newTo = changes.mapPos(curFrom, val.endSide);
                        if (newTo < newFrom)
                            continue;
                    }
                } else {
                    newFrom = changes.mapPos(curFrom, val.startSide);
                    newTo = changes.mapPos(curTo, val.endSide);
                    if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                        continue;
                }
                if ((newTo - newFrom || val.endSide - val.startSide) < 0)
                    continue;
                if (newPos < 0)
                    newPos = newFrom;
                if (val.point)
                    maxPoint = Math.max(maxPoint, newTo - newFrom);
                value.push(val);
                from.push(newFrom - newPos);
                to.push(newTo - newPos);
            }
            return {
                mapped: value.length ? new Chunk$1(from, to, value, maxPoint) : null,
                pos: newPos
            };
        }
    }
    class RangeSet {
        constructor(chunkPos, chunk, nextLayer, maxPoint)
        {
            this.chunkPos = chunkPos;
            this.chunk = chunk;
            this.nextLayer = nextLayer;
            this.maxPoint = maxPoint;
        }
        static create(chunkPos, chunk, nextLayer, maxPoint)
        {
            return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
        }
        get length()
        {
            let last = this.chunk.length - 1;
            return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
        }
        get size()
        {
            if (this.isEmpty)
                return 0;
            let size = this.nextLayer.size;
            for (let _i29 = 0, _this$chunk = this.chunk, _length29 = _this$chunk.length; _i29 < _length29; _i29++) {
                let chunk = _this$chunk[_i29];
                size += chunk.value.length;
            }
            return size;
        }
        chunkEnd(index)
        {
            return this.chunkPos[index] + this.chunk[index].length;
        }
        update(updateSpec)
        {
            let {add=[], sort=false, filterFrom=0, filterTo=this.length} = updateSpec;
            let filter = updateSpec.filter;
            if (add.length == 0 && !filter)
                return this;
            if (sort)
                add = add.slice().sort(cmpRange);
            if (this.isEmpty)
                return add.length ? RangeSet.of(add) : this;
            let cur = new LayerCursor(this, null, -1).goto(0),
                i = 0,
                spill = [];
            let builder = new RangeSetBuilder();
            while (cur.value || i < add.length) {
                if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
                    let range = add[i++];
                    if (!builder.addInner(range.from, range.to, range.value))
                        spill.push(range);
                } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
                    cur.nextChunk();
                } else {
                    if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                        if (!builder.addInner(cur.from, cur.to, cur.value))
                            spill.push(Range$1.create(cur.from, cur.to, cur.value));
                    }
                    cur.next();
                }
            }
            return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({
                add: spill,
                filter,
                filterFrom,
                filterTo
            }));
        }
        map(changes)
        {
            if (changes.empty || this.isEmpty)
                return this;
            let chunks = [],
                chunkPos = [],
                maxPoint = -1;
            for (let i = 0; i < this.chunk.length; i++) {
                let start = this.chunkPos[i],
                    chunk = this.chunk[i];
                let touch = changes.touchesRange(start, start + chunk.length);
                if (touch === false) {
                    maxPoint = Math.max(maxPoint, chunk.maxPoint);
                    chunks.push(chunk);
                    chunkPos.push(changes.mapPos(start));
                } else if (touch === true) {
                    let {mapped, pos} = chunk.map(start, changes);
                    if (mapped) {
                        maxPoint = Math.max(maxPoint, mapped.maxPoint);
                        chunks.push(mapped);
                        chunkPos.push(pos);
                    }
                }
            }
            let next = this.nextLayer.map(changes);
            return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
        }
        between(from, to, f)
        {
            if (this.isEmpty)
                return;
            for (let i = 0; i < this.chunk.length; i++) {
                let start = this.chunkPos[i],
                    chunk = this.chunk[i];
                if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
                    return;
            }
            this.nextLayer.between(from, to, f);
        }
        iter(from=0)
        {
            return HeapCursor.from([this]).goto(from);
        }
        get isEmpty()
        {
            return this.nextLayer == this;
        }
        static iter(sets, from=0)
        {
            return HeapCursor.from(sets).goto(from);
        }
        static compare(oldSets, newSets, textDiff, comparator, minPointSize=-1)
        {
            let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
            let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
            let sharedChunks = findSharedChunks(a, b, textDiff);
            let sideA = new SpanCursor(a, sharedChunks, minPointSize);
            let sideB = new SpanCursor(b, sharedChunks, minPointSize);
            textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
            if (textDiff.empty && textDiff.length == 0)
                compare(sideA, 0, sideB, 0, 0, comparator);
        }
        static eq(oldSets, newSets, from=0, to)
        {
            if (to == null)
                to = 1000000000 - 1;
            let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);
            let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);
            if (a.length != b.length)
                return false;
            if (!a.length)
                return true;
            let sharedChunks = findSharedChunks(a, b);
            let sideA = new SpanCursor(a, sharedChunks, 0).goto(from),
                sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
            for (;;) {
                if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
                    return false;
                if (sideA.to > to)
                    return true;
                sideA.next();
                sideB.next();
            }
        }
        static spans(sets, from, to, iterator, minPointSize=-1)
        {
            let cursor = new SpanCursor(sets, null, minPointSize).goto(from),
                pos = from;
            let openRanges = cursor.openStart;
            for (;;) {
                let curTo = Math.min(cursor.to, to);
                if (cursor.point) {
                    let active = cursor.activeForPoint(cursor.to);
                    let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);
                    iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
                    openRanges = Math.min(cursor.openEnd(curTo), active.length);
                } else if (curTo > pos) {
                    iterator.span(pos, curTo, cursor.active, openRanges);
                    openRanges = cursor.openEnd(curTo);
                }
                if (cursor.to > to)
                    return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
                pos = cursor.to;
                cursor.next();
            }
        }
        static of(ranges, sort=false)
        {
            let build = new RangeSetBuilder();
            for (let _i30 = 0, _ref = ranges instanceof Range$1 ? [ranges] : sort ? lazySort(ranges) : ranges, _length30 = _ref.length; _i30 < _length30; _i30++) {
                let range = _ref[_i30];
                build.add(range.from, range.to, range.value);
            }
            return build.finish();
        }
    }
    RangeSet.empty = new RangeSet([], [], null, -1);
    function lazySort(ranges) {
        if (ranges.length > 1)
            for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
                let cur = ranges[i];
                if (cmpRange(prev, cur) > 0)
                    return ranges.slice().sort(cmpRange);
                prev = cur;
            }
        return ranges;
    }
    RangeSet.empty.nextLayer = RangeSet.empty;
    class RangeSetBuilder {
        constructor()
        {
            this.chunks = [];
            this.chunkPos = [];
            this.chunkStart = -1;
            this.last = null;
            this.lastFrom = -1000000000;
            this.lastTo = -1000000000;
            this.from = [];
            this.to = [];
            this.value = [];
            this.maxPoint = -1;
            this.setMaxPoint = -1;
            this.nextLayer = null;
        }
        finishChunk(newArrays)
        {
            this.chunks.push(new Chunk$1(this.from, this.to, this.value, this.maxPoint));
            this.chunkPos.push(this.chunkStart);
            this.chunkStart = -1;
            this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
            this.maxPoint = -1;
            if (newArrays) {
                this.from = [];
                this.to = [];
                this.value = [];
            }
        }
        add(from, to, value)
        {
            if (!this.addInner(from, to, value))
                (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
        }
        addInner(from, to, value)
        {
            let diff = from - this.lastTo || value.startSide - this.last.endSide;
            if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
                throw new Error("Ranges must be added sorted by `from` position and `startSide`");
            if (diff < 0)
                return false;
            if (this.from.length == 250)
                this.finishChunk(true);
            if (this.chunkStart < 0)
                this.chunkStart = from;
            this.from.push(from - this.chunkStart);
            this.to.push(to - this.chunkStart);
            this.last = value;
            this.lastFrom = from;
            this.lastTo = to;
            this.value.push(value);
            if (value.point)
                this.maxPoint = Math.max(this.maxPoint, to - from);
            return true;
        }
        addChunk(from, chunk)
        {
            if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
                return false;
            if (this.from.length)
                this.finishChunk(true);
            this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
            this.chunks.push(chunk);
            this.chunkPos.push(from);
            let last = chunk.value.length - 1;
            this.last = chunk.value[last];
            this.lastFrom = chunk.from[last] + from;
            this.lastTo = chunk.to[last] + from;
            return true;
        }
        finish()
        {
            return this.finishInner(RangeSet.empty);
        }
        finishInner(next)
        {
            if (this.from.length)
                this.finishChunk(false);
            if (this.chunks.length == 0)
                return next;
            let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
            this.from = null;
            return result;
        }
    }
    function findSharedChunks(a, b, textDiff) {
        let inA = new Map();
        for (let _i31 = 0, _length31 = a.length; _i31 < _length31; _i31++) {
            let set = a[_i31];
            for (let i = 0; i < set.chunk.length; i++)
                if (set.chunk[i].maxPoint <= 0)
                    inA.set(set.chunk[i], set.chunkPos[i]);
        }
        let shared = new Set();
        for (let _i32 = 0, _length32 = b.length; _i32 < _length32; _i32++) {
            let set = b[_i32];
            for (let i = 0; i < set.chunk.length; i++) {
                let known = inA.get(set.chunk[i]);
                if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
                    shared.add(set.chunk[i]);
            }
        }
        return shared;
    }
    class LayerCursor {
        constructor(layer, skip, minPoint, rank=0)
        {
            this.layer = layer;
            this.skip = skip;
            this.minPoint = minPoint;
            this.rank = rank;
        }
        get startSide()
        {
            return this.value ? this.value.startSide : 0;
        }
        get endSide()
        {
            return this.value ? this.value.endSide : 0;
        }
        goto(pos, side=-1000000000)
        {
            this.chunkIndex = this.rangeIndex = 0;
            this.gotoInner(pos, side, false);
            return this;
        }
        gotoInner(pos, side, forward)
        {
            while (this.chunkIndex < this.layer.chunk.length) {
                let next = this.layer.chunk[this.chunkIndex];
                if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
                    break;
                this.chunkIndex++;
                forward = false;
            }
            if (this.chunkIndex < this.layer.chunk.length) {
                let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
                if (!forward || this.rangeIndex < rangeIndex)
                    this.setRangeIndex(rangeIndex);
            }
            this.next();
        }
        forward(pos, side)
        {
            if ((this.to - pos || this.endSide - side) < 0)
                this.gotoInner(pos, side, true);
        }
        next()
        {
            for (;;) {
                if (this.chunkIndex == this.layer.chunk.length) {
                    this.from = this.to = 1000000000;
                    this.value = null;
                    break;
                } else {
                    let chunkPos = this.layer.chunkPos[this.chunkIndex],
                        chunk = this.layer.chunk[this.chunkIndex];
                    let from = chunkPos + chunk.from[this.rangeIndex];
                    this.from = from;
                    this.to = chunkPos + chunk.to[this.rangeIndex];
                    this.value = chunk.value[this.rangeIndex];
                    this.setRangeIndex(this.rangeIndex + 1);
                    if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                        break;
                }
            }
        }
        setRangeIndex(index)
        {
            if (index == this.layer.chunk[this.chunkIndex].value.length) {
                this.chunkIndex++;
                if (this.skip) {
                    while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                        this.chunkIndex++;
                }
                this.rangeIndex = 0;
            } else {
                this.rangeIndex = index;
            }
        }
        nextChunk()
        {
            this.chunkIndex++;
            this.rangeIndex = 0;
            this.next();
        }
        compare(other)
        {
            return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
        }
    }
    class HeapCursor {
        constructor(heap)
        {
            this.heap = heap;
        }
        static from(sets, skip=null, minPoint=-1)
        {
            let heap = [];
            for (let i = 0; i < sets.length; i++) {
                for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
                    if (cur.maxPoint >= minPoint)
                        heap.push(new LayerCursor(cur, skip, minPoint, i));
                }
            }
            return heap.length == 1 ? heap[0] : new HeapCursor(heap);
        }
        get startSide()
        {
            return this.value ? this.value.startSide : 0;
        }
        goto(pos, side=-1000000000)
        {
            for (let _i33 = 0, _this$heap = this.heap, _length33 = _this$heap.length; _i33 < _length33; _i33++) {
                let cur = _this$heap[_i33];
                cur.goto(pos, side);
            }
            for (let i = this.heap.length >> 1; i >= 0; i--)
                heapBubble(this.heap, i);
            this.next();
            return this;
        }
        forward(pos, side)
        {
            for (let _i34 = 0, _this$heap2 = this.heap, _length34 = _this$heap2.length; _i34 < _length34; _i34++) {
                let cur = _this$heap2[_i34];
                cur.forward(pos, side);
            }
            for (let i = this.heap.length >> 1; i >= 0; i--)
                heapBubble(this.heap, i);
            if ((this.to - pos || this.value.endSide - side) < 0)
                this.next();
        }
        next()
        {
            if (this.heap.length == 0) {
                this.from = this.to = 1000000000;
                this.value = null;
                this.rank = -1;
            } else {
                let top = this.heap[0];
                this.from = top.from;
                this.to = top.to;
                this.value = top.value;
                this.rank = top.rank;
                if (top.value)
                    top.next();
                heapBubble(this.heap, 0);
            }
        }
    }
    function heapBubble(heap, index) {
        for (let cur = heap[index]; ;) {
            let childIndex = (index << 1) + 1;
            if (childIndex >= heap.length)
                break;
            let child = heap[childIndex];
            if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
                child = heap[childIndex + 1];
                childIndex++;
            }
            if (cur.compare(child) < 0)
                break;
            heap[childIndex] = cur;
            heap[index] = child;
            index = childIndex;
        }
    }
    class SpanCursor {
        constructor(sets, skip, minPoint)
        {
            this.minPoint = minPoint;
            this.active = [];
            this.activeTo = [];
            this.activeRank = [];
            this.minActive = -1;
            this.point = null;
            this.pointFrom = 0;
            this.pointRank = 0;
            this.to = -1000000000;
            this.endSide = 0;
            this.openStart = -1;
            this.cursor = HeapCursor.from(sets, skip, minPoint);
        }
        goto(pos, side=-1000000000)
        {
            this.cursor.goto(pos, side);
            this.active.length = this.activeTo.length = this.activeRank.length = 0;
            this.minActive = -1;
            this.to = pos;
            this.endSide = side;
            this.openStart = -1;
            this.next();
            return this;
        }
        forward(pos, side)
        {
            while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
                this.removeActive(this.minActive);
            this.cursor.forward(pos, side);
        }
        removeActive(index)
        {
            remove(this.active, index);
            remove(this.activeTo, index);
            remove(this.activeRank, index);
            this.minActive = findMinIndex(this.active, this.activeTo);
        }
        addActive(trackOpen)
        {
            let i = 0,
                {value, to, rank} = this.cursor;
            while (i < this.activeRank.length && this.activeRank[i] <= rank)
                i++;
            insert(this.active, i, value);
            insert(this.activeTo, i, to);
            insert(this.activeRank, i, rank);
            if (trackOpen)
                insert(trackOpen, i, this.cursor.from);
            this.minActive = findMinIndex(this.active, this.activeTo);
        }
        next()
        {
            let from = this.to,
                wasPoint = this.point;
            this.point = null;
            let trackOpen = this.openStart < 0 ? [] : null;
            for (;;) {
                let a = this.minActive;
                if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
                    if (this.activeTo[a] > from) {
                        this.to = this.activeTo[a];
                        this.endSide = this.active[a].endSide;
                        break;
                    }
                    this.removeActive(a);
                    if (trackOpen)
                        remove(trackOpen, a);
                } else if (!this.cursor.value) {
                    this.to = this.endSide = 1000000000;
                    break;
                } else if (this.cursor.from > from) {
                    this.to = this.cursor.from;
                    this.endSide = this.cursor.startSide;
                    break;
                } else {
                    let nextVal = this.cursor.value;
                    if (!nextVal.point) {
                        this.addActive(trackOpen);
                        this.cursor.next();
                    } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                        this.cursor.next();
                    } else {
                        this.point = nextVal;
                        this.pointFrom = this.cursor.from;
                        this.pointRank = this.cursor.rank;
                        this.to = this.cursor.to;
                        this.endSide = nextVal.endSide;
                        this.cursor.next();
                        this.forward(this.to, this.endSide);
                        break;
                    }
                }
            }
            if (trackOpen) {
                this.openStart = 0;
                for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
                    this.openStart++;
            }
        }
        activeForPoint(to)
        {
            if (!this.active.length)
                return this.active;
            let active = [];
            for (let i = this.active.length - 1; i >= 0; i--) {
                if (this.activeRank[i] < this.pointRank)
                    break;
                if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
                    active.push(this.active[i]);
            }
            return active.reverse();
        }
        openEnd(to)
        {
            let open = 0;
            for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
                open++;
            return open;
        }
    }
    function compare(a, startA, b, startB, length, comparator) {
        a.goto(startA);
        b.goto(startB);
        let endB = startB + length;
        let pos = startB,
            dPos = startB - startA;
        for (;;) {
            let diff = a.to + dPos - b.to || a.endSide - b.endSide;
            let end = diff < 0 ? a.to + dPos : b.to,
                clipEnd = Math.min(end, endB);
            if (a.point || b.point) {
                if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
                    comparator.comparePoint(pos, clipEnd, a.point, b.point);
            } else {
                if (clipEnd > pos && !sameValues(a.active, b.active))
                    comparator.compareRange(pos, clipEnd, a.active, b.active);
            }
            if (end > endB)
                break;
            pos = end;
            if (diff <= 0)
                a.next();
            if (diff >= 0)
                b.next();
        }
    }
    function sameValues(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++)
            if (a[i] != b[i] && !a[i].eq(b[i]))
                return false;
        return true;
    }
    function remove(array, index) {
        for (let i = index, e = array.length - 1; i < e; i++)
            array[i] = array[i + 1];
        array.pop();
    }
    function insert(array, index, value) {
        for (let i = array.length - 1; i >= index; i--)
            array[i + 1] = array[i];
        array[index] = value;
    }
    function findMinIndex(value, array) {
        let found = -1,
            foundPos = 1000000000;
        for (let i = 0; i < array.length; i++)
            if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
                found = i;
                foundPos = array[i];
            }
        return found;
    }
    function countColumn(string, tabSize, to=string.length) {
        let n = 0;
        for (let i = 0; i < to;) {
            if (string.charCodeAt(i) == 9) {
                n += tabSize - n % tabSize;
                i++;
            } else {
                n++;
                i = findClusterBreak(string, i);
            }
        }
        return n;
    }
    function findColumn(string, col, tabSize, strict) {
        for (let i = 0, n = 0; ;) {
            if (n >= col)
                return i;
            if (i == string.length)
                break;
            n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
            i = findClusterBreak(string, i);
        }
        return strict === true ? -1 : string.length;
    }
    var _m0 = Object.freeze({
        __proto__: null,
        Annotation: Annotation,
        AnnotationType: AnnotationType,
        ChangeDesc: ChangeDesc,
        ChangeSet: ChangeSet,
        get CharCategory() {
            return CharCategory;
        },
        Compartment: Compartment,
        EditorSelection: EditorSelection,
        EditorState: EditorState,
        Facet: Facet,
        Line: Line$1,
        get MapMode() {
            return MapMode;
        },
        Prec: Prec,
        Range: Range$1,
        RangeSet: RangeSet,
        RangeSetBuilder: RangeSetBuilder,
        RangeValue: RangeValue,
        SelectionRange: SelectionRange,
        StateEffect: StateEffect,
        StateEffectType: StateEffectType,
        StateField: StateField,
        Text: Text,
        Transaction: Transaction,
        codePointAt: codePointAt,
        codePointSize: codePointSize,
        combineConfig: combineConfig,
        countColumn: countColumn,
        findClusterBreak: findClusterBreak,
        findColumn: findColumn,
        fromCodePoint: fromCodePoint
    });
    const C = "\u037c";
    const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
    const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
    const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
    class StyleModule {
        constructor(spec, options)
        {
            this.rules = [];
            let {finish} = options || {};
            function splitSelector(selector) {
                return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
            }
            function render(selectors, spec, target, isKeyframes) {
                let local = [],
                    isAt = /^@(\w+)\b/.exec(selectors[0]),
                    keyframes = isAt && isAt[1] == "keyframes";
                if (isAt && spec == null)
                    return target.push(selectors[0] + ";");
                for (let prop in spec) {
                    let value = spec[prop];
                    if (/&/.test(prop)) {
                        render(prop.split(/,\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
                    } else if (value && typeof value == "object") {
                        if (!isAt)
                            throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
                        render(splitSelector(prop), value, local, keyframes);
                    } else if (value != null) {
                        local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, l => "-" + l.toLowerCase()) + ": " + value + ";");
                    }
                }
                if (local.length || keyframes) {
                    target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
                }
            }
            for (let prop in spec)
                render(splitSelector(prop), spec[prop], this.rules);
        }
        getRules()
        {
            return this.rules.join("\n");
        }
        static newName()
        {
            let id = top[COUNT] || 1;
            top[COUNT] = id + 1;
            return C + id.toString(36);
        }
        static mount(root, modules)
        {
            (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
        }
    }
    let adoptedSet = null;
    class StyleSet {
        constructor(root)
        {
            if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
                if (adoptedSet) {
                    root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
                    return root[SET] = adoptedSet;
                }
                this.sheet = new CSSStyleSheet();
                root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
                adoptedSet = this;
            } else {
                this.styleTag = (root.ownerDocument || root).createElement("style");
                let target = root.head || root;
                target.insertBefore(this.styleTag, target.firstChild);
            }
            this.modules = [];
            root[SET] = this;
        }
        mount(modules)
        {
            let sheet = this.sheet;
            let pos = 0,
                j = 0;
            for (let i = 0; i < modules.length; i++) {
                let mod = modules[i],
                    index = this.modules.indexOf(mod);
                if (index < j && index > -1) {
                    this.modules.splice(index, 1);
                    j--;
                    index = -1;
                }
                if (index == -1) {
                    this.modules.splice(j++, 0, mod);
                    if (sheet)
                        for (let k = 0; k < mod.rules.length; k++)
                            sheet.insertRule(mod.rules[k], pos++);
                } else {
                    while (j < index)
                        pos += this.modules[j++].rules.length;
                    pos += mod.rules.length;
                    j++;
                }
            }
            if (!sheet) {
                let text = "";
                for (let i = 0; i < this.modules.length; i++)
                    text += this.modules[i].getRules() + "\n";
                this.styleTag.textContent = text;
            }
        }
    }
    var base = {
        8: "Backspace",
        9: "Tab",
        10: "Enter",
        12: "NumLock",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        44: "PrintScreen",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Meta",
        92: "Meta",
        106: "*",
        107: "+",
        108: ",",
        109: "-",
        110: ".",
        111: "/",
        144: "NumLock",
        145: "ScrollLock",
        160: "Shift",
        161: "Shift",
        162: "Control",
        163: "Control",
        164: "Alt",
        165: "Alt",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
    };
    var shift = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: "\""
    };
    var chrome$1 = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
    typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
    var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    var brokenModifierNames = mac || chrome$1 && +chrome$1[1] < 57;
    for (var i = 0; i < 10; i++)
        base[48 + i] = base[96 + i] = String(i);
    for (var i = 1; i <= 24; i++)
        base[i + 111] = "F" + i;
    for (var i = 65; i <= 90; i++) {
        base[i] = String.fromCharCode(i + 32);
        shift[i] = String.fromCharCode(i);
    }
    for (var code in base)
        if (!shift.hasOwnProperty(code))
            shift[code] = base[code];
    function keyName(event) {
        var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie$1 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
        var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
        if (name == "Esc")
            name = "Escape";
        if (name == "Del")
            name = "Delete";
        if (name == "Left")
            name = "ArrowLeft";
        if (name == "Up")
            name = "ArrowUp";
        if (name == "Right")
            name = "ArrowRight";
        if (name == "Down")
            name = "ArrowDown";
        return name;
    }
    function getSelection(root) {
        let target;
        if (root.nodeType == 11) {
            target = root.getSelection ? root : root.ownerDocument;
        } else {
            target = root;
        }
        return target.getSelection();
    }
    function contains(dom, node) {
        return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
    }
    function deepActiveElement(doc) {
        let elt = doc.activeElement;
        while (elt && elt.shadowRoot)
            elt = elt.shadowRoot.activeElement;
        return elt;
    }
    function hasSelection(dom, selection) {
        if (!selection.anchorNode)
            return false;
        try {
            return contains(dom, selection.anchorNode);
        } catch (_) {
            return false;
        }
    }
    function clientRectsFor(dom) {
        if (dom.nodeType == 3)
            return textRange(dom, 0, dom.nodeValue.length).getClientRects();
        else if (dom.nodeType == 1)
            return dom.getClientRects();
        else
            return [];
    }
    function isEquivalentPosition(node, off, targetNode, targetOff) {
        return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
    }
    function domIndex(node) {
        for (var index = 0;; index++) {
            node = node.previousSibling;
            if (!node)
                return index;
        }
    }
    function scanFor(node, off, targetNode, targetOff, dir) {
        for (;;) {
            if (node == targetNode && off == targetOff)
                return true;
            if (off == (dir < 0 ? 0 : maxOffset(node))) {
                if (node.nodeName == "DIV")
                    return false;
                let parent = node.parentNode;
                if (!parent || parent.nodeType != 1)
                    return false;
                off = domIndex(node) + (dir < 0 ? 0 : 1);
                node = parent;
            } else if (node.nodeType == 1) {
                node = node.childNodes[off + (dir < 0 ? -1 : 0)];
                if (node.nodeType == 1 && node.contentEditable == "false")
                    return false;
                off = dir < 0 ? maxOffset(node) : 0;
            } else {
                return false;
            }
        }
    }
    function maxOffset(node) {
        return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    const Rect0 = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    function flattenRect(rect, left) {
        let x = left ? rect.left : rect.right;
        return {
            left: x,
            right: x,
            top: rect.top,
            bottom: rect.bottom
        };
    }
    function windowRect(win) {
        return {
            left: 0,
            right: win.innerWidth,
            top: 0,
            bottom: win.innerHeight
        };
    }
    function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
        let doc = dom.ownerDocument,
            win = doc.defaultView || window;
        for (let cur = dom; cur;) {
            if (cur.nodeType == 1) {
                let bounding,
                    top = cur == doc.body;
                if (top) {
                    bounding = windowRect(win);
                } else {
                    if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                        cur = cur.assignedSlot || cur.parentNode;
                        continue;
                    }
                    let rect = cur.getBoundingClientRect();
                    bounding = {
                        left: rect.left,
                        right: rect.left + cur.clientWidth,
                        top: rect.top,
                        bottom: rect.top + cur.clientHeight
                    };
                }
                let moveX = 0,
                    moveY = 0;
                if (y == "nearest") {
                    if (rect.top < bounding.top) {
                        moveY = -(bounding.top - rect.top + yMargin);
                        if (side > 0 && rect.bottom > bounding.bottom + moveY)
                            moveY = rect.bottom - bounding.bottom + moveY + yMargin;
                    } else if (rect.bottom > bounding.bottom) {
                        moveY = rect.bottom - bounding.bottom + yMargin;
                        if (side < 0 && rect.top - moveY < bounding.top)
                            moveY = -(bounding.top + moveY - rect.top + yMargin);
                    }
                } else {
                    let rectHeight = rect.bottom - rect.top,
                        boundingHeight = bounding.bottom - bounding.top;
                    let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
                    moveY = targetTop - bounding.top;
                }
                if (x == "nearest") {
                    if (rect.left < bounding.left) {
                        moveX = -(bounding.left - rect.left + xMargin);
                        if (side > 0 && rect.right > bounding.right + moveX)
                            moveX = rect.right - bounding.right + moveX + xMargin;
                    } else if (rect.right > bounding.right) {
                        moveX = rect.right - bounding.right + xMargin;
                        if (side < 0 && rect.left < bounding.left + moveX)
                            moveX = -(bounding.left + moveX - rect.left + xMargin);
                    }
                } else {
                    let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
                    moveX = targetLeft - bounding.left;
                }
                if (moveX || moveY) {
                    if (top) {
                        win.scrollBy(moveX, moveY);
                    } else {
                        let movedX = 0,
                            movedY = 0;
                        if (moveY) {
                            let start = cur.scrollTop;
                            cur.scrollTop += moveY;
                            movedY = cur.scrollTop - start;
                        }
                        if (moveX) {
                            let start = cur.scrollLeft;
                            cur.scrollLeft += moveX;
                            movedX = cur.scrollLeft - start;
                        }
                        rect = {
                            left: rect.left - movedX,
                            top: rect.top - movedY,
                            right: rect.right - movedX,
                            bottom: rect.bottom - movedY
                        };
                        if (movedX && Math.abs(movedX - moveX) < 1)
                            x = "nearest";
                        if (movedY && Math.abs(movedY - moveY) < 1)
                            y = "nearest";
                    }
                }
                if (top)
                    break;
                cur = cur.assignedSlot || cur.parentNode;
            } else if (cur.nodeType == 11) {
                cur = cur.host;
            } else {
                break;
            }
        }
    }
    function scrollableParent(dom) {
        let doc = dom.ownerDocument;
        for (let cur = dom.parentNode; cur;) {
            if (cur == doc.body) {
                break;
            } else if (cur.nodeType == 1) {
                if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)
                    return cur;
                cur = cur.assignedSlot || cur.parentNode;
            } else if (cur.nodeType == 11) {
                cur = cur.host;
            } else {
                break;
            }
        }
        return null;
    }
    class DOMSelectionState {
        constructor()
        {
            this.anchorNode = null;
            this.anchorOffset = 0;
            this.focusNode = null;
            this.focusOffset = 0;
        }
        eq(domSel)
        {
            return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
        }
        setRange(range)
        {
            this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
        }
        set(anchorNode, anchorOffset, focusNode, focusOffset)
        {
            this.anchorNode = anchorNode;
            this.anchorOffset = anchorOffset;
            this.focusNode = focusNode;
            this.focusOffset = focusOffset;
        }
    }
    let preventScrollSupported = null;
    function focusPreventScroll(dom) {
        if (dom.setActive)
            return dom.setActive();
        if (preventScrollSupported)
            return dom.focus(preventScrollSupported);
        let stack = [];
        for (let cur = dom; cur; cur = cur.parentNode) {
            stack.push(cur, cur.scrollTop, cur.scrollLeft);
            if (cur == cur.ownerDocument)
                break;
        }
        dom.focus(preventScrollSupported == null ? {
            get preventScroll() {
                preventScrollSupported = {
                    preventScroll: true
                };
                return true;
            }
        } : undefined);
        if (!preventScrollSupported) {
            preventScrollSupported = false;
            for (let i = 0; i < stack.length;) {
                let elt = stack[i++],
                    top = stack[i++],
                    left = stack[i++];
                if (elt.scrollTop != top)
                    elt.scrollTop = top;
                if (elt.scrollLeft != left)
                    elt.scrollLeft = left;
            }
        }
    }
    let scratchRange;
    function textRange(node, from, to=from) {
        let range = scratchRange || (scratchRange = document.createRange());
        range.setEnd(node, to);
        range.setStart(node, from);
        return range;
    }
    function dispatchKey(elt, name, code) {
        let options = {
            key: name,
            code: name,
            keyCode: code,
            which: code,
            cancelable: true
        };
        let down = new KeyboardEvent("keydown", options);
        down.synthetic = true;
        elt.dispatchEvent(down);
        let up = new KeyboardEvent("keyup", options);
        up.synthetic = true;
        elt.dispatchEvent(up);
        return down.defaultPrevented || up.defaultPrevented;
    }
    function getRoot(node) {
        while (node) {
            if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
                return node;
            node = node.assignedSlot || node.parentNode;
        }
        return null;
    }
    function clearAttributes(node) {
        while (node.attributes.length)
            node.removeAttributeNode(node.attributes[0]);
    }
    function atElementStart(doc, selection) {
        let node = selection.focusNode,
            offset = selection.focusOffset;
        if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
            return false;
        for (;;) {
            if (offset) {
                if (node.nodeType != 1)
                    return false;
                let prev = node.childNodes[offset - 1];
                if (prev.contentEditable == "false")
                    offset--;
                else {
                    node = prev;
                    offset = maxOffset(node);
                }
            } else if (node == doc) {
                return true;
            } else {
                offset = domIndex(node);
                node = node.parentNode;
            }
        }
    }
    class DOMPos {
        constructor(node, offset, precise=true)
        {
            this.node = node;
            this.offset = offset;
            this.precise = precise;
        }
        static before(dom, precise)
        {
            return new DOMPos(dom.parentNode, domIndex(dom), precise);
        }
        static after(dom, precise)
        {
            return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
        }
    }
    const noChildren = [];
    class ContentView {
        constructor()
        {
            this.parent = null;
            this.dom = null;
            this.dirty = 2;
        }
        get editorView()
        {
            if (!this.parent)
                throw new Error("Accessing view in orphan content view");
            return this.parent.editorView;
        }
        get overrideDOMText()
        {
            return null;
        }
        get posAtStart()
        {
            return this.parent ? this.parent.posBefore(this) : 0;
        }
        get posAtEnd()
        {
            return this.posAtStart + this.length;
        }
        posBefore(view)
        {
            let pos = this.posAtStart;
            for (let _i35 = 0, _this$children2 = this.children, _length35 = _this$children2.length; _i35 < _length35; _i35++) {
                let child = _this$children2[_i35];
                if (child == view)
                    return pos;
                pos += child.length + child.breakAfter;
            }
            throw new RangeError("Invalid child in posBefore");
        }
        posAfter(view)
        {
            return this.posBefore(view) + view.length;
        }
        coordsAt(_pos, _side)
        {
            return null;
        }
        sync(track)
        {
            if (this.dirty & 2) {
                let parent = this.dom;
                let prev = null,
                    next;
                for (let _i36 = 0, _this$children3 = this.children, _length36 = _this$children3.length; _i36 < _length36; _i36++) {
                    let child = _this$children3[_i36];
                    if (child.dirty) {
                        if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                            let contentView = ContentView.get(next);
                            if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                                child.reuseDOM(next);
                        }
                        child.sync(track);
                        child.dirty = 0;
                    }
                    next = prev ? prev.nextSibling : parent.firstChild;
                    if (track && !track.written && track.node == parent && next != child.dom)
                        track.written = true;
                    if (child.dom.parentNode == parent) {
                        while (next && next != child.dom)
                            next = rm$1(next);
                    } else {
                        parent.insertBefore(child.dom, next);
                    }
                    prev = child.dom;
                }
                next = prev ? prev.nextSibling : parent.firstChild;
                if (next && track && track.node == parent)
                    track.written = true;
                while (next)
                    next = rm$1(next);
            } else if (this.dirty & 1) {
                for (let _i37 = 0, _this$children4 = this.children, _length37 = _this$children4.length; _i37 < _length37; _i37++) {
                    let child = _this$children4[_i37];
                    if (child.dirty) {
                        child.sync(track);
                        child.dirty = 0;
                    }
                }
            }
        }
        reuseDOM(_dom) {}
        localPosFromDOM(node, offset)
        {
            let after;
            if (node == this.dom) {
                after = this.dom.childNodes[offset];
            } else {
                let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
                for (;;) {
                    let parent = node.parentNode;
                    if (parent == this.dom)
                        break;
                    if (bias == 0 && parent.firstChild != parent.lastChild) {
                        if (node == parent.firstChild)
                            bias = -1;
                        else
                            bias = 1;
                    }
                    node = parent;
                }
                if (bias < 0)
                    after = node;
                else
                    after = node.nextSibling;
            }
            if (after == this.dom.firstChild)
                return 0;
            while (after && !ContentView.get(after))
                after = after.nextSibling;
            if (!after)
                return this.length;
            for (let i = 0, pos = 0; ; i++) {
                let child = this.children[i];
                if (child.dom == after)
                    return pos;
                pos += child.length + child.breakAfter;
            }
        }
        domBoundsAround(from, to, offset=0)
        {
            let fromI = -1,
                fromStart = -1,
                toI = -1,
                toEnd = -1;
            for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
                let child = this.children[i],
                    end = pos + child.length;
                if (pos < from && end > to)
                    return child.domBoundsAround(from, to, pos);
                if (end >= from && fromI == -1) {
                    fromI = i;
                    fromStart = pos;
                }
                if (pos > to && child.dom.parentNode == this.dom) {
                    toI = i;
                    toEnd = prevEnd;
                    break;
                }
                prevEnd = end;
                pos = end + child.breakAfter;
            }
            return {
                from: fromStart,
                to: toEnd < 0 ? offset + this.length : toEnd,
                startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
                endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
            };
        }
        markDirty(andParent=false)
        {
            this.dirty |= 2;
            this.markParentsDirty(andParent);
        }
        markParentsDirty(childList)
        {
            for (let parent = this.parent; parent; parent = parent.parent) {
                if (childList)
                    parent.dirty |= 2;
                if (parent.dirty & 1)
                    return;
                parent.dirty |= 1;
                childList = false;
            }
        }
        setParent(parent)
        {
            if (this.parent != parent) {
                this.parent = parent;
                if (this.dirty)
                    this.markParentsDirty(true);
            }
        }
        setDOM(dom)
        {
            if (this.dom)
                this.dom.cmView = null;
            this.dom = dom;
            dom.cmView = this;
        }
        get rootView()
        {
            for (let v = this; ;) {
                let parent = v.parent;
                if (!parent)
                    return v;
                v = parent;
            }
        }
        replaceChildren(from, to, children=noChildren)
        {
            this.markDirty();
            for (let i = from; i < to; i++) {
                let child = this.children[i];
                if (child.parent == this)
                    child.destroy();
            }
            this.children.splice(from, to - from, ...children);
            for (let i = 0; i < children.length; i++)
                children[i].setParent(this);
        }
        ignoreMutation(_rec)
        {
            return false;
        }
        ignoreEvent(_event)
        {
            return false;
        }
        childCursor(pos=this.length)
        {
            return new ChildCursor(this.children, pos, this.children.length);
        }
        childPos(pos, bias=1)
        {
            return this.childCursor().findPos(pos, bias);
        }
        toString()
        {
            let name = this.constructor.name.replace("View", "");
            return name + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
        }
        static get(node)
        {
            return node.cmView;
        }
        get isEditable()
        {
            return true;
        }
        merge(from, to, source, hasStart, openStart, openEnd)
        {
            return false;
        }
        become(other)
        {
            return false;
        }
        canReuseDOM(other)
        {
            return other.constructor == this.constructor;
        }
        getSide()
        {
            return 0;
        }
        destroy()
        {
            this.parent = null;
        }
    }
    ContentView.prototype.breakAfter = 0;
    function rm$1(dom) {
        let next = dom.nextSibling;
        dom.parentNode.removeChild(dom);
        return next;
    }
    class ChildCursor {
        constructor(children, pos, i)
        {
            this.children = children;
            this.pos = pos;
            this.i = i;
            this.off = 0;
        }
        findPos(pos, bias=1)
        {
            for (;;) {
                if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                    this.off = pos - this.pos;
                    return this;
                }
                let next = this.children[--this.i];
                this.pos -= next.length + next.breakAfter;
            }
        }
    }
    function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
        let {children} = parent;
        let before = children.length ? children[fromI] : null;
        let last = insert.length ? insert[insert.length - 1] : null;
        let breakAtEnd = last ? last.breakAfter : breakAtStart;
        if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
            return;
        if (toI < children.length) {
            let after = children[toI];
            if (after && toOff < after.length) {
                if (fromI == toI) {
                    after = after.split(toOff);
                    toOff = 0;
                }
                if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                    insert[insert.length - 1] = after;
                } else {
                    if (toOff)
                        after.merge(0, toOff, null, false, 0, openEnd);
                    insert.push(after);
                }
            } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
                if (last)
                    last.breakAfter = 1;
                else
                    breakAtStart = 1;
            }
            toI++;
        }
        if (before) {
            before.breakAfter = breakAtStart;
            if (fromOff > 0) {
                if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
                    before.breakAfter = insert.shift().breakAfter;
                } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                    before.merge(fromOff, before.length, null, false, openStart, 0);
                }
                fromI++;
            }
        }
        while (fromI < toI && insert.length) {
            if (children[toI - 1].become(insert[insert.length - 1])) {
                toI--;
                insert.pop();
                openEnd = insert.length ? 0 : openStart;
            } else if (children[fromI].become(insert[0])) {
                fromI++;
                insert.shift();
                openStart = insert.length ? 0 : openEnd;
            } else {
                break;
            }
        }
        if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
            fromI--;
        if (fromI < toI || insert.length)
            parent.replaceChildren(fromI, toI, insert);
    }
    function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
        let cur = parent.childCursor();
        let {i: toI, off: toOff} = cur.findPos(to, 1);
        let {i: fromI, off: fromOff} = cur.findPos(from, -1);
        let dLen = from - to;
        for (let _i38 = 0, _length38 = insert.length; _i38 < _length38; _i38++) {
            let view = insert[_i38];
            dLen += view.length;
        }
        parent.length += dLen;
        replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
    }
    let nav = typeof navigator != "undefined" ? navigator : {
        userAgent: "",
        vendor: "",
        platform: ""
    };
    let doc = typeof document != "undefined" ? document : {
        documentElement: {
            style: {}
        }
    };
    const ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
    const ie_upto10 = /MSIE \d/.test(nav.userAgent);
    const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
    const ie = !!(ie_upto10 || ie_11up || ie_edge);
    const gecko = !ie && /gecko\/(\d+)/i.test(nav.userAgent);
    const chrome = !ie && /Chrome\/(\d+)/.exec(nav.userAgent);
    const webkit = ("webkitFontSmoothing" in doc.documentElement.style);
    const safari = !ie && /Apple Computer/.test(nav.vendor);
    const ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
    var browser = {
        mac: ios || /Mac/.test(nav.platform),
        windows: /Win/.test(nav.platform),
        linux: /Linux|X11/.test(nav.platform),
        ie,
        ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
        gecko,
        gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
        chrome: !!chrome,
        chrome_version: chrome ? +chrome[1] : 0,
        ios,
        android: /Android\b/.test(nav.userAgent),
        webkit,
        safari,
        webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
        tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
    };
    const MaxJoinLen = 256;
    class TextView extends ContentView {
        constructor(text)
        {
            super();
            this.text = text;
        }
        get length()
        {
            return this.text.length;
        }
        createDOM(textDOM)
        {
            this.setDOM(textDOM || document.createTextNode(this.text));
        }
        sync(track)
        {
            if (!this.dom)
                this.createDOM();
            if (this.dom.nodeValue != this.text) {
                if (track && track.node == this.dom)
                    track.written = true;
                this.dom.nodeValue = this.text;
            }
        }
        reuseDOM(dom)
        {
            if (dom.nodeType == 3)
                this.createDOM(dom);
        }
        merge(from, to, source)
        {
            if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
                return false;
            this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
            this.markDirty();
            return true;
        }
        split(from)
        {
            let result = new TextView(this.text.slice(from));
            this.text = this.text.slice(0, from);
            this.markDirty();
            return result;
        }
        localPosFromDOM(node, offset)
        {
            return node == this.dom ? offset : offset ? this.text.length : 0;
        }
        domAtPos(pos)
        {
            return new DOMPos(this.dom, pos);
        }
        domBoundsAround(_from, _to, offset)
        {
            return {
                from: offset,
                to: offset + this.length,
                startDOM: this.dom,
                endDOM: this.dom.nextSibling
            };
        }
        coordsAt(pos, side)
        {
            return textCoords(this.dom, pos, side);
        }
    }
    class MarkView extends ContentView {
        constructor(mark, children=[], length=0)
        {
            super();
            this.mark = mark;
            this.children = children;
            this.length = length;
            for (let _i39 = 0, _length39 = children.length; _i39 < _length39; _i39++) {
                let ch = children[_i39];
                ch.setParent(this);
            }
        }
        setAttrs(dom)
        {
            clearAttributes(dom);
            if (this.mark.class)
                dom.className = this.mark.class;
            if (this.mark.attrs)
                for (let name in this.mark.attrs)
                    dom.setAttribute(name, this.mark.attrs[name]);
            return dom;
        }
        reuseDOM(node)
        {
            if (node.nodeName == this.mark.tagName.toUpperCase()) {
                this.setDOM(node);
                this.dirty |= 4 | 2;
            }
        }
        sync(track)
        {
            if (!this.dom)
                this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
            else if (this.dirty & 4)
                this.setAttrs(this.dom);
            super.sync(track);
        }
        merge(from, to, source, _hasStart, openStart, openEnd)
        {
            if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
                return false;
            mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
            this.markDirty();
            return true;
        }
        split(from)
        {
            let result = [],
                off = 0,
                detachFrom = -1,
                i = 0;
            for (let _i40 = 0, _this$children5 = this.children, _length40 = _this$children5.length; _i40 < _length40; _i40++) {
                let elt = _this$children5[_i40];
                let end = off + elt.length;
                if (end > from)
                    result.push(off < from ? elt.split(from - off) : elt);
                if (detachFrom < 0 && off >= from)
                    detachFrom = i;
                off = end;
                i++;
            }
            let length = this.length - from;
            this.length = from;
            if (detachFrom > -1) {
                this.children.length = detachFrom;
                this.markDirty();
            }
            return new MarkView(this.mark, result, length);
        }
        domAtPos(pos)
        {
            return inlineDOMAtPos(this, pos);
        }
        coordsAt(pos, side)
        {
            return coordsInChildren(this, pos, side);
        }
    }
    function textCoords(text, pos, side) {
        let length = text.nodeValue.length;
        if (pos > length)
            pos = length;
        let from = pos,
            to = pos,
            flatten = 0;
        if (pos == 0 && side < 0 || pos == length && side >= 0) {
            if (!(browser.chrome || browser.gecko)) {
                if (pos) {
                    from--;
                    flatten = 1;
                } else if (to < length) {
                    to++;
                    flatten = -1;
                }
            }
        } else {
            if (side < 0)
                from--;
            else if (to < length)
                to++;
        }
        let rects = textRange(text, from, to).getClientRects();
        if (!rects.length)
            return Rect0;
        let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
        if (browser.safari && !flatten && rect.width == 0)
            rect = Array.prototype.find.call(rects, r => r.width) || rect;
        return flatten ? flattenRect(rect, flatten < 0) : rect || null;
    }
    class WidgetView extends ContentView {
        constructor(widget, length, side)
        {
            super();
            this.widget = widget;
            this.length = length;
            this.side = side;
            this.prevWidget = null;
        }
        static create(widget, length, side)
        {
            return new (widget.customView || WidgetView)(widget, length, side);
        }
        split(from)
        {
            let result = WidgetView.create(this.widget, this.length - from, this.side);
            this.length -= from;
            return result;
        }
        sync()
        {
            if (!this.dom || !this.widget.updateDOM(this.dom)) {
                if (this.dom && this.prevWidget)
                    this.prevWidget.destroy(this.dom);
                this.prevWidget = null;
                this.setDOM(this.widget.toDOM(this.editorView));
                this.dom.contentEditable = "false";
            }
        }
        getSide()
        {
            return this.side;
        }
        merge(from, to, source, hasStart, openStart, openEnd)
        {
            if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
                return false;
            this.length = from + (source ? source.length : 0) + (this.length - to);
            return true;
        }
        become(other)
        {
            if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
                if (this.widget.constructor == other.widget.constructor) {
                    if (!this.widget.eq(other.widget))
                        this.markDirty(true);
                    if (this.dom && !this.prevWidget)
                        this.prevWidget = this.widget;
                    this.widget = other.widget;
                    return true;
                }
            }
            return false;
        }
        ignoreMutation()
        {
            return true;
        }
        ignoreEvent(event)
        {
            return this.widget.ignoreEvent(event);
        }
        get overrideDOMText()
        {
            if (this.length == 0)
                return Text.empty;
            let top = this;
            while (top.parent)
                top = top.parent;
            let view = top.editorView,
                text = view && view.state.doc,
                start = this.posAtStart;
            return text ? text.slice(start, start + this.length) : Text.empty;
        }
        domAtPos(pos)
        {
            return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
        }
        domBoundsAround()
        {
            return null;
        }
        coordsAt(pos, side)
        {
            let rects = this.dom.getClientRects(),
                rect = null;
            if (!rects.length)
                return Rect0;
            for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
                rect = rects[i];
                if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
                    break;
            }
            return this.length ? rect : flattenRect(rect, this.side > 0);
        }
        get isEditable()
        {
            return false;
        }
        destroy()
        {
            super.destroy();
            if (this.dom)
                this.widget.destroy(this.dom);
        }
    }
    class CompositionView extends WidgetView {
        domAtPos(pos)
        {
            let {topView, text} = this.widget;
            if (!topView)
                return new DOMPos(text, Math.min(pos, text.nodeValue.length));
            return scanCompositionTree(pos, 0, topView, text, (v, p) => v.domAtPos(p), p => new DOMPos(text, Math.min(p, text.nodeValue.length)));
        }
        sync()
        {
            this.setDOM(this.widget.toDOM());
        }
        localPosFromDOM(node, offset)
        {
            let {topView, text} = this.widget;
            if (!topView)
                return Math.min(offset, this.length);
            return posFromDOMInCompositionTree(node, offset, topView, text);
        }
        ignoreMutation()
        {
            return false;
        }
        get overrideDOMText()
        {
            return null;
        }
        coordsAt(pos, side)
        {
            let {topView, text} = this.widget;
            if (!topView)
                return textCoords(text, pos, side);
            return scanCompositionTree(pos, side, topView, text, (v, pos, side) => v.coordsAt(pos, side), (pos, side) => textCoords(text, pos, side));
        }
        destroy()
        {
            var _a;
            super.destroy();
            (_a = this.widget.topView) === null || _a === void 0 ? void 0 : _a.destroy();
        }
        get isEditable()
        {
            return true;
        }
        canReuseDOM()
        {
            return true;
        }
    }
    function scanCompositionTree(pos, side, view, text, enterView, fromText) {
        if (view instanceof MarkView) {
            for (let child = view.dom.firstChild; child; child = child.nextSibling) {
                let desc = ContentView.get(child);
                if (!desc)
                    return fromText(pos, side);
                let hasComp = contains(child, text);
                let len = desc.length + (hasComp ? text.nodeValue.length : 0);
                if (pos < len || pos == len && desc.getSide() <= 0)
                    return hasComp ? scanCompositionTree(pos, side, desc, text, enterView, fromText) : enterView(desc, pos, side);
                pos -= len;
            }
            return enterView(view, view.length, -1);
        } else if (view.dom == text) {
            return fromText(pos, side);
        } else {
            return enterView(view, pos, side);
        }
    }
    function posFromDOMInCompositionTree(node, offset, view, text) {
        if (view instanceof MarkView) {
            for (let _i41 = 0, _view$children = view.children, _length41 = _view$children.length; _i41 < _length41; _i41++) {
                let child = _view$children[_i41];
                let pos = 0,
                    hasComp = contains(child.dom, text);
                if (contains(child.dom, node))
                    return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));
                pos += hasComp ? text.nodeValue.length : child.length;
            }
        } else if (view.dom == text) {
            return Math.min(offset, text.nodeValue.length);
        }
        return view.localPosFromDOM(node, offset);
    }
    class WidgetBufferView extends ContentView {
        constructor(side)
        {
            super();
            this.side = side;
        }
        get length()
        {
            return 0;
        }
        merge()
        {
            return false;
        }
        become(other)
        {
            return other instanceof WidgetBufferView && other.side == this.side;
        }
        split()
        {
            return new WidgetBufferView(this.side);
        }
        sync()
        {
            if (!this.dom) {
                let dom = document.createElement("img");
                dom.className = "cm-widgetBuffer";
                dom.setAttribute("aria-hidden", "true");
                this.setDOM(dom);
            }
        }
        getSide()
        {
            return this.side;
        }
        domAtPos(pos)
        {
            return DOMPos.before(this.dom);
        }
        localPosFromDOM()
        {
            return 0;
        }
        domBoundsAround()
        {
            return null;
        }
        coordsAt(pos)
        {
            let imgRect = this.dom.getBoundingClientRect();
            let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
            return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? {
                left: imgRect.left,
                right: imgRect.right,
                top: siblingRect.top,
                bottom: siblingRect.bottom
            } : imgRect;
        }
        get overrideDOMText()
        {
            return Text.empty;
        }
    }
    TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
    function inlineSiblingRect(view, side) {
        let parent = view.parent,
            index = parent ? parent.children.indexOf(view) : -1;
        while (parent && index >= 0) {
            if (side < 0 ? index > 0 : index < parent.children.length) {
                let next = parent.children[index + side];
                if (next instanceof TextView) {
                    let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
                    if (nextRect)
                        return nextRect;
                }
                index += side;
            } else if (parent instanceof MarkView && parent.parent) {
                index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
                parent = parent.parent;
            } else {
                let last = parent.dom.lastChild;
                if (last && last.nodeName == "BR")
                    return last.getClientRects()[0];
                break;
            }
        }
        return undefined;
    }
    function inlineDOMAtPos(parent, pos) {
        let dom = parent.dom,
            {children} = parent,
            i = 0;
        for (let off = 0; i < children.length; i++) {
            let child = children[i],
                end = off + child.length;
            if (end == off && child.getSide() <= 0)
                continue;
            if (pos > off && pos < end && child.dom.parentNode == dom)
                return child.domAtPos(pos - off);
            if (pos <= off)
                break;
            off = end;
        }
        for (let j = i; j > 0; j--) {
            let prev = children[j - 1];
            if (prev.dom.parentNode == dom)
                return prev.domAtPos(prev.length);
        }
        for (let j = i; j < children.length; j++) {
            let next = children[j];
            if (next.dom.parentNode == dom)
                return next.domAtPos(0);
        }
        return new DOMPos(dom, 0);
    }
    function joinInlineInto(parent, view, open) {
        let last,
            {children} = parent;
        if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
            joinInlineInto(last, view.children[0], open - 1);
        } else {
            children.push(view);
            view.setParent(parent);
        }
        parent.length += view.length;
    }
    function coordsInChildren(view, pos, side) {
        let before = null,
            beforePos = -1,
            after = null,
            afterPos = -1;
        function scan(view, pos) {
            for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {
                let child = view.children[i],
                    end = off + child.length;
                if (end >= pos) {
                    if (child.children.length) {
                        scan(child, pos - off);
                    } else if (!after && (end > pos || off == end && child.getSide() > 0)) {
                        after = child;
                        afterPos = pos - off;
                    } else if (off < pos || off == end && child.getSide() < 0) {
                        before = child;
                        beforePos = pos - off;
                    }
                }
                off = end;
            }
        }
        scan(view, pos);
        let target = (side < 0 ? before : after) || before || after;
        if (target)
            return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
        return fallbackRect(view);
    }
    function fallbackRect(view) {
        let last = view.dom.lastChild;
        if (!last)
            return view.dom.getBoundingClientRect();
        let rects = clientRectsFor(last);
        return rects[rects.length - 1] || null;
    }
    function combineAttrs(source, target) {
        for (let name in source) {
            if (name == "class" && target.class)
                target.class += " " + source.class;
            else if (name == "style" && target.style)
                target.style += ";" + source.style;
            else
                target[name] = source[name];
        }
        return target;
    }
    function attrsEq(a, b) {
        if (a == b)
            return true;
        if (!a || !b)
            return false;
        let keysA = Object.keys(a),
            keysB = Object.keys(b);
        if (keysA.length != keysB.length)
            return false;
        for (let _i42 = 0, _length42 = keysA.length; _i42 < _length42; _i42++) {
            let key = keysA[_i42];
            if (keysB.indexOf(key) == -1 || a[key] !== b[key])
                return false;
        }
        return true;
    }
    function updateAttrs(dom, prev, attrs) {
        let changed = null;
        if (prev)
            for (let name in prev)
                if (!(attrs && name in attrs))
                    dom.removeAttribute(changed = name);
        if (attrs)
            for (let name in attrs)
                if (!(prev && prev[name] == attrs[name]))
                    dom.setAttribute(changed = name, attrs[name]);
        return !!changed;
    }
    class WidgetType {
        eq(widget)
        {
            return false;
        }
        updateDOM(dom)
        {
            return false;
        }
        compare(other)
        {
            return this == other || this.constructor == other.constructor && this.eq(other);
        }
        get estimatedHeight()
        {
            return -1;
        }
        ignoreEvent(event)
        {
            return true;
        }
        get customView()
        {
            return null;
        }
        destroy(dom) {}
    }
    var BlockType = function(BlockType) {
        BlockType[BlockType["Text"] = 0] = "Text";
        BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
        BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
        BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
        return BlockType;
    }(BlockType || (BlockType = {}));
    class Decoration extends RangeValue {
        constructor(startSide, endSide, widget, spec)
        {
            super();
            this.startSide = startSide;
            this.endSide = endSide;
            this.widget = widget;
            this.spec = spec;
        }
        get heightRelevant()
        {
            return false;
        }
        static mark(spec)
        {
            return new MarkDecoration(spec);
        }
        static widget(spec)
        {
            let side = spec.side || 0,
                block = !!spec.block;
            side += block ? side > 0 ? 300000000 : -400000000 : side > 0 ? 100000000 : -100000000;
            return new PointDecoration(spec, side, side, block, spec.widget || null, false);
        }
        static replace(spec)
        {
            let block = !!spec.block,
                startSide,
                endSide;
            if (spec.isBlockGap) {
                startSide = -500000000;
                endSide = 400000000;
            } else {
                let {start, end} = getInclusive(spec, block);
                startSide = (start ? block ? -300000000 : -1 : 500000000) - 1;
                endSide = (end ? block ? 200000000 : 1 : -600000000) + 1;
            }
            return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
        }
        static line(spec)
        {
            return new LineDecoration(spec);
        }
        static set(of, sort=false)
        {
            return RangeSet.of(of, sort);
        }
        hasHeight()
        {
            return this.widget ? this.widget.estimatedHeight > -1 : false;
        }
    }
    Decoration.none = RangeSet.empty;
    class MarkDecoration extends Decoration {
        constructor(spec)
        {
            let {start, end} = getInclusive(spec);
            super(start ? -1 : 500000000, end ? 1 : -600000000, null, spec);
            this.tagName = spec.tagName || "span";
            this.class = spec.class || "";
            this.attrs = spec.attributes || null;
        }
        eq(other)
        {
            return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
        }
        range(from, to=from)
        {
            if (from >= to)
                throw new RangeError("Mark decorations may not be empty");
            return super.range(from, to);
        }
    }
    MarkDecoration.prototype.point = false;
    class LineDecoration extends Decoration {
        constructor(spec)
        {
            super(-200000000, -200000000, null, spec);
        }
        eq(other)
        {
            return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
        }
        range(from, to=from)
        {
            if (to != from)
                throw new RangeError("Line decoration ranges must be zero-length");
            return super.range(from, to);
        }
    }
    LineDecoration.prototype.mapMode = MapMode.TrackBefore;
    LineDecoration.prototype.point = true;
    class PointDecoration extends Decoration {
        constructor(spec, startSide, endSide, block, widget, isReplace)
        {
            super(startSide, endSide, widget, spec);
            this.block = block;
            this.isReplace = isReplace;
            this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
        }
        get type()
        {
            return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
        }
        get heightRelevant()
        {
            return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
        }
        eq(other)
        {
            return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
        }
        range(from, to=from)
        {
            if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
                throw new RangeError("Invalid range for replacement decoration");
            if (!this.isReplace && to != from)
                throw new RangeError("Widget decorations can only have zero-length ranges");
            return super.range(from, to);
        }
    }
    PointDecoration.prototype.point = true;
    function getInclusive(spec, block=false) {
        let {inclusiveStart: start, inclusiveEnd: end} = spec;
        if (start == null)
            start = spec.inclusive;
        if (end == null)
            end = spec.inclusive;
        return {
            start: start !== null && start !== void 0 ? start : block,
            end: end !== null && end !== void 0 ? end : block
        };
    }
    function widgetsEq(a, b) {
        return a == b || !!(a && b && a.compare(b));
    }
    function addRange(from, to, ranges, margin=0) {
        let last = ranges.length - 1;
        if (last >= 0 && ranges[last] + margin >= from)
            ranges[last] = Math.max(ranges[last], to);
        else
            ranges.push(from, to);
    }
    class LineView extends ContentView {
        constructor()
        {
            super(...arguments);
            this.children = [];
            this.length = 0;
            this.prevAttrs = undefined;
            this.attrs = null;
            this.breakAfter = 0;
        }
        merge(from, to, source, hasStart, openStart, openEnd)
        {
            if (source) {
                if (!(source instanceof LineView))
                    return false;
                if (!this.dom)
                    source.transferDOM(this);
            }
            if (hasStart)
                this.setDeco(source ? source.attrs : null);
            mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
            return true;
        }
        split(at)
        {
            let end = new LineView();
            end.breakAfter = this.breakAfter;
            if (this.length == 0)
                return end;
            let {i, off} = this.childPos(at);
            if (off) {
                end.append(this.children[i].split(off), 0);
                this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
                i++;
            }
            for (let j = i; j < this.children.length; j++)
                end.append(this.children[j], 0);
            while (i > 0 && this.children[i - 1].length == 0)
                this.children[--i].destroy();
            this.children.length = i;
            this.markDirty();
            this.length = at;
            return end;
        }
        transferDOM(other)
        {
            if (!this.dom)
                return;
            this.markDirty();
            other.setDOM(this.dom);
            other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
            this.prevAttrs = undefined;
            this.dom = null;
        }
        setDeco(attrs)
        {
            if (!attrsEq(this.attrs, attrs)) {
                if (this.dom) {
                    this.prevAttrs = this.attrs;
                    this.markDirty();
                }
                this.attrs = attrs;
            }
        }
        append(child, openStart)
        {
            joinInlineInto(this, child, openStart);
        }
        addLineDeco(deco)
        {
            let attrs = deco.spec.attributes,
                cls = deco.spec.class;
            if (attrs)
                this.attrs = combineAttrs(attrs, this.attrs || {});
            if (cls)
                this.attrs = combineAttrs({
                    class: cls
                }, this.attrs || {});
        }
        domAtPos(pos)
        {
            return inlineDOMAtPos(this, pos);
        }
        reuseDOM(node)
        {
            if (node.nodeName == "DIV") {
                this.setDOM(node);
                this.dirty |= 4 | 2;
            }
        }
        sync(track)
        {
            var _a;
            if (!this.dom) {
                this.setDOM(document.createElement("div"));
                this.dom.className = "cm-line";
                this.prevAttrs = this.attrs ? null : undefined;
            } else if (this.dirty & 4) {
                clearAttributes(this.dom);
                this.dom.className = "cm-line";
                this.prevAttrs = this.attrs ? null : undefined;
            }
            if (this.prevAttrs !== undefined) {
                updateAttrs(this.dom, this.prevAttrs, this.attrs);
                this.dom.classList.add("cm-line");
                this.prevAttrs = undefined;
            }
            super.sync(track);
            let last = this.dom.lastChild;
            while (last && ContentView.get(last) instanceof MarkView)
                last = last.lastChild;
            if (!last || !this.length || last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
                let hack = document.createElement("BR");
                hack.cmIgnore = true;
                this.dom.appendChild(hack);
            }
        }
        measureTextSize()
        {
            if (this.children.length == 0 || this.length > 20)
                return null;
            let totalWidth = 0;
            for (let _i43 = 0, _this$children6 = this.children, _length43 = _this$children6.length; _i43 < _length43; _i43++) {
                let child = _this$children6[_i43];
                if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
                    return null;
                let rects = clientRectsFor(child.dom);
                if (rects.length != 1)
                    return null;
                totalWidth += rects[0].width;
            }
            return !totalWidth ? null : {
                lineHeight: this.dom.getBoundingClientRect().height,
                charWidth: totalWidth / this.length
            };
        }
        coordsAt(pos, side)
        {
            return coordsInChildren(this, pos, side);
        }
        become(_other)
        {
            return false;
        }
        get type()
        {
            return BlockType.Text;
        }
        static find(docView, pos)
        {
            for (let i = 0, off = 0; i < docView.children.length; i++) {
                let block = docView.children[i],
                    end = off + block.length;
                if (end >= pos) {
                    if (block instanceof LineView)
                        return block;
                    if (end > pos)
                        break;
                }
                off = end + block.breakAfter;
            }
            return null;
        }
    }
    class BlockWidgetView extends ContentView {
        constructor(widget, length, type)
        {
            super();
            this.widget = widget;
            this.length = length;
            this.type = type;
            this.breakAfter = 0;
            this.prevWidget = null;
        }
        merge(from, to, source, _takeDeco, openStart, openEnd)
        {
            if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
                return false;
            this.length = from + (source ? source.length : 0) + (this.length - to);
            return true;
        }
        domAtPos(pos)
        {
            return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
        }
        split(at)
        {
            let len = this.length - at;
            this.length = at;
            let end = new BlockWidgetView(this.widget, len, this.type);
            end.breakAfter = this.breakAfter;
            return end;
        }
        get children()
        {
            return noChildren;
        }
        sync()
        {
            if (!this.dom || !this.widget.updateDOM(this.dom)) {
                if (this.dom && this.prevWidget)
                    this.prevWidget.destroy(this.dom);
                this.prevWidget = null;
                this.setDOM(this.widget.toDOM(this.editorView));
                this.dom.contentEditable = "false";
            }
        }
        get overrideDOMText()
        {
            return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
        }
        domBoundsAround()
        {
            return null;
        }
        become(other)
        {
            if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
                if (!other.widget.eq(this.widget))
                    this.markDirty(true);
                if (this.dom && !this.prevWidget)
                    this.prevWidget = this.widget;
                this.widget = other.widget;
                this.length = other.length;
                this.breakAfter = other.breakAfter;
                return true;
            }
            return false;
        }
        ignoreMutation()
        {
            return true;
        }
        ignoreEvent(event)
        {
            return this.widget.ignoreEvent(event);
        }
        destroy()
        {
            super.destroy();
            if (this.dom)
                this.widget.destroy(this.dom);
        }
    }
    class ContentBuilder {
        constructor(doc, pos, end, disallowBlockEffectsFor)
        {
            this.doc = doc;
            this.pos = pos;
            this.end = end;
            this.disallowBlockEffectsFor = disallowBlockEffectsFor;
            this.content = [];
            this.curLine = null;
            this.breakAtStart = 0;
            this.pendingBuffer = 0;
            this.bufferMarks = [];
            this.atCursorPos = true;
            this.openStart = -1;
            this.openEnd = -1;
            this.text = "";
            this.textOff = 0;
            this.cursor = doc.iter();
            this.skip = pos;
        }
        posCovered()
        {
            if (this.content.length == 0)
                return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
            let last = this.content[this.content.length - 1];
            return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
        }
        getLine()
        {
            if (!this.curLine) {
                this.content.push(this.curLine = new LineView());
                this.atCursorPos = true;
            }
            return this.curLine;
        }
        flushBuffer(active=this.bufferMarks)
        {
            if (this.pendingBuffer) {
                this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
                this.pendingBuffer = 0;
            }
        }
        addBlockWidget(view)
        {
            this.flushBuffer();
            this.curLine = null;
            this.content.push(view);
        }
        finish(openEnd)
        {
            if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
                this.flushBuffer();
            else
                this.pendingBuffer = 0;
            if (!this.posCovered())
                this.getLine();
        }
        buildText(length, active, openStart)
        {
            while (length > 0) {
                if (this.textOff == this.text.length) {
                    let {value, lineBreak, done} = this.cursor.next(this.skip);
                    this.skip = 0;
                    if (done)
                        throw new Error("Ran out of text content when drawing inline views");
                    if (lineBreak) {
                        if (!this.posCovered())
                            this.getLine();
                        if (this.content.length)
                            this.content[this.content.length - 1].breakAfter = 1;
                        else
                            this.breakAtStart = 1;
                        this.flushBuffer();
                        this.curLine = null;
                        this.atCursorPos = true;
                        length--;
                        continue;
                    } else {
                        this.text = value;
                        this.textOff = 0;
                    }
                }
                let take = Math.min(this.text.length - this.textOff, length, 512);
                this.flushBuffer(active.slice(active.length - openStart));
                this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
                this.atCursorPos = true;
                this.textOff += take;
                length -= take;
                openStart = 0;
            }
        }
        span(from, to, active, openStart)
        {
            this.buildText(to - from, active, openStart);
            this.pos = to;
            if (this.openStart < 0)
                this.openStart = openStart;
        }
        point(from, to, deco, active, openStart, index)
        {
            if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
                if (deco.block)
                    throw new RangeError("Block decorations may not be specified via plugins");
                if (to > this.doc.lineAt(this.pos).to)
                    throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
            }
            let len = to - from;
            if (deco instanceof PointDecoration) {
                if (deco.block) {
                    let {type} = deco;
                    if (type == BlockType.WidgetAfter && !this.posCovered())
                        this.getLine();
                    this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
                } else {
                    let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
                    let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
                    let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
                    let line = this.getLine();
                    if (this.pendingBuffer == 2 && !cursorBefore)
                        this.pendingBuffer = 0;
                    this.flushBuffer(active);
                    if (cursorBefore) {
                        line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                        openStart = active.length + Math.max(0, openStart - active.length);
                    }
                    line.append(wrapMarks(view, active), openStart);
                    this.atCursorPos = cursorAfter;
                    this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
                    if (this.pendingBuffer)
                        this.bufferMarks = active.slice();
                }
            } else if (this.doc.lineAt(this.pos).from == this.pos) {
                this.getLine().addLineDeco(deco);
            }
            if (len) {
                if (this.textOff + len <= this.text.length) {
                    this.textOff += len;
                } else {
                    this.skip += len - (this.text.length - this.textOff);
                    this.text = "";
                    this.textOff = 0;
                }
                this.pos = to;
            }
            if (this.openStart < 0)
                this.openStart = openStart;
        }
        static build(text, from, to, decorations, dynamicDecorationMap)
        {
            let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
            builder.openEnd = RangeSet.spans(decorations, from, to, builder);
            if (builder.openStart < 0)
                builder.openStart = builder.openEnd;
            builder.finish(builder.openEnd);
            return builder;
        }
    }
    function wrapMarks(view, active) {
        for (let _i44 = 0, _length44 = active.length; _i44 < _length44; _i44++) {
            let mark = active[_i44];
            view = new MarkView(mark, [view], view.length);
        }
        return view;
    }
    class NullWidget extends WidgetType {
        constructor(tag)
        {
            super();
            this.tag = tag;
        }
        eq(other)
        {
            return other.tag == this.tag;
        }
        toDOM()
        {
            return document.createElement(this.tag);
        }
        updateDOM(elt)
        {
            return elt.nodeName.toLowerCase() == this.tag;
        }
    }
    const clickAddsSelectionRange = Facet.define();
    const dragMovesSelection$1 = Facet.define();
    const mouseSelectionStyle = Facet.define();
    const exceptionSink = Facet.define();
    const updateListener = Facet.define();
    const inputHandler$1 = Facet.define();
    const perLineTextDirection = Facet.define({
        combine: values => values.some(x => x)
    });
    const nativeSelectionHidden = Facet.define({
        combine: values => values.some(x => x)
    });
    class ScrollTarget {
        constructor(range, y="nearest", x="nearest", yMargin=5, xMargin=5)
        {
            this.range = range;
            this.y = y;
            this.x = x;
            this.yMargin = yMargin;
            this.xMargin = xMargin;
        }
        map(changes)
        {
            return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
        }
    }
    const scrollIntoView$1 = StateEffect.define({
        map: (t, ch) => t.map(ch)
    });
    function logException(state, exception, context) {
        let handler = state.facet(exceptionSink);
        if (handler.length)
            handler[0](exception);
        else if (window.onerror)
            window.onerror(String(exception), context, undefined, undefined, exception);
        else if (context)
            console.error(context + ":", exception);
        else
            console.error(exception);
    }
    const editable = Facet.define({
        combine: values => values.length ? values[0] : true
    });
    let nextPluginID = 0;
    const viewPlugin = Facet.define();
    class ViewPlugin {
        constructor(id, create, domEventHandlers, buildExtensions)
        {
            this.id = id;
            this.create = create;
            this.domEventHandlers = domEventHandlers;
            this.extension = buildExtensions(this);
        }
        static define(create, spec)
        {
            const {eventHandlers, provide, decorations: deco} = spec || {};
            return new ViewPlugin(nextPluginID++, create, eventHandlers, plugin => {
                let ext = [viewPlugin.of(plugin)];
                if (deco)
                    ext.push(decorations.of(view => {
                        let pluginInst = view.plugin(plugin);
                        return pluginInst ? deco(pluginInst) : Decoration.none;
                    }));
                if (provide)
                    ext.push(provide(plugin));
                return ext;
            });
        }
        static fromClass(cls, spec)
        {
            return ViewPlugin.define(view => new cls(view), spec);
        }
    }
    class PluginInstance {
        constructor(spec)
        {
            this.spec = spec;
            this.mustUpdate = null;
            this.value = null;
        }
        update(view)
        {
            if (!this.value) {
                if (this.spec) {
                    try {
                        this.value = this.spec.create(view);
                    } catch (e) {
                        logException(view.state, e, "CodeMirror plugin crashed");
                        this.deactivate();
                    }
                }
            } else if (this.mustUpdate) {
                let update = this.mustUpdate;
                this.mustUpdate = null;
                if (this.value.update) {
                    try {
                        this.value.update(update);
                    } catch (e) {
                        logException(update.state, e, "CodeMirror plugin crashed");
                        if (this.value.destroy)
                            try {
                                this.value.destroy();
                            } catch (_) {}
                        this.deactivate();
                    }
                }
            }
            return this;
        }
        destroy(view)
        {
            var _a;
            if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
                try {
                    this.value.destroy();
                } catch (e) {
                    logException(view.state, e, "CodeMirror plugin crashed");
                }
            }
        }
        deactivate()
        {
            this.spec = this.value = null;
        }
    }
    const editorAttributes = Facet.define();
    const contentAttributes = Facet.define();
    const decorations = Facet.define();
    const atomicRanges = Facet.define();
    const scrollMargins = Facet.define();
    const styleModule = Facet.define();
    class ChangedRange {
        constructor(fromA, toA, fromB, toB)
        {
            this.fromA = fromA;
            this.toA = toA;
            this.fromB = fromB;
            this.toB = toB;
        }
        join(other)
        {
            return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
        }
        addToSet(set)
        {
            let i = set.length,
                me = this;
            for (; i > 0; i--) {
                let range = set[i - 1];
                if (range.fromA > me.toA)
                    continue;
                if (range.toA < me.fromA)
                    break;
                me = me.join(range);
                set.splice(i - 1, 1);
            }
            set.splice(i, 0, me);
            return set;
        }
        static extendWithRanges(diff, ranges)
        {
            if (ranges.length == 0)
                return diff;
            let result = [];
            for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
                let next = dI == diff.length ? null : diff[dI],
                    off = posA - posB;
                let end = next ? next.fromB : 1e9;
                while (rI < ranges.length && ranges[rI] < end) {
                    let from = ranges[rI],
                        to = ranges[rI + 1];
                    let fromB = Math.max(posB, from),
                        toB = Math.min(end, to);
                    if (fromB <= toB)
                        new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                    if (to > end)
                        break;
                    else
                        rI += 2;
                }
                if (!next)
                    return result;
                new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
                posA = next.toA;
                posB = next.toB;
            }
        }
    }
    class ViewUpdate {
        constructor(view, state, transactions)
        {
            this.view = view;
            this.state = state;
            this.transactions = transactions;
            this.flags = 0;
            this.startState = view.state;
            this.changes = ChangeSet.empty(this.startState.doc.length);
            for (let _i45 = 0, _length45 = transactions.length; _i45 < _length45; _i45++) {
                let tr = transactions[_i45];
                this.changes = this.changes.compose(tr.changes);
            }
            let changedRanges = [];
            this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
            this.changedRanges = changedRanges;
            let focus = view.hasFocus;
            if (focus != view.inputState.notifiedFocused) {
                view.inputState.notifiedFocused = focus;
                this.flags |= 1;
            }
        }
        static create(view, state, transactions)
        {
            return new ViewUpdate(view, state, transactions);
        }
        get viewportChanged()
        {
            return (this.flags & 4) > 0;
        }
        get heightChanged()
        {
            return (this.flags & 2) > 0;
        }
        get geometryChanged()
        {
            return this.docChanged || (this.flags & (8 | 2)) > 0;
        }
        get focusChanged()
        {
            return (this.flags & 1) > 0;
        }
        get docChanged()
        {
            return !this.changes.empty;
        }
        get selectionSet()
        {
            return this.transactions.some(tr => tr.selection);
        }
        get empty()
        {
            return this.flags == 0 && this.transactions.length == 0;
        }
    }
    var Direction = function(Direction) {
        Direction[Direction["LTR"] = 0] = "LTR";
        Direction[Direction["RTL"] = 1] = "RTL";
        return Direction;
    }(Direction || (Direction = {}));
    const LTR = Direction.LTR,
        RTL = Direction.RTL;
    function dec(str) {
        let result = [];
        for (let i = 0; i < str.length; i++)
            result.push(1 << +str[i]);
        return result;
    }
    const LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
    const ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
    const Brackets = Object.create(null),
        BracketStack = [];
    for (let _i46 = 0, _ref2 = ["()", "[]", "{}"], _length46 = _ref2.length; _i46 < _length46; _i46++) {
        let p = _ref2[_i46];
        let l = p.charCodeAt(0),
            r = p.charCodeAt(1);
        Brackets[l] = r;
        Brackets[r] = -l;
    }
    function charType(ch) {
        return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 : 0x2000 <= ch && ch <= 0x200b ? 256 : 0xfb50 <= ch && ch <= 0xfdff ? 4 : ch == 0x200c ? 256 : 1;
    }
    const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
    class BidiSpan {
        constructor(from, to, level)
        {
            this.from = from;
            this.to = to;
            this.level = level;
        }
        get dir()
        {
            return this.level % 2 ? RTL : LTR;
        }
        side(end, dir)
        {
            return this.dir == dir == end ? this.to : this.from;
        }
        static find(order, index, level, assoc)
        {
            let maybe = -1;
            for (let i = 0; i < order.length; i++) {
                let span = order[i];
                if (span.from <= index && span.to >= index) {
                    if (span.level == level)
                        return i;
                    if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
                        maybe = i;
                }
            }
            if (maybe < 0)
                throw new RangeError("Index out of range");
            return maybe;
        }
    }
    const types = [];
    function computeOrder(line, direction) {
        let len = line.length,
            outerType = direction == LTR ? 1 : 2,
            oppositeType = direction == LTR ? 2 : 1;
        if (!line || outerType == 1 && !BidiRE.test(line))
            return trivialOrder(len);
        for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
            let type = charType(line.charCodeAt(i));
            if (type == 512)
                type = prev;
            else if (type == 8 && prevStrong == 4)
                type = 16;
            types[i] = type == 4 ? 2 : type;
            if (type & 7)
                prevStrong = type;
            prev = type;
        }
        for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
            let type = types[i];
            if (type == 128) {
                if (i < len - 1 && prev == types[i + 1] && prev & 24)
                    type = types[i] = prev;
                else
                    types[i] = 256;
            } else if (type == 64) {
                let end = i + 1;
                while (end < len && types[end] == 64)
                    end++;
                let replace = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
                for (let j = i; j < end; j++)
                    types[j] = replace;
                i = end - 1;
            } else if (type == 8 && prevStrong == 1) {
                types[i] = 1;
            }
            prev = type;
            if (type & 7)
                prevStrong = type;
        }
        for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
            if (br = Brackets[ch = line.charCodeAt(i)]) {
                if (br < 0) {
                    for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                        if (BracketStack[sJ + 1] == -br) {
                            let flags = BracketStack[sJ + 2];
                            let type = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                            if (type)
                                types[i] = types[BracketStack[sJ]] = type;
                            sI = sJ;
                            break;
                        }
                    }
                } else if (BracketStack.length == 189) {
                    break;
                } else {
                    BracketStack[sI++] = i;
                    BracketStack[sI++] = ch;
                    BracketStack[sI++] = context;
                }
            } else if ((type = types[i]) == 2 || type == 1) {
                let embed = type == outerType;
                context = embed ? 0 : 1;
                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                    let cur = BracketStack[sJ + 2];
                    if (cur & 2)
                        break;
                    if (embed) {
                        BracketStack[sJ + 2] |= 2;
                    } else {
                        if (cur & 4)
                            break;
                        BracketStack[sJ + 2] |= 4;
                    }
                }
            }
        }
        for (let i = 0; i < len; i++) {
            if (types[i] == 256) {
                let end = i + 1;
                while (end < len && types[end] == 256)
                    end++;
                let beforeL = (i ? types[i - 1] : outerType) == 1;
                let afterL = (end < len ? types[end] : outerType) == 1;
                let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
                for (let j = i; j < end; j++)
                    types[j] = replace;
                i = end - 1;
            }
        }
        let order = [];
        if (outerType == 1) {
            for (let i = 0; i < len;) {
                let start = i,
                    rtl = types[i++] != 1;
                while (i < len && rtl == (types[i] != 1))
                    i++;
                if (rtl) {
                    for (let j = i; j > start;) {
                        let end = j,
                            l = types[--j] != 2;
                        while (j > start && l == (types[j - 1] != 2))
                            j--;
                        order.push(new BidiSpan(j, end, l ? 2 : 1));
                    }
                } else {
                    order.push(new BidiSpan(start, i, 0));
                }
            }
        } else {
            for (let i = 0; i < len;) {
                let start = i,
                    rtl = types[i++] == 2;
                while (i < len && rtl == (types[i] == 2))
                    i++;
                order.push(new BidiSpan(start, i, rtl ? 1 : 2));
            }
        }
        return order;
    }
    function trivialOrder(length) {
        return [new BidiSpan(0, length, 0)];
    }
    let movedOver = "";
    function moveVisually(line, order, dir, start, forward) {
        var _a;
        let startIndex = start.head - line.from,
            spanI = -1;
        if (startIndex == 0) {
            if (!forward || !line.length)
                return null;
            if (order[0].level != dir) {
                startIndex = order[0].side(false, dir);
                spanI = 0;
            }
        } else if (startIndex == line.length) {
            if (forward)
                return null;
            let last = order[order.length - 1];
            if (last.level != dir) {
                startIndex = last.side(true, dir);
                spanI = order.length - 1;
            }
        }
        if (spanI < 0)
            spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
        let span = order[spanI];
        if (startIndex == span.side(forward, dir)) {
            span = order[spanI += forward ? 1 : -1];
            startIndex = span.side(!forward, dir);
        }
        let indexForward = forward == (span.dir == dir);
        let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
        movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
        if (nextIndex != span.side(forward, dir))
            return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
        let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
        if (!nextSpan && span.level != dir)
            return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
        if (nextSpan && nextSpan.level < span.level)
            return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
        return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
    }
    const LineBreakPlaceholder = "\uffff";
    class DOMReader {
        constructor(points, state)
        {
            this.points = points;
            this.text = "";
            this.lineSeparator = state.facet(EditorState.lineSeparator);
        }
        append(text)
        {
            this.text += text;
        }
        lineBreak()
        {
            this.text += LineBreakPlaceholder;
        }
        readRange(start, end)
        {
            if (!start)
                return this;
            let parent = start.parentNode;
            for (let cur = start; ;) {
                this.findPointBefore(parent, cur);
                this.readNode(cur);
                let next = cur.nextSibling;
                if (next == end)
                    break;
                let view = ContentView.get(cur),
                    nextView = ContentView.get(next);
                if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore))
                    this.lineBreak();
                cur = next;
            }
            this.findPointBefore(parent, end);
            return this;
        }
        readTextNode(node)
        {
            let text = node.nodeValue;
            for (let _i47 = 0, _this$points = this.points, _length47 = _this$points.length; _i47 < _length47; _i47++) {
                let point = _this$points[_i47];
                if (point.node == node)
                    point.pos = this.text.length + Math.min(point.offset, text.length);
            }
            for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ;) {
                let nextBreak = -1,
                    breakSize = 1,
                    m;
                if (this.lineSeparator) {
                    nextBreak = text.indexOf(this.lineSeparator, off);
                    breakSize = this.lineSeparator.length;
                } else if (m = re.exec(text)) {
                    nextBreak = m.index;
                    breakSize = m[0].length;
                }
                this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
                if (nextBreak < 0)
                    break;
                this.lineBreak();
                if (breakSize > 1)
                    for (let _i48 = 0, _this$points2 = this.points, _length48 = _this$points2.length; _i48 < _length48; _i48++) {
                        let point = _this$points2[_i48];
                        if (point.node == node && point.pos > this.text.length)
                            point.pos -= breakSize - 1;
                    }
                off = nextBreak + breakSize;
            }
        }
        readNode(node)
        {
            if (node.cmIgnore)
                return;
            let view = ContentView.get(node);
            let fromView = view && view.overrideDOMText;
            if (fromView != null) {
                this.findPointInside(node, fromView.length);
                for (let i = fromView.iter(); !i.next().done;) {
                    if (i.lineBreak)
                        this.lineBreak();
                    else
                        this.append(i.value);
                }
            } else if (node.nodeType == 3) {
                this.readTextNode(node);
            } else if (node.nodeName == "BR") {
                if (node.nextSibling)
                    this.lineBreak();
            } else if (node.nodeType == 1) {
                this.readRange(node.firstChild, null);
            }
        }
        findPointBefore(node, next)
        {
            for (let _i49 = 0, _this$points3 = this.points, _length49 = _this$points3.length; _i49 < _length49; _i49++) {
                let point = _this$points3[_i49];
                if (point.node == node && node.childNodes[point.offset] == next)
                    point.pos = this.text.length;
            }
        }
        findPointInside(node, maxLen)
        {
            for (let _i50 = 0, _this$points4 = this.points, _length50 = _this$points4.length; _i50 < _length50; _i50++) {
                let point = _this$points4[_i50];
                if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
                    point.pos = this.text.length + Math.min(maxLen, point.offset);
            }
        }
    }
    function isBlockElement(node) {
        return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
    }
    class DOMPoint {
        constructor(node, offset)
        {
            this.node = node;
            this.offset = offset;
            this.pos = -1;
        }
    }
    class DocView extends ContentView {
        constructor(view)
        {
            super();
            this.view = view;
            this.compositionDeco = Decoration.none;
            this.decorations = [];
            this.dynamicDecorationMap = [];
            this.minWidth = 0;
            this.minWidthFrom = 0;
            this.minWidthTo = 0;
            this.impreciseAnchor = null;
            this.impreciseHead = null;
            this.forceSelection = false;
            this.lastUpdate = Date.now();
            this.setDOM(view.contentDOM);
            this.children = [new LineView()];
            this.children[0].setParent(this);
            this.updateDeco();
            this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
        }
        get editorView()
        {
            return this.view;
        }
        get length()
        {
            return this.view.state.doc.length;
        }
        update(update)
        {
            let changedRanges = update.changedRanges;
            if (this.minWidth > 0 && changedRanges.length) {
                if (!changedRanges.every(({fromA, toA}) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
                    this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
                } else {
                    this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                    this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
                }
            }
            if (this.view.inputState.composing < 0)
                this.compositionDeco = Decoration.none;
            else if (update.transactions.length || this.dirty)
                this.compositionDeco = computeCompositionDeco(this.view, update.changes);
            if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines)
                this.forceSelection = true;
            let prevDeco = this.decorations,
                deco = this.updateDeco();
            let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
            changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
            if (this.dirty == 0 && changedRanges.length == 0) {
                return false;
            } else {
                this.updateInner(changedRanges, update.startState.doc.length);
                if (update.transactions.length)
                    this.lastUpdate = Date.now();
                return true;
            }
        }
        updateInner(changes, oldLength)
        {
            this.view.viewState.mustMeasureContent = true;
            this.updateChildren(changes, oldLength);
            let {observer} = this.view;
            observer.ignore(() => {
                this.dom.style.height = this.view.viewState.contentHeight + "px";
                this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
                let track = browser.chrome || browser.ios ? {
                    node: observer.selectionRange.focusNode,
                    written: false
                } : undefined;
                this.sync(track);
                this.dirty = 0;
                if (track && (track.written || observer.selectionRange.focusNode != track.node))
                    this.forceSelection = true;
                this.dom.style.height = "";
            });
            let gaps = [];
            if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
                for (let _i51 = 0, _this$children7 = this.children, _length51 = _this$children7.length; _i51 < _length51; _i51++) {
                    let child = _this$children7[_i51];
                    if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                        gaps.push(child.dom);
                }
            observer.updateGaps(gaps);
        }
        updateChildren(changes, oldLength)
        {
            let cursor = this.childCursor(oldLength);
            for (let i = changes.length - 1; ; i--) {
                let next = i >= 0 ? changes[i] : null;
                if (!next)
                    break;
                let {fromA, toA, fromB, toB} = next;
                let {content, breakAtStart, openStart, openEnd} = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
                let {i: toI, off: toOff} = cursor.findPos(toA, 1);
                let {i: fromI, off: fromOff} = cursor.findPos(fromA, -1);
                replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
            }
        }
        updateSelection(mustRead=false, fromPointer=false)
        {
            if (mustRead || !this.view.observer.selectionRange.focusNode)
                this.view.observer.readSelectionRange();
            if (!(fromPointer || this.mayControlSelection()))
                return;
            let force = this.forceSelection;
            this.forceSelection = false;
            let main = this.view.state.selection.main;
            let anchor = this.domAtPos(main.anchor);
            let head = main.empty ? anchor : this.domAtPos(main.head);
            if (browser.gecko && main.empty && betweenUneditable(anchor)) {
                let dummy = document.createTextNode("");
                this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
                anchor = head = new DOMPos(dummy, 0);
                force = true;
            }
            let domSel = this.view.observer.selectionRange;
            if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
                this.view.observer.ignore(() => {
                    if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
                        this.dom.blur();
                        this.dom.focus({
                            preventScroll: true
                        });
                    }
                    let rawSel = getSelection(this.view.root);
                    if (!rawSel)
                        ;
                    else if (main.empty) {
                        if (browser.gecko) {
                            let nextTo = nextToUneditable(anchor.node, anchor.offset);
                            if (nextTo && nextTo != (1 | 2)) {
                                let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                                if (text)
                                    anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
                            }
                        }
                        rawSel.collapse(anchor.node, anchor.offset);
                        if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
                            domSel.cursorBidiLevel = main.bidiLevel;
                    } else if (rawSel.extend) {
                        rawSel.collapse(anchor.node, anchor.offset);
                        try {
                            rawSel.extend(head.node, head.offset);
                        } catch (_) {}
                    } else {
                        let range = document.createRange();
                        if (main.anchor > main.head)
                            [anchor, head] = [head, anchor];
                        range.setEnd(head.node, head.offset);
                        range.setStart(anchor.node, anchor.offset);
                        rawSel.removeAllRanges();
                        rawSel.addRange(range);
                    }
                });
                this.view.observer.setSelectionRange(anchor, head);
            }
            this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
            this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
        }
        enforceCursorAssoc()
        {
            if (this.compositionDeco.size)
                return;
            let {view} = this,
                cursor = view.state.selection.main;
            let sel = getSelection(view.root);
            let {anchorNode, anchorOffset} = view.observer.selectionRange;
            if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
                return;
            let line = LineView.find(this, cursor.head);
            if (!line)
                return;
            let lineStart = line.posAtStart;
            if (cursor.head == lineStart || cursor.head == lineStart + line.length)
                return;
            let before = this.coordsAt(cursor.head, -1),
                after = this.coordsAt(cursor.head, 1);
            if (!before || !after || before.bottom > after.top)
                return;
            let dom = this.domAtPos(cursor.head + cursor.assoc);
            sel.collapse(dom.node, dom.offset);
            sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
            view.observer.readSelectionRange();
            let newRange = view.observer.selectionRange;
            if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
                sel.collapse(anchorNode, anchorOffset);
        }
        mayControlSelection()
        {
            let active = this.view.root.activeElement;
            return active == this.dom || hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));
        }
        nearest(dom)
        {
            for (let cur = dom; cur;) {
                let domView = ContentView.get(cur);
                if (domView && domView.rootView == this)
                    return domView;
                cur = cur.parentNode;
            }
            return null;
        }
        posFromDOM(node, offset)
        {
            let view = this.nearest(node);
            if (!view)
                throw new RangeError("Trying to find position for a DOM position outside of the document");
            return view.localPosFromDOM(node, offset) + view.posAtStart;
        }
        domAtPos(pos)
        {
            let {i, off} = this.childCursor().findPos(pos, -1);
            for (; i < this.children.length - 1;) {
                let child = this.children[i];
                if (off < child.length || child instanceof LineView)
                    break;
                i++;
                off = 0;
            }
            return this.children[i].domAtPos(off);
        }
        coordsAt(pos, side)
        {
            for (let off = this.length, i = this.children.length - 1; ; i--) {
                let child = this.children[i],
                    start = off - child.breakAfter - child.length;
                if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
                    return child.coordsAt(pos - start, side);
                off = start;
            }
        }
        measureVisibleLineHeights(viewport)
        {
            let result = [],
                {from, to} = viewport;
            let contentWidth = this.view.contentDOM.clientWidth;
            let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
            let widest = -1,
                ltr = this.view.textDirection == Direction.LTR;
            for (let pos = 0, i = 0; i < this.children.length; i++) {
                let child = this.children[i],
                    end = pos + child.length;
                if (end > to)
                    break;
                if (pos >= from) {
                    let childRect = child.dom.getBoundingClientRect();
                    result.push(childRect.height);
                    if (isWider) {
                        let last = child.dom.lastChild;
                        let rects = last ? clientRectsFor(last) : [];
                        if (rects.length) {
                            let rect = rects[rects.length - 1];
                            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                            if (width > widest) {
                                widest = width;
                                this.minWidth = contentWidth;
                                this.minWidthFrom = pos;
                                this.minWidthTo = end;
                            }
                        }
                    }
                }
                pos = end + child.breakAfter;
            }
            return result;
        }
        textDirectionAt(pos)
        {
            let {i} = this.childPos(pos, 1);
            return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
        }
        measureTextSize()
        {
            for (let _i52 = 0, _this$children8 = this.children, _length52 = _this$children8.length; _i52 < _length52; _i52++) {
                let child = _this$children8[_i52];
                if (child instanceof LineView) {
                    let measure = child.measureTextSize();
                    if (measure)
                        return measure;
                }
            }
            let dummy = document.createElement("div"),
                lineHeight,
                charWidth;
            dummy.className = "cm-line";
            dummy.style.width = "99999px";
            dummy.textContent = "abc def ghi jkl mno pqr stu";
            this.view.observer.ignore(() => {
                this.dom.appendChild(dummy);
                let rect = clientRectsFor(dummy.firstChild)[0];
                lineHeight = dummy.getBoundingClientRect().height;
                charWidth = rect ? rect.width / 27 : 7;
                dummy.remove();
            });
            return {
                lineHeight,
                charWidth
            };
        }
        childCursor(pos=this.length)
        {
            let i = this.children.length;
            if (i)
                pos -= this.children[--i].length;
            return new ChildCursor(this.children, pos, i);
        }
        computeBlockGapDeco()
        {
            let deco = [],
                vs = this.view.viewState;
            for (let pos = 0, i = 0; ; i++) {
                let next = i == vs.viewports.length ? null : vs.viewports[i];
                let end = next ? next.from - 1 : this.length;
                if (end > pos) {
                    let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
                    deco.push(Decoration.replace({
                        widget: new BlockGapWidget(height),
                        block: true,
                        inclusive: true,
                        isBlockGap: true
                    }).range(pos, end));
                }
                if (!next)
                    break;
                pos = next.to + 1;
            }
            return Decoration.set(deco);
        }
        updateDeco()
        {
            let allDeco = this.view.state.facet(decorations).map((d, i) => {
                let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
                return dynamic ? d(this.view) : d;
            });
            for (let i = allDeco.length; i < allDeco.length + 3; i++)
                this.dynamicDecorationMap[i] = false;
            return this.decorations = [...allDeco, this.compositionDeco, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco];
        }
        scrollIntoView(target)
        {
            let {range} = target;
            let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1),
                other;
            if (!rect)
                return;
            if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
                rect = {
                    left: Math.min(rect.left, other.left),
                    top: Math.min(rect.top, other.top),
                    right: Math.max(rect.right, other.right),
                    bottom: Math.max(rect.bottom, other.bottom)
                };
            let mLeft = 0,
                mRight = 0,
                mTop = 0,
                mBottom = 0;
            for (let _i53 = 0, _this$view$state$face = this.view.state.facet(scrollMargins).map(f => f(this.view)), _length53 = _this$view$state$face.length; _i53 < _length53; _i53++) {
                let margins = _this$view$state$face[_i53];
                if (margins) {
                    let {left, right, top, bottom} = margins;
                    if (left != null)
                        mLeft = Math.max(mLeft, left);
                    if (right != null)
                        mRight = Math.max(mRight, right);
                    if (top != null)
                        mTop = Math.max(mTop, top);
                    if (bottom != null)
                        mBottom = Math.max(mBottom, bottom);
                }
            }
            let targetRect = {
                left: rect.left - mLeft,
                top: rect.top - mTop,
                right: rect.right + mRight,
                bottom: rect.bottom + mBottom
            };
            scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
        }
    }
    function betweenUneditable(pos) {
        return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
    }
    class BlockGapWidget extends WidgetType {
        constructor(height)
        {
            super();
            this.height = height;
        }
        toDOM()
        {
            let elt = document.createElement("div");
            this.updateDOM(elt);
            return elt;
        }
        eq(other)
        {
            return other.height == this.height;
        }
        updateDOM(elt)
        {
            elt.style.height = this.height + "px";
            return true;
        }
        get estimatedHeight()
        {
            return this.height;
        }
    }
    function compositionSurroundingNode(view) {
        let sel = view.observer.selectionRange;
        let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
        if (!textNode)
            return null;
        let cView = view.docView.nearest(textNode);
        if (!cView)
            return null;
        if (cView instanceof LineView) {
            let topNode = textNode;
            while (topNode.parentNode != cView.dom)
                topNode = topNode.parentNode;
            let prev = topNode.previousSibling;
            while (prev && !ContentView.get(prev))
                prev = prev.previousSibling;
            let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
            return {
                from: pos,
                to: pos,
                node: topNode,
                text: textNode
            };
        } else {
            for (;;) {
                let {parent} = cView;
                if (!parent)
                    return null;
                if (parent instanceof LineView)
                    break;
                cView = parent;
            }
            let from = cView.posAtStart;
            return {
                from,
                to: from + cView.length,
                node: cView.dom,
                text: textNode
            };
        }
    }
    function computeCompositionDeco(view, changes) {
        let surrounding = compositionSurroundingNode(view);
        if (!surrounding)
            return Decoration.none;
        let {from, to, node, text: textNode} = surrounding;
        let newFrom = changes.mapPos(from, 1),
            newTo = Math.max(newFrom, changes.mapPos(to, -1));
        let {state} = view,
            text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state).readRange(node.firstChild, null).text;
        if (newTo - newFrom < text.length) {
            if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text.length), LineBreakPlaceholder) == text)
                newTo = newFrom + text.length;
            else if (state.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text)
                newFrom = newTo - text.length;
            else
                return Decoration.none;
        } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {
            return Decoration.none;
        }
        let topView = ContentView.get(node);
        if (topView instanceof CompositionView)
            topView = topView.widget.topView;
        else if (topView)
            topView.parent = null;
        return Decoration.set(Decoration.replace({
            widget: new CompositionWidget(node, textNode, topView),
            inclusive: true
        }).range(newFrom, newTo));
    }
    class CompositionWidget extends WidgetType {
        constructor(top, text, topView)
        {
            super();
            this.top = top;
            this.text = text;
            this.topView = topView;
        }
        eq(other)
        {
            return this.top == other.top && this.text == other.text;
        }
        toDOM()
        {
            return this.top;
        }
        ignoreEvent()
        {
            return false;
        }
        get customView()
        {
            return CompositionView;
        }
    }
    function nearbyTextNode(node, offset, side) {
        for (;;) {
            if (node.nodeType == 3)
                return node;
            if (node.nodeType == 1 && offset > 0 && side <= 0) {
                node = node.childNodes[offset - 1];
                offset = maxOffset(node);
            } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
                node = node.childNodes[offset];
                offset = 0;
            } else {
                return null;
            }
        }
    }
    function nextToUneditable(node, offset) {
        if (node.nodeType != 1)
            return 0;
        return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
    }
    class DecorationComparator$1 {
        constructor()
        {
            this.changes = [];
        }
        compareRange(from, to)
        {
            addRange(from, to, this.changes);
        }
        comparePoint(from, to)
        {
            addRange(from, to, this.changes);
        }
    }
    function findChangedDeco(a, b, diff) {
        let comp = new DecorationComparator$1();
        RangeSet.compare(a, b, diff, comp);
        return comp.changes;
    }
    function inUneditable(node, inside) {
        for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
            if (cur.nodeType == 1 && cur.contentEditable == 'false') {
                return true;
            }
        }
        return false;
    }
    function groupAt(state, pos, bias=1) {
        let categorize = state.charCategorizer(pos);
        let line = state.doc.lineAt(pos),
            linePos = pos - line.from;
        if (line.length == 0)
            return EditorSelection.cursor(pos);
        if (linePos == 0)
            bias = 1;
        else if (linePos == line.length)
            bias = -1;
        let from = linePos,
            to = linePos;
        if (bias < 0)
            from = findClusterBreak(line.text, linePos, false);
        else
            to = findClusterBreak(line.text, linePos);
        let cat = categorize(line.text.slice(from, to));
        while (from > 0) {
            let prev = findClusterBreak(line.text, from, false);
            if (categorize(line.text.slice(prev, from)) != cat)
                break;
            from = prev;
        }
        while (to < line.length) {
            let next = findClusterBreak(line.text, to);
            if (categorize(line.text.slice(to, next)) != cat)
                break;
            to = next;
        }
        return EditorSelection.range(from + line.from, to + line.from);
    }
    function getdx(x, rect) {
        return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
    }
    function getdy(y, rect) {
        return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
    }
    function yOverlap(a, b) {
        return a.top < b.bottom - 1 && a.bottom > b.top + 1;
    }
    function upTop(rect, top) {
        return top < rect.top ? {
            top,
            left: rect.left,
            right: rect.right,
            bottom: rect.bottom
        } : rect;
    }
    function upBot(rect, bottom) {
        return bottom > rect.bottom ? {
            top: rect.top,
            left: rect.left,
            right: rect.right,
            bottom
        } : rect;
    }
    function domPosAtCoords(parent, x, y) {
        let closest,
            closestRect,
            closestX,
            closestY,
            closestOverlap = false;
        let above,
            below,
            aboveRect,
            belowRect;
        for (let child = parent.firstChild; child; child = child.nextSibling) {
            let rects = clientRectsFor(child);
            for (let i = 0; i < rects.length; i++) {
                let rect = rects[i];
                if (closestRect && yOverlap(closestRect, rect))
                    rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
                let dx = getdx(x, rect),
                    dy = getdy(y, rect);
                if (dx == 0 && dy == 0)
                    return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
                if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                    closest = child;
                    closestRect = rect;
                    closestX = dx;
                    closestY = dy;
                    let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;
                    closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
                }
                if (dx == 0) {
                    if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                        above = child;
                        aboveRect = rect;
                    } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                        below = child;
                        belowRect = rect;
                    }
                } else if (aboveRect && yOverlap(aboveRect, rect)) {
                    aboveRect = upBot(aboveRect, rect.bottom);
                } else if (belowRect && yOverlap(belowRect, rect)) {
                    belowRect = upTop(belowRect, rect.top);
                }
            }
        }
        if (aboveRect && aboveRect.bottom >= y) {
            closest = above;
            closestRect = aboveRect;
        } else if (belowRect && belowRect.top <= y) {
            closest = below;
            closestRect = belowRect;
        }
        if (!closest)
            return {
                node: parent,
                offset: 0
            };
        let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
        if (closest.nodeType == 3)
            return domPosInText(closest, clipX, y);
        if (closestOverlap && closest.contentEditable != "false")
            return domPosAtCoords(closest, clipX, y);
        let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
        return {
            node: parent,
            offset
        };
    }
    function domPosInText(node, x, y) {
        let len = node.nodeValue.length;
        let closestOffset = -1,
            closestDY = 1e9,
            generalSide = 0;
        for (let i = 0; i < len; i++) {
            let rects = textRange(node, i, i + 1).getClientRects();
            for (let j = 0; j < rects.length; j++) {
                let rect = rects[j];
                if (rect.top == rect.bottom)
                    continue;
                if (!generalSide)
                    generalSide = x - rect.left;
                let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
                if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                    let right = x >= (rect.left + rect.right) / 2,
                        after = right;
                    if (browser.chrome || browser.gecko) {
                        let rectBefore = textRange(node, i).getBoundingClientRect();
                        if (rectBefore.left == rect.right)
                            after = !right;
                    }
                    if (dy <= 0)
                        return {
                            node,
                            offset: i + (after ? 1 : 0)
                        };
                    closestOffset = i + (after ? 1 : 0);
                    closestDY = dy;
                }
            }
        }
        return {
            node,
            offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0
        };
    }
    function posAtCoords(view, {x, y}, precise, bias=-1) {
        var _a;
        let content = view.contentDOM.getBoundingClientRect(),
            docTop = content.top + view.viewState.paddingTop;
        let block,
            {docHeight} = view.viewState;
        let yOffset = y - docTop;
        if (yOffset < 0)
            return 0;
        if (yOffset > docHeight)
            return view.state.doc.length;
        for (let halfLine = view.defaultLineHeight / 2, bounced = false; ;) {
            block = view.elementAtHeight(yOffset);
            if (block.type == BlockType.Text)
                break;
            for (;;) {
                yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
                if (yOffset >= 0 && yOffset <= docHeight)
                    break;
                if (bounced)
                    return precise ? null : 0;
                bounced = true;
                bias = -bias;
            }
        }
        y = docTop + yOffset;
        let lineStart = block.from;
        if (lineStart < view.viewport.from)
            return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
        if (lineStart > view.viewport.to)
            return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
        let doc = view.dom.ownerDocument;
        let root = view.root.elementFromPoint ? view.root : doc;
        let element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element))
            element = null;
        if (!element) {
            x = Math.max(content.left + 1, Math.min(content.right - 1, x));
            element = root.elementFromPoint(x, y);
            if (element && !view.contentDOM.contains(element))
                element = null;
        }
        let node,
            offset = -1;
        if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
            if (doc.caretPositionFromPoint) {
                let pos = doc.caretPositionFromPoint(x, y);
                if (pos)
                    ({offsetNode: node, offset} = pos);
            } else if (doc.caretRangeFromPoint) {
                let range = doc.caretRangeFromPoint(x, y);
                if (range) {
                    ({startContainer: node, startOffset: offset} = range);
                    if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                        node = undefined;
                }
            }
        }
        if (!node || !view.docView.dom.contains(node)) {
            let line = LineView.find(view.docView, lineStart);
            if (!line)
                return yOffset > block.top + block.height / 2 ? block.to : block.from;
            ({node, offset} = domPosAtCoords(line.dom, x, y));
        }
        return view.docView.posFromDOM(node, offset);
    }
    function posAtCoordsImprecise(view, contentRect, block, x, y) {
        let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
        if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
            let line = Math.floor((y - block.top) / view.defaultLineHeight);
            into += line * view.viewState.heightOracle.lineLength;
        }
        let content = view.state.sliceDoc(block.from, block.to);
        return block.from + findColumn(content, into, view.state.tabSize);
    }
    function isSuspiciousSafariCaretResult(node, offset, x) {
        let len;
        if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
            return false;
        for (let next = node.nextSibling; next; next = next.nextSibling)
            if (next.nodeType != 1 || next.nodeName != "BR")
                return false;
        return textRange(node, len - 1, len).getBoundingClientRect().left > x;
    }
    function isSuspiciousChromeCaretResult(node, offset, x) {
        if (offset != 0)
            return false;
        for (let cur = node; ;) {
            let parent = cur.parentNode;
            if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
                return false;
            if (parent.classList.contains("cm-line"))
                break;
            cur = parent;
        }
        let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
        return x - rect.left > 5;
    }
    function moveToLineBoundary(view, start, forward, includeWrap) {
        let line = view.state.doc.lineAt(start.head);
        let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
        if (coords) {
            let editorRect = view.dom.getBoundingClientRect();
            let direction = view.textDirectionAt(line.from);
            let pos = view.posAtCoords({
                x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
                y: (coords.top + coords.bottom) / 2
            });
            if (pos != null)
                return EditorSelection.cursor(pos, forward ? -1 : 1);
        }
        let lineView = LineView.find(view.docView, start.head);
        let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
        return EditorSelection.cursor(end, forward ? -1 : 1);
    }
    function moveByChar(view, start, forward, by) {
        let line = view.state.doc.lineAt(start.head),
            spans = view.bidiSpans(line);
        let direction = view.textDirectionAt(line.from);
        for (let cur = start, check = null; ;) {
            let next = moveVisually(line, spans, direction, cur, forward),
                char = movedOver;
            if (!next) {
                if (line.number == (forward ? view.state.doc.lines : 1))
                    return cur;
                char = "\n";
                line = view.state.doc.line(line.number + (forward ? 1 : -1));
                spans = view.bidiSpans(line);
                next = EditorSelection.cursor(forward ? line.from : line.to);
            }
            if (!check) {
                if (!by)
                    return next;
                check = by(char);
            } else if (!check(char)) {
                return cur;
            }
            cur = next;
        }
    }
    function byGroup(view, pos, start) {
        let categorize = view.state.charCategorizer(pos);
        let cat = categorize(start);
        return next => {
            let nextCat = categorize(next);
            if (cat == CharCategory.Space)
                cat = nextCat;
            return cat == nextCat;
        };
    }
    function moveVertically(view, start, forward, distance) {
        let startPos = start.head,
            dir = forward ? 1 : -1;
        if (startPos == (forward ? view.state.doc.length : 0))
            return EditorSelection.cursor(startPos, start.assoc);
        let goal = start.goalColumn,
            startY;
        let rect = view.contentDOM.getBoundingClientRect();
        let startCoords = view.coordsAtPos(startPos),
            docTop = view.documentTop;
        if (startCoords) {
            if (goal == null)
                goal = startCoords.left - rect.left;
            startY = dir < 0 ? startCoords.top : startCoords.bottom;
        } else {
            let line = view.viewState.lineBlockAt(startPos);
            if (goal == null)
                goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
            startY = (dir < 0 ? line.top : line.bottom) + docTop;
        }
        let resolvedGoal = rect.left + goal;
        let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
        for (let extra = 0; ; extra += 10) {
            let curY = startY + (dist + extra) * dir;
            let pos = posAtCoords(view, {
                x: resolvedGoal,
                y: curY
            }, false, dir);
            if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
                return EditorSelection.cursor(pos, start.assoc, undefined, goal);
        }
    }
    function skipAtoms(view, oldPos, pos) {
        let atoms = view.state.facet(atomicRanges).map(f => f(view));
        for (;;) {
            let moved = false;
            for (let _i54 = 0, _length54 = atoms.length; _i54 < _length54; _i54++) {
                let set = atoms[_i54];
                set.between(pos.from - 1, pos.from + 1, (from, to, value) => {
                    if (pos.from > from && pos.from < to) {
                        pos = oldPos.head > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
                        moved = true;
                    }
                });
            }
            if (!moved)
                return pos;
        }
    }
    class InputState {
        constructor(view)
        {
            this.lastKeyCode = 0;
            this.lastKeyTime = 0;
            this.lastTouchTime = 0;
            this.lastFocusTime = 0;
            this.lastScrollTop = 0;
            this.lastScrollLeft = 0;
            this.chromeScrollHack = -1;
            this.pendingIOSKey = undefined;
            this.lastSelectionOrigin = null;
            this.lastSelectionTime = 0;
            this.lastEscPress = 0;
            this.lastContextMenu = 0;
            this.scrollHandlers = [];
            this.registeredEvents = [];
            this.customHandlers = [];
            this.composing = -1;
            this.compositionFirstChange = null;
            this.compositionEndedAt = 0;
            this.mouseSelection = null;
            let handleEvent = (handler, event) => {
                if (this.ignoreDuringComposition(event))
                    return;
                if (event.type == "keydown" && this.keydown(view, event))
                    return;
                if (this.mustFlushObserver(event))
                    view.observer.forceFlush();
                if (this.runCustomHandlers(event.type, view, event))
                    event.preventDefault();
                else
                    handler(view, event);
            };
            for (let type in handlers) {
                let handler = handlers[type];
                view.contentDOM.addEventListener(type, event => {
                    if (eventBelongsToEditor(view, event))
                        handleEvent(handler, event);
                }, handlerOptions[type]);
                this.registeredEvents.push(type);
            }
            view.scrollDOM.addEventListener("mousedown", event => {
                if (event.target == view.scrollDOM)
                    handleEvent(handlers.mousedown, event);
            });
            if (browser.chrome && browser.chrome_version == 102) {
                view.scrollDOM.addEventListener("wheel", () => {
                    if (this.chromeScrollHack < 0)
                        view.contentDOM.style.pointerEvents = "none";
                    else
                        window.clearTimeout(this.chromeScrollHack);
                    this.chromeScrollHack = setTimeout(() => {
                        this.chromeScrollHack = -1;
                        view.contentDOM.style.pointerEvents = "";
                    }, 100);
                }, {
                    passive: true
                });
            }
            this.notifiedFocused = view.hasFocus;
            if (browser.safari)
                view.contentDOM.addEventListener("input", () => null);
        }
        setSelectionOrigin(origin)
        {
            this.lastSelectionOrigin = origin;
            this.lastSelectionTime = Date.now();
        }
        ensureHandlers(view, plugins)
        {
            var _a;
            let handlers;
            this.customHandlers = [];
            for (let _i55 = 0, _length55 = plugins.length; _i55 < _length55; _i55++) {
                let plugin = plugins[_i55];
                if (handlers = (_a = plugin.update(view).spec) === null || _a === void 0 ? void 0 : _a.domEventHandlers) {
                    this.customHandlers.push({
                        plugin: plugin.value,
                        handlers
                    });
                    for (let type in handlers)
                        if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
                            this.registeredEvents.push(type);
                            view.contentDOM.addEventListener(type, event => {
                                if (!eventBelongsToEditor(view, event))
                                    return;
                                if (this.runCustomHandlers(type, view, event))
                                    event.preventDefault();
                            });
                        }
                }
            }
        }
        runCustomHandlers(type, view, event)
        {
            for (let _i56 = 0, _this$customHandlers = this.customHandlers, _length56 = _this$customHandlers.length; _i56 < _length56; _i56++) {
                let set = _this$customHandlers[_i56];
                let handler = set.handlers[type];
                if (handler) {
                    try {
                        if (handler.call(set.plugin, event, view) || event.defaultPrevented)
                            return true;
                    } catch (e) {
                        logException(view.state, e);
                    }
                }
            }
            return false;
        }
        runScrollHandlers(view, event)
        {
            this.lastScrollTop = view.scrollDOM.scrollTop;
            this.lastScrollLeft = view.scrollDOM.scrollLeft;
            for (let _i57 = 0, _this$customHandlers2 = this.customHandlers, _length57 = _this$customHandlers2.length; _i57 < _length57; _i57++) {
                let set = _this$customHandlers2[_i57];
                let handler = set.handlers.scroll;
                if (handler) {
                    try {
                        handler.call(set.plugin, event, view);
                    } catch (e) {
                        logException(view.state, e);
                    }
                }
            }
        }
        keydown(view, event)
        {
            this.lastKeyCode = event.keyCode;
            this.lastKeyTime = Date.now();
            if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000)
                return true;
            if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
                view.observer.delayAndroidKey(event.key, event.keyCode);
                return true;
            }
            let pending;
            if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
                this.pendingIOSKey = pending || event;
                setTimeout(() => this.flushIOSKey(view), 250);
                return true;
            }
            return false;
        }
        flushIOSKey(view)
        {
            let key = this.pendingIOSKey;
            if (!key)
                return false;
            this.pendingIOSKey = undefined;
            return dispatchKey(view.contentDOM, key.key, key.keyCode);
        }
        ignoreDuringComposition(event)
        {
            if (!/^key/.test(event.type))
                return false;
            if (this.composing > 0)
                return true;
            if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
                this.compositionEndedAt = 0;
                return true;
            }
            return false;
        }
        mustFlushObserver(event)
        {
            return event.type == "keydown" && event.keyCode != 229;
        }
        startMouseSelection(mouseSelection)
        {
            if (this.mouseSelection)
                this.mouseSelection.destroy();
            this.mouseSelection = mouseSelection;
        }
        update(update)
        {
            if (this.mouseSelection)
                this.mouseSelection.update(update);
            if (update.transactions.length)
                this.lastKeyCode = this.lastSelectionTime = 0;
        }
        destroy()
        {
            if (this.mouseSelection)
                this.mouseSelection.destroy();
        }
    }
    const PendingKeys = [{
        key: "Backspace",
        keyCode: 8,
        inputType: "deleteContentBackward"
    }, {
        key: "Enter",
        keyCode: 13,
        inputType: "insertParagraph"
    }, {
        key: "Delete",
        keyCode: 46,
        inputType: "deleteContentForward"
    }];
    const EmacsyPendingKeys = "dthko";
    const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
    function dragScrollSpeed(dist) {
        return dist * 0.7 + 8;
    }
    class MouseSelection {
        constructor(view, startEvent, style, mustSelect)
        {
            this.view = view;
            this.style = style;
            this.mustSelect = mustSelect;
            this.scrollSpeed = {
                x: 0,
                y: 0
            };
            this.scrolling = -1;
            this.lastEvent = startEvent;
            this.scrollParent = scrollableParent(view.contentDOM);
            let doc = view.contentDOM.ownerDocument;
            doc.addEventListener("mousemove", this.move = this.move.bind(this));
            doc.addEventListener("mouseup", this.up = this.up.bind(this));
            this.extend = startEvent.shiftKey;
            this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
            this.dragMove = dragMovesSelection(view, startEvent);
            this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
            if (this.dragging === false) {
                startEvent.preventDefault();
                this.select(startEvent);
            }
        }
        move(event)
        {
            var _a;
            if (event.buttons == 0)
                return this.destroy();
            if (this.dragging !== false)
                return;
            this.select(this.lastEvent = event);
            let sx = 0,
                sy = 0;
            let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {
                left: 0,
                top: 0,
                right: this.view.win.innerWidth,
                bottom: this.view.win.innerHeight
            };
            if (event.clientX <= rect.left)
                sx = -dragScrollSpeed(rect.left - event.clientX);
            else if (event.clientX >= rect.right)
                sx = dragScrollSpeed(event.clientX - rect.right);
            if (event.clientY <= rect.top)
                sy = -dragScrollSpeed(rect.top - event.clientY);
            else if (event.clientY >= rect.bottom)
                sy = dragScrollSpeed(event.clientY - rect.bottom);
            this.setScrollSpeed(sx, sy);
        }
        up(event)
        {
            if (this.dragging == null)
                this.select(this.lastEvent);
            if (!this.dragging)
                event.preventDefault();
            this.destroy();
        }
        destroy()
        {
            this.setScrollSpeed(0, 0);
            let doc = this.view.contentDOM.ownerDocument;
            doc.removeEventListener("mousemove", this.move);
            doc.removeEventListener("mouseup", this.up);
            this.view.inputState.mouseSelection = null;
        }
        setScrollSpeed(sx, sy)
        {
            this.scrollSpeed = {
                x: sx,
                y: sy
            };
            if (sx || sy) {
                if (this.scrolling < 0)
                    this.scrolling = setInterval(() => this.scroll(), 50);
            } else if (this.scrolling > -1) {
                clearInterval(this.scrolling);
                this.scrolling = -1;
            }
        }
        scroll()
        {
            if (this.scrollParent) {
                this.scrollParent.scrollLeft += this.scrollSpeed.x;
                this.scrollParent.scrollTop += this.scrollSpeed.y;
            } else {
                this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
            }
            if (this.dragging === false)
                this.select(this.lastEvent);
        }
        select(event)
        {
            let selection = this.style.get(event, this.extend, this.multiple);
            if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
                this.view.dispatch({
                    selection,
                    userEvent: "select.pointer"
                });
            this.mustSelect = false;
        }
        update(update)
        {
            if (update.docChanged && this.dragging)
                this.dragging = this.dragging.map(update.changes);
            if (this.style.update(update))
                setTimeout(() => this.select(this.lastEvent), 20);
        }
    }
    function addsSelectionRange(view, event) {
        let facet = view.state.facet(clickAddsSelectionRange);
        return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
    }
    function dragMovesSelection(view, event) {
        let facet = view.state.facet(dragMovesSelection$1);
        return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
    }
    function isInPrimarySelection(view, event) {
        let {main} = view.state.selection;
        if (main.empty)
            return false;
        let sel = getSelection(view.root);
        if (!sel || sel.rangeCount == 0)
            return true;
        let rects = sel.getRangeAt(0).getClientRects();
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
                return true;
        }
        return false;
    }
    function eventBelongsToEditor(view, event) {
        if (!event.bubbles)
            return true;
        if (event.defaultPrevented)
            return false;
        for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
            if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
                return false;
        return true;
    }
    const handlers = Object.create(null);
    const handlerOptions = Object.create(null);
    const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
    function capturePaste(view) {
        let parent = view.dom.parentNode;
        if (!parent)
            return;
        let target = parent.appendChild(document.createElement("textarea"));
        target.style.cssText = "position: fixed; left: -10000px; top: 10px";
        target.focus();
        setTimeout(() => {
            view.focus();
            target.remove();
            doPaste(view, target.value);
        }, 50);
    }
    function doPaste(view, input) {
        let {state} = view,
            changes,
            i = 1,
            text = state.toText(input);
        let byLine = text.lines == state.selection.ranges.length;
        let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
        if (linewise) {
            let lastLine = -1;
            changes = state.changeByRange(range => {
                let line = state.doc.lineAt(range.from);
                if (line.from == lastLine)
                    return {
                        range
                    };
                lastLine = line.from;
                let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
                return {
                    changes: {
                        from: line.from,
                        insert
                    },
                    range: EditorSelection.cursor(range.from + insert.length)
                };
            });
        } else if (byLine) {
            changes = state.changeByRange(range => {
                let line = text.line(i++);
                return {
                    changes: {
                        from: range.from,
                        to: range.to,
                        insert: line.text
                    },
                    range: EditorSelection.cursor(range.from + line.length)
                };
            });
        } else {
            changes = state.replaceSelection(text);
        }
        view.dispatch(changes, {
            userEvent: "input.paste",
            scrollIntoView: true
        });
    }
    handlers.keydown = (view, event) => {
        view.inputState.setSelectionOrigin("select");
        if (event.keyCode == 27)
            view.inputState.lastEscPress = Date.now();
        else if (modifierCodes.indexOf(event.keyCode) < 0)
            view.inputState.lastEscPress = 0;
    };
    handlers.touchstart = (view, e) => {
        view.inputState.lastTouchTime = Date.now();
        view.inputState.setSelectionOrigin("select.pointer");
    };
    handlers.touchmove = view => {
        view.inputState.setSelectionOrigin("select.pointer");
    };
    handlerOptions.touchstart = handlerOptions.touchmove = {
        passive: true
    };
    handlers.mousedown = (view, event) => {
        view.observer.flush();
        if (view.inputState.lastTouchTime > Date.now() - 2000)
            return;
        let style = null;
        for (let _i58 = 0, _view$state$facet = view.state.facet(mouseSelectionStyle), _length58 = _view$state$facet.length; _i58 < _length58; _i58++) {
            let makeStyle = _view$state$facet[_i58];
            style = makeStyle(view, event);
            if (style)
                break;
        }
        if (!style && event.button == 0)
            style = basicMouseSelection(view, event);
        if (style) {
            let mustFocus = view.root.activeElement != view.contentDOM;
            if (mustFocus)
                view.observer.ignore(() => focusPreventScroll(view.contentDOM));
            view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
        }
    };
    function rangeForClick(view, pos, bias, type) {
        if (type == 1) {
            return EditorSelection.cursor(pos, bias);
        } else if (type == 2) {
            return groupAt(view.state, pos, bias);
        } else {
            let visual = LineView.find(view.docView, pos),
                line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
            let from = visual ? visual.posAtStart : line.from,
                to = visual ? visual.posAtEnd : line.to;
            if (to < view.state.doc.length && to == line.to)
                to++;
            return EditorSelection.range(from, to);
        }
    }
    let insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
    let inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
    function findPositionSide(view, pos, x, y) {
        let line = LineView.find(view.docView, pos);
        if (!line)
            return 1;
        let off = pos - line.posAtStart;
        if (off == 0)
            return 1;
        if (off == line.length)
            return -1;
        let before = line.coordsAt(off, -1);
        if (before && inside(x, y, before))
            return -1;
        let after = line.coordsAt(off, 1);
        if (after && inside(x, y, after))
            return 1;
        return before && insideY(y, before) ? -1 : 1;
    }
    function queryPos(view, event) {
        let pos = view.posAtCoords({
            x: event.clientX,
            y: event.clientY
        }, false);
        return {
            pos,
            bias: findPositionSide(view, pos, event.clientX, event.clientY)
        };
    }
    const BadMouseDetail = browser.ie && browser.ie_version <= 11;
    let lastMouseDown = null,
        lastMouseDownCount = 0,
        lastMouseDownTime = 0;
    function getClickType(event) {
        if (!BadMouseDetail)
            return event.detail;
        let last = lastMouseDown,
            lastTime = lastMouseDownTime;
        lastMouseDown = event;
        lastMouseDownTime = Date.now();
        return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
    }
    function basicMouseSelection(view, event) {
        let start = queryPos(view, event),
            type = getClickType(event);
        let startSel = view.state.selection;
        return {
            update(update) {
                if (update.docChanged) {
                    start.pos = update.changes.mapPos(start.pos);
                    startSel = startSel.map(update.changes);
                }
            },
            get(event, extend, multiple) {
                let cur = queryPos(view, event);
                let range = rangeForClick(view, cur.pos, cur.bias, type);
                if (start.pos != cur.pos && !extend) {
                    let startRange = rangeForClick(view, start.pos, start.bias, type);
                    let from = Math.min(startRange.from, range.from),
                        to = Math.max(startRange.to, range.to);
                    range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
                }
                if (extend)
                    return startSel.replaceRange(startSel.main.extend(range.from, range.to));
                else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some(r => r.eq(range)))
                    return removeRange(startSel, range);
                else if (multiple)
                    return startSel.addRange(range);
                else
                    return EditorSelection.create([range]);
            }
        };
    }
    function removeRange(sel, range) {
        for (let i = 0; ; i++) {
            if (sel.ranges[i].eq(range))
                return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
        }
    }
    handlers.dragstart = (view, event) => {
        let {selection: {main}} = view.state;
        let {mouseSelection} = view.inputState;
        if (mouseSelection)
            mouseSelection.dragging = main;
        if (event.dataTransfer) {
            event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
            event.dataTransfer.effectAllowed = "copyMove";
        }
    };
    function dropText(view, event, text, direct) {
        if (!text)
            return;
        let dropPos = view.posAtCoords({
            x: event.clientX,
            y: event.clientY
        }, false);
        event.preventDefault();
        let {mouseSelection} = view.inputState;
        let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? {
            from: mouseSelection.dragging.from,
            to: mouseSelection.dragging.to
        } : null;
        let ins = {
            from: dropPos,
            insert: text
        };
        let changes = view.state.changes(del ? [del, ins] : ins);
        view.focus();
        view.dispatch({
            changes,
            selection: {
                anchor: changes.mapPos(dropPos, -1),
                head: changes.mapPos(dropPos, 1)
            },
            userEvent: del ? "move.drop" : "input.drop"
        });
    }
    handlers.drop = (view, event) => {
        if (!event.dataTransfer)
            return;
        if (view.state.readOnly)
            return event.preventDefault();
        let files = event.dataTransfer.files;
        if (files && files.length) {
            event.preventDefault();
            let text = Array(files.length),
                read = 0;
            let finishFile = () => {
                if (++read == files.length)
                    dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
            };
            for (let i = 0; i < files.length; i++) {
                let reader = new FileReader();
                reader.onerror = finishFile;
                reader.onload = () => {
                    if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                        text[i] = reader.result;
                    finishFile();
                };
                reader.readAsText(files[i]);
            }
        } else {
            dropText(view, event, event.dataTransfer.getData("Text"), true);
        }
    };
    handlers.paste = (view, event) => {
        if (view.state.readOnly)
            return event.preventDefault();
        view.observer.flush();
        let data = brokenClipboardAPI ? null : event.clipboardData;
        if (data) {
            doPaste(view, data.getData("text/plain"));
            event.preventDefault();
        } else {
            capturePaste(view);
        }
    };
    function captureCopy(view, text) {
        let parent = view.dom.parentNode;
        if (!parent)
            return;
        let target = parent.appendChild(document.createElement("textarea"));
        target.style.cssText = "position: fixed; left: -10000px; top: 10px";
        target.value = text;
        target.focus();
        target.selectionEnd = text.length;
        target.selectionStart = 0;
        setTimeout(() => {
            target.remove();
            view.focus();
        }, 50);
    }
    function copiedRange(state) {
        let content = [],
            ranges = [],
            linewise = false;
        for (let _i59 = 0, _state$selection$rang = state.selection.ranges, _length59 = _state$selection$rang.length; _i59 < _length59; _i59++) {
            let range = _state$selection$rang[_i59];
            if (!range.empty) {
                content.push(state.sliceDoc(range.from, range.to));
                ranges.push(range);
            }
        }
        if (!content.length) {
            let upto = -1;
            for (let _i60 = 0, _state$selection$rang2 = state.selection.ranges, _length60 = _state$selection$rang2.length; _i60 < _length60; _i60++) {
                let {from} = _state$selection$rang2[_i60];
                let line = state.doc.lineAt(from);
                if (line.number > upto) {
                    content.push(line.text);
                    ranges.push({
                        from: line.from,
                        to: Math.min(state.doc.length, line.to + 1)
                    });
                }
                upto = line.number;
            }
            linewise = true;
        }
        return {
            text: content.join(state.lineBreak),
            ranges,
            linewise
        };
    }
    let lastLinewiseCopy = null;
    handlers.copy = handlers.cut = (view, event) => {
        let {text, ranges, linewise} = copiedRange(view.state);
        if (!text && !linewise)
            return;
        lastLinewiseCopy = linewise ? text : null;
        let data = brokenClipboardAPI ? null : event.clipboardData;
        if (data) {
            event.preventDefault();
            data.clearData();
            data.setData("text/plain", text);
        } else {
            captureCopy(view, text);
        }
        if (event.type == "cut" && !view.state.readOnly)
            view.dispatch({
                changes: ranges,
                scrollIntoView: true,
                userEvent: "delete.cut"
            });
    };
    function updateForFocusChange(view) {
        setTimeout(() => {
            if (view.hasFocus != view.inputState.notifiedFocused)
                view.update([]);
        }, 10);
    }
    handlers.focus = view => {
        view.inputState.lastFocusTime = Date.now();
        if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
            view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
            view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
        }
        updateForFocusChange(view);
    };
    handlers.blur = view => {
        view.observer.clearSelectionRange();
        updateForFocusChange(view);
    };
    handlers.compositionstart = handlers.compositionupdate = view => {
        if (view.inputState.compositionFirstChange == null)
            view.inputState.compositionFirstChange = true;
        if (view.inputState.composing < 0) {
            view.inputState.composing = 0;
        }
    };
    handlers.compositionend = view => {
        view.inputState.composing = -1;
        view.inputState.compositionEndedAt = Date.now();
        view.inputState.compositionFirstChange = null;
        if (browser.chrome && browser.android)
            view.observer.flushSoon();
        setTimeout(() => {
            if (view.inputState.composing < 0 && view.docView.compositionDeco.size)
                view.update([]);
        }, 50);
    };
    handlers.contextmenu = view => {
        view.inputState.lastContextMenu = Date.now();
    };
    handlers.beforeinput = (view, event) => {
        var _a;
        let pending;
        if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {
            view.observer.delayAndroidKey(pending.key, pending.keyCode);
            if (pending.key == "Backspace" || pending.key == "Delete") {
                let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;
                setTimeout(() => {
                    var _a;
                    if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                        view.contentDOM.blur();
                        view.focus();
                    }
                }, 100);
            }
        }
    };
    const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
    class HeightOracle {
        constructor(lineWrapping)
        {
            this.lineWrapping = lineWrapping;
            this.doc = Text.empty;
            this.heightSamples = {};
            this.lineHeight = 14;
            this.charWidth = 7;
            this.lineLength = 30;
            this.heightChanged = false;
        }
        heightForGap(from, to)
        {
            let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
            if (this.lineWrapping)
                lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
            return this.lineHeight * lines;
        }
        heightForLine(length)
        {
            if (!this.lineWrapping)
                return this.lineHeight;
            let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
            return lines * this.lineHeight;
        }
        setDoc(doc)
        {
            this.doc = doc;
            return this;
        }
        mustRefreshForWrapping(whiteSpace)
        {
            return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
        }
        mustRefreshForHeights(lineHeights)
        {
            let newHeight = false;
            for (let i = 0; i < lineHeights.length; i++) {
                let h = lineHeights[i];
                if (h < 0) {
                    i++;
                } else if (!this.heightSamples[Math.floor(h * 10)]) {
                    newHeight = true;
                    this.heightSamples[Math.floor(h * 10)] = true;
                }
            }
            return newHeight;
        }
        refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights)
        {
            let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
            let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
            this.lineWrapping = lineWrapping;
            this.lineHeight = lineHeight;
            this.charWidth = charWidth;
            this.lineLength = lineLength;
            if (changed) {
                this.heightSamples = {};
                for (let i = 0; i < knownHeights.length; i++) {
                    let h = knownHeights[i];
                    if (h < 0)
                        i++;
                    else
                        this.heightSamples[Math.floor(h * 10)] = true;
                }
            }
            return changed;
        }
    }
    class MeasuredHeights {
        constructor(from, heights)
        {
            this.from = from;
            this.heights = heights;
            this.index = 0;
        }
        get more()
        {
            return this.index < this.heights.length;
        }
    }
    class BlockInfo {
        constructor(from, length, top, height, type)
        {
            this.from = from;
            this.length = length;
            this.top = top;
            this.height = height;
            this.type = type;
        }
        get to()
        {
            return this.from + this.length;
        }
        get bottom()
        {
            return this.top + this.height;
        }
        join(other)
        {
            let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
            return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
        }
    }
    var QueryType$1 = function(QueryType) {
        QueryType[QueryType["ByPos"] = 0] = "ByPos";
        QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
        QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
        return QueryType;
    }(QueryType$1 || (QueryType$1 = {}));
    const Epsilon = 1e-3;
    class HeightMap {
        constructor(length, height, flags=2)
        {
            this.length = length;
            this.height = height;
            this.flags = flags;
        }
        get outdated()
        {
            return (this.flags & 2) > 0;
        }
        set outdated(value)
        {
            this.flags = (value ? 2 : 0) | this.flags & ~2;
        }
        setHeight(oracle, height)
        {
            if (this.height != height) {
                if (Math.abs(this.height - height) > Epsilon)
                    oracle.heightChanged = true;
                this.height = height;
            }
        }
        replace(_from, _to, nodes)
        {
            return HeightMap.of(nodes);
        }
        decomposeLeft(_to, result)
        {
            result.push(this);
        }
        decomposeRight(_from, result)
        {
            result.push(this);
        }
        applyChanges(decorations, oldDoc, oracle, changes)
        {
            let me = this;
            for (let i = changes.length - 1; i >= 0; i--) {
                let {fromA, toA, fromB, toB} = changes[i];
                let start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oldDoc, 0, 0);
                let end = start.to >= toA ? start : me.lineAt(toA, QueryType$1.ByPosNoHeight, oldDoc, 0, 0);
                toB += end.to - toA;
                toA = end.to;
                while (i > 0 && start.from <= changes[i - 1].toA) {
                    fromA = changes[i - 1].fromA;
                    fromB = changes[i - 1].fromB;
                    i--;
                    if (fromA < start.from)
                        start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oldDoc, 0, 0);
                }
                fromB += start.from - fromA;
                fromA = start.from;
                let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);
                me = me.replace(fromA, toA, nodes);
            }
            return me.updateHeight(oracle, 0);
        }
        static empty()
        {
            return new HeightMapText(0, 0);
        }
        static of(nodes)
        {
            if (nodes.length == 1)
                return nodes[0];
            let i = 0,
                j = nodes.length,
                before = 0,
                after = 0;
            for (;;) {
                if (i == j) {
                    if (before > after * 2) {
                        let split = nodes[i - 1];
                        if (split.break)
                            nodes.splice(--i, 1, split.left, null, split.right);
                        else
                            nodes.splice(--i, 1, split.left, split.right);
                        j += 1 + split.break;
                        before -= split.size;
                    } else if (after > before * 2) {
                        let split = nodes[j];
                        if (split.break)
                            nodes.splice(j, 1, split.left, null, split.right);
                        else
                            nodes.splice(j, 1, split.left, split.right);
                        j += 2 + split.break;
                        after -= split.size;
                    } else {
                        break;
                    }
                } else if (before < after) {
                    let next = nodes[i++];
                    if (next)
                        before += next.size;
                } else {
                    let next = nodes[--j];
                    if (next)
                        after += next.size;
                }
            }
            let brk = 0;
            if (nodes[i - 1] == null) {
                brk = 1;
                i--;
            } else if (nodes[i] == null) {
                brk = 1;
                j++;
            }
            return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
        }
    }
    HeightMap.prototype.size = 1;
    class HeightMapBlock extends HeightMap {
        constructor(length, height, type)
        {
            super(length, height);
            this.type = type;
        }
        blockAt(_height, _doc, top, offset)
        {
            return new BlockInfo(offset, this.length, top, this.height, this.type);
        }
        lineAt(_value, _type, doc, top, offset)
        {
            return this.blockAt(0, doc, top, offset);
        }
        forEachLine(from, to, doc, top, offset, f)
        {
            if (from <= offset + this.length && to >= offset)
                f(this.blockAt(0, doc, top, offset));
        }
        updateHeight(oracle, offset=0, _force=false, measured)
        {
            if (measured && measured.from <= offset && measured.more)
                this.setHeight(oracle, measured.heights[measured.index++]);
            this.outdated = false;
            return this;
        }
        toString()
        {
            return `block(${this.length})`;
        }
    }
    class HeightMapText extends HeightMapBlock {
        constructor(length, height)
        {
            super(length, height, BlockType.Text);
            this.collapsed = 0;
            this.widgetHeight = 0;
        }
        replace(_from, _to, nodes)
        {
            let node = nodes[0];
            if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
                if (node instanceof HeightMapGap)
                    node = new HeightMapText(node.length, this.height);
                else
                    node.height = this.height;
                if (!this.outdated)
                    node.outdated = false;
                return node;
            } else {
                return HeightMap.of(nodes);
            }
        }
        updateHeight(oracle, offset=0, force=false, measured)
        {
            if (measured && measured.from <= offset && measured.more)
                this.setHeight(oracle, measured.heights[measured.index++]);
            else if (force || this.outdated)
                this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
            this.outdated = false;
            return this;
        }
        toString()
        {
            return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
        }
    }
    class HeightMapGap extends HeightMap {
        constructor(length)
        {
            super(length, 0);
        }
        lines(doc, offset)
        {
            let firstLine = doc.lineAt(offset).number,
                lastLine = doc.lineAt(offset + this.length).number;
            return {
                firstLine,
                lastLine,
                lineHeight: this.height / (lastLine - firstLine + 1)
            };
        }
        blockAt(height, doc, top, offset)
        {
            let {firstLine, lastLine, lineHeight} = this.lines(doc, offset);
            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));
            let {from, length} = doc.line(firstLine + line);
            return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);
        }
        lineAt(value, type, doc, top, offset)
        {
            if (type == QueryType$1.ByHeight)
                return this.blockAt(value, doc, top, offset);
            if (type == QueryType$1.ByPosNoHeight) {
                let {from, to} = doc.lineAt(value);
                return new BlockInfo(from, to - from, 0, 0, BlockType.Text);
            }
            let {firstLine, lineHeight} = this.lines(doc, offset);
            let {from, length, number} = doc.lineAt(value);
            return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);
        }
        forEachLine(from, to, doc, top, offset, f)
        {
            let {firstLine, lineHeight} = this.lines(doc, offset);
            for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;) {
                let line = doc.lineAt(pos);
                if (pos == from)
                    top += lineHeight * (line.number - firstLine);
                f(new BlockInfo(line.from, line.length, top, lineHeight, BlockType.Text));
                top += lineHeight;
                pos = line.to + 1;
            }
        }
        replace(from, to, nodes)
        {
            let after = this.length - to;
            if (after > 0) {
                let last = nodes[nodes.length - 1];
                if (last instanceof HeightMapGap)
                    nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
                else
                    nodes.push(null, new HeightMapGap(after - 1));
            }
            if (from > 0) {
                let first = nodes[0];
                if (first instanceof HeightMapGap)
                    nodes[0] = new HeightMapGap(from + first.length);
                else
                    nodes.unshift(new HeightMapGap(from - 1), null);
            }
            return HeightMap.of(nodes);
        }
        decomposeLeft(to, result)
        {
            result.push(new HeightMapGap(to - 1), null);
        }
        decomposeRight(from, result)
        {
            result.push(null, new HeightMapGap(this.length - from - 1));
        }
        updateHeight(oracle, offset=0, force=false, measured)
        {
            let end = offset + this.length;
            if (measured && measured.from <= offset + this.length && measured.more) {
                let nodes = [],
                    pos = Math.max(offset, measured.from),
                    singleHeight = -1;
                let wasChanged = oracle.heightChanged;
                if (measured.from > offset)
                    nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
                while (pos <= end && measured.more) {
                    let len = oracle.doc.lineAt(pos).length;
                    if (nodes.length)
                        nodes.push(null);
                    let height = measured.heights[measured.index++];
                    if (singleHeight == -1)
                        singleHeight = height;
                    else if (Math.abs(height - singleHeight) >= Epsilon)
                        singleHeight = -2;
                    let line = new HeightMapText(len, height);
                    line.outdated = false;
                    nodes.push(line);
                    pos += len + 1;
                }
                if (pos <= end)
                    nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
                let result = HeightMap.of(nodes);
                oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
                return result;
            } else if (force || this.outdated) {
                this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
                this.outdated = false;
            }
            return this;
        }
        toString()
        {
            return `gap(${this.length})`;
        }
    }
    class HeightMapBranch extends HeightMap {
        constructor(left, brk, right)
        {
            super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
            this.left = left;
            this.right = right;
            this.size = left.size + right.size;
        }
        get break()
        {
            return this.flags & 1;
        }
        blockAt(height, doc, top, offset)
        {
            let mid = top + this.left.height;
            return height < mid ? this.left.blockAt(height, doc, top, offset) : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);
        }
        lineAt(value, type, doc, top, offset)
        {
            let rightTop = top + this.left.height,
                rightOffset = offset + this.left.length + this.break;
            let left = type == QueryType$1.ByHeight ? value < rightTop : value < rightOffset;
            let base = left ? this.left.lineAt(value, type, doc, top, offset) : this.right.lineAt(value, type, doc, rightTop, rightOffset);
            if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
                return base;
            let subQuery = type == QueryType$1.ByPosNoHeight ? QueryType$1.ByPosNoHeight : QueryType$1.ByPos;
            if (left)
                return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));
            else
                return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);
        }
        forEachLine(from, to, doc, top, offset, f)
        {
            let rightTop = top + this.left.height,
                rightOffset = offset + this.left.length + this.break;
            if (this.break) {
                if (from < rightOffset)
                    this.left.forEachLine(from, to, doc, top, offset, f);
                if (to >= rightOffset)
                    this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);
            } else {
                let mid = this.lineAt(rightOffset, QueryType$1.ByPos, doc, top, offset);
                if (from < mid.from)
                    this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);
                if (mid.to >= from && mid.from <= to)
                    f(mid);
                if (to > mid.to)
                    this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);
            }
        }
        replace(from, to, nodes)
        {
            let rightStart = this.left.length + this.break;
            if (to < rightStart)
                return this.balanced(this.left.replace(from, to, nodes), this.right);
            if (from > this.left.length)
                return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
            let result = [];
            if (from > 0)
                this.decomposeLeft(from, result);
            let left = result.length;
            for (let _i61 = 0, _length61 = nodes.length; _i61 < _length61; _i61++) {
                let node = nodes[_i61];
                result.push(node);
            }
            if (from > 0)
                mergeGaps(result, left - 1);
            if (to < this.length) {
                let right = result.length;
                this.decomposeRight(to, result);
                mergeGaps(result, right);
            }
            return HeightMap.of(result);
        }
        decomposeLeft(to, result)
        {
            let left = this.left.length;
            if (to <= left)
                return this.left.decomposeLeft(to, result);
            result.push(this.left);
            if (this.break) {
                left++;
                if (to >= left)
                    result.push(null);
            }
            if (to > left)
                this.right.decomposeLeft(to - left, result);
        }
        decomposeRight(from, result)
        {
            let left = this.left.length,
                right = left + this.break;
            if (from >= right)
                return this.right.decomposeRight(from - right, result);
            if (from < left)
                this.left.decomposeRight(from, result);
            if (this.break && from < right)
                result.push(null);
            result.push(this.right);
        }
        balanced(left, right)
        {
            if (left.size > 2 * right.size || right.size > 2 * left.size)
                return HeightMap.of(this.break ? [left, null, right] : [left, right]);
            this.left = left;
            this.right = right;
            this.height = left.height + right.height;
            this.outdated = left.outdated || right.outdated;
            this.size = left.size + right.size;
            this.length = left.length + this.break + right.length;
            return this;
        }
        updateHeight(oracle, offset=0, force=false, measured)
        {
            let {left, right} = this,
                rightStart = offset + left.length + this.break,
                rebalance = null;
            if (measured && measured.from <= offset + left.length && measured.more)
                rebalance = left = left.updateHeight(oracle, offset, force, measured);
            else
                left.updateHeight(oracle, offset, force);
            if (measured && measured.from <= rightStart + right.length && measured.more)
                rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
            else
                right.updateHeight(oracle, rightStart, force);
            if (rebalance)
                return this.balanced(left, right);
            this.height = this.left.height + this.right.height;
            this.outdated = false;
            return this;
        }
        toString()
        {
            return this.left + (this.break ? " " : "-") + this.right;
        }
    }
    function mergeGaps(nodes, around) {
        let before,
            after;
        if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
            nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
    }
    const relevantWidgetHeight = 5;
    class NodeBuilder {
        constructor(pos, oracle)
        {
            this.pos = pos;
            this.oracle = oracle;
            this.nodes = [];
            this.lineStart = -1;
            this.lineEnd = -1;
            this.covering = null;
            this.writtenTo = pos;
        }
        get isCovered()
        {
            return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
        }
        span(_from, to)
        {
            if (this.lineStart > -1) {
                let end = Math.min(to, this.lineEnd),
                    last = this.nodes[this.nodes.length - 1];
                if (last instanceof HeightMapText)
                    last.length += end - this.pos;
                else if (end > this.pos || !this.isCovered)
                    this.nodes.push(new HeightMapText(end - this.pos, -1));
                this.writtenTo = end;
                if (to > end) {
                    this.nodes.push(null);
                    this.writtenTo++;
                    this.lineStart = -1;
                }
            }
            this.pos = to;
        }
        point(from, to, deco)
        {
            if (from < to || deco.heightRelevant) {
                let height = deco.widget ? deco.widget.estimatedHeight : 0;
                if (height < 0)
                    height = this.oracle.lineHeight;
                let len = to - from;
                if (deco.block) {
                    this.addBlock(new HeightMapBlock(len, height, deco.type));
                } else if (len || height >= relevantWidgetHeight) {
                    this.addLineDeco(height, len);
                }
            } else if (to > from) {
                this.span(from, to);
            }
            if (this.lineEnd > -1 && this.lineEnd < this.pos)
                this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
        }
        enterLine()
        {
            if (this.lineStart > -1)
                return;
            let {from, to} = this.oracle.doc.lineAt(this.pos);
            this.lineStart = from;
            this.lineEnd = to;
            if (this.writtenTo < from) {
                if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
                    this.nodes.push(this.blankContent(this.writtenTo, from - 1));
                this.nodes.push(null);
            }
            if (this.pos > from)
                this.nodes.push(new HeightMapText(this.pos - from, -1));
            this.writtenTo = this.pos;
        }
        blankContent(from, to)
        {
            let gap = new HeightMapGap(to - from);
            if (this.oracle.doc.lineAt(from).to == to)
                gap.flags |= 4;
            return gap;
        }
        ensureLine()
        {
            this.enterLine();
            let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
            if (last instanceof HeightMapText)
                return last;
            let line = new HeightMapText(0, -1);
            this.nodes.push(line);
            return line;
        }
        addBlock(block)
        {
            this.enterLine();
            if (block.type == BlockType.WidgetAfter && !this.isCovered)
                this.ensureLine();
            this.nodes.push(block);
            this.writtenTo = this.pos = this.pos + block.length;
            if (block.type != BlockType.WidgetBefore)
                this.covering = block;
        }
        addLineDeco(height, length)
        {
            let line = this.ensureLine();
            line.length += length;
            line.collapsed += length;
            line.widgetHeight = Math.max(line.widgetHeight, height);
            this.writtenTo = this.pos = this.pos + length;
        }
        finish(from)
        {
            let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
            if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
                this.nodes.push(new HeightMapText(0, -1));
            else if (this.writtenTo < this.pos || last == null)
                this.nodes.push(this.blankContent(this.writtenTo, this.pos));
            let pos = from;
            for (let _i62 = 0, _this$nodes = this.nodes, _length62 = _this$nodes.length; _i62 < _length62; _i62++) {
                let node = _this$nodes[_i62];
                if (node instanceof HeightMapText)
                    node.updateHeight(this.oracle, pos);
                pos += node ? node.length : 1;
            }
            return this.nodes;
        }
        static build(oracle, decorations, from, to)
        {
            let builder = new NodeBuilder(from, oracle);
            RangeSet.spans(decorations, from, to, builder, 0);
            return builder.finish(from);
        }
    }
    function heightRelevantDecoChanges(a, b, diff) {
        let comp = new DecorationComparator();
        RangeSet.compare(a, b, diff, comp, 0);
        return comp.changes;
    }
    class DecorationComparator {
        constructor()
        {
            this.changes = [];
        }
        compareRange() {}
        comparePoint(from, to, a, b)
        {
            if (from < to || a && a.heightRelevant || b && b.heightRelevant)
                addRange(from, to, this.changes, 5);
        }
    }
    function visiblePixelRange(dom, paddingTop) {
        let rect = dom.getBoundingClientRect();
        let doc = dom.ownerDocument,
            win = doc.defaultView || window;
        let left = Math.max(0, rect.left),
            right = Math.min(win.innerWidth, rect.right);
        let top = Math.max(0, rect.top),
            bottom = Math.min(win.innerHeight, rect.bottom);
        for (let parent = dom.parentNode; parent && parent != doc.body;) {
            if (parent.nodeType == 1) {
                let elt = parent;
                let style = window.getComputedStyle(elt);
                if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
                    let parentRect = elt.getBoundingClientRect();
                    left = Math.max(left, parentRect.left);
                    right = Math.min(right, parentRect.right);
                    top = Math.max(top, parentRect.top);
                    bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
                }
                parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
            } else if (parent.nodeType == 11) {
                parent = parent.host;
            } else {
                break;
            }
        }
        return {
            left: left - rect.left,
            right: Math.max(left, right) - rect.left,
            top: top - (rect.top + paddingTop),
            bottom: Math.max(top, bottom) - (rect.top + paddingTop)
        };
    }
    function fullPixelRange(dom, paddingTop) {
        let rect = dom.getBoundingClientRect();
        return {
            left: 0,
            right: rect.right - rect.left,
            top: paddingTop,
            bottom: rect.bottom - (rect.top + paddingTop)
        };
    }
    class LineGap {
        constructor(from, to, size)
        {
            this.from = from;
            this.to = to;
            this.size = size;
        }
        static same(a, b)
        {
            if (a.length != b.length)
                return false;
            for (let i = 0; i < a.length; i++) {
                let gA = a[i],
                    gB = b[i];
                if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
                    return false;
            }
            return true;
        }
        draw(wrapping)
        {
            return Decoration.replace({
                widget: new LineGapWidget(this.size, wrapping)
            }).range(this.from, this.to);
        }
    }
    class LineGapWidget extends WidgetType {
        constructor(size, vertical)
        {
            super();
            this.size = size;
            this.vertical = vertical;
        }
        eq(other)
        {
            return other.size == this.size && other.vertical == this.vertical;
        }
        toDOM()
        {
            let elt = document.createElement("div");
            if (this.vertical) {
                elt.style.height = this.size + "px";
            } else {
                elt.style.width = this.size + "px";
                elt.style.height = "2px";
                elt.style.display = "inline-block";
            }
            return elt;
        }
        get estimatedHeight()
        {
            return this.vertical ? this.size : -1;
        }
    }
    class ViewState {
        constructor(state)
        {
            this.state = state;
            this.pixelViewport = {
                left: 0,
                right: window.innerWidth,
                top: 0,
                bottom: 0
            };
            this.inView = true;
            this.paddingTop = 0;
            this.paddingBottom = 0;
            this.contentDOMWidth = 0;
            this.contentDOMHeight = 0;
            this.editorHeight = 0;
            this.editorWidth = 0;
            this.scaler = IdScaler;
            this.scrollTarget = null;
            this.printing = false;
            this.mustMeasureContent = true;
            this.defaultTextDirection = Direction.LTR;
            this.visibleRanges = [];
            this.mustEnforceCursorAssoc = false;
            let guessWrapping = state.facet(contentAttributes).some(v => typeof v != "function" && v.class == "cm-lineWrapping");
            this.heightOracle = new HeightOracle(guessWrapping);
            this.stateDeco = state.facet(decorations).filter(d => typeof d != "function");
            this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
            this.viewport = this.getViewport(0, null);
            this.updateViewportLines();
            this.updateForViewport();
            this.lineGaps = this.ensureLineGaps([]);
            this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));
            this.computeVisibleRanges();
        }
        updateForViewport()
        {
            let viewports = [this.viewport],
                {main} = this.state.selection;
            for (let i = 0; i <= 1; i++) {
                let pos = i ? main.head : main.anchor;
                if (!viewports.some(({from, to}) => pos >= from && pos <= to)) {
                    let {from, to} = this.lineBlockAt(pos);
                    viewports.push(new Viewport(from, to));
                }
            }
            this.viewports = viewports.sort((a, b) => a.from - b.from);
            this.scaler = this.heightMap.height <= 7000000 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
        }
        updateViewportLines()
        {
            this.viewportLines = [];
            this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, block => {
                this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
            });
        }
        update(update, scrollTarget=null)
        {
            this.state = update.state;
            let prevDeco = this.stateDeco;
            this.stateDeco = this.state.facet(decorations).filter(d => typeof d != "function");
            let contentChanges = update.changedRanges;
            let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
            let prevHeight = this.heightMap.height;
            this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
            if (this.heightMap.height != prevHeight)
                update.flags |= 2;
            let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
            if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
                viewport = this.getViewport(0, scrollTarget);
            let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
            this.viewport = viewport;
            this.updateForViewport();
            if (updateLines)
                this.updateViewportLines();
            if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 << 1)
                this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
            update.flags |= this.computeVisibleRanges();
            if (scrollTarget)
                this.scrollTarget = scrollTarget;
            if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
                this.mustEnforceCursorAssoc = true;
        }
        measure(view)
        {
            let dom = view.contentDOM,
                style = window.getComputedStyle(dom);
            let oracle = this.heightOracle;
            let whiteSpace = style.whiteSpace;
            this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
            let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
            let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
            this.contentDOMHeight = dom.clientHeight;
            this.mustMeasureContent = false;
            let result = 0,
                bias = 0;
            let paddingTop = parseInt(style.paddingTop) || 0,
                paddingBottom = parseInt(style.paddingBottom) || 0;
            if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
                this.paddingTop = paddingTop;
                this.paddingBottom = paddingBottom;
                result |= 8 | 2;
            }
            if (this.editorWidth != view.scrollDOM.clientWidth) {
                if (oracle.lineWrapping)
                    measureContent = true;
                this.editorWidth = view.scrollDOM.clientWidth;
                result |= 8;
            }
            let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
            let dTop = pixelViewport.top - this.pixelViewport.top,
                dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
            this.pixelViewport = pixelViewport;
            let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
            if (inView != this.inView) {
                this.inView = inView;
                if (inView)
                    measureContent = true;
            }
            if (!this.inView && !this.scrollTarget)
                return 0;
            let contentWidth = dom.clientWidth;
            if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
                this.contentDOMWidth = contentWidth;
                this.editorHeight = view.scrollDOM.clientHeight;
                result |= 8;
            }
            if (measureContent) {
                let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
                if (oracle.mustRefreshForHeights(lineHeights))
                    refresh = true;
                if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
                    let {lineHeight, charWidth} = view.docView.measureTextSize();
                    refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
                    if (refresh) {
                        view.docView.minWidth = 0;
                        result |= 8;
                    }
                }
                if (dTop > 0 && dBottom > 0)
                    bias = Math.max(dTop, dBottom);
                else if (dTop < 0 && dBottom < 0)
                    bias = Math.min(dTop, dBottom);
                oracle.heightChanged = false;
                for (let _i63 = 0, _this$viewports = this.viewports, _length63 = _this$viewports.length; _i63 < _length63; _i63++) {
                    let vp = _this$viewports[_i63];
                    let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
                    this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
                }
                if (oracle.heightChanged)
                    result |= 2;
            }
            let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
            if (viewportChange)
                this.viewport = this.getViewport(bias, this.scrollTarget);
            this.updateForViewport();
            if (result & 2 || viewportChange)
                this.updateViewportLines();
            if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 << 1)
                this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
            result |= this.computeVisibleRanges();
            if (this.mustEnforceCursorAssoc) {
                this.mustEnforceCursorAssoc = false;
                view.docView.enforceCursorAssoc();
            }
            return result;
        }
        get visibleTop()
        {
            return this.scaler.fromDOM(this.pixelViewport.top);
        }
        get visibleBottom()
        {
            return this.scaler.fromDOM(this.pixelViewport.bottom);
        }
        getViewport(bias, scrollTarget)
        {
            let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 / 2));
            let map = this.heightMap,
                doc = this.state.doc,
                {visibleTop, visibleBottom} = this;
            let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000, QueryType$1.ByHeight, doc, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000, QueryType$1.ByHeight, doc, 0, 0).to);
            if (scrollTarget) {
                let {head} = scrollTarget.range;
                if (head < viewport.from || head > viewport.to) {
                    let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
                    let block = map.lineAt(head, QueryType$1.ByPos, doc, 0, 0),
                        topPos;
                    if (scrollTarget.y == "center")
                        topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
                    else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                        topPos = block.top;
                    else
                        topPos = block.bottom - viewHeight;
                    viewport = new Viewport(map.lineAt(topPos - 1000 / 2, QueryType$1.ByHeight, doc, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 / 2, QueryType$1.ByHeight, doc, 0, 0).to);
                }
            }
            return viewport;
        }
        mapViewport(viewport, changes)
        {
            let from = changes.mapPos(viewport.from, -1),
                to = changes.mapPos(viewport.to, 1);
            return new Viewport(this.heightMap.lineAt(from, QueryType$1.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType$1.ByPos, this.state.doc, 0, 0).to);
        }
        viewportIsAppropriate({from, to}, bias=0)
        {
            if (!this.inView)
                return true;
            let {top} = this.heightMap.lineAt(from, QueryType$1.ByPos, this.state.doc, 0, 0);
            let {bottom} = this.heightMap.lineAt(to, QueryType$1.ByPos, this.state.doc, 0, 0);
            let {visibleTop, visibleBottom} = this;
            return (from == 0 || top <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && top > visibleTop - 2 * 1000 && bottom < visibleBottom + 2 * 1000;
        }
        mapLineGaps(gaps, changes)
        {
            if (!gaps.length || changes.empty)
                return gaps;
            let mapped = [];
            for (let _i64 = 0, _length64 = gaps.length; _i64 < _length64; _i64++) {
                let gap = gaps[_i64];
                if (!changes.touchesRange(gap.from, gap.to))
                    mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
            }
            return mapped;
        }
        ensureLineGaps(current, mayMeasure)
        {
            let wrapping = this.heightOracle.lineWrapping;
            let margin = wrapping ? 10000 : 2000,
                halfMargin = margin >> 1,
                doubleMargin = margin << 1;
            if (this.defaultTextDirection != Direction.LTR && !wrapping)
                return [];
            let gaps = [];
            let addGap = (from, to, line, structure) => {
                if (to - from < halfMargin)
                    return;
                let sel = this.state.selection.main,
                    avoid = [sel.from];
                if (!sel.empty)
                    avoid.push(sel.to);
                for (let _i65 = 0, _length65 = avoid.length; _i65 < _length65; _i65++) {
                    let pos = avoid[_i65];
                    if (pos > from && pos < to) {
                        addGap(from, pos - 10, line, structure);
                        addGap(pos + 10, to, line, structure);
                        return;
                    }
                }
                let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some(pos => gap.from < pos && gap.to > pos));
                if (!gap) {
                    if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {
                        let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
                        if (lineStart > from)
                            to = lineStart;
                    }
                    gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
                }
                gaps.push(gap);
            };
            for (let _i66 = 0, _this$viewportLines = this.viewportLines, _length66 = _this$viewportLines.length; _i66 < _length66; _i66++) {
                let line = _this$viewportLines[_i66];
                if (line.length < doubleMargin)
                    continue;
                let structure = lineStructure(line.from, line.to, this.stateDeco);
                if (structure.total < doubleMargin)
                    continue;
                let target = this.scrollTarget ? this.scrollTarget.range.head : null;
                let viewFrom,
                    viewTo;
                if (wrapping) {
                    let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
                    let top,
                        bot;
                    if (target != null) {
                        let targetFrac = findFraction(structure, target);
                        let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
                        top = targetFrac - spaceFrac;
                        bot = targetFrac + spaceFrac;
                    } else {
                        top = (this.visibleTop - line.top - marginHeight) / line.height;
                        bot = (this.visibleBottom - line.top + marginHeight) / line.height;
                    }
                    viewFrom = findPosition(structure, top);
                    viewTo = findPosition(structure, bot);
                } else {
                    let totalWidth = structure.total * this.heightOracle.charWidth;
                    let marginWidth = margin * this.heightOracle.charWidth;
                    let left,
                        right;
                    if (target != null) {
                        let targetFrac = findFraction(structure, target);
                        let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
                        left = targetFrac - spaceFrac;
                        right = targetFrac + spaceFrac;
                    } else {
                        left = (this.pixelViewport.left - marginWidth) / totalWidth;
                        right = (this.pixelViewport.right + marginWidth) / totalWidth;
                    }
                    viewFrom = findPosition(structure, left);
                    viewTo = findPosition(structure, right);
                }
                if (viewFrom > line.from)
                    addGap(line.from, viewFrom, line, structure);
                if (viewTo < line.to)
                    addGap(viewTo, line.to, line, structure);
            }
            return gaps;
        }
        gapSize(line, from, to, structure)
        {
            let fraction = findFraction(structure, to) - findFraction(structure, from);
            if (this.heightOracle.lineWrapping) {
                return line.height * fraction;
            } else {
                return structure.total * this.heightOracle.charWidth * fraction;
            }
        }
        updateLineGaps(gaps)
        {
            if (!LineGap.same(gaps, this.lineGaps)) {
                this.lineGaps = gaps;
                this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));
            }
        }
        computeVisibleRanges()
        {
            let deco = this.stateDeco;
            if (this.lineGaps.length)
                deco = deco.concat(this.lineGapDeco);
            let ranges = [];
            RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
                span(from, to) {
                    ranges.push({
                        from,
                        to
                    });
                },
                point() {}
            }, 20);
            let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
            this.visibleRanges = ranges;
            return changed ? 4 : 0;
        }
        lineBlockAt(pos)
        {
            return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(b => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType$1.ByPos, this.state.doc, 0, 0), this.scaler);
        }
        lineBlockAtHeight(height)
        {
            return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType$1.ByHeight, this.state.doc, 0, 0), this.scaler);
        }
        elementAtHeight(height)
        {
            return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
        }
        get docHeight()
        {
            return this.scaler.toDOM(this.heightMap.height);
        }
        get contentHeight()
        {
            return this.docHeight + this.paddingTop + this.paddingBottom;
        }
    }
    class Viewport {
        constructor(from, to)
        {
            this.from = from;
            this.to = to;
        }
    }
    function lineStructure(from, to, stateDeco) {
        let ranges = [],
            pos = from,
            total = 0;
        RangeSet.spans(stateDeco, from, to, {
            span() {},
            point(from, to) {
                if (from > pos) {
                    ranges.push({
                        from: pos,
                        to: from
                    });
                    total += from - pos;
                }
                pos = to;
            }
        }, 20);
        if (pos < to) {
            ranges.push({
                from: pos,
                to
            });
            total += to - pos;
        }
        return {
            total,
            ranges
        };
    }
    function findPosition({total, ranges}, ratio) {
        if (ratio <= 0)
            return ranges[0].from;
        if (ratio >= 1)
            return ranges[ranges.length - 1].to;
        let dist = Math.floor(total * ratio);
        for (let i = 0; ; i++) {
            let {from, to} = ranges[i],
                size = to - from;
            if (dist <= size)
                return from + dist;
            dist -= size;
        }
    }
    function findFraction(structure, pos) {
        let counted = 0;
        for (let _i67 = 0, _structure$ranges = structure.ranges, _length67 = _structure$ranges.length; _i67 < _length67; _i67++) {
            let {from, to} = _structure$ranges[_i67];
            if (pos <= to) {
                counted += pos - from;
                break;
            }
            counted += to - from;
        }
        return counted / structure.total;
    }
    function find(array, f) {
        for (let _i68 = 0, _length68 = array.length; _i68 < _length68; _i68++) {
            let val = array[_i68];
            if (f(val))
                return val;
        }
        return undefined;
    }
    const IdScaler = {
        toDOM(n) {
            return n;
        },
        fromDOM(n) {
            return n;
        },
        scale: 1
    };
    class BigScaler {
        constructor(doc, heightMap, viewports)
        {
            let vpHeight = 0,
                base = 0,
                domBase = 0;
            this.viewports = viewports.map(({from, to}) => {
                let top = heightMap.lineAt(from, QueryType$1.ByPos, doc, 0, 0).top;
                let bottom = heightMap.lineAt(to, QueryType$1.ByPos, doc, 0, 0).bottom;
                vpHeight += bottom - top;
                return {
                    from,
                    to,
                    top,
                    bottom,
                    domTop: 0,
                    domBottom: 0
                };
            });
            this.scale = (7000000 - vpHeight) / (heightMap.height - vpHeight);
            for (let _i69 = 0, _this$viewports2 = this.viewports, _length69 = _this$viewports2.length; _i69 < _length69; _i69++) {
                let obj = _this$viewports2[_i69];
                obj.domTop = domBase + (obj.top - base) * this.scale;
                domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
                base = obj.bottom;
            }
        }
        toDOM(n)
        {
            for (let i = 0, base = 0, domBase = 0; ; i++) {
                let vp = i < this.viewports.length ? this.viewports[i] : null;
                if (!vp || n < vp.top)
                    return domBase + (n - base) * this.scale;
                if (n <= vp.bottom)
                    return vp.domTop + (n - vp.top);
                base = vp.bottom;
                domBase = vp.domBottom;
            }
        }
        fromDOM(n)
        {
            for (let i = 0, base = 0, domBase = 0; ; i++) {
                let vp = i < this.viewports.length ? this.viewports[i] : null;
                if (!vp || n < vp.domTop)
                    return base + (n - domBase) / this.scale;
                if (n <= vp.domBottom)
                    return vp.top + (n - vp.domTop);
                base = vp.bottom;
                domBase = vp.domBottom;
            }
        }
    }
    function scaleBlock(block, scaler) {
        if (scaler.scale == 1)
            return block;
        let bTop = scaler.toDOM(block.top),
            bBottom = scaler.toDOM(block.bottom);
        return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map(b => scaleBlock(b, scaler)) : block.type);
    }
    const theme = Facet.define({
        combine: strs => strs.join(" ")
    });
    const darkTheme = Facet.define({
        combine: values => values.indexOf(true) > -1
    });
    const baseThemeID = StyleModule.newName(),
        baseLightID = StyleModule.newName(),
        baseDarkID = StyleModule.newName();
    const lightDarkIDs = {
        "&light": "." + baseLightID,
        "&dark": "." + baseDarkID
    };
    function buildTheme(main, spec, scopes) {
        return new StyleModule(spec, {
            finish(sel) {
                return /&/.test(sel) ? sel.replace(/&\w*/, m => {
                    if (m == "&")
                        return main;
                    if (!scopes || !scopes[m])
                        throw new RangeError(`Unsupported selector: ${m}`);
                    return scopes[m];
                }) : main + " " + sel;
            }
        });
    }
    const baseTheme$1$3 = buildTheme("." + baseThemeID, {
        "&": {
            position: "relative !important",
            boxSizing: "border-box",
            "&.cm-focused": {
                outline: "1px dotted #212121"
            },
            display: "flex !important",
            flexDirection: "column"
        },
        ".cm-scroller": {
            display: "flex !important",
            alignItems: "flex-start !important",
            fontFamily: "monospace",
            lineHeight: 1.4,
            height: "100%",
            overflowX: "auto",
            position: "relative",
            zIndex: 0
        },
        ".cm-content": {
            margin: 0,
            flexGrow: 2,
            flexShrink: 0,
            display: "block",
            whiteSpace: "pre",
            wordWrap: "normal",
            boxSizing: "border-box",
            padding: "4px 0",
            outline: "none",
            "&[contenteditable=true]": {
                WebkitUserModify: "read-write-plaintext-only"
            }
        },
        ".cm-lineWrapping": {
            whiteSpace_fallback: "pre-wrap",
            whiteSpace: "break-spaces",
            wordBreak: "break-word",
            overflowWrap: "anywhere",
            flexShrink: 1
        },
        "&light .cm-content": {
            caretColor: "black"
        },
        "&dark .cm-content": {
            caretColor: "white"
        },
        ".cm-line": {
            display: "block",
            padding: "0 2px 0 6px"
        },
        ".cm-layer": {
            contain: "size style",
            "& > *": {
                position: "absolute"
            }
        },
        "&light .cm-selectionBackground": {
            background: "#d9d9d9"
        },
        "&dark .cm-selectionBackground": {
            background: "#222"
        },
        "&light.cm-focused .cm-selectionBackground": {
            background: "#d7d4f0"
        },
        "&dark.cm-focused .cm-selectionBackground": {
            background: "#233"
        },
        ".cm-cursorLayer": {
            pointerEvents: "none"
        },
        "&.cm-focused .cm-cursorLayer": {
            animation: "steps(1) cm-blink 1.2s infinite"
        },
        "@keyframes cm-blink": {
            "0%": {},
            "50%": {
                opacity: 0
            },
            "100%": {}
        },
        "@keyframes cm-blink2": {
            "0%": {},
            "50%": {
                opacity: 0
            },
            "100%": {}
        },
        ".cm-cursor, .cm-dropCursor": {
            borderLeft: "1.2px solid black",
            marginLeft: "-0.6px",
            pointerEvents: "none"
        },
        ".cm-cursor": {
            display: "none"
        },
        "&dark .cm-cursor": {
            borderLeftColor: "#444"
        },
        "&.cm-focused .cm-cursor": {
            display: "block"
        },
        "&light .cm-activeLine": {
            backgroundColor: "#cceeff44"
        },
        "&dark .cm-activeLine": {
            backgroundColor: "#99eeff33"
        },
        "&light .cm-specialChar": {
            color: "red"
        },
        "&dark .cm-specialChar": {
            color: "#f78"
        },
        ".cm-gutters": {
            flexShrink: 0,
            display: "flex",
            height: "100%",
            boxSizing: "border-box",
            left: 0,
            zIndex: 200
        },
        "&light .cm-gutters": {
            backgroundColor: "#f5f5f5",
            color: "#6c6c6c",
            borderRight: "1px solid #ddd"
        },
        "&dark .cm-gutters": {
            backgroundColor: "#333338",
            color: "#ccc"
        },
        ".cm-gutter": {
            display: "flex !important",
            flexDirection: "column",
            flexShrink: 0,
            boxSizing: "border-box",
            minHeight: "100%",
            overflow: "hidden"
        },
        ".cm-gutterElement": {
            boxSizing: "border-box"
        },
        ".cm-lineNumbers .cm-gutterElement": {
            padding: "0 3px 0 5px",
            minWidth: "20px",
            textAlign: "right",
            whiteSpace: "nowrap"
        },
        "&light .cm-activeLineGutter": {
            backgroundColor: "#e2f2ff"
        },
        "&dark .cm-activeLineGutter": {
            backgroundColor: "#222227"
        },
        ".cm-panels": {
            boxSizing: "border-box",
            position: "sticky",
            left: 0,
            right: 0
        },
        "&light .cm-panels": {
            backgroundColor: "#f5f5f5",
            color: "black"
        },
        "&light .cm-panels-top": {
            borderBottom: "1px solid #ddd"
        },
        "&light .cm-panels-bottom": {
            borderTop: "1px solid #ddd"
        },
        "&dark .cm-panels": {
            backgroundColor: "#333338",
            color: "white"
        },
        ".cm-tab": {
            display: "inline-block",
            overflow: "hidden",
            verticalAlign: "bottom"
        },
        ".cm-widgetBuffer": {
            verticalAlign: "text-top",
            height: "1em",
            width: 0,
            display: "inline"
        },
        ".cm-placeholder": {
            color: "#888",
            display: "inline-block",
            verticalAlign: "top"
        },
        ".cm-highlightSpace:before": {
            content: "attr(data-display)",
            position: "absolute",
            pointerEvents: "none",
            color: "#888"
        },
        ".cm-highlightTab": {
            backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
            backgroundSize: "auto 100%",
            backgroundPosition: "right 90%",
            backgroundRepeat: "no-repeat"
        },
        ".cm-trailingSpace": {
            backgroundColor: "#ff332255"
        },
        ".cm-button": {
            verticalAlign: "middle",
            color: "inherit",
            fontSize: "70%",
            padding: ".2em 1em",
            borderRadius: "1px"
        },
        "&light .cm-button": {
            backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
            border: "1px solid #888",
            "&:active": {
                backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
            }
        },
        "&dark .cm-button": {
            backgroundImage: "linear-gradient(#393939, #111)",
            border: "1px solid #888",
            "&:active": {
                backgroundImage: "linear-gradient(#111, #333)"
            }
        },
        ".cm-textfield": {
            verticalAlign: "middle",
            color: "inherit",
            fontSize: "70%",
            border: "1px solid silver",
            padding: ".2em .5em"
        },
        "&light .cm-textfield": {
            backgroundColor: "white"
        },
        "&dark .cm-textfield": {
            border: "1px solid #555",
            backgroundColor: "inherit"
        }
    }, lightDarkIDs);
    class DOMChange {
        constructor(view, start, end, typeOver)
        {
            this.typeOver = typeOver;
            this.bounds = null;
            this.text = "";
            let {impreciseHead: iHead, impreciseAnchor: iAnchor} = view.docView;
            if (view.state.readOnly && start > -1) {
                this.newSel = null;
            } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
                let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
                let reader = new DOMReader(selPoints, view.state);
                reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
                this.text = reader.text;
                this.newSel = selectionFromPoints(selPoints, this.bounds.from);
            } else {
                let domSel = view.observer.selectionRange;
                let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
                let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
                this.newSel = EditorSelection.single(anchor, head);
            }
        }
    }
    function applyDOMChange(view, domChange) {
        let change;
        let {newSel} = domChange,
            sel = view.state.selection.main;
        if (domChange.bounds) {
            let {from, to} = domChange.bounds;
            let preferredPos = sel.from,
                preferredSide = null;
            if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && domChange.text.length < to - from) {
                preferredPos = sel.to;
                preferredSide = "end";
            }
            let diff = findDiff$1(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
            if (diff) {
                if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
                    diff.toB--;
                change = {
                    from: from + diff.from,
                    to: from + diff.toA,
                    insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
                };
            }
        } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
            newSel = null;
        }
        if (!change && !newSel)
            return false;
        if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
            change = {
                from: sel.from,
                to: sel.to,
                insert: view.state.doc.slice(sel.from, sel.to)
            };
        } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
            change = {
                from: sel.from,
                to: sel.to,
                insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
            };
        } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString())) {
            if (newSel && change.insert.length == 2)
                newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
            change = {
                from: sel.from,
                to: sel.to,
                insert: Text.of([" "])
            };
        } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
            if (newSel)
                newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
            change = {
                from: sel.from,
                to: sel.to,
                insert: Text.of([" "])
            };
        }
        if (change) {
            let startState = view.state;
            if (browser.ios && view.inputState.flushIOSKey(view))
                return true;
            if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
                return true;
            let text = change.insert.toString();
            if (view.state.facet(inputHandler$1).some(h => h(view, change.from, change.to, text)))
                return true;
            if (view.inputState.composing >= 0)
                view.inputState.composing++;
            let tr;
            if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
                let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
                let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
                tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
            } else {
                let changes = startState.changes(change);
                let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : undefined;
                if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
                    let replaced = view.state.sliceDoc(change.from, change.to);
                    let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
                    let offset = sel.to - change.to,
                        size = sel.to - sel.from;
                    tr = startState.changeByRange(range => {
                        if (range.from == sel.from && range.to == sel.to)
                            return {
                                changes,
                                range: mainSel || range.map(changes)
                            };
                        let to = range.to - offset,
                            from = to - replaced.length;
                        if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to)
                            return {
                                range
                            };
                        let rangeChanges = startState.changes({
                                from,
                                to,
                                insert: change.insert
                            }),
                            selOff = range.to - sel.to;
                        return {
                            changes: rangeChanges,
                            range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                        };
                    });
                } else {
                    tr = {
                        changes,
                        selection: mainSel && startState.selection.replaceRange(mainSel)
                    };
                }
            }
            let userEvent = "input.type";
            if (view.composing) {
                userEvent += ".compose";
                if (view.inputState.compositionFirstChange) {
                    userEvent += ".start";
                    view.inputState.compositionFirstChange = false;
                }
            }
            view.dispatch(tr, {
                scrollIntoView: true,
                userEvent
            });
            return true;
        } else if (newSel && !newSel.main.eq(sel)) {
            let scrollIntoView = false,
                userEvent = "select";
            if (view.inputState.lastSelectionTime > Date.now() - 50) {
                if (view.inputState.lastSelectionOrigin == "select")
                    scrollIntoView = true;
                userEvent = view.inputState.lastSelectionOrigin;
            }
            view.dispatch({
                selection: newSel,
                scrollIntoView,
                userEvent
            });
            return true;
        } else {
            return false;
        }
    }
    function findDiff$1(a, b, preferredPos, preferredSide) {
        let minLen = Math.min(a.length, b.length);
        let from = 0;
        while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
            from++;
        if (from == minLen && a.length == b.length)
            return null;
        let toA = a.length,
            toB = b.length;
        while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
            toA--;
            toB--;
        }
        if (preferredSide == "end") {
            let adjust = Math.max(0, from - Math.min(toA, toB));
            preferredPos -= toA + adjust - from;
        }
        if (toA < from && a.length < b.length) {
            let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
            from -= move;
            toB = from + (toB - toA);
            toA = from;
        } else if (toB < from) {
            let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
            from -= move;
            toA = from + (toA - toB);
            toB = from;
        }
        return {
            from,
            toA,
            toB
        };
    }
    function selectionPoints(view) {
        let result = [];
        if (view.root.activeElement != view.contentDOM)
            return result;
        let {anchorNode, anchorOffset, focusNode, focusOffset} = view.observer.selectionRange;
        if (anchorNode) {
            result.push(new DOMPoint(anchorNode, anchorOffset));
            if (focusNode != anchorNode || focusOffset != anchorOffset)
                result.push(new DOMPoint(focusNode, focusOffset));
        }
        return result;
    }
    function selectionFromPoints(points, base) {
        if (points.length == 0)
            return null;
        let anchor = points[0].pos,
            head = points.length == 2 ? points[1].pos : anchor;
        return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base, head + base) : null;
    }
    const observeOptions = {
        childList: true,
        characterData: true,
        subtree: true,
        attributes: true,
        characterDataOldValue: true
    };
    const useCharData = browser.ie && browser.ie_version <= 11;
    class DOMObserver {
        constructor(view)
        {
            this.view = view;
            this.active = false;
            this.selectionRange = new DOMSelectionState();
            this.selectionChanged = false;
            this.delayedFlush = -1;
            this.resizeTimeout = -1;
            this.queue = [];
            this.delayedAndroidKey = null;
            this.flushingAndroidKey = -1;
            this.lastChange = 0;
            this.scrollTargets = [];
            this.intersection = null;
            this.resizeScroll = null;
            this.resizeContent = null;
            this.intersecting = false;
            this.gapIntersection = null;
            this.gaps = [];
            this.parentCheck = -1;
            this.dom = view.contentDOM;
            this.observer = new MutationObserver(mutations => {
                for (let _i70 = 0, _length70 = mutations.length; _i70 < _length70; _i70++) {
                    let mut = mutations[_i70];
                    this.queue.push(mut);
                }
                if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some(m => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                    this.flushSoon();
                else
                    this.flush();
            });
            if (useCharData)
                this.onCharData = event => {
                    this.queue.push({
                        target: event.target,
                        type: "characterData",
                        oldValue: event.prevValue
                    });
                    this.flushSoon();
                };
            this.onSelectionChange = this.onSelectionChange.bind(this);
            this.onResize = this.onResize.bind(this);
            this.onPrint = this.onPrint.bind(this);
            this.onScroll = this.onScroll.bind(this);
            if (typeof ResizeObserver == "function") {
                this.resizeScroll = new ResizeObserver(() => {
                    var _a;
                    if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)
                        this.onResize();
                });
                this.resizeScroll.observe(view.scrollDOM);
                this.resizeContent = new ResizeObserver(() => this.view.requestMeasure());
                this.resizeContent.observe(view.contentDOM);
            }
            this.addWindowListeners(this.win = view.win);
            this.start();
            if (typeof IntersectionObserver == "function") {
                this.intersection = new IntersectionObserver(entries => {
                    if (this.parentCheck < 0)
                        this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                    if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
                        this.intersecting = !this.intersecting;
                        if (this.intersecting != this.view.inView)
                            this.onScrollChanged(document.createEvent("Event"));
                    }
                }, {});
                this.intersection.observe(this.dom);
                this.gapIntersection = new IntersectionObserver(entries => {
                    if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                        this.onScrollChanged(document.createEvent("Event"));
                }, {});
            }
            this.listenForScroll();
            this.readSelectionRange();
        }
        onScrollChanged(e)
        {
            this.view.inputState.runScrollHandlers(this.view, e);
            if (this.intersecting)
                this.view.measure();
        }
        onScroll(e)
        {
            if (this.intersecting)
                this.flush(false);
            this.onScrollChanged(e);
        }
        onResize()
        {
            if (this.resizeTimeout < 0)
                this.resizeTimeout = setTimeout(() => {
                    this.resizeTimeout = -1;
                    this.view.requestMeasure();
                }, 50);
        }
        onPrint()
        {
            this.view.viewState.printing = true;
            this.view.measure();
            setTimeout(() => {
                this.view.viewState.printing = false;
                this.view.requestMeasure();
            }, 500);
        }
        updateGaps(gaps)
        {
            if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
                this.gapIntersection.disconnect();
                for (let _i71 = 0, _length71 = gaps.length; _i71 < _length71; _i71++) {
                    let gap = gaps[_i71];
                    this.gapIntersection.observe(gap);
                }
                this.gaps = gaps;
            }
        }
        onSelectionChange(event)
        {
            let wasChanged = this.selectionChanged;
            if (!this.readSelectionRange() || this.delayedAndroidKey)
                return;
            let {view} = this,
                sel = this.selectionRange;
            if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
                return;
            let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
            if (context && context.ignoreEvent(event)) {
                if (!wasChanged)
                    this.selectionChanged = false;
                return;
            }
            if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
                this.flushSoon();
            else
                this.flush(false);
        }
        readSelectionRange()
        {
            let {view} = this;
            let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
            if (!range || this.selectionRange.eq(range))
                return false;
            let local = hasSelection(this.dom, range);
            if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
                this.view.inputState.lastFocusTime = 0;
                view.docView.updateSelection();
                return false;
            }
            this.selectionRange.setRange(range);
            if (local)
                this.selectionChanged = true;
            return true;
        }
        setSelectionRange(anchor, head)
        {
            this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
            this.selectionChanged = false;
        }
        clearSelectionRange()
        {
            this.selectionRange.set(null, 0, null, 0);
        }
        listenForScroll()
        {
            this.parentCheck = -1;
            let i = 0,
                changed = null;
            for (let dom = this.dom; dom;) {
                if (dom.nodeType == 1) {
                    if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                        i++;
                    else if (!changed)
                        changed = this.scrollTargets.slice(0, i);
                    if (changed)
                        changed.push(dom);
                    dom = dom.assignedSlot || dom.parentNode;
                } else if (dom.nodeType == 11) {
                    dom = dom.host;
                } else {
                    break;
                }
            }
            if (i < this.scrollTargets.length && !changed)
                changed = this.scrollTargets.slice(0, i);
            if (changed) {
                for (let _i72 = 0, _this$scrollTargets = this.scrollTargets, _length72 = _this$scrollTargets.length; _i72 < _length72; _i72++) {
                    let dom = _this$scrollTargets[_i72];
                    dom.removeEventListener("scroll", this.onScroll);
                }
                for (let _i73 = 0, _this$scrollTargets2 = this.scrollTargets = changed, _length73 = _this$scrollTargets2.length; _i73 < _length73; _i73++) {
                    let dom = _this$scrollTargets2[_i73];
                    dom.addEventListener("scroll", this.onScroll);
                }
            }
        }
        ignore(f)
        {
            if (!this.active)
                return f();
            try {
                this.stop();
                return f();
            } finally {
                this.start();
                this.clear();
            }
        }
        start()
        {
            if (this.active)
                return;
            this.observer.observe(this.dom, observeOptions);
            if (useCharData)
                this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
            this.active = true;
        }
        stop()
        {
            if (!this.active)
                return;
            this.active = false;
            this.observer.disconnect();
            if (useCharData)
                this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
        }
        clear()
        {
            this.processRecords();
            this.queue.length = 0;
            this.selectionChanged = false;
        }
        delayAndroidKey(key, keyCode)
        {
            var _a;
            if (!this.delayedAndroidKey) {
                let flush = () => {
                    let key = this.delayedAndroidKey;
                    if (key) {
                        this.clearDelayedAndroidKey();
                        if (!this.flush() && key.force)
                            dispatchKey(this.dom, key.key, key.keyCode);
                    }
                };
                this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
            }
            if (!this.delayedAndroidKey || key == "Enter")
                this.delayedAndroidKey = {
                    key,
                    keyCode,
                    force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
                };
        }
        clearDelayedAndroidKey()
        {
            this.win.cancelAnimationFrame(this.flushingAndroidKey);
            this.delayedAndroidKey = null;
            this.flushingAndroidKey = -1;
        }
        flushSoon()
        {
            if (this.delayedFlush < 0)
                this.delayedFlush = this.view.win.requestAnimationFrame(() => {
                    this.delayedFlush = -1;
                    this.flush();
                });
        }
        forceFlush()
        {
            if (this.delayedFlush >= 0) {
                this.view.win.cancelAnimationFrame(this.delayedFlush);
                this.delayedFlush = -1;
            }
            this.flush();
        }
        processRecords()
        {
            let records = this.queue;
            for (let _i74 = 0, _this$observer$takeRe = this.observer.takeRecords(), _length74 = _this$observer$takeRe.length; _i74 < _length74; _i74++) {
                let mut = _this$observer$takeRe[_i74];
                records.push(mut);
            }
            if (records.length)
                this.queue = [];
            let from = -1,
                to = -1,
                typeOver = false;
            for (let _i75 = 0, _length75 = records.length; _i75 < _length75; _i75++) {
                let record = records[_i75];
                let range = this.readMutation(record);
                if (!range)
                    continue;
                if (range.typeOver)
                    typeOver = true;
                if (from == -1) {
                    ({from, to} = range);
                } else {
                    from = Math.min(range.from, from);
                    to = Math.max(range.to, to);
                }
            }
            return {
                from,
                to,
                typeOver
            };
        }
        readChange()
        {
            let {from, to, typeOver} = this.processRecords();
            let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
            if (from < 0 && !newSel)
                return null;
            if (from > -1)
                this.lastChange = Date.now();
            this.view.inputState.lastFocusTime = 0;
            this.selectionChanged = false;
            return new DOMChange(this.view, from, to, typeOver);
        }
        flush(readSelection=true)
        {
            if (this.delayedFlush >= 0 || this.delayedAndroidKey)
                return false;
            if (readSelection)
                this.readSelectionRange();
            let domChange = this.readChange();
            if (!domChange)
                return false;
            let startState = this.view.state;
            let handled = applyDOMChange(this.view, domChange);
            if (this.view.state == startState)
                this.view.update([]);
            return handled;
        }
        readMutation(rec)
        {
            let cView = this.view.docView.nearest(rec.target);
            if (!cView || cView.ignoreMutation(rec))
                return null;
            cView.markDirty(rec.type == "attributes");
            if (rec.type == "attributes")
                cView.dirty |= 4;
            if (rec.type == "childList") {
                let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
                let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
                return {
                    from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                    to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
                    typeOver: false
                };
            } else if (rec.type == "characterData") {
                return {
                    from: cView.posAtStart,
                    to: cView.posAtEnd,
                    typeOver: rec.target.nodeValue == rec.oldValue
                };
            } else {
                return null;
            }
        }
        setWindow(win)
        {
            if (win != this.win) {
                this.removeWindowListeners(this.win);
                this.win = win;
                this.addWindowListeners(this.win);
            }
        }
        addWindowListeners(win)
        {
            win.addEventListener("resize", this.onResize);
            win.addEventListener("beforeprint", this.onPrint);
            win.addEventListener("scroll", this.onScroll);
            win.document.addEventListener("selectionchange", this.onSelectionChange);
        }
        removeWindowListeners(win)
        {
            win.removeEventListener("scroll", this.onScroll);
            win.removeEventListener("resize", this.onResize);
            win.removeEventListener("beforeprint", this.onPrint);
            win.document.removeEventListener("selectionchange", this.onSelectionChange);
        }
        destroy()
        {
            var _a,
                _b,
                _c,
                _d;
            this.stop();
            (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
            (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
            (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
            (_d = this.resizeContent) === null || _d === void 0 ? void 0 : _d.disconnect();
            for (let _i76 = 0, _this$scrollTargets3 = this.scrollTargets, _length76 = _this$scrollTargets3.length; _i76 < _length76; _i76++) {
                let dom = _this$scrollTargets3[_i76];
                dom.removeEventListener("scroll", this.onScroll);
            }
            this.removeWindowListeners(this.win);
            clearTimeout(this.parentCheck);
            clearTimeout(this.resizeTimeout);
            this.win.cancelAnimationFrame(this.delayedFlush);
            this.win.cancelAnimationFrame(this.flushingAndroidKey);
        }
    }
    function findChild(cView, dom, dir) {
        while (dom) {
            let curView = ContentView.get(dom);
            if (curView && curView.parent == cView)
                return curView;
            let parent = dom.parentNode;
            dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
        }
        return null;
    }
    function safariSelectionRangeHack(view) {
        let found = null;
        function read(event) {
            event.preventDefault();
            event.stopImmediatePropagation();
            found = event.getTargetRanges()[0];
        }
        view.contentDOM.addEventListener("beforeinput", read, true);
        view.dom.ownerDocument.execCommand("indent");
        view.contentDOM.removeEventListener("beforeinput", read, true);
        if (!found)
            return null;
        let anchorNode = found.startContainer,
            anchorOffset = found.startOffset;
        let focusNode = found.endContainer,
            focusOffset = found.endOffset;
        let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
        if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
            [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
        return {
            anchorNode,
            anchorOffset,
            focusNode,
            focusOffset
        };
    }
    class EditorView {
        constructor(config={})
        {
            this.plugins = [];
            this.pluginMap = new Map();
            this.editorAttrs = {};
            this.contentAttrs = {};
            this.bidiCache = [];
            this.destroyed = false;
            this.updateState = 2;
            this.measureScheduled = -1;
            this.measureRequests = [];
            this.contentDOM = document.createElement("div");
            this.scrollDOM = document.createElement("div");
            this.scrollDOM.tabIndex = -1;
            this.scrollDOM.className = "cm-scroller";
            this.scrollDOM.appendChild(this.contentDOM);
            this.announceDOM = document.createElement("div");
            this.announceDOM.style.cssText = "position: fixed; top: -10000px";
            this.announceDOM.setAttribute("aria-live", "polite");
            this.dom = document.createElement("div");
            this.dom.appendChild(this.announceDOM);
            this.dom.appendChild(this.scrollDOM);
            this._dispatch = config.dispatch || (tr => this.update([tr]));
            this.dispatch = this.dispatch.bind(this);
            this._root = config.root || getRoot(config.parent) || document;
            this.viewState = new ViewState(config.state || EditorState.create(config));
            this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));
            for (let _i77 = 0, _this$plugins = this.plugins, _length77 = _this$plugins.length; _i77 < _length77; _i77++) {
                let plugin = _this$plugins[_i77];
                plugin.update(this);
            }
            this.observer = new DOMObserver(this);
            this.inputState = new InputState(this);
            this.inputState.ensureHandlers(this, this.plugins);
            this.docView = new DocView(this);
            this.mountStyles();
            this.updateAttrs();
            this.updateState = 0;
            this.requestMeasure();
            if (config.parent)
                config.parent.appendChild(this.dom);
        }
        get state()
        {
            return this.viewState.state;
        }
        get viewport()
        {
            return this.viewState.viewport;
        }
        get visibleRanges()
        {
            return this.viewState.visibleRanges;
        }
        get inView()
        {
            return this.viewState.inView;
        }
        get composing()
        {
            return this.inputState.composing > 0;
        }
        get compositionStarted()
        {
            return this.inputState.composing >= 0;
        }
        get root()
        {
            return this._root;
        }
        get win()
        {
            return this.dom.ownerDocument.defaultView || window;
        }
        dispatch(...input)
        {
            this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
        }
        update(transactions)
        {
            if (this.updateState != 0)
                throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
            let redrawn = false,
                attrsChanged = false,
                update;
            let state = this.state;
            for (let _i78 = 0, _length78 = transactions.length; _i78 < _length78; _i78++) {
                let tr = transactions[_i78];
                if (tr.startState != state)
                    throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
                state = tr.state;
            }
            if (this.destroyed) {
                this.viewState.state = state;
                return;
            }
            let pendingKey = this.observer.delayedAndroidKey,
                domChange = null;
            if (pendingKey) {
                this.observer.clearDelayedAndroidKey();
                domChange = this.observer.readChange();
                if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
                    domChange = null;
            } else {
                this.observer.clear();
            }
            if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
                return this.setState(state);
            update = ViewUpdate.create(this, state, transactions);
            let scrollTarget = this.viewState.scrollTarget;
            try {
                this.updateState = 2;
                for (let _i79 = 0, _length79 = transactions.length; _i79 < _length79; _i79++) {
                    let tr = transactions[_i79];
                    if (scrollTarget)
                        scrollTarget = scrollTarget.map(tr.changes);
                    if (tr.scrollIntoView) {
                        let {main} = tr.state.selection;
                        scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
                    }
                    for (let _i80 = 0, _tr$effects2 = tr.effects, _length80 = _tr$effects2.length; _i80 < _length80; _i80++) {
                        let e = _tr$effects2[_i80];
                        if (e.is(scrollIntoView$1))
                            scrollTarget = e.value;
                    }
                }
                this.viewState.update(update, scrollTarget);
                this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
                if (!update.empty) {
                    this.updatePlugins(update);
                    this.inputState.update(update);
                }
                redrawn = this.docView.update(update);
                if (this.state.facet(styleModule) != this.styleModules)
                    this.mountStyles();
                attrsChanged = this.updateAttrs();
                this.showAnnouncements(transactions);
                this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent("select.pointer")));
            } finally {
                this.updateState = 0;
            }
            if (update.startState.facet(theme) != update.state.facet(theme))
                this.viewState.mustMeasureContent = true;
            if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
                this.requestMeasure();
            if (!update.empty)
                for (let _i81 = 0, _this$state$facet = this.state.facet(updateListener), _length81 = _this$state$facet.length; _i81 < _length81; _i81++) {
                    let listener = _this$state$facet[_i81];
                    listener(update);
                }
            if (domChange) {
                if (!applyDOMChange(this, domChange) && pendingKey.force)
                    dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
            }
        }
        setState(newState)
        {
            if (this.updateState != 0)
                throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
            if (this.destroyed) {
                this.viewState.state = newState;
                return;
            }
            this.updateState = 2;
            let hadFocus = this.hasFocus;
            try {
                for (let _i82 = 0, _this$plugins2 = this.plugins, _length82 = _this$plugins2.length; _i82 < _length82; _i82++) {
                    let plugin = _this$plugins2[_i82];
                    plugin.destroy(this);
                }
                this.viewState = new ViewState(newState);
                this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));
                this.pluginMap.clear();
                for (let _i83 = 0, _this$plugins3 = this.plugins, _length83 = _this$plugins3.length; _i83 < _length83; _i83++) {
                    let plugin = _this$plugins3[_i83];
                    plugin.update(this);
                }
                this.docView = new DocView(this);
                this.inputState.ensureHandlers(this, this.plugins);
                this.mountStyles();
                this.updateAttrs();
                this.bidiCache = [];
            } finally {
                this.updateState = 0;
            }
            if (hadFocus)
                this.focus();
            this.requestMeasure();
        }
        updatePlugins(update)
        {
            let prevSpecs = update.startState.facet(viewPlugin),
                specs = update.state.facet(viewPlugin);
            if (prevSpecs != specs) {
                let newPlugins = [];
                for (let _i84 = 0, _length84 = specs.length; _i84 < _length84; _i84++) {
                    let spec = specs[_i84];
                    let found = prevSpecs.indexOf(spec);
                    if (found < 0) {
                        newPlugins.push(new PluginInstance(spec));
                    } else {
                        let plugin = this.plugins[found];
                        plugin.mustUpdate = update;
                        newPlugins.push(plugin);
                    }
                }
                for (let _i85 = 0, _this$plugins4 = this.plugins, _length85 = _this$plugins4.length; _i85 < _length85; _i85++) {
                    let plugin = _this$plugins4[_i85];
                    if (plugin.mustUpdate != update)
                        plugin.destroy(this);
                }
                this.plugins = newPlugins;
                this.pluginMap.clear();
                this.inputState.ensureHandlers(this, this.plugins);
            } else {
                for (let _i86 = 0, _this$plugins5 = this.plugins, _length86 = _this$plugins5.length; _i86 < _length86; _i86++) {
                    let p = _this$plugins5[_i86];
                    p.mustUpdate = update;
                }
            }
            for (let i = 0; i < this.plugins.length; i++)
                this.plugins[i].update(this);
        }
        measure(flush=true)
        {
            if (this.destroyed)
                return;
            if (this.measureScheduled > -1)
                cancelAnimationFrame(this.measureScheduled);
            this.measureScheduled = 0;
            if (flush)
                this.observer.forceFlush();
            let updated = null;
            let {scrollHeight, scrollTop, clientHeight} = this.scrollDOM;
            let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
            try {
                for (let i = 0; ; i++) {
                    this.updateState = 1;
                    let oldViewport = this.viewport;
                    let refBlock = this.viewState.lineBlockAtHeight(refHeight);
                    let changed = this.viewState.measure(this);
                    if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                        break;
                    if (i > 5) {
                        console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
                        break;
                    }
                    let measuring = [];
                    if (!(changed & 4))
                        [this.measureRequests, measuring] = [measuring, this.measureRequests];
                    let measured = measuring.map(m => {
                        try {
                            return m.read(this);
                        } catch (e) {
                            logException(this.state, e);
                            return BadMeasure;
                        }
                    });
                    let update = ViewUpdate.create(this, this.state, []),
                        redrawn = false,
                        scrolled = false;
                    update.flags |= changed;
                    if (!updated)
                        updated = update;
                    else
                        updated.flags |= changed;
                    this.updateState = 2;
                    if (!update.empty) {
                        this.updatePlugins(update);
                        this.inputState.update(update);
                        this.updateAttrs();
                        redrawn = this.docView.update(update);
                    }
                    for (let i = 0; i < measuring.length; i++)
                        if (measured[i] != BadMeasure) {
                            try {
                                let m = measuring[i];
                                if (m.write)
                                    m.write(measured[i], this);
                            } catch (e) {
                                logException(this.state, e);
                            }
                        }
                    if (this.viewState.editorHeight) {
                        if (this.viewState.scrollTarget) {
                            this.docView.scrollIntoView(this.viewState.scrollTarget);
                            this.viewState.scrollTarget = null;
                            scrolled = true;
                        } else {
                            let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
                            if (diff > 1 || diff < -1) {
                                this.scrollDOM.scrollTop += diff;
                                scrolled = true;
                            }
                        }
                    }
                    if (redrawn)
                        this.docView.updateSelection(true);
                    if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
                        break;
                }
            } finally {
                this.updateState = 0;
                this.measureScheduled = -1;
            }
            if (updated && !updated.empty)
                for (let _i87 = 0, _this$state$facet2 = this.state.facet(updateListener), _length87 = _this$state$facet2.length; _i87 < _length87; _i87++) {
                    let listener = _this$state$facet2[_i87];
                    listener(updated);
                }
        }
        get themeClasses()
        {
            return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
        }
        updateAttrs()
        {
            let editorAttrs = attrsFromFacet(this, editorAttributes, {
                class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
            });
            let contentAttrs = {
                spellcheck: "false",
                autocorrect: "off",
                autocapitalize: "off",
                translate: "no",
                contenteditable: !this.state.facet(editable) ? "false" : "true",
                class: "cm-content",
                style: `${browser.tabSize}: ${this.state.tabSize}`,
                role: "textbox",
                "aria-multiline": "true"
            };
            if (this.state.readOnly)
                contentAttrs["aria-readonly"] = "true";
            attrsFromFacet(this, contentAttributes, contentAttrs);
            let changed = this.observer.ignore(() => {
                let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
                let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
                return changedContent || changedEditor;
            });
            this.editorAttrs = editorAttrs;
            this.contentAttrs = contentAttrs;
            return changed;
        }
        showAnnouncements(trs)
        {
            let first = true;
            for (let _i88 = 0, _length88 = trs.length; _i88 < _length88; _i88++) {
                let tr = trs[_i88];
                for (let _i89 = 0, _tr$effects3 = tr.effects, _length89 = _tr$effects3.length; _i89 < _length89; _i89++) {
                    let effect = _tr$effects3[_i89];
                    if (effect.is(EditorView.announce)) {
                        if (first)
                            this.announceDOM.textContent = "";
                        first = false;
                        let div = this.announceDOM.appendChild(document.createElement("div"));
                        div.textContent = effect.value;
                    }
                }
            }
        }
        mountStyles()
        {
            this.styleModules = this.state.facet(styleModule);
            StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1$3).reverse());
        }
        readMeasured()
        {
            if (this.updateState == 2)
                throw new Error("Reading the editor layout isn't allowed during an update");
            if (this.updateState == 0 && this.measureScheduled > -1)
                this.measure(false);
        }
        requestMeasure(request)
        {
            if (this.measureScheduled < 0)
                this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
            if (request) {
                if (this.measureRequests.indexOf(request) > -1)
                    return;
                if (request.key != null)
                    for (let i = 0; i < this.measureRequests.length; i++) {
                        if (this.measureRequests[i].key === request.key) {
                            this.measureRequests[i] = request;
                            return;
                        }
                    }
                this.measureRequests.push(request);
            }
        }
        plugin(plugin)
        {
            let known = this.pluginMap.get(plugin);
            if (known === undefined || known && known.spec != plugin)
                this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);
            return known && known.update(this).value;
        }
        get documentTop()
        {
            return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
        }
        get documentPadding()
        {
            return {
                top: this.viewState.paddingTop,
                bottom: this.viewState.paddingBottom
            };
        }
        elementAtHeight(height)
        {
            this.readMeasured();
            return this.viewState.elementAtHeight(height);
        }
        lineBlockAtHeight(height)
        {
            this.readMeasured();
            return this.viewState.lineBlockAtHeight(height);
        }
        get viewportLineBlocks()
        {
            return this.viewState.viewportLines;
        }
        lineBlockAt(pos)
        {
            return this.viewState.lineBlockAt(pos);
        }
        get contentHeight()
        {
            return this.viewState.contentHeight;
        }
        moveByChar(start, forward, by)
        {
            return skipAtoms(this, start, moveByChar(this, start, forward, by));
        }
        moveByGroup(start, forward)
        {
            return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
        }
        moveToLineBoundary(start, forward, includeWrap=true)
        {
            return moveToLineBoundary(this, start, forward, includeWrap);
        }
        moveVertically(start, forward, distance)
        {
            return skipAtoms(this, start, moveVertically(this, start, forward, distance));
        }
        domAtPos(pos)
        {
            return this.docView.domAtPos(pos);
        }
        posAtDOM(node, offset=0)
        {
            return this.docView.posFromDOM(node, offset);
        }
        posAtCoords(coords, precise=true)
        {
            this.readMeasured();
            return posAtCoords(this, coords, precise);
        }
        coordsAtPos(pos, side=1)
        {
            this.readMeasured();
            let rect = this.docView.coordsAt(pos, side);
            if (!rect || rect.left == rect.right)
                return rect;
            let line = this.state.doc.lineAt(pos),
                order = this.bidiSpans(line);
            let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
            return flattenRect(rect, span.dir == Direction.LTR == side > 0);
        }
        get defaultCharacterWidth()
        {
            return this.viewState.heightOracle.charWidth;
        }
        get defaultLineHeight()
        {
            return this.viewState.heightOracle.lineHeight;
        }
        get textDirection()
        {
            return this.viewState.defaultTextDirection;
        }
        textDirectionAt(pos)
        {
            let perLine = this.state.facet(perLineTextDirection);
            if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
                return this.textDirection;
            this.readMeasured();
            return this.docView.textDirectionAt(pos);
        }
        get lineWrapping()
        {
            return this.viewState.heightOracle.lineWrapping;
        }
        bidiSpans(line)
        {
            if (line.length > MaxBidiLine)
                return trivialOrder(line.length);
            let dir = this.textDirectionAt(line.from);
            for (let _i90 = 0, _this$bidiCache = this.bidiCache, _length90 = _this$bidiCache.length; _i90 < _length90; _i90++) {
                let entry = _this$bidiCache[_i90];
                if (entry.from == line.from && entry.dir == dir)
                    return entry.order;
            }
            let order = computeOrder(line.text, dir);
            this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
            return order;
        }
        get hasFocus()
        {
            var _a;
            return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
        }
        focus()
        {
            this.observer.ignore(() => {
                focusPreventScroll(this.contentDOM);
                this.docView.updateSelection();
            });
        }
        setRoot(root)
        {
            if (this._root != root) {
                this._root = root;
                this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
                this.mountStyles();
            }
        }
        destroy()
        {
            for (let _i91 = 0, _this$plugins6 = this.plugins, _length91 = _this$plugins6.length; _i91 < _length91; _i91++) {
                let plugin = _this$plugins6[_i91];
                plugin.destroy(this);
            }
            this.plugins = [];
            this.inputState.destroy();
            this.dom.remove();
            this.observer.destroy();
            if (this.measureScheduled > -1)
                cancelAnimationFrame(this.measureScheduled);
            this.destroyed = true;
        }
        static scrollIntoView(pos, options={})
        {
            return scrollIntoView$1.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
        }
        static domEventHandlers(handlers)
        {
            return ViewPlugin.define(() => ({}), {
                eventHandlers: handlers
            });
        }
        static theme(spec, options)
        {
            let prefix = StyleModule.newName();
            let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
            if (options && options.dark)
                result.push(darkTheme.of(true));
            return result;
        }
        static baseTheme(spec)
        {
            return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
        }
        static findFromDOM(dom)
        {
            var _a;
            let content = dom.querySelector(".cm-content");
            let cView = content && ContentView.get(content) || ContentView.get(dom);
            return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
        }
    }
    EditorView.styleModule = styleModule;
    EditorView.inputHandler = inputHandler$1;
    EditorView.perLineTextDirection = perLineTextDirection;
    EditorView.exceptionSink = exceptionSink;
    EditorView.updateListener = updateListener;
    EditorView.editable = editable;
    EditorView.mouseSelectionStyle = mouseSelectionStyle;
    EditorView.dragMovesSelection = dragMovesSelection$1;
    EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
    EditorView.decorations = decorations;
    EditorView.atomicRanges = atomicRanges;
    EditorView.scrollMargins = scrollMargins;
    EditorView.darkTheme = darkTheme;
    EditorView.contentAttributes = contentAttributes;
    EditorView.editorAttributes = editorAttributes;
    EditorView.lineWrapping = EditorView.contentAttributes.of({
        "class": "cm-lineWrapping"
    });
    EditorView.announce = StateEffect.define();
    const MaxBidiLine = 4096;
    const BadMeasure = {};
    class CachedOrder {
        constructor(from, to, dir, order)
        {
            this.from = from;
            this.to = to;
            this.dir = dir;
            this.order = order;
        }
        static update(cache, changes)
        {
            if (changes.empty)
                return cache;
            let result = [],
                lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
            for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
                let entry = cache[i];
                if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
                    result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
            }
            return result;
        }
    }
    function attrsFromFacet(view, facet, base) {
        for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
            let source = sources[i],
                value = typeof source == "function" ? source(view) : source;
            if (value)
                combineAttrs(value, base);
        }
        return base;
    }
    const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
    function normalizeKeyName(name, platform) {
        const parts = name.split(/-(?!$)/);
        let result = parts[parts.length - 1];
        if (result == "Space")
            result = " ";
        let alt,
            ctrl,
            shift,
            meta;
        for (let i = 0; i < parts.length - 1; ++i) {
            const mod = parts[i];
            if (/^(cmd|meta|m)$/i.test(mod))
                meta = true;
            else if (/^a(lt)?$/i.test(mod))
                alt = true;
            else if (/^(c|ctrl|control)$/i.test(mod))
                ctrl = true;
            else if (/^s(hift)?$/i.test(mod))
                shift = true;
            else if (/^mod$/i.test(mod)) {
                if (platform == "mac")
                    meta = true;
                else
                    ctrl = true;
            } else
                throw new Error("Unrecognized modifier name: " + mod);
        }
        if (alt)
            result = "Alt-" + result;
        if (ctrl)
            result = "Ctrl-" + result;
        if (meta)
            result = "Meta-" + result;
        if (shift)
            result = "Shift-" + result;
        return result;
    }
    function modifiers(name, event, shift) {
        if (event.altKey)
            name = "Alt-" + name;
        if (event.ctrlKey)
            name = "Ctrl-" + name;
        if (event.metaKey)
            name = "Meta-" + name;
        if (shift !== false && event.shiftKey)
            name = "Shift-" + name;
        return name;
    }
    const handleKeyEvents = Prec.default(EditorView.domEventHandlers({
        keydown(event, view) {
            return runHandlers(getKeymap(view.state), event, view, "editor");
        }
    }));
    const keymap = Facet.define({
        enables: handleKeyEvents
    });
    const Keymaps = new WeakMap();
    function getKeymap(state) {
        let bindings = state.facet(keymap);
        let map = Keymaps.get(bindings);
        if (!map)
            Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
        return map;
    }
    function runScopeHandlers(view, event, scope) {
        return runHandlers(getKeymap(view.state), event, view, scope);
    }
    let storedPrefix = null;
    const PrefixTimeout = 4000;
    function buildKeymap(bindings, platform=currentPlatform) {
        let bound = Object.create(null);
        let isPrefix = Object.create(null);
        let checkPrefix = (name, is) => {
            let current = isPrefix[name];
            if (current == null)
                isPrefix[name] = is;
            else if (current != is)
                throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
        };
        let add = (scope, key, command, preventDefault) => {
            var _a,
                _b;
            let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
            let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
            for (let i = 1; i < parts.length; i++) {
                let prefix = parts.slice(0, i).join(" ");
                checkPrefix(prefix, true);
                if (!scopeObj[prefix])
                    scopeObj[prefix] = {
                        preventDefault: true,
                        run: [view => {
                            let ourObj = storedPrefix = {
                                view,
                                prefix,
                                scope
                            };
                            setTimeout(() => {
                                if (storedPrefix == ourObj)
                                    storedPrefix = null;
                            }, PrefixTimeout);
                            return true;
                        }]
                    };
            }
            let full = parts.join(" ");
            checkPrefix(full, false);
            let binding = scopeObj[full] || (scopeObj[full] = {
                preventDefault: false,
                run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
            });
            if (command)
                binding.run.push(command);
            if (preventDefault)
                binding.preventDefault = true;
        };
        for (let _i92 = 0, _length92 = bindings.length; _i92 < _length92; _i92++) {
            let b = bindings[_i92];
            let scopes = b.scope ? b.scope.split(" ") : ["editor"];
            if (b.any)
                for (let _i93 = 0, _length93 = scopes.length; _i93 < _length93; _i93++) {
                    let scope = scopes[_i93];
                    let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
                    if (!scopeObj._any)
                        scopeObj._any = {
                            preventDefault: false,
                            run: []
                        };
                    for (let key in scopeObj)
                        scopeObj[key].run.push(b.any);
                }
            let name = b[platform] || b.key;
            if (!name)
                continue;
            for (let _i94 = 0, _length94 = scopes.length; _i94 < _length94; _i94++) {
                let scope = scopes[_i94];
                add(scope, name, b.run, b.preventDefault);
                if (b.shift)
                    add(scope, "Shift-" + name, b.shift, b.preventDefault);
            }
        }
        return bound;
    }
    function runHandlers(map, event, view, scope) {
        let name = keyName(event);
        let charCode = codePointAt(name, 0),
            isChar = codePointSize(charCode) == name.length && name != " ";
        let prefix = "",
            fallthrough = false;
        if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
            prefix = storedPrefix.prefix + " ";
            if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
                storedPrefix = null;
        }
        let ran = new Set();
        let runFor = binding => {
            if (binding) {
                for (let _i95 = 0, _binding$run = binding.run, _length95 = _binding$run.length; _i95 < _length95; _i95++) {
                    let cmd = _binding$run[_i95];
                    if (!ran.has(cmd)) {
                        ran.add(cmd);
                        if (cmd(view, event))
                            return true;
                    }
                }
                if (binding.preventDefault)
                    fallthrough = true;
            }
            return false;
        };
        let scopeObj = map[scope],
            baseName,
            shiftName;
        if (scopeObj) {
            if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)]))
                return true;
            if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && !(browser.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
                if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
                    return true;
                else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)]))
                    return true;
            } else if (isChar && event.shiftKey) {
                if (runFor(scopeObj[prefix + modifiers(name, event, true)]))
                    return true;
            }
            if (runFor(scopeObj._any))
                return true;
        }
        return fallthrough;
    }
    class RectangleMarker {
        constructor(className, left, top, width, height)
        {
            this.className = className;
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
        }
        draw()
        {
            let elt = document.createElement("div");
            elt.className = this.className;
            this.adjust(elt);
            return elt;
        }
        update(elt, prev)
        {
            if (prev.className != this.className)
                return false;
            this.adjust(elt);
            return true;
        }
        adjust(elt)
        {
            elt.style.left = this.left + "px";
            elt.style.top = this.top + "px";
            if (this.width != null)
                elt.style.width = this.width + "px";
            elt.style.height = this.height + "px";
        }
        eq(p)
        {
            return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
        }
        static forRange(view, className, range)
        {
            if (range.empty) {
                let pos = view.coordsAtPos(range.head, range.assoc || 1);
                if (!pos)
                    return [];
                let base = getBase(view);
                return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];
            } else {
                return rectanglesForRange(view, className, range);
            }
        }
    }
    function getBase(view) {
        let rect = view.scrollDOM.getBoundingClientRect();
        let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
        return {
            left: left - view.scrollDOM.scrollLeft,
            top: rect.top - view.scrollDOM.scrollTop
        };
    }
    function wrappedLine(view, pos, inside) {
        let range = EditorSelection.cursor(pos);
        return {
            from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),
            to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),
            type: BlockType.Text
        };
    }
    function blockAt(view, pos) {
        let line = view.lineBlockAt(pos);
        if (Array.isArray(line.type))
            for (let _i96 = 0, _line$type = line.type, _length96 = _line$type.length; _i96 < _length96; _i96++) {
                let l = _line$type[_i96];
                if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
                    return l;
            }
        return line;
    }
    function rectanglesForRange(view, className, range) {
        if (range.to <= view.viewport.from || range.from >= view.viewport.to)
            return [];
        let from = Math.max(range.from, view.viewport.from),
            to = Math.min(range.to, view.viewport.to);
        let ltr = view.textDirection == Direction.LTR;
        let content = view.contentDOM,
            contentRect = content.getBoundingClientRect(),
            base = getBase(view);
        let lineStyle = window.getComputedStyle(content.firstChild);
        let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
        let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
        let startBlock = blockAt(view, from),
            endBlock = blockAt(view, to);
        let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
        let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
        if (view.lineWrapping) {
            if (visualStart)
                visualStart = wrappedLine(view, from, visualStart);
            if (visualEnd)
                visualEnd = wrappedLine(view, to, visualEnd);
        }
        if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
            return pieces(drawForLine(range.from, range.to, visualStart));
        } else {
            let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
            let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
            let between = [];
            if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
                between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
            else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)
                top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
            return pieces(top).concat(between).concat(pieces(bottom));
        }
        function piece(left, top, right, bottom) {
            return new RectangleMarker(className, left - base.left, top - base.top - 0.01, right - left, bottom - top + 0.01);
        }
        function pieces({top, bottom, horizontal}) {
            let pieces = [];
            for (let i = 0; i < horizontal.length; i += 2)
                pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
            return pieces;
        }
        function drawForLine(from, to, line) {
            let top = 1e9,
                bottom = -1e9,
                horizontal = [];
            function addSpan(from, fromOpen, to, toOpen, dir) {
                let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);
                let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);
                top = Math.min(fromCoords.top, toCoords.top, top);
                bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
                if (dir == Direction.LTR)
                    horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
                else
                    horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
            }
            let start = from !== null && from !== void 0 ? from : line.from,
                end = to !== null && to !== void 0 ? to : line.to;
            for (let _i97 = 0, _view$visibleRanges = view.visibleRanges, _length97 = _view$visibleRanges.length; _i97 < _length97; _i97++) {
                let r = _view$visibleRanges[_i97];
                if (r.to > start && r.from < end) {
                    for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ;) {
                        let docLine = view.state.doc.lineAt(pos);
                        for (let _i98 = 0, _view$bidiSpans = view.bidiSpans(docLine), _length98 = _view$bidiSpans.length; _i98 < _length98; _i98++) {
                            let span = _view$bidiSpans[_i98];
                            let spanFrom = span.from + docLine.from,
                                spanTo = span.to + docLine.from;
                            if (spanFrom >= endPos)
                                break;
                            if (spanTo > pos)
                                addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
                        }
                        pos = docLine.to + 1;
                        if (pos >= endPos)
                            break;
                    }
                }
            }
            if (horizontal.length == 0)
                addSpan(start, from == null, end, to == null, view.textDirection);
            return {
                top,
                bottom,
                horizontal
            };
        }
        function drawForWidget(block, top) {
            let y = contentRect.top + (top ? block.top : block.bottom);
            return {
                top: y,
                bottom: y,
                horizontal: []
            };
        }
    }
    function sameMarker(a, b) {
        return a.constructor == b.constructor && a.eq(b);
    }
    class LayerView {
        constructor(view, layer)
        {
            this.view = view;
            this.layer = layer;
            this.drawn = [];
            this.measureReq = {
                read: this.measure.bind(this),
                write: this.draw.bind(this)
            };
            this.dom = view.scrollDOM.appendChild(document.createElement("div"));
            this.dom.classList.add("cm-layer");
            if (layer.above)
                this.dom.classList.add("cm-layer-above");
            if (layer.class)
                this.dom.classList.add(layer.class);
            this.dom.setAttribute("aria-hidden", "true");
            this.setOrder(view.state);
            view.requestMeasure(this.measureReq);
            if (layer.mount)
                layer.mount(this.dom, view);
        }
        update(update)
        {
            if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
                this.setOrder(update.state);
            if (this.layer.update(update, this.dom) || update.geometryChanged)
                update.view.requestMeasure(this.measureReq);
        }
        setOrder(state)
        {
            let pos = 0,
                order = state.facet(layerOrder);
            while (pos < order.length && order[pos] != this.layer)
                pos++;
            this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
        }
        measure()
        {
            return this.layer.markers(this.view);
        }
        draw(markers)
        {
            if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
                let old = this.dom.firstChild,
                    oldI = 0;
                for (let _i99 = 0, _length99 = markers.length; _i99 < _length99; _i99++) {
                    let marker = markers[_i99];
                    if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
                        old = old.nextSibling;
                        oldI++;
                    } else {
                        this.dom.insertBefore(marker.draw(), old);
                    }
                }
                while (old) {
                    let next = old.nextSibling;
                    old.remove();
                    old = next;
                }
                this.drawn = markers;
            }
        }
        destroy()
        {
            if (this.layer.destroy)
                this.layer.destroy(this.dom, this.view);
            this.dom.remove();
        }
    }
    const layerOrder = Facet.define();
    function layer(config) {
        return [ViewPlugin.define(v => new LayerView(v, config)), layerOrder.of(config)];
    }
    const CanHidePrimary = !browser.ios;
    const selectionConfig = Facet.define({
        combine(configs) {
            return combineConfig(configs, {
                cursorBlinkRate: 1200,
                drawRangeCursor: true
            }, {
                cursorBlinkRate: (a, b) => Math.min(a, b),
                drawRangeCursor: (a, b) => a || b
            });
        }
    });
    function drawSelection(config={}) {
        return [selectionConfig.of(config), cursorLayer, selectionLayer, hideNativeSelection, nativeSelectionHidden.of(true)];
    }
    function configChanged$1(update) {
        return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
    }
    const cursorLayer = layer({
        above: true,
        markers(view) {
            let {state} = view,
                conf = state.facet(selectionConfig);
            let cursors = [];
            for (let _i100 = 0, _state$selection$rang3 = state.selection.ranges, _length100 = _state$selection$rang3.length; _i100 < _length100; _i100++) {
                let r = _state$selection$rang3[_i100];
                let prim = r == state.selection.main;
                if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
                    let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
                    let cursor = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
                    for (let _i101 = 0, _RectangleMarker$forR = RectangleMarker.forRange(view, className, cursor), _length101 = _RectangleMarker$forR.length; _i101 < _length101; _i101++) {
                        let piece = _RectangleMarker$forR[_i101];
                        cursors.push(piece);
                    }
                }
            }
            return cursors;
        },
        update(update, dom) {
            if (update.transactions.some(tr => tr.selection))
                dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
            let confChange = configChanged$1(update);
            if (confChange)
                setBlinkRate(update.state, dom);
            return update.docChanged || update.selectionSet || confChange;
        },
        mount(dom, view) {
            setBlinkRate(view.state, dom);
        },
        class: "cm-cursorLayer"
    });
    function setBlinkRate(state, dom) {
        dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    const selectionLayer = layer({
        above: false,
        markers(view) {
            return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
        },
        update(update, dom) {
            return update.docChanged || update.selectionSet || update.viewportChanged || configChanged$1(update);
        },
        class: "cm-selectionLayer"
    });
    const themeSpec = {
        ".cm-line": {
            "& ::selection": {
                backgroundColor: "transparent !important"
            },
            "&::selection": {
                backgroundColor: "transparent !important"
            }
        }
    };
    if (CanHidePrimary)
        themeSpec[".cm-line"].caretColor = "transparent !important";
    const hideNativeSelection = Prec.highest(EditorView.theme(themeSpec));
    const setDropCursorPos = StateEffect.define({
        map(pos, mapping) {
            return pos == null ? null : mapping.mapPos(pos);
        }
    });
    const dropCursorPos = StateField.define({
        create() {
            return null;
        },
        update(pos, tr) {
            if (pos != null)
                pos = tr.changes.mapPos(pos);
            return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);
        }
    });
    const drawDropCursor = ViewPlugin.fromClass(class {
        constructor(view)
        {
            this.view = view;
            this.cursor = null;
            this.measureReq = {
                read: this.readPos.bind(this),
                write: this.drawCursor.bind(this)
            };
        }
        update(update)
        {
            var _a;
            let cursorPos = update.state.field(dropCursorPos);
            if (cursorPos == null) {
                if (this.cursor != null) {
                    (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
                    this.cursor = null;
                }
            } else {
                if (!this.cursor) {
                    this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
                    this.cursor.className = "cm-dropCursor";
                }
                if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
                    this.view.requestMeasure(this.measureReq);
            }
        }
        readPos()
        {
            let pos = this.view.state.field(dropCursorPos);
            let rect = pos != null && this.view.coordsAtPos(pos);
            if (!rect)
                return null;
            let outer = this.view.scrollDOM.getBoundingClientRect();
            return {
                left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
                top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
                height: rect.bottom - rect.top
            };
        }
        drawCursor(pos)
        {
            if (this.cursor) {
                if (pos) {
                    this.cursor.style.left = pos.left + "px";
                    this.cursor.style.top = pos.top + "px";
                    this.cursor.style.height = pos.height + "px";
                } else {
                    this.cursor.style.left = "-100000px";
                }
            }
        }
        destroy()
        {
            if (this.cursor)
                this.cursor.remove();
        }
        setDropPos(pos)
        {
            if (this.view.state.field(dropCursorPos) != pos)
                this.view.dispatch({
                    effects: setDropCursorPos.of(pos)
                });
        }
    }
    , {
        eventHandlers: {
            dragover(event) {
                this.setDropPos(this.view.posAtCoords({
                    x: event.clientX,
                    y: event.clientY
                }));
            },
            dragleave(event) {
                if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
                    this.setDropPos(null);
            },
            dragend() {
                this.setDropPos(null);
            },
            drop() {
                this.setDropPos(null);
            }
        }
    });
    function dropCursor() {
        return [dropCursorPos, drawDropCursor];
    }
    function iterMatches(doc, re, from, to, f) {
        re.lastIndex = 0;
        for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
            if (!cursor.lineBreak)
                while (m = re.exec(cursor.value))
                    f(pos + m.index, m);
        }
    }
    function matchRanges(view, maxLength) {
        let visible = view.visibleRanges;
        if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
            return visible;
        let result = [];
        for (let _i102 = 0, _length102 = visible.length; _i102 < _length102; _i102++) {
            let {from, to} = visible[_i102];
            from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
            to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
            if (result.length && result[result.length - 1].to >= from)
                result[result.length - 1].to = to;
            else
                result.push({
                    from,
                    to
                });
        }
        return result;
    }
    class MatchDecorator {
        constructor(config)
        {
            const {regexp, decoration, decorate, boundary, maxLength=1000} = config;
            if (!regexp.global)
                throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
            this.regexp = regexp;
            if (decorate) {
                this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
            } else if (typeof decoration == "function") {
                this.addMatch = (match, view, from, add) => {
                    let deco = decoration(match, view, from);
                    if (deco)
                        add(from, from + match[0].length, deco);
                };
            } else if (decoration) {
                this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
            } else {
                throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
            }
            this.boundary = boundary;
            this.maxLength = maxLength;
        }
        createDeco(view)
        {
            let build = new RangeSetBuilder(),
                add = build.add.bind(build);
            for (let _i103 = 0, _matchRanges = matchRanges(view, this.maxLength), _length103 = _matchRanges.length; _i103 < _length103; _i103++) {
                let {from, to} = _matchRanges[_i103];
                iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));
            }
            return build.finish();
        }
        updateDeco(update, deco)
        {
            let changeFrom = 1e9,
                changeTo = -1;
            if (update.docChanged)
                update.changes.iterChanges((_f, _t, from, to) => {
                    if (to > update.view.viewport.from && from < update.view.viewport.to) {
                        changeFrom = Math.min(from, changeFrom);
                        changeTo = Math.max(to, changeTo);
                    }
                });
            if (update.viewportChanged || changeTo - changeFrom > 1000)
                return this.createDeco(update.view);
            if (changeTo > -1)
                return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
            return deco;
        }
        updateRange(view, deco, updateFrom, updateTo)
        {
            for (let _i104 = 0, _view$visibleRanges2 = view.visibleRanges, _length104 = _view$visibleRanges2.length; _i104 < _length104; _i104++) {
                let r = _view$visibleRanges2[_i104];
                let from = Math.max(r.from, updateFrom),
                    to = Math.min(r.to, updateTo);
                if (to > from) {
                    let fromLine = view.state.doc.lineAt(from),
                        toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
                    let start = Math.max(r.from, fromLine.from),
                        end = Math.min(r.to, toLine.to);
                    if (this.boundary) {
                        for (; from > fromLine.from; from--)
                            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                                start = from;
                                break;
                            }
                        for (; to < toLine.to; to++)
                            if (this.boundary.test(toLine.text[to - toLine.from])) {
                                end = to;
                                break;
                            }
                    }
                    let ranges = [],
                        m;
                    let add = (from, to, deco) => ranges.push(deco.range(from, to));
                    if (fromLine == toLine) {
                        this.regexp.lastIndex = start - fromLine.from;
                        while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                            this.addMatch(m, view, m.index + fromLine.from, add);
                    } else {
                        iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));
                    }
                    deco = deco.update({
                        filterFrom: start,
                        filterTo: end,
                        filter: (from, to) => from < start || to > end,
                        add: ranges
                    });
                }
            }
            return deco;
        }
    }
    const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
    const Specials = new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
    const Names = {
        0: "null",
        7: "bell",
        8: "backspace",
        10: "newline",
        11: "vertical tab",
        13: "carriage return",
        27: "escape",
        8203: "zero width space",
        8204: "zero width non-joiner",
        8205: "zero width joiner",
        8206: "left-to-right mark",
        8207: "right-to-left mark",
        8232: "line separator",
        8237: "left-to-right override",
        8238: "right-to-left override",
        8294: "left-to-right isolate",
        8295: "right-to-left isolate",
        8297: "pop directional isolate",
        8233: "paragraph separator",
        65279: "zero width no-break space",
        65532: "object replacement"
    };
    let _supportsTabSize = null;
    function supportsTabSize() {
        var _a;
        if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
            let styles = document.body.style;
            _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
        }
        return _supportsTabSize || false;
    }
    const specialCharConfig = Facet.define({
        combine(configs) {
            let config = combineConfig(configs, {
                render: null,
                specialChars: Specials,
                addSpecialChars: null
            });
            if (config.replaceTabs = !supportsTabSize())
                config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
            if (config.addSpecialChars)
                config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
            return config;
        }
    });
    function highlightSpecialChars(config={}) {
        return [specialCharConfig.of(config), specialCharPlugin()];
    }
    let _plugin = null;
    function specialCharPlugin() {
        return _plugin || (_plugin = ViewPlugin.fromClass(class {
                constructor(view)
                {
                    this.view = view;
                    this.decorations = Decoration.none;
                    this.decorationCache = Object.create(null);
                    this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
                    this.decorations = this.decorator.createDeco(view);
                }
                makeDecorator(conf)
                {
                    return new MatchDecorator({
                        regexp: conf.specialChars,
                        decoration: (m, view, pos) => {
                            let {doc} = view.state;
                            let code = codePointAt(m[0], 0);
                            if (code == 9) {
                                let line = doc.lineAt(pos);
                                let size = view.state.tabSize,
                                    col = countColumn(line.text, size, pos - line.from);
                                return Decoration.replace({
                                    widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth)
                                });
                            }
                            return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({
                                    widget: new SpecialCharWidget(conf, code)
                                }));
                        },
                        boundary: conf.replaceTabs ? undefined : /[^]/
                    });
                }
                update(update)
                {
                    let conf = update.state.facet(specialCharConfig);
                    if (update.startState.facet(specialCharConfig) != conf) {
                        this.decorator = this.makeDecorator(conf);
                        this.decorations = this.decorator.createDeco(update.view);
                    } else {
                        this.decorations = this.decorator.updateDeco(update, this.decorations);
                    }
                }
            }
            , {
                decorations: v => v.decorations
            }));
    }
    const DefaultPlaceholder = "\u2022";
    function placeholder$1(code) {
        if (code >= 32)
            return DefaultPlaceholder;
        if (code == 10)
            return "\u2424";
        return String.fromCharCode(9216 + code);
    }
    class SpecialCharWidget extends WidgetType {
        constructor(options, code)
        {
            super();
            this.options = options;
            this.code = code;
        }
        eq(other)
        {
            return other.code == this.code;
        }
        toDOM(view)
        {
            let ph = placeholder$1(this.code);
            let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
            let custom = this.options.render && this.options.render(this.code, desc, ph);
            if (custom)
                return custom;
            let span = document.createElement("span");
            span.textContent = ph;
            span.title = desc;
            span.setAttribute("aria-label", desc);
            span.className = "cm-specialChar";
            return span;
        }
        ignoreEvent()
        {
            return false;
        }
    }
    class TabWidget extends WidgetType {
        constructor(width)
        {
            super();
            this.width = width;
        }
        eq(other)
        {
            return other.width == this.width;
        }
        toDOM()
        {
            let span = document.createElement("span");
            span.textContent = "\t";
            span.className = "cm-tab";
            span.style.width = this.width + "px";
            return span;
        }
        ignoreEvent()
        {
            return false;
        }
    }
    const plugin = ViewPlugin.fromClass(class {
        constructor()
        {
            this.height = 1000;
            this.attrs = {
                style: "padding-bottom: 1000px"
            };
        }
        update(update)
        {
            let {view} = update;
            let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;
            if (height != this.height) {
                this.height = height;
                this.attrs = {
                    style: `padding-bottom: ${height}px`
                };
            }
        }
    }
    );
    function scrollPastEnd() {
        return [plugin, contentAttributes.of(view => {
            var _a;
            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;
        })];
    }
    function highlightActiveLine() {
        return activeLineHighlighter;
    }
    const lineDeco = Decoration.line({
        class: "cm-activeLine"
    });
    const activeLineHighlighter = ViewPlugin.fromClass(class {
        constructor(view)
        {
            this.decorations = this.getDeco(view);
        }
        update(update)
        {
            if (update.docChanged || update.selectionSet)
                this.decorations = this.getDeco(update.view);
        }
        getDeco(view)
        {
            let lastLineStart = -1,
                deco = [];
            for (let _i105 = 0, _view$state$selection = view.state.selection.ranges, _length105 = _view$state$selection.length; _i105 < _length105; _i105++) {
                let r = _view$state$selection[_i105];
                let line = view.lineBlockAt(r.head);
                if (line.from > lastLineStart) {
                    deco.push(lineDeco.range(line.from));
                    lastLineStart = line.from;
                }
            }
            return Decoration.set(deco);
        }
    }
    , {
        decorations: v => v.decorations
    });
    class Placeholder extends WidgetType {
        constructor(content)
        {
            super();
            this.content = content;
        }
        toDOM()
        {
            let wrap = document.createElement("span");
            wrap.className = "cm-placeholder";
            wrap.style.pointerEvents = "none";
            wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content);
            if (typeof this.content == "string")
                wrap.setAttribute("aria-label", "placeholder " + this.content);
            else
                wrap.setAttribute("aria-hidden", "true");
            return wrap;
        }
        ignoreEvent()
        {
            return false;
        }
    }
    function placeholder(content) {
        return ViewPlugin.fromClass(class {
            constructor(view)
            {
                this.view = view;
                this.placeholder = Decoration.set([Decoration.widget({
                    widget: new Placeholder(content),
                    side: 1
                }).range(0)]);
            }
            get decorations()
            {
                return this.view.state.doc.length ? Decoration.none : this.placeholder;
            }
        }
        , {
            decorations: v => v.decorations
        });
    }
    const MaxOff = 2000;
    function rectangleFor(state, a, b) {
        let startLine = Math.min(a.line, b.line),
            endLine = Math.max(a.line, b.line);
        let ranges = [];
        if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
            let startOff = Math.min(a.off, b.off),
                endOff = Math.max(a.off, b.off);
            for (let i = startLine; i <= endLine; i++) {
                let line = state.doc.line(i);
                if (line.length <= endOff)
                    ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
            }
        } else {
            let startCol = Math.min(a.col, b.col),
                endCol = Math.max(a.col, b.col);
            for (let i = startLine; i <= endLine; i++) {
                let line = state.doc.line(i);
                let start = findColumn(line.text, startCol, state.tabSize, true);
                if (start < 0) {
                    ranges.push(EditorSelection.cursor(line.to));
                } else {
                    let end = findColumn(line.text, endCol, state.tabSize);
                    ranges.push(EditorSelection.range(line.from + start, line.from + end));
                }
            }
        }
        return ranges;
    }
    function absoluteColumn(view, x) {
        let ref = view.coordsAtPos(view.viewport.from);
        return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
    }
    function getPos(view, event) {
        let offset = view.posAtCoords({
            x: event.clientX,
            y: event.clientY
        }, false);
        let line = view.state.doc.lineAt(offset),
            off = offset - line.from;
        let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
        return {
            line: line.number,
            col,
            off
        };
    }
    function rectangleSelectionStyle(view, event) {
        let start = getPos(view, event),
            startSel = view.state.selection;
        if (!start)
            return null;
        return {
            update(update) {
                if (update.docChanged) {
                    let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                    let newLine = update.state.doc.lineAt(newStart);
                    start = {
                        line: newLine.number,
                        col: start.col,
                        off: Math.min(start.off, newLine.length)
                    };
                    startSel = startSel.map(update.changes);
                }
            },
            get(event, _extend, multiple) {
                let cur = getPos(view, event);
                if (!cur)
                    return startSel;
                let ranges = rectangleFor(view.state, start, cur);
                if (!ranges.length)
                    return startSel;
                if (multiple)
                    return EditorSelection.create(ranges.concat(startSel.ranges));
                else
                    return EditorSelection.create(ranges);
            }
        };
    }
    function rectangularSelection(options) {
        let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
        return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
    }
    const keys = {
        Alt: [18, e => e.altKey],
        Control: [17, e => e.ctrlKey],
        Shift: [16, e => e.shiftKey],
        Meta: [91, e => e.metaKey]
    };
    const showCrosshair = {
        style: "cursor: crosshair"
    };
    function crosshairCursor(options={}) {
        let [code, getter] = keys[options.key || "Alt"];
        let plugin = ViewPlugin.fromClass(class {
            constructor(view)
            {
                this.view = view;
                this.isDown = false;
            }
            set(isDown)
            {
                if (this.isDown != isDown) {
                    this.isDown = isDown;
                    this.view.update([]);
                }
            }
        }
        , {
            eventHandlers: {
                keydown(e) {
                    this.set(e.keyCode == code || getter(e));
                },
                keyup(e) {
                    if (e.keyCode == code || !getter(e))
                        this.set(false);
                },
                mousemove(e) {
                    this.set(getter(e));
                }
            }
        });
        return [plugin, EditorView.contentAttributes.of(view => {
            var _a;
            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;
        })];
    }
    const Outside = "-10000px";
    class TooltipViewManager {
        constructor(view, facet, createTooltipView)
        {
            this.facet = facet;
            this.createTooltipView = createTooltipView;
            this.input = view.state.facet(facet);
            this.tooltips = this.input.filter(t => t);
            this.tooltipViews = this.tooltips.map(createTooltipView);
        }
        update(update)
        {
            var _a;
            let input = update.state.facet(this.facet);
            let tooltips = input.filter(x => x);
            if (input === this.input) {
                for (let _i106 = 0, _this$tooltipViews = this.tooltipViews, _length106 = _this$tooltipViews.length; _i106 < _length106; _i106++) {
                    let t = _this$tooltipViews[_i106];
                    if (t.update)
                        t.update(update);
                }
                return false;
            }
            let tooltipViews = [];
            for (let i = 0; i < tooltips.length; i++) {
                let tip = tooltips[i],
                    known = -1;
                if (!tip)
                    continue;
                for (let i = 0; i < this.tooltips.length; i++) {
                    let other = this.tooltips[i];
                    if (other && other.create == tip.create)
                        known = i;
                }
                if (known < 0) {
                    tooltipViews[i] = this.createTooltipView(tip);
                } else {
                    let tooltipView = tooltipViews[i] = this.tooltipViews[known];
                    if (tooltipView.update)
                        tooltipView.update(update);
                }
            }
            for (let _i107 = 0, _this$tooltipViews2 = this.tooltipViews, _length107 = _this$tooltipViews2.length; _i107 < _length107; _i107++) {
                let t = _this$tooltipViews2[_i107];
                if (tooltipViews.indexOf(t) < 0) {
                    t.dom.remove();
                    (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
                }
            }
            this.input = input;
            this.tooltips = tooltips;
            this.tooltipViews = tooltipViews;
            return true;
        }
    }
    function tooltips(config={}) {
        return tooltipConfig.of(config);
    }
    function windowSpace(view) {
        let {win} = view;
        return {
            top: 0,
            left: 0,
            bottom: win.innerHeight,
            right: win.innerWidth
        };
    }
    const tooltipConfig = Facet.define({
        combine: values => {
            var _a,
                _b,
                _c;
            return {
                position: browser.ios ? "absolute" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
                parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
                tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
            };
        }
    });
    const tooltipPlugin = ViewPlugin.fromClass(class {
        constructor(view)
        {
            this.view = view;
            this.inView = true;
            this.lastTransaction = 0;
            this.measureTimeout = -1;
            let config = view.state.facet(tooltipConfig);
            this.position = config.position;
            this.parent = config.parent;
            this.classes = view.themeClasses;
            this.createContainer();
            this.measureReq = {
                read: this.readMeasure.bind(this),
                write: this.writeMeasure.bind(this),
                key: this
            };
            this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t));
            this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(entries => {
                if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
                    this.measureSoon();
            }, {
                threshold: [1]
            }) : null;
            this.observeIntersection();
            view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
            this.maybeMeasure();
        }
        createContainer()
        {
            if (this.parent) {
                this.container = document.createElement("div");
                this.container.style.position = "relative";
                this.container.className = this.view.themeClasses;
                this.parent.appendChild(this.container);
            } else {
                this.container = this.view.dom;
            }
        }
        observeIntersection()
        {
            if (this.intersectionObserver) {
                this.intersectionObserver.disconnect();
                for (let _i108 = 0, _this$manager$tooltip = this.manager.tooltipViews, _length108 = _this$manager$tooltip.length; _i108 < _length108; _i108++) {
                    let tooltip = _this$manager$tooltip[_i108];
                    this.intersectionObserver.observe(tooltip.dom);
                }
            }
        }
        measureSoon()
        {
            if (this.measureTimeout < 0)
                this.measureTimeout = setTimeout(() => {
                    this.measureTimeout = -1;
                    this.maybeMeasure();
                }, 50);
        }
        update(update)
        {
            if (update.transactions.length)
                this.lastTransaction = Date.now();
            let updated = this.manager.update(update);
            if (updated)
                this.observeIntersection();
            let shouldMeasure = updated || update.geometryChanged;
            let newConfig = update.state.facet(tooltipConfig);
            if (newConfig.position != this.position) {
                this.position = newConfig.position;
                for (let _i109 = 0, _this$manager$tooltip2 = this.manager.tooltipViews, _length109 = _this$manager$tooltip2.length; _i109 < _length109; _i109++) {
                    let t = _this$manager$tooltip2[_i109];
                    t.dom.style.position = this.position;
                }
                shouldMeasure = true;
            }
            if (newConfig.parent != this.parent) {
                if (this.parent)
                    this.container.remove();
                this.parent = newConfig.parent;
                this.createContainer();
                for (let _i110 = 0, _this$manager$tooltip3 = this.manager.tooltipViews, _length110 = _this$manager$tooltip3.length; _i110 < _length110; _i110++) {
                    let t = _this$manager$tooltip3[_i110];
                    this.container.appendChild(t.dom);
                }
                shouldMeasure = true;
            } else if (this.parent && this.view.themeClasses != this.classes) {
                this.classes = this.container.className = this.view.themeClasses;
            }
            if (shouldMeasure)
                this.maybeMeasure();
        }
        createTooltip(tooltip)
        {
            let tooltipView = tooltip.create(this.view);
            tooltipView.dom.classList.add("cm-tooltip");
            if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
                let arrow = document.createElement("div");
                arrow.className = "cm-tooltip-arrow";
                tooltipView.dom.appendChild(arrow);
            }
            tooltipView.dom.style.position = this.position;
            tooltipView.dom.style.top = Outside;
            this.container.appendChild(tooltipView.dom);
            if (tooltipView.mount)
                tooltipView.mount(this.view);
            return tooltipView;
        }
        destroy()
        {
            var _a,
                _b;
            this.view.win.removeEventListener("resize", this.measureSoon);
            for (let _i111 = 0, _this$manager$tooltip4 = this.manager.tooltipViews, _length111 = _this$manager$tooltip4.length; _i111 < _length111; _i111++) {
                let tooltipView = _this$manager$tooltip4[_i111];
                tooltipView.dom.remove();
                (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);
            }
            (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
            clearTimeout(this.measureTimeout);
        }
        readMeasure()
        {
            let editor = this.view.dom.getBoundingClientRect();
            return {
                editor,
                parent: this.parent ? this.container.getBoundingClientRect() : editor,
                pos: this.manager.tooltips.map((t, i) => {
                    let tv = this.manager.tooltipViews[i];
                    return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
                }),
                size: this.manager.tooltipViews.map(({dom}) => dom.getBoundingClientRect()),
                space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
            };
        }
        writeMeasure(measured)
        {
            let {editor, space} = measured;
            let others = [];
            for (let i = 0; i < this.manager.tooltips.length; i++) {
                let tooltip = this.manager.tooltips[i],
                    tView = this.manager.tooltipViews[i],
                    {dom} = tView;
                let pos = measured.pos[i],
                    size = measured.size[i];
                if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - .1 || pos.left > Math.min(editor.right, space.right) + .1) {
                    dom.style.top = Outside;
                    continue;
                }
                let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
                let arrowHeight = arrow ? 7 : 0;
                let width = size.right - size.left,
                    height = size.bottom - size.top;
                let offset = tView.offset || noOffset,
                    ltr = this.view.textDirection == Direction.LTR;
                let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
                let above = !!tooltip.above;
                if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
                    above = !above;
                let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
                if (spaceVert < height && tView.resize !== false) {
                    if (spaceVert < this.view.defaultLineHeight) {
                        dom.style.top = Outside;
                        continue;
                    }
                    dom.style.height = (height = spaceVert) + "px";
                } else if (dom.style.height) {
                    dom.style.height = "";
                }
                let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
                let right = left + width;
                if (tView.overlap !== true)
                    for (let _i112 = 0, _length112 = others.length; _i112 < _length112; _i112++) {
                        let r = others[_i112];
                        if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                            top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
                    }
                if (this.position == "absolute") {
                    dom.style.top = top - measured.parent.top + "px";
                    dom.style.left = left - measured.parent.left + "px";
                } else {
                    dom.style.top = top + "px";
                    dom.style.left = left + "px";
                }
                if (arrow)
                    arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)}px`;
                if (tView.overlap !== true)
                    others.push({
                        left,
                        top,
                        right,
                        bottom: top + height
                    });
                dom.classList.toggle("cm-tooltip-above", above);
                dom.classList.toggle("cm-tooltip-below", !above);
                if (tView.positioned)
                    tView.positioned(measured.space);
            }
        }
        maybeMeasure()
        {
            if (this.manager.tooltips.length) {
                if (this.view.inView)
                    this.view.requestMeasure(this.measureReq);
                if (this.inView != this.view.inView) {
                    this.inView = this.view.inView;
                    if (!this.inView)
                        for (let _i113 = 0, _this$manager$tooltip5 = this.manager.tooltipViews, _length113 = _this$manager$tooltip5.length; _i113 < _length113; _i113++) {
                            let tv = _this$manager$tooltip5[_i113];
                            tv.dom.style.top = Outside;
                        }
                }
            }
        }
    }
    , {
        eventHandlers: {
            scroll() {
                this.maybeMeasure();
            }
        }
    });
    const baseTheme$5 = EditorView.baseTheme({
        ".cm-tooltip": {
            zIndex: 100,
            boxSizing: "border-box"
        },
        "&light .cm-tooltip": {
            border: "1px solid #bbb",
            backgroundColor: "#f5f5f5"
        },
        "&light .cm-tooltip-section:not(:first-child)": {
            borderTop: "1px solid #bbb"
        },
        "&dark .cm-tooltip": {
            backgroundColor: "#333338",
            color: "white"
        },
        ".cm-tooltip-arrow": {
            height: `${7}px`,
            width: `${7 * 2}px`,
            position: "absolute",
            zIndex: -1,
            overflow: "hidden",
            "&:before, &:after": {
                content: "''",
                position: "absolute",
                width: 0,
                height: 0,
                borderLeft: `${7}px solid transparent`,
                borderRight: `${7}px solid transparent`
            },
            ".cm-tooltip-above &": {
                bottom: `-${7}px`,
                "&:before": {
                    borderTop: `${7}px solid #bbb`
                },
                "&:after": {
                    borderTop: `${7}px solid #f5f5f5`,
                    bottom: "1px"
                }
            },
            ".cm-tooltip-below &": {
                top: `-${7}px`,
                "&:before": {
                    borderBottom: `${7}px solid #bbb`
                },
                "&:after": {
                    borderBottom: `${7}px solid #f5f5f5`,
                    top: "1px"
                }
            }
        },
        "&dark .cm-tooltip .cm-tooltip-arrow": {
            "&:before": {
                borderTopColor: "#333338",
                borderBottomColor: "#333338"
            },
            "&:after": {
                borderTopColor: "transparent",
                borderBottomColor: "transparent"
            }
        }
    });
    const noOffset = {
        x: 0,
        y: 0
    };
    const showTooltip = Facet.define({
        enables: [tooltipPlugin, baseTheme$5]
    });
    const showHoverTooltip = Facet.define();
    class HoverTooltipHost {
        constructor(view)
        {
            this.view = view;
            this.mounted = false;
            this.dom = document.createElement("div");
            this.dom.classList.add("cm-tooltip-hover");
            this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t));
        }
        static create(view)
        {
            return new HoverTooltipHost(view);
        }
        createHostedView(tooltip)
        {
            let hostedView = tooltip.create(this.view);
            hostedView.dom.classList.add("cm-tooltip-section");
            this.dom.appendChild(hostedView.dom);
            if (this.mounted && hostedView.mount)
                hostedView.mount(this.view);
            return hostedView;
        }
        mount(view)
        {
            for (let _i114 = 0, _this$manager$tooltip6 = this.manager.tooltipViews, _length114 = _this$manager$tooltip6.length; _i114 < _length114; _i114++) {
                let hostedView = _this$manager$tooltip6[_i114];
                if (hostedView.mount)
                    hostedView.mount(view);
            }
            this.mounted = true;
        }
        positioned(space)
        {
            for (let _i115 = 0, _this$manager$tooltip7 = this.manager.tooltipViews, _length115 = _this$manager$tooltip7.length; _i115 < _length115; _i115++) {
                let hostedView = _this$manager$tooltip7[_i115];
                if (hostedView.positioned)
                    hostedView.positioned(space);
            }
        }
        update(update)
        {
            this.manager.update(update);
        }
    }
    const showHoverTooltipHost = showTooltip.compute([showHoverTooltip], state => {
        let tooltips = state.facet(showHoverTooltip).filter(t => t);
        if (tooltips.length === 0)
            return null;
        return {
            pos: Math.min(...tooltips.map(t => t.pos)),
            end: Math.max(...tooltips.filter(t => t.end != null).map(t => t.end)),
            create: HoverTooltipHost.create,
            above: tooltips[0].above,
            arrow: tooltips.some(t => t.arrow)
        };
    });
    class HoverPlugin {
        constructor(view, source, field, setHover, hoverTime)
        {
            this.view = view;
            this.source = source;
            this.field = field;
            this.setHover = setHover;
            this.hoverTime = hoverTime;
            this.hoverTimeout = -1;
            this.restartTimeout = -1;
            this.pending = null;
            this.lastMove = {
                x: 0,
                y: 0,
                target: view.dom,
                time: 0
            };
            this.checkHover = this.checkHover.bind(this);
            view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
            view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
        }
        update()
        {
            if (this.pending) {
                this.pending = null;
                clearTimeout(this.restartTimeout);
                this.restartTimeout = setTimeout(() => this.startHover(), 20);
            }
        }
        get active()
        {
            return this.view.state.field(this.field);
        }
        checkHover()
        {
            this.hoverTimeout = -1;
            if (this.active)
                return;
            let hovered = Date.now() - this.lastMove.time;
            if (hovered < this.hoverTime)
                this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
            else
                this.startHover();
        }
        startHover()
        {
            clearTimeout(this.restartTimeout);
            let {lastMove} = this;
            let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
            if (pos == null)
                return;
            let posCoords = this.view.coordsAtPos(pos);
            if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
                return;
            let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
            let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
            if (open === null || open === void 0 ? void 0 : open.then) {
                let pending = this.pending = {
                    pos
                };
                open.then(result => {
                    if (this.pending == pending) {
                        this.pending = null;
                        if (result)
                            this.view.dispatch({
                                effects: this.setHover.of(result)
                            });
                    }
                }, e => logException(this.view.state, e, "hover tooltip"));
            } else if (open) {
                this.view.dispatch({
                    effects: this.setHover.of(open)
                });
            }
        }
        mousemove(event)
        {
            var _a;
            this.lastMove = {
                x: event.clientX,
                y: event.clientY,
                target: event.target,
                time: Date.now()
            };
            if (this.hoverTimeout < 0)
                this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
            let tooltip = this.active;
            if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
                let {pos} = tooltip || this.pending,
                    end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;
                if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6)) {
                    this.view.dispatch({
                        effects: this.setHover.of(null)
                    });
                    this.pending = null;
                }
            }
        }
        mouseleave(e)
        {
            clearTimeout(this.hoverTimeout);
            this.hoverTimeout = -1;
            if (this.active && !isInTooltip(e.relatedTarget))
                this.view.dispatch({
                    effects: this.setHover.of(null)
                });
        }
        destroy()
        {
            clearTimeout(this.hoverTimeout);
            this.view.dom.removeEventListener("mouseleave", this.mouseleave);
            this.view.dom.removeEventListener("mousemove", this.mousemove);
        }
    }
    function isInTooltip(elt) {
        for (let cur = elt; cur; cur = cur.parentNode)
            if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip"))
                return true;
        return false;
    }
    function isOverRange(view, from, to, x, y, margin) {
        let range = document.createRange();
        let fromDOM = view.domAtPos(from),
            toDOM = view.domAtPos(to);
        range.setEnd(toDOM.node, toDOM.offset);
        range.setStart(fromDOM.node, fromDOM.offset);
        let rects = range.getClientRects();
        range.detach();
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
            if (dist <= margin)
                return true;
        }
        return false;
    }
    function hoverTooltip(source, options={}) {
        let setHover = StateEffect.define();
        let hoverState = StateField.define({
            create() {
                return null;
            },
            update(value, tr) {
                if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value)))
                    return null;
                if (value && tr.docChanged) {
                    let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
                    if (newPos == null)
                        return null;
                    let copy = Object.assign(Object.create(null), value);
                    copy.pos = newPos;
                    if (value.end != null)
                        copy.end = tr.changes.mapPos(value.end);
                    value = copy;
                }
                for (let _i116 = 0, _tr$effects4 = tr.effects, _length116 = _tr$effects4.length; _i116 < _length116; _i116++) {
                    let effect = _tr$effects4[_i116];
                    if (effect.is(setHover))
                        value = effect.value;
                    if (effect.is(closeHoverTooltipEffect))
                        value = null;
                }
                return value;
            },
            provide: f => showHoverTooltip.from(f)
        });
        return [hoverState, ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300)), showHoverTooltipHost];
    }
    function getTooltip(view, tooltip) {
        let plugin = view.plugin(tooltipPlugin);
        if (!plugin)
            return null;
        let found = plugin.manager.tooltips.indexOf(tooltip);
        return found < 0 ? null : plugin.manager.tooltipViews[found];
    }
    function hasHoverTooltips(state) {
        return state.facet(showHoverTooltip).some(x => x);
    }
    const closeHoverTooltipEffect = StateEffect.define();
    const closeHoverTooltips = closeHoverTooltipEffect.of(null);
    function repositionTooltips(view) {
        var _a;
        (_a = view.plugin(tooltipPlugin)) === null || _a === void 0 ? void 0 : _a.maybeMeasure();
    }
    const panelConfig = Facet.define({
        combine(configs) {
            let topContainer,
                bottomContainer;
            for (let _i117 = 0, _length117 = configs.length; _i117 < _length117; _i117++) {
                let c = configs[_i117];
                topContainer = topContainer || c.topContainer;
                bottomContainer = bottomContainer || c.bottomContainer;
            }
            return {
                topContainer,
                bottomContainer
            };
        }
    });
    function panels(config) {
        return config ? [panelConfig.of(config)] : [];
    }
    function getPanel(view, panel) {
        let plugin = view.plugin(panelPlugin);
        let index = plugin ? plugin.specs.indexOf(panel) : -1;
        return index > -1 ? plugin.panels[index] : null;
    }
    const panelPlugin = ViewPlugin.fromClass(class {
        constructor(view)
        {
            this.input = view.state.facet(showPanel);
            this.specs = this.input.filter(s => s);
            this.panels = this.specs.map(spec => spec(view));
            let conf = view.state.facet(panelConfig);
            this.top = new PanelGroup(view, true, conf.topContainer);
            this.bottom = new PanelGroup(view, false, conf.bottomContainer);
            this.top.sync(this.panels.filter(p => p.top));
            this.bottom.sync(this.panels.filter(p => !p.top));
            for (let _i118 = 0, _this$panels = this.panels, _length118 = _this$panels.length; _i118 < _length118; _i118++) {
                let p = _this$panels[_i118];
                p.dom.classList.add("cm-panel");
                if (p.mount)
                    p.mount();
            }
        }
        update(update)
        {
            let conf = update.state.facet(panelConfig);
            if (this.top.container != conf.topContainer) {
                this.top.sync([]);
                this.top = new PanelGroup(update.view, true, conf.topContainer);
            }
            if (this.bottom.container != conf.bottomContainer) {
                this.bottom.sync([]);
                this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
            }
            this.top.syncClasses();
            this.bottom.syncClasses();
            let input = update.state.facet(showPanel);
            if (input != this.input) {
                let specs = input.filter(x => x);
                let panels = [],
                    top = [],
                    bottom = [],
                    mount = [];
                for (let _i119 = 0, _length119 = specs.length; _i119 < _length119; _i119++) {
                    let spec = specs[_i119];
                    let known = this.specs.indexOf(spec),
                        panel;
                    if (known < 0) {
                        panel = spec(update.view);
                        mount.push(panel);
                    } else {
                        panel = this.panels[known];
                        if (panel.update)
                            panel.update(update);
                    }
                    panels.push(panel);
                    (panel.top ? top : bottom).push(panel);
                }
                this.specs = specs;
                this.panels = panels;
                this.top.sync(top);
                this.bottom.sync(bottom);
                for (let _i120 = 0, _length120 = mount.length; _i120 < _length120; _i120++) {
                    let p = mount[_i120];
                    p.dom.classList.add("cm-panel");
                    if (p.mount)
                        p.mount();
                }
            } else {
                for (let _i121 = 0, _this$panels2 = this.panels, _length121 = _this$panels2.length; _i121 < _length121; _i121++) {
                    let p = _this$panels2[_i121];
                    if (p.update)
                        p.update(update);
                }
            }
        }
        destroy()
        {
            this.top.sync([]);
            this.bottom.sync([]);
        }
    }
    , {
        provide: plugin => EditorView.scrollMargins.of(view => {
            let value = view.plugin(plugin);
            return value && {
                    top: value.top.scrollMargin(),
                    bottom: value.bottom.scrollMargin()
                };
        })
    });
    class PanelGroup {
        constructor(view, top, container)
        {
            this.view = view;
            this.top = top;
            this.container = container;
            this.dom = undefined;
            this.classes = "";
            this.panels = [];
            this.syncClasses();
        }
        sync(panels)
        {
            for (let _i122 = 0, _this$panels3 = this.panels, _length122 = _this$panels3.length; _i122 < _length122; _i122++) {
                let p = _this$panels3[_i122];
                if (p.destroy && panels.indexOf(p) < 0)
                    p.destroy();
            }
            this.panels = panels;
            this.syncDOM();
        }
        syncDOM()
        {
            if (this.panels.length == 0) {
                if (this.dom) {
                    this.dom.remove();
                    this.dom = undefined;
                }
                return;
            }
            if (!this.dom) {
                this.dom = document.createElement("div");
                this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
                this.dom.style[this.top ? "top" : "bottom"] = "0";
                let parent = this.container || this.view.dom;
                parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
            }
            let curDOM = this.dom.firstChild;
            for (let _i123 = 0, _this$panels4 = this.panels, _length123 = _this$panels4.length; _i123 < _length123; _i123++) {
                let panel = _this$panels4[_i123];
                if (panel.dom.parentNode == this.dom) {
                    while (curDOM != panel.dom)
                        curDOM = rm$2(curDOM);
                    curDOM = curDOM.nextSibling;
                } else {
                    this.dom.insertBefore(panel.dom, curDOM);
                }
            }
            while (curDOM)
                curDOM = rm$2(curDOM);
        }
        scrollMargin()
        {
            return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
        }
        syncClasses()
        {
            if (!this.container || this.classes == this.view.themeClasses)
                return;
            for (let _i124 = 0, _this$classes$split = this.classes.split(" "), _length124 = _this$classes$split.length; _i124 < _length124; _i124++) {
                let cls = _this$classes$split[_i124];
                if (cls)
                    this.container.classList.remove(cls);
            }
            for (let _i125 = 0, _this$classes$split2 = (this.classes = this.view.themeClasses).split(" "), _length125 = _this$classes$split2.length; _i125 < _length125; _i125++) {
                let cls = _this$classes$split2[_i125];
                if (cls)
                    this.container.classList.add(cls);
            }
        }
    }
    function rm$2(node) {
        let next = node.nextSibling;
        node.remove();
        return next;
    }
    const showPanel = Facet.define({
        enables: panelPlugin
    });
    class GutterMarker extends RangeValue {
        compare(other)
        {
            return this == other || this.constructor == other.constructor && this.eq(other);
        }
        eq(other)
        {
            return false;
        }
        destroy(dom) {}
    }
    GutterMarker.prototype.elementClass = "";
    GutterMarker.prototype.toDOM = undefined;
    GutterMarker.prototype.mapMode = MapMode.TrackBefore;
    GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
    GutterMarker.prototype.point = true;
    const gutterLineClass = Facet.define();
    const defaults$2 = {
        class: "",
        renderEmptyElements: false,
        elementStyle: "",
        markers: () => RangeSet.empty,
        lineMarker: () => null,
        lineMarkerChange: null,
        initialSpacer: null,
        updateSpacer: null,
        domEventHandlers: {}
    };
    const activeGutters = Facet.define();
    function gutter(config) {
        return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults$2), config))];
    }
    const unfixGutters = Facet.define({
        combine: values => values.some(x => x)
    });
    function gutters(config) {
        let result = [gutterView];
        if (config && config.fixed === false)
            result.push(unfixGutters.of(true));
        return result;
    }
    const gutterView = ViewPlugin.fromClass(class {
        constructor(view)
        {
            this.view = view;
            this.prevViewport = view.viewport;
            this.dom = document.createElement("div");
            this.dom.className = "cm-gutters";
            this.dom.setAttribute("aria-hidden", "true");
            this.dom.style.minHeight = this.view.contentHeight + "px";
            this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
            for (let _i126 = 0, _this$gutters = this.gutters, _length126 = _this$gutters.length; _i126 < _length126; _i126++) {
                let gutter = _this$gutters[_i126];
                this.dom.appendChild(gutter.dom);
            }
            this.fixed = !view.state.facet(unfixGutters);
            if (this.fixed) {
                this.dom.style.position = "sticky";
            }
            this.syncGutters(false);
            view.scrollDOM.insertBefore(this.dom, view.contentDOM);
        }
        update(update)
        {
            if (this.updateGutters(update)) {
                let vpA = this.prevViewport,
                    vpB = update.view.viewport;
                let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
                this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
            }
            if (update.geometryChanged)
                this.dom.style.minHeight = this.view.contentHeight + "px";
            if (this.view.state.facet(unfixGutters) != !this.fixed) {
                this.fixed = !this.fixed;
                this.dom.style.position = this.fixed ? "sticky" : "";
            }
            this.prevViewport = update.view.viewport;
        }
        syncGutters(detach)
        {
            let after = this.dom.nextSibling;
            if (detach)
                this.dom.remove();
            let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
            let classSet = [];
            let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
            for (let _i127 = 0, _this$view$viewportLi = this.view.viewportLineBlocks, _length127 = _this$view$viewportLi.length; _i127 < _length127; _i127++) {
                let line = _this$view$viewportLi[_i127];
                let text;
                if (Array.isArray(line.type)) {
                    for (let _i128 = 0, _line$type2 = line.type, _length128 = _line$type2.length; _i128 < _length128; _i128++) {
                        let b = _line$type2[_i128];
                        if (b.type == BlockType.Text) {
                            text = b;
                            break;
                        }
                    }
                } else {
                    text = line.type == BlockType.Text ? line : undefined;
                }
                if (!text)
                    continue;
                if (classSet.length)
                    classSet = [];
                advanceCursor(lineClasses, classSet, line.from);
                for (let _i129 = 0, _length129 = contexts.length; _i129 < _length129; _i129++) {
                    let cx = contexts[_i129];
                    cx.line(this.view, text, classSet);
                }
            }
            for (let _i130 = 0, _length130 = contexts.length; _i130 < _length130; _i130++) {
                let cx = contexts[_i130];
                cx.finish();
            }
            if (detach)
                this.view.scrollDOM.insertBefore(this.dom, after);
        }
        updateGutters(update)
        {
            let prev = update.startState.facet(activeGutters),
                cur = update.state.facet(activeGutters);
            let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
            if (prev == cur) {
                for (let _i131 = 0, _this$gutters2 = this.gutters, _length131 = _this$gutters2.length; _i131 < _length131; _i131++) {
                    let gutter = _this$gutters2[_i131];
                    if (gutter.update(update))
                        change = true;
                }
            } else {
                change = true;
                let gutters = [];
                for (let _i132 = 0, _length132 = cur.length; _i132 < _length132; _i132++) {
                    let conf = cur[_i132];
                    let known = prev.indexOf(conf);
                    if (known < 0) {
                        gutters.push(new SingleGutterView(this.view, conf));
                    } else {
                        this.gutters[known].update(update);
                        gutters.push(this.gutters[known]);
                    }
                }
                for (let _i133 = 0, _this$gutters3 = this.gutters, _length133 = _this$gutters3.length; _i133 < _length133; _i133++) {
                    let g = _this$gutters3[_i133];
                    g.dom.remove();
                    if (gutters.indexOf(g) < 0)
                        g.destroy();
                }
                for (let _i134 = 0, _length134 = gutters.length; _i134 < _length134; _i134++) {
                    let g = gutters[_i134];
                    this.dom.appendChild(g.dom);
                }
                this.gutters = gutters;
            }
            return change;
        }
        destroy()
        {
            for (let _i135 = 0, _this$gutters4 = this.gutters, _length135 = _this$gutters4.length; _i135 < _length135; _i135++) {
                let view = _this$gutters4[_i135];
                view.destroy();
            }
            this.dom.remove();
        }
    }
    , {
        provide: plugin => EditorView.scrollMargins.of(view => {
            let value = view.plugin(plugin);
            if (!value || value.gutters.length == 0 || !value.fixed)
                return null;
            return view.textDirection == Direction.LTR ? {
                left: value.dom.offsetWidth
            } : {
                right: value.dom.offsetWidth
            };
        })
    });
    function asArray(val) {
        return Array.isArray(val) ? val : [val];
    }
    function advanceCursor(cursor, collect, pos) {
        while (cursor.value && cursor.from <= pos) {
            if (cursor.from == pos)
                collect.push(cursor.value);
            cursor.next();
        }
    }
    class UpdateContext {
        constructor(gutter, viewport, height)
        {
            this.gutter = gutter;
            this.height = height;
            this.i = 0;
            this.cursor = RangeSet.iter(gutter.markers, viewport.from);
        }
        line(view, line, extraMarkers)
        {
            let localMarkers = [];
            advanceCursor(this.cursor, localMarkers, line.from);
            if (extraMarkers.length)
                localMarkers = localMarkers.concat(extraMarkers);
            let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
            if (forLine)
                localMarkers.unshift(forLine);
            let gutter = this.gutter;
            if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
                return;
            let above = line.top - this.height;
            if (this.i == gutter.elements.length) {
                let newElt = new GutterElement(view, line.height, above, localMarkers);
                gutter.elements.push(newElt);
                gutter.dom.appendChild(newElt.dom);
            } else {
                gutter.elements[this.i].update(view, line.height, above, localMarkers);
            }
            this.height = line.bottom;
            this.i++;
        }
        finish()
        {
            let gutter = this.gutter;
            while (gutter.elements.length > this.i) {
                let last = gutter.elements.pop();
                gutter.dom.removeChild(last.dom);
                last.destroy();
            }
        }
    }
    class SingleGutterView {
        constructor(view, config)
        {
            this.view = view;
            this.config = config;
            this.elements = [];
            this.spacer = null;
            this.dom = document.createElement("div");
            this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
            for (let prop in config.domEventHandlers) {
                this.dom.addEventListener(prop, event => {
                    let target = event.target,
                        y;
                    if (target != this.dom && this.dom.contains(target)) {
                        while (target.parentNode != this.dom)
                            target = target.parentNode;
                        let rect = target.getBoundingClientRect();
                        y = (rect.top + rect.bottom) / 2;
                    } else {
                        y = event.clientY;
                    }
                    let line = view.lineBlockAtHeight(y - view.documentTop);
                    if (config.domEventHandlers[prop](view, line, event))
                        event.preventDefault();
                });
            }
            this.markers = asArray(config.markers(view));
            if (config.initialSpacer) {
                this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
                this.dom.appendChild(this.spacer.dom);
                this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
            }
        }
        update(update)
        {
            let prevMarkers = this.markers;
            this.markers = asArray(this.config.markers(update.view));
            if (this.spacer && this.config.updateSpacer) {
                let updated = this.config.updateSpacer(this.spacer.markers[0], update);
                if (updated != this.spacer.markers[0])
                    this.spacer.update(update.view, 0, 0, [updated]);
            }
            let vp = update.view.viewport;
            return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
        }
        destroy()
        {
            for (let _i136 = 0, _this$elements = this.elements, _length136 = _this$elements.length; _i136 < _length136; _i136++) {
                let elt = _this$elements[_i136];
                elt.destroy();
            }
        }
    }
    class GutterElement {
        constructor(view, height, above, markers)
        {
            this.height = -1;
            this.above = 0;
            this.markers = [];
            this.dom = document.createElement("div");
            this.dom.className = "cm-gutterElement";
            this.update(view, height, above, markers);
        }
        update(view, height, above, markers)
        {
            if (this.height != height)
                this.dom.style.height = (this.height = height) + "px";
            if (this.above != above)
                this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
            if (!sameMarkers(this.markers, markers))
                this.setMarkers(view, markers);
        }
        setMarkers(view, markers)
        {
            let cls = "cm-gutterElement",
                domPos = this.dom.firstChild;
            for (let iNew = 0, iOld = 0; ;) {
                let skipTo = iOld,
                    marker = iNew < markers.length ? markers[iNew++] : null,
                    matched = false;
                if (marker) {
                    let c = marker.elementClass;
                    if (c)
                        cls += " " + c;
                    for (let i = iOld; i < this.markers.length; i++)
                        if (this.markers[i].compare(marker)) {
                            skipTo = i;
                            matched = true;
                            break;
                        }
                } else {
                    skipTo = this.markers.length;
                }
                while (iOld < skipTo) {
                    let next = this.markers[iOld++];
                    if (next.toDOM) {
                        next.destroy(domPos);
                        let after = domPos.nextSibling;
                        domPos.remove();
                        domPos = after;
                    }
                }
                if (!marker)
                    break;
                if (marker.toDOM) {
                    if (matched)
                        domPos = domPos.nextSibling;
                    else
                        this.dom.insertBefore(marker.toDOM(view), domPos);
                }
                if (matched)
                    iOld++;
            }
            this.dom.className = cls;
            this.markers = markers;
        }
        destroy()
        {
            this.setMarkers(null, []);
        }
    }
    function sameMarkers(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++)
            if (!a[i].compare(b[i]))
                return false;
        return true;
    }
    const lineNumberMarkers = Facet.define();
    const lineNumberConfig = Facet.define({
        combine(values) {
            return combineConfig(values, {
                formatNumber: String,
                domEventHandlers: {}
            }, {
                domEventHandlers(a, b) {
                    let result = Object.assign({}, a);
                    for (let event in b) {
                        let exists = result[event],
                            add = b[event];
                        result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
                    }
                    return result;
                }
            });
        }
    });
    class NumberMarker extends GutterMarker {
        constructor(number)
        {
            super();
            this.number = number;
        }
        eq(other)
        {
            return this.number == other.number;
        }
        toDOM()
        {
            return document.createTextNode(this.number);
        }
    }
    function formatNumber(view, number) {
        return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
    }
    const lineNumberGutter = activeGutters.compute([lineNumberConfig], state => ({
        class: "cm-lineNumbers",
        renderEmptyElements: false,
        markers(view) {
            return view.state.facet(lineNumberMarkers);
        },
        lineMarker(view, line, others) {
            if (others.some(m => m.toDOM))
                return null;
            return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
        },
        lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
        initialSpacer(view) {
            return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
        },
        updateSpacer(spacer, update) {
            let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
            return max == spacer.number ? spacer : new NumberMarker(max);
        },
        domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
    }));
    function lineNumbers(config={}) {
        return [lineNumberConfig.of(config), gutters(), lineNumberGutter];
    }
    function maxLineNumber(lines) {
        let last = 9;
        while (last < lines)
            last = last * 10 + 9;
        return last;
    }
    const activeLineGutterMarker = new class  extends GutterMarker{
        constructor()
        {
            super(...arguments);
            this.elementClass = "cm-activeLineGutter";
        }
    }
    ();
    const activeLineGutterHighlighter = gutterLineClass.compute(["selection"], state => {
        let marks = [],
            last = -1;
        for (let _i137 = 0, _state$selection$rang4 = state.selection.ranges, _length137 = _state$selection$rang4.length; _i137 < _length137; _i137++) {
            let range = _state$selection$rang4[_i137];
            let linePos = state.doc.lineAt(range.head).from;
            if (linePos > last) {
                last = linePos;
                marks.push(activeLineGutterMarker.range(linePos));
            }
        }
        return RangeSet.of(marks);
    });
    function highlightActiveLineGutter() {
        return activeLineGutterHighlighter;
    }
    const WhitespaceDeco = new Map();
    function getWhitespaceDeco(space) {
        let deco = WhitespaceDeco.get(space);
        if (!deco)
            WhitespaceDeco.set(space, deco = Decoration.mark({
                attributes: space === "\t" ? {
                    class: "cm-highlightTab"
                } : {
                    class: "cm-highlightSpace",
                    "data-display": space.replace(/ /g, "·")
                }
            }));
        return deco;
    }
    function matcher(decorator) {
        return ViewPlugin.define(view => ({
            decorations: decorator.createDeco(view),
            update(u) {
                this.decorations = decorator.updateDeco(u, this.decorations);
            }
        }), {
            decorations: v => v.decorations
        });
    }
    const whitespaceHighlighter = matcher(new MatchDecorator({
        regexp: /\t| +/g,
        decoration: match => getWhitespaceDeco(match[0]),
        boundary: /\S/
    }));
    function highlightWhitespace() {
        return whitespaceHighlighter;
    }
    const trailingHighlighter = matcher(new MatchDecorator({
        regexp: /\s+$/g,
        decoration: Decoration.mark({
            class: "cm-trailingSpace"
        }),
        boundary: /\S/
    }));
    function highlightTrailingWhitespace() {
        return trailingHighlighter;
    }
    const __test$1 = {
        HeightMap,
        HeightOracle,
        MeasuredHeights,
        QueryType: QueryType$1,
        ChangedRange,
        computeOrder,
        moveVisually
    };
    var _m1 = Object.freeze({
        __proto__: null,
        BidiSpan: BidiSpan,
        BlockInfo: BlockInfo,
        get BlockType() {
            return BlockType;
        },
        Decoration: Decoration,
        get Direction() {
            return Direction;
        },
        EditorView: EditorView,
        GutterMarker: GutterMarker,
        MatchDecorator: MatchDecorator,
        RectangleMarker: RectangleMarker,
        ViewPlugin: ViewPlugin,
        ViewUpdate: ViewUpdate,
        WidgetType: WidgetType,
        __test: __test$1,
        closeHoverTooltips: closeHoverTooltips,
        crosshairCursor: crosshairCursor,
        drawSelection: drawSelection,
        dropCursor: dropCursor,
        getPanel: getPanel,
        getTooltip: getTooltip,
        gutter: gutter,
        gutterLineClass: gutterLineClass,
        gutters: gutters,
        hasHoverTooltips: hasHoverTooltips,
        highlightActiveLine: highlightActiveLine,
        highlightActiveLineGutter: highlightActiveLineGutter,
        highlightSpecialChars: highlightSpecialChars,
        highlightTrailingWhitespace: highlightTrailingWhitespace,
        highlightWhitespace: highlightWhitespace,
        hoverTooltip: hoverTooltip,
        keymap: keymap,
        layer: layer,
        lineNumberMarkers: lineNumberMarkers,
        lineNumbers: lineNumbers,
        logException: logException,
        panels: panels,
        placeholder: placeholder,
        rectangularSelection: rectangularSelection,
        repositionTooltips: repositionTooltips,
        runScopeHandlers: runScopeHandlers,
        scrollPastEnd: scrollPastEnd,
        showPanel: showPanel,
        showTooltip: showTooltip,
        tooltips: tooltips
    });
    const DefaultBufferLength = 1024;
    let nextPropID = 0;
    class Range {
        constructor(from, to)
        {
            this.from = from;
            this.to = to;
        }
    }
    class NodeProp {
        constructor(config={})
        {
            this.id = nextPropID++;
            this.perNode = !!config.perNode;
            this.deserialize = config.deserialize || (() => {
                throw new Error("This node type doesn't define a deserialize function");
            });
        }
        add(match)
        {
            if (this.perNode)
                throw new RangeError("Can't add per-node props to node types");
            if (typeof match != "function")
                match = NodeType.match(match);
            return type => {
                let result = match(type);
                return result === undefined ? null : [this, result];
            };
        }
    }
    NodeProp.closedBy = new NodeProp({
        deserialize: str => str.split(" ")
    });
    NodeProp.openedBy = new NodeProp({
        deserialize: str => str.split(" ")
    });
    NodeProp.group = new NodeProp({
        deserialize: str => str.split(" ")
    });
    NodeProp.contextHash = new NodeProp({
        perNode: true
    });
    NodeProp.lookAhead = new NodeProp({
        perNode: true
    });
    NodeProp.mounted = new NodeProp({
        perNode: true
    });
    class MountedTree {
        constructor(tree, overlay, parser)
        {
            this.tree = tree;
            this.overlay = overlay;
            this.parser = parser;
        }
    }
    const noProps = Object.create(null);
    class NodeType {
        constructor(name, props, id, flags=0)
        {
            this.name = name;
            this.props = props;
            this.id = id;
            this.flags = flags;
        }
        static define(spec)
        {
            let props = spec.props && spec.props.length ? Object.create(null) : noProps;
            let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
            let type = new NodeType(spec.name || "", props, spec.id, flags);
            if (spec.props)
                for (let _i138 = 0, _spec$props = spec.props, _length138 = _spec$props.length; _i138 < _length138; _i138++) {
                    let src = _spec$props[_i138];
                    if (!Array.isArray(src))
                        src = src(type);
                    if (src) {
                        if (src[0].perNode)
                            throw new RangeError("Can't store a per-node prop on a node type");
                        props[src[0].id] = src[1];
                    }
                }
            return type;
        }
        prop(prop)
        {
            return this.props[prop.id];
        }
        get isTop()
        {
            return (this.flags & 1) > 0;
        }
        get isSkipped()
        {
            return (this.flags & 2) > 0;
        }
        get isError()
        {
            return (this.flags & 4) > 0;
        }
        get isAnonymous()
        {
            return (this.flags & 8) > 0;
        }
        is(name)
        {
            if (typeof name == 'string') {
                if (this.name == name)
                    return true;
                let group = this.prop(NodeProp.group);
                return group ? group.indexOf(name) > -1 : false;
            }
            return this.id == name;
        }
        static match(map)
        {
            let direct = Object.create(null);
            for (let prop in map)
                for (let _i139 = 0, _prop$split = prop.split(" "), _length139 = _prop$split.length; _i139 < _length139; _i139++) {
                    let name = _prop$split[_i139];
                    direct[name] = map[prop];
                }
            return node => {
                for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                    let found = direct[i < 0 ? node.name : groups[i]];
                    if (found)
                        return found;
                }
            };
        }
    }
    NodeType.none = new NodeType("", Object.create(null), 0, 8);
    class NodeSet {
        constructor(types)
        {
            this.types = types;
            for (let i = 0; i < types.length; i++)
                if (types[i].id != i)
                    throw new RangeError("Node type ids should correspond to array positions when creating a node set");
        }
        extend(...props)
        {
            let newTypes = [];
            for (let _i140 = 0, _this$types = this.types, _length140 = _this$types.length; _i140 < _length140; _i140++) {
                let type = _this$types[_i140];
                let newProps = null;
                for (let _i141 = 0, _length141 = props.length; _i141 < _length141; _i141++) {
                    let source = props[_i141];
                    let add = source(type);
                    if (add) {
                        if (!newProps)
                            newProps = Object.assign({}, type.props);
                        newProps[add[0].id] = add[1];
                    }
                }
                newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
            }
            return new NodeSet(newTypes);
        }
    }
    const CachedNode = new WeakMap(),
        CachedInnerNode = new WeakMap();
    var IterMode;
    (function(IterMode) {
        IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
        IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
        IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
        IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
    })(IterMode || (IterMode = {}));
    class Tree {
        constructor(type, children, positions, length, props)
        {
            this.type = type;
            this.children = children;
            this.positions = positions;
            this.length = length;
            this.props = null;
            if (props && props.length) {
                this.props = Object.create(null);
                for (let _i142 = 0, _length142 = props.length; _i142 < _length142; _i142++) {
                    let [prop, value] = props[_i142];
                    this.props[typeof prop == "number" ? prop : prop.id] = value;
                }
            }
        }
        toString()
        {
            let mounted = this.prop(NodeProp.mounted);
            if (mounted && !mounted.overlay)
                return mounted.tree.toString();
            let children = "";
            for (let _i143 = 0, _this$children9 = this.children, _length143 = _this$children9.length; _i143 < _length143; _i143++) {
                let ch = _this$children9[_i143];
                let str = ch.toString();
                if (str) {
                    if (children)
                        children += ",";
                    children += str;
                }
            }
            return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
        }
        cursor(mode=0)
        {
            return new TreeCursor(this.topNode, mode);
        }
        cursorAt(pos, side=0, mode=0)
        {
            let scope = CachedNode.get(this) || this.topNode;
            let cursor = new TreeCursor(scope);
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
            return cursor;
        }
        get topNode()
        {
            return new TreeNode(this, 0, 0, null);
        }
        resolve(pos, side=0)
        {
            let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
            CachedNode.set(this, node);
            return node;
        }
        resolveInner(pos, side=0)
        {
            let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
            CachedInnerNode.set(this, node);
            return node;
        }
        iterate(spec)
        {
            let {enter, leave, from=0, to=this.length} = spec;
            for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ;) {
                let entered = false;
                if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
                    if (c.firstChild())
                        continue;
                    entered = true;
                }
                for (;;) {
                    if (entered && leave && !c.type.isAnonymous)
                        leave(c);
                    if (c.nextSibling())
                        break;
                    if (!c.parent())
                        return;
                    entered = true;
                }
            }
        }
        prop(prop)
        {
            return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
        }
        get propValues()
        {
            let result = [];
            if (this.props)
                for (let id in this.props)
                    result.push([+id, this.props[id]]);
            return result;
        }
        balance(config={})
        {
            return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
        }
        static build(data)
        {
            return buildTree(data);
        }
    }
    Tree.empty = new Tree(NodeType.none, [], [], 0);
    class FlatBufferCursor {
        constructor(buffer, index)
        {
            this.buffer = buffer;
            this.index = index;
        }
        get id()
        {
            return this.buffer[this.index - 4];
        }
        get start()
        {
            return this.buffer[this.index - 3];
        }
        get end()
        {
            return this.buffer[this.index - 2];
        }
        get size()
        {
            return this.buffer[this.index - 1];
        }
        get pos()
        {
            return this.index;
        }
        next()
        {
            this.index -= 4;
        }
        fork()
        {
            return new FlatBufferCursor(this.buffer, this.index);
        }
    }
    class TreeBuffer {
        constructor(buffer, length, set)
        {
            this.buffer = buffer;
            this.length = length;
            this.set = set;
        }
        get type()
        {
            return NodeType.none;
        }
        toString()
        {
            let result = [];
            for (let index = 0; index < this.buffer.length;) {
                result.push(this.childString(index));
                index = this.buffer[index + 3];
            }
            return result.join(",");
        }
        childString(index)
        {
            let id = this.buffer[index],
                endIndex = this.buffer[index + 3];
            let type = this.set.types[id],
                result = type.name;
            if (/\W/.test(result) && !type.isError)
                result = JSON.stringify(result);
            index += 4;
            if (endIndex == index)
                return result;
            let children = [];
            while (index < endIndex) {
                children.push(this.childString(index));
                index = this.buffer[index + 3];
            }
            return result + "(" + children.join(",") + ")";
        }
        findChild(startIndex, endIndex, dir, pos, side)
        {
            let {buffer} = this,
                pick = -1;
            for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
                if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                    pick = i;
                    if (dir > 0)
                        break;
                }
            }
            return pick;
        }
        slice(startI, endI, from, to)
        {
            let b = this.buffer;
            let copy = new Uint16Array(endI - startI);
            for (let i = startI, j = 0; i < endI;) {
                copy[j++] = b[i++];
                copy[j++] = b[i++] - from;
                copy[j++] = b[i++] - from;
                copy[j++] = b[i++] - startI;
            }
            return new TreeBuffer(copy, to - from, this.set);
        }
    }
    function checkSide(side, pos, from, to) {
        switch (side) {
        case -2:
            return from < pos;
        case -1:
            return to >= pos && from < pos;
        case 0:
            return from < pos && to > pos;
        case 1:
            return from <= pos && to > pos;
        case 2:
            return to > pos;
        case 4:
            return true;
        }
    }
    function enterUnfinishedNodesBefore(node, pos) {
        let scan = node.childBefore(pos);
        while (scan) {
            let last = scan.lastChild;
            if (!last || last.to != scan.to)
                break;
            if (last.type.isError && last.from == last.to) {
                node = scan;
                scan = last.prevSibling;
            } else {
                scan = last;
            }
        }
        return node;
    }
    function resolveNode(node, pos, side, overlays) {
        var _a;
        while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
            let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
            if (!parent)
                return node;
            node = parent;
        }
        let mode = overlays ? 0 : IterMode.IgnoreOverlays;
        if (overlays)
            for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
                if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                    node = parent;
            }
        for (;;) {
            let inner = node.enter(pos, side, mode);
            if (!inner)
                return node;
            node = inner;
        }
    }
    class TreeNode {
        constructor(_tree, from, index, _parent)
        {
            this._tree = _tree;
            this.from = from;
            this.index = index;
            this._parent = _parent;
        }
        get type()
        {
            return this._tree.type;
        }
        get name()
        {
            return this._tree.type.name;
        }
        get to()
        {
            return this.from + this._tree.length;
        }
        nextChild(i, dir, pos, side, mode=0)
        {
            for (let parent = this; ;) {
                for (let {children, positions} = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                    let next = children[i],
                        start = positions[i] + parent.from;
                    if (!checkSide(side, pos, start, start + next.length))
                        continue;
                    if (next instanceof TreeBuffer) {
                        if (mode & IterMode.ExcludeBuffers)
                            continue;
                        let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                        if (index > -1)
                            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                    } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {
                        let mounted;
                        if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                            return new TreeNode(mounted.tree, start, i, parent);
                        let inner = new TreeNode(next, start, i, parent);
                        return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                    }
                }
                if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
                    return null;
                if (parent.index >= 0)
                    i = parent.index + dir;
                else
                    i = dir < 0 ? -1 : parent._parent._tree.children.length;
                parent = parent._parent;
                if (!parent)
                    return null;
            }
        }
        get firstChild()
        {
            return this.nextChild(0, 1, 0, 4);
        }
        get lastChild()
        {
            return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
        }
        childAfter(pos)
        {
            return this.nextChild(0, 1, pos, 2);
        }
        childBefore(pos)
        {
            return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
        }
        enter(pos, side, mode=0)
        {
            let mounted;
            if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
                let rPos = pos - this.from;
                for (let _i144 = 0, _mounted$overlay = mounted.overlay, _length144 = _mounted$overlay.length; _i144 < _length144; _i144++) {
                    let {from, to} = _mounted$overlay[_i144];
                    if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
                        return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
                }
            }
            return this.nextChild(0, 1, pos, side, mode);
        }
        nextSignificantParent()
        {
            let val = this;
            while (val.type.isAnonymous && val._parent)
                val = val._parent;
            return val;
        }
        get parent()
        {
            return this._parent ? this._parent.nextSignificantParent() : null;
        }
        get nextSibling()
        {
            return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
        }
        get prevSibling()
        {
            return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
        }
        cursor(mode=0)
        {
            return new TreeCursor(this, mode);
        }
        get tree()
        {
            return this._tree;
        }
        toTree()
        {
            return this._tree;
        }
        resolve(pos, side=0)
        {
            return resolveNode(this, pos, side, false);
        }
        resolveInner(pos, side=0)
        {
            return resolveNode(this, pos, side, true);
        }
        enterUnfinishedNodesBefore(pos)
        {
            return enterUnfinishedNodesBefore(this, pos);
        }
        getChild(type, before=null, after=null)
        {
            let r = getChildren(this, type, before, after);
            return r.length ? r[0] : null;
        }
        getChildren(type, before=null, after=null)
        {
            return getChildren(this, type, before, after);
        }
        toString()
        {
            return this._tree.toString();
        }
        get node()
        {
            return this;
        }
        matchContext(context)
        {
            return matchNodeContext(this, context);
        }
    }
    function getChildren(node, type, before, after) {
        let cur = node.cursor(),
            result = [];
        if (!cur.firstChild())
            return result;
        if (before != null)
            while (!cur.type.is(before))
                if (!cur.nextSibling())
                    return result;
        for (;;) {
            if (after != null && cur.type.is(after))
                return result;
            if (cur.type.is(type))
                result.push(cur.node);
            if (!cur.nextSibling())
                return after == null ? result : [];
        }
    }
    function matchNodeContext(node, context, i=context.length - 1) {
        for (let p = node.parent; i >= 0; p = p.parent) {
            if (!p)
                return false;
            if (!p.type.isAnonymous) {
                if (context[i] && context[i] != p.name)
                    return false;
                i--;
            }
        }
        return true;
    }
    class BufferContext {
        constructor(parent, buffer, index, start)
        {
            this.parent = parent;
            this.buffer = buffer;
            this.index = index;
            this.start = start;
        }
    }
    class BufferNode {
        constructor(context, _parent, index)
        {
            this.context = context;
            this._parent = _parent;
            this.index = index;
            this.type = context.buffer.set.types[context.buffer.buffer[index]];
        }
        get name()
        {
            return this.type.name;
        }
        get from()
        {
            return this.context.start + this.context.buffer.buffer[this.index + 1];
        }
        get to()
        {
            return this.context.start + this.context.buffer.buffer[this.index + 2];
        }
        child(dir, pos, side)
        {
            let {buffer} = this.context;
            let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
            return index < 0 ? null : new BufferNode(this.context, this, index);
        }
        get firstChild()
        {
            return this.child(1, 0, 4);
        }
        get lastChild()
        {
            return this.child(-1, 0, 4);
        }
        childAfter(pos)
        {
            return this.child(1, pos, 2);
        }
        childBefore(pos)
        {
            return this.child(-1, pos, -2);
        }
        enter(pos, side, mode=0)
        {
            if (mode & IterMode.ExcludeBuffers)
                return null;
            let {buffer} = this.context;
            let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
            return index < 0 ? null : new BufferNode(this.context, this, index);
        }
        get parent()
        {
            return this._parent || this.context.parent.nextSignificantParent();
        }
        externalSibling(dir)
        {
            return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
        }
        get nextSibling()
        {
            let {buffer} = this.context;
            let after = buffer.buffer[this.index + 3];
            if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
                return new BufferNode(this.context, this._parent, after);
            return this.externalSibling(1);
        }
        get prevSibling()
        {
            let {buffer} = this.context;
            let parentStart = this._parent ? this._parent.index + 4 : 0;
            if (this.index == parentStart)
                return this.externalSibling(-1);
            return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
        }
        cursor(mode=0)
        {
            return new TreeCursor(this, mode);
        }
        get tree()
        {
            return null;
        }
        toTree()
        {
            let children = [],
                positions = [];
            let {buffer} = this.context;
            let startI = this.index + 4,
                endI = buffer.buffer[this.index + 3];
            if (endI > startI) {
                let from = buffer.buffer[this.index + 1],
                    to = buffer.buffer[this.index + 2];
                children.push(buffer.slice(startI, endI, from, to));
                positions.push(0);
            }
            return new Tree(this.type, children, positions, this.to - this.from);
        }
        resolve(pos, side=0)
        {
            return resolveNode(this, pos, side, false);
        }
        resolveInner(pos, side=0)
        {
            return resolveNode(this, pos, side, true);
        }
        enterUnfinishedNodesBefore(pos)
        {
            return enterUnfinishedNodesBefore(this, pos);
        }
        toString()
        {
            return this.context.buffer.childString(this.index);
        }
        getChild(type, before=null, after=null)
        {
            let r = getChildren(this, type, before, after);
            return r.length ? r[0] : null;
        }
        getChildren(type, before=null, after=null)
        {
            return getChildren(this, type, before, after);
        }
        get node()
        {
            return this;
        }
        matchContext(context)
        {
            return matchNodeContext(this, context);
        }
    }
    class TreeCursor {
        constructor(node, mode=0)
        {
            this.mode = mode;
            this.buffer = null;
            this.stack = [];
            this.index = 0;
            this.bufferNode = null;
            if (node instanceof TreeNode) {
                this.yieldNode(node);
            } else {
                this._tree = node.context.parent;
                this.buffer = node.context;
                for (let n = node._parent; n; n = n._parent)
                    this.stack.unshift(n.index);
                this.bufferNode = node;
                this.yieldBuf(node.index);
            }
        }
        get name()
        {
            return this.type.name;
        }
        yieldNode(node)
        {
            if (!node)
                return false;
            this._tree = node;
            this.type = node.type;
            this.from = node.from;
            this.to = node.to;
            return true;
        }
        yieldBuf(index, type)
        {
            this.index = index;
            let {start, buffer} = this.buffer;
            this.type = type || buffer.set.types[buffer.buffer[index]];
            this.from = start + buffer.buffer[index + 1];
            this.to = start + buffer.buffer[index + 2];
            return true;
        }
        yield(node)
        {
            if (!node)
                return false;
            if (node instanceof TreeNode) {
                this.buffer = null;
                return this.yieldNode(node);
            }
            this.buffer = node.context;
            return this.yieldBuf(node.index, node.type);
        }
        toString()
        {
            return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
        }
        enterChild(dir, pos, side)
        {
            if (!this.buffer)
                return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
            let {buffer} = this.buffer;
            let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
            if (index < 0)
                return false;
            this.stack.push(this.index);
            return this.yieldBuf(index);
        }
        firstChild()
        {
            return this.enterChild(1, 0, 4);
        }
        lastChild()
        {
            return this.enterChild(-1, 0, 4);
        }
        childAfter(pos)
        {
            return this.enterChild(1, pos, 2);
        }
        childBefore(pos)
        {
            return this.enterChild(-1, pos, -2);
        }
        enter(pos, side, mode=this.mode)
        {
            if (!this.buffer)
                return this.yield(this._tree.enter(pos, side, mode));
            return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
        }
        parent()
        {
            if (!this.buffer)
                return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
            if (this.stack.length)
                return this.yieldBuf(this.stack.pop());
            let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
            this.buffer = null;
            return this.yieldNode(parent);
        }
        sibling(dir)
        {
            if (!this.buffer)
                return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
            let {buffer} = this.buffer,
                d = this.stack.length - 1;
            if (dir < 0) {
                let parentStart = d < 0 ? 0 : this.stack[d] + 4;
                if (this.index != parentStart)
                    return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
            } else {
                let after = buffer.buffer[this.index + 3];
                if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                    return this.yieldBuf(after);
            }
            return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
        }
        nextSibling()
        {
            return this.sibling(1);
        }
        prevSibling()
        {
            return this.sibling(-1);
        }
        atLastNode(dir)
        {
            let index,
                parent,
                {buffer} = this;
            if (buffer) {
                if (dir > 0) {
                    if (this.index < buffer.buffer.buffer.length)
                        return false;
                } else {
                    for (let i = 0; i < this.index; i++)
                        if (buffer.buffer.buffer[i + 3] < this.index)
                            return false;
                }
                ({index, parent} = buffer);
            } else {
                ({index, _parent: parent} = this._tree);
            }
            for (; parent;({index, _parent: parent} = parent)) {
                if (index > -1)
                    for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                        let child = parent._tree.children[i];
                        if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                            return false;
                    }
            }
            return true;
        }
        move(dir, enter)
        {
            if (enter && this.enterChild(dir, 0, 4))
                return true;
            for (;;) {
                if (this.sibling(dir))
                    return true;
                if (this.atLastNode(dir) || !this.parent())
                    return false;
            }
        }
        next(enter=true)
        {
            return this.move(1, enter);
        }
        prev(enter=true)
        {
            return this.move(-1, enter);
        }
        moveTo(pos, side=0)
        {
            while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
                if (!this.parent())
                    break;
            while (this.enterChild(1, pos, side)) {}
            return this;
        }
        get node()
        {
            if (!this.buffer)
                return this._tree;
            let cache = this.bufferNode,
                result = null,
                depth = 0;
            if (cache && cache.context == this.buffer) {
                scan:
                for (let index = this.index, d = this.stack.length; d >= 0;) {
                    for (let c = cache; c; c = c._parent)
                        if (c.index == index) {
                            if (index == this.index)
                                return c;
                            result = c;
                            depth = d + 1;
                            break scan;
                        }
                    index = this.stack[--d];
                }
            }
            for (let i = depth; i < this.stack.length; i++)
                result = new BufferNode(this.buffer, result, this.stack[i]);
            return this.bufferNode = new BufferNode(this.buffer, result, this.index);
        }
        get tree()
        {
            return this.buffer ? null : this._tree._tree;
        }
        iterate(enter, leave)
        {
            for (let depth = 0; ;) {
                let mustLeave = false;
                if (this.type.isAnonymous || enter(this) !== false) {
                    if (this.firstChild()) {
                        depth++;
                        continue;
                    }
                    if (!this.type.isAnonymous)
                        mustLeave = true;
                }
                for (;;) {
                    if (mustLeave && leave)
                        leave(this);
                    mustLeave = this.type.isAnonymous;
                    if (this.nextSibling())
                        break;
                    if (!depth)
                        return;
                    this.parent();
                    depth--;
                    mustLeave = true;
                }
            }
        }
        matchContext(context)
        {
            if (!this.buffer)
                return matchNodeContext(this.node, context);
            let {buffer} = this.buffer,
                {types} = buffer.set;
            for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
                if (d < 0)
                    return matchNodeContext(this.node, context, i);
                let type = types[buffer.buffer[this.stack[d]]];
                if (!type.isAnonymous) {
                    if (context[i] && context[i] != type.name)
                        return false;
                    i--;
                }
            }
            return true;
        }
    }
    function hasChild(tree) {
        return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
    }
    function buildTree(data) {
        var _a;
        let {buffer, nodeSet, maxBufferLength=DefaultBufferLength, reused=[], minRepeatType=nodeSet.types.length} = data;
        let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
        let types = nodeSet.types;
        let contextHash = 0,
            lookAhead = 0;
        function takeNode(parentStart, minPos, children, positions, inRepeat) {
            let {id, start, end, size} = cursor;
            let lookAheadAtStart = lookAhead;
            while (size < 0) {
                cursor.next();
                if (size == -1) {
                    let node = reused[id];
                    children.push(node);
                    positions.push(start - parentStart);
                    return;
                } else if (size == -3) {
                    contextHash = id;
                    return;
                } else if (size == -4) {
                    lookAhead = id;
                    return;
                } else {
                    throw new RangeError(`Unrecognized record size: ${size}`);
                }
            }
            let type = types[id],
                node,
                buffer;
            let startPos = start - parentStart;
            if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
                let data = new Uint16Array(buffer.size - buffer.skip);
                let endPos = cursor.pos - buffer.size,
                    index = data.length;
                while (cursor.pos > endPos)
                    index = copyToBuffer(buffer.start, data, index);
                node = new TreeBuffer(data, end - buffer.start, nodeSet);
                startPos = buffer.start - parentStart;
            } else {
                let endPos = cursor.pos - size;
                cursor.next();
                let localChildren = [],
                    localPositions = [];
                let localInRepeat = id >= minRepeatType ? id : -1;
                let lastGroup = 0,
                    lastEnd = end;
                while (cursor.pos > endPos) {
                    if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                        if (cursor.end <= lastEnd - maxBufferLength) {
                            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                            lastGroup = localChildren.length;
                            lastEnd = cursor.end;
                        }
                        cursor.next();
                    } else {
                        takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                    }
                }
                if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                    makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
                localChildren.reverse();
                localPositions.reverse();
                if (localInRepeat > -1 && lastGroup > 0) {
                    let make = makeBalanced(type);
                    node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
                } else {
                    node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
                }
            }
            children.push(node);
            positions.push(startPos);
        }
        function makeBalanced(type) {
            return (children, positions, length) => {
                let lookAhead = 0,
                    lastI = children.length - 1,
                    last,
                    lookAheadProp;
                if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                    if (!lastI && last.type == type && last.length == length)
                        return last;
                    if (lookAheadProp = last.prop(NodeProp.lookAhead))
                        lookAhead = positions[lastI] + last.length + lookAheadProp;
                }
                return makeTree(type, children, positions, length, lookAhead);
            };
        }
        function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
            let localChildren = [],
                localPositions = [];
            while (children.length > i) {
                localChildren.push(children.pop());
                localPositions.push(positions.pop() + base - from);
            }
            children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
            positions.push(from - base);
        }
        function makeTree(type, children, positions, length, lookAhead=0, props) {
            if (contextHash) {
                let pair = [NodeProp.contextHash, contextHash];
                props = props ? [pair].concat(props) : [pair];
            }
            if (lookAhead > 25) {
                let pair = [NodeProp.lookAhead, lookAhead];
                props = props ? [pair].concat(props) : [pair];
            }
            return new Tree(type, children, positions, length, props);
        }
        function findBufferSize(maxSize, inRepeat) {
            let fork = cursor.fork();
            let size = 0,
                start = 0,
                skip = 0,
                minStart = fork.end - maxBufferLength;
            let result = {
                size: 0,
                start: 0,
                skip: 0
            };
            scan:
            for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
                let nodeSize = fork.size;
                if (fork.id == inRepeat && nodeSize >= 0) {
                    result.size = size;
                    result.start = start;
                    result.skip = skip;
                    skip += 4;
                    size += 4;
                    fork.next();
                    continue;
                }
                let startPos = fork.pos - nodeSize;
                if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                    break;
                let localSkipped = fork.id >= minRepeatType ? 4 : 0;
                let nodeStart = fork.start;
                fork.next();
                while (fork.pos > startPos) {
                    if (fork.size < 0) {
                        if (fork.size == -3)
                            localSkipped += 4;
                        else
                            break scan;
                    } else if (fork.id >= minRepeatType) {
                        localSkipped += 4;
                    }
                    fork.next();
                }
                start = nodeStart;
                size += nodeSize;
                skip += localSkipped;
            }
            if (inRepeat < 0 || size == maxSize) {
                result.size = size;
                result.start = start;
                result.skip = skip;
            }
            return result.size > 4 ? result : undefined;
        }
        function copyToBuffer(bufferStart, buffer, index) {
            let {id, start, end, size} = cursor;
            cursor.next();
            if (size >= 0 && id < minRepeatType) {
                let startIndex = index;
                if (size > 4) {
                    let endPos = cursor.pos - (size - 4);
                    while (cursor.pos > endPos)
                        index = copyToBuffer(bufferStart, buffer, index);
                }
                buffer[--index] = startIndex;
                buffer[--index] = end - bufferStart;
                buffer[--index] = start - bufferStart;
                buffer[--index] = id;
            } else if (size == -3) {
                contextHash = id;
            } else if (size == -4) {
                lookAhead = id;
            }
            return index;
        }
        let children = [],
            positions = [];
        while (cursor.pos > 0)
            takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
        let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
        return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
    }
    const nodeSizeCache = new WeakMap();
    function nodeSize(balanceType, node) {
        if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
            return 1;
        let size = nodeSizeCache.get(node);
        if (size == null) {
            size = 1;
            for (let _i145 = 0, _node$children = node.children, _length145 = _node$children.length; _i145 < _length145; _i145++) {
                let child = _node$children[_i145];
                if (child.type != balanceType || !(child instanceof Tree)) {
                    size = 1;
                    break;
                }
                size += nodeSize(balanceType, child);
            }
            nodeSizeCache.set(node, size);
        }
        return size;
    }
    function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
        let total = 0;
        for (let i = from; i < to; i++)
            total += nodeSize(balanceType, children[i]);
        let maxChild = Math.ceil(total * 1.5 / 8);
        let localChildren = [],
            localPositions = [];
        function divide(children, positions, from, to, offset) {
            for (let i = from; i < to;) {
                let groupFrom = i,
                    groupStart = positions[i],
                    groupSize = nodeSize(balanceType, children[i]);
                i++;
                for (; i < to; i++) {
                    let nextSize = nodeSize(balanceType, children[i]);
                    if (groupSize + nextSize >= maxChild)
                        break;
                    groupSize += nextSize;
                }
                if (i == groupFrom + 1) {
                    if (groupSize > maxChild) {
                        let only = children[groupFrom];
                        divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                        continue;
                    }
                    localChildren.push(children[groupFrom]);
                } else {
                    let length = positions[i - 1] + children[i - 1].length - groupStart;
                    localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
                }
                localPositions.push(groupStart + offset - start);
            }
        }
        divide(children, positions, from, to, 0);
        return (mkTop || mkTree)(localChildren, localPositions, length);
    }
    class NodeWeakMap {
        constructor()
        {
            this.map = new WeakMap();
        }
        setBuffer(buffer, index, value)
        {
            let inner = this.map.get(buffer);
            if (!inner)
                this.map.set(buffer, inner = new Map());
            inner.set(index, value);
        }
        getBuffer(buffer, index)
        {
            let inner = this.map.get(buffer);
            return inner && inner.get(index);
        }
        set(node, value)
        {
            if (node instanceof BufferNode)
                this.setBuffer(node.context.buffer, node.index, value);
            else if (node instanceof TreeNode)
                this.map.set(node.tree, value);
        }
        get(node)
        {
            return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;
        }
        cursorSet(cursor, value)
        {
            if (cursor.buffer)
                this.setBuffer(cursor.buffer.buffer, cursor.index, value);
            else
                this.map.set(cursor.tree, value);
        }
        cursorGet(cursor)
        {
            return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
        }
    }
    class TreeFragment {
        constructor(from, to, tree, offset, openStart=false, openEnd=false)
        {
            this.from = from;
            this.to = to;
            this.tree = tree;
            this.offset = offset;
            this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
        }
        get openStart()
        {
            return (this.open & 1) > 0;
        }
        get openEnd()
        {
            return (this.open & 2) > 0;
        }
        static addTree(tree, fragments=[], partial=false)
        {
            let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
            for (let _i146 = 0, _length146 = fragments.length; _i146 < _length146; _i146++) {
                let f = fragments[_i146];
                if (f.to > tree.length)
                    result.push(f);
            }
            return result;
        }
        static applyChanges(fragments, changes, minGap=128)
        {
            if (!changes.length)
                return fragments;
            let result = [];
            let fI = 1,
                nextF = fragments.length ? fragments[0] : null;
            for (let cI = 0, pos = 0, off = 0; ; cI++) {
                let nextC = cI < changes.length ? changes[cI] : null;
                let nextPos = nextC ? nextC.fromA : 1e9;
                if (nextPos - pos >= minGap)
                    while (nextF && nextF.from < nextPos) {
                        let cut = nextF;
                        if (pos >= cut.from || nextPos <= cut.to || off) {
                            let fFrom = Math.max(cut.from, pos) - off,
                                fTo = Math.min(cut.to, nextPos) - off;
                            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                        }
                        if (cut)
                            result.push(cut);
                        if (nextF.to > nextPos)
                            break;
                        nextF = fI < fragments.length ? fragments[fI++] : null;
                    }
                if (!nextC)
                    break;
                pos = nextC.toA;
                off = nextC.toA - nextC.toB;
            }
            return result;
        }
    }
    class Parser {
        startParse(input, fragments, ranges)
        {
            if (typeof input == "string")
                input = new StringInput(input);
            ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
            return this.createParse(input, fragments || [], ranges);
        }
        parse(input, fragments, ranges)
        {
            let parse = this.startParse(input, fragments, ranges);
            for (;;) {
                let done = parse.advance();
                if (done)
                    return done;
            }
        }
    }
    class StringInput {
        constructor(string)
        {
            this.string = string;
        }
        get length()
        {
            return this.string.length;
        }
        chunk(from)
        {
            return this.string.slice(from);
        }
        get lineChunks()
        {
            return false;
        }
        read(from, to)
        {
            return this.string.slice(from, to);
        }
    }
    function parseMixed(nest) {
        return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
    }
    class InnerParse {
        constructor(parser, parse, overlay, target, ranges)
        {
            this.parser = parser;
            this.parse = parse;
            this.overlay = overlay;
            this.target = target;
            this.ranges = ranges;
        }
    }
    class ActiveOverlay {
        constructor(parser, predicate, mounts, index, start, target, prev)
        {
            this.parser = parser;
            this.predicate = predicate;
            this.mounts = mounts;
            this.index = index;
            this.start = start;
            this.target = target;
            this.prev = prev;
            this.depth = 0;
            this.ranges = [];
        }
    }
    const stoppedInner = new NodeProp({
        perNode: true
    });
    class MixedParse {
        constructor(base, nest, input, fragments, ranges)
        {
            this.nest = nest;
            this.input = input;
            this.fragments = fragments;
            this.ranges = ranges;
            this.inner = [];
            this.innerDone = 0;
            this.baseTree = null;
            this.stoppedAt = null;
            this.baseParse = base;
        }
        advance()
        {
            if (this.baseParse) {
                let done = this.baseParse.advance();
                if (!done)
                    return null;
                this.baseParse = null;
                this.baseTree = done;
                this.startInner();
                if (this.stoppedAt != null)
                    for (let _i147 = 0, _this$inner = this.inner, _length147 = _this$inner.length; _i147 < _length147; _i147++) {
                        let inner = _this$inner[_i147];
                        inner.parse.stopAt(this.stoppedAt);
                    }
            }
            if (this.innerDone == this.inner.length) {
                let result = this.baseTree;
                if (this.stoppedAt != null)
                    result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
                return result;
            }
            let inner = this.inner[this.innerDone],
                done = inner.parse.advance();
            if (done) {
                this.innerDone++;
                let props = Object.assign(Object.create(null), inner.target.props);
                props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
                inner.target.props = props;
            }
            return null;
        }
        get parsedPos()
        {
            if (this.baseParse)
                return 0;
            let pos = this.input.length;
            for (let i = this.innerDone; i < this.inner.length; i++) {
                if (this.inner[i].ranges[0].from < pos)
                    pos = Math.min(pos, this.inner[i].parse.parsedPos);
            }
            return pos;
        }
        stopAt(pos)
        {
            this.stoppedAt = pos;
            if (this.baseParse)
                this.baseParse.stopAt(pos);
            else
                for (let i = this.innerDone; i < this.inner.length; i++)
                    this.inner[i].parse.stopAt(pos);
        }
        startInner()
        {
            let fragmentCursor = new FragmentCursor$2(this.fragments);
            let overlay = null;
            let covered = null;
            let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
            scan:
            for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {
                let enter = true,
                    range;
                if (fragmentCursor.hasNode(cursor)) {
                    if (overlay) {
                        let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                        if (match)
                            for (let _i148 = 0, _match$mount$overlay = match.mount.overlay, _length148 = _match$mount$overlay.length; _i148 < _length148; _i148++) {
                                let r = _match$mount$overlay[_i148];
                                let from = r.from + match.pos,
                                    to = r.to + match.pos;
                                if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                    overlay.ranges.push({
                                        from,
                                        to
                                    });
                            }
                    }
                    enter = false;
                } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                    enter = isCovered != 2;
                } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                    if (!cursor.tree)
                        materialize(cursor);
                    let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                    if (typeof nest.overlay == "function") {
                        overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                    } else {
                        let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                        if (ranges.length)
                            this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                        if (!nest.overlay)
                            enter = false;
                        else if (ranges.length)
                            covered = {
                                ranges,
                                depth: 0,
                                prev: covered
                            };
                    }
                } else if (overlay && (range = overlay.predicate(cursor))) {
                    if (range === true)
                        range = new Range(cursor.from, cursor.to);
                    if (range.from < range.to)
                        overlay.ranges.push(range);
                }
                if (enter && cursor.firstChild()) {
                    if (overlay)
                        overlay.depth++;
                    if (covered)
                        covered.depth++;
                } else {
                    for (;;) {
                        if (cursor.nextSibling())
                            break;
                        if (!cursor.parent())
                            break scan;
                        if (overlay && !--overlay.depth) {
                            let ranges = punchRanges(this.ranges, overlay.ranges);
                            if (ranges.length)
                                this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                            overlay = overlay.prev;
                        }
                        if (covered && !--covered.depth)
                            covered = covered.prev;
                    }
                }
            }
        }
    }
    function checkCover(covered, from, to) {
        for (let _i149 = 0, _length149 = covered.length; _i149 < _length149; _i149++) {
            let range = covered[_i149];
            if (range.from >= to)
                break;
            if (range.to > from)
                return range.from <= from && range.to >= to ? 2 : 1;
        }
        return 0;
    }
    function sliceBuf(buf, startI, endI, nodes, positions, off) {
        if (startI < endI) {
            let from = buf.buffer[startI + 1],
                to = buf.buffer[endI - 2];
            nodes.push(buf.slice(startI, endI, from, to));
            positions.push(from - off);
        }
    }
    function materialize(cursor) {
        let {node} = cursor,
            depth = 0;
        do {
            cursor.parent();
            depth++;
        } while (!cursor.tree);
        let i = 0,
            base = cursor.tree,
            off = 0;
        for (;; i++) {
            off = base.positions[i] + cursor.from;
            if (off <= node.from && off + base.children[i].length >= node.to)
                break;
        }
        let buf = base.children[i],
            b = buf.buffer;
        function split(startI, endI, type, innerOffset, length) {
            let i = startI;
            while (b[i + 2] + off <= node.from)
                i = b[i + 3];
            let children = [],
                positions = [];
            sliceBuf(buf, startI, i, children, positions, innerOffset);
            let from = b[i + 1],
                to = b[i + 2];
            let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;
            children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));
            positions.push(from - innerOffset);
            sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
            return new Tree(type, children, positions, length);
        }
        base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
        for (let d = 0; d <= depth; d++)
            cursor.childAfter(node.from);
    }
    class StructureCursor {
        constructor(root, offset)
        {
            this.offset = offset;
            this.done = false;
            this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
        }
        moveTo(pos)
        {
            let {cursor} = this,
                p = pos - this.offset;
            while (!this.done && cursor.from < p) {
                if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers))
                    ;
                else if (!cursor.next(false))
                    this.done = true;
            }
        }
        hasNode(cursor)
        {
            this.moveTo(cursor.from);
            if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
                for (let tree = this.cursor.tree; ;) {
                    if (tree == cursor.tree)
                        return true;
                    if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                        tree = tree.children[0];
                    else
                        break;
                }
            }
            return false;
        }
    }
    class FragmentCursor$2 {
        constructor(fragments)
        {
            var _a;
            this.fragments = fragments;
            this.curTo = 0;
            this.fragI = 0;
            if (fragments.length) {
                let first = this.curFrag = fragments[0];
                this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
                this.inner = new StructureCursor(first.tree, -first.offset);
            } else {
                this.curFrag = this.inner = null;
            }
        }
        hasNode(node)
        {
            while (this.curFrag && node.from >= this.curTo)
                this.nextFrag();
            return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
        }
        nextFrag()
        {
            var _a;
            this.fragI++;
            if (this.fragI == this.fragments.length) {
                this.curFrag = this.inner = null;
            } else {
                let frag = this.curFrag = this.fragments[this.fragI];
                this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
                this.inner = new StructureCursor(frag.tree, -frag.offset);
            }
        }
        findMounts(pos, parser)
        {
            var _a;
            let result = [];
            if (this.inner) {
                this.inner.cursor.moveTo(pos, 1);
                for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                    let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                    if (mount && mount.parser == parser) {
                        for (let i = this.fragI; i < this.fragments.length; i++) {
                            let frag = this.fragments[i];
                            if (frag.from >= pos.to)
                                break;
                            if (frag.tree == this.curFrag.tree)
                                result.push({
                                    frag,
                                    pos: pos.from - frag.offset,
                                    mount
                                });
                        }
                    }
                }
            }
            return result;
        }
    }
    function punchRanges(outer, ranges) {
        let copy = null,
            current = ranges;
        for (let i = 1, j = 0; i < outer.length; i++) {
            let gapFrom = outer[i - 1].to,
                gapTo = outer[i].from;
            for (; j < current.length; j++) {
                let r = current[j];
                if (r.from >= gapTo)
                    break;
                if (r.to <= gapFrom)
                    continue;
                if (!copy)
                    current = copy = ranges.slice();
                if (r.from < gapFrom) {
                    copy[j] = new Range(r.from, gapFrom);
                    if (r.to > gapTo)
                        copy.splice(j + 1, 0, new Range(gapTo, r.to));
                } else if (r.to > gapTo) {
                    copy[j--] = new Range(gapTo, r.to);
                } else {
                    copy.splice(j--, 1);
                }
            }
        }
        return current;
    }
    function findCoverChanges(a, b, from, to) {
        let iA = 0,
            iB = 0,
            inA = false,
            inB = false,
            pos = -1e9;
        let result = [];
        for (;;) {
            let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
            let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
            if (inA != inB) {
                let start = Math.max(pos, from),
                    end = Math.min(nextA, nextB, to);
                if (start < end)
                    result.push(new Range(start, end));
            }
            pos = Math.min(nextA, nextB);
            if (pos == 1e9)
                break;
            if (nextA == pos) {
                if (!inA)
                    inA = true;
                else {
                    inA = false;
                    iA++;
                }
            }
            if (nextB == pos) {
                if (!inB)
                    inB = true;
                else {
                    inB = false;
                    iB++;
                }
            }
        }
        return result;
    }
    function enterFragments(mounts, ranges) {
        let result = [];
        for (let _i150 = 0, _length150 = mounts.length; _i150 < _length150; _i150++) {
            let {pos, mount, frag} = mounts[_i150];
            let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),
                endPos = startPos + mount.tree.length;
            let from = Math.max(frag.from, startPos),
                to = Math.min(frag.to, endPos);
            if (mount.overlay) {
                let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
                let changes = findCoverChanges(ranges, overlay, from, to);
                for (let i = 0, pos = from; ; i++) {
                    let last = i == changes.length,
                        end = last ? to : changes[i].from;
                    if (end > pos)
                        result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));
                    if (last)
                        break;
                    pos = changes[i].to;
                }
            } else {
                result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
            }
        }
        return result;
    }
    var _m26 = Object.freeze({
        __proto__: null,
        DefaultBufferLength: DefaultBufferLength,
        get IterMode() {
            return IterMode;
        },
        MountedTree: MountedTree,
        NodeProp: NodeProp,
        NodeSet: NodeSet,
        NodeType: NodeType,
        NodeWeakMap: NodeWeakMap,
        Parser: Parser,
        Tree: Tree,
        TreeBuffer: TreeBuffer,
        TreeCursor: TreeCursor,
        TreeFragment: TreeFragment,
        parseMixed: parseMixed
    });
    let nextTagID = 0;
    class Tag {
        constructor(set, base, modified)
        {
            this.set = set;
            this.base = base;
            this.modified = modified;
            this.id = nextTagID++;
        }
        static define(parent)
        {
            if (parent === null || parent === void 0 ? void 0 : parent.base)
                throw new Error("Can not derive from a modified tag");
            let tag = new Tag([], null, []);
            tag.set.push(tag);
            if (parent)
                for (let _i151 = 0, _parent$set = parent.set, _length151 = _parent$set.length; _i151 < _length151; _i151++) {
                    let t = _parent$set[_i151];
                    tag.set.push(t);
                }
            return tag;
        }
        static defineModifier()
        {
            let mod = new Modifier();
            return tag => {
                if (tag.modified.indexOf(mod) > -1)
                    return tag;
                return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
            };
        }
    }
    let nextModifierID = 0;
    class Modifier {
        constructor()
        {
            this.instances = [];
            this.id = nextModifierID++;
        }
        static get(base, mods)
        {
            if (!mods.length)
                return base;
            let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
            if (exists)
                return exists;
            let set = [],
                tag = new Tag(set, base, mods);
            for (let _i152 = 0, _length152 = mods.length; _i152 < _length152; _i152++) {
                let m = mods[_i152];
                m.instances.push(tag);
            }
            let configs = powerSet(mods);
            for (let _i153 = 0, _base$set = base.set, _length153 = _base$set.length; _i153 < _length153; _i153++) {
                let parent = _base$set[_i153];
                if (!parent.modified.length)
                    for (let _i154 = 0, _length154 = configs.length; _i154 < _length154; _i154++) {
                        let config = configs[_i154];
                        set.push(Modifier.get(parent, config));
                    }
            }
            return tag;
        }
    }
    function sameArray(a, b) {
        return a.length == b.length && a.every((x, i) => x == b[i]);
    }
    function powerSet(array) {
        let sets = [[]];
        for (let i = 0; i < array.length; i++) {
            for (let j = 0, e = sets.length; j < e; j++) {
                sets.push(sets[j].concat(array[i]));
            }
        }
        return sets.sort((a, b) => b.length - a.length);
    }
    function styleTags(spec) {
        let byName = Object.create(null);
        for (let prop in spec) {
            let tags = spec[prop];
            if (!Array.isArray(tags))
                tags = [tags];
            for (let _i155 = 0, _prop$split2 = prop.split(" "), _length155 = _prop$split2.length; _i155 < _length155; _i155++) {
                let part = _prop$split2[_i155];
                if (part) {
                    let pieces = [],
                        mode = 2,
                        rest = part;
                    for (let pos = 0; ;) {
                        if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                            mode = 1;
                            break;
                        }
                        let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                        if (!m)
                            throw new RangeError("Invalid path: " + part);
                        pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                        pos += m[0].length;
                        if (pos == part.length)
                            break;
                        let next = part[pos++];
                        if (pos == part.length && next == "!") {
                            mode = 0;
                            break;
                        }
                        if (next != "/")
                            throw new RangeError("Invalid path: " + part);
                        rest = part.slice(pos);
                    }
                    let last = pieces.length - 1,
                        inner = pieces[last];
                    if (!inner)
                        throw new RangeError("Invalid path: " + part);
                    let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
                    byName[inner] = rule.sort(byName[inner]);
                }
            }
        }
        return ruleNodeProp.add(byName);
    }
    const ruleNodeProp = new NodeProp();
    class Rule {
        constructor(tags, mode, context, next)
        {
            this.tags = tags;
            this.mode = mode;
            this.context = context;
            this.next = next;
        }
        get opaque()
        {
            return this.mode == 0;
        }
        get inherit()
        {
            return this.mode == 1;
        }
        sort(other)
        {
            if (!other || other.depth < this.depth) {
                this.next = other;
                return this;
            }
            other.next = this.sort(other.next);
            return other;
        }
        get depth()
        {
            return this.context ? this.context.length : 0;
        }
    }
    Rule.empty = new Rule([], 2, null);
    function tagHighlighter(tags, options) {
        let map = Object.create(null);
        for (let _i156 = 0, _length156 = tags.length; _i156 < _length156; _i156++) {
            let style = tags[_i156];
            if (!Array.isArray(style.tag))
                map[style.tag.id] = style.class;
            else
                for (let _i157 = 0, _style$tag = style.tag, _length157 = _style$tag.length; _i157 < _length157; _i157++) {
                    let tag = _style$tag[_i157];
                    map[tag.id] = style.class;
                }
        }
        let {scope, all=null} = options || {};
        return {
            style: tags => {
                let cls = all;
                for (let _i158 = 0, _length158 = tags.length; _i158 < _length158; _i158++) {
                    let tag = tags[_i158];
                    for (let _i159 = 0, _tag$set = tag.set, _length159 = _tag$set.length; _i159 < _length159; _i159++) {
                        let sub = _tag$set[_i159];
                        let tagClass = map[sub.id];
                        if (tagClass) {
                            cls = cls ? cls + " " + tagClass : tagClass;
                            break;
                        }
                    }
                }
                return cls;
            },
            scope
        };
    }
    function highlightTags(highlighters, tags) {
        let result = null;
        for (let _i160 = 0, _length160 = highlighters.length; _i160 < _length160; _i160++) {
            let highlighter = highlighters[_i160];
            let value = highlighter.style(tags);
            if (value)
                result = result ? result + " " + value : value;
        }
        return result;
    }
    function highlightTree(tree, highlighter, putStyle, from=0, to=tree.length) {
        let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
        builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
        builder.flush(to);
    }
    class HighlightBuilder {
        constructor(at, highlighters, span)
        {
            this.at = at;
            this.highlighters = highlighters;
            this.span = span;
            this.class = "";
        }
        startSpan(at, cls)
        {
            if (cls != this.class) {
                this.flush(at);
                if (at > this.at)
                    this.at = at;
                this.class = cls;
            }
        }
        flush(to)
        {
            if (to > this.at && this.class)
                this.span(this.at, to, this.class);
        }
        highlightRange(cursor, from, to, inheritedClass, highlighters)
        {
            let {type, from: start, to: end} = cursor;
            if (start >= to || end <= from)
                return;
            if (type.isTop)
                highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));
            let cls = inheritedClass;
            let rule = getStyleTags(cursor) || Rule.empty;
            let tagCls = highlightTags(highlighters, rule.tags);
            if (tagCls) {
                if (cls)
                    cls += " ";
                cls += tagCls;
                if (rule.mode == 1)
                    inheritedClass += (inheritedClass ? " " : "") + tagCls;
            }
            this.startSpan(cursor.from, cls);
            if (rule.opaque)
                return;
            let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
            if (mounted && mounted.overlay) {
                let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
                let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));
                let hasChild = cursor.firstChild();
                for (let i = 0, pos = start; ; i++) {
                    let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
                    let nextPos = next ? next.from + start : end;
                    let rangeFrom = Math.max(from, pos),
                        rangeTo = Math.min(to, nextPos);
                    if (rangeFrom < rangeTo && hasChild) {
                        while (cursor.from < rangeTo) {
                            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                            this.startSpan(Math.min(rangeTo, cursor.to), cls);
                            if (cursor.to >= nextPos || !cursor.nextSibling())
                                break;
                        }
                    }
                    if (!next || nextPos > to)
                        break;
                    pos = next.to + start;
                    if (pos > from) {
                        this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
                        this.startSpan(pos, cls);
                    }
                }
                if (hasChild)
                    cursor.parent();
            } else if (cursor.firstChild()) {
                do {
                    if (cursor.to <= from)
                        continue;
                    if (cursor.from >= to)
                        break;
                    this.highlightRange(cursor, from, to, inheritedClass, highlighters);
                    this.startSpan(Math.min(to, cursor.to), cls);
                } while (cursor.nextSibling());
                cursor.parent();
            }
        }
    }
    function getStyleTags(node) {
        let rule = node.type.prop(ruleNodeProp);
        while (rule && rule.context && !node.matchContext(rule.context))
            rule = rule.next;
        return rule || null;
    }
    const t = Tag.define;
    const comment = t(),
        name = t(),
        typeName = t(name),
        propertyName = t(name),
        literal = t(),
        string = t(literal),
        number = t(literal),
        content = t(),
        heading = t(content),
        keyword = t(),
        operator = t(),
        punctuation = t(),
        bracket = t(punctuation),
        meta = t();
    const tags$1 = {
        comment,
        lineComment: t(comment),
        blockComment: t(comment),
        docComment: t(comment),
        name,
        variableName: t(name),
        typeName: typeName,
        tagName: t(typeName),
        propertyName: propertyName,
        attributeName: t(propertyName),
        className: t(name),
        labelName: t(name),
        namespace: t(name),
        macroName: t(name),
        literal,
        string,
        docString: t(string),
        character: t(string),
        attributeValue: t(string),
        number,
        integer: t(number),
        float: t(number),
        bool: t(literal),
        regexp: t(literal),
        escape: t(literal),
        color: t(literal),
        url: t(literal),
        keyword,
        self: t(keyword),
        null: t(keyword),
        atom: t(keyword),
        unit: t(keyword),
        modifier: t(keyword),
        operatorKeyword: t(keyword),
        controlKeyword: t(keyword),
        definitionKeyword: t(keyword),
        moduleKeyword: t(keyword),
        operator,
        derefOperator: t(operator),
        arithmeticOperator: t(operator),
        logicOperator: t(operator),
        bitwiseOperator: t(operator),
        compareOperator: t(operator),
        updateOperator: t(operator),
        definitionOperator: t(operator),
        typeOperator: t(operator),
        controlOperator: t(operator),
        punctuation,
        separator: t(punctuation),
        bracket,
        angleBracket: t(bracket),
        squareBracket: t(bracket),
        paren: t(bracket),
        brace: t(bracket),
        content,
        heading,
        heading1: t(heading),
        heading2: t(heading),
        heading3: t(heading),
        heading4: t(heading),
        heading5: t(heading),
        heading6: t(heading),
        contentSeparator: t(content),
        list: t(content),
        quote: t(content),
        emphasis: t(content),
        strong: t(content),
        link: t(content),
        monospace: t(content),
        strikethrough: t(content),
        inserted: t(),
        deleted: t(),
        changed: t(),
        invalid: t(),
        meta,
        documentMeta: t(meta),
        annotation: t(meta),
        processingInstruction: t(meta),
        definition: Tag.defineModifier(),
        constant: Tag.defineModifier(),
        function: Tag.defineModifier(),
        standard: Tag.defineModifier(),
        local: Tag.defineModifier(),
        special: Tag.defineModifier()
    };
    const classHighlighter = tagHighlighter([{
        tag: tags$1.link,
        class: "tok-link"
    }, {
        tag: tags$1.heading,
        class: "tok-heading"
    }, {
        tag: tags$1.emphasis,
        class: "tok-emphasis"
    }, {
        tag: tags$1.strong,
        class: "tok-strong"
    }, {
        tag: tags$1.keyword,
        class: "tok-keyword"
    }, {
        tag: tags$1.atom,
        class: "tok-atom"
    }, {
        tag: tags$1.bool,
        class: "tok-bool"
    }, {
        tag: tags$1.url,
        class: "tok-url"
    }, {
        tag: tags$1.labelName,
        class: "tok-labelName"
    }, {
        tag: tags$1.inserted,
        class: "tok-inserted"
    }, {
        tag: tags$1.deleted,
        class: "tok-deleted"
    }, {
        tag: tags$1.literal,
        class: "tok-literal"
    }, {
        tag: tags$1.string,
        class: "tok-string"
    }, {
        tag: tags$1.number,
        class: "tok-number"
    }, {
        tag: [tags$1.regexp, tags$1.escape, tags$1.special(tags$1.string)],
        class: "tok-string2"
    }, {
        tag: tags$1.variableName,
        class: "tok-variableName"
    }, {
        tag: tags$1.local(tags$1.variableName),
        class: "tok-variableName tok-local"
    }, {
        tag: tags$1.definition(tags$1.variableName),
        class: "tok-variableName tok-definition"
    }, {
        tag: tags$1.special(tags$1.variableName),
        class: "tok-variableName2"
    }, {
        tag: tags$1.definition(tags$1.propertyName),
        class: "tok-propertyName tok-definition"
    }, {
        tag: tags$1.typeName,
        class: "tok-typeName"
    }, {
        tag: tags$1.namespace,
        class: "tok-namespace"
    }, {
        tag: tags$1.className,
        class: "tok-className"
    }, {
        tag: tags$1.macroName,
        class: "tok-macroName"
    }, {
        tag: tags$1.propertyName,
        class: "tok-propertyName"
    }, {
        tag: tags$1.operator,
        class: "tok-operator"
    }, {
        tag: tags$1.comment,
        class: "tok-comment"
    }, {
        tag: tags$1.meta,
        class: "tok-meta"
    }, {
        tag: tags$1.invalid,
        class: "tok-invalid"
    }, {
        tag: tags$1.punctuation,
        class: "tok-punctuation"
    }]);
    var _m27 = Object.freeze({
        __proto__: null,
        Tag: Tag,
        classHighlighter: classHighlighter,
        getStyleTags: getStyleTags,
        highlightTree: highlightTree,
        styleTags: styleTags,
        tagHighlighter: tagHighlighter,
        tags: tags$1
    });
    var _a;
    const languageDataProp = new NodeProp();
    function defineLanguageFacet(baseData) {
        return Facet.define({
            combine: baseData ? values => values.concat(baseData) : undefined
        });
    }
    class Language {
        constructor(data, parser, extraExtensions=[], name="")
        {
            this.data = data;
            this.name = name;
            if (!EditorState.prototype.hasOwnProperty("tree"))
                Object.defineProperty(EditorState.prototype, "tree", {
                    get() {
                        return syntaxTree(this);
                    }
                });
            this.parser = parser;
            this.extension = [language.of(this), EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))].concat(extraExtensions);
        }
        isActiveAt(state, pos, side=-1)
        {
            return languageDataFacetAt(state, pos, side) == this.data;
        }
        findRegions(state)
        {
            let lang = state.facet(language);
            if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
                return [{
                    from: 0,
                    to: state.doc.length
                }];
            if (!lang || !lang.allowsNesting)
                return [];
            let result = [];
            let explore = (tree, from) => {
                if (tree.prop(languageDataProp) == this.data) {
                    result.push({
                        from,
                        to: from + tree.length
                    });
                    return;
                }
                let mount = tree.prop(NodeProp.mounted);
                if (mount) {
                    if (mount.tree.prop(languageDataProp) == this.data) {
                        if (mount.overlay)
                            for (let _i161 = 0, _mount$overlay = mount.overlay, _length161 = _mount$overlay.length; _i161 < _length161; _i161++) {
                                let r = _mount$overlay[_i161];
                                result.push({
                                    from: r.from + from,
                                    to: r.to + from
                                });
                            }
                        else
                            result.push({
                                from: from,
                                to: from + tree.length
                            });
                        return;
                    } else if (mount.overlay) {
                        let size = result.length;
                        explore(mount.tree, mount.overlay[0].from + from);
                        if (result.length > size)
                            return;
                    }
                }
                for (let i = 0; i < tree.children.length; i++) {
                    let ch = tree.children[i];
                    if (ch instanceof Tree)
                        explore(ch, tree.positions[i] + from);
                }
            };
            explore(syntaxTree(state), 0);
            return result;
        }
        get allowsNesting()
        {
            return true;
        }
    }
    Language.setState = StateEffect.define();
    function languageDataFacetAt(state, pos, side) {
        let topLang = state.facet(language);
        if (!topLang)
            return null;
        let facet = topLang.data;
        if (topLang.allowsNesting) {
            for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
                facet = node.type.prop(languageDataProp) || facet;
        }
        return facet;
    }
    class LRLanguage extends Language {
        constructor(data, parser, name)
        {
            super(data, parser, [], name);
            this.parser = parser;
        }
        static define(spec)
        {
            let data = defineLanguageFacet(spec.languageData);
            return new LRLanguage(data, spec.parser.configure({
                props: [languageDataProp.add(type => type.isTop ? data : undefined)]
            }), spec.name);
        }
        configure(options, name)
        {
            return new LRLanguage(this.data, this.parser.configure(options), name || this.name);
        }
        get allowsNesting()
        {
            return this.parser.hasWrappers();
        }
    }
    function syntaxTree(state) {
        let field = state.field(Language.state, false);
        return field ? field.tree : Tree.empty;
    }
    function ensureSyntaxTree(state, upto, timeout=50) {
        var _a;
        let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;
        if (!parse)
            return null;
        let oldVieport = parse.viewport;
        parse.updateViewport({
            from: 0,
            to: upto
        });
        let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;
        parse.updateViewport(oldVieport);
        return result;
    }
    function syntaxTreeAvailable(state, upto=state.doc.length) {
        var _a;
        return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;
    }
    function forceParsing(view, upto=view.viewport.to, timeout=100) {
        let success = ensureSyntaxTree(view.state, upto, timeout);
        if (success != syntaxTree(view.state))
            view.dispatch({});
        return !!success;
    }
    function syntaxParserRunning(view) {
        var _a;
        return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;
    }
    class DocInput {
        constructor(doc, length=doc.length)
        {
            this.doc = doc;
            this.length = length;
            this.cursorPos = 0;
            this.string = "";
            this.cursor = doc.iter();
        }
        syncTo(pos)
        {
            this.string = this.cursor.next(pos - this.cursorPos).value;
            this.cursorPos = pos + this.string.length;
            return this.cursorPos - this.string.length;
        }
        chunk(pos)
        {
            this.syncTo(pos);
            return this.string;
        }
        get lineChunks()
        {
            return true;
        }
        read(from, to)
        {
            let stringStart = this.cursorPos - this.string.length;
            if (from < stringStart || to >= this.cursorPos)
                return this.doc.sliceString(from, to);
            else
                return this.string.slice(from - stringStart, to - stringStart);
        }
    }
    let currentContext = null;
    class ParseContext {
        constructor(parser, state, fragments=[], tree, treeLen, viewport, skipped, scheduleOn)
        {
            this.parser = parser;
            this.state = state;
            this.fragments = fragments;
            this.tree = tree;
            this.treeLen = treeLen;
            this.viewport = viewport;
            this.skipped = skipped;
            this.scheduleOn = scheduleOn;
            this.parse = null;
            this.tempSkipped = [];
        }
        static create(parser, state, viewport)
        {
            return new ParseContext(parser, state, [], Tree.empty, 0, viewport, [], null);
        }
        startParse()
        {
            return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
        }
        work(until, upto)
        {
            if (upto != null && upto >= this.state.doc.length)
                upto = undefined;
            if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
                this.takeTree();
                return true;
            }
            return this.withContext(() => {
                var _a;
                if (typeof until == "number") {
                    let endTime = Date.now() + until;
                    until = () => Date.now() > endTime;
                }
                if (!this.parse)
                    this.parse = this.startParse();
                if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
                    this.parse.stopAt(upto);
                for (;;) {
                    let done = this.parse.advance();
                    if (done) {
                        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
                        this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
                        this.tree = done;
                        this.parse = null;
                        if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                            this.parse = this.startParse();
                        else
                            return true;
                    }
                    if (until())
                        return false;
                }
            });
        }
        takeTree()
        {
            let pos,
                tree;
            if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
                if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
                    this.parse.stopAt(pos);
                this.withContext(() => {
                    while (!(tree = this.parse.advance())) {}
                });
                this.treeLen = pos;
                this.tree = tree;
                this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
                this.parse = null;
            }
        }
        withContext(f)
        {
            let prev = currentContext;
            currentContext = this;
            try {
                return f();
            } finally {
                currentContext = prev;
            }
        }
        withoutTempSkipped(fragments)
        {
            for (let r; r = this.tempSkipped.pop();)
                fragments = cutFragments(fragments, r.from, r.to);
            return fragments;
        }
        changes(changes, newState)
        {
            let {fragments, tree, treeLen, viewport, skipped} = this;
            this.takeTree();
            if (!changes.empty) {
                let ranges = [];
                changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({
                    fromA,
                    toA,
                    fromB,
                    toB
                }));
                fragments = TreeFragment.applyChanges(fragments, ranges);
                tree = Tree.empty;
                treeLen = 0;
                viewport = {
                    from: changes.mapPos(viewport.from, -1),
                    to: changes.mapPos(viewport.to, 1)
                };
                if (this.skipped.length) {
                    skipped = [];
                    for (let _i162 = 0, _this$skipped = this.skipped, _length162 = _this$skipped.length; _i162 < _length162; _i162++) {
                        let r = _this$skipped[_i162];
                        let from = changes.mapPos(r.from, 1),
                            to = changes.mapPos(r.to, -1);
                        if (from < to)
                            skipped.push({
                                from,
                                to
                            });
                    }
                }
            }
            return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
        }
        updateViewport(viewport)
        {
            if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
                return false;
            this.viewport = viewport;
            let startLen = this.skipped.length;
            for (let i = 0; i < this.skipped.length; i++) {
                let {from, to} = this.skipped[i];
                if (from < viewport.to && to > viewport.from) {
                    this.fragments = cutFragments(this.fragments, from, to);
                    this.skipped.splice(i--, 1);
                }
            }
            if (this.skipped.length >= startLen)
                return false;
            this.reset();
            return true;
        }
        reset()
        {
            if (this.parse) {
                this.takeTree();
                this.parse = null;
            }
        }
        skipUntilInView(from, to)
        {
            this.skipped.push({
                from,
                to
            });
        }
        static getSkippingParser(until)
        {
            return new class  extends Parser{
                createParse(input, fragments, ranges)
                {
                    let from = ranges[0].from,
                        to = ranges[ranges.length - 1].to;
                    let parser = {
                        parsedPos: from,
                        advance() {
                            let cx = currentContext;
                            if (cx) {
                                for (let _i163 = 0, _length163 = ranges.length; _i163 < _length163; _i163++) {
                                    let r = ranges[_i163];
                                    cx.tempSkipped.push(r);
                                }
                                if (until)
                                    cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                            }
                            this.parsedPos = to;
                            return new Tree(NodeType.none, [], [], to - from);
                        },
                        stoppedAt: null,
                        stopAt() {}
                    };
                    return parser;
                }
            }
            ();
        }
        isDone(upto)
        {
            upto = Math.min(upto, this.state.doc.length);
            let frags = this.fragments;
            return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
        }
        static get()
        {
            return currentContext;
        }
    }
    function cutFragments(fragments, from, to) {
        return TreeFragment.applyChanges(fragments, [{
            fromA: from,
            toA: to,
            fromB: from,
            toB: to
        }]);
    }
    class LanguageState {
        constructor(context)
        {
            this.context = context;
            this.tree = context.tree;
        }
        apply(tr)
        {
            if (!tr.docChanged && this.tree == this.context.tree)
                return this;
            let newCx = this.context.changes(tr.changes, tr.state);
            let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
            if (!newCx.work(20, upto))
                newCx.takeTree();
            return new LanguageState(newCx);
        }
        static init(state)
        {
            let vpTo = Math.min(3000, state.doc.length);
            let parseState = ParseContext.create(state.facet(language).parser, state, {
                from: 0,
                to: vpTo
            });
            if (!parseState.work(20, vpTo))
                parseState.takeTree();
            return new LanguageState(parseState);
        }
    }
    Language.state = StateField.define({
        create: LanguageState.init,
        update(value, tr) {
            for (let _i164 = 0, _tr$effects5 = tr.effects, _length164 = _tr$effects5.length; _i164 < _length164; _i164++) {
                let e = _tr$effects5[_i164];
                if (e.is(Language.setState))
                    return e.value;
            }
            if (tr.startState.facet(language) != tr.state.facet(language))
                return LanguageState.init(tr.state);
            return value.apply(tr);
        }
    });
    let requestIdle = callback => {
        let timeout = setTimeout(() => callback(), 500);
        return () => clearTimeout(timeout);
    };
    if (typeof requestIdleCallback != "undefined")
        requestIdle = callback => {
            let idle = -1,
                timeout = setTimeout(() => {
                    idle = requestIdleCallback(callback, {
                        timeout: 500 - 100
                    });
                }, 100);
            return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
        };
    const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
    const parseWorker = ViewPlugin.fromClass(class ParseWorker {
        constructor(view)
        {
            this.view = view;
            this.working = null;
            this.workScheduled = 0;
            this.chunkEnd = -1;
            this.chunkBudget = -1;
            this.work = this.work.bind(this);
            this.scheduleWork();
        }
        update(update)
        {
            let cx = this.view.state.field(Language.state).context;
            if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
                this.scheduleWork();
            if (update.docChanged) {
                if (this.view.hasFocus)
                    this.chunkBudget += 50;
                this.scheduleWork();
            }
            this.checkAsyncSchedule(cx);
        }
        scheduleWork()
        {
            if (this.working)
                return;
            let {state} = this.view,
                field = state.field(Language.state);
            if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
                this.working = requestIdle(this.work);
        }
        work(deadline)
        {
            this.working = null;
            let now = Date.now();
            if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
                this.chunkEnd = now + 30000;
                this.chunkBudget = 3000;
            }
            if (this.chunkBudget <= 0)
                return;
            let {state, viewport: {to: vpTo}} = this.view,
                field = state.field(Language.state);
            if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000))
                return;
            let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
            let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;
            let done = field.context.work(() => {
                return isInputPending && isInputPending() || Date.now() > endTime;
            }, vpTo + (viewportFirst ? 0 : 100000));
            this.chunkBudget -= Date.now() - now;
            if (done || this.chunkBudget <= 0) {
                field.context.takeTree();
                this.view.dispatch({
                    effects: Language.setState.of(new LanguageState(field.context))
                });
            }
            if (this.chunkBudget > 0 && !(done && !viewportFirst))
                this.scheduleWork();
            this.checkAsyncSchedule(field.context);
        }
        checkAsyncSchedule(cx)
        {
            if (cx.scheduleOn) {
                this.workScheduled++;
                cx.scheduleOn.then(() => this.scheduleWork()).catch(err => logException(this.view.state, err)).then(() => this.workScheduled--);
                cx.scheduleOn = null;
            }
        }
        destroy()
        {
            if (this.working)
                this.working();
        }
        isWorking()
        {
            return !!(this.working || this.workScheduled > 0);
        }
    }
    , {
        eventHandlers: {
            focus() {
                this.scheduleWork();
            }
        }
    });
    const language = Facet.define({
        combine(languages) {
            return languages.length ? languages[0] : null;
        },
        enables: language => [Language.state, parseWorker, EditorView.contentAttributes.compute([language], state => {
            let lang = state.facet(language);
            return lang && lang.name ? {
                "data-language": lang.name
            } : {};
        })]
    });
    class LanguageSupport {
        constructor(language, support=[])
        {
            this.language = language;
            this.support = support;
            this.extension = [language, support];
        }
    }
    class LanguageDescription {
        constructor(name, alias, extensions, filename, loadFunc, support=undefined)
        {
            this.name = name;
            this.alias = alias;
            this.extensions = extensions;
            this.filename = filename;
            this.loadFunc = loadFunc;
            this.support = support;
            this.loading = null;
        }
        load()
        {
            return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => {
                    this.loading = null;
                    throw err;
                }));
        }
        static of(spec)
        {
            let {load, support} = spec;
            if (!load) {
                if (!support)
                    throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
                load = () => Promise.resolve(support);
            }
            return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
        }
        static matchFilename(descs, filename)
        {
            for (let _i165 = 0, _length165 = descs.length; _i165 < _length165; _i165++) {
                let d = descs[_i165];
                if (d.filename && d.filename.test(filename))
                    return d;
            }
            let ext = /\.([^.]+)$/.exec(filename);
            if (ext)
                for (let _i166 = 0, _length166 = descs.length; _i166 < _length166; _i166++) {
                    let d = descs[_i166];
                    if (d.extensions.indexOf(ext[1]) > -1)
                        return d;
                }
            return null;
        }
        static matchLanguageName(descs, name, fuzzy=true)
        {
            name = name.toLowerCase();
            for (let _i167 = 0, _length167 = descs.length; _i167 < _length167; _i167++) {
                let d = descs[_i167];
                if (d.alias.some(a => a == name))
                    return d;
            }
            if (fuzzy)
                for (let _i168 = 0, _length168 = descs.length; _i168 < _length168; _i168++) {
                    let d = descs[_i168];
                    for (let _i169 = 0, _d$alias = d.alias, _length169 = _d$alias.length; _i169 < _length169; _i169++) {
                        let a = _d$alias[_i169];
                        let found = name.indexOf(a);
                        if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length])))
                            return d;
                    }
                }
            return null;
        }
    }
    const indentService = Facet.define();
    const indentUnit = Facet.define({
        combine: values => {
            if (!values.length)
                return "  ";
            if (!/^(?: +|\t+)$/.test(values[0]))
                throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
            return values[0];
        }
    });
    function getIndentUnit(state) {
        let unit = state.facet(indentUnit);
        return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
    }
    function indentString(state, cols) {
        let result = "",
            ts = state.tabSize;
        if (state.facet(indentUnit).charCodeAt(0) == 9)
            while (cols >= ts) {
                result += "\t";
                cols -= ts;
            }
        for (let i = 0; i < cols; i++)
            result += " ";
        return result;
    }
    function getIndentation(context, pos) {
        if (context instanceof EditorState)
            context = new IndentContext(context);
        for (let _i170 = 0, _context$state$facet = context.state.facet(indentService), _length170 = _context$state$facet.length; _i170 < _length170; _i170++) {
            let service = _context$state$facet[_i170];
            let result = service(context, pos);
            if (result !== undefined)
                return result;
        }
        let tree = syntaxTree(context.state);
        return tree ? syntaxIndentation(context, tree, pos) : null;
    }
    function indentRange(state, from, to) {
        let updated = Object.create(null);
        let context = new IndentContext(state, {
            overrideIndentation: start => {
                var _a;
                return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;
            }
        });
        let changes = [];
        for (let pos = from; pos <= to;) {
            let line = state.doc.lineAt(pos);
            pos = line.to + 1;
            let indent = getIndentation(context, line.from);
            if (indent == null)
                continue;
            if (!/\S/.test(line.text))
                indent = 0;
            let cur = /^\s*/.exec(line.text)[0];
            let norm = indentString(state, indent);
            if (cur != norm) {
                updated[line.from] = indent;
                changes.push({
                    from: line.from,
                    to: line.from + cur.length,
                    insert: norm
                });
            }
        }
        return state.changes(changes);
    }
    class IndentContext {
        constructor(state, options={})
        {
            this.state = state;
            this.options = options;
            this.unit = getIndentUnit(state);
        }
        lineAt(pos, bias=1)
        {
            let line = this.state.doc.lineAt(pos);
            let {simulateBreak, simulateDoubleBreak} = this.options;
            if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
                if (simulateDoubleBreak && simulateBreak == pos)
                    return {
                        text: "",
                        from: pos
                    };
                else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
                    return {
                        text: line.text.slice(simulateBreak - line.from),
                        from: simulateBreak
                    };
                else
                    return {
                        text: line.text.slice(0, simulateBreak - line.from),
                        from: line.from
                    };
            }
            return line;
        }
        textAfterPos(pos, bias=1)
        {
            if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
                return "";
            let {text, from} = this.lineAt(pos, bias);
            return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
        }
        column(pos, bias=1)
        {
            let {text, from} = this.lineAt(pos, bias);
            let result = this.countColumn(text, pos - from);
            let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
            if (override > -1)
                result += override - this.countColumn(text, text.search(/\S|$/));
            return result;
        }
        countColumn(line, pos=line.length)
        {
            return countColumn(line, this.state.tabSize, pos);
        }
        lineIndent(pos, bias=1)
        {
            let {text, from} = this.lineAt(pos, bias);
            let override = this.options.overrideIndentation;
            if (override) {
                let overriden = override(from);
                if (overriden > -1)
                    return overriden;
            }
            return this.countColumn(text, text.search(/\S|$/));
        }
        get simulatedBreak()
        {
            return this.options.simulateBreak || null;
        }
    }
    const indentNodeProp = new NodeProp();
    function syntaxIndentation(cx, ast, pos) {
        return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
    }
    function ignoreClosed(cx) {
        return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
    }
    function indentStrategy(tree) {
        let strategy = tree.type.prop(indentNodeProp);
        if (strategy)
            return strategy;
        let first = tree.firstChild,
            close;
        if (first && (close = first.type.prop(NodeProp.closedBy))) {
            let last = tree.lastChild,
                closed = last && close.indexOf(last.name) > -1;
            return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
        }
        return tree.parent == null ? topIndent$1 : null;
    }
    function indentFrom(node, pos, base) {
        for (; node; node = node.parent) {
            let strategy = indentStrategy(node);
            if (strategy)
                return strategy(TreeIndentContext.create(base, pos, node));
        }
        return null;
    }
    function topIndent$1() {
        return 0;
    }
    class TreeIndentContext extends IndentContext {
        constructor(base, pos, node)
        {
            super(base.state, base.options);
            this.base = base;
            this.pos = pos;
            this.node = node;
        }
        static create(base, pos, node)
        {
            return new TreeIndentContext(base, pos, node);
        }
        get textAfter()
        {
            return this.textAfterPos(this.pos);
        }
        get baseIndent()
        {
            let line = this.state.doc.lineAt(this.node.from);
            for (;;) {
                let atBreak = this.node.resolve(line.from);
                while (atBreak.parent && atBreak.parent.from == atBreak.from)
                    atBreak = atBreak.parent;
                if (isParent(atBreak, this.node))
                    break;
                line = this.state.doc.lineAt(atBreak.from);
            }
            return this.lineIndent(line.from);
        }
        continue()
        {
            let parent = this.node.parent;
            return parent ? indentFrom(parent, this.pos, this.base) : 0;
        }
    }
    function isParent(parent, of) {
        for (let cur = of; cur; cur = cur.parent)
            if (parent == cur)
                return true;
        return false;
    }
    function bracketedAligned(context) {
        let tree = context.node;
        let openToken = tree.childAfter(tree.from),
            last = tree.lastChild;
        if (!openToken)
            return null;
        let sim = context.options.simulateBreak;
        let openLine = context.state.doc.lineAt(openToken.from);
        let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
        for (let pos = openToken.to; ;) {
            let next = tree.childAfter(pos);
            if (!next || next == last)
                return null;
            if (!next.type.isSkipped)
                return next.from < lineEnd ? openToken : null;
            pos = next.to;
        }
    }
    function delimitedIndent({closing, align=true, units=1}) {
        return context => delimitedStrategy(context, align, units, closing);
    }
    function delimitedStrategy(context, align, units, closing, closedAt) {
        let after = context.textAfter,
            space = after.match(/^\s*/)[0].length;
        let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
        let aligned = align ? bracketedAligned(context) : null;
        if (aligned)
            return closed ? context.column(aligned.from) : context.column(aligned.to);
        return context.baseIndent + (closed ? 0 : context.unit * units);
    }
    const flatIndent = context => context.baseIndent;
    function continuedIndent({except, units=1}={}) {
        return context => {
            let matchExcept = except && except.test(context.textAfter);
            return context.baseIndent + (matchExcept ? 0 : units * context.unit);
        };
    }
    const DontIndentBeyond = 200;
    function indentOnInput() {
        return EditorState.transactionFilter.of(tr => {
            if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
                return tr;
            let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
            if (!rules.length)
                return tr;
            let doc = tr.newDoc,
                {head} = tr.newSelection.main,
                line = doc.lineAt(head);
            if (head > line.from + DontIndentBeyond)
                return tr;
            let lineStart = doc.sliceString(line.from, head);
            if (!rules.some(r => r.test(lineStart)))
                return tr;
            let {state} = tr,
                last = -1,
                changes = [];
            for (let _i171 = 0, _state$selection$rang5 = state.selection.ranges, _length171 = _state$selection$rang5.length; _i171 < _length171; _i171++) {
                let {head} = _state$selection$rang5[_i171];
                let line = state.doc.lineAt(head);
                if (line.from == last)
                    continue;
                last = line.from;
                let indent = getIndentation(state, line.from);
                if (indent == null)
                    continue;
                let cur = /^\s*/.exec(line.text)[0];
                let norm = indentString(state, indent);
                if (cur != norm)
                    changes.push({
                        from: line.from,
                        to: line.from + cur.length,
                        insert: norm
                    });
            }
            return changes.length ? [tr, {
                changes,
                sequential: true
            }] : tr;
        });
    }
    const foldService = Facet.define();
    const foldNodeProp = new NodeProp();
    function foldInside(node) {
        let first = node.firstChild,
            last = node.lastChild;
        return first && first.to < last.from ? {
            from: first.to,
            to: last.type.isError ? node.to : last.from
        } : null;
    }
    function syntaxFolding(state, start, end) {
        let tree = syntaxTree(state);
        if (tree.length < end)
            return null;
        let inner = tree.resolveInner(end, 1);
        let found = null;
        for (let cur = inner; cur; cur = cur.parent) {
            if (cur.to <= end || cur.from > end)
                continue;
            if (found && cur.from < start)
                break;
            let prop = cur.type.prop(foldNodeProp);
            if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {
                let value = prop(cur, state);
                if (value && value.from <= end && value.from >= start && value.to > end)
                    found = value;
            }
        }
        return found;
    }
    function isUnfinished(node) {
        let ch = node.lastChild;
        return ch && ch.to == node.to && ch.type.isError;
    }
    function foldable(state, lineStart, lineEnd) {
        for (let _i172 = 0, _state$facet2 = state.facet(foldService), _length172 = _state$facet2.length; _i172 < _length172; _i172++) {
            let service = _state$facet2[_i172];
            let result = service(state, lineStart, lineEnd);
            if (result)
                return result;
        }
        return syntaxFolding(state, lineStart, lineEnd);
    }
    function mapRange(range, mapping) {
        let from = mapping.mapPos(range.from, 1),
            to = mapping.mapPos(range.to, -1);
        return from >= to ? undefined : {
            from,
            to
        };
    }
    const foldEffect = StateEffect.define({
        map: mapRange
    });
    const unfoldEffect = StateEffect.define({
        map: mapRange
    });
    function selectedLines(view) {
        let lines = [];
        for (let _i173 = 0, _view$state$selection2 = view.state.selection.ranges, _length173 = _view$state$selection2.length; _i173 < _length173; _i173++) {
            let {head} = _view$state$selection2[_i173];
            if (lines.some(l => l.from <= head && l.to >= head))
                continue;
            lines.push(view.lineBlockAt(head));
        }
        return lines;
    }
    const foldState = StateField.define({
        create() {
            return Decoration.none;
        },
        update(folded, tr) {
            folded = folded.map(tr.changes);
            for (let _i174 = 0, _tr$effects6 = tr.effects, _length174 = _tr$effects6.length; _i174 < _length174; _i174++) {
                let e = _tr$effects6[_i174];
                if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
                    folded = folded.update({
                        add: [foldWidget.range(e.value.from, e.value.to)]
                    });
                else if (e.is(unfoldEffect))
                    folded = folded.update({
                        filter: (from, to) => e.value.from != from || e.value.to != to,
                        filterFrom: e.value.from,
                        filterTo: e.value.to
                    });
            }
            if (tr.selection) {
                let onSelection = false,
                    {head} = tr.selection.main;
                folded.between(head, head, (a, b) => {
                    if (a < head && b > head)
                        onSelection = true;
                });
                if (onSelection)
                    folded = folded.update({
                        filterFrom: head,
                        filterTo: head,
                        filter: (a, b) => b <= head || a >= head
                    });
            }
            return folded;
        },
        provide: f => EditorView.decorations.from(f),
        toJSON(folded, state) {
            let ranges = [];
            folded.between(0, state.doc.length, (from, to) => {
                ranges.push(from, to);
            });
            return ranges;
        },
        fromJSON(value) {
            if (!Array.isArray(value) || value.length % 2)
                throw new RangeError("Invalid JSON for fold state");
            let ranges = [];
            for (let i = 0; i < value.length;) {
                let from = value[i++],
                    to = value[i++];
                if (typeof from != "number" || typeof to != "number")
                    throw new RangeError("Invalid JSON for fold state");
                ranges.push(foldWidget.range(from, to));
            }
            return Decoration.set(ranges, true);
        }
    });
    function foldedRanges(state) {
        return state.field(foldState, false) || RangeSet.empty;
    }
    function findFold(state, from, to) {
        var _a;
        let found = null;
        (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
            if (!found || found.from > from)
                found = {
                    from,
                    to
                };
        });
        return found;
    }
    function foldExists(folded, from, to) {
        let found = false;
        folded.between(from, from, (a, b) => {
            if (a == from && b == to)
                found = true;
        });
        return found;
    }
    function maybeEnable(state, other) {
        return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
    }
    const foldCode = view => {
        for (let _i175 = 0, _selectedLines = selectedLines(view), _length175 = _selectedLines.length; _i175 < _length175; _i175++) {
            let line = _selectedLines[_i175];
            let range = foldable(view.state, line.from, line.to);
            if (range) {
                view.dispatch({
                    effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])
                });
                return true;
            }
        }
        return false;
    };
    const unfoldCode = view => {
        if (!view.state.field(foldState, false))
            return false;
        let effects = [];
        for (let _i176 = 0, _selectedLines2 = selectedLines(view), _length176 = _selectedLines2.length; _i176 < _length176; _i176++) {
            let line = _selectedLines2[_i176];
            let folded = findFold(view.state, line.from, line.to);
            if (folded)
                effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
        }
        if (effects.length)
            view.dispatch({
                effects
            });
        return effects.length > 0;
    };
    function announceFold(view, range, fold=true) {
        let lineFrom = view.state.doc.lineAt(range.from).number,
            lineTo = view.state.doc.lineAt(range.to).number;
        return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
    }
    const foldAll = view => {
        let {state} = view,
            effects = [];
        for (let pos = 0; pos < state.doc.length;) {
            let line = view.lineBlockAt(pos),
                range = foldable(state, line.from, line.to);
            if (range)
                effects.push(foldEffect.of(range));
            pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
        }
        if (effects.length)
            view.dispatch({
                effects: maybeEnable(view.state, effects)
            });
        return !!effects.length;
    };
    const unfoldAll = view => {
        let field = view.state.field(foldState, false);
        if (!field || !field.size)
            return false;
        let effects = [];
        field.between(0, view.state.doc.length, (from, to) => {
            effects.push(unfoldEffect.of({
                from,
                to
            }));
        });
        view.dispatch({
            effects
        });
        return true;
    };
    const foldKeymap = [{
        key: "Ctrl-Shift-[",
        mac: "Cmd-Alt-[",
        run: foldCode
    }, {
        key: "Ctrl-Shift-]",
        mac: "Cmd-Alt-]",
        run: unfoldCode
    }, {
        key: "Ctrl-Alt-[",
        run: foldAll
    }, {
        key: "Ctrl-Alt-]",
        run: unfoldAll
    }];
    const defaultConfig = {
        placeholderDOM: null,
        placeholderText: "…"
    };
    const foldConfig = Facet.define({
        combine(values) {
            return combineConfig(values, defaultConfig);
        }
    });
    function codeFolding(config) {
        let result = [foldState, baseTheme$1$2];
        if (config)
            result.push(foldConfig.of(config));
        return result;
    }
    const foldWidget = Decoration.replace({
        widget: new class  extends WidgetType{
            toDOM(view)
            {
                let {state} = view,
                    conf = state.facet(foldConfig);
                let onclick = event => {
                    let line = view.lineBlockAt(view.posAtDOM(event.target));
                    let folded = findFold(view.state, line.from, line.to);
                    if (folded)
                        view.dispatch({
                            effects: unfoldEffect.of(folded)
                        });
                    event.preventDefault();
                };
                if (conf.placeholderDOM)
                    return conf.placeholderDOM(view, onclick);
                let element = document.createElement("span");
                element.textContent = conf.placeholderText;
                element.setAttribute("aria-label", state.phrase("folded code"));
                element.title = state.phrase("unfold");
                element.className = "cm-foldPlaceholder";
                element.onclick = onclick;
                return element;
            }
        }
        ()
    });
    const foldGutterDefaults = {
        openText: "⌄",
        closedText: "›",
        markerDOM: null,
        domEventHandlers: {},
        foldingChanged: () => false
    };
    class FoldMarker extends GutterMarker {
        constructor(config, open)
        {
            super();
            this.config = config;
            this.open = open;
        }
        eq(other)
        {
            return this.config == other.config && this.open == other.open;
        }
        toDOM(view)
        {
            if (this.config.markerDOM)
                return this.config.markerDOM(this.open);
            let span = document.createElement("span");
            span.textContent = this.open ? this.config.openText : this.config.closedText;
            span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
            return span;
        }
    }
    function foldGutter(config={}) {
        let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
        let canFold = new FoldMarker(fullConfig, true),
            canUnfold = new FoldMarker(fullConfig, false);
        let markers = ViewPlugin.fromClass(class {
            constructor(view)
            {
                this.from = view.viewport.from;
                this.markers = this.buildMarkers(view);
            }
            update(update)
            {
                if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
                    this.markers = this.buildMarkers(update.view);
            }
            buildMarkers(view)
            {
                let builder = new RangeSetBuilder();
                for (let _i177 = 0, _view$viewportLineBlo = view.viewportLineBlocks, _length177 = _view$viewportLineBlo.length; _i177 < _length177; _i177++) {
                    let line = _view$viewportLineBlo[_i177];
                    let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
                    if (mark)
                        builder.add(line.from, line.from, mark);
                }
                return builder.finish();
            }
        }
        );
        let {domEventHandlers} = fullConfig;
        return [markers, gutter({
            class: "cm-foldGutter",
            markers(view) {
                var _a;
                return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty;
            },
            initialSpacer() {
                return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {
                click: (view, line, event) => {
                    if (domEventHandlers.click && domEventHandlers.click(view, line, event))
                        return true;
                    let folded = findFold(view.state, line.from, line.to);
                    if (folded) {
                        view.dispatch({
                            effects: unfoldEffect.of(folded)
                        });
                        return true;
                    }
                    let range = foldable(view.state, line.from, line.to);
                    if (range) {
                        view.dispatch({
                            effects: foldEffect.of(range)
                        });
                        return true;
                    }
                    return false;
                }
            })
        }), codeFolding()];
    }
    const baseTheme$1$2 = EditorView.baseTheme({
        ".cm-foldPlaceholder": {
            backgroundColor: "#eee",
            border: "1px solid #ddd",
            color: "#888",
            borderRadius: ".2em",
            margin: "0 1px",
            padding: "0 1px",
            cursor: "pointer"
        },
        ".cm-foldGutter span": {
            padding: "0 1px",
            cursor: "pointer"
        }
    });
    class HighlightStyle {
        constructor(specs, options)
        {
            this.specs = specs;
            let modSpec;
            function def(spec) {
                let cls = StyleModule.newName();
                (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
                return cls;
            }
            const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : undefined;
            const scopeOpt = options.scope;
            this.scope = scopeOpt instanceof Language ? type => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? type => type == scopeOpt : undefined;
            this.style = tagHighlighter(specs.map(style => ({
                tag: style.tag,
                class: style.class || def(Object.assign({}, style, {
                    tag: null
                }))
            })), {
                all
            }).style;
            this.module = modSpec ? new StyleModule(modSpec) : null;
            this.themeType = options.themeType;
        }
        static define(specs, options)
        {
            return new HighlightStyle(specs, options || {});
        }
    }
    const highlighterFacet = Facet.define();
    const fallbackHighlighter = Facet.define({
        combine(values) {
            return values.length ? [values[0]] : null;
        }
    });
    function getHighlighters(state) {
        let main = state.facet(highlighterFacet);
        return main.length ? main : state.facet(fallbackHighlighter);
    }
    function syntaxHighlighting(highlighter, options) {
        let ext = [treeHighlighter],
            themeType;
        if (highlighter instanceof HighlightStyle) {
            if (highlighter.module)
                ext.push(EditorView.styleModule.of(highlighter.module));
            themeType = highlighter.themeType;
        }
        if (options === null || options === void 0 ? void 0 : options.fallback)
            ext.push(fallbackHighlighter.of(highlighter));
        else if (themeType)
            ext.push(highlighterFacet.computeN([EditorView.darkTheme], state => {
                return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
            }));
        else
            ext.push(highlighterFacet.of(highlighter));
        return ext;
    }
    function highlightingFor(state, tags, scope) {
        let highlighters = getHighlighters(state);
        let result = null;
        if (highlighters)
            for (let _i178 = 0, _length178 = highlighters.length; _i178 < _length178; _i178++) {
                let highlighter = highlighters[_i178];
                if (!highlighter.scope || scope && highlighter.scope(scope)) {
                    let cls = highlighter.style(tags);
                    if (cls)
                        result = result ? result + " " + cls : cls;
                }
            }
        return result;
    }
    class TreeHighlighter {
        constructor(view)
        {
            this.markCache = Object.create(null);
            this.tree = syntaxTree(view.state);
            this.decorations = this.buildDeco(view, getHighlighters(view.state));
        }
        update(update)
        {
            let tree = syntaxTree(update.state),
                highlighters = getHighlighters(update.state);
            let styleChange = highlighters != getHighlighters(update.startState);
            if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
                this.decorations = this.decorations.map(update.changes);
            } else if (tree != this.tree || update.viewportChanged || styleChange) {
                this.tree = tree;
                this.decorations = this.buildDeco(update.view, highlighters);
            }
        }
        buildDeco(view, highlighters)
        {
            if (!highlighters || !this.tree.length)
                return Decoration.none;
            let builder = new RangeSetBuilder();
            for (let _i179 = 0, _view$visibleRanges3 = view.visibleRanges, _length179 = _view$visibleRanges3.length; _i179 < _length179; _i179++) {
                let {from, to} = _view$visibleRanges3[_i179];
                highlightTree(this.tree, highlighters, (from, to, style) => {
                    builder.add(from, to, this.markCache[style] || (this.markCache[style] = Decoration.mark({
                        class: style
                    })));
                }, from, to);
            }
            return builder.finish();
        }
    }
    const treeHighlighter = Prec.high(ViewPlugin.fromClass(TreeHighlighter, {
        decorations: v => v.decorations
    }));
    const defaultHighlightStyle = HighlightStyle.define([{
        tag: tags$1.meta,
        color: "#404740"
    }, {
        tag: tags$1.link,
        textDecoration: "underline"
    }, {
        tag: tags$1.heading,
        textDecoration: "underline",
        fontWeight: "bold"
    }, {
        tag: tags$1.emphasis,
        fontStyle: "italic"
    }, {
        tag: tags$1.strong,
        fontWeight: "bold"
    }, {
        tag: tags$1.strikethrough,
        textDecoration: "line-through"
    }, {
        tag: tags$1.keyword,
        color: "#708"
    }, {
        tag: [tags$1.atom, tags$1.bool, tags$1.url, tags$1.contentSeparator, tags$1.labelName],
        color: "#219"
    }, {
        tag: [tags$1.literal, tags$1.inserted],
        color: "#164"
    }, {
        tag: [tags$1.string, tags$1.deleted],
        color: "#a11"
    }, {
        tag: [tags$1.regexp, tags$1.escape, tags$1.special(tags$1.string)],
        color: "#e40"
    }, {
        tag: tags$1.definition(tags$1.variableName),
        color: "#00f"
    }, {
        tag: tags$1.local(tags$1.variableName),
        color: "#30a"
    }, {
        tag: [tags$1.typeName, tags$1.namespace],
        color: "#085"
    }, {
        tag: tags$1.className,
        color: "#167"
    }, {
        tag: [tags$1.special(tags$1.variableName), tags$1.macroName],
        color: "#256"
    }, {
        tag: tags$1.definition(tags$1.propertyName),
        color: "#00c"
    }, {
        tag: tags$1.comment,
        color: "#940"
    }, {
        tag: tags$1.invalid,
        color: "#f00"
    }]);
    const baseTheme$4 = EditorView.baseTheme({
        "&.cm-focused .cm-matchingBracket": {
            backgroundColor: "#328c8252"
        },
        "&.cm-focused .cm-nonmatchingBracket": {
            backgroundColor: "#bb555544"
        }
    });
    const DefaultScanDist = 10000,
        DefaultBrackets = "()[]{}";
    const bracketMatchingConfig = Facet.define({
        combine(configs) {
            return combineConfig(configs, {
                afterCursor: true,
                brackets: DefaultBrackets,
                maxScanDistance: DefaultScanDist,
                renderMatch: defaultRenderMatch
            });
        }
    });
    const matchingMark = Decoration.mark({
            class: "cm-matchingBracket"
        }),
        nonmatchingMark = Decoration.mark({
            class: "cm-nonmatchingBracket"
        });
    function defaultRenderMatch(match) {
        let decorations = [];
        let mark = match.matched ? matchingMark : nonmatchingMark;
        decorations.push(mark.range(match.start.from, match.start.to));
        if (match.end)
            decorations.push(mark.range(match.end.from, match.end.to));
        return decorations;
    }
    const bracketMatchingState = StateField.define({
        create() {
            return Decoration.none;
        },
        update(deco, tr) {
            if (!tr.docChanged && !tr.selection)
                return deco;
            let decorations = [];
            let config = tr.state.facet(bracketMatchingConfig);
            for (let _i180 = 0, _tr$state$selection$r = tr.state.selection.ranges, _length180 = _tr$state$selection$r.length; _i180 < _length180; _i180++) {
                let range = _tr$state$selection$r[_i180];
                if (!range.empty)
                    continue;
                let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));
                if (match)
                    decorations = decorations.concat(config.renderMatch(match, tr.state));
            }
            return Decoration.set(decorations, true);
        },
        provide: f => EditorView.decorations.from(f)
    });
    const bracketMatchingUnique = [bracketMatchingState, baseTheme$4];
    function bracketMatching(config={}) {
        return [bracketMatchingConfig.of(config), bracketMatchingUnique];
    }
    const bracketMatchingHandle = new NodeProp();
    function matchingNodes(node, dir, brackets) {
        let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
        if (byProp)
            return byProp;
        if (node.name.length == 1) {
            let index = brackets.indexOf(node.name);
            if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
                return [brackets[index + dir]];
        }
        return null;
    }
    function findHandle(node) {
        let hasHandle = node.type.prop(bracketMatchingHandle);
        return hasHandle ? hasHandle(node.node) : node;
    }
    function matchBrackets(state, pos, dir, config={}) {
        let maxScanDistance = config.maxScanDistance || DefaultScanDist,
            brackets = config.brackets || DefaultBrackets;
        let tree = syntaxTree(state),
            node = tree.resolveInner(pos, dir);
        for (let cur = node; cur; cur = cur.parent) {
            let matches = matchingNodes(cur.type, dir, brackets);
            if (matches && cur.from < cur.to) {
                let handle = findHandle(cur);
                if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
                    return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
            }
        }
        return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
    }
    function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
        let parent = token.parent,
            firstToken = {
                from: handle.from,
                to: handle.to
            };
        let depth = 0,
            cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
        if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
            do {
                if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
                    if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                        let endHandle = findHandle(cursor);
                        return {
                            start: firstToken,
                            end: endHandle ? {
                                from: endHandle.from,
                                to: endHandle.to
                            } : undefined,
                            matched: true
                        };
                    } else if (matchingNodes(cursor.type, dir, brackets)) {
                        depth++;
                    } else if (matchingNodes(cursor.type, -dir, brackets)) {
                        if (depth == 0) {
                            let endHandle = findHandle(cursor);
                            return {
                                start: firstToken,
                                end: endHandle && endHandle.from < endHandle.to ? {
                                    from: endHandle.from,
                                    to: endHandle.to
                                } : undefined,
                                matched: false
                            };
                        }
                        depth--;
                    }
                }
            } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
        return {
            start: firstToken,
            matched: false
        };
    }
    function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
        let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
        let bracket = brackets.indexOf(startCh);
        if (bracket < 0 || bracket % 2 == 0 != dir > 0)
            return null;
        let startToken = {
            from: dir < 0 ? pos - 1 : pos,
            to: dir > 0 ? pos + 1 : pos
        };
        let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),
            depth = 0;
        for (let distance = 0; !iter.next().done && distance <= maxScanDistance;) {
            let text = iter.value;
            if (dir < 0)
                distance += text.length;
            let basePos = pos + distance * dir;
            for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
                let found = brackets.indexOf(text[pos]);
                if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)
                    continue;
                if (found % 2 == 0 == dir > 0) {
                    depth++;
                } else if (depth == 1) {
                    return {
                        start: startToken,
                        end: {
                            from: basePos + pos,
                            to: basePos + pos + 1
                        },
                        matched: found >> 1 == bracket >> 1
                    };
                } else {
                    depth--;
                }
            }
            if (dir > 0)
                distance += text.length;
        }
        return iter.done ? {
            start: startToken,
            matched: false
        } : null;
    }
    function countCol(string, end, tabSize, startIndex=0, startValue=0) {
        if (end == null) {
            end = string.search(/[^\s\u00a0]/);
            if (end == -1)
                end = string.length;
        }
        let n = startValue;
        for (let i = startIndex; i < end; i++) {
            if (string.charCodeAt(i) == 9)
                n += tabSize - n % tabSize;
            else
                n++;
        }
        return n;
    }
    class StringStream {
        constructor(string, tabSize, indentUnit)
        {
            this.string = string;
            this.tabSize = tabSize;
            this.indentUnit = indentUnit;
            this.pos = 0;
            this.start = 0;
            this.lastColumnPos = 0;
            this.lastColumnValue = 0;
        }
        eol()
        {
            return this.pos >= this.string.length;
        }
        sol()
        {
            return this.pos == 0;
        }
        peek()
        {
            return this.string.charAt(this.pos) || undefined;
        }
        next()
        {
            if (this.pos < this.string.length)
                return this.string.charAt(this.pos++);
        }
        eat(match)
        {
            let ch = this.string.charAt(this.pos);
            let ok;
            if (typeof match == "string")
                ok = ch == match;
            else
                ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
            if (ok) {
                ++this.pos;
                return ch;
            }
        }
        eatWhile(match)
        {
            let start = this.pos;
            while (this.eat(match)) {}
            return this.pos > start;
        }
        eatSpace()
        {
            let start = this.pos;
            while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
                ++this.pos;
            return this.pos > start;
        }
        skipToEnd()
        {
            this.pos = this.string.length;
        }
        skipTo(ch)
        {
            let found = this.string.indexOf(ch, this.pos);
            if (found > -1) {
                this.pos = found;
                return true;
            }
        }
        backUp(n)
        {
            this.pos -= n;
        }
        column()
        {
            if (this.lastColumnPos < this.start) {
                this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
                this.lastColumnPos = this.start;
            }
            return this.lastColumnValue;
        }
        indentation()
        {
            return countCol(this.string, null, this.tabSize);
        }
        match(pattern, consume, caseInsensitive)
        {
            if (typeof pattern == "string") {
                let cased = str => caseInsensitive ? str.toLowerCase() : str;
                let substr = this.string.substr(this.pos, pattern.length);
                if (cased(substr) == cased(pattern)) {
                    if (consume !== false)
                        this.pos += pattern.length;
                    return true;
                } else
                    return null;
            } else {
                let match = this.string.slice(this.pos).match(pattern);
                if (match && match.index > 0)
                    return null;
                if (match && consume !== false)
                    this.pos += match[0].length;
                return match;
            }
        }
        current()
        {
            return this.string.slice(this.start, this.pos);
        }
    }
    function fullParser(spec) {
        return {
            name: spec.name || "",
            token: spec.token,
            blankLine: spec.blankLine || (() => {}),
            startState: spec.startState || (() => true),
            copyState: spec.copyState || defaultCopyState,
            indent: spec.indent || (() => null),
            languageData: spec.languageData || {},
            tokenTable: spec.tokenTable || noTokens
        };
    }
    function defaultCopyState(state) {
        if (typeof state != "object")
            return state;
        let newState = {};
        for (let prop in state) {
            let val = state[prop];
            newState[prop] = val instanceof Array ? val.slice() : val;
        }
        return newState;
    }
    class StreamLanguage extends Language {
        constructor(parser)
        {
            let data = defineLanguageFacet(parser.languageData);
            let p = fullParser(parser),
                self;
            let impl = new class  extends Parser{
                createParse(input, fragments, ranges)
                {
                    return new Parse$1(self, input, fragments, ranges);
                }
            }
            ();
            super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser.name);
            this.topNode = docID(data);
            self = this;
            this.streamParser = p;
            this.stateAfter = new NodeProp({
                perNode: true
            });
            this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
        }
        static define(spec)
        {
            return new StreamLanguage(spec);
        }
        getIndent(cx, pos)
        {
            let tree = syntaxTree(cx.state),
                at = tree.resolve(pos);
            while (at && at.type != this.topNode)
                at = at.parent;
            if (!at)
                return null;
            let start = findState(this, tree, 0, at.from, pos),
                statePos,
                state;
            if (start) {
                state = start.state;
                statePos = start.pos + 1;
            } else {
                state = this.streamParser.startState(cx.unit);
                statePos = 0;
            }
            if (pos - statePos > 10000)
                return null;
            while (statePos < pos) {
                let line = cx.state.doc.lineAt(statePos),
                    end = Math.min(pos, line.to);
                if (line.length) {
                    let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);
                    while (stream.pos < end - line.from)
                        readToken$1(this.streamParser.token, stream, state);
                } else {
                    this.streamParser.blankLine(state, cx.unit);
                }
                if (end == pos)
                    break;
                statePos = line.to + 1;
            }
            let {text} = cx.lineAt(pos);
            return this.streamParser.indent(state, /^\s*(.*)/.exec(text)[1], cx);
        }
        get allowsNesting()
        {
            return false;
        }
    }
    function findState(lang, tree, off, startPos, before) {
        let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);
        if (state)
            return {
                state: lang.streamParser.copyState(state),
                pos: off + tree.length
            };
        for (let i = tree.children.length - 1; i >= 0; i--) {
            let child = tree.children[i],
                pos = off + tree.positions[i];
            let found = child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before);
            if (found)
                return found;
        }
        return null;
    }
    function cutTree(lang, tree, from, to, inside) {
        if (inside && from <= 0 && to >= tree.length)
            return tree;
        if (!inside && tree.type == lang.topNode)
            inside = true;
        for (let i = tree.children.length - 1; i >= 0; i--) {
            let pos = tree.positions[i],
                child = tree.children[i],
                inner;
            if (pos < to && child instanceof Tree) {
                if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))
                    break;
                return !inside ? inner : new Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);
            }
        }
        return null;
    }
    function findStartInFragments(lang, fragments, startPos, editorState) {
        for (let _i181 = 0, _length181 = fragments.length; _i181 < _length181; _i181++) {
            let f = fragments[_i181];
            let from = f.from + (f.openStart ? 25 : 0),
                to = f.to - (f.openEnd ? 25 : 0);
            let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to),
                tree;
            if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))
                return {
                    state: found.state,
                    tree
                };
        }
        return {
            state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),
            tree: Tree.empty
        };
    }
    class Parse$1 {
        constructor(lang, input, fragments, ranges)
        {
            this.lang = lang;
            this.input = input;
            this.fragments = fragments;
            this.ranges = ranges;
            this.stoppedAt = null;
            this.chunks = [];
            this.chunkPos = [];
            this.chunk = [];
            this.chunkReused = undefined;
            this.rangeIndex = 0;
            this.to = ranges[ranges.length - 1].to;
            let context = ParseContext.get(),
                from = ranges[0].from;
            let {state, tree} = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);
            this.state = state;
            this.parsedPos = this.chunkStart = from + tree.length;
            for (let i = 0; i < tree.children.length; i++) {
                this.chunks.push(tree.children[i]);
                this.chunkPos.push(tree.positions[i]);
            }
            if (context && this.parsedPos < context.viewport.from - 100000) {
                this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
                context.skipUntilInView(this.parsedPos, context.viewport.from);
                this.parsedPos = context.viewport.from;
            }
            this.moveRangeIndex();
        }
        advance()
        {
            let context = ParseContext.get();
            let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
            let end = Math.min(parseEnd, this.chunkStart + 2048);
            if (context)
                end = Math.min(end, context.viewport.to);
            while (this.parsedPos < end)
                this.parseLine(context);
            if (this.chunkStart < this.parsedPos)
                this.finishChunk();
            if (this.parsedPos >= parseEnd)
                return this.finish();
            if (context && this.parsedPos >= context.viewport.to) {
                context.skipUntilInView(this.parsedPos, parseEnd);
                return this.finish();
            }
            return null;
        }
        stopAt(pos)
        {
            this.stoppedAt = pos;
        }
        lineAfter(pos)
        {
            let chunk = this.input.chunk(pos);
            if (!this.input.lineChunks) {
                let eol = chunk.indexOf("\n");
                if (eol > -1)
                    chunk = chunk.slice(0, eol);
            } else if (chunk == "\n") {
                chunk = "";
            }
            return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
        }
        nextLine()
        {
            let from = this.parsedPos,
                line = this.lineAfter(from),
                end = from + line.length;
            for (let index = this.rangeIndex; ;) {
                let rangeEnd = this.ranges[index].to;
                if (rangeEnd >= end)
                    break;
                line = line.slice(0, rangeEnd - (end - line.length));
                index++;
                if (index == this.ranges.length)
                    break;
                let rangeStart = this.ranges[index].from;
                let after = this.lineAfter(rangeStart);
                line += after;
                end = rangeStart + after.length;
            }
            return {
                line,
                end
            };
        }
        skipGapsTo(pos, offset, side)
        {
            for (;;) {
                let end = this.ranges[this.rangeIndex].to,
                    offPos = pos + offset;
                if (side > 0 ? end > offPos : end >= offPos)
                    break;
                let start = this.ranges[++this.rangeIndex].from;
                offset += start - end;
            }
            return offset;
        }
        moveRangeIndex()
        {
            while (this.ranges[this.rangeIndex].to < this.parsedPos)
                this.rangeIndex++;
        }
        emitToken(id, from, to, size, offset)
        {
            if (this.ranges.length > 1) {
                offset = this.skipGapsTo(from, offset, 1);
                from += offset;
                let len0 = this.chunk.length;
                offset = this.skipGapsTo(to, offset, -1);
                to += offset;
                size += this.chunk.length - len0;
            }
            this.chunk.push(id, from, to, size);
            return offset;
        }
        parseLine(context)
        {
            let {line, end} = this.nextLine(),
                offset = 0,
                {streamParser} = this.lang;
            let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
            if (stream.eol()) {
                streamParser.blankLine(this.state, stream.indentUnit);
            } else {
                while (!stream.eol()) {
                    let token = readToken$1(streamParser.token, stream, this.state);
                    if (token)
                        offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);
                    if (stream.start > 10000)
                        break;
                }
            }
            this.parsedPos = end;
            this.moveRangeIndex();
            if (this.parsedPos < this.to)
                this.parsedPos++;
        }
        finishChunk()
        {
            let tree = Tree.build({
                buffer: this.chunk,
                start: this.chunkStart,
                length: this.parsedPos - this.chunkStart,
                nodeSet,
                topID: 0,
                maxBufferLength: 2048,
                reused: this.chunkReused
            });
            tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
            this.chunks.push(tree);
            this.chunkPos.push(this.chunkStart - this.ranges[0].from);
            this.chunk = [];
            this.chunkReused = undefined;
            this.chunkStart = this.parsedPos;
        }
        finish()
        {
            return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
        }
    }
    function readToken$1(token, stream, state) {
        stream.start = stream.pos;
        for (let i = 0; i < 10; i++) {
            let result = token(stream, state);
            if (stream.pos > stream.start)
                return result;
        }
        throw new Error("Stream parser failed to advance stream.");
    }
    const noTokens = Object.create(null);
    const typeArray = [NodeType.none];
    const nodeSet = new NodeSet(typeArray);
    const warned = [];
    const defaultTable = Object.create(null);
    for (let _i182 = 0, _ref3 = [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]], _length182 = _ref3.length; _i182 < _length182; _i182++) {
        let [legacyName, name] = _ref3[_i182];
        defaultTable[legacyName] = createTokenType(noTokens, name);
    }
    class TokenTable {
        constructor(extra)
        {
            this.extra = extra;
            this.table = Object.assign(Object.create(null), defaultTable);
        }
        resolve(tag)
        {
            return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
        }
    }
    const defaultTokenTable = new TokenTable(noTokens);
    function warnForPart(part, msg) {
        if (warned.indexOf(part) > -1)
            return;
        warned.push(part);
        console.warn(msg);
    }
    function createTokenType(extra, tagStr) {
        let tag = null;
        for (let _i183 = 0, _tagStr$split = tagStr.split("."), _length183 = _tagStr$split.length; _i183 < _length183; _i183++) {
            let part = _tagStr$split[_i183];
            let value = extra[part] || tags$1[part];
            if (!value) {
                warnForPart(part, `Unknown highlighting tag ${part}`);
            } else if (typeof value == "function") {
                if (!tag)
                    warnForPart(part, `Modifier ${part} used at start of tag`);
                else
                    tag = value(tag);
            } else {
                if (tag)
                    warnForPart(part, `Tag ${part} used as modifier`);
                else
                    tag = value;
            }
        }
        if (!tag)
            return 0;
        let name = tagStr.replace(/ /g, "_"),
            type = NodeType.define({
                id: typeArray.length,
                name,
                props: [styleTags({
                    [name]: tag
                })]
            });
        typeArray.push(type);
        return type.id;
    }
    function docID(data) {
        let type = NodeType.define({
            id: typeArray.length,
            name: "Document",
            props: [languageDataProp.add(() => data)]
        });
        typeArray.push(type);
        return type;
    }
    var _m2 = Object.freeze({
        __proto__: null,
        HighlightStyle: HighlightStyle,
        IndentContext: IndentContext,
        LRLanguage: LRLanguage,
        Language: Language,
        LanguageDescription: LanguageDescription,
        LanguageSupport: LanguageSupport,
        ParseContext: ParseContext,
        StreamLanguage: StreamLanguage,
        StringStream: StringStream,
        TreeIndentContext: TreeIndentContext,
        bracketMatching: bracketMatching,
        bracketMatchingHandle: bracketMatchingHandle,
        codeFolding: codeFolding,
        continuedIndent: continuedIndent,
        defaultHighlightStyle: defaultHighlightStyle,
        defineLanguageFacet: defineLanguageFacet,
        delimitedIndent: delimitedIndent,
        ensureSyntaxTree: ensureSyntaxTree,
        flatIndent: flatIndent,
        foldAll: foldAll,
        foldCode: foldCode,
        foldEffect: foldEffect,
        foldGutter: foldGutter,
        foldInside: foldInside,
        foldKeymap: foldKeymap,
        foldNodeProp: foldNodeProp,
        foldService: foldService,
        foldState: foldState,
        foldable: foldable,
        foldedRanges: foldedRanges,
        forceParsing: forceParsing,
        getIndentUnit: getIndentUnit,
        getIndentation: getIndentation,
        highlightingFor: highlightingFor,
        indentNodeProp: indentNodeProp,
        indentOnInput: indentOnInput,
        indentRange: indentRange,
        indentService: indentService,
        indentString: indentString,
        indentUnit: indentUnit,
        language: language,
        languageDataProp: languageDataProp,
        matchBrackets: matchBrackets,
        syntaxHighlighting: syntaxHighlighting,
        syntaxParserRunning: syntaxParserRunning,
        syntaxTree: syntaxTree,
        syntaxTreeAvailable: syntaxTreeAvailable,
        unfoldAll: unfoldAll,
        unfoldCode: unfoldCode,
        unfoldEffect: unfoldEffect
    });
    const toggleComment = target => {
        let config = getConfig(target.state);
        return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
    };
    function command(f, option) {
        return ({state, dispatch}) => {
            if (state.readOnly)
                return false;
            let tr = f(option, state);
            if (!tr)
                return false;
            dispatch(state.update(tr));
            return true;
        };
    }
    const toggleLineComment = command(changeLineComment, 0);
    const lineComment = command(changeLineComment, 1);
    const lineUncomment = command(changeLineComment, 2);
    const toggleBlockComment = command(changeBlockComment, 0);
    const blockComment = command(changeBlockComment, 1);
    const blockUncomment = command(changeBlockComment, 2);
    const toggleBlockCommentByLine = command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
    function getConfig(state, pos=state.selection.main.head) {
        let data = state.languageDataAt("commentTokens", pos);
        return data.length ? data[0] : {};
    }
    const SearchMargin = 50;
    function findBlockComment(state, {open, close}, from, to) {
        let textBefore = state.sliceDoc(from - SearchMargin, from);
        let textAfter = state.sliceDoc(to, to + SearchMargin);
        let spaceBefore = /\s*$/.exec(textBefore)[0].length,
            spaceAfter = /^\s*/.exec(textAfter)[0].length;
        let beforeOff = textBefore.length - spaceBefore;
        if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
            return {
                open: {
                    pos: from - spaceBefore,
                    margin: spaceBefore && 1
                },
                close: {
                    pos: to + spaceAfter,
                    margin: spaceAfter && 1
                }
            };
        }
        let startText,
            endText;
        if (to - from <= 2 * SearchMargin) {
            startText = endText = state.sliceDoc(from, to);
        } else {
            startText = state.sliceDoc(from, from + SearchMargin);
            endText = state.sliceDoc(to - SearchMargin, to);
        }
        let startSpace = /^\s*/.exec(startText)[0].length,
            endSpace = /\s*$/.exec(endText)[0].length;
        let endOff = endText.length - endSpace - close.length;
        if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
            return {
                open: {
                    pos: from + startSpace + open.length,
                    margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
                },
                close: {
                    pos: to - endSpace - close.length,
                    margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
                }
            };
        }
        return null;
    }
    function selectedLineRanges(state) {
        let ranges = [];
        for (let _i184 = 0, _state$selection$rang6 = state.selection.ranges, _length184 = _state$selection$rang6.length; _i184 < _length184; _i184++) {
            let r = _state$selection$rang6[_i184];
            let fromLine = state.doc.lineAt(r.from);
            let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
            let last = ranges.length - 1;
            if (last >= 0 && ranges[last].to > fromLine.from)
                ranges[last].to = toLine.to;
            else
                ranges.push({
                    from: fromLine.from,
                    to: toLine.to
                });
        }
        return ranges;
    }
    function changeBlockComment(option, state, ranges=state.selection.ranges) {
        let tokens = ranges.map(r => getConfig(state, r.from).block);
        if (!tokens.every(c => c))
            return null;
        let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
        if (option != 2 && !comments.every(c => c)) {
            return {
                changes: state.changes(ranges.map((range, i) => {
                    if (comments[i])
                        return [];
                    return [{
                        from: range.from,
                        insert: tokens[i].open + " "
                    }, {
                        from: range.to,
                        insert: " " + tokens[i].close
                    }];
                }))
            };
        } else if (option != 1 && comments.some(c => c)) {
            let changes = [];
            for (let i = 0, comment; i < comments.length; i++)
                if (comment = comments[i]) {
                    let token = tokens[i],
                        {open, close} = comment;
                    changes.push({
                        from: open.pos - token.open.length,
                        to: open.pos + open.margin
                    }, {
                        from: close.pos - close.margin,
                        to: close.pos + token.close.length
                    });
                }
            return {
                changes
            };
        }
        return null;
    }
    function changeLineComment(option, state, ranges=state.selection.ranges) {
        let lines = [];
        let prevLine = -1;
        for (let _i185 = 0, _length185 = ranges.length; _i185 < _length185; _i185++) {
            let {from, to} = ranges[_i185];
            let startI = lines.length,
                minIndent = 1e9;
            for (let pos = from; pos <= to;) {
                let line = state.doc.lineAt(pos);
                if (line.from > prevLine && (from == to || to > line.from)) {
                    prevLine = line.from;
                    let token = getConfig(state, pos).line;
                    if (!token)
                        continue;
                    let indent = /^\s*/.exec(line.text)[0].length;
                    let empty = indent == line.length;
                    let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
                    if (indent < line.text.length && indent < minIndent)
                        minIndent = indent;
                    lines.push({
                        line,
                        comment,
                        token,
                        indent,
                        empty,
                        single: false
                    });
                }
                pos = line.to + 1;
            }
            if (minIndent < 1e9)
                for (let i = startI; i < lines.length; i++)
                    if (lines[i].indent < lines[i].line.text.length)
                        lines[i].indent = minIndent;
            if (lines.length == startI + 1)
                lines[startI].single = true;
        }
        if (option != 2 && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {
            let changes = [];
            for (let _i186 = 0, _length186 = lines.length; _i186 < _length186; _i186++) {
                let {line, token, indent, empty, single} = lines[_i186];
                if (single || !empty)
                    changes.push({
                        from: line.from + indent,
                        insert: token + " "
                    });
            }
            let changeSet = state.changes(changes);
            return {
                changes: changeSet,
                selection: state.selection.map(changeSet, 1)
            };
        } else if (option != 1 && lines.some(l => l.comment >= 0)) {
            let changes = [];
            for (let _i187 = 0, _length187 = lines.length; _i187 < _length187; _i187++) {
                let {line, comment, token} = lines[_i187];
                if (comment >= 0) {
                    let from = line.from + comment,
                        to = from + token.length;
                    if (line.text[to - line.from] == " ")
                        to++;
                    changes.push({
                        from,
                        to
                    });
                }
            }
            return {
                changes
            };
        }
        return null;
    }
    const fromHistory = Annotation.define();
    const isolateHistory = Annotation.define();
    const invertedEffects = Facet.define();
    const historyConfig = Facet.define({
        combine(configs) {
            return combineConfig(configs, {
                minDepth: 100,
                newGroupDelay: 500
            }, {
                minDepth: Math.max,
                newGroupDelay: Math.min
            });
        }
    });
    function changeEnd(changes) {
        let end = 0;
        changes.iterChangedRanges((_, to) => end = to);
        return end;
    }
    const historyField_ = StateField.define({
        create() {
            return HistoryState.empty;
        },
        update(state, tr) {
            let config = tr.state.facet(historyConfig);
            let fromHist = tr.annotation(fromHistory);
            if (fromHist) {
                let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : undefined;
                let item = HistEvent.fromTransaction(tr, selection),
                    from = fromHist.side;
                let other = from == 0 ? state.undone : state.done;
                if (item)
                    other = updateBranch(other, other.length, config.minDepth, item);
                else
                    other = addSelection(other, tr.startState.selection);
                return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
            }
            let isolate = tr.annotation(isolateHistory);
            if (isolate == "full" || isolate == "before")
                state = state.isolate();
            if (tr.annotation(Transaction.addToHistory) === false)
                return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
            let event = HistEvent.fromTransaction(tr);
            let time = tr.annotation(Transaction.time),
                userEvent = tr.annotation(Transaction.userEvent);
            if (event)
                state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);
            else if (tr.selection)
                state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
            if (isolate == "full" || isolate == "after")
                state = state.isolate();
            return state;
        },
        toJSON(value) {
            return {
                done: value.done.map(e => e.toJSON()),
                undone: value.undone.map(e => e.toJSON())
            };
        },
        fromJSON(json) {
            return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
        }
    });
    function history(config={}) {
        return [historyField_, historyConfig.of(config), EditorView.domEventHandlers({
            beforeinput(e, view) {
                let command = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
                if (!command)
                    return false;
                e.preventDefault();
                return command(view);
            }
        })];
    }
    const historyField = historyField_;
    function cmd(side, selection) {
        return function({state, dispatch}) {
            if (!selection && state.readOnly)
                return false;
            let historyState = state.field(historyField_, false);
            if (!historyState)
                return false;
            let tr = historyState.pop(side, state, selection);
            if (!tr)
                return false;
            dispatch(tr);
            return true;
        };
    }
    const undo = cmd(0, false);
    const redo = cmd(1, false);
    const undoSelection = cmd(0, true);
    const redoSelection = cmd(1, true);
    function depth(side) {
        return function(state) {
            let histState = state.field(historyField_, false);
            if (!histState)
                return 0;
            let branch = side == 0 ? histState.done : histState.undone;
            return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
        };
    }
    const undoDepth = depth(0);
    const redoDepth = depth(1);
    class HistEvent {
        constructor(changes, effects, mapped, startSelection, selectionsAfter)
        {
            this.changes = changes;
            this.effects = effects;
            this.mapped = mapped;
            this.startSelection = startSelection;
            this.selectionsAfter = selectionsAfter;
        }
        setSelAfter(after)
        {
            return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
        }
        toJSON()
        {
            var _a,
                _b,
                _c;
            return {
                changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
                mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
                startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
                selectionsAfter: this.selectionsAfter.map(s => s.toJSON())
            };
        }
        static fromJSON(json)
        {
            return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
        }
        static fromTransaction(tr, selection)
        {
            let effects = none$2;
            for (let _i188 = 0, _tr$startState$facet = tr.startState.facet(invertedEffects), _length188 = _tr$startState$facet.length; _i188 < _length188; _i188++) {
                let invert = _tr$startState$facet[_i188];
                let result = invert(tr);
                if (result.length)
                    effects = effects.concat(result);
            }
            if (!effects.length && tr.changes.empty)
                return null;
            return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none$2);
        }
        static selection(selections)
        {
            return new HistEvent(undefined, none$2, undefined, undefined, selections);
        }
    }
    function updateBranch(branch, to, maxLen, newEvent) {
        let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
        let newBranch = branch.slice(start, to);
        newBranch.push(newEvent);
        return newBranch;
    }
    function isAdjacent(a, b) {
        let ranges = [],
            isAdjacent = false;
        a.iterChangedRanges((f, t) => ranges.push(f, t));
        b.iterChangedRanges((_f, _t, f, t) => {
            for (let i = 0; i < ranges.length;) {
                let from = ranges[i++],
                    to = ranges[i++];
                if (t >= from && f <= to)
                    isAdjacent = true;
            }
        });
        return isAdjacent;
    }
    function eqSelectionShape(a, b) {
        return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
    }
    function conc(a, b) {
        return !a.length ? b : !b.length ? a : a.concat(b);
    }
    const none$2 = [];
    const MaxSelectionsPerEvent = 200;
    function addSelection(branch, selection) {
        if (!branch.length) {
            return [HistEvent.selection([selection])];
        } else {
            let lastEvent = branch[branch.length - 1];
            let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
            if (sels.length && sels[sels.length - 1].eq(selection))
                return branch;
            sels.push(selection);
            return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
        }
    }
    function popSelection(branch) {
        let last = branch[branch.length - 1];
        let newBranch = branch.slice();
        newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
        return newBranch;
    }
    function addMappingToBranch(branch, mapping) {
        if (!branch.length)
            return branch;
        let length = branch.length,
            selections = none$2;
        while (length) {
            let event = mapEvent(branch[length - 1], mapping, selections);
            if (event.changes && !event.changes.empty || event.effects.length) {
                let result = branch.slice(0, length);
                result[length - 1] = event;
                return result;
            } else {
                mapping = event.mapped;
                length--;
                selections = event.selectionsAfter;
            }
        }
        return selections.length ? [HistEvent.selection(selections)] : none$2;
    }
    function mapEvent(event, mapping, extraSelections) {
        let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none$2, extraSelections);
        if (!event.changes)
            return HistEvent.selection(selections);
        let mappedChanges = event.changes.map(mapping),
            before = mapping.mapDesc(event.changes, true);
        let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
        return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
    }
    const joinableUserEvent = /^(input\.type|delete)($|\.)/;
    class HistoryState {
        constructor(done, undone, prevTime=0, prevUserEvent=undefined)
        {
            this.done = done;
            this.undone = undone;
            this.prevTime = prevTime;
            this.prevUserEvent = prevUserEvent;
        }
        isolate()
        {
            return this.prevTime ? new HistoryState(this.done, this.undone) : this;
        }
        addChanges(event, time, userEvent, newGroupDelay, maxLen)
        {
            let done = this.done,
                lastEvent = done[done.length - 1];
            if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
                done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none$2));
            } else {
                done = updateBranch(done, done.length, maxLen, event);
            }
            return new HistoryState(done, none$2, time, userEvent);
        }
        addSelection(selection, time, userEvent, newGroupDelay)
        {
            let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none$2;
            if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
                return this;
            return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
        }
        addMapping(mapping)
        {
            return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
        }
        pop(side, state, selection)
        {
            let branch = side == 0 ? this.done : this.undone;
            if (branch.length == 0)
                return null;
            let event = branch[branch.length - 1];
            if (selection && event.selectionsAfter.length) {
                return state.update({
                    selection: event.selectionsAfter[event.selectionsAfter.length - 1],
                    annotations: fromHistory.of({
                        side,
                        rest: popSelection(branch)
                    }),
                    userEvent: side == 0 ? "select.undo" : "select.redo",
                    scrollIntoView: true
                });
            } else if (!event.changes) {
                return null;
            } else {
                let rest = branch.length == 1 ? none$2 : branch.slice(0, branch.length - 1);
                if (event.mapped)
                    rest = addMappingToBranch(rest, event.mapped);
                return state.update({
                    changes: event.changes,
                    selection: event.startSelection,
                    effects: event.effects,
                    annotations: fromHistory.of({
                        side,
                        rest
                    }),
                    filter: false,
                    userEvent: side == 0 ? "undo" : "redo",
                    scrollIntoView: true
                });
            }
        }
    }
    HistoryState.empty = new HistoryState(none$2, none$2);
    const historyKeymap = [{
        key: "Mod-z",
        run: undo,
        preventDefault: true
    }, {
        key: "Mod-y",
        mac: "Mod-Shift-z",
        run: redo,
        preventDefault: true
    }, {
        linux: "Ctrl-Shift-z",
        run: redo,
        preventDefault: true
    }, {
        key: "Mod-u",
        run: undoSelection,
        preventDefault: true
    }, {
        key: "Alt-u",
        mac: "Mod-Shift-u",
        run: redoSelection,
        preventDefault: true
    }];
    function updateSel(sel, by) {
        return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
    }
    function setSel(state, selection) {
        return state.update({
            selection,
            scrollIntoView: true,
            userEvent: "select"
        });
    }
    function moveSel({state, dispatch}, how) {
        let selection = updateSel(state.selection, how);
        if (selection.eq(state.selection))
            return false;
        dispatch(setSel(state, selection));
        return true;
    }
    function rangeEnd(range, forward) {
        return EditorSelection.cursor(forward ? range.to : range.from);
    }
    function cursorByChar(view, forward) {
        return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
    }
    function ltrAtCursor(view) {
        return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
    }
    const cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));
    const cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));
    const cursorCharForward = view => cursorByChar(view, true);
    const cursorCharBackward = view => cursorByChar(view, false);
    function cursorByGroup(view, forward) {
        return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
    }
    const cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));
    const cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));
    const cursorGroupForward = view => cursorByGroup(view, true);
    const cursorGroupBackward = view => cursorByGroup(view, false);
    function moveBySubword(view, range, forward) {
        let categorize = view.state.charCategorizer(range.from);
        return view.moveByChar(range, forward, start => {
            let cat = CharCategory.Space,
                pos = range.from;
            let done = false,
                sawUpper = false,
                sawLower = false;
            let step = next => {
                if (done)
                    return false;
                pos += forward ? next.length : -next.length;
                let nextCat = categorize(next),
                    ahead;
                if (cat == CharCategory.Space)
                    cat = nextCat;
                if (cat != nextCat)
                    return false;
                if (cat == CharCategory.Word) {
                    if (next.toLowerCase() == next) {
                        if (!forward && sawUpper)
                            return false;
                        sawLower = true;
                    } else if (sawLower) {
                        if (forward)
                            return false;
                        done = true;
                    } else {
                        if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word && ahead.toLowerCase() == ahead)
                            return false;
                        sawUpper = true;
                    }
                }
                return true;
            };
            step(start);
            return step;
        });
    }
    function cursorBySubword(view, forward) {
        return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));
    }
    const cursorSubwordForward = view => cursorBySubword(view, true);
    const cursorSubwordBackward = view => cursorBySubword(view, false);
    function interestingNode(state, node, bracketProp) {
        if (node.type.prop(bracketProp))
            return true;
        let len = node.to - node.from;
        return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
    }
    function moveBySyntax(state, start, forward) {
        let pos = syntaxTree(state).resolveInner(start.head);
        let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
        for (let at = start.head; ;) {
            let next = forward ? pos.childAfter(at) : pos.childBefore(at);
            if (!next)
                break;
            if (interestingNode(state, next, bracketProp))
                pos = next;
            else
                at = forward ? next.to : next.from;
        }
        let bracket = pos.type.prop(bracketProp),
            match,
            newPos;
        if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
            newPos = forward ? match.end.to : match.end.from;
        else
            newPos = forward ? pos.to : pos.from;
        return EditorSelection.cursor(newPos, forward ? -1 : 1);
    }
    const cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
    const cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
    function cursorByLine(view, forward) {
        return moveSel(view, range => {
            if (!range.empty)
                return rangeEnd(range, forward);
            let moved = view.moveVertically(range, forward);
            return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
        });
    }
    const cursorLineUp = view => cursorByLine(view, false);
    const cursorLineDown = view => cursorByLine(view, true);
    function pageHeight(view) {
        return Math.max(view.defaultLineHeight, Math.min(view.dom.clientHeight, innerHeight) - 5);
    }
    function cursorByPage(view, forward) {
        let {state} = view,
            selection = updateSel(state.selection, range => {
                return range.empty ? view.moveVertically(range, forward, pageHeight(view)) : rangeEnd(range, forward);
            });
        if (selection.eq(state.selection))
            return false;
        let startPos = view.coordsAtPos(state.selection.main.head);
        let scrollRect = view.scrollDOM.getBoundingClientRect();
        let effect;
        if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)
            effect = EditorView.scrollIntoView(selection.main.head, {
                y: "start",
                yMargin: startPos.top - scrollRect.top
            });
        view.dispatch(setSel(state, selection), {
            effects: effect
        });
        return true;
    }
    const cursorPageUp = view => cursorByPage(view, false);
    const cursorPageDown = view => cursorByPage(view, true);
    function moveByLineBoundary(view, start, forward) {
        let line = view.lineBlockAt(start.head),
            moved = view.moveToLineBoundary(start, forward);
        if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
            moved = view.moveToLineBoundary(start, forward, false);
        if (!forward && moved.head == line.from && line.length) {
            let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
            if (space && start.head != line.from + space)
                moved = EditorSelection.cursor(line.from + space);
        }
        return moved;
    }
    const cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));
    const cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));
    const cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
    const cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
    const cursorLineStart = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
    const cursorLineEnd = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
    function toMatchingBracket(state, dispatch, extend) {
        let found = false,
            selection = updateSel(state.selection, range => {
                let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
                if (!matching || !matching.end)
                    return range;
                found = true;
                let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
                return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
            });
        if (!found)
            return false;
        dispatch(setSel(state, selection));
        return true;
    }
    const cursorMatchingBracket = ({state, dispatch}) => toMatchingBracket(state, dispatch, false);
    const selectMatchingBracket = ({state, dispatch}) => toMatchingBracket(state, dispatch, true);
    function extendSel(view, how) {
        let selection = updateSel(view.state.selection, range => {
            let head = how(range);
            return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);
        });
        if (selection.eq(view.state.selection))
            return false;
        view.dispatch(setSel(view.state, selection));
        return true;
    }
    function selectByChar(view, forward) {
        return extendSel(view, range => view.moveByChar(range, forward));
    }
    const selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));
    const selectCharRight = view => selectByChar(view, ltrAtCursor(view));
    const selectCharForward = view => selectByChar(view, true);
    const selectCharBackward = view => selectByChar(view, false);
    function selectByGroup(view, forward) {
        return extendSel(view, range => view.moveByGroup(range, forward));
    }
    const selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));
    const selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));
    const selectGroupForward = view => selectByGroup(view, true);
    const selectGroupBackward = view => selectByGroup(view, false);
    function selectBySubword(view, forward) {
        return extendSel(view, range => moveBySubword(view, range, forward));
    }
    const selectSubwordForward = view => selectBySubword(view, true);
    const selectSubwordBackward = view => selectBySubword(view, false);
    const selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
    const selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
    function selectByLine(view, forward) {
        return extendSel(view, range => view.moveVertically(range, forward));
    }
    const selectLineUp = view => selectByLine(view, false);
    const selectLineDown = view => selectByLine(view, true);
    function selectByPage(view, forward) {
        return extendSel(view, range => view.moveVertically(range, forward, pageHeight(view)));
    }
    const selectPageUp = view => selectByPage(view, false);
    const selectPageDown = view => selectByPage(view, true);
    const selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));
    const selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));
    const selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
    const selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
    const selectLineStart = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from));
    const selectLineEnd = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to));
    const cursorDocStart = ({state, dispatch}) => {
        dispatch(setSel(state, {
            anchor: 0
        }));
        return true;
    };
    const cursorDocEnd = ({state, dispatch}) => {
        dispatch(setSel(state, {
            anchor: state.doc.length
        }));
        return true;
    };
    const selectDocStart = ({state, dispatch}) => {
        dispatch(setSel(state, {
            anchor: state.selection.main.anchor,
            head: 0
        }));
        return true;
    };
    const selectDocEnd = ({state, dispatch}) => {
        dispatch(setSel(state, {
            anchor: state.selection.main.anchor,
            head: state.doc.length
        }));
        return true;
    };
    const selectAll = ({state, dispatch}) => {
        dispatch(state.update({
            selection: {
                anchor: 0,
                head: state.doc.length
            },
            userEvent: "select"
        }));
        return true;
    };
    const selectLine = ({state, dispatch}) => {
        let ranges = selectedLineBlocks(state).map(({from, to}) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
        dispatch(state.update({
            selection: EditorSelection.create(ranges),
            userEvent: "select"
        }));
        return true;
    };
    const selectParentSyntax = ({state, dispatch}) => {
        let selection = updateSel(state.selection, range => {
            var _a;
            let context = syntaxTree(state).resolveInner(range.head, 1);
            while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))
                context = context.parent;
            return EditorSelection.range(context.to, context.from);
        });
        dispatch(setSel(state, selection));
        return true;
    };
    const simplifySelection = ({state, dispatch}) => {
        let cur = state.selection,
            selection = null;
        if (cur.ranges.length > 1)
            selection = EditorSelection.create([cur.main]);
        else if (!cur.main.empty)
            selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
        if (!selection)
            return false;
        dispatch(setSel(state, selection));
        return true;
    };
    function deleteBy(target, by) {
        if (target.state.readOnly)
            return false;
        let event = "delete.selection",
            {state} = target;
        let changes = state.changeByRange(range => {
            let {from, to} = range;
            if (from == to) {
                let towards = by(from);
                if (towards < from) {
                    event = "delete.backward";
                    towards = skipAtomic(target, towards, false);
                } else if (towards > from) {
                    event = "delete.forward";
                    towards = skipAtomic(target, towards, true);
                }
                from = Math.min(from, towards);
                to = Math.max(to, towards);
            } else {
                from = skipAtomic(target, from, false);
                to = skipAtomic(target, to, true);
            }
            return from == to ? {
                range
            } : {
                changes: {
                    from,
                    to
                },
                range: EditorSelection.cursor(from)
            };
        });
        if (changes.changes.empty)
            return false;
        target.dispatch(state.update(changes, {
            scrollIntoView: true,
            userEvent: event,
            effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : undefined
        }));
        return true;
    }
    function skipAtomic(target, pos, forward) {
        if (target instanceof EditorView)
            for (let _i189 = 0, _target$state$facet$m = target.state.facet(EditorView.atomicRanges).map(f => f(target)), _length189 = _target$state$facet$m.length; _i189 < _length189; _i189++) {
                let ranges = _target$state$facet$m[_i189];
                ranges.between(pos, pos, (from, to) => {
                    if (from < pos && to > pos)
                        pos = forward ? to : from;
                });
            }
        return pos;
    }
    const deleteByChar = (target, forward) => deleteBy(target, pos => {
        let {state} = target,
            line = state.doc.lineAt(pos),
            before,
            targetPos;
        if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
            if (before[before.length - 1] == "\t")
                return pos - 1;
            let col = countColumn(before, state.tabSize),
                drop = col % getIndentUnit(state) || getIndentUnit(state);
            for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
                pos--;
            targetPos = pos;
        } else {
            targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
            if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
                targetPos += forward ? 1 : -1;
        }
        return targetPos;
    });
    const deleteCharBackward = view => deleteByChar(view, false);
    const deleteCharForward = view => deleteByChar(view, true);
    const deleteByGroup = (target, forward) => deleteBy(target, start => {
        let pos = start,
            {state} = target,
            line = state.doc.lineAt(pos);
        let categorize = state.charCategorizer(pos);
        for (let cat = null; ;) {
            if (pos == (forward ? line.to : line.from)) {
                if (pos == start && line.number != (forward ? state.doc.lines : 1))
                    pos += forward ? 1 : -1;
                break;
            }
            let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
            let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
            let nextCat = categorize(nextChar);
            if (cat != null && nextCat != cat)
                break;
            if (nextChar != " " || pos != start)
                cat = nextCat;
            pos = next;
        }
        return pos;
    });
    const deleteGroupBackward = target => deleteByGroup(target, false);
    const deleteGroupForward = target => deleteByGroup(target, true);
    const deleteToLineEnd = view => deleteBy(view, pos => {
        let lineEnd = view.lineBlockAt(pos).to;
        return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);
    });
    const deleteToLineStart = view => deleteBy(view, pos => {
        let lineStart = view.lineBlockAt(pos).from;
        return pos > lineStart ? lineStart : Math.max(0, pos - 1);
    });
    const deleteTrailingWhitespace = ({state, dispatch}) => {
        if (state.readOnly)
            return false;
        let changes = [];
        for (let pos = 0, prev = "", iter = state.doc.iter(); ;) {
            iter.next();
            if (iter.lineBreak || iter.done) {
                let trailing = prev.search(/\s+$/);
                if (trailing > -1)
                    changes.push({
                        from: pos - (prev.length - trailing),
                        to: pos
                    });
                if (iter.done)
                    break;
                prev = "";
            } else {
                prev = iter.value;
            }
            pos += iter.value.length;
        }
        if (!changes.length)
            return false;
        dispatch(state.update({
            changes,
            userEvent: "delete"
        }));
        return true;
    };
    const splitLine = ({state, dispatch}) => {
        if (state.readOnly)
            return false;
        let changes = state.changeByRange(range => {
            return {
                changes: {
                    from: range.from,
                    to: range.to,
                    insert: Text.of(["", ""])
                },
                range: EditorSelection.cursor(range.from)
            };
        });
        dispatch(state.update(changes, {
            scrollIntoView: true,
            userEvent: "input"
        }));
        return true;
    };
    const transposeChars = ({state, dispatch}) => {
        if (state.readOnly)
            return false;
        let changes = state.changeByRange(range => {
            if (!range.empty || range.from == 0 || range.from == state.doc.length)
                return {
                    range
                };
            let pos = range.from,
                line = state.doc.lineAt(pos);
            let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
            let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
            return {
                changes: {
                    from,
                    to,
                    insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))
                },
                range: EditorSelection.cursor(to)
            };
        });
        if (changes.changes.empty)
            return false;
        dispatch(state.update(changes, {
            scrollIntoView: true,
            userEvent: "move.character"
        }));
        return true;
    };
    function selectedLineBlocks(state) {
        let blocks = [],
            upto = -1;
        for (let _i190 = 0, _state$selection$rang7 = state.selection.ranges, _length190 = _state$selection$rang7.length; _i190 < _length190; _i190++) {
            let range = _state$selection$rang7[_i190];
            let startLine = state.doc.lineAt(range.from),
                endLine = state.doc.lineAt(range.to);
            if (!range.empty && range.to == endLine.from)
                endLine = state.doc.lineAt(range.to - 1);
            if (upto >= startLine.number) {
                let prev = blocks[blocks.length - 1];
                prev.to = endLine.to;
                prev.ranges.push(range);
            } else {
                blocks.push({
                    from: startLine.from,
                    to: endLine.to,
                    ranges: [range]
                });
            }
            upto = endLine.number + 1;
        }
        return blocks;
    }
    function moveLine(state, dispatch, forward) {
        if (state.readOnly)
            return false;
        let changes = [],
            ranges = [];
        for (let _i191 = 0, _selectedLineBlocks = selectedLineBlocks(state), _length191 = _selectedLineBlocks.length; _i191 < _length191; _i191++) {
            let block = _selectedLineBlocks[_i191];
            if (forward ? block.to == state.doc.length : block.from == 0)
                continue;
            let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
            let size = nextLine.length + 1;
            if (forward) {
                changes.push({
                    from: block.to,
                    to: nextLine.to
                }, {
                    from: block.from,
                    insert: nextLine.text + state.lineBreak
                });
                for (let _i192 = 0, _block$ranges = block.ranges, _length192 = _block$ranges.length; _i192 < _length192; _i192++) {
                    let r = _block$ranges[_i192];
                    ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
                }
            } else {
                changes.push({
                    from: nextLine.from,
                    to: block.from
                }, {
                    from: block.to,
                    insert: state.lineBreak + nextLine.text
                });
                for (let _i193 = 0, _block$ranges2 = block.ranges, _length193 = _block$ranges2.length; _i193 < _length193; _i193++) {
                    let r = _block$ranges2[_i193];
                    ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
                }
            }
        }
        if (!changes.length)
            return false;
        dispatch(state.update({
            changes,
            scrollIntoView: true,
            selection: EditorSelection.create(ranges, state.selection.mainIndex),
            userEvent: "move.line"
        }));
        return true;
    }
    const moveLineUp = ({state, dispatch}) => moveLine(state, dispatch, false);
    const moveLineDown = ({state, dispatch}) => moveLine(state, dispatch, true);
    function copyLine(state, dispatch, forward) {
        if (state.readOnly)
            return false;
        let changes = [];
        for (let _i194 = 0, _selectedLineBlocks2 = selectedLineBlocks(state), _length194 = _selectedLineBlocks2.length; _i194 < _length194; _i194++) {
            let block = _selectedLineBlocks2[_i194];
            if (forward)
                changes.push({
                    from: block.from,
                    insert: state.doc.slice(block.from, block.to) + state.lineBreak
                });
            else
                changes.push({
                    from: block.to,
                    insert: state.lineBreak + state.doc.slice(block.from, block.to)
                });
        }
        dispatch(state.update({
            changes,
            scrollIntoView: true,
            userEvent: "input.copyline"
        }));
        return true;
    }
    const copyLineUp = ({state, dispatch}) => copyLine(state, dispatch, false);
    const copyLineDown = ({state, dispatch}) => copyLine(state, dispatch, true);
    const deleteLine = view => {
        if (view.state.readOnly)
            return false;
        let {state} = view,
            changes = state.changes(selectedLineBlocks(state).map(({from, to}) => {
                if (from > 0)
                    from--;
                else if (to < state.doc.length)
                    to++;
                return {
                    from,
                    to
                };
            }));
        let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);
        view.dispatch({
            changes,
            selection,
            scrollIntoView: true,
            userEvent: "delete.line"
        });
        return true;
    };
    const insertNewline = ({state, dispatch}) => {
        dispatch(state.update(state.replaceSelection(state.lineBreak), {
            scrollIntoView: true,
            userEvent: "input"
        }));
        return true;
    };
    function isBetweenBrackets(state, pos) {
        if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
            return {
                from: pos,
                to: pos
            };
        let context = syntaxTree(state).resolveInner(pos);
        let before = context.childBefore(pos),
            after = context.childAfter(pos),
            closedBy;
        if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
            return {
                from: before.to,
                to: after.from
            };
        return null;
    }
    const insertNewlineAndIndent = newlineAndIndent(false);
    const insertBlankLine = newlineAndIndent(true);
    function newlineAndIndent(atEof) {
        return ({state, dispatch}) => {
            if (state.readOnly)
                return false;
            let changes = state.changeByRange(range => {
                let {from, to} = range,
                    line = state.doc.lineAt(from);
                let explode = !atEof && from == to && isBetweenBrackets(state, from);
                if (atEof)
                    from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
                let cx = new IndentContext(state, {
                    simulateBreak: from,
                    simulateDoubleBreak: !!explode
                });
                let indent = getIndentation(cx, from);
                if (indent == null)
                    indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
                while (to < line.to && /\s/.test(line.text[to - line.from]))
                    to++;
                if (explode)
                    ({from, to} = explode);
                else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
                    from = line.from;
                let insert = ["", indentString(state, indent)];
                if (explode)
                    insert.push(indentString(state, cx.lineIndent(line.from, -1)));
                return {
                    changes: {
                        from,
                        to,
                        insert: Text.of(insert)
                    },
                    range: EditorSelection.cursor(from + 1 + insert[1].length)
                };
            });
            dispatch(state.update(changes, {
                scrollIntoView: true,
                userEvent: "input"
            }));
            return true;
        };
    }
    function changeBySelectedLine(state, f) {
        let atLine = -1;
        return state.changeByRange(range => {
            let changes = [];
            for (let pos = range.from; pos <= range.to;) {
                let line = state.doc.lineAt(pos);
                if (line.number > atLine && (range.empty || range.to > line.from)) {
                    f(line, changes, range);
                    atLine = line.number;
                }
                pos = line.to + 1;
            }
            let changeSet = state.changes(changes);
            return {
                changes,
                range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
            };
        });
    }
    const indentSelection = ({state, dispatch}) => {
        if (state.readOnly)
            return false;
        let updated = Object.create(null);
        let context = new IndentContext(state, {
            overrideIndentation: start => {
                let found = updated[start];
                return found == null ? -1 : found;
            }
        });
        let changes = changeBySelectedLine(state, (line, changes, range) => {
            let indent = getIndentation(context, line.from);
            if (indent == null)
                return;
            if (!/\S/.test(line.text))
                indent = 0;
            let cur = /^\s*/.exec(line.text)[0];
            let norm = indentString(state, indent);
            if (cur != norm || range.from < line.from + cur.length) {
                updated[line.from] = indent;
                changes.push({
                    from: line.from,
                    to: line.from + cur.length,
                    insert: norm
                });
            }
        });
        if (!changes.changes.empty)
            dispatch(state.update(changes, {
                userEvent: "indent"
            }));
        return true;
    };
    const indentMore = ({state, dispatch}) => {
        if (state.readOnly)
            return false;
        dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
            changes.push({
                from: line.from,
                insert: state.facet(indentUnit)
            });
        }), {
            userEvent: "input.indent"
        }));
        return true;
    };
    const indentLess = ({state, dispatch}) => {
        if (state.readOnly)
            return false;
        dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
            let space = /^\s*/.exec(line.text)[0];
            if (!space)
                return;
            let col = countColumn(space, state.tabSize),
                keep = 0;
            let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));
            while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
                keep++;
            changes.push({
                from: line.from + keep,
                to: line.from + space.length,
                insert: insert.slice(keep)
            });
        }), {
            userEvent: "delete.dedent"
        }));
        return true;
    };
    const insertTab = ({state, dispatch}) => {
        if (state.selection.ranges.some(r => !r.empty))
            return indentMore({
                state,
                dispatch
            });
        dispatch(state.update(state.replaceSelection("\t"), {
            scrollIntoView: true,
            userEvent: "input"
        }));
        return true;
    };
    const emacsStyleKeymap = [{
        key: "Ctrl-b",
        run: cursorCharLeft,
        shift: selectCharLeft,
        preventDefault: true
    }, {
        key: "Ctrl-f",
        run: cursorCharRight,
        shift: selectCharRight
    }, {
        key: "Ctrl-p",
        run: cursorLineUp,
        shift: selectLineUp
    }, {
        key: "Ctrl-n",
        run: cursorLineDown,
        shift: selectLineDown
    }, {
        key: "Ctrl-a",
        run: cursorLineStart,
        shift: selectLineStart
    }, {
        key: "Ctrl-e",
        run: cursorLineEnd,
        shift: selectLineEnd
    }, {
        key: "Ctrl-d",
        run: deleteCharForward
    }, {
        key: "Ctrl-h",
        run: deleteCharBackward
    }, {
        key: "Ctrl-k",
        run: deleteToLineEnd
    }, {
        key: "Ctrl-Alt-h",
        run: deleteGroupBackward
    }, {
        key: "Ctrl-o",
        run: splitLine
    }, {
        key: "Ctrl-t",
        run: transposeChars
    }, {
        key: "Ctrl-v",
        run: cursorPageDown
    }];
    const standardKeymap = [{
        key: "ArrowLeft",
        run: cursorCharLeft,
        shift: selectCharLeft,
        preventDefault: true
    }, {
        key: "Mod-ArrowLeft",
        mac: "Alt-ArrowLeft",
        run: cursorGroupLeft,
        shift: selectGroupLeft,
        preventDefault: true
    }, {
        mac: "Cmd-ArrowLeft",
        run: cursorLineBoundaryLeft,
        shift: selectLineBoundaryLeft,
        preventDefault: true
    }, {
        key: "ArrowRight",
        run: cursorCharRight,
        shift: selectCharRight,
        preventDefault: true
    }, {
        key: "Mod-ArrowRight",
        mac: "Alt-ArrowRight",
        run: cursorGroupRight,
        shift: selectGroupRight,
        preventDefault: true
    }, {
        mac: "Cmd-ArrowRight",
        run: cursorLineBoundaryRight,
        shift: selectLineBoundaryRight,
        preventDefault: true
    }, {
        key: "ArrowUp",
        run: cursorLineUp,
        shift: selectLineUp,
        preventDefault: true
    }, {
        mac: "Cmd-ArrowUp",
        run: cursorDocStart,
        shift: selectDocStart
    }, {
        mac: "Ctrl-ArrowUp",
        run: cursorPageUp,
        shift: selectPageUp
    }, {
        key: "ArrowDown",
        run: cursorLineDown,
        shift: selectLineDown,
        preventDefault: true
    }, {
        mac: "Cmd-ArrowDown",
        run: cursorDocEnd,
        shift: selectDocEnd
    }, {
        mac: "Ctrl-ArrowDown",
        run: cursorPageDown,
        shift: selectPageDown
    }, {
        key: "PageUp",
        run: cursorPageUp,
        shift: selectPageUp
    }, {
        key: "PageDown",
        run: cursorPageDown,
        shift: selectPageDown
    }, {
        key: "Home",
        run: cursorLineBoundaryBackward,
        shift: selectLineBoundaryBackward,
        preventDefault: true
    }, {
        key: "Mod-Home",
        run: cursorDocStart,
        shift: selectDocStart
    }, {
        key: "End",
        run: cursorLineBoundaryForward,
        shift: selectLineBoundaryForward,
        preventDefault: true
    }, {
        key: "Mod-End",
        run: cursorDocEnd,
        shift: selectDocEnd
    }, {
        key: "Enter",
        run: insertNewlineAndIndent
    }, {
        key: "Mod-a",
        run: selectAll
    }, {
        key: "Backspace",
        run: deleteCharBackward,
        shift: deleteCharBackward
    }, {
        key: "Delete",
        run: deleteCharForward
    }, {
        key: "Mod-Backspace",
        mac: "Alt-Backspace",
        run: deleteGroupBackward
    }, {
        key: "Mod-Delete",
        mac: "Alt-Delete",
        run: deleteGroupForward
    }, {
        mac: "Mod-Backspace",
        run: deleteToLineStart
    }, {
        mac: "Mod-Delete",
        run: deleteToLineEnd
    }].concat(emacsStyleKeymap.map(b => ({
        mac: b.key,
        run: b.run,
        shift: b.shift
    })));
    const defaultKeymap = [{
        key: "Alt-ArrowLeft",
        mac: "Ctrl-ArrowLeft",
        run: cursorSyntaxLeft,
        shift: selectSyntaxLeft
    }, {
        key: "Alt-ArrowRight",
        mac: "Ctrl-ArrowRight",
        run: cursorSyntaxRight,
        shift: selectSyntaxRight
    }, {
        key: "Alt-ArrowUp",
        run: moveLineUp
    }, {
        key: "Shift-Alt-ArrowUp",
        run: copyLineUp
    }, {
        key: "Alt-ArrowDown",
        run: moveLineDown
    }, {
        key: "Shift-Alt-ArrowDown",
        run: copyLineDown
    }, {
        key: "Escape",
        run: simplifySelection
    }, {
        key: "Mod-Enter",
        run: insertBlankLine
    }, {
        key: "Alt-l",
        mac: "Ctrl-l",
        run: selectLine
    }, {
        key: "Mod-i",
        run: selectParentSyntax,
        preventDefault: true
    }, {
        key: "Mod-[",
        run: indentLess
    }, {
        key: "Mod-]",
        run: indentMore
    }, {
        key: "Mod-Alt-\\",
        run: indentSelection
    }, {
        key: "Shift-Mod-k",
        run: deleteLine
    }, {
        key: "Shift-Mod-\\",
        run: cursorMatchingBracket
    }, {
        key: "Mod-/",
        run: toggleComment
    }, {
        key: "Alt-A",
        run: toggleBlockComment
    }].concat(standardKeymap);
    const indentWithTab = {
        key: "Tab",
        run: indentMore,
        shift: indentLess
    };
    var _m3 = Object.freeze({
        __proto__: null,
        blockComment: blockComment,
        blockUncomment: blockUncomment,
        copyLineDown: copyLineDown,
        copyLineUp: copyLineUp,
        cursorCharBackward: cursorCharBackward,
        cursorCharForward: cursorCharForward,
        cursorCharLeft: cursorCharLeft,
        cursorCharRight: cursorCharRight,
        cursorDocEnd: cursorDocEnd,
        cursorDocStart: cursorDocStart,
        cursorGroupBackward: cursorGroupBackward,
        cursorGroupForward: cursorGroupForward,
        cursorGroupLeft: cursorGroupLeft,
        cursorGroupRight: cursorGroupRight,
        cursorLineBoundaryBackward: cursorLineBoundaryBackward,
        cursorLineBoundaryForward: cursorLineBoundaryForward,
        cursorLineBoundaryLeft: cursorLineBoundaryLeft,
        cursorLineBoundaryRight: cursorLineBoundaryRight,
        cursorLineDown: cursorLineDown,
        cursorLineEnd: cursorLineEnd,
        cursorLineStart: cursorLineStart,
        cursorLineUp: cursorLineUp,
        cursorMatchingBracket: cursorMatchingBracket,
        cursorPageDown: cursorPageDown,
        cursorPageUp: cursorPageUp,
        cursorSubwordBackward: cursorSubwordBackward,
        cursorSubwordForward: cursorSubwordForward,
        cursorSyntaxLeft: cursorSyntaxLeft,
        cursorSyntaxRight: cursorSyntaxRight,
        defaultKeymap: defaultKeymap,
        deleteCharBackward: deleteCharBackward,
        deleteCharForward: deleteCharForward,
        deleteGroupBackward: deleteGroupBackward,
        deleteGroupForward: deleteGroupForward,
        deleteLine: deleteLine,
        deleteToLineEnd: deleteToLineEnd,
        deleteToLineStart: deleteToLineStart,
        deleteTrailingWhitespace: deleteTrailingWhitespace,
        emacsStyleKeymap: emacsStyleKeymap,
        history: history,
        historyField: historyField,
        historyKeymap: historyKeymap,
        indentLess: indentLess,
        indentMore: indentMore,
        indentSelection: indentSelection,
        indentWithTab: indentWithTab,
        insertBlankLine: insertBlankLine,
        insertNewline: insertNewline,
        insertNewlineAndIndent: insertNewlineAndIndent,
        insertTab: insertTab,
        invertedEffects: invertedEffects,
        isolateHistory: isolateHistory,
        lineComment: lineComment,
        lineUncomment: lineUncomment,
        moveLineDown: moveLineDown,
        moveLineUp: moveLineUp,
        redo: redo,
        redoDepth: redoDepth,
        redoSelection: redoSelection,
        selectAll: selectAll,
        selectCharBackward: selectCharBackward,
        selectCharForward: selectCharForward,
        selectCharLeft: selectCharLeft,
        selectCharRight: selectCharRight,
        selectDocEnd: selectDocEnd,
        selectDocStart: selectDocStart,
        selectGroupBackward: selectGroupBackward,
        selectGroupForward: selectGroupForward,
        selectGroupLeft: selectGroupLeft,
        selectGroupRight: selectGroupRight,
        selectLine: selectLine,
        selectLineBoundaryBackward: selectLineBoundaryBackward,
        selectLineBoundaryForward: selectLineBoundaryForward,
        selectLineBoundaryLeft: selectLineBoundaryLeft,
        selectLineBoundaryRight: selectLineBoundaryRight,
        selectLineDown: selectLineDown,
        selectLineEnd: selectLineEnd,
        selectLineStart: selectLineStart,
        selectLineUp: selectLineUp,
        selectMatchingBracket: selectMatchingBracket,
        selectPageDown: selectPageDown,
        selectPageUp: selectPageUp,
        selectParentSyntax: selectParentSyntax,
        selectSubwordBackward: selectSubwordBackward,
        selectSubwordForward: selectSubwordForward,
        selectSyntaxLeft: selectSyntaxLeft,
        selectSyntaxRight: selectSyntaxRight,
        simplifySelection: simplifySelection,
        splitLine: splitLine,
        standardKeymap: standardKeymap,
        toggleBlockComment: toggleBlockComment,
        toggleBlockCommentByLine: toggleBlockCommentByLine,
        toggleComment: toggleComment,
        toggleLineComment: toggleLineComment,
        transposeChars: transposeChars,
        undo: undo,
        undoDepth: undoDepth,
        undoSelection: undoSelection
    });
    function crelt() {
        var elt = arguments[0];
        if (typeof elt == "string")
            elt = document.createElement(elt);
        var i = 1,
            next = arguments[1];
        if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
            for (var name in next)
                if (Object.prototype.hasOwnProperty.call(next, name)) {
                    var value = next[name];
                    if (typeof value == "string")
                        elt.setAttribute(name, value);
                    else if (value != null)
                        elt[name] = value;
                }
            i++;
        }
        for (; i < arguments.length; i++)
            add(elt, arguments[i]);
        return elt;
    }
    function add(elt, child) {
        if (typeof child == "string") {
            elt.appendChild(document.createTextNode(child));
        } else if (child == null)
            ;
        else if (child.nodeType != null) {
            elt.appendChild(child);
        } else if (Array.isArray(child)) {
            for (var i = 0; i < child.length; i++)
                add(elt, child[i]);
        } else {
            throw new RangeError("Unsupported child node: " + child);
        }
    }
    var _m28 = Object.freeze({
        __proto__: null,
        'default': crelt
    });
    const basicNormalize = typeof String.prototype.normalize == "function" ? x => x.normalize("NFKD") : x => x;
    class SearchCursor {
        constructor(text, query, from=0, to=text.length, normalize, test)
        {
            this.test = test;
            this.value = {
                from: 0,
                to: 0
            };
            this.done = false;
            this.matches = [];
            this.buffer = "";
            this.bufferPos = 0;
            this.iter = text.iterRange(from, to);
            this.bufferStart = from;
            this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;
            this.query = this.normalize(query);
        }
        peek()
        {
            if (this.bufferPos == this.buffer.length) {
                this.bufferStart += this.buffer.length;
                this.iter.next();
                if (this.iter.done)
                    return -1;
                this.bufferPos = 0;
                this.buffer = this.iter.value;
            }
            return codePointAt(this.buffer, this.bufferPos);
        }
        next()
        {
            while (this.matches.length)
                this.matches.pop();
            return this.nextOverlapping();
        }
        nextOverlapping()
        {
            for (;;) {
                let next = this.peek();
                if (next < 0) {
                    this.done = true;
                    return this;
                }
                let str = fromCodePoint(next),
                    start = this.bufferStart + this.bufferPos;
                this.bufferPos += codePointSize(next);
                let norm = this.normalize(str);
                for (let i = 0, pos = start; ; i++) {
                    let code = norm.charCodeAt(i);
                    let match = this.match(code, pos);
                    if (match) {
                        this.value = match;
                        return this;
                    }
                    if (i == norm.length - 1)
                        break;
                    if (pos == start && i < str.length && str.charCodeAt(i) == code)
                        pos++;
                }
            }
        }
        match(code, pos)
        {
            let match = null;
            for (let i = 0; i < this.matches.length; i += 2) {
                let index = this.matches[i],
                    keep = false;
                if (this.query.charCodeAt(index) == code) {
                    if (index == this.query.length - 1) {
                        match = {
                            from: this.matches[i + 1],
                            to: pos + 1
                        };
                    } else {
                        this.matches[i]++;
                        keep = true;
                    }
                }
                if (!keep) {
                    this.matches.splice(i, 2);
                    i -= 2;
                }
            }
            if (this.query.charCodeAt(0) == code) {
                if (this.query.length == 1)
                    match = {
                        from: pos,
                        to: pos + 1
                    };
                else
                    this.matches.push(1, pos);
            }
            if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))
                match = null;
            return match;
        }
    }
    if (typeof Symbol != "undefined")
        SearchCursor.prototype[Symbol.iterator] = function() {
            return this;
        };
    const empty = {
        from: -1,
        to: -1,
        match: /.*/.exec("")
    };
    const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
    class RegExpCursor {
        constructor(text, query, options, from=0, to=text.length)
        {
            this.text = text;
            this.to = to;
            this.curLine = "";
            this.done = false;
            this.value = empty;
            if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
                return new MultilineRegExpCursor(text, query, options, from, to);
            this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
            this.test = options === null || options === void 0 ? void 0 : options.test;
            this.iter = text.iter();
            let startLine = text.lineAt(from);
            this.curLineStart = startLine.from;
            this.matchPos = toCharEnd(text, from);
            this.getLine(this.curLineStart);
        }
        getLine(skip)
        {
            this.iter.next(skip);
            if (this.iter.lineBreak) {
                this.curLine = "";
            } else {
                this.curLine = this.iter.value;
                if (this.curLineStart + this.curLine.length > this.to)
                    this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
                this.iter.next();
            }
        }
        nextLine()
        {
            this.curLineStart = this.curLineStart + this.curLine.length + 1;
            if (this.curLineStart > this.to)
                this.curLine = "";
            else
                this.getLine(0);
        }
        next()
        {
            for (let off = this.matchPos - this.curLineStart; ;) {
                this.re.lastIndex = off;
                let match = this.matchPos <= this.to && this.re.exec(this.curLine);
                if (match) {
                    let from = this.curLineStart + match.index,
                        to = from + match[0].length;
                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                    if (from == this.curLineStart + this.curLine.length)
                        this.nextLine();
                    if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
                        this.value = {
                            from,
                            to,
                            match
                        };
                        return this;
                    }
                    off = this.matchPos - this.curLineStart;
                } else if (this.curLineStart + this.curLine.length < this.to) {
                    this.nextLine();
                    off = 0;
                } else {
                    this.done = true;
                    return this;
                }
            }
        }
    }
    const flattened = new WeakMap();
    class FlattenedDoc {
        constructor(from, text)
        {
            this.from = from;
            this.text = text;
        }
        get to()
        {
            return this.from + this.text.length;
        }
        static get(doc, from, to)
        {
            let cached = flattened.get(doc);
            if (!cached || cached.from >= to || cached.to <= from) {
                let flat = new FlattenedDoc(from, doc.sliceString(from, to));
                flattened.set(doc, flat);
                return flat;
            }
            if (cached.from == from && cached.to == to)
                return cached;
            let {text, from: cachedFrom} = cached;
            if (cachedFrom > from) {
                text = doc.sliceString(from, cachedFrom) + text;
                cachedFrom = from;
            }
            if (cached.to < to)
                text += doc.sliceString(cached.to, to);
            flattened.set(doc, new FlattenedDoc(cachedFrom, text));
            return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
        }
    }
    class MultilineRegExpCursor {
        constructor(text, query, options, from, to)
        {
            this.text = text;
            this.to = to;
            this.done = false;
            this.value = empty;
            this.matchPos = toCharEnd(text, from);
            this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
            this.test = options === null || options === void 0 ? void 0 : options.test;
            this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000));
        }
        chunkEnd(pos)
        {
            return pos >= this.to ? this.to : this.text.lineAt(pos).to;
        }
        next()
        {
            for (;;) {
                let off = this.re.lastIndex = this.matchPos - this.flat.from;
                let match = this.re.exec(this.flat.text);
                if (match && !match[0] && match.index == off) {
                    this.re.lastIndex = off + 1;
                    match = this.re.exec(this.flat.text);
                }
                if (match) {
                    let from = this.flat.from + match.index,
                        to = from + match[0].length;
                    if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
                        this.value = {
                            from,
                            to,
                            match
                        };
                        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                        return this;
                    }
                }
                if (this.flat.to == this.to) {
                    this.done = true;
                    return this;
                }
                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
            }
        }
    }
    if (typeof Symbol != "undefined") {
        RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
            return this;
        };
    }
    function validRegExp(source) {
        try {
            new RegExp(source, baseFlags);
            return true;
        } catch (_a) {
            return false;
        }
    }
    function toCharEnd(text, pos) {
        if (pos >= text.length)
            return pos;
        let line = text.lineAt(pos),
            next;
        while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)
            pos++;
        return pos;
    }
    function createLineDialog(view) {
        let input = crelt("input", {
            class: "cm-textfield",
            name: "line"
        });
        let dom = crelt("form", {
            class: "cm-gotoLine",
            onkeydown: event => {
                if (event.keyCode == 27) {
                    event.preventDefault();
                    view.dispatch({
                        effects: dialogEffect.of(false)
                    });
                    view.focus();
                } else if (event.keyCode == 13) {
                    event.preventDefault();
                    go();
                }
            },
            onsubmit: event => {
                event.preventDefault();
                go();
            }
        }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {
            class: "cm-button",
            type: "submit"
        }, view.state.phrase("go")));
        function go() {
            let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
            if (!match)
                return;
            let {state} = view,
                startLine = state.doc.lineAt(state.selection.main.head);
            let [, sign, ln, cl, percent] = match;
            let col = cl ? +cl.slice(1) : 0;
            let line = ln ? +ln : startLine.number;
            if (ln && percent) {
                let pc = line / 100;
                if (sign)
                    pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
                line = Math.round(state.doc.lines * pc);
            } else if (ln && sign) {
                line = line * (sign == "-" ? -1 : 1) + startLine.number;
            }
            let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
            view.dispatch({
                effects: dialogEffect.of(false),
                selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
                scrollIntoView: true
            });
            view.focus();
        }
        return {
            dom
        };
    }
    const dialogEffect = StateEffect.define();
    const dialogField = StateField.define({
        create() {
            return true;
        },
        update(value, tr) {
            for (let _i195 = 0, _tr$effects7 = tr.effects, _length195 = _tr$effects7.length; _i195 < _length195; _i195++) {
                let e = _tr$effects7[_i195];
                if (e.is(dialogEffect))
                    value = e.value;
            }
            return value;
        },
        provide: f => showPanel.from(f, val => val ? createLineDialog : null)
    });
    const gotoLine = view => {
        let panel = getPanel(view, createLineDialog);
        if (!panel) {
            let effects = [dialogEffect.of(true)];
            if (view.state.field(dialogField, false) == null)
                effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1$1]));
            view.dispatch({
                effects
            });
            panel = getPanel(view, createLineDialog);
        }
        if (panel)
            panel.dom.querySelector("input").focus();
        return true;
    };
    const baseTheme$1$1 = EditorView.baseTheme({
        ".cm-panel.cm-gotoLine": {
            padding: "2px 6px 4px",
            "& label": {
                fontSize: "80%"
            }
        }
    });
    const defaultHighlightOptions = {
        highlightWordAroundCursor: false,
        minSelectionLength: 1,
        maxMatches: 100,
        wholeWords: false
    };
    const highlightConfig = Facet.define({
        combine(options) {
            return combineConfig(options, defaultHighlightOptions, {
                highlightWordAroundCursor: (a, b) => a || b,
                minSelectionLength: Math.min,
                maxMatches: Math.min
            });
        }
    });
    function highlightSelectionMatches(options) {
        let ext = [defaultTheme, matchHighlighter];
        if (options)
            ext.push(highlightConfig.of(options));
        return ext;
    }
    const matchDeco = Decoration.mark({
        class: "cm-selectionMatch"
    });
    const mainMatchDeco = Decoration.mark({
        class: "cm-selectionMatch cm-selectionMatch-main"
    });
    function insideWordBoundaries(check, state, from, to) {
        return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
    }
    function insideWord(check, state, from, to) {
        return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
    }
    const matchHighlighter = ViewPlugin.fromClass(class {
        constructor(view)
        {
            this.decorations = this.getDeco(view);
        }
        update(update)
        {
            if (update.selectionSet || update.docChanged || update.viewportChanged)
                this.decorations = this.getDeco(update.view);
        }
        getDeco(view)
        {
            let conf = view.state.facet(highlightConfig);
            let {state} = view,
                sel = state.selection;
            if (sel.ranges.length > 1)
                return Decoration.none;
            let range = sel.main,
                query,
                check = null;
            if (range.empty) {
                if (!conf.highlightWordAroundCursor)
                    return Decoration.none;
                let word = state.wordAt(range.head);
                if (!word)
                    return Decoration.none;
                check = state.charCategorizer(range.head);
                query = state.sliceDoc(word.from, word.to);
            } else {
                let len = range.to - range.from;
                if (len < conf.minSelectionLength || len > 200)
                    return Decoration.none;
                if (conf.wholeWords) {
                    query = state.sliceDoc(range.from, range.to);
                    check = state.charCategorizer(range.head);
                    if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
                        return Decoration.none;
                } else {
                    query = state.sliceDoc(range.from, range.to).trim();
                    if (!query)
                        return Decoration.none;
                }
            }
            let deco = [];
            for (let _i196 = 0, _view$visibleRanges4 = view.visibleRanges, _length196 = _view$visibleRanges4.length; _i196 < _length196; _i196++) {
                let part = _view$visibleRanges4[_i196];
                let cursor = new SearchCursor(state.doc, query, part.from, part.to);
                while (!cursor.next().done) {
                    let {from, to} = cursor.value;
                    if (!check || insideWordBoundaries(check, state, from, to)) {
                        if (range.empty && from <= range.from && to >= range.to)
                            deco.push(mainMatchDeco.range(from, to));
                        else if (from >= range.to || to <= range.from)
                            deco.push(matchDeco.range(from, to));
                        if (deco.length > conf.maxMatches)
                            return Decoration.none;
                    }
                }
            }
            return Decoration.set(deco);
        }
    }
    , {
        decorations: v => v.decorations
    });
    const defaultTheme = EditorView.baseTheme({
        ".cm-selectionMatch": {
            backgroundColor: "#99ff7780"
        },
        ".cm-searchMatch .cm-selectionMatch": {
            backgroundColor: "transparent"
        }
    });
    const selectWord = ({state, dispatch}) => {
        let {selection} = state;
        let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
        if (newSel.eq(selection))
            return false;
        dispatch(state.update({
            selection: newSel
        }));
        return true;
    };
    function findNextOccurrence(state, query) {
        let {main, ranges} = state.selection;
        let word = state.wordAt(main.head),
            fullWord = word && word.from == main.from && word.to == main.to;
        for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ;) {
            cursor.next();
            if (cursor.done) {
                if (cycled)
                    return null;
                cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
                cycled = true;
            } else {
                if (cycled && ranges.some(r => r.from == cursor.value.from))
                    continue;
                if (fullWord) {
                    let word = state.wordAt(cursor.value.from);
                    if (!word || word.from != cursor.value.from || word.to != cursor.value.to)
                        continue;
                }
                return cursor.value;
            }
        }
    }
    const selectNextOccurrence = ({state, dispatch}) => {
        let {ranges} = state.selection;
        if (ranges.some(sel => sel.from === sel.to))
            return selectWord({
                state,
                dispatch
            });
        let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
        if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))
            return false;
        let range = findNextOccurrence(state, searchedText);
        if (!range)
            return false;
        dispatch(state.update({
            selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
            effects: EditorView.scrollIntoView(range.to)
        }));
        return true;
    };
    const searchConfigFacet = Facet.define({
        combine(configs) {
            return combineConfig(configs, {
                top: false,
                caseSensitive: false,
                literal: false,
                wholeWord: false,
                createPanel: view => new SearchPanel(view)
            });
        }
    });
    function search(config) {
        return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;
    }
    class SearchQuery {
        constructor(config)
        {
            this.search = config.search;
            this.caseSensitive = !!config.caseSensitive;
            this.literal = !!config.literal;
            this.regexp = !!config.regexp;
            this.replace = config.replace || "";
            this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
            this.unquoted = this.unquote(this.search);
            this.wholeWord = !!config.wholeWord;
        }
        unquote(text)
        {
            return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "\t" : "\\");
        }
        eq(other)
        {
            return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
        }
        create()
        {
            return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
        }
        getCursor(state, from=0, to)
        {
            let st = state.doc ? state : EditorState.create({
                doc: state
            });
            if (to == null)
                to = st.doc.length;
            return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
        }
    }
    class QueryType {
        constructor(spec)
        {
            this.spec = spec;
        }
    }
    function stringCursor(spec, state, from, to) {
        return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);
    }
    function stringWordTest(doc, categorizer) {
        return (from, to, buf, bufPos) => {
            if (bufPos > from || bufPos + buf.length < to) {
                bufPos = Math.max(0, from - 2);
                buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));
            }
            return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
        };
    }
    class StringQuery extends QueryType {
        constructor(spec)
        {
            super(spec);
        }
        nextMatch(state, curFrom, curTo)
        {
            let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
            if (cursor.done)
                cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
            return cursor.done ? null : cursor.value;
        }
        prevMatchInRange(state, from, to)
        {
            for (let pos = to; ;) {
                let start = Math.max(from, pos - 10000 - this.spec.unquoted.length);
                let cursor = stringCursor(this.spec, state, start, pos),
                    range = null;
                while (!cursor.nextOverlapping().done)
                    range = cursor.value;
                if (range)
                    return range;
                if (start == from)
                    return null;
                pos -= 10000;
            }
        }
        prevMatch(state, curFrom, curTo)
        {
            return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
        }
        getReplacement(_result)
        {
            return this.spec.unquote(this.spec.replace);
        }
        matchAll(state, limit)
        {
            let cursor = stringCursor(this.spec, state, 0, state.doc.length),
                ranges = [];
            while (!cursor.next().done) {
                if (ranges.length >= limit)
                    return null;
                ranges.push(cursor.value);
            }
            return ranges;
        }
        highlight(state, from, to, add)
        {
            let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
            while (!cursor.next().done)
                add(cursor.value.from, cursor.value.to);
        }
    }
    function regexpCursor(spec, state, from, to) {
        return new RegExpCursor(state.doc, spec.search, {
            ignoreCase: !spec.caseSensitive,
            test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined
        }, from, to);
    }
    function charBefore(str, index) {
        return str.slice(findClusterBreak(str, index, false), index);
    }
    function charAfter(str, index) {
        return str.slice(index, findClusterBreak(str, index));
    }
    function regexpWordTest(categorizer) {
        return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
    }
    class RegExpQuery extends QueryType {
        nextMatch(state, curFrom, curTo)
        {
            let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
            if (cursor.done)
                cursor = regexpCursor(this.spec, state, 0, curFrom).next();
            return cursor.done ? null : cursor.value;
        }
        prevMatchInRange(state, from, to)
        {
            for (let size = 1; ; size++) {
                let start = Math.max(from, to - size * 10000);
                let cursor = regexpCursor(this.spec, state, start, to),
                    range = null;
                while (!cursor.next().done)
                    range = cursor.value;
                if (range && (start == from || range.from > start + 10))
                    return range;
                if (start == from)
                    return null;
            }
        }
        prevMatch(state, curFrom, curTo)
        {
            return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
        }
        getReplacement(result)
        {
            return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m));
        }
        matchAll(state, limit)
        {
            let cursor = regexpCursor(this.spec, state, 0, state.doc.length),
                ranges = [];
            while (!cursor.next().done) {
                if (ranges.length >= limit)
                    return null;
                ranges.push(cursor.value);
            }
            return ranges;
        }
        highlight(state, from, to, add)
        {
            let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250), Math.min(to + 250, state.doc.length));
            while (!cursor.next().done)
                add(cursor.value.from, cursor.value.to);
        }
    }
    const setSearchQuery = StateEffect.define();
    const togglePanel$1 = StateEffect.define();
    const searchState = StateField.define({
        create(state) {
            return new SearchState(defaultQuery(state).create(), null);
        },
        update(value, tr) {
            for (let _i197 = 0, _tr$effects8 = tr.effects, _length197 = _tr$effects8.length; _i197 < _length197; _i197++) {
                let effect = _tr$effects8[_i197];
                if (effect.is(setSearchQuery))
                    value = new SearchState(effect.value.create(), value.panel);
                else if (effect.is(togglePanel$1))
                    value = new SearchState(value.query, effect.value ? createSearchPanel : null);
            }
            return value;
        },
        provide: f => showPanel.from(f, val => val.panel)
    });
    function getSearchQuery(state) {
        let curState = state.field(searchState, false);
        return curState ? curState.query.spec : defaultQuery(state);
    }
    function searchPanelOpen(state) {
        var _a;
        return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;
    }
    class SearchState {
        constructor(query, panel)
        {
            this.query = query;
            this.panel = panel;
        }
    }
    const matchMark = Decoration.mark({
            class: "cm-searchMatch"
        }),
        selectedMatchMark = Decoration.mark({
            class: "cm-searchMatch cm-searchMatch-selected"
        });
    const searchHighlighter = ViewPlugin.fromClass(class {
        constructor(view)
        {
            this.view = view;
            this.decorations = this.highlight(view.state.field(searchState));
        }
        update(update)
        {
            let state = update.state.field(searchState);
            if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
                this.decorations = this.highlight(state);
        }
        highlight({query, panel})
        {
            if (!panel || !query.spec.valid)
                return Decoration.none;
            let {view} = this;
            let builder = new RangeSetBuilder();
            for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
                let {from, to} = ranges[i];
                while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
                    to = ranges[++i].to;
                query.highlight(view.state, from, to, (from, to) => {
                    let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);
                    builder.add(from, to, selected ? selectedMatchMark : matchMark);
                });
            }
            return builder.finish();
        }
    }
    , {
        decorations: v => v.decorations
    });
    function searchCommand(f) {
        return view => {
            let state = view.state.field(searchState, false);
            return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
        };
    }
    const findNext = searchCommand((view, {query}) => {
        let {to} = view.state.selection.main;
        let next = query.nextMatch(view.state, to, to);
        if (!next)
            return false;
        view.dispatch({
            selection: {
                anchor: next.from,
                head: next.to
            },
            scrollIntoView: true,
            effects: announceMatch(view, next),
            userEvent: "select.search"
        });
        return true;
    });
    const findPrevious = searchCommand((view, {query}) => {
        let {state} = view,
            {from} = state.selection.main;
        let range = query.prevMatch(state, from, from);
        if (!range)
            return false;
        view.dispatch({
            selection: {
                anchor: range.from,
                head: range.to
            },
            scrollIntoView: true,
            effects: announceMatch(view, range),
            userEvent: "select.search"
        });
        return true;
    });
    const selectMatches = searchCommand((view, {query}) => {
        let ranges = query.matchAll(view.state, 1000);
        if (!ranges || !ranges.length)
            return false;
        view.dispatch({
            selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),
            userEvent: "select.search.matches"
        });
        return true;
    });
    const selectSelectionMatches = ({state, dispatch}) => {
        let sel = state.selection;
        if (sel.ranges.length > 1 || sel.main.empty)
            return false;
        let {from, to} = sel.main;
        let ranges = [],
            main = 0;
        for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {
            if (ranges.length > 1000)
                return false;
            if (cur.value.from == from)
                main = ranges.length;
            ranges.push(EditorSelection.range(cur.value.from, cur.value.to));
        }
        dispatch(state.update({
            selection: EditorSelection.create(ranges, main),
            userEvent: "select.search.matches"
        }));
        return true;
    };
    const replaceNext = searchCommand((view, {query}) => {
        let {state} = view,
            {from, to} = state.selection.main;
        if (state.readOnly)
            return false;
        let next = query.nextMatch(state, from, from);
        if (!next)
            return false;
        let changes = [],
            selection,
            replacement;
        let announce = [];
        if (next.from == from && next.to == to) {
            replacement = state.toText(query.getReplacement(next));
            changes.push({
                from: next.from,
                to: next.to,
                insert: replacement
            });
            next = query.nextMatch(state, next.from, next.to);
            announce.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
        }
        if (next) {
            let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
            selection = {
                anchor: next.from - off,
                head: next.to - off
            };
            announce.push(announceMatch(view, next));
        }
        view.dispatch({
            changes,
            selection,
            scrollIntoView: !!selection,
            effects: announce,
            userEvent: "input.replace"
        });
        return true;
    });
    const replaceAll = searchCommand((view, {query}) => {
        if (view.state.readOnly)
            return false;
        let changes = query.matchAll(view.state, 1e9).map(match => {
            let {from, to} = match;
            return {
                from,
                to,
                insert: query.getReplacement(match)
            };
        });
        if (!changes.length)
            return false;
        let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
        view.dispatch({
            changes,
            effects: EditorView.announce.of(announceText),
            userEvent: "input.replace.all"
        });
        return true;
    });
    function createSearchPanel(view) {
        return view.state.facet(searchConfigFacet).createPanel(view);
    }
    function defaultQuery(state, fallback) {
        var _a,
            _b,
            _c,
            _d;
        let sel = state.selection.main;
        let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
        if (fallback && !selText)
            return fallback;
        let config = state.facet(searchConfigFacet);
        return new SearchQuery({
            search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
            caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
            literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,
            wholeWord: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _d !== void 0 ? _d : config.wholeWord
        });
    }
    const openSearchPanel = view => {
        let state = view.state.field(searchState, false);
        if (state && state.panel) {
            let panel = getPanel(view, createSearchPanel);
            if (!panel)
                return false;
            let searchInput = panel.dom.querySelector("[main-field]");
            if (searchInput && searchInput != view.root.activeElement) {
                let query = defaultQuery(view.state, state.query.spec);
                if (query.valid)
                    view.dispatch({
                        effects: setSearchQuery.of(query)
                    });
                searchInput.focus();
                searchInput.select();
            }
        } else {
            view.dispatch({
                effects: [togglePanel$1.of(true), state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)]
            });
        }
        return true;
    };
    const closeSearchPanel = view => {
        let state = view.state.field(searchState, false);
        if (!state || !state.panel)
            return false;
        let panel = getPanel(view, createSearchPanel);
        if (panel && panel.dom.contains(view.root.activeElement))
            view.focus();
        view.dispatch({
            effects: togglePanel$1.of(false)
        });
        return true;
    };
    const searchKeymap = [{
        key: "Mod-f",
        run: openSearchPanel,
        scope: "editor search-panel"
    }, {
        key: "F3",
        run: findNext,
        shift: findPrevious,
        scope: "editor search-panel",
        preventDefault: true
    }, {
        key: "Mod-g",
        run: findNext,
        shift: findPrevious,
        scope: "editor search-panel",
        preventDefault: true
    }, {
        key: "Escape",
        run: closeSearchPanel,
        scope: "editor search-panel"
    }, {
        key: "Mod-Shift-l",
        run: selectSelectionMatches
    }, {
        key: "Alt-g",
        run: gotoLine
    }, {
        key: "Mod-d",
        run: selectNextOccurrence,
        preventDefault: true
    }];
    class SearchPanel {
        constructor(view)
        {
            this.view = view;
            let query = this.query = view.state.field(searchState).query.spec;
            this.commit = this.commit.bind(this);
            this.searchField = crelt("input", {
                value: query.search,
                placeholder: phrase(view, "Find"),
                "aria-label": phrase(view, "Find"),
                class: "cm-textfield",
                name: "search",
                form: "",
                "main-field": "true",
                onchange: this.commit,
                onkeyup: this.commit
            });
            this.replaceField = crelt("input", {
                value: query.replace,
                placeholder: phrase(view, "Replace"),
                "aria-label": phrase(view, "Replace"),
                class: "cm-textfield",
                name: "replace",
                form: "",
                onchange: this.commit,
                onkeyup: this.commit
            });
            this.caseField = crelt("input", {
                type: "checkbox",
                name: "case",
                form: "",
                checked: query.caseSensitive,
                onchange: this.commit
            });
            this.reField = crelt("input", {
                type: "checkbox",
                name: "re",
                form: "",
                checked: query.regexp,
                onchange: this.commit
            });
            this.wordField = crelt("input", {
                type: "checkbox",
                name: "word",
                form: "",
                checked: query.wholeWord,
                onchange: this.commit
            });
            function button(name, onclick, content) {
                return crelt("button", {
                    class: "cm-button",
                    name,
                    onclick,
                    type: "button"
                }, content);
            }
            this.dom = crelt("div", {
                onkeydown: e => this.keydown(e),
                class: "cm-search"
            }, [this.searchField, button("next", () => findNext(view), [phrase(view, "next")]), button("prev", () => findPrevious(view), [phrase(view, "previous")]), button("select", () => selectMatches(view), [phrase(view, "all")]), crelt("label", null, [this.caseField, phrase(view, "match case")]), crelt("label", null, [this.reField, phrase(view, "regexp")]), crelt("label", null, [this.wordField, phrase(view, "by word")]), ...(view.state.readOnly ? [] : [crelt("br"), this.replaceField, button("replace", () => replaceNext(view), [phrase(view, "replace")]), button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])]), crelt("button", {
                name: "close",
                onclick: () => closeSearchPanel(view),
                "aria-label": phrase(view, "close"),
                type: "button"
            }, ["×"])]);
        }
        commit()
        {
            let query = new SearchQuery({
                search: this.searchField.value,
                caseSensitive: this.caseField.checked,
                regexp: this.reField.checked,
                wholeWord: this.wordField.checked,
                replace: this.replaceField.value
            });
            if (!query.eq(this.query)) {
                this.query = query;
                this.view.dispatch({
                    effects: setSearchQuery.of(query)
                });
            }
        }
        keydown(e)
        {
            if (runScopeHandlers(this.view, e, "search-panel")) {
                e.preventDefault();
            } else if (e.keyCode == 13 && e.target == this.searchField) {
                e.preventDefault();
                (e.shiftKey ? findPrevious : findNext)(this.view);
            } else if (e.keyCode == 13 && e.target == this.replaceField) {
                e.preventDefault();
                replaceNext(this.view);
            }
        }
        update(update)
        {
            for (let _i198 = 0, _update$transactions = update.transactions, _length198 = _update$transactions.length; _i198 < _length198; _i198++) {
                let tr = _update$transactions[_i198];
                for (let _i199 = 0, _tr$effects9 = tr.effects, _length199 = _tr$effects9.length; _i199 < _length199; _i199++) {
                    let effect = _tr$effects9[_i199];
                    if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
                        this.setQuery(effect.value);
                }
            }
        }
        setQuery(query)
        {
            this.query = query;
            this.searchField.value = query.search;
            this.replaceField.value = query.replace;
            this.caseField.checked = query.caseSensitive;
            this.reField.checked = query.regexp;
            this.wordField.checked = query.wholeWord;
        }
        mount()
        {
            this.searchField.select();
        }
        get pos()
        {
            return 80;
        }
        get top()
        {
            return this.view.state.facet(searchConfigFacet).top;
        }
    }
    function phrase(view, phrase) {
        return view.state.phrase(phrase);
    }
    const AnnounceMargin = 30;
    const Break = /[\s\.,:;?!]/;
    function announceMatch(view, {from, to}) {
        let line = view.state.doc.lineAt(from),
            lineEnd = view.state.doc.lineAt(to).to;
        let start = Math.max(line.from, from - AnnounceMargin),
            end = Math.min(lineEnd, to + AnnounceMargin);
        let text = view.state.sliceDoc(start, end);
        if (start != line.from) {
            for (let i = 0; i < AnnounceMargin; i++)
                if (!Break.test(text[i + 1]) && Break.test(text[i])) {
                    text = text.slice(i);
                    break;
                }
        }
        if (end != lineEnd) {
            for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
                if (!Break.test(text[i - 1]) && Break.test(text[i])) {
                    text = text.slice(0, i);
                    break;
                }
        }
        return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
    }
    const baseTheme$3 = EditorView.baseTheme({
        ".cm-panel.cm-search": {
            padding: "2px 6px 4px",
            position: "relative",
            "& [name=close]": {
                position: "absolute",
                top: "0",
                right: "4px",
                backgroundColor: "inherit",
                border: "none",
                font: "inherit",
                padding: 0,
                margin: 0
            },
            "& input, & button, & label": {
                margin: ".2em .6em .2em 0"
            },
            "& input[type=checkbox]": {
                marginRight: ".2em"
            },
            "& label": {
                fontSize: "80%",
                whiteSpace: "pre"
            }
        },
        "&light .cm-searchMatch": {
            backgroundColor: "#ffff0054"
        },
        "&dark .cm-searchMatch": {
            backgroundColor: "#00ffff8a"
        },
        "&light .cm-searchMatch-selected": {
            backgroundColor: "#ff6a0054"
        },
        "&dark .cm-searchMatch-selected": {
            backgroundColor: "#ff00ff8a"
        }
    });
    const searchExtensions = [searchState, Prec.lowest(searchHighlighter), baseTheme$3];
    var _m4 = Object.freeze({
        __proto__: null,
        RegExpCursor: RegExpCursor,
        SearchCursor: SearchCursor,
        SearchQuery: SearchQuery,
        closeSearchPanel: closeSearchPanel,
        findNext: findNext,
        findPrevious: findPrevious,
        getSearchQuery: getSearchQuery,
        gotoLine: gotoLine,
        highlightSelectionMatches: highlightSelectionMatches,
        openSearchPanel: openSearchPanel,
        replaceAll: replaceAll,
        replaceNext: replaceNext,
        search: search,
        searchKeymap: searchKeymap,
        searchPanelOpen: searchPanelOpen,
        selectMatches: selectMatches,
        selectNextOccurrence: selectNextOccurrence,
        selectSelectionMatches: selectSelectionMatches,
        setSearchQuery: setSearchQuery
    });
    class CompletionContext {
        constructor(state, pos, explicit)
        {
            this.state = state;
            this.pos = pos;
            this.explicit = explicit;
            this.abortListeners = [];
        }
        tokenBefore(types)
        {
            let token = syntaxTree(this.state).resolveInner(this.pos, -1);
            while (token && types.indexOf(token.name) < 0)
                token = token.parent;
            return token ? {
                from: token.from,
                to: this.pos,
                text: this.state.sliceDoc(token.from, this.pos),
                type: token.type
            } : null;
        }
        matchBefore(expr)
        {
            let line = this.state.doc.lineAt(this.pos);
            let start = Math.max(line.from, this.pos - 250);
            let str = line.text.slice(start - line.from, this.pos - line.from);
            let found = str.search(ensureAnchor(expr, false));
            return found < 0 ? null : {
                from: start + found,
                to: this.pos,
                text: str.slice(found)
            };
        }
        get aborted()
        {
            return this.abortListeners == null;
        }
        addEventListener(type, listener)
        {
            if (type == "abort" && this.abortListeners)
                this.abortListeners.push(listener);
        }
    }
    function toSet(chars) {
        let flat = Object.keys(chars).join("");
        let words = /\w/.test(flat);
        if (words)
            flat = flat.replace(/\w/g, "");
        return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
    }
    function prefixMatch(options) {
        let first = Object.create(null),
            rest = Object.create(null);
        for (let _i200 = 0, _length200 = options.length; _i200 < _length200; _i200++) {
            let {label} = options[_i200];
            first[label[0]] = true;
            for (let i = 1; i < label.length; i++)
                rest[label[i]] = true;
        }
        let source = toSet(first) + toSet(rest) + "*$";
        return [new RegExp("^" + source), new RegExp(source)];
    }
    function completeFromList(list) {
        let options = list.map(o => typeof o == "string" ? {
            label: o
        } : o);
        let [validFor, match] = options.every(o => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
        return context => {
            let token = context.matchBefore(match);
            return token || context.explicit ? {
                from: token ? token.from : context.pos,
                options,
                validFor
            } : null;
        };
    }
    function ifIn(nodes, source) {
        return context => {
            for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)
                if (nodes.indexOf(pos.name) > -1)
                    return source(context);
            return null;
        };
    }
    function ifNotIn(nodes, source) {
        return context => {
            for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)
                if (nodes.indexOf(pos.name) > -1)
                    return null;
            return source(context);
        };
    }
    class Option {
        constructor(completion, source, match)
        {
            this.completion = completion;
            this.source = source;
            this.match = match;
        }
    }
    function cur(state) {
        return state.selection.main.head;
    }
    function ensureAnchor(expr, start) {
        var _a;
        let {source} = expr;
        let addStart = start && source[0] != "^",
            addEnd = source[source.length - 1] != "$";
        if (!addStart && !addEnd)
            return expr;
        return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? "i" : "");
    }
    const pickedCompletion = Annotation.define();
    function insertCompletionText(state, text, from, to) {
        return Object.assign(Object.assign({}, state.changeByRange(range => {
            if (range == state.selection.main)
                return {
                    changes: {
                        from: from,
                        to: to,
                        insert: text
                    },
                    range: EditorSelection.cursor(from + text.length)
                };
            let len = to - from;
            if (!range.empty || len && state.sliceDoc(range.from - len, range.from) != state.sliceDoc(from, to))
                return {
                    range
                };
            return {
                changes: {
                    from: range.from - len,
                    to: range.from,
                    insert: text
                },
                range: EditorSelection.cursor(range.from - len + text.length)
            };
        })), {
            userEvent: "input.complete"
        });
    }
    function applyCompletion(view, option) {
        const apply = option.completion.apply || option.completion.label;
        let result = option.source;
        if (typeof apply == "string")
            view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {
                annotations: pickedCompletion.of(option.completion)
            }));
        else
            apply(view, option.completion, result.from, result.to);
    }
    const SourceCache = new WeakMap();
    function asSource(source) {
        if (!Array.isArray(source))
            return source;
        let known = SourceCache.get(source);
        if (!known)
            SourceCache.set(source, known = completeFromList(source));
        return known;
    }
    class FuzzyMatcher {
        constructor(pattern)
        {
            this.pattern = pattern;
            this.chars = [];
            this.folded = [];
            this.any = [];
            this.precise = [];
            this.byWord = [];
            for (let p = 0; p < pattern.length;) {
                let char = codePointAt(pattern, p),
                    size = codePointSize(char);
                this.chars.push(char);
                let part = pattern.slice(p, p + size),
                    upper = part.toUpperCase();
                this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
                p += size;
            }
            this.astral = pattern.length != this.chars.length;
        }
        match(word)
        {
            if (this.pattern.length == 0)
                return [0];
            if (word.length < this.pattern.length)
                return null;
            let {chars, folded, any, precise, byWord} = this;
            if (chars.length == 1) {
                let first = codePointAt(word, 0);
                return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200, 0, codePointSize(first)] : null;
            }
            let direct = word.indexOf(this.pattern);
            if (direct == 0)
                return [0, 0, this.pattern.length];
            let len = chars.length,
                anyTo = 0;
            if (direct < 0) {
                for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {
                    let next = codePointAt(word, i);
                    if (next == chars[anyTo] || next == folded[anyTo])
                        any[anyTo++] = i;
                    i += codePointSize(next);
                }
                if (anyTo < len)
                    return null;
            }
            let preciseTo = 0;
            let byWordTo = 0,
                byWordFolded = false;
            let adjacentTo = 0,
                adjacentStart = -1,
                adjacentEnd = -1;
            let hasLower = /[a-z]/.test(word),
                wordAdjacent = true;
            for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len;) {
                let next = codePointAt(word, i);
                if (direct < 0) {
                    if (preciseTo < len && next == chars[preciseTo])
                        precise[preciseTo++] = i;
                    if (adjacentTo < len) {
                        if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                            if (adjacentTo == 0)
                                adjacentStart = i;
                            adjacentEnd = i + 1;
                            adjacentTo++;
                        } else {
                            adjacentTo = 0;
                        }
                    }
                }
                let ch,
                    type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
                if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
                    if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
                        byWord[byWordTo++] = i;
                    else if (byWord.length)
                        wordAdjacent = false;
                }
                prevType = type;
                i += codePointSize(next);
            }
            if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
                return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
            if (adjacentTo == len && adjacentStart == 0)
                return [-200 - word.length, 0, adjacentEnd];
            if (direct > -1)
                return [-700 - word.length, direct, direct + this.pattern.length];
            if (adjacentTo == len)
                return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
            if (byWordTo == len)
                return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
            return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
        }
        result(score, positions, word)
        {
            let result = [score - word.length],
                i = 1;
            for (let _i201 = 0, _length201 = positions.length; _i201 < _length201; _i201++) {
                let pos = positions[_i201];
                let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
                if (i > 1 && result[i - 1] == pos)
                    result[i - 1] = to;
                else {
                    result[i++] = pos;
                    result[i++] = to;
                }
            }
            return result;
        }
    }
    const completionConfig = Facet.define({
        combine(configs) {
            return combineConfig(configs, {
                activateOnTyping: true,
                selectOnOpen: true,
                override: null,
                closeOnBlur: true,
                maxRenderedOptions: 100,
                defaultKeymap: true,
                tooltipClass: () => "",
                optionClass: () => "",
                aboveCursor: false,
                icons: true,
                addToOptions: [],
                compareCompletions: (a, b) => a.label.localeCompare(b.label),
                interactionDelay: 75
            }, {
                defaultKeymap: (a, b) => a && b,
                closeOnBlur: (a, b) => a && b,
                icons: (a, b) => a && b,
                tooltipClass: (a, b) => c => joinClass(a(c), b(c)),
                optionClass: (a, b) => c => joinClass(a(c), b(c)),
                addToOptions: (a, b) => a.concat(b)
            });
        }
    });
    function joinClass(a, b) {
        return a ? b ? a + " " + b : a : b;
    }
    function optionContent(config) {
        let content = config.addToOptions.slice();
        if (config.icons)
            content.push({
                render(completion) {
                    let icon = document.createElement("div");
                    icon.classList.add("cm-completionIcon");
                    if (completion.type)
                        icon.classList.add(...completion.type.split(/\s+/g).map(cls => "cm-completionIcon-" + cls));
                    icon.setAttribute("aria-hidden", "true");
                    return icon;
                },
                position: 20
            });
        content.push({
            render(completion, _s, match) {
                let labelElt = document.createElement("span");
                labelElt.className = "cm-completionLabel";
                let {label} = completion,
                    off = 0;
                for (let j = 1; j < match.length;) {
                    let from = match[j++],
                        to = match[j++];
                    if (from > off)
                        labelElt.appendChild(document.createTextNode(label.slice(off, from)));
                    let span = labelElt.appendChild(document.createElement("span"));
                    span.appendChild(document.createTextNode(label.slice(from, to)));
                    span.className = "cm-completionMatchedText";
                    off = to;
                }
                if (off < label.length)
                    labelElt.appendChild(document.createTextNode(label.slice(off)));
                return labelElt;
            },
            position: 50
        }, {
            render(completion) {
                if (!completion.detail)
                    return null;
                let detailElt = document.createElement("span");
                detailElt.className = "cm-completionDetail";
                detailElt.textContent = completion.detail;
                return detailElt;
            },
            position: 80
        });
        return content.sort((a, b) => a.position - b.position).map(a => a.render);
    }
    function rangeAroundSelected(total, selected, max) {
        if (total <= max)
            return {
                from: 0,
                to: total
            };
        if (selected < 0)
            selected = 0;
        if (selected <= total >> 1) {
            let off = Math.floor(selected / max);
            return {
                from: off * max,
                to: (off + 1) * max
            };
        }
        let off = Math.floor((total - selected) / max);
        return {
            from: total - (off + 1) * max,
            to: total - off * max
        };
    }
    class CompletionTooltip {
        constructor(view, stateField)
        {
            this.view = view;
            this.stateField = stateField;
            this.info = null;
            this.placeInfo = {
                read: () => this.measureInfo(),
                write: pos => this.positionInfo(pos),
                key: this
            };
            this.space = null;
            this.currentClass = "";
            let cState = view.state.field(stateField);
            let {options, selected} = cState.open;
            let config = view.state.facet(completionConfig);
            this.optionContent = optionContent(config);
            this.optionClass = config.optionClass;
            this.tooltipClass = config.tooltipClass;
            this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);
            this.dom = document.createElement("div");
            this.dom.className = "cm-tooltip-autocomplete";
            this.updateTooltipClass(view.state);
            this.dom.addEventListener("mousedown", e => {
                for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
                    if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
                        applyCompletion(view, options[+match[1]]);
                        e.preventDefault();
                        return;
                    }
                }
            });
            this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
            this.list.addEventListener("scroll", () => {
                if (this.info)
                    this.view.requestMeasure(this.placeInfo);
            });
        }
        mount()
        {
            this.updateSel();
        }
        update(update)
        {
            var _a,
                _b,
                _c;
            let cState = update.state.field(this.stateField);
            let prevState = update.startState.field(this.stateField);
            this.updateTooltipClass(update.state);
            if (cState != prevState) {
                this.updateSel();
                if (((_a = cState.open) === null || _a === void 0 ? void 0 : _a.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled))
                    this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));
            }
        }
        updateTooltipClass(state)
        {
            let cls = this.tooltipClass(state);
            if (cls != this.currentClass) {
                for (let _i202 = 0, _this$currentClass$sp = this.currentClass.split(" "), _length202 = _this$currentClass$sp.length; _i202 < _length202; _i202++) {
                    let c = _this$currentClass$sp[_i202];
                    if (c)
                        this.dom.classList.remove(c);
                }
                for (let _i203 = 0, _cls$split = cls.split(" "), _length203 = _cls$split.length; _i203 < _length203; _i203++) {
                    let c = _cls$split[_i203];
                    if (c)
                        this.dom.classList.add(c);
                }
                this.currentClass = cls;
            }
        }
        positioned(space)
        {
            this.space = space;
            if (this.info)
                this.view.requestMeasure(this.placeInfo);
        }
        updateSel()
        {
            let cState = this.view.state.field(this.stateField),
                open = cState.open;
            if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
                this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
                this.list.remove();
                this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
                this.list.addEventListener("scroll", () => {
                    if (this.info)
                        this.view.requestMeasure(this.placeInfo);
                });
            }
            if (this.updateSelectedOption(open.selected)) {
                if (this.info) {
                    this.info.remove();
                    this.info = null;
                }
                let {completion} = open.options[open.selected];
                let {info} = completion;
                if (!info)
                    return;
                let infoResult = typeof info === 'string' ? document.createTextNode(info) : info(completion);
                if (!infoResult)
                    return;
                if ('then' in infoResult) {
                    infoResult.then(node => {
                        if (node && this.view.state.field(this.stateField, false) == cState)
                            this.addInfoPane(node);
                    }).catch(e => logException(this.view.state, e, "completion info"));
                } else {
                    this.addInfoPane(infoResult);
                }
            }
        }
        addInfoPane(content)
        {
            let dom = this.info = document.createElement("div");
            dom.className = "cm-tooltip cm-completionInfo";
            dom.appendChild(content);
            this.dom.appendChild(dom);
            this.view.requestMeasure(this.placeInfo);
        }
        updateSelectedOption(selected)
        {
            let set = null;
            for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
                if (i == selected) {
                    if (!opt.hasAttribute("aria-selected")) {
                        opt.setAttribute("aria-selected", "true");
                        set = opt;
                    }
                } else {
                    if (opt.hasAttribute("aria-selected"))
                        opt.removeAttribute("aria-selected");
                }
            }
            if (set)
                scrollIntoView(this.list, set);
            return set;
        }
        measureInfo()
        {
            let sel = this.dom.querySelector("[aria-selected]");
            if (!sel || !this.info)
                return null;
            let listRect = this.dom.getBoundingClientRect();
            let infoRect = this.info.getBoundingClientRect();
            let selRect = sel.getBoundingClientRect();
            let space = this.space;
            if (!space) {
                let win = this.dom.ownerDocument.defaultView || window;
                space = {
                    left: 0,
                    top: 0,
                    right: win.innerWidth,
                    bottom: win.innerHeight
                };
            }
            if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10)
                return null;
            let rtl = this.view.textDirection == Direction.RTL,
                left = rtl,
                narrow = false,
                maxWidth;
            let top = "",
                bottom = "";
            let spaceLeft = listRect.left - space.left,
                spaceRight = space.right - listRect.right;
            if (left && spaceLeft < Math.min(infoRect.width, spaceRight))
                left = false;
            else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))
                left = true;
            if (infoRect.width <= (left ? spaceLeft : spaceRight)) {
                top = Math.max(space.top, Math.min(selRect.top, space.bottom - infoRect.height)) - listRect.top + "px";
                maxWidth = Math.min(400, left ? spaceLeft : spaceRight) + "px";
            } else {
                narrow = true;
                maxWidth = Math.min(400, (rtl ? listRect.right : space.right - listRect.left) - 30) + "px";
                let spaceBelow = space.bottom - listRect.bottom;
                if (spaceBelow >= infoRect.height || spaceBelow > listRect.top)
                    top = selRect.bottom - listRect.top + "px";
                else
                    bottom = listRect.bottom - selRect.top + "px";
            }
            return {
                top,
                bottom,
                maxWidth,
                class: narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right"
            };
        }
        positionInfo(pos)
        {
            if (this.info) {
                if (pos) {
                    this.info.style.top = pos.top;
                    this.info.style.bottom = pos.bottom;
                    this.info.style.maxWidth = pos.maxWidth;
                    this.info.className = "cm-tooltip cm-completionInfo cm-completionInfo-" + pos.class;
                } else {
                    this.info.style.top = "-1e6px";
                }
            }
        }
        createListBox(options, id, range)
        {
            const ul = document.createElement("ul");
            ul.id = id;
            ul.setAttribute("role", "listbox");
            ul.setAttribute("aria-expanded", "true");
            ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
            for (let i = range.from; i < range.to; i++) {
                let {completion, match} = options[i];
                const li = ul.appendChild(document.createElement("li"));
                li.id = id + "-" + i;
                li.setAttribute("role", "option");
                let cls = this.optionClass(completion);
                if (cls)
                    li.className = cls;
                for (let _i204 = 0, _this$optionContent = this.optionContent, _length204 = _this$optionContent.length; _i204 < _length204; _i204++) {
                    let source = _this$optionContent[_i204];
                    let node = source(completion, this.view.state, match);
                    if (node)
                        li.appendChild(node);
                }
            }
            if (range.from)
                ul.classList.add("cm-completionListIncompleteTop");
            if (range.to < options.length)
                ul.classList.add("cm-completionListIncompleteBottom");
            return ul;
        }
    }
    function completionTooltip(stateField) {
        return view => new CompletionTooltip(view, stateField);
    }
    function scrollIntoView(container, element) {
        let parent = container.getBoundingClientRect();
        let self = element.getBoundingClientRect();
        if (self.top < parent.top)
            container.scrollTop -= parent.top - self.top;
        else if (self.bottom > parent.bottom)
            container.scrollTop += self.bottom - parent.bottom;
    }
    function score(option) {
        return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
    }
    function sortOptions(active, state) {
        let options = [],
            i = 0;
        for (let _i205 = 0, _length205 = active.length; _i205 < _length205; _i205++) {
            let a = active[_i205];
            if (a.hasResult()) {
                if (a.result.filter === false) {
                    let getMatch = a.result.getMatch;
                    for (let _i206 = 0, _a$result$options = a.result.options, _length206 = _a$result$options.length; _i206 < _length206; _i206++) {
                        let option = _a$result$options[_i206];
                        let match = [1e9 - i++];
                        if (getMatch)
                            for (let _i207 = 0, _getMatch = getMatch(option), _length207 = _getMatch.length; _i207 < _length207; _i207++) {
                                let n = _getMatch[_i207];
                                match.push(n);
                            }
                        options.push(new Option(option, a, match));
                    }
                } else {
                    let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)),
                        match;
                    for (let _i208 = 0, _a$result$options2 = a.result.options, _length208 = _a$result$options2.length; _i208 < _length208; _i208++) {
                        let option = _a$result$options2[_i208];
                        if (match = matcher.match(option.label)) {
                            if (option.boost != null)
                                match[0] += option.boost;
                            options.push(new Option(option, a, match));
                        }
                    }
                }
            }
        }
        let result = [],
            prev = null;
        let compare = state.facet(completionConfig).compareCompletions;
        for (let _i209 = 0, _options$sort = options.sort((a, b) => b.match[0] - a.match[0] || compare(a.completion, b.completion)), _length209 = _options$sort.length; _i209 < _length209; _i209++) {
            let opt = _options$sort[_i209];
            if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply)
                result.push(opt);
            else if (score(opt.completion) > score(prev))
                result[result.length - 1] = opt;
            prev = opt.completion;
        }
        return result;
    }
    class CompletionDialog {
        constructor(options, attrs, tooltip, timestamp, selected, disabled)
        {
            this.options = options;
            this.attrs = attrs;
            this.tooltip = tooltip;
            this.timestamp = timestamp;
            this.selected = selected;
            this.disabled = disabled;
        }
        setSelected(selected, id)
        {
            return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
        }
        static build(active, state, id, prev, conf)
        {
            let options = sortOptions(active, state);
            if (!options.length) {
                return prev && active.some(a => a.state == 1) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;
            }
            let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
            if (prev && prev.selected != selected && prev.selected != -1) {
                let selectedValue = prev.options[prev.selected].completion;
                for (let i = 0; i < options.length; i++)
                    if (options[i].completion == selectedValue) {
                        selected = i;
                        break;
                    }
            }
            return new CompletionDialog(options, makeAttrs(id, selected), {
                pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
                create: completionTooltip(completionState),
                above: conf.aboveCursor
            }, prev ? prev.timestamp : Date.now(), selected, false);
        }
        map(changes)
        {
            return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {
                pos: changes.mapPos(this.tooltip.pos)
            }), this.timestamp, this.selected, this.disabled);
        }
    }
    class CompletionState {
        constructor(active, id, open)
        {
            this.active = active;
            this.id = id;
            this.open = open;
        }
        static start()
        {
            return new CompletionState(none$1, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
        }
        update(tr)
        {
            let {state} = tr,
                conf = state.facet(completionConfig);
            let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
            let active = sources.map(source => {
                let value = this.active.find(s => s.source == source) || new ActiveSource(source, this.active.some(a => a.state != 0) ? 1 : 0);
                return value.update(tr, conf);
            });
            if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
                active = this.active;
            let open = this.open;
            if (open && tr.docChanged)
                open = open.map(tr.changes);
            if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active))
                open = CompletionDialog.build(active, state, this.id, open, conf);
            else if (open && open.disabled && !active.some(a => a.state == 1))
                open = null;
            if (!open && active.every(a => a.state != 1) && active.some(a => a.hasResult()))
                active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0) : a);
            for (let _i210 = 0, _tr$effects10 = tr.effects, _length210 = _tr$effects10.length; _i210 < _length210; _i210++) {
                let effect = _tr$effects10[_i210];
                if (effect.is(setSelectedEffect))
                    open = open && open.setSelected(effect.value, this.id);
            }
            return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
        }
        get tooltip()
        {
            return this.open ? this.open.tooltip : null;
        }
        get attrs()
        {
            return this.open ? this.open.attrs : baseAttrs;
        }
    }
    function sameResults(a, b) {
        if (a == b)
            return true;
        for (let iA = 0, iB = 0; ;) {
            while (iA < a.length && !a[iA].hasResult)
                iA++;
            while (iB < b.length && !b[iB].hasResult)
                iB++;
            let endA = iA == a.length,
                endB = iB == b.length;
            if (endA || endB)
                return endA == endB;
            if (a[iA++].result != b[iB++].result)
                return false;
        }
    }
    const baseAttrs = {
        "aria-autocomplete": "list"
    };
    function makeAttrs(id, selected) {
        let result = {
            "aria-autocomplete": "list",
            "aria-haspopup": "listbox",
            "aria-controls": id
        };
        if (selected > -1)
            result["aria-activedescendant"] = id + "-" + selected;
        return result;
    }
    const none$1 = [];
    function getUserEvent(tr) {
        return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
    }
    class ActiveSource {
        constructor(source, state, explicitPos=-1)
        {
            this.source = source;
            this.state = state;
            this.explicitPos = explicitPos;
        }
        hasResult()
        {
            return false;
        }
        update(tr, conf)
        {
            let event = getUserEvent(tr),
                value = this;
            if (event)
                value = value.handleUserEvent(tr, event, conf);
            else if (tr.docChanged)
                value = value.handleChange(tr);
            else if (tr.selection && value.state != 0)
                value = new ActiveSource(value.source, 0);
            for (let _i211 = 0, _tr$effects11 = tr.effects, _length211 = _tr$effects11.length; _i211 < _length211; _i211++) {
                let effect = _tr$effects11[_i211];
                if (effect.is(startCompletionEffect))
                    value = new ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
                else if (effect.is(closeCompletionEffect))
                    value = new ActiveSource(value.source, 0);
                else if (effect.is(setActiveEffect))
                    for (let _i212 = 0, _effect$value = effect.value, _length212 = _effect$value.length; _i212 < _length212; _i212++) {
                        let active = _effect$value[_i212];
                        if (active.source == value.source)
                            value = active;
                    }
            }
            return value;
        }
        handleUserEvent(tr, type, conf)
        {
            return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1);
        }
        handleChange(tr)
        {
            return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
        }
        map(changes)
        {
            return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
        }
    }
    class ActiveResult extends ActiveSource {
        constructor(source, explicitPos, result, from, to)
        {
            super(source, 2, explicitPos);
            this.result = result;
            this.from = from;
            this.to = to;
        }
        hasResult()
        {
            return true;
        }
        handleUserEvent(tr, type, conf)
        {
            var _a;
            let from = tr.changes.mapPos(this.from),
                to = tr.changes.mapPos(this.to, 1);
            let pos = cur(tr.state);
            if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from)
                return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 : 0);
            let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos),
                updated;
            if (checkValid(this.result.validFor, tr.state, from, to))
                return new ActiveResult(this.source, explicitPos, this.result, from, to);
            if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
                return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));
            return new ActiveSource(this.source, 1, explicitPos);
        }
        handleChange(tr)
        {
            return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
        }
        map(mapping)
        {
            return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
        }
    }
    function checkValid(validFor, state, from, to) {
        if (!validFor)
            return false;
        let text = state.sliceDoc(from, to);
        return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
    }
    const startCompletionEffect = StateEffect.define();
    const closeCompletionEffect = StateEffect.define();
    const setActiveEffect = StateEffect.define({
        map(sources, mapping) {
            return sources.map(s => s.map(mapping));
        }
    });
    const setSelectedEffect = StateEffect.define();
    const completionState = StateField.define({
        create() {
            return CompletionState.start();
        },
        update(value, tr) {
            return value.update(tr);
        },
        provide: f => [showTooltip.from(f, val => val.tooltip), EditorView.contentAttributes.from(f, state => state.attrs)]
    });
    function moveCompletionSelection(forward, by="option") {
        return view => {
            let cState = view.state.field(completionState, false);
            if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
                return false;
            let step = 1,
                tooltip;
            if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
                step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
            let {length} = cState.open.options;
            let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
            if (selected < 0)
                selected = by == "page" ? 0 : length - 1;
            else if (selected >= length)
                selected = by == "page" ? length - 1 : 0;
            view.dispatch({
                effects: setSelectedEffect.of(selected)
            });
            return true;
        };
    }
    const acceptCompletion = view => {
        let cState = view.state.field(completionState, false);
        if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
            return false;
        if (!cState.open.disabled)
            applyCompletion(view, cState.open.options[cState.open.selected]);
        return true;
    };
    const startCompletion = view => {
        let cState = view.state.field(completionState, false);
        if (!cState)
            return false;
        view.dispatch({
            effects: startCompletionEffect.of(true)
        });
        return true;
    };
    const closeCompletion = view => {
        let cState = view.state.field(completionState, false);
        if (!cState || !cState.active.some(a => a.state != 0))
            return false;
        view.dispatch({
            effects: closeCompletionEffect.of(null)
        });
        return true;
    };
    class RunningQuery {
        constructor(active, context)
        {
            this.active = active;
            this.context = context;
            this.time = Date.now();
            this.updates = [];
            this.done = undefined;
        }
    }
    const DebounceTime = 50,
        MaxUpdateCount = 50,
        MinAbortTime = 1000;
    const completionPlugin = ViewPlugin.fromClass(class {
        constructor(view)
        {
            this.view = view;
            this.debounceUpdate = -1;
            this.running = [];
            this.debounceAccept = -1;
            this.composing = 0;
            for (let _i213 = 0, _view$state$field$act = view.state.field(completionState).active, _length213 = _view$state$field$act.length; _i213 < _length213; _i213++) {
                let active = _view$state$field$act[_i213];
                if (active.state == 1)
                    this.startQuery(active);
            }
        }
        update(update)
        {
            let cState = update.state.field(completionState);
            if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
                return;
            let doesReset = update.transactions.some(tr => {
                return (tr.selection || tr.docChanged) && !getUserEvent(tr);
            });
            for (let i = 0; i < this.running.length; i++) {
                let query = this.running[i];
                if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
                    for (let _i214 = 0, _query$context$abortL = query.context.abortListeners, _length214 = _query$context$abortL.length; _i214 < _length214; _i214++) {
                        let handler = _query$context$abortL[_i214];
                        try {
                            handler();
                        } catch (e) {
                            logException(this.view.state, e);
                        }
                    }
                    query.context.abortListeners = null;
                    this.running.splice(i--, 1);
                } else {
                    query.updates.push(...update.transactions);
                }
            }
            if (this.debounceUpdate > -1)
                clearTimeout(this.debounceUpdate);
            this.debounceUpdate = cState.active.some(a => a.state == 1 && !this.running.some(q => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
            if (this.composing != 0)
                for (let _i215 = 0, _update$transactions2 = update.transactions, _length215 = _update$transactions2.length; _i215 < _length215; _i215++) {
                    let tr = _update$transactions2[_i215];
                    if (getUserEvent(tr) == "input")
                        this.composing = 2;
                    else if (this.composing == 2 && tr.selection)
                        this.composing = 3;
                }
        }
        startUpdate()
        {
            this.debounceUpdate = -1;
            let {state} = this.view,
                cState = state.field(completionState);
            for (let _i216 = 0, _cState$active = cState.active, _length216 = _cState$active.length; _i216 < _length216; _i216++) {
                let active = _cState$active[_i216];
                if (active.state == 1 && !this.running.some(r => r.active.source == active.source))
                    this.startQuery(active);
            }
        }
        startQuery(active)
        {
            let {state} = this.view,
                pos = cur(state);
            let context = new CompletionContext(state, pos, active.explicitPos == pos);
            let pending = new RunningQuery(active, context);
            this.running.push(pending);
            Promise.resolve(active.source(context)).then(result => {
                if (!pending.context.aborted) {
                    pending.done = result || null;
                    this.scheduleAccept();
                }
            }, err => {
                this.view.dispatch({
                    effects: closeCompletionEffect.of(null)
                });
                logException(this.view.state, err);
            });
        }
        scheduleAccept()
        {
            if (this.running.every(q => q.done !== undefined))
                this.accept();
            else if (this.debounceAccept < 0)
                this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
        }
        accept()
        {
            var _a;
            if (this.debounceAccept > -1)
                clearTimeout(this.debounceAccept);
            this.debounceAccept = -1;
            let updated = [];
            let conf = this.view.state.facet(completionConfig);
            for (let i = 0; i < this.running.length; i++) {
                let query = this.running[i];
                if (query.done === undefined)
                    continue;
                this.running.splice(i--, 1);
                if (query.done) {
                    let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));
                    for (let _i217 = 0, _query$updates = query.updates, _length217 = _query$updates.length; _i217 < _length217; _i217++) {
                        let tr = _query$updates[_i217];
                        active = active.update(tr, conf);
                    }
                    if (active.hasResult()) {
                        updated.push(active);
                        continue;
                    }
                }
                let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);
                if (current && current.state == 1) {
                    if (query.done == null) {
                        let active = new ActiveSource(query.active.source, 0);
                        for (let _i218 = 0, _query$updates2 = query.updates, _length218 = _query$updates2.length; _i218 < _length218; _i218++) {
                            let tr = _query$updates2[_i218];
                            active = active.update(tr, conf);
                        }
                        if (active.state != 1)
                            updated.push(active);
                    } else {
                        this.startQuery(current);
                    }
                }
            }
            if (updated.length)
                this.view.dispatch({
                    effects: setActiveEffect.of(updated)
                });
        }
    }
    , {
        eventHandlers: {
            blur() {
                let state = this.view.state.field(completionState, false);
                if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur)
                    this.view.dispatch({
                        effects: closeCompletionEffect.of(null)
                    });
            },
            compositionstart() {
                this.composing = 1;
            },
            compositionend() {
                if (this.composing == 3) {
                    setTimeout(() => this.view.dispatch({
                        effects: startCompletionEffect.of(false)
                    }), 20);
                }
                this.composing = 0;
            }
        }
    });
    const baseTheme$2 = EditorView.baseTheme({
        ".cm-tooltip.cm-tooltip-autocomplete": {
            "& > ul": {
                fontFamily: "monospace",
                whiteSpace: "nowrap",
                overflow: "hidden auto",
                maxWidth_fallback: "700px",
                maxWidth: "min(700px, 95vw)",
                minWidth: "250px",
                maxHeight: "10em",
                height: "100%",
                listStyle: "none",
                margin: 0,
                padding: 0,
                "& > li": {
                    overflowX: "hidden",
                    textOverflow: "ellipsis",
                    cursor: "pointer",
                    padding: "1px 3px",
                    lineHeight: 1.2
                }
            }
        },
        "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
            background: "#17c",
            color: "white"
        },
        "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
            background: "#777"
        },
        "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
            background: "#347",
            color: "white"
        },
        "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
            background: "#444"
        },
        ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
            content: '"···"',
            opacity: 0.5,
            display: "block",
            textAlign: "center"
        },
        ".cm-tooltip.cm-completionInfo": {
            position: "absolute",
            padding: "3px 9px",
            width: "max-content",
            maxWidth: `${400}px`,
            boxSizing: "border-box"
        },
        ".cm-completionInfo.cm-completionInfo-left": {
            right: "100%"
        },
        ".cm-completionInfo.cm-completionInfo-right": {
            left: "100%"
        },
        ".cm-completionInfo.cm-completionInfo-left-narrow": {
            right: `${30}px`
        },
        ".cm-completionInfo.cm-completionInfo-right-narrow": {
            left: `${30}px`
        },
        "&light .cm-snippetField": {
            backgroundColor: "#00000022"
        },
        "&dark .cm-snippetField": {
            backgroundColor: "#ffffff22"
        },
        ".cm-snippetFieldPosition": {
            verticalAlign: "text-top",
            width: 0,
            height: "1.15em",
            display: "inline-block",
            margin: "0 -0.7px -.7em",
            borderLeft: "1.4px dotted #888"
        },
        ".cm-completionMatchedText": {
            textDecoration: "underline"
        },
        ".cm-completionDetail": {
            marginLeft: "0.5em",
            fontStyle: "italic"
        },
        ".cm-completionIcon": {
            fontSize: "90%",
            width: ".8em",
            display: "inline-block",
            textAlign: "center",
            paddingRight: ".6em",
            opacity: "0.6",
            boxSizing: "content-box"
        },
        ".cm-completionIcon-function, .cm-completionIcon-method": {
            "&:after": {
                content: "'ƒ'"
            }
        },
        ".cm-completionIcon-class": {
            "&:after": {
                content: "'○'"
            }
        },
        ".cm-completionIcon-interface": {
            "&:after": {
                content: "'◌'"
            }
        },
        ".cm-completionIcon-variable": {
            "&:after": {
                content: "'𝑥'"
            }
        },
        ".cm-completionIcon-constant": {
            "&:after": {
                content: "'𝐶'"
            }
        },
        ".cm-completionIcon-type": {
            "&:after": {
                content: "'𝑡'"
            }
        },
        ".cm-completionIcon-enum": {
            "&:after": {
                content: "'∪'"
            }
        },
        ".cm-completionIcon-property": {
            "&:after": {
                content: "'□'"
            }
        },
        ".cm-completionIcon-keyword": {
            "&:after": {
                content: "'🔑\uFE0E'"
            }
        },
        ".cm-completionIcon-namespace": {
            "&:after": {
                content: "'▢'"
            }
        },
        ".cm-completionIcon-text": {
            "&:after": {
                content: "'abc'",
                fontSize: "50%",
                verticalAlign: "middle"
            }
        }
    });
    class FieldPos {
        constructor(field, line, from, to)
        {
            this.field = field;
            this.line = line;
            this.from = from;
            this.to = to;
        }
    }
    class FieldRange {
        constructor(field, from, to)
        {
            this.field = field;
            this.from = from;
            this.to = to;
        }
        map(changes)
        {
            let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
            let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
            return from == null || to == null ? null : new FieldRange(this.field, from, to);
        }
    }
    class Snippet {
        constructor(lines, fieldPositions)
        {
            this.lines = lines;
            this.fieldPositions = fieldPositions;
        }
        instantiate(state, pos)
        {
            let text = [],
                lineStart = [pos];
            let lineObj = state.doc.lineAt(pos),
                baseIndent = /^\s*/.exec(lineObj.text)[0];
            for (let _i219 = 0, _this$lines = this.lines, _length219 = _this$lines.length; _i219 < _length219; _i219++) {
                let line = _this$lines[_i219];
                if (text.length) {
                    let indent = baseIndent,
                        tabs = /^\t*/.exec(line)[0].length;
                    for (let i = 0; i < tabs; i++)
                        indent += state.facet(indentUnit);
                    lineStart.push(pos + indent.length - tabs);
                    line = indent + line.slice(tabs);
                }
                text.push(line);
                pos += line.length + 1;
            }
            let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));
            return {
                text,
                ranges
            };
        }
        static parse(template)
        {
            let fields = [];
            let lines = [],
                positions = [],
                m;
            for (let _i220 = 0, _template$split = template.split(/\r\n?|\n/), _length220 = _template$split.length; _i220 < _length220; _i220++) {
                let line = _template$split[_i220];
                while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
                    let seq = m[1] ? +m[1] : null,
                        name = m[2] || m[3] || "",
                        found = -1;
                    for (let i = 0; i < fields.length; i++) {
                        if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)
                            found = i;
                    }
                    if (found < 0) {
                        let i = 0;
                        while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))
                            i++;
                        fields.splice(i, 0, {
                            seq,
                            name
                        });
                        found = i;
                        for (let _i221 = 0, _length221 = positions.length; _i221 < _length221; _i221++) {
                            let pos = positions[_i221];
                            if (pos.field >= found)
                                pos.field++;
                        }
                    }
                    positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));
                    line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);
                }
                for (let esc; esc = /\\([{}])/.exec(line);) {
                    line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);
                    for (let _i222 = 0, _length222 = positions.length; _i222 < _length222; _i222++) {
                        let pos = positions[_i222];
                        if (pos.line == lines.length && pos.from > esc.index) {
                            pos.from--;
                            pos.to--;
                        }
                    }
                }
                lines.push(line);
            }
            return new Snippet(lines, positions);
        }
    }
    let fieldMarker = Decoration.widget({
        widget: new class  extends WidgetType{
            toDOM()
            {
                let span = document.createElement("span");
                span.className = "cm-snippetFieldPosition";
                return span;
            }
            ignoreEvent()
            {
                return false;
            }
        }
        ()
    });
    let fieldRange = Decoration.mark({
        class: "cm-snippetField"
    });
    class ActiveSnippet {
        constructor(ranges, active)
        {
            this.ranges = ranges;
            this.active = active;
            this.deco = Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
        }
        map(changes)
        {
            let ranges = [];
            for (let _i223 = 0, _this$ranges = this.ranges, _length223 = _this$ranges.length; _i223 < _length223; _i223++) {
                let r = _this$ranges[_i223];
                let mapped = r.map(changes);
                if (!mapped)
                    return null;
                ranges.push(mapped);
            }
            return new ActiveSnippet(ranges, this.active);
        }
        selectionInsideField(sel)
        {
            return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));
        }
    }
    const setActive = StateEffect.define({
        map(value, changes) {
            return value && value.map(changes);
        }
    });
    const moveToField = StateEffect.define();
    const snippetState = StateField.define({
        create() {
            return null;
        },
        update(value, tr) {
            for (let _i224 = 0, _tr$effects12 = tr.effects, _length224 = _tr$effects12.length; _i224 < _length224; _i224++) {
                let effect = _tr$effects12[_i224];
                if (effect.is(setActive))
                    return effect.value;
                if (effect.is(moveToField) && value)
                    return new ActiveSnippet(value.ranges, effect.value);
            }
            if (value && tr.docChanged)
                value = value.map(tr.changes);
            if (value && tr.selection && !value.selectionInsideField(tr.selection))
                value = null;
            return value;
        },
        provide: f => EditorView.decorations.from(f, val => val ? val.deco : Decoration.none)
    });
    function fieldSelection(ranges, field) {
        return EditorSelection.create(ranges.filter(r => r.field == field).map(r => EditorSelection.range(r.from, r.to)));
    }
    function snippet(template) {
        let snippet = Snippet.parse(template);
        return (editor, _completion, from, to) => {
            let {text, ranges} = snippet.instantiate(editor.state, from);
            let spec = {
                changes: {
                    from,
                    to,
                    insert: Text.of(text)
                },
                scrollIntoView: true
            };
            if (ranges.length)
                spec.selection = fieldSelection(ranges, 0);
            if (ranges.length > 1) {
                let active = new ActiveSnippet(ranges, 0);
                let effects = spec.effects = [setActive.of(active)];
                if (editor.state.field(snippetState, false) === undefined)
                    effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme$2]));
            }
            editor.dispatch(editor.state.update(spec));
        };
    }
    function moveField(dir) {
        return ({state, dispatch}) => {
            let active = state.field(snippetState, false);
            if (!active || dir < 0 && active.active == 0)
                return false;
            let next = active.active + dir,
                last = dir > 0 && !active.ranges.some(r => r.field == next + dir);
            dispatch(state.update({
                selection: fieldSelection(active.ranges, next),
                effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))
            }));
            return true;
        };
    }
    const clearSnippet = ({state, dispatch}) => {
        let active = state.field(snippetState, false);
        if (!active)
            return false;
        dispatch(state.update({
            effects: setActive.of(null)
        }));
        return true;
    };
    const nextSnippetField = moveField(1);
    const prevSnippetField = moveField(-1);
    const defaultSnippetKeymap = [{
        key: "Tab",
        run: nextSnippetField,
        shift: prevSnippetField
    }, {
        key: "Escape",
        run: clearSnippet
    }];
    const snippetKeymap = Facet.define({
        combine(maps) {
            return maps.length ? maps[0] : defaultSnippetKeymap;
        }
    });
    const addSnippetKeymap = Prec.highest(keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));
    function snippetCompletion(template, completion) {
        return Object.assign(Object.assign({}, completion), {
            apply: snippet(template)
        });
    }
    const snippetPointerHandler = EditorView.domEventHandlers({
        mousedown(event, view) {
            let active = view.state.field(snippetState, false),
                pos;
            if (!active || (pos = view.posAtCoords({
                x: event.clientX,
                y: event.clientY
            })) == null)
                return false;
            let match = active.ranges.find(r => r.from <= pos && r.to >= pos);
            if (!match || match.field == active.active)
                return false;
            view.dispatch({
                selection: fieldSelection(active.ranges, match.field),
                effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)
            });
            return true;
        }
    });
    function wordRE(wordChars) {
        let escaped = wordChars.replace(/[\\[.+*?(){|^$]/g, "\\$&");
        try {
            return new RegExp(`[\\p{Alphabetic}\\p{Number}_${escaped}]+`, "ug");
        } catch (_a) {
            return new RegExp(`[\w${escaped}]`, "g");
        }
    }
    function mapRE(re, f) {
        return new RegExp(f(re.source), re.unicode ? "u" : "");
    }
    const wordCaches = Object.create(null);
    function wordCache(wordChars) {
        return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap());
    }
    function storeWords(doc, wordRE, result, seen, ignoreAt) {
        for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {
            let {value} = lines,
                m;
            wordRE.lastIndex = 0;
            while (m = wordRE.exec(value)) {
                if (!seen[m[0]] && pos + m.index != ignoreAt) {
                    result.push({
                        type: "text",
                        label: m[0]
                    });
                    seen[m[0]] = true;
                    if (result.length >= 2000)
                        return;
                }
            }
            pos += value.length + 1;
        }
    }
    function collectWords(doc, cache, wordRE, to, ignoreAt) {
        let big = doc.length >= 1000;
        let cached = big && cache.get(doc);
        if (cached)
            return cached;
        let result = [],
            seen = Object.create(null);
        if (doc.children) {
            let pos = 0;
            for (let _i225 = 0, _doc$children = doc.children, _length225 = _doc$children.length; _i225 < _length225; _i225++) {
                let ch = _doc$children[_i225];
                if (ch.length >= 1000) {
                    for (let _i226 = 0, _collectWords = collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos), _length226 = _collectWords.length; _i226 < _length226; _i226++) {
                        let c = _collectWords[_i226];
                        if (!seen[c.label]) {
                            seen[c.label] = true;
                            result.push(c);
                        }
                    }
                } else {
                    storeWords(ch, wordRE, result, seen, ignoreAt - pos);
                }
                pos += ch.length + 1;
            }
        } else {
            storeWords(doc, wordRE, result, seen, ignoreAt);
        }
        if (big && result.length < 2000)
            cache.set(doc, result);
        return result;
    }
    const completeAnyWord = context => {
        let wordChars = context.state.languageDataAt("wordChars", context.pos).join("");
        let re = wordRE(wordChars);
        let token = context.matchBefore(mapRE(re, s => s + "$"));
        if (!token && !context.explicit)
            return null;
        let from = token ? token.from : context.pos;
        let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000, from);
        return {
            from,
            options,
            validFor: mapRE(re, s => "^" + s)
        };
    };
    const defaults$1 = {
        brackets: ["(", "[", "{", "'", '"'],
        before: ")]}:;>",
        stringPrefixes: []
    };
    const closeBracketEffect = StateEffect.define({
        map(value, mapping) {
            let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
            return mapped == null ? undefined : mapped;
        }
    });
    const skipBracketEffect = StateEffect.define({
        map(value, mapping) {
            return mapping.mapPos(value);
        }
    });
    const closedBracket = new class  extends RangeValue{}
    ();
    closedBracket.startSide = 1;
    closedBracket.endSide = -1;
    const bracketState = StateField.define({
        create() {
            return RangeSet.empty;
        },
        update(value, tr) {
            if (tr.selection) {
                let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
                let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
                if (lineStart != tr.changes.mapPos(prevLineStart, -1))
                    value = RangeSet.empty;
            }
            value = value.map(tr.changes);
            for (let _i227 = 0, _tr$effects13 = tr.effects, _length227 = _tr$effects13.length; _i227 < _length227; _i227++) {
                let effect = _tr$effects13[_i227];
                if (effect.is(closeBracketEffect))
                    value = value.update({
                        add: [closedBracket.range(effect.value, effect.value + 1)]
                    });
                else if (effect.is(skipBracketEffect))
                    value = value.update({
                        filter: from => from != effect.value
                    });
            }
            return value;
        }
    });
    function closeBrackets() {
        return [inputHandler, bracketState];
    }
    const definedClosing = "()[]{}<>";
    function closing(ch) {
        for (let i = 0; i < definedClosing.length; i += 2)
            if (definedClosing.charCodeAt(i) == ch)
                return definedClosing.charAt(i + 1);
        return fromCodePoint(ch < 128 ? ch : ch + 1);
    }
    function config(state, pos) {
        return state.languageDataAt("closeBrackets", pos)[0] || defaults$1;
    }
    const android$1 = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
    const inputHandler = EditorView.inputHandler.of((view, from, to, insert) => {
        if ((android$1 ? view.composing : view.compositionStarted) || view.state.readOnly)
            return false;
        let sel = view.state.selection.main;
        if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 || from != sel.from || to != sel.to)
            return false;
        let tr = insertBracket(view.state, insert);
        if (!tr)
            return false;
        view.dispatch(tr);
        return true;
    });
    const deleteBracketPair = ({state, dispatch}) => {
        if (state.readOnly)
            return false;
        let conf = config(state, state.selection.main.head);
        let tokens = conf.brackets || defaults$1.brackets;
        let dont = null,
            changes = state.changeByRange(range => {
                if (range.empty) {
                    let before = prevChar(state.doc, range.head);
                    for (let _i228 = 0, _length228 = tokens.length; _i228 < _length228; _i228++) {
                        let token = tokens[_i228];
                        if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
                            return {
                                changes: {
                                    from: range.head - token.length,
                                    to: range.head + token.length
                                },
                                range: EditorSelection.cursor(range.head - token.length)
                            };
                    }
                }
                return {
                    range: dont = range
                };
            });
        if (!dont)
            dispatch(state.update(changes, {
                scrollIntoView: true,
                userEvent: "delete.backward"
            }));
        return !dont;
    };
    const closeBracketsKeymap = [{
        key: "Backspace",
        run: deleteBracketPair
    }];
    function insertBracket(state, bracket) {
        let conf = config(state, state.selection.main.head);
        let tokens = conf.brackets || defaults$1.brackets;
        for (let _i229 = 0, _length229 = tokens.length; _i229 < _length229; _i229++) {
            let tok = tokens[_i229];
            let closed = closing(codePointAt(tok, 0));
            if (bracket == tok)
                return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults$1.before);
            if (bracket == closed && closedBracketAt(state, state.selection.main.from))
                return handleClose(state, tok, closed);
        }
        return null;
    }
    function closedBracketAt(state, pos) {
        let found = false;
        state.field(bracketState).between(0, state.doc.length, from => {
            if (from == pos)
                found = true;
        });
        return found;
    }
    function nextChar(doc, pos) {
        let next = doc.sliceString(pos, pos + 2);
        return next.slice(0, codePointSize(codePointAt(next, 0)));
    }
    function prevChar(doc, pos) {
        let prev = doc.sliceString(pos - 2, pos);
        return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
    }
    function handleOpen(state, open, close, closeBefore) {
        let dont = null,
            changes = state.changeByRange(range => {
                if (!range.empty)
                    return {
                        changes: [{
                            insert: open,
                            from: range.from
                        }, {
                            insert: close,
                            from: range.to
                        }],
                        effects: closeBracketEffect.of(range.to + open.length),
                        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
                    };
                let next = nextChar(state.doc, range.head);
                if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
                    return {
                        changes: {
                            insert: open + close,
                            from: range.head
                        },
                        effects: closeBracketEffect.of(range.head + open.length),
                        range: EditorSelection.cursor(range.head + open.length)
                    };
                return {
                    range: dont = range
                };
            });
        return dont ? null : state.update(changes, {
            scrollIntoView: true,
            userEvent: "input.type"
        });
    }
    function handleClose(state, _open, close) {
        let dont = null,
            moved = state.selection.ranges.map(range => {
                if (range.empty && nextChar(state.doc, range.head) == close)
                    return EditorSelection.cursor(range.head + close.length);
                return dont = range;
            });
        return dont ? null : state.update({
            selection: EditorSelection.create(moved, state.selection.mainIndex),
            scrollIntoView: true,
            effects: state.selection.ranges.map(({from}) => skipBracketEffect.of(from))
        });
    }
    function handleSame(state, token, allowTriple, config) {
        let stringPrefixes = config.stringPrefixes || defaults$1.stringPrefixes;
        let dont = null,
            changes = state.changeByRange(range => {
                if (!range.empty)
                    return {
                        changes: [{
                            insert: token,
                            from: range.from
                        }, {
                            insert: token,
                            from: range.to
                        }],
                        effects: closeBracketEffect.of(range.to + token.length),
                        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
                    };
                let pos = range.head,
                    next = nextChar(state.doc, pos),
                    start;
                if (next == token) {
                    if (nodeStart(state, pos)) {
                        return {
                            changes: {
                                insert: token + token,
                                from: pos
                            },
                            effects: closeBracketEffect.of(pos + token.length),
                            range: EditorSelection.cursor(pos + token.length)
                        };
                    } else if (closedBracketAt(state, pos)) {
                        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
                        return {
                            range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
                            effects: skipBracketEffect.of(pos)
                        };
                    }
                } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
                    return {
                        changes: {
                            insert: token + token + token + token,
                            from: pos
                        },
                        effects: closeBracketEffect.of(pos + token.length),
                        range: EditorSelection.cursor(pos + token.length)
                    };
                } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
                    if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
                        return {
                            changes: {
                                insert: token + token,
                                from: pos
                            },
                            effects: closeBracketEffect.of(pos + token.length),
                            range: EditorSelection.cursor(pos + token.length)
                        };
                }
                return {
                    range: dont = range
                };
            });
        return dont ? null : state.update(changes, {
            scrollIntoView: true,
            userEvent: "input.type"
        });
    }
    function nodeStart(state, pos) {
        let tree = syntaxTree(state).resolveInner(pos + 1);
        return tree.parent && tree.from == pos;
    }
    function probablyInString(state, pos, quoteToken, prefixes) {
        let node = syntaxTree(state).resolveInner(pos, -1);
        let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
        for (let i = 0; i < 5; i++) {
            let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
            let quotePos = start.indexOf(quoteToken);
            if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
                let first = node.firstChild;
                while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
                    if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
                        return false;
                    first = first.firstChild;
                }
                return true;
            }
            let parent = node.to == pos && node.parent;
            if (!parent)
                break;
            node = parent;
        }
        return false;
    }
    function canStartStringAt(state, pos, prefixes) {
        let charCat = state.charCategorizer(pos);
        if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
            return pos;
        for (let _i230 = 0, _length230 = prefixes.length; _i230 < _length230; _i230++) {
            let prefix = prefixes[_i230];
            let start = pos - prefix.length;
            if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
                return start;
        }
        return -1;
    }
    function autocompletion(config={}) {
        return [completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme$2];
    }
    const completionKeymap = [{
        key: "Ctrl-Space",
        run: startCompletion
    }, {
        key: "Escape",
        run: closeCompletion
    }, {
        key: "ArrowDown",
        run: moveCompletionSelection(true)
    }, {
        key: "ArrowUp",
        run: moveCompletionSelection(false)
    }, {
        key: "PageDown",
        run: moveCompletionSelection(true, "page")
    }, {
        key: "PageUp",
        run: moveCompletionSelection(false, "page")
    }, {
        key: "Enter",
        run: acceptCompletion
    }];
    const completionKeymapExt = Prec.highest(keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
    function completionStatus(state) {
        let cState = state.field(completionState, false);
        return cState && cState.active.some(a => a.state == 1) ? "pending" : cState && cState.active.some(a => a.state != 0) ? "active" : null;
    }
    const completionArrayCache = new WeakMap();
    function currentCompletions(state) {
        var _a;
        let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
        if (!open || open.disabled)
            return [];
        let completions = completionArrayCache.get(open.options);
        if (!completions)
            completionArrayCache.set(open.options, completions = open.options.map(o => o.completion));
        return completions;
    }
    function selectedCompletion(state) {
        var _a;
        let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
        return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;
    }
    function selectedCompletionIndex(state) {
        var _a;
        let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
        return open && !open.disabled && open.selected >= 0 ? open.selected : null;
    }
    function setSelectedCompletion(index) {
        return setSelectedEffect.of(index);
    }
    var _m5 = Object.freeze({
        __proto__: null,
        CompletionContext: CompletionContext,
        acceptCompletion: acceptCompletion,
        autocompletion: autocompletion,
        clearSnippet: clearSnippet,
        closeBrackets: closeBrackets,
        closeBracketsKeymap: closeBracketsKeymap,
        closeCompletion: closeCompletion,
        completeAnyWord: completeAnyWord,
        completeFromList: completeFromList,
        completionKeymap: completionKeymap,
        completionStatus: completionStatus,
        currentCompletions: currentCompletions,
        deleteBracketPair: deleteBracketPair,
        ifIn: ifIn,
        ifNotIn: ifNotIn,
        insertBracket: insertBracket,
        insertCompletionText: insertCompletionText,
        moveCompletionSelection: moveCompletionSelection,
        nextSnippetField: nextSnippetField,
        pickedCompletion: pickedCompletion,
        prevSnippetField: prevSnippetField,
        selectedCompletion: selectedCompletion,
        selectedCompletionIndex: selectedCompletionIndex,
        setSelectedCompletion: setSelectedCompletion,
        snippet: snippet,
        snippetCompletion: snippetCompletion,
        snippetKeymap: snippetKeymap,
        startCompletion: startCompletion
    });
    class SelectedDiagnostic {
        constructor(from, to, diagnostic)
        {
            this.from = from;
            this.to = to;
            this.diagnostic = diagnostic;
        }
    }
    class LintState {
        constructor(diagnostics, panel, selected)
        {
            this.diagnostics = diagnostics;
            this.panel = panel;
            this.selected = selected;
        }
        static init(diagnostics, panel, state)
        {
            let markedDiagnostics = diagnostics;
            let diagnosticFilter = state.facet(lintConfig).markerFilter;
            if (diagnosticFilter)
                markedDiagnostics = diagnosticFilter(markedDiagnostics);
            let ranges = Decoration.set(markedDiagnostics.map(d => {
                return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({
                    widget: new DiagnosticWidget(d),
                    diagnostic: d
                }).range(d.from) : Decoration.mark({
                    attributes: {
                        class: "cm-lintRange cm-lintRange-" + d.severity
                    },
                    diagnostic: d
                }).range(d.from, d.to);
            }), true);
            return new LintState(ranges, panel, findDiagnostic(ranges));
        }
    }
    function findDiagnostic(diagnostics, diagnostic=null, after=0) {
        let found = null;
        diagnostics.between(after, 1e9, (from, to, {spec}) => {
            if (diagnostic && spec.diagnostic != diagnostic)
                return;
            found = new SelectedDiagnostic(from, to, spec.diagnostic);
            return false;
        });
        return found;
    }
    function hideTooltip(tr, tooltip) {
        return !!(tr.effects.some(e => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));
    }
    function maybeEnableLint(state, effects) {
        return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([lintState, EditorView.decorations.compute([lintState], state => {
            let {selected, panel} = state.field(lintState);
            return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([activeMark.range(selected.from, selected.to)]);
        }), hoverTooltip(lintTooltip, {
            hideOn: hideTooltip
        }), baseTheme$1]));
    }
    function setDiagnostics(state, diagnostics) {
        return {
            effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
        };
    }
    const setDiagnosticsEffect = StateEffect.define();
    const togglePanel = StateEffect.define();
    const movePanelSelection = StateEffect.define();
    const lintState = StateField.define({
        create() {
            return new LintState(Decoration.none, null, null);
        },
        update(value, tr) {
            if (tr.docChanged) {
                let mapped = value.diagnostics.map(tr.changes),
                    selected = null;
                if (value.selected) {
                    let selPos = tr.changes.mapPos(value.selected.from, 1);
                    selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
                }
                value = new LintState(mapped, value.panel, selected);
            }
            for (let _i231 = 0, _tr$effects14 = tr.effects, _length231 = _tr$effects14.length; _i231 < _length231; _i231++) {
                let effect = _tr$effects14[_i231];
                if (effect.is(setDiagnosticsEffect)) {
                    value = LintState.init(effect.value, value.panel, tr.state);
                } else if (effect.is(togglePanel)) {
                    value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
                } else if (effect.is(movePanelSelection)) {
                    value = new LintState(value.diagnostics, value.panel, effect.value);
                }
            }
            return value;
        },
        provide: f => [showPanel.from(f, val => val.panel), EditorView.decorations.from(f, s => s.diagnostics)]
    });
    function diagnosticCount(state) {
        let lint = state.field(lintState, false);
        return lint ? lint.diagnostics.size : 0;
    }
    const activeMark = Decoration.mark({
        class: "cm-lintRange cm-lintRange-active"
    });
    function lintTooltip(view, pos, side) {
        let {diagnostics} = view.state.field(lintState);
        let found = [],
            stackStart = 2e8,
            stackEnd = 0;
        diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, {spec}) => {
            if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
                found.push(spec.diagnostic);
                stackStart = Math.min(from, stackStart);
                stackEnd = Math.max(to, stackEnd);
            }
        });
        let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
        if (diagnosticFilter)
            found = diagnosticFilter(found);
        if (!found.length)
            return null;
        return {
            pos: stackStart,
            end: stackEnd,
            above: view.state.doc.lineAt(stackStart).to < stackEnd,
            create() {
                return {
                    dom: diagnosticsTooltip(view, found)
                };
            }
        };
    }
    function diagnosticsTooltip(view, diagnostics) {
        return crelt("ul", {
            class: "cm-tooltip-lint"
        }, diagnostics.map(d => renderDiagnostic(view, d, false)));
    }
    const openLintPanel = view => {
        let field = view.state.field(lintState, false);
        if (!field || !field.panel)
            view.dispatch({
                effects: maybeEnableLint(view.state, [togglePanel.of(true)])
            });
        let panel = getPanel(view, LintPanel.open);
        if (panel)
            panel.dom.querySelector(".cm-panel-lint ul").focus();
        return true;
    };
    const closeLintPanel = view => {
        let field = view.state.field(lintState, false);
        if (!field || !field.panel)
            return false;
        view.dispatch({
            effects: togglePanel.of(false)
        });
        return true;
    };
    const nextDiagnostic = view => {
        let field = view.state.field(lintState, false);
        if (!field)
            return false;
        let sel = view.state.selection.main,
            next = field.diagnostics.iter(sel.to + 1);
        if (!next.value) {
            next = field.diagnostics.iter(0);
            if (!next.value || next.from == sel.from && next.to == sel.to)
                return false;
        }
        view.dispatch({
            selection: {
                anchor: next.from,
                head: next.to
            },
            scrollIntoView: true
        });
        return true;
    };
    const lintKeymap = [{
        key: "Mod-Shift-m",
        run: openLintPanel,
        preventDefault: true
    }, {
        key: "F8",
        run: nextDiagnostic
    }];
    const lintPlugin = ViewPlugin.fromClass(class {
        constructor(view)
        {
            this.view = view;
            this.timeout = -1;
            this.set = true;
            let {delay} = view.state.facet(lintConfig);
            this.lintTime = Date.now() + delay;
            this.run = this.run.bind(this);
            this.timeout = setTimeout(this.run, delay);
        }
        run()
        {
            let now = Date.now();
            if (now < this.lintTime - 10) {
                setTimeout(this.run, this.lintTime - now);
            } else {
                this.set = false;
                let {state} = this.view,
                    {sources} = state.facet(lintConfig);
                Promise.all(sources.map(source => Promise.resolve(source(this.view)))).then(annotations => {
                    let all = annotations.reduce((a, b) => a.concat(b));
                    if (this.view.state.doc == state.doc)
                        this.view.dispatch(setDiagnostics(this.view.state, all));
                }, error => {
                    logException(this.view.state, error);
                });
            }
        }
        update(update)
        {
            let config = update.state.facet(lintConfig);
            if (update.docChanged || config != update.startState.facet(lintConfig)) {
                this.lintTime = Date.now() + config.delay;
                if (!this.set) {
                    this.set = true;
                    this.timeout = setTimeout(this.run, config.delay);
                }
            }
        }
        force()
        {
            if (this.set) {
                this.lintTime = Date.now();
                this.run();
            }
        }
        destroy()
        {
            clearTimeout(this.timeout);
        }
    }
    );
    const lintConfig = Facet.define({
        combine(input) {
            return Object.assign({
                sources: input.map(i => i.source)
            }, combineConfig(input.map(i => i.config), {
                delay: 750,
                markerFilter: null,
                tooltipFilter: null
            }));
        },
        enables: lintPlugin
    });
    function linter(source, config={}) {
        return lintConfig.of({
            source,
            config
        });
    }
    function forceLinting(view) {
        let plugin = view.plugin(lintPlugin);
        if (plugin)
            plugin.force();
    }
    function assignKeys(actions) {
        let assigned = [];
        if (actions)
            actions:
            for (let _i232 = 0, _length232 = actions.length; _i232 < _length232; _i232++) {
                let {name} = actions[_i232];
                for (let i = 0; i < name.length; i++) {
                    let ch = name[i];
                    if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {
                        assigned.push(ch);
                        continue actions;
                    }
                }
                assigned.push("");
            }
        return assigned;
    }
    function renderDiagnostic(view, diagnostic, inPanel) {
        var _a;
        let keys = inPanel ? assignKeys(diagnostic.actions) : [];
        return crelt("li", {
            class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity
        }, crelt("span", {
            class: "cm-diagnosticText"
        }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
            let click = e => {
                e.preventDefault();
                let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
                if (found)
                    action.apply(view, found.from, found.to);
            };
            let {name} = action,
                keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;
            let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex), crelt("u", name.slice(keyIndex, keyIndex + 1)), name.slice(keyIndex + 1)];
            return crelt("button", {
                type: "button",
                class: "cm-diagnosticAction",
                onclick: click,
                onmousedown: click,
                "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
            }, nameElt);
        }), diagnostic.source && crelt("div", {
            class: "cm-diagnosticSource"
        }, diagnostic.source));
    }
    class DiagnosticWidget extends WidgetType {
        constructor(diagnostic)
        {
            super();
            this.diagnostic = diagnostic;
        }
        eq(other)
        {
            return other.diagnostic == this.diagnostic;
        }
        toDOM()
        {
            return crelt("span", {
                class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity
            });
        }
    }
    class PanelItem {
        constructor(view, diagnostic)
        {
            this.diagnostic = diagnostic;
            this.id = "item_" + Math.floor(Math.random() * 0xffffffff).toString(16);
            this.dom = renderDiagnostic(view, diagnostic, true);
            this.dom.id = this.id;
            this.dom.setAttribute("role", "option");
        }
    }
    class LintPanel {
        constructor(view)
        {
            this.view = view;
            this.items = [];
            let onkeydown = event => {
                if (event.keyCode == 27) {
                    closeLintPanel(this.view);
                    this.view.focus();
                } else if (event.keyCode == 38 || event.keyCode == 33) {
                    this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
                } else if (event.keyCode == 40 || event.keyCode == 34) {
                    this.moveSelection((this.selectedIndex + 1) % this.items.length);
                } else if (event.keyCode == 36) {
                    this.moveSelection(0);
                } else if (event.keyCode == 35) {
                    this.moveSelection(this.items.length - 1);
                } else if (event.keyCode == 13) {
                    this.view.focus();
                } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
                    let {diagnostic} = this.items[this.selectedIndex],
                        keys = assignKeys(diagnostic.actions);
                    for (let i = 0; i < keys.length; i++)
                        if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
                            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                            if (found)
                                diagnostic.actions[i].apply(view, found.from, found.to);
                        }
                } else {
                    return;
                }
                event.preventDefault();
            };
            let onclick = event => {
                for (let i = 0; i < this.items.length; i++) {
                    if (this.items[i].dom.contains(event.target))
                        this.moveSelection(i);
                }
            };
            this.list = crelt("ul", {
                tabIndex: 0,
                role: "listbox",
                "aria-label": this.view.state.phrase("Diagnostics"),
                onkeydown,
                onclick
            });
            this.dom = crelt("div", {
                class: "cm-panel-lint"
            }, this.list, crelt("button", {
                type: "button",
                name: "close",
                "aria-label": this.view.state.phrase("close"),
                onclick: () => closeLintPanel(this.view)
            }, "×"));
            this.update();
        }
        get selectedIndex()
        {
            let selected = this.view.state.field(lintState).selected;
            if (!selected)
                return -1;
            for (let i = 0; i < this.items.length; i++)
                if (this.items[i].diagnostic == selected.diagnostic)
                    return i;
            return -1;
        }
        update()
        {
            let {diagnostics, selected} = this.view.state.field(lintState);
            let i = 0,
                needsSync = false,
                newSelectedItem = null;
            diagnostics.between(0, this.view.state.doc.length, (_start, _end, {spec}) => {
                let found = -1,
                    item;
                for (let j = i; j < this.items.length; j++)
                    if (this.items[j].diagnostic == spec.diagnostic) {
                        found = j;
                        break;
                    }
                if (found < 0) {
                    item = new PanelItem(this.view, spec.diagnostic);
                    this.items.splice(i, 0, item);
                    needsSync = true;
                } else {
                    item = this.items[found];
                    if (found > i) {
                        this.items.splice(i, found - i);
                        needsSync = true;
                    }
                }
                if (selected && item.diagnostic == selected.diagnostic) {
                    if (!item.dom.hasAttribute("aria-selected")) {
                        item.dom.setAttribute("aria-selected", "true");
                        newSelectedItem = item;
                    }
                } else if (item.dom.hasAttribute("aria-selected")) {
                    item.dom.removeAttribute("aria-selected");
                }
                i++;
            });
            while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
                needsSync = true;
                this.items.pop();
            }
            if (this.items.length == 0) {
                this.items.push(new PanelItem(this.view, {
                    from: -1,
                    to: -1,
                    severity: "info",
                    message: this.view.state.phrase("No diagnostics")
                }));
                needsSync = true;
            }
            if (newSelectedItem) {
                this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
                this.view.requestMeasure({
                    key: this,
                    read: () => ({
                        sel: newSelectedItem.dom.getBoundingClientRect(),
                        panel: this.list.getBoundingClientRect()
                    }),
                    write: ({sel, panel}) => {
                        if (sel.top < panel.top)
                            this.list.scrollTop -= panel.top - sel.top;
                        else if (sel.bottom > panel.bottom)
                            this.list.scrollTop += sel.bottom - panel.bottom;
                    }
                });
            } else if (this.selectedIndex < 0) {
                this.list.removeAttribute("aria-activedescendant");
            }
            if (needsSync)
                this.sync();
        }
        sync()
        {
            let domPos = this.list.firstChild;
            function rm() {
                let prev = domPos;
                domPos = prev.nextSibling;
                prev.remove();
            }
            for (let _i233 = 0, _this$items = this.items, _length233 = _this$items.length; _i233 < _length233; _i233++) {
                let item = _this$items[_i233];
                if (item.dom.parentNode == this.list) {
                    while (domPos != item.dom)
                        rm();
                    domPos = item.dom.nextSibling;
                } else {
                    this.list.insertBefore(item.dom, domPos);
                }
            }
            while (domPos)
                rm();
        }
        moveSelection(selectedIndex)
        {
            if (this.selectedIndex < 0)
                return;
            let field = this.view.state.field(lintState);
            let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
            if (!selection)
                return;
            this.view.dispatch({
                selection: {
                    anchor: selection.from,
                    head: selection.to
                },
                scrollIntoView: true,
                effects: movePanelSelection.of(selection)
            });
        }
        static open(view)
        {
            return new LintPanel(view);
        }
    }
    function svg(content, attrs=`viewBox="0 0 40 40"`) {
        return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content)}</svg>')`;
    }
    function underline(color) {
        return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
    }
    const baseTheme$1 = EditorView.baseTheme({
        ".cm-diagnostic": {
            padding: "3px 6px 3px 8px",
            marginLeft: "-1px",
            display: "block",
            whiteSpace: "pre-wrap"
        },
        ".cm-diagnostic-error": {
            borderLeft: "5px solid #d11"
        },
        ".cm-diagnostic-warning": {
            borderLeft: "5px solid orange"
        },
        ".cm-diagnostic-info": {
            borderLeft: "5px solid #999"
        },
        ".cm-diagnosticAction": {
            font: "inherit",
            border: "none",
            padding: "2px 4px",
            backgroundColor: "#444",
            color: "white",
            borderRadius: "3px",
            marginLeft: "8px"
        },
        ".cm-diagnosticSource": {
            fontSize: "70%",
            opacity: .7
        },
        ".cm-lintRange": {
            backgroundPosition: "left bottom",
            backgroundRepeat: "repeat-x",
            paddingBottom: "0.7px"
        },
        ".cm-lintRange-error": {
            backgroundImage: underline("#d11")
        },
        ".cm-lintRange-warning": {
            backgroundImage: underline("orange")
        },
        ".cm-lintRange-info": {
            backgroundImage: underline("#999")
        },
        ".cm-lintRange-active": {
            backgroundColor: "#ffdd9980"
        },
        ".cm-tooltip-lint": {
            padding: 0,
            margin: 0
        },
        ".cm-lintPoint": {
            position: "relative",
            "&:after": {
                content: '""',
                position: "absolute",
                bottom: 0,
                left: "-2px",
                borderLeft: "3px solid transparent",
                borderRight: "3px solid transparent",
                borderBottom: "4px solid #d11"
            }
        },
        ".cm-lintPoint-warning": {
            "&:after": {
                borderBottomColor: "orange"
            }
        },
        ".cm-lintPoint-info": {
            "&:after": {
                borderBottomColor: "#999"
            }
        },
        ".cm-panel.cm-panel-lint": {
            position: "relative",
            "& ul": {
                maxHeight: "100px",
                overflowY: "auto",
                "& [aria-selected]": {
                    backgroundColor: "#ddd",
                    "& u": {
                        textDecoration: "underline"
                    }
                },
                "&:focus [aria-selected]": {
                    background_fallback: "#bdf",
                    backgroundColor: "Highlight",
                    color_fallback: "white",
                    color: "HighlightText"
                },
                "& u": {
                    textDecoration: "none"
                },
                padding: 0,
                margin: 0
            },
            "& [name=close]": {
                position: "absolute",
                top: "0",
                right: "2px",
                background: "inherit",
                border: "none",
                font: "inherit",
                padding: 0,
                margin: 0
            }
        }
    });
    class LintGutterMarker extends GutterMarker {
        constructor(diagnostics)
        {
            super();
            this.diagnostics = diagnostics;
            this.severity = diagnostics.reduce((max, d) => {
                let s = d.severity;
                return s == "error" || s == "warning" && max == "info" ? s : max;
            }, "info");
        }
        toDOM(view)
        {
            let elt = document.createElement("div");
            elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
            let diagnostics = this.diagnostics;
            let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
            if (diagnosticsFilter)
                diagnostics = diagnosticsFilter(diagnostics);
            if (diagnostics.length)
                elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
            return elt;
        }
    }
    function trackHoverOn(view, marker) {
        let mousemove = event => {
            let rect = marker.getBoundingClientRect();
            if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
                return;
            for (let target = event.target; target; target = target.parentNode) {
                if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
                    return;
            }
            window.removeEventListener("mousemove", mousemove);
            if (view.state.field(lintGutterTooltip))
                view.dispatch({
                    effects: setLintGutterTooltip.of(null)
                });
        };
        window.addEventListener("mousemove", mousemove);
    }
    function gutterMarkerMouseOver(view, marker, diagnostics) {
        function hovered() {
            let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
            const linePos = view.coordsAtPos(line.from);
            if (linePos) {
                view.dispatch({
                    effects: setLintGutterTooltip.of({
                        pos: line.from,
                        above: false,
                        create() {
                            return {
                                dom: diagnosticsTooltip(view, diagnostics),
                                getCoords: () => marker.getBoundingClientRect()
                            };
                        }
                    })
                });
            }
            marker.onmouseout = marker.onmousemove = null;
            trackHoverOn(view, marker);
        }
        let {hoverTime} = view.state.facet(lintGutterConfig);
        let hoverTimeout = setTimeout(hovered, hoverTime);
        marker.onmouseout = () => {
            clearTimeout(hoverTimeout);
            marker.onmouseout = marker.onmousemove = null;
        };
        marker.onmousemove = () => {
            clearTimeout(hoverTimeout);
            hoverTimeout = setTimeout(hovered, hoverTime);
        };
    }
    function markersForDiagnostics(doc, diagnostics) {
        let byLine = Object.create(null);
        for (let _i234 = 0, _length234 = diagnostics.length; _i234 < _length234; _i234++) {
            let diagnostic = diagnostics[_i234];
            let line = doc.lineAt(diagnostic.from);
            (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
        }
        let markers = [];
        for (let line in byLine) {
            markers.push(new LintGutterMarker(byLine[line]).range(+line));
        }
        return RangeSet.of(markers, true);
    }
    const lintGutterExtension = gutter({
        class: "cm-gutter-lint",
        markers: view => view.state.field(lintGutterMarkers)
    });
    const lintGutterMarkers = StateField.define({
        create() {
            return RangeSet.empty;
        },
        update(markers, tr) {
            markers = markers.map(tr.changes);
            let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
            for (let _i235 = 0, _tr$effects15 = tr.effects, _length235 = _tr$effects15.length; _i235 < _length235; _i235++) {
                let effect = _tr$effects15[_i235];
                if (effect.is(setDiagnosticsEffect)) {
                    let diagnostics = effect.value;
                    if (diagnosticFilter)
                        diagnostics = diagnosticFilter(diagnostics || []);
                    markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
                }
            }
            return markers;
        }
    });
    const setLintGutterTooltip = StateEffect.define();
    const lintGutterTooltip = StateField.define({
        create() {
            return null;
        },
        update(tooltip, tr) {
            if (tooltip && tr.docChanged)
                tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), {
                    pos: tr.changes.mapPos(tooltip.pos)
                });
            return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);
        },
        provide: field => showTooltip.from(field)
    });
    const lintGutterTheme = EditorView.baseTheme({
        ".cm-gutter-lint": {
            width: "1.4em",
            "& .cm-gutterElement": {
                padding: ".2em"
            }
        },
        ".cm-lint-marker": {
            width: "1em",
            height: "1em"
        },
        ".cm-lint-marker-info": {
            content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
        },
        ".cm-lint-marker-warning": {
            content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
        },
        ".cm-lint-marker-error": {
            content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
        }
    });
    const lintGutterConfig = Facet.define({
        combine(configs) {
            return combineConfig(configs, {
                hoverTime: 300,
                markerFilter: null,
                tooltipFilter: null
            });
        }
    });
    function lintGutter(config={}) {
        return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];
    }
    function forEachDiagnostic(state, f) {
        let lState = state.field(lintState, false);
        if (lState && lState.diagnostics.size)
            for (let iter = RangeSet.iter([lState.diagnostics]); iter.value; iter.next())
                f(iter.value.spec.diagnostic, iter.from, iter.to);
    }
    var _m6 = Object.freeze({
        __proto__: null,
        closeLintPanel: closeLintPanel,
        diagnosticCount: diagnosticCount,
        forEachDiagnostic: forEachDiagnostic,
        forceLinting: forceLinting,
        lintGutter: lintGutter,
        lintKeymap: lintKeymap,
        linter: linter,
        nextDiagnostic: nextDiagnostic,
        openLintPanel: openLintPanel,
        setDiagnostics: setDiagnostics,
        setDiagnosticsEffect: setDiagnosticsEffect
    });
    class LocalUpdate {
        constructor(origin, changes, effects, clientID)
        {
            this.origin = origin;
            this.changes = changes;
            this.effects = effects;
            this.clientID = clientID;
        }
    }
    class CollabState {
        constructor(version, unconfirmed)
        {
            this.version = version;
            this.unconfirmed = unconfirmed;
        }
    }
    const collabConfig = Facet.define({
        combine(configs) {
            let combined = combineConfig(configs, {
                startVersion: 0,
                clientID: null,
                sharedEffects: () => []
            });
            if (combined.clientID == null)
                combined.clientID = configs.length && configs[0].generatedID || "";
            return combined;
        }
    });
    const collabReceive = Annotation.define();
    const collabField = StateField.define({
        create(state) {
            return new CollabState(state.facet(collabConfig).startVersion, []);
        },
        update(collab, tr) {
            let isSync = tr.annotation(collabReceive);
            if (isSync)
                return isSync;
            let {sharedEffects, clientID} = tr.startState.facet(collabConfig);
            let effects = sharedEffects(tr);
            if (effects.length || !tr.changes.empty)
                return new CollabState(collab.version, collab.unconfirmed.concat(new LocalUpdate(tr, tr.changes, effects, clientID)));
            return collab;
        }
    });
    function collab(config={}) {
        return [collabField, collabConfig.of(Object.assign({
            generatedID: Math.floor(Math.random() * 1e9).toString(36)
        }, config))];
    }
    function receiveUpdates(state, updates) {
        let {version, unconfirmed} = state.field(collabField);
        let {clientID} = state.facet(collabConfig);
        version += updates.length;
        let own = 0;
        while (own < updates.length && updates[own].clientID == clientID)
            own++;
        if (own) {
            unconfirmed = unconfirmed.slice(own);
            updates = updates.slice(own);
        }
        if (!updates.length)
            return state.update({
                annotations: [collabReceive.of(new CollabState(version, unconfirmed))]
            });
        let changes = updates[0].changes,
            effects = updates[0].effects || [];
        for (let i = 1; i < updates.length; i++) {
            let update = updates[i];
            effects = StateEffect.mapEffects(effects, update.changes);
            if (update.effects)
                effects = effects.concat(update.effects);
            changes = changes.compose(update.changes);
        }
        if (unconfirmed.length) {
            unconfirmed = unconfirmed.map(update => {
                let updateChanges = update.changes.map(changes);
                changes = changes.map(update.changes, true);
                return new LocalUpdate(update.origin, updateChanges, StateEffect.mapEffects(update.effects, changes), clientID);
            });
            effects = StateEffect.mapEffects(effects, unconfirmed.reduce((ch, u) => ch.compose(u.changes), ChangeSet.empty(unconfirmed[0].changes.length)));
        }
        return state.update({
            changes,
            effects,
            annotations: [Transaction.addToHistory.of(false), Transaction.remote.of(true), collabReceive.of(new CollabState(version, unconfirmed))],
            filter: false
        });
    }
    function sendableUpdates(state) {
        return state.field(collabField).unconfirmed;
    }
    function getSyncedVersion(state) {
        return state.field(collabField).version;
    }
    function getClientID(state) {
        return state.facet(collabConfig).clientID;
    }
    var _m7 = Object.freeze({
        __proto__: null,
        collab: collab,
        getClientID: getClientID,
        getSyncedVersion: getSyncedVersion,
        receiveUpdates: receiveUpdates,
        sendableUpdates: sendableUpdates
    });
    const basicSetup = (() => [lineNumbers(), highlightActiveLineGutter(), highlightSpecialChars(), history(), foldGutter(), drawSelection(), dropCursor(), EditorState.allowMultipleSelections.of(true), indentOnInput(), syntaxHighlighting(defaultHighlightStyle, {
        fallback: true
    }), bracketMatching(), closeBrackets(), autocompletion(), rectangularSelection(), crosshairCursor(), highlightActiveLine(), highlightSelectionMatches(), keymap.of([...closeBracketsKeymap, ...defaultKeymap, ...searchKeymap, ...historyKeymap, ...foldKeymap, ...completionKeymap, ...lintKeymap])])();
    const minimalSetup = (() => [highlightSpecialChars(), history(), drawSelection(), syntaxHighlighting(defaultHighlightStyle, {
        fallback: true
    }), keymap.of([...defaultKeymap, ...historyKeymap])])();
    var _m8 = Object.freeze({
        __proto__: null,
        basicSetup: basicSetup,
        minimalSetup: minimalSetup,
        EditorView: EditorView
    });
    class Stack {
        constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead=0, parent)
        {
            this.p = p;
            this.stack = stack;
            this.state = state;
            this.reducePos = reducePos;
            this.pos = pos;
            this.score = score;
            this.buffer = buffer;
            this.bufferBase = bufferBase;
            this.curContext = curContext;
            this.lookAhead = lookAhead;
            this.parent = parent;
        }
        toString()
        {
            return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
        }
        static start(p, state, pos=0)
        {
            let cx = p.parser.context;
            return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
        }
        get context()
        {
            return this.curContext ? this.curContext.context : null;
        }
        pushState(state, start)
        {
            this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
            this.state = state;
        }
        reduce(action)
        {
            let depth = action >> 19,
                type = action & 65535;
            let {parser} = this.p;
            let dPrec = parser.dynamicPrecedence(type);
            if (dPrec)
                this.score += dPrec;
            if (depth == 0) {
                this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
                if (type < parser.minRepeatTerm)
                    this.storeNode(type, this.reducePos, this.reducePos, 4, true);
                this.reduceContext(type, this.reducePos);
                return;
            }
            let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
            let start = this.stack[base - 2];
            let bufferBase = this.stack[base - 1],
                count = this.bufferBase + this.buffer.length - bufferBase;
            if (type < parser.minRepeatTerm || action & 131072) {
                let pos = parser.stateFlag(this.state, 1) ? this.pos : this.reducePos;
                this.storeNode(type, start, pos, count + 4, true);
            }
            if (action & 262144) {
                this.state = this.stack[base];
            } else {
                let baseStateID = this.stack[base - 3];
                this.state = parser.getGoto(baseStateID, type, true);
            }
            while (this.stack.length > base)
                this.stack.pop();
            this.reduceContext(type, start);
        }
        storeNode(term, start, end, size=4, isReduce=false)
        {
            if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
                let cur = this,
                    top = this.buffer.length;
                if (top == 0 && cur.parent) {
                    top = cur.bufferBase - cur.parent.bufferBase;
                    cur = cur.parent;
                }
                if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {
                    if (start == end)
                        return;
                    if (cur.buffer[top - 2] >= start) {
                        cur.buffer[top - 2] = end;
                        return;
                    }
                }
            }
            if (!isReduce || this.pos == end) {
                this.buffer.push(term, start, end, size);
            } else {
                let index = this.buffer.length;
                if (index > 0 && this.buffer[index - 4] != 0)
                    while (index > 0 && this.buffer[index - 2] > end) {
                        this.buffer[index] = this.buffer[index - 4];
                        this.buffer[index + 1] = this.buffer[index - 3];
                        this.buffer[index + 2] = this.buffer[index - 2];
                        this.buffer[index + 3] = this.buffer[index - 1];
                        index -= 4;
                        if (size > 4)
                            size -= 4;
                    }
                this.buffer[index] = term;
                this.buffer[index + 1] = start;
                this.buffer[index + 2] = end;
                this.buffer[index + 3] = size;
            }
        }
        shift(action, next, nextEnd)
        {
            let start = this.pos;
            if (action & 131072) {
                this.pushState(action & 65535, this.pos);
            } else if ((action & 262144) == 0) {
                let nextState = action,
                    {parser} = this.p;
                if (nextEnd > this.pos || next <= parser.maxNode) {
                    this.pos = nextEnd;
                    if (!parser.stateFlag(nextState, 1))
                        this.reducePos = nextEnd;
                }
                this.pushState(nextState, start);
                this.shiftContext(next, start);
                if (next <= parser.maxNode)
                    this.buffer.push(next, start, nextEnd, 4);
            } else {
                this.pos = nextEnd;
                this.shiftContext(next, start);
                if (next <= this.p.parser.maxNode)
                    this.buffer.push(next, start, nextEnd, 4);
            }
        }
        apply(action, next, nextEnd)
        {
            if (action & 65536)
                this.reduce(action);
            else
                this.shift(action, next, nextEnd);
        }
        useNode(value, next)
        {
            let index = this.p.reused.length - 1;
            if (index < 0 || this.p.reused[index] != value) {
                this.p.reused.push(value);
                index++;
            }
            let start = this.pos;
            this.reducePos = this.pos = start + value.length;
            this.pushState(next, start);
            this.buffer.push(index, start, this.reducePos, -1);
            if (this.curContext)
                this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
        }
        split()
        {
            let parent = this;
            let off = parent.buffer.length;
            while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
                off -= 4;
            let buffer = parent.buffer.slice(off),
                base = parent.bufferBase + off;
            while (parent && base == parent.bufferBase)
                parent = parent.parent;
            return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
        }
        recoverByDelete(next, nextEnd)
        {
            let isNode = next <= this.p.parser.maxNode;
            if (isNode)
                this.storeNode(next, this.pos, nextEnd, 4);
            this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
            this.pos = this.reducePos = nextEnd;
            this.score -= 190;
        }
        canShift(term)
        {
            for (let sim = new SimulatedStack(this); ;) {
                let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
                if (action == 0)
                    return false;
                if ((action & 65536) == 0)
                    return true;
                sim.reduce(action);
            }
        }
        recoverByInsert(next)
        {
            if (this.stack.length >= 300)
                return [];
            let nextStates = this.p.parser.nextStates(this.state);
            if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
                let best = [];
                for (let i = 0, s; i < nextStates.length; i += 2) {
                    if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                        best.push(nextStates[i], s);
                }
                if (this.stack.length < 120)
                    for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
                        let s = nextStates[i + 1];
                        if (!best.some((v, i) => i & 1 && v == s))
                            best.push(nextStates[i], s);
                    }
                nextStates = best;
            }
            let result = [];
            for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
                let s = nextStates[i + 1];
                if (s == this.state)
                    continue;
                let stack = this.split();
                stack.pushState(s, this.pos);
                stack.storeNode(0, stack.pos, stack.pos, 4, true);
                stack.shiftContext(nextStates[i], this.pos);
                stack.score -= 200;
                result.push(stack);
            }
            return result;
        }
        forceReduce()
        {
            let reduce = this.p.parser.stateSlot(this.state, 5);
            if ((reduce & 65536) == 0)
                return false;
            let {parser} = this.p;
            if (!parser.validAction(this.state, reduce)) {
                let depth = reduce >> 19,
                    term = reduce & 65535;
                let target = this.stack.length - depth * 3;
                if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)
                    return false;
                this.storeNode(0, this.reducePos, this.reducePos, 4, true);
                this.score -= 100;
            }
            this.reducePos = this.pos;
            this.reduce(reduce);
            return true;
        }
        forceAll()
        {
            while (!this.p.parser.stateFlag(this.state, 2)) {
                if (!this.forceReduce()) {
                    this.storeNode(0, this.pos, this.pos, 4, true);
                    break;
                }
            }
            return this;
        }
        get deadEnd()
        {
            if (this.stack.length != 3)
                return false;
            let {parser} = this.p;
            return parser.data[parser.stateSlot(this.state, 1)] == 65535 && !parser.stateSlot(this.state, 4);
        }
        restart()
        {
            this.state = this.stack[0];
            this.stack.length = 0;
        }
        sameState(other)
        {
            if (this.state != other.state || this.stack.length != other.stack.length)
                return false;
            for (let i = 0; i < this.stack.length; i += 3)
                if (this.stack[i] != other.stack[i])
                    return false;
            return true;
        }
        get parser()
        {
            return this.p.parser;
        }
        dialectEnabled(dialectID)
        {
            return this.p.parser.dialect.flags[dialectID];
        }
        shiftContext(term, start)
        {
            if (this.curContext)
                this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
        }
        reduceContext(term, start)
        {
            if (this.curContext)
                this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
        }
        emitContext()
        {
            let last = this.buffer.length - 1;
            if (last < 0 || this.buffer[last] != -3)
                this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
        }
        emitLookAhead()
        {
            let last = this.buffer.length - 1;
            if (last < 0 || this.buffer[last] != -4)
                this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
        }
        updateContext(context)
        {
            if (context != this.curContext.context) {
                let newCx = new StackContext(this.curContext.tracker, context);
                if (newCx.hash != this.curContext.hash)
                    this.emitContext();
                this.curContext = newCx;
            }
        }
        setLookAhead(lookAhead)
        {
            if (lookAhead > this.lookAhead) {
                this.emitLookAhead();
                this.lookAhead = lookAhead;
            }
        }
        close()
        {
            if (this.curContext && this.curContext.tracker.strict)
                this.emitContext();
            if (this.lookAhead > 0)
                this.emitLookAhead();
        }
    }
    class StackContext {
        constructor(tracker, context)
        {
            this.tracker = tracker;
            this.context = context;
            this.hash = tracker.strict ? tracker.hash(context) : 0;
        }
    }
    var Recover;
    (function(Recover) {
        Recover[Recover["Insert"] = 200] = "Insert";
        Recover[Recover["Delete"] = 190] = "Delete";
        Recover[Recover["Reduce"] = 100] = "Reduce";
        Recover[Recover["MaxNext"] = 4] = "MaxNext";
        Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
        Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
    })(Recover || (Recover = {}));
    class SimulatedStack {
        constructor(start)
        {
            this.start = start;
            this.state = start.state;
            this.stack = start.stack;
            this.base = this.stack.length;
        }
        reduce(action)
        {
            let term = action & 65535,
                depth = action >> 19;
            if (depth == 0) {
                if (this.stack == this.start.stack)
                    this.stack = this.stack.slice();
                this.stack.push(this.state, 0, 0);
                this.base += 3;
            } else {
                this.base -= (depth - 1) * 3;
            }
            let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
            this.state = goto;
        }
    }
    class StackBufferCursor {
        constructor(stack, pos, index)
        {
            this.stack = stack;
            this.pos = pos;
            this.index = index;
            this.buffer = stack.buffer;
            if (this.index == 0)
                this.maybeNext();
        }
        static create(stack, pos=stack.bufferBase + stack.buffer.length)
        {
            return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
        }
        maybeNext()
        {
            let next = this.stack.parent;
            if (next != null) {
                this.index = this.stack.bufferBase - next.bufferBase;
                this.stack = next;
                this.buffer = next.buffer;
            }
        }
        get id()
        {
            return this.buffer[this.index - 4];
        }
        get start()
        {
            return this.buffer[this.index - 3];
        }
        get end()
        {
            return this.buffer[this.index - 2];
        }
        get size()
        {
            return this.buffer[this.index - 1];
        }
        next()
        {
            this.index -= 4;
            this.pos -= 4;
            if (this.index == 0)
                this.maybeNext();
        }
        fork()
        {
            return new StackBufferCursor(this.stack, this.pos, this.index);
        }
    }
    class CachedToken {
        constructor()
        {
            this.start = -1;
            this.value = -1;
            this.end = -1;
            this.extended = -1;
            this.lookAhead = 0;
            this.mask = 0;
            this.context = 0;
        }
    }
    const nullToken = new CachedToken();
    class InputStream {
        constructor(input, ranges)
        {
            this.input = input;
            this.ranges = ranges;
            this.chunk = "";
            this.chunkOff = 0;
            this.chunk2 = "";
            this.chunk2Pos = 0;
            this.next = -1;
            this.token = nullToken;
            this.rangeIndex = 0;
            this.pos = this.chunkPos = ranges[0].from;
            this.range = ranges[0];
            this.end = ranges[ranges.length - 1].to;
            this.readNext();
        }
        resolveOffset(offset, assoc)
        {
            let range = this.range,
                index = this.rangeIndex;
            let pos = this.pos + offset;
            while (pos < range.from) {
                if (!index)
                    return null;
                let next = this.ranges[--index];
                pos -= range.from - next.to;
                range = next;
            }
            while (assoc < 0 ? pos > range.to : pos >= range.to) {
                if (index == this.ranges.length - 1)
                    return null;
                let next = this.ranges[++index];
                pos += next.from - range.to;
                range = next;
            }
            return pos;
        }
        clipPos(pos)
        {
            if (pos >= this.range.from && pos < this.range.to)
                return pos;
            for (let _i236 = 0, _this$ranges2 = this.ranges, _length236 = _this$ranges2.length; _i236 < _length236; _i236++) {
                let range = _this$ranges2[_i236];
                if (range.to > pos)
                    return Math.max(pos, range.from);
            }
            return this.end;
        }
        peek(offset)
        {
            let idx = this.chunkOff + offset,
                pos,
                result;
            if (idx >= 0 && idx < this.chunk.length) {
                pos = this.pos + offset;
                result = this.chunk.charCodeAt(idx);
            } else {
                let resolved = this.resolveOffset(offset, 1);
                if (resolved == null)
                    return -1;
                pos = resolved;
                if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                    result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
                } else {
                    let i = this.rangeIndex,
                        range = this.range;
                    while (range.to <= pos)
                        range = this.ranges[++i];
                    this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                    if (pos + this.chunk2.length > range.to)
                        this.chunk2 = this.chunk2.slice(0, range.to - pos);
                    result = this.chunk2.charCodeAt(0);
                }
            }
            if (pos >= this.token.lookAhead)
                this.token.lookAhead = pos + 1;
            return result;
        }
        acceptToken(token, endOffset=0)
        {
            let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
            if (end == null || end < this.token.start)
                throw new RangeError("Token end out of bounds");
            this.token.value = token;
            this.token.end = end;
        }
        getChunk()
        {
            if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
                let {chunk, chunkPos} = this;
                this.chunk = this.chunk2;
                this.chunkPos = this.chunk2Pos;
                this.chunk2 = chunk;
                this.chunk2Pos = chunkPos;
                this.chunkOff = this.pos - this.chunkPos;
            } else {
                this.chunk2 = this.chunk;
                this.chunk2Pos = this.chunkPos;
                let nextChunk = this.input.chunk(this.pos);
                let end = this.pos + nextChunk.length;
                this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
                this.chunkPos = this.pos;
                this.chunkOff = 0;
            }
        }
        readNext()
        {
            if (this.chunkOff >= this.chunk.length) {
                this.getChunk();
                if (this.chunkOff == this.chunk.length)
                    return this.next = -1;
            }
            return this.next = this.chunk.charCodeAt(this.chunkOff);
        }
        advance(n=1)
        {
            this.chunkOff += n;
            while (this.pos + n >= this.range.to) {
                if (this.rangeIndex == this.ranges.length - 1)
                    return this.setDone();
                n -= this.range.to - this.pos;
                this.range = this.ranges[++this.rangeIndex];
                this.pos = this.range.from;
            }
            this.pos += n;
            if (this.pos >= this.token.lookAhead)
                this.token.lookAhead = this.pos + 1;
            return this.readNext();
        }
        setDone()
        {
            this.pos = this.chunkPos = this.end;
            this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
            this.chunk = "";
            return this.next = -1;
        }
        reset(pos, token)
        {
            if (token) {
                this.token = token;
                token.start = pos;
                token.lookAhead = pos + 1;
                token.value = token.extended = -1;
            } else {
                this.token = nullToken;
            }
            if (this.pos != pos) {
                this.pos = pos;
                if (pos == this.end) {
                    this.setDone();
                    return this;
                }
                while (pos < this.range.from)
                    this.range = this.ranges[--this.rangeIndex];
                while (pos >= this.range.to)
                    this.range = this.ranges[++this.rangeIndex];
                if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                    this.chunkOff = pos - this.chunkPos;
                } else {
                    this.chunk = "";
                    this.chunkOff = 0;
                }
                this.readNext();
            }
            return this;
        }
        read(from, to)
        {
            if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
                return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
            if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
                return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
            if (from >= this.range.from && to <= this.range.to)
                return this.input.read(from, to);
            let result = "";
            for (let _i237 = 0, _this$ranges3 = this.ranges, _length237 = _this$ranges3.length; _i237 < _length237; _i237++) {
                let r = _this$ranges3[_i237];
                if (r.from >= to)
                    break;
                if (r.to > from)
                    result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
            }
            return result;
        }
    }
    class TokenGroup {
        constructor(data, id)
        {
            this.data = data;
            this.id = id;
        }
        token(input, stack)
        {
            readToken(this.data, input, stack, this.id);
        }
    }
    TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
    class ExternalTokenizer {
        constructor(token, options={})
        {
            this.token = token;
            this.contextual = !!options.contextual;
            this.fallback = !!options.fallback;
            this.extend = !!options.extend;
        }
    }
    function readToken(data, input, stack, group) {
        let state = 0,
            groupMask = 1 << group,
            {parser} = stack.p,
            {dialect} = parser;
        scan:
        for (;;) {
            if ((groupMask & data[state]) == 0)
                break;
            let accEnd = data[state + 1];
            for (let i = state + 3; i < accEnd; i += 2)
                if ((data[i + 1] & groupMask) > 0) {
                    let term = data[i];
                    if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
                        input.acceptToken(term);
                        break;
                    }
                }
            let next = input.next,
                low = 0,
                high = data[state + 2];
            if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 && data[accEnd + high * 3 - 3] == 65535) {
                state = data[accEnd + high * 3 - 1];
                continue scan;
            }
            for (; low < high;) {
                let mid = low + high >> 1;
                let index = accEnd + mid + (mid << 1);
                let from = data[index],
                    to = data[index + 1] || 0x10000;
                if (next < from)
                    high = mid;
                else if (next >= to)
                    low = mid + 1;
                else {
                    state = data[index + 2];
                    input.advance();
                    continue scan;
                }
            }
            break;
        }
    }
    function decodeArray(input, Type=Uint16Array) {
        if (typeof input != "string")
            return input;
        let array = null;
        for (let pos = 0, out = 0; pos < input.length;) {
            let value = 0;
            for (;;) {
                let next = input.charCodeAt(pos++),
                    stop = false;
                if (next == 126) {
                    value = 65535;
                    break;
                }
                if (next >= 92)
                    next--;
                if (next >= 34)
                    next--;
                let digit = next - 32;
                if (digit >= 46) {
                    digit -= 46;
                    stop = true;
                }
                value += digit;
                if (stop)
                    break;
                value *= 46;
            }
            if (array)
                array[out++] = value;
            else
                array = new Type(value);
        }
        return array;
    }
    const verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
    let stackIDs = null;
    var Safety;
    (function(Safety) {
        Safety[Safety["Margin"] = 25] = "Margin";
    })(Safety || (Safety = {}));
    function cutAt(tree, pos, side) {
        let cursor = tree.cursor(IterMode.IncludeAnonymous);
        cursor.moveTo(pos);
        for (;;) {
            if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
                for (;;) {
                    if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                        return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
                    if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        return side < 0 ? 0 : tree.length;
                }
        }
    }
    class FragmentCursor$1 {
        constructor(fragments, nodeSet)
        {
            this.fragments = fragments;
            this.nodeSet = nodeSet;
            this.i = 0;
            this.fragment = null;
            this.safeFrom = -1;
            this.safeTo = -1;
            this.trees = [];
            this.start = [];
            this.index = [];
            this.nextFragment();
        }
        nextFragment()
        {
            let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
            if (fr) {
                this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
                this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
                while (this.trees.length) {
                    this.trees.pop();
                    this.start.pop();
                    this.index.pop();
                }
                this.trees.push(fr.tree);
                this.start.push(-fr.offset);
                this.index.push(0);
                this.nextStart = this.safeFrom;
            } else {
                this.nextStart = 1e9;
            }
        }
        nodeAt(pos)
        {
            if (pos < this.nextStart)
                return null;
            while (this.fragment && this.safeTo <= pos)
                this.nextFragment();
            if (!this.fragment)
                return null;
            for (;;) {
                let last = this.trees.length - 1;
                if (last < 0) {
                    this.nextFragment();
                    return null;
                }
                let top = this.trees[last],
                    index = this.index[last];
                if (index == top.children.length) {
                    this.trees.pop();
                    this.start.pop();
                    this.index.pop();
                    continue;
                }
                let next = top.children[index];
                let start = this.start[last] + top.positions[index];
                if (start > pos) {
                    this.nextStart = start;
                    return null;
                }
                if (next instanceof Tree) {
                    if (start == pos) {
                        if (start < this.safeFrom)
                            return null;
                        let end = start + next.length;
                        if (end <= this.safeTo) {
                            let lookAhead = next.prop(NodeProp.lookAhead);
                            if (!lookAhead || end + lookAhead < this.fragment.to)
                                return next;
                        }
                    }
                    this.index[last]++;
                    if (start + next.length >= Math.max(this.safeFrom, pos)) {
                        this.trees.push(next);
                        this.start.push(start);
                        this.index.push(0);
                    }
                } else {
                    this.index[last]++;
                    this.nextStart = start + next.length;
                }
            }
        }
    }
    class TokenCache {
        constructor(parser, stream)
        {
            this.stream = stream;
            this.tokens = [];
            this.mainToken = null;
            this.actions = [];
            this.tokens = parser.tokenizers.map(_ => new CachedToken());
        }
        getActions(stack)
        {
            let actionIndex = 0;
            let main = null;
            let {parser} = stack.p,
                {tokenizers} = parser;
            let mask = parser.stateSlot(stack.state, 3);
            let context = stack.curContext ? stack.curContext.hash : 0;
            let lookAhead = 0;
            for (let i = 0; i < tokenizers.length; i++) {
                if ((1 << i & mask) == 0)
                    continue;
                let tokenizer = tokenizers[i],
                    token = this.tokens[i];
                if (main && !tokenizer.fallback)
                    continue;
                if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                    this.updateCachedToken(token, tokenizer, stack);
                    token.mask = mask;
                    token.context = context;
                }
                if (token.lookAhead > token.end + 25)
                    lookAhead = Math.max(token.lookAhead, lookAhead);
                if (token.value != 0) {
                    let startIndex = actionIndex;
                    if (token.extended > -1)
                        actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                    actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                    if (!tokenizer.extend) {
                        main = token;
                        if (actionIndex > startIndex)
                            break;
                    }
                }
            }
            while (this.actions.length > actionIndex)
                this.actions.pop();
            if (lookAhead)
                stack.setLookAhead(lookAhead);
            if (!main && stack.pos == this.stream.end) {
                main = new CachedToken();
                main.value = stack.p.parser.eofTerm;
                main.start = main.end = stack.pos;
                actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
            }
            this.mainToken = main;
            return this.actions;
        }
        getMainToken(stack)
        {
            if (this.mainToken)
                return this.mainToken;
            let main = new CachedToken(),
                {pos, p} = stack;
            main.start = pos;
            main.end = Math.min(pos + 1, p.stream.end);
            main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
            return main;
        }
        updateCachedToken(token, tokenizer, stack)
        {
            let start = this.stream.clipPos(stack.pos);
            tokenizer.token(this.stream.reset(start, token), stack);
            if (token.value > -1) {
                let {parser} = stack.p;
                for (let i = 0; i < parser.specialized.length; i++)
                    if (parser.specialized[i] == token.value) {
                        let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                        if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                            if ((result & 1) == 0)
                                token.value = result >> 1;
                            else
                                token.extended = result >> 1;
                            break;
                        }
                    }
            } else {
                token.value = 0;
                token.end = this.stream.clipPos(start + 1);
            }
        }
        putAction(action, token, end, index)
        {
            for (let i = 0; i < index; i += 3)
                if (this.actions[i] == action)
                    return index;
            this.actions[index++] = action;
            this.actions[index++] = token;
            this.actions[index++] = end;
            return index;
        }
        addActions(stack, token, end, index)
        {
            let {state} = stack,
                {parser} = stack.p,
                {data} = parser;
            for (let set = 0; set < 2; set++) {
                for (let i = parser.stateSlot(state, set ? 2 : 1); ; i += 3) {
                    if (data[i] == 65535) {
                        if (data[i + 1] == 1) {
                            i = pair(data, i + 2);
                        } else {
                            if (index == 0 && data[i + 1] == 2)
                                index = this.putAction(pair(data, i + 2), token, end, index);
                            break;
                        }
                    }
                    if (data[i] == token)
                        index = this.putAction(pair(data, i + 1), token, end, index);
                }
            }
            return index;
        }
    }
    var Rec;
    (function(Rec) {
        Rec[Rec["Distance"] = 5] = "Distance";
        Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
        Rec[Rec["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
        Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
        Rec[Rec["CutDepth"] = 15000] = "CutDepth";
        Rec[Rec["CutTo"] = 9000] = "CutTo";
    })(Rec || (Rec = {}));
    class Parse {
        constructor(parser, input, fragments, ranges)
        {
            this.parser = parser;
            this.input = input;
            this.ranges = ranges;
            this.recovering = 0;
            this.nextStackID = 0x2654;
            this.minStackPos = 0;
            this.reused = [];
            this.stoppedAt = null;
            this.stream = new InputStream(input, ranges);
            this.tokens = new TokenCache(parser, this.stream);
            this.topTerm = parser.top[1];
            let {from} = ranges[0];
            this.stacks = [Stack.start(this, parser.top[0], from)];
            this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor$1(fragments, parser.nodeSet) : null;
        }
        get parsedPos()
        {
            return this.minStackPos;
        }
        advance()
        {
            let stacks = this.stacks,
                pos = this.minStackPos;
            let newStacks = this.stacks = [];
            let stopped,
                stoppedTokens;
            for (let i = 0; i < stacks.length; i++) {
                let stack = stacks[i];
                for (;;) {
                    this.tokens.mainToken = null;
                    if (stack.pos > pos) {
                        newStacks.push(stack);
                    } else if (this.advanceStack(stack, newStacks, stacks)) {
                        continue;
                    } else {
                        if (!stopped) {
                            stopped = [];
                            stoppedTokens = [];
                        }
                        stopped.push(stack);
                        let tok = this.tokens.getMainToken(stack);
                        stoppedTokens.push(tok.value, tok.end);
                    }
                    break;
                }
            }
            if (!newStacks.length) {
                let finished = stopped && findFinished(stopped);
                if (finished)
                    return this.stackToTree(finished);
                if (this.parser.strict) {
                    if (verbose && stopped)
                        console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                    throw new SyntaxError("No parse at " + pos);
                }
                if (!this.recovering)
                    this.recovering = 5;
            }
            if (this.recovering && stopped) {
                let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
                if (finished)
                    return this.stackToTree(finished.forceAll());
            }
            if (this.recovering) {
                let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
                if (newStacks.length > maxRemaining) {
                    newStacks.sort((a, b) => b.score - a.score);
                    while (newStacks.length > maxRemaining)
                        newStacks.pop();
                }
                if (newStacks.some(s => s.reducePos > pos))
                    this.recovering--;
            } else if (newStacks.length > 1) {
                outer:
                for (let i = 0; i < newStacks.length - 1; i++) {
                    let stack = newStacks[i];
                    for (let j = i + 1; j < newStacks.length; j++) {
                        let other = newStacks[j];
                        if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
                            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                                newStacks.splice(j--, 1);
                            } else {
                                newStacks.splice(i--, 1);
                                continue outer;
                            }
                        }
                    }
                }
            }
            this.minStackPos = newStacks[0].pos;
            for (let i = 1; i < newStacks.length; i++)
                if (newStacks[i].pos < this.minStackPos)
                    this.minStackPos = newStacks[i].pos;
            return null;
        }
        stopAt(pos)
        {
            if (this.stoppedAt != null && this.stoppedAt < pos)
                throw new RangeError("Can't move stoppedAt forward");
            this.stoppedAt = pos;
        }
        advanceStack(stack, stacks, split)
        {
            let start = stack.pos,
                {parser} = this;
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (this.stoppedAt != null && start > this.stoppedAt)
                return stack.forceReduce() ? stack : null;
            if (this.fragments) {
                let strictCx = stack.curContext && stack.curContext.tracker.strict,
                    cxHash = strictCx ? stack.curContext.hash : 0;
                for (let cached = this.fragments.nodeAt(start); cached;) {
                    let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                    if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
                        stack.useNode(cached, match);
                        if (verbose)
                            console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                        return true;
                    }
                    if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                        break;
                    let inner = cached.children[0];
                    if (inner instanceof Tree && cached.positions[0] == 0)
                        cached = inner;
                    else
                        break;
                }
            }
            let defaultReduce = parser.stateSlot(stack.state, 4);
            if (defaultReduce > 0) {
                stack.reduce(defaultReduce);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535)})`);
                return true;
            }
            if (stack.stack.length >= 15000) {
                while (stack.stack.length > 9000 && stack.forceReduce()) {}
            }
            let actions = this.tokens.getActions(stack);
            for (let i = 0; i < actions.length;) {
                let action = actions[i++],
                    term = actions[i++],
                    end = actions[i++];
                let last = i == actions.length || !split;
                let localStack = last ? stack : stack.split();
                localStack.apply(action, term, end);
                if (verbose)
                    console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser.getName(action & 65535)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
                if (last)
                    return true;
                else if (localStack.pos > start)
                    stacks.push(localStack);
                else
                    split.push(localStack);
            }
            return false;
        }
        advanceFully(stack, newStacks)
        {
            let pos = stack.pos;
            for (;;) {
                if (!this.advanceStack(stack, null, null))
                    return false;
                if (stack.pos > pos) {
                    pushStackDedup(stack, newStacks);
                    return true;
                }
            }
        }
        runRecovery(stacks, tokens, newStacks)
        {
            let finished = null,
                restarted = false;
            for (let i = 0; i < stacks.length; i++) {
                let stack = stacks[i],
                    token = tokens[i << 1],
                    tokenEnd = tokens[(i << 1) + 1];
                let base = verbose ? this.stackID(stack) + " -> " : "";
                if (stack.deadEnd) {
                    if (restarted)
                        continue;
                    restarted = true;
                    stack.restart();
                    if (verbose)
                        console.log(base + this.stackID(stack) + " (restarted)");
                    let done = this.advanceFully(stack, newStacks);
                    if (done)
                        continue;
                }
                let force = stack.split(),
                    forceBase = base;
                for (let j = 0; force.forceReduce() && j < 10; j++) {
                    if (verbose)
                        console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                    let done = this.advanceFully(force, newStacks);
                    if (done)
                        break;
                    if (verbose)
                        forceBase = this.stackID(force) + " -> ";
                }
                for (let _i238 = 0, _stack$recoverByInser = stack.recoverByInsert(token), _length238 = _stack$recoverByInser.length; _i238 < _length238; _i238++) {
                    let insert = _stack$recoverByInser[_i238];
                    if (verbose)
                        console.log(base + this.stackID(insert) + " (via recover-insert)");
                    this.advanceFully(insert, newStacks);
                }
                if (this.stream.end > stack.pos) {
                    if (tokenEnd == stack.pos) {
                        tokenEnd++;
                        token = 0;
                    }
                    stack.recoverByDelete(token, tokenEnd);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                    pushStackDedup(stack, newStacks);
                } else if (!finished || finished.score < stack.score) {
                    finished = stack;
                }
            }
            return finished;
        }
        stackToTree(stack)
        {
            stack.close();
            return Tree.build({
                buffer: StackBufferCursor.create(stack),
                nodeSet: this.parser.nodeSet,
                topID: this.topTerm,
                maxBufferLength: this.parser.bufferLength,
                reused: this.reused,
                start: this.ranges[0].from,
                length: stack.pos - this.ranges[0].from,
                minRepeatType: this.parser.minRepeatTerm
            });
        }
        stackID(stack)
        {
            let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);
            if (!id)
                stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
            return id + stack;
        }
    }
    function pushStackDedup(stack, newStacks) {
        for (let i = 0; i < newStacks.length; i++) {
            let other = newStacks[i];
            if (other.pos == stack.pos && other.sameState(stack)) {
                if (newStacks[i].score < stack.score)
                    newStacks[i] = stack;
                return;
            }
        }
        newStacks.push(stack);
    }
    class Dialect {
        constructor(source, flags, disabled)
        {
            this.source = source;
            this.flags = flags;
            this.disabled = disabled;
        }
        allows(term)
        {
            return !this.disabled || this.disabled[term] == 0;
        }
    }
    const id = x => x;
    class ContextTracker {
        constructor(spec)
        {
            this.start = spec.start;
            this.shift = spec.shift || id;
            this.reduce = spec.reduce || id;
            this.reuse = spec.reuse || id;
            this.hash = spec.hash || (() => 0);
            this.strict = spec.strict !== false;
        }
    }
    class LRParser extends Parser {
        constructor(spec)
        {
            super();
            this.wrappers = [];
            if (spec.version != 14)
                throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
            let nodeNames = spec.nodeNames.split(" ");
            this.minRepeatTerm = nodeNames.length;
            for (let i = 0; i < spec.repeatNodeCount; i++)
                nodeNames.push("");
            let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
            let nodeProps = [];
            for (let i = 0; i < nodeNames.length; i++)
                nodeProps.push([]);
            function setProp(nodeID, prop, value) {
                nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
            }
            if (spec.nodeProps)
                for (let _i239 = 0, _spec$nodeProps = spec.nodeProps, _length239 = _spec$nodeProps.length; _i239 < _length239; _i239++) {
                    let propSpec = _spec$nodeProps[_i239];
                    let prop = propSpec[0];
                    if (typeof prop == "string")
                        prop = NodeProp[prop];
                    for (let i = 1; i < propSpec.length;) {
                        let next = propSpec[i++];
                        if (next >= 0) {
                            setProp(next, prop, propSpec[i++]);
                        } else {
                            let value = propSpec[i + -next];
                            for (let j = -next; j > 0; j--)
                                setProp(propSpec[i++], prop, value);
                            i++;
                        }
                    }
                }
            this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({
                name: i >= this.minRepeatTerm ? undefined : name,
                id: i,
                props: nodeProps[i],
                top: topTerms.indexOf(i) > -1,
                error: i == 0,
                skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
            })));
            if (spec.propSources)
                this.nodeSet = this.nodeSet.extend(...spec.propSources);
            this.strict = false;
            this.bufferLength = DefaultBufferLength;
            let tokenArray = decodeArray(spec.tokenData);
            this.context = spec.context;
            this.specializerSpecs = spec.specialized || [];
            this.specialized = new Uint16Array(this.specializerSpecs.length);
            for (let i = 0; i < this.specializerSpecs.length; i++)
                this.specialized[i] = this.specializerSpecs[i].term;
            this.specializers = this.specializerSpecs.map(getSpecializer);
            this.states = decodeArray(spec.states, Uint32Array);
            this.data = decodeArray(spec.stateData);
            this.goto = decodeArray(spec.goto);
            this.maxTerm = spec.maxTerm;
            this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
            this.topRules = spec.topRules;
            this.dialects = spec.dialects || {};
            this.dynamicPrecedences = spec.dynamicPrecedences || null;
            this.tokenPrecTable = spec.tokenPrec;
            this.termNames = spec.termNames || null;
            this.maxNode = this.nodeSet.types.length - 1;
            this.dialect = this.parseDialect();
            this.top = this.topRules[Object.keys(this.topRules)[0]];
        }
        createParse(input, fragments, ranges)
        {
            let parse = new Parse(this, input, fragments, ranges);
            for (let _i240 = 0, _this$wrappers = this.wrappers, _length240 = _this$wrappers.length; _i240 < _length240; _i240++) {
                let w = _this$wrappers[_i240];
                parse = w(parse, input, fragments, ranges);
            }
            return parse;
        }
        getGoto(state, term, loose=false)
        {
            let table = this.goto;
            if (term >= table[0])
                return -1;
            for (let pos = table[term + 1]; ;) {
                let groupTag = table[pos++],
                    last = groupTag & 1;
                let target = table[pos++];
                if (last && loose)
                    return target;
                for (let end = pos + (groupTag >> 1); pos < end; pos++)
                    if (table[pos] == state)
                        return target;
                if (last)
                    return -1;
            }
        }
        hasAction(state, terminal)
        {
            let data = this.data;
            for (let set = 0; set < 2; set++) {
                for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
                    if ((next = data[i]) == 65535) {
                        if (data[i + 1] == 1)
                            next = data[i = pair(data, i + 2)];
                        else if (data[i + 1] == 2)
                            return pair(data, i + 2);
                        else
                            break;
                    }
                    if (next == terminal || next == 0)
                        return pair(data, i + 1);
                }
            }
            return 0;
        }
        stateSlot(state, slot)
        {
            return this.states[state * 6 + slot];
        }
        stateFlag(state, flag)
        {
            return (this.stateSlot(state, 0) & flag) > 0;
        }
        validAction(state, action)
        {
            if (action == this.stateSlot(state, 4))
                return true;
            for (let i = this.stateSlot(state, 1); ; i += 3) {
                if (this.data[i] == 65535) {
                    if (this.data[i + 1] == 1)
                        i = pair(this.data, i + 2);
                    else
                        return false;
                }
                if (action == pair(this.data, i + 1))
                    return true;
            }
        }
        nextStates(state)
        {
            let result = [];
            for (let i = this.stateSlot(state, 1); ; i += 3) {
                if (this.data[i] == 65535) {
                    if (this.data[i + 1] == 1)
                        i = pair(this.data, i + 2);
                    else
                        break;
                }
                if ((this.data[i + 2] & 65536 >> 16) == 0) {
                    let value = this.data[i + 1];
                    if (!result.some((v, i) => i & 1 && v == value))
                        result.push(this.data[i], value);
                }
            }
            return result;
        }
        overrides(token, prev)
        {
            let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
            return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
        }
        configure(config)
        {
            let copy = Object.assign(Object.create(LRParser.prototype), this);
            if (config.props)
                copy.nodeSet = this.nodeSet.extend(...config.props);
            if (config.top) {
                let info = this.topRules[config.top];
                if (!info)
                    throw new RangeError(`Invalid top rule name ${config.top}`);
                copy.top = info;
            }
            if (config.tokenizers)
                copy.tokenizers = this.tokenizers.map(t => {
                    let found = config.tokenizers.find(r => r.from == t);
                    return found ? found.to : t;
                });
            if (config.specializers) {
                copy.specializers = this.specializers.slice();
                copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
                    let found = config.specializers.find(r => r.from == s.external);
                    if (!found)
                        return s;
                    let spec = Object.assign(Object.assign({}, s), {
                        external: found.to
                    });
                    copy.specializers[i] = getSpecializer(spec);
                    return spec;
                });
            }
            if (config.contextTracker)
                copy.context = config.contextTracker;
            if (config.dialect)
                copy.dialect = this.parseDialect(config.dialect);
            if (config.strict != null)
                copy.strict = config.strict;
            if (config.wrap)
                copy.wrappers = copy.wrappers.concat(config.wrap);
            if (config.bufferLength != null)
                copy.bufferLength = config.bufferLength;
            return copy;
        }
        hasWrappers()
        {
            return this.wrappers.length > 0;
        }
        getName(term)
        {
            return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
        }
        get eofTerm()
        {
            return this.maxNode + 1;
        }
        get topNode()
        {
            return this.nodeSet.types[this.top[1]];
        }
        dynamicPrecedence(term)
        {
            let prec = this.dynamicPrecedences;
            return prec == null ? 0 : prec[term] || 0;
        }
        parseDialect(dialect)
        {
            let values = Object.keys(this.dialects),
                flags = values.map(() => false);
            if (dialect)
                for (let _i241 = 0, _dialect$split = dialect.split(" "), _length241 = _dialect$split.length; _i241 < _length241; _i241++) {
                    let part = _dialect$split[_i241];
                    let id = values.indexOf(part);
                    if (id >= 0)
                        flags[id] = true;
                }
            let disabled = null;
            for (let i = 0; i < values.length; i++)
                if (!flags[i]) {
                    for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535;)
                        (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
                }
            return new Dialect(dialect, flags, disabled);
        }
        static deserialize(spec)
        {
            return new LRParser(spec);
        }
    }
    function pair(data, off) {
        return data[off] | data[off + 1] << 16;
    }
    function findOffset(data, start, term) {
        for (let i = start, next; (next = data[i]) != 65535; i++)
            if (next == term)
                return i - start;
        return -1;
    }
    function findFinished(stacks) {
        let best = null;
        for (let _i242 = 0, _length242 = stacks.length; _i242 < _length242; _i242++) {
            let stack = stacks[_i242];
            let stopped = stack.p.stoppedAt;
            if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
                best = stack;
        }
        return best;
    }
    function getSpecializer(spec) {
        if (spec.external) {
            let mask = spec.extend ? 1 : 0;
            return (value, stack) => spec.external(value, stack) << 1 | mask;
        }
        return spec.get;
    }
    var _m25 = Object.freeze({
        __proto__: null,
        ContextTracker: ContextTracker,
        ExternalTokenizer: ExternalTokenizer,
        InputStream: InputStream,
        LRParser: LRParser,
        Stack: Stack
    });
    const TSExtends = 1,
        noSemi = 294,
        incdec = 2,
        incdecPrefix = 3,
        templateContent = 295,
        InterpolationStart = 4,
        templateEnd = 296,
        insertSemi = 297,
        spaces = 299,
        newline$2 = 300,
        LineComment$1 = 5,
        BlockComment$1 = 6,
        Dialect_ts = 1;
    const space$3 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];
    const braceR = 125,
        braceL = 123,
        semicolon$1 = 59,
        slash$1 = 47,
        star = 42,
        plus = 43,
        minus = 45,
        dollar = 36,
        backtick = 96,
        backslash = 92;
    const trackNewline = new ContextTracker({
        start: false,
        shift(context, term) {
            return term == LineComment$1 || term == BlockComment$1 || term == spaces ? context : term == newline$2;
        },
        strict: false
    });
    const insertSemicolon = new ExternalTokenizer((input, stack) => {
        let {next} = input;
        if ((next == braceR || next == -1 || stack.context) && stack.canShift(insertSemi))
            input.acceptToken(insertSemi);
    }, {
        contextual: true,
        fallback: true
    });
    const noSemicolon = new ExternalTokenizer((input, stack) => {
        let {next} = input,
            after;
        if (space$3.indexOf(next) > -1)
            return;
        if (next == slash$1 && ((after = input.peek(1)) == slash$1 || after == star))
            return;
        if (next != braceR && next != semicolon$1 && next != -1 && !stack.context && stack.canShift(noSemi))
            input.acceptToken(noSemi);
    }, {
        contextual: true
    });
    const incdecToken = new ExternalTokenizer((input, stack) => {
        let {next} = input;
        if (next == plus || next == minus) {
            input.advance();
            if (next == input.next) {
                input.advance();
                let mayPostfix = !stack.context && stack.canShift(incdec);
                input.acceptToken(mayPostfix ? incdec : incdecPrefix);
            }
        }
    }, {
        contextual: true
    });
    const template = new ExternalTokenizer(input => {
        for (let afterDollar = false, i = 0; ; i++) {
            let {next} = input;
            if (next < 0) {
                if (i)
                    input.acceptToken(templateContent);
                break;
            } else if (next == backtick) {
                if (i)
                    input.acceptToken(templateContent);
                else
                    input.acceptToken(templateEnd, 1);
                break;
            } else if (next == braceL && afterDollar) {
                if (i == 1)
                    input.acceptToken(InterpolationStart, 1);
                else
                    input.acceptToken(templateContent, -1);
                break;
            } else if (next == 10 && i) {
                input.advance();
                input.acceptToken(templateContent);
                break;
            } else if (next == backslash) {
                input.advance();
            }
            afterDollar = next == dollar;
            input.advance();
        }
    });
    const tsExtends = new ExternalTokenizer((input, stack) => {
        if (input.next != 101 || !stack.dialectEnabled(Dialect_ts))
            return;
        input.advance();
        for (let i = 0; i < 6; i++) {
            if (input.next != "xtends".charCodeAt(i))
                return;
            input.advance();
        }
        if (input.next >= 57 && input.next <= 65 || input.next >= 48 && input.next <= 90 || input.next == 95 || input.next >= 97 && input.next <= 122 || input.next > 160)
            return;
        input.acceptToken(TSExtends);
    });
    const jsHighlight = styleTags({
        "get set async static": tags$1.modifier,
        "for while do if else switch try catch finally return throw break continue default case": tags$1.controlKeyword,
        "in of await yield void typeof delete instanceof": tags$1.operatorKeyword,
        "let var const function class extends": tags$1.definitionKeyword,
        "import export from": tags$1.moduleKeyword,
        "with debugger as new": tags$1.keyword,
        TemplateString: tags$1.special(tags$1.string),
        super: tags$1.atom,
        BooleanLiteral: tags$1.bool,
        this: tags$1.self,
        null: tags$1.null,
        Star: tags$1.modifier,
        VariableName: tags$1.variableName,
        "CallExpression/VariableName TaggedTemplateExpression/VariableName": tags$1.function(tags$1.variableName),
        VariableDefinition: tags$1.definition(tags$1.variableName),
        Label: tags$1.labelName,
        PropertyName: tags$1.propertyName,
        PrivatePropertyName: tags$1.special(tags$1.propertyName),
        "CallExpression/MemberExpression/PropertyName": tags$1.function(tags$1.propertyName),
        "FunctionDeclaration/VariableDefinition": tags$1.function(tags$1.definition(tags$1.variableName)),
        "ClassDeclaration/VariableDefinition": tags$1.definition(tags$1.className),
        PropertyDefinition: tags$1.definition(tags$1.propertyName),
        PrivatePropertyDefinition: tags$1.definition(tags$1.special(tags$1.propertyName)),
        UpdateOp: tags$1.updateOperator,
        LineComment: tags$1.lineComment,
        BlockComment: tags$1.blockComment,
        Number: tags$1.number,
        String: tags$1.string,
        ArithOp: tags$1.arithmeticOperator,
        LogicOp: tags$1.logicOperator,
        BitOp: tags$1.bitwiseOperator,
        CompareOp: tags$1.compareOperator,
        RegExp: tags$1.regexp,
        Equals: tags$1.definitionOperator,
        Arrow: tags$1.function(tags$1.punctuation),
        ": Spread": tags$1.punctuation,
        "( )": tags$1.paren,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace,
        "InterpolationStart InterpolationEnd": tags$1.special(tags$1.brace),
        ".": tags$1.derefOperator,
        ", ;": tags$1.separator,
        "@": tags$1.meta,
        TypeName: tags$1.typeName,
        TypeDefinition: tags$1.definition(tags$1.typeName),
        "type enum interface implements namespace module declare": tags$1.definitionKeyword,
        "abstract global Privacy readonly override": tags$1.modifier,
        "is keyof unique infer": tags$1.operatorKeyword,
        JSXAttributeValue: tags$1.attributeValue,
        JSXText: tags$1.content,
        "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags$1.angleBracket,
        "JSXIdentifier JSXNameSpacedName": tags$1.tagName,
        "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags$1.attributeName,
        "JSXBuiltin/JSXIdentifier": tags$1.standard(tags$1.tagName)
    });
    const spec_identifier$5 = {
        __proto__: null,
        export: 18,
        as: 23,
        from: 29,
        default: 32,
        async: 37,
        function: 38,
        this: 50,
        true: 58,
        false: 58,
        null: 68,
        void: 72,
        typeof: 76,
        super: 92,
        new: 126,
        await: 143,
        yield: 145,
        delete: 146,
        class: 156,
        extends: 158,
        public: 213,
        private: 213,
        protected: 213,
        readonly: 215,
        instanceof: 234,
        satisfies: 237,
        in: 238,
        const: 240,
        import: 272,
        keyof: 327,
        unique: 331,
        infer: 337,
        is: 373,
        abstract: 393,
        implements: 395,
        type: 397,
        let: 400,
        var: 402,
        interface: 409,
        enum: 413,
        namespace: 419,
        module: 421,
        declare: 425,
        global: 429,
        for: 450,
        of: 459,
        while: 462,
        with: 466,
        do: 470,
        if: 474,
        else: 476,
        switch: 480,
        case: 486,
        try: 492,
        catch: 496,
        finally: 500,
        return: 504,
        throw: 508,
        break: 512,
        continue: 516,
        debugger: 520
    };
    const spec_word = {
        __proto__: null,
        async: 113,
        get: 115,
        set: 117,
        public: 175,
        private: 175,
        protected: 175,
        static: 177,
        abstract: 179,
        override: 181,
        readonly: 187,
        accessor: 189,
        new: 377
    };
    const spec_LessThan = {
        __proto__: null,
        "<": 133
    };
    const parser$d = LRParser.deserialize({
        version: 14,
        states: "$CWO`QdOOO$}QdOOO)WQ(C|O'#ChO)_OWO'#DYO+jQdO'#D_O+zQdO'#DjO$}QdO'#DtO.OQdO'#DzOOQ(C['#ET'#ETO.fQ`O'#EQOOQO'#IW'#IWO.nQ`O'#GgOOQO'#Ee'#EeO.yQ`O'#EdO/OQ`O'#EdO1QQ(C|O'#JQO3nQ(C|O'#JRO4_Q`O'#FSO4dQ!bO'#FkOOQ(C['#F['#F[O4oO#tO'#F[O4}Q&jO'#FrO6bQ`O'#FqOOQ(C['#JR'#JROOQ(CW'#JQ'#JQOOQS'#Jk'#JkO6gQ`O'#H{O6lQ(ChO'#H|OOQS'#Iu'#IuOOQS'#IO'#IOQ`QdOOO$}QdO'#DlO6tQ`O'#GgO6yQ&jO'#CmO7XQ`O'#EcO7dQ`O'#EnO7iQ&jO'#FZO8TQ`O'#GgO8YQ`O'#GkO8eQ`O'#GkO8sQ`O'#GnO8sQ`O'#GoO8sQ`O'#GqO6tQ`O'#GtO9dQ`O'#GwO:uQ`O'#CdO;VQ`O'#HUO;_Q`O'#H[O;_Q`O'#H^O`QdO'#H`O;_Q`O'#HbO;_Q`O'#HeO;dQ`O'#HkO;iQ(CjO'#HqO$}QdO'#HsO;tQ(CjO'#HuO<PQ(CjO'#HwO6lQ(ChO'#HyO<[Q(C|O'#ChO<xQ,UO'#DdQOQ`OOO=mQaO'#D{O6yQ&jO'#EcO={Q`O'#EcO>WQpO'#FZO$}QdO'#DZOOOW'#IQ'#IQO>`OWO,59tOOQ(C[,59t,59tO>kQdO'#IRO?OQ`O'#JSOAQQtO'#JSO)jQdO'#JSOAXQ`O,59yOAoQ`O'#EeOA|Q`O'#J`OBXQ`O'#J_OBXQ`O'#J_OBaQ`O,5;ROBfQ`O'#J^OOQ(C[,5:U,5:UOBmQdO,5:UODnQ(C|O,5:`OE_Q`O,5:fOEdQ`O'#J[OF^Q(ChO'#J]O8YQ`O'#J[OFeQ`O'#J[OFmQ`O,5;QOFrQ`O'#J[OOQ(C]'#Ch'#ChO$}QdO'#DzOGfQpO,5:lOOQO'#JX'#JXOOQO-E<U-E<UO6tQ`O,5=ROG|Q`O,5=ROHRQdO,5;OOJRQ&jO'#E`OKcQ`O,5;OOLxQ&jO'#DnOMPQdO'#DsOMZQ,UO,5;XOMcQ,UO,5;XO$}QdO,5;XOOQS'#Ez'#EzOOQS'#E|'#E|O$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YOOQS'#FQ'#FQOMqQdO,5;kOOQ(C[,5;p,5;pOOQ(C[,5;q,5;qO! qQ`O,5;qOOQ(C[,5;r,5;rO$}QdO'#I^O! yQ(ChO,5<_OJRQ&jO,5;YO!!hQ&jO,5;YO$}QdO,5;nO!!oQ!bO'#FaO!#lQ!bO'#JdO!#WQ!bO'#JdO!#sQ!bO'#JdOOQO'#Jd'#JdO!$XQ!bO,5;yOOOO,5<V,5<VO!$jQdO'#FmOOOO'#I]'#I]O4oO#tO,5;vO!$qQ!bO'#FoOOQ(C[,5;v,5;vO!%bQ7]O'#CsOOQ(C]'#Cv'#CvO!%uQ`O'#CvO!%zOWO'#CzO!&hQ&kO,5<[O!&oQ`O,5<^O!(RQMhO'#F|O!(`Q`O'#F}O!(eQ`O'#F}O!(jQMhO'#GRO!)iQ,UO'#GVO!*_Q7]O'#I}OOQ(C]'#I}'#I}O!+eQaO'#I|O!+sQ`O'#I{O!+{Q`O'#CrOOQ(C]'#Ct'#CtOOQ(C]'#C}'#C}OOQ(C]'#DP'#DPO.iQ`O'#DROKhQ&jO'#FtOKhQ&jO'#FvO!,TQ`O'#FxO!,YQ`O'#FyO!(eQ`O'#GPOKhQ&jO'#GUO!,_Q`O'#EfO!,yQ`O,5<]O`QdO,5>gOOQS'#Ix'#IxOOQS,5>h,5>hOOQS-E;|-E;|O!.xQ(C|O,5:WOOQ(CX'#Cp'#CpO!/lQ&kO,5=ROOQO'#Cf'#CfO!/}Q(ChO'#IyO6bQ`O'#IyO;dQ`O,59XO!0`Q!bO,59XO!0hQ&jO,59XO6yQ&jO,59XO!0sQ`O,5;OO!0{Q`O'#HTO!1ZQ`O'#JoO$}QdO,5;sO!1cQ,UO,5;uO!1hQ`O,5=nO!1mQ`O,5=nO!1rQ`O,5=nO6lQ(ChO,5=nO!2QQ`O'#EgO!2wQ,UO'#EhOOQ(CW'#J^'#J^O!3OQ(ChO'#JlO6lQ(ChO,5=VO8sQ`O,5=]OOQP'#Cs'#CsO!3ZQ!bO,5=YO!3cQ!cO,5=ZO!3nQ`O,5=]O!3sQpO,5=`O;dQ`O'#GyO6tQ`O'#G{O!3{Q`O'#G{O6yQ&jO'#HOO!4QQ`O'#HOOOQS,5=c,5=cO!4VQ`O'#HPO!4_Q`O'#CmO!4dQ`O,59OO!4nQ`O,59OO!6sQdO,59OOOQS,59O,59OO!7QQ(ChO,59OO$}QdO,59OO!7]QdO'#HWOOQS'#HX'#HXOOQS'#HY'#HYO`QdO,5=pO!7mQ`O,5=pO`QdO,5=vO`QdO,5=xO!7rQ`O,5=zO`QdO,5=|O!7wQ`O,5>PO!7|QdO,5>VOOQS,5>],5>]O$}QdO,5>]O6lQ(ChO,5>_OOQS,5>a,5>aO!<QQ`O,5>aOOQS,5>c,5>cO!<QQ`O,5>cOOQS,5>e,5>eO!<VQ!bO'#DWOOQ(CW'#JU'#JUO$}QdO'#JUO!<tQ!bO'#JUO!=cQ!bO'#DeO!=tQ,UO'#DeO!@PQdO'#DeO!@WQ`O'#JTO!@`Q`O,5:OO!@eQ`O'#EiO!@sQ`O'#JaO!@{Q`O,5;SO!AcQ,UO'#DeO!AmQ,UO'#EOOOQ(C[,5:g,5:gO$}QdO,5:gOJRQ&jO,5:gO!BjQaO,5:gO;dQ`O,5:}O!0`Q!bO,5:}O!0hQ&jO,5:}O6yQ&jO,5:}O!BuQpO,59uOOOW-E<O-E<OOOQ(C[1G/`1G/`O!BzQtO,5>mO)jQdO,5>mOOQO,5>s,5>sO!CUQdO'#IROOQO-E<P-E<PO!CcQ`O,5?nO!CkQtO,5?nO!CrQ`O,5?yOOQ(C[1G/e1G/eO$}QdO,5?zO!CzQ`O'#IXOOQO-E<V-E<VO!CrQ`O,5?yOOQ(CW1G0m1G0mOOQ(C[1G/p1G/pOOQ(C[1G0Q1G0QO!D`Q`O,5?vO8YQ`O,5?vO!DhQ`O,5?vOOQ(CW'#E_'#E_O$}QdO,5?wO!DvQ(ChO,5?wO!EXQ(ChO,5?wO!E`Q`O'#IZO!D`Q`O,5?vOOQ(CW1G0l1G0lOMZQ,UO,5:nOMfQ,UO,5:nOOQO,5:p,5:pO!E}Q`O,5:pO!FVQ&kO1G2mO6tQ`O1G2mOOQ(C[1G0j1G0jO!FhQ(C|O1G0jO!GmQ(CyO,5:zOOQ(C]'#F{'#F{O!JWQ(C}O'#I}OHRQdO1G0jO!J}Q&kO'#JVO!KXQ`O,5:YO!K^QtO'#JWO$}QdO'#JWO!KhQ`O,5:_OOQ(C]'#DW'#DWOOQ(C[1G0s1G0sO$}QdO1G0sOOQ(C[1G1]1G1]O!KmQ`O1G0sO!NUQ(C|O1G0tO!N]Q(C|O1G0tO#!vQ(C|O1G0tO#!}Q(C|O1G0tO#%XQ(C|O1G0tO#%oQ(C|O1G0tO#(iQ(C|O1G0tO#(pQ(C|O1G0tO#+ZQ(C|O1G0tO#+bQ(C|O1G0tO#-YQ(C|O1G0tO#0YQ!LUO'#ChO#2WQ!LUO1G1VO#4UQ!LUO'#JRO! tQ`O1G1]O#4iQ(C|O,5>xOOQ(CW-E<[-E<[O#5]Q(C}O1G0tOOQ(C[1G0t1G0tO#7hQ(C|O1G1YO#8[Q!bO,5;}O#8dQ!bO,5<OO#8lQ!bO'#FfO#9TQ`O'#FeOOQO'#Je'#JeOOQO'#I['#I[O#9YQ!bO1G1eOOQ(C[1G1e1G1eOOOO1G1p1G1pO#9kQ!LUO'#JQO#9uQ`O,5<XOMqQdO,5<XOOOO-E<Z-E<ZOOQ(C[1G1b1G1bOOQ(C[,5<Z,5<ZO#9zQ!bO,5<ZOOQ(C],59b,59bOJRQ&jO'#C|OOOW'#IP'#IPO#:POWO,59fOOQ(C],59f,59fO$}QdO1G1vO!,YQ`O'#I`O#:[Q`O,5<oOOQ(C],5<l,5<lOOQO'#Gb'#GbOKhQ&jO,5<{OOQO'#Gd'#GdOKhQ&jO,5<}OJRQ&jO,5=POOQO1G1x1G1xO#:gQqO'#CpO#:zQqO,5<hO#;RQ`O'#JhO6tQ`O'#JhO#;aQ`O,5<jOKhQ&jO,5<iO#;fQ`O'#GOO#;qQ`O,5<iO#;vQqO'#F{O#<TQqO'#JiO#<_Q`O'#JiOJRQ&jO'#JiO#<dQ`O,5<mOOQ(CW'#Di'#DiO#<iQ!bO'#GWO!)dQ,UO'#GWO#<zQ`O'#GYO#=PQ`O'#G[O!(eQ`O'#G_O#=UQ(ChO'#IbO#=aQ,UO,5<qOOQ(C],5<q,5<qO#=hQ,UO'#GWO#=vQ,UO'#GXO#>OQ,UO'#GXOOQ(C],5=Q,5=QOKhQ&jO,5?hOKhQ&jO,5?hO#>TQ`O'#IcO#>`Q`O,5?gO#>hQ`O,59^O#?XQ&kO,59mOOQ(C],59m,59mO#?zQ&kO,5<`O#@mQ&kO,5<bO#@wQ`O,5<dOOQ(C],5<e,5<eO#@|Q`O,5<kO#ARQ&kO,5<pOHRQdO1G1wO#AcQ`O1G1wOOQS1G4R1G4ROOQ(C[1G/r1G/rO! qQ`O1G/rOOQS1G2m1G2mOJRQ&jO1G2mO$}QdO1G2mOJRQ&jO1G2mO#AhQaO1G2mO#CQQ&jO'#E`OOQ(CW,5?e,5?eO#C[Q(ChO,5?eOOQS1G.s1G.sO;dQ`O1G.sO!0`Q!bO1G.sO!0hQ&jO1G.sO#CmQ`O1G0jO#CrQ`O'#ChO#C}Q`O'#JpO#DVQ`O,5=oO#D[Q`O'#JpO#DaQ`O'#JpO#DiQ`O'#IkO#DwQ`O,5@ZO#EPQtO1G1_OOQ(C[1G1a1G1aO6tQ`O1G3YO#EWQ`O1G3YO#E]Q`O1G3YO#EbQ`O1G3YOOQS1G3Y1G3YO8YQ`O'#J_O8YQ`O'#EiO$}QdO'#EiO8YQ`O'#IeO#EgQ(ChO,5@WOOQS1G2q1G2qO!3nQ`O1G2wOJRQ&jO1G2tO#ErQ`O1G2tOOQS1G2u1G2uOJRQ&jO1G2uO#EwQaO1G2uO#FPQ,UO'#GsOOQS1G2w1G2wO!)dQ,UO'#IgO!3sQpO1G2zOOQS1G2z1G2zOOQS,5=e,5=eO#FXQ&kO,5=gO6tQ`O,5=gO#=PQ`O,5=jO6bQ`O,5=jO!0`Q!bO,5=jO!0hQ&jO,5=jO6yQ&jO,5=jO#FjQ`O'#JnO#FuQ`O,5=kOOQS1G.j1G.jO#FzQ(ChO1G.jO#GVQ`O1G.jO#G[Q`O1G.jO6lQ(ChO1G.jO#GdQtO,5@]O#GnQ`O,5@]O#GyQdO,5=rO#HQQ`O,5=rO8YQ`O,5@]OOQS1G3[1G3[O`QdO1G3[OOQS1G3b1G3bOOQS1G3d1G3dO;_Q`O1G3fO#HVQdO1G3hO#LTQdO'#HgOOQS1G3k1G3kO#LbQ`O'#HmO;dQ`O'#HoOOQS1G3q1G3qO#LjQdO1G3qO6lQ(ChO1G3wOOQS1G3y1G3yOOQ(CW'#GS'#GSO6lQ(ChO1G3{O6lQ(ChO1G3}O$!kQ`O,5?pOMqQdO,5;TO8YQ`O,5;TO;dQ`O,5:POMqQdO,5:PO$}QdO'#JUO!0`Q!bO,5:PO$!pQ!LUO,5:POOQO,5;T,5;TO$!zQ,UO'#ISO$#bQ`O,5?oOOQ(C[1G/j1G/jO$#jQ,UO'#IYO$#tQ`O,5?{OOQ(CW1G0n1G0nO!=tQ,UO,5:PO$#|Q,UO'#E[OOQ(CW'#EZ'#EZO$$sQ(DjO'#E[O$%_Q,UO'#EPOOQO'#IV'#IVO$%pQ,UO,5:jOOQ(C[,5:j,5:jO$&mQ,UO'#EPO$&zQ,UO'#EPO$'[Q,UO'#EbO$'_Q,UO'#E[O$'xQ,UO'#E[O$%_Q,UO'#E[O$(iQ`O1G0RO$(nQqO1G0ROOQ(C[1G0R1G0RO$}QdO1G0ROJRQ&jO1G0ROOQ(C[1G0i1G0iO;dQ`O1G0iO!0`Q!bO1G0iO!0hQ&jO1G0iOOOW1G/a1G/aO$(uQpO,5<_O$(}QtO1G4XOOQO1G4_1G4_O$}QdO,5>mO$)XQ`O1G5YO$)aQ`O1G5eO$)iQtO1G5fO8YQ`O,5>sO$)sQ`O1G5bO$)sQ`O1G5bO8YQ`O1G5bO$){Q(C|O1G5cO$}QdO1G5cO$*]Q(ChO1G5cO$*nQ`O,5>uO8YQ`O,5>uOOQO,5>u,5>uO$+SQ`O,5>uOOQO-E<X-E<XOOQO1G0Y1G0YOOQO1G0[1G0[O! tQ`O1G0[OOQS7+(X7+(XOJRQ&jO7+(XO$}QdO7+(XOJRQ&jO7+(XO$+bQaO7+(XO$+pQ&kO7+(XO$,RQ(C}O,59mO$.ZQ(C}O,5<`O$0fQ(C}O,5<bO$2qQ(C}O,5<pOOQ(C[7+&U7+&UO$5SQ(C|O7+&UO$5vQ&jO'#ITO$6QQ`O,5?qOOQ(C]1G/t1G/tO$6YQdO'#IUO$6gQ`O,5?rO$6oQtO,5?rOOQ(C[1G/y1G/yO$6yQ`O7+&_OOQ(C[7+&_7+&_O$7OQ!LUO,5:`O$}QdO7+&qO$7YQ!LUO,5:WOOQ(C[7+&w7+&wOOQO1G1i1G1iOOQO1G1j1G1jO$7gQ$ISO,5<QOMqQdO,5<POOQO-E<Y-E<YOOQ(C[7+'P7+'POOOO7+'[7+'[OOOO1G1s1G1sO$7rQ`O1G1sOOQ(C[1G1u1G1uO$7wQqO,59hOOOW-E;}-E;}OOQ(C]1G/Q1G/QO$8OQ(C|O7+'bOOQ(C],5>z,5>zO$8rQ`O,5>zOOQ(C]1G2Z1G2ZP$8wQ`O'#I`POQ(C]-E<^-E<^O$9hQ&kO1G2gO$:ZQ&kO1G2iO$:eQqO1G2kOOQ(C]1G2S1G2SO$:lQ`O'#I_O$:zQ`O,5@SO$:zQ`O,5@SO$;SQ`O,5@SO$;_Q`O,5@SOOQO1G2U1G2UO$;mQ&kO1G2TOKhQ&jO1G2TO$;}QMhO'#IaO$<_Q`O,5@TOJRQ&jO,5@TO$<gQqO,5@TOOQ(C]1G2X1G2XOOQ(CW,5<r,5<rOOQ(CW,5<s,5<sO$<qQ`O,5<sO#<uQ`O,5<sO!0`Q!bO,5<rOOQO'#GZ'#GZO$<vQ`O,5<tOOQ(CW,5<v,5<vO$<qQ`O,5<yOOQO,5>|,5>|OOQO-E<`-E<`OOQ(C]1G2]1G2]O!)dQ,UO,5<rO$=OQ`O,5<sO#<zQ`O,5<tO!)dQ,UO,5<sO$=ZQ&kO1G5SO$=eQ&kO1G5SOOQO,5>},5>}OOQO-E<a-E<aOOQP1G.x1G.xO!1cQ,UO,59oO$}QdO,59oO$=rQ`O1G2OOKhQ&jO1G2VO$=wQ(C|O7+'cOOQ(C[7+'c7+'cOHRQdO7+'cOOQ(C[7+%^7+%^O$>kQqO'#JjO$(iQ`O7+(XO$>uQ`O7+(XO$>}QqO7+(XO$?XQ(CyO'#ChO$?lQ(CyO,5<wO$@^Q`O,5<wOOQ(CW1G5P1G5POOQS7+$_7+$_O;dQ`O7+$_O!0`Q!bO7+$_OHRQdO7+&UO$@cQ`O'#IjO$@tQ`O,5@[OOQO1G3Z1G3ZO6tQ`O,5@[O$@tQ`O,5@[O$@|Q`O,5@[OOQO,5?V,5?VOOQO-E<i-E<iOOQ(C[7+&y7+&yO$ARQ`O7+(tO6lQ(ChO7+(tO6tQ`O7+(tO$AWQ`O7+(tO$A]Q`O,5;TOOQ(CW,5?P,5?POOQ(CW-E<c-E<cOOQS7+(c7+(cO$AbQ(CyO7+(`OJRQ&jO7+(`O$AlQqO7+(aOOQS7+(a7+(aOJRQ&jO7+(aO$AsQ`O'#JmO$BOQ`O,5=_OOQO,5?R,5?ROOQO-E<e-E<eOOQS7+(f7+(fO$CUQ,UO'#G|OOQS1G3R1G3ROJRQ&jO1G3RO$}QdO1G3ROJRQ&jO1G3RO$C]QaO1G3RO$CkQ&kO1G3RO6lQ(ChO1G3UO#=PQ`O1G3UO6bQ`O1G3UO!0`Q!bO1G3UO!0hQ&jO1G3UO$C|Q`O'#IiO$DXQ`O,5@YO$DaQ,UO,5@YOOQ(CW1G3V1G3VOOQS7+$U7+$UO$DiQ`O7+$UO6lQ(ChO7+$UO$DnQ`O7+$UO$}QdO1G5wO$}QdO1G5xO$DsQdO1G3^O$DzQ`O1G3^O$EPQdO1G3^O$EWQ(ChO1G5wOOQS7+(v7+(vO6lQ(ChO7+)QO`QdO7+)SOOQS'#Js'#JsOOQS'#Il'#IlO$EbQdO,5>ROOQS,5>R,5>RO$}QdO'#HhO$EoQ`O'#HjOOQS,5>X,5>XO8YQ`O,5>XOOQS,5>Z,5>ZOOQS7+)]7+)]OOQS7+)c7+)cOOQS7+)g7+)gOOQS7+)i7+)iO$EtQ!bO1G5[O$FYQ!LUO1G0oO$FdQ`O1G0oOOQO1G/k1G/kO$FoQ!LUO1G/kO$FyQ`O,5?pO;dQ`O1G/kOMqQdO'#DeOOQO,5>n,5>nOOQO-E<Q-E<QOOQO,5>t,5>tOOQO-E<W-E<WO!0`Q!bO1G/kO$GOQ7[O,5:lO$HOQ(DjO,5:vO$%_Q,UO,5:kO$HjQ,UO,5:kO$HwQ,UO,5:kO$IXQ,UO,5:vO$IrQ,UO,5:vO$%_Q,UO,5:vO;dQ`O,5:kOOQO,5:v,5:vO$}QdO,5:vO$JcQ(ChO,5:vO$JnQ(ChO,5:vO!0`Q!bO,5:kOOQO-E<T-E<TOOQ(C[1G0U1G0UOOQO,5:|,5:|O$J|Q(ChO,5:vOOQ(C[7+%m7+%mO$(iQ`O7+%mO$(nQqO7+%mOOQ(C[7+&T7+&TO;dQ`O7+&TO!0`Q!bO7+&TO$KbQ`O7+*|O$KbQ`O7+*|O$KjQ(C|O7+*}O$}QdO7+*}OOQO1G4a1G4aO8YQ`O1G4aO$KzQ`O1G4aOOQO7+%v7+%vO$(iQ`O<<KsO$LYQ`O<<KsO$LbQqO<<KsOOQS<<Ks<<KsOJRQ&jO<<KsO$}QdO<<KsOJRQ&jO<<KsO$LlQaO<<KsO$LzQ(C}O1G2gO% VQ(C}O1G2iO%#bQ(C}O1G2TO%%sQ&kO,5>oOOQO-E<R-E<RO%%}QtO,5>pO$}QdO,5>pOOQO-E<S-E<SO%&XQ`O1G5^OOQ(C[<<Iy<<IyO%&aQ!LUO1G0jO%(kQ!LUO1G0tO%(rQ!LUO1G0tO%*vQ!LUO1G0tO%*}Q!LUO1G0tO%,rQ!LUO1G0tO%-YQ!LUO1G0tO%/mQ!LUO1G0tO%/tQ!LUO1G0tO%1xQ!LUO1G0tO%2PQ!LUO1G0tO%3wQ!LUO1G0tO%4[Q(C|O<<J]O%5aQ!LVO1G0tO%7VQ!LVO'#I}O%7aQ!LUO1G1YOMqQdO'#FhOOQO'#Jf'#JfOOQO1G1l1G1lO%7nQ`O1G1kO%7sQ!LUO,5>xOOOO7+'_7+'_OOOW1G/S1G/SOOQ(C]1G4f1G4fOKhQ&jO7+(VO%7}Q`O,5>yO6tQ`O,5>yOOQO-E<]-E<]O%8]Q`O1G5nO%8]Q`O1G5nO%8eQ`O1G5nO%8pQ&kO7+'oO%9QQqO,5>{O%9[Q`O,5>{OJRQ&jO,5>{OOQO-E<_-E<_O%9aQqO1G5oO%9kQ`O1G5oOOQ(CW1G2_1G2_O$<qQ`O1G2_OOQ(CW1G2^1G2^O%9sQ`O1G2`OJRQ&jO1G2`OOQ(CW1G2e1G2eO!0`Q!bO1G2^O#<uQ`O1G2_O%9xQ`O1G2`O%:QQ`O1G2_OKhQ&jO7+*nOOQ(C]1G/Z1G/ZO%:]Q`O1G/ZOOQ(C]7+'j7+'jO%:bQ&kO7+'qO%:rQ(C|O<<J}OOQ(C[<<J}<<J}OJRQ&jO'#IdO%;fQ`O,5@UOJRQ&jO1G2cOOQS<<Gy<<GyO;dQ`O<<GyO%;nQ(C|O<<IpOOQ(C[<<Ip<<IpOOQO,5?U,5?UO%<bQ`O,5?UO%<gQ`O,5?UOOQO-E<h-E<hO%<oQ`O1G5vO%<oQ`O1G5vO6tQ`O1G5vO%<wQ`O<<L`OOQS<<L`<<L`O%<|Q`O<<L`O6lQ(ChO<<L`O%=RQ`O1G0oOOQS<<Kz<<KzO$AbQ(CyO<<KzOOQS<<K{<<K{O$AlQqO<<K{O%=WQ,UO'#IfO%=cQ`O,5@XOMqQdO,5@XOOQS1G2y1G2yO%=kQ(DjO'#JUO%>VQdO'#JUO%>^Q,UO'#E[O%>tQ(ChO'#E[O$$sQ(DjO'#E[O$%hQ,UO'#G}OOQO'#Ih'#IhO%?YQ,UO,5=hOOQS,5=h,5=hO%?aQ,UO'#E[O%?rQ,UO'#E[O%@YQ,UO'#E[O%@vQ,UO'#G}O%AXQ`O7+(mO%A^Q`O7+(mO%AfQqO7+(mOOQS7+(m7+(mOJRQ&jO7+(mO$}QdO7+(mOJRQ&jO7+(mO%ApQaO7+(mOOQS7+(p7+(pO6lQ(ChO7+(pO#=PQ`O7+(pO6bQ`O7+(pO!0`Q!bO7+(pO%BOQ`O,5?TOOQO-E<g-E<gOOQO'#HQ'#HQO%BZQ`O1G5tO6lQ(ChO<<GpOOQS<<Gp<<GpO%BcQ`O<<GpO%BhQ`O7++cO%BmQ`O7++dOOQS7+(x7+(xO%BrQ`O7+(xO%BwQdO7+(xO%COQ`O7+(xO$}QdO7++cO$}QdO7++dOOQS<<Ll<<LlOOQS<<Ln<<LnOOQS-E<j-E<jOOQS1G3m1G3mO%CTQ`O,5>SOOQS,5>U,5>UO%CYQ`O1G3sO8YQ`O7+&ZOMqQdO7+&ZOOQ(CW1G5[1G5[OOQO7+%V7+%VO%C_Q!LUO1G5fO;dQ`O7+%VO;dQ`O1G0VOOQO1G0b1G0bO$}QdO1G0bO%CiQ(ChO1G0bO%CtQ(ChO1G0bO!0`Q!bO1G0VO$%_Q,UO1G0VO%DSQ,UO1G0VO%DaQ(DjO1G0bO%D{Q,UO1G0VO$%_Q,UO1G0bO%E]Q,UO1G0bO%EvQ(ChO1G0bOOQO1G0V1G0VO%F[Q(C|O1G0bOOQ(C[<<IX<<IXOOQ(C[<<Io<<IoO;dQ`O<<IoO%FfQ`O<<NhO%FnQ(C|O<<NiOOQO7+){7+){O8YQ`O7+){OOQSANA_ANA_OJRQ&jOANA_O$(iQ`OANA_O%GOQ`OANA_O%GWQqOANA_O$}QdOANA_OJRQ&jOANA_O%GbQ(C}O7+'oO%IsQ(C}O7+'qO%LUQtO1G4[O%L`Q!LUO7+&UO%MUQ!LVO,59mO& YQ!LVO,5<`O&#aQ!LVO,5<bO&%SQ!LVO,5<pO&&xQ!LUO7+'bO&'VQ!LUO7+'cO&'dQ`O,5<SOOQO7+'V7+'VO&'iQ&kO<<KqOOQO1G4e1G4eO&'pQ`O1G4eO&'{Q`O1G4eO&(ZQ`O7++YO&(ZQ`O7++YOJRQ&jO1G4gO&(cQqO1G4gO&(mQ`O7++ZOOQ(CW7+'y7+'yO$<qQ`O7+'zO&(uQqO7+'zOOQ(CW7+'x7+'xO$<qQ`O7+'yO&(|Q`O7+'zOJRQ&jO7+'zO#<uQ`O7+'yO&)RQ&kO<<NYOOQ(C]7+$u7+$uO&)]QqO,5?OOOQO-E<b-E<bO&)gQ(CyO7+'}OOQSAN=eAN=eO6tQ`O1G4pOOQO1G4p1G4pO&)wQ`O1G4pO&)|Q`O7++bO&)|Q`O7++bO6lQ(ChOANAzO&*UQ`OANAzOOQSANAzANAzOOQSANAfANAfOOQSANAgANAgO&*ZQ`O,5?QOOQO-E<d-E<dO&*fQ!LUO1G5sO#=PQ`O,5=iO6bQ`O,5=iO&,vQtO'#ChO&-QQ,UO,5:vO&-[Q,UO,5:vO!0`Q!bO,5=iOOQO-E<f-E<fOOQS1G3S1G3SO%>VQdO,5<tO%=kQ(DjO,5=iO$HOQ(DjO,5:vO$%hQ,UO,5=iO&-lQ,UO,5=iO&-}Q,UO,5:vOOQS<<LX<<LXOJRQ&jO<<LXO%AXQ`O<<LXO&.eQ`O<<LXO&.mQqO<<LXO$}QdO<<LXOJRQ&jO<<LXOOQS<<L[<<L[O6lQ(ChO<<L[O#=PQ`O<<L[O6bQ`O<<L[O&.wQ,UO1G4oO&/PQ`O7++`OOQSAN=[AN=[O6lQ(ChOAN=[OOQS<<N}<<N}OOQS<= O<= OOOQS<<Ld<<LdO&/XQ`O<<LdO&/^QdO<<LdO&/eQ`O<<N}O&/jQ`O<= OOOQS1G3n1G3nO;dQ`O7+)_O&/oQ`O<<IuO&/zQ!LUO<<IuOOQO<<Hq<<HqOOQO7+%q7+%qO%F[Q(C|O7+%|OOQO7+%|7+%|O$}QdO7+%|O&0UQ(ChO7+%|O;dQ`O7+%qO!0`Q!bO7+%qO$%_Q,UO7+%qO&0aQ(ChO7+%|O&0oQ,UO7+%qO&0|Q(ChO7+%|O&1bQ(DjO7+%|O&1lQ,UO7+%qO$%_Q,UO7+%|OOQ(C[AN?ZAN?ZOOQO<<Mg<<MgO$(iQ`OG26yOOQSG26yG26yOJRQ&jOG26yO&1|Q`OG26yO&2UQqOG26yO&2`Q!LUO<<J]O&2mQ!LVO1G2TO&4wQ!LVO1G2gO&7OQ!LVO1G2iO&8qQ!LUO<<J}O&9OQ!LUO<<IpOOQO1G1n1G1nOKhQ&jOANA]OOQO7+*P7+*PO&9]Q`O7+*PO&9hQ`O<<NtO&9pQqO7+*ROOQ(CW<<Kf<<KfO$<qQ`O<<KfOOQ(CW<<Ke<<KeO&9zQqO<<KfO$<qQ`O<<KeOOQO7+*[7+*[O6tQ`O7+*[O&:RQ`O<<N|OOQSG27fG27fO6lQ(ChOG27fOMqQdO1G4lO&:ZQ`O7++_O6lQ(ChO1G3TO#=PQ`O1G3TO&:cQ,UO1G0bO6bQ`O1G3TO!0`Q!bO1G3TO$%hQ,UO1G3TO%=kQ(DjO1G3TO%DaQ(DjO1G0bO&:mQ,UO1G3TO%AXQ`OANAsOOQSANAsANAsOJRQ&jOANAsO&;OQ`OANAsO&;WQqOANAsOOQSANAvANAvO6lQ(ChOANAvO#=PQ`OANAvOOQO'#HR'#HROOQO7+*Z7+*ZOOQSG22vG22vOOQSANBOANBOO&;bQ`OANBOOOQSANDiANDiOOQSANDjANDjOOQS<<Ly<<LyOMqQdOAN?aOOQO<<Ih<<IhO%F[Q(C|O<<IhO$}QdO<<IhOOQO<<I]<<I]O;dQ`O<<I]O!0`Q!bO<<I]O&;gQ(ChO<<IhO$%_Q,UO<<I]O&;rQ(ChO<<IhO&<QQ,UO<<I]O&<_Q(ChO<<IhOOQSLD,eLD,eO$(iQ`OLD,eOJRQ&jOLD,eO&<sQ!LVO7+'oO&>iQ!LVO7+'qO&@_Q&kOG26wOOQO<<Mk<<MkOOQ(CWANAQANAQO$<qQ`OANAQOOQ(CWANAPANAPOOQO<<Mv<<MvOOQSLD-QLD-QO&@oQ!LUO7+*WOOQO7+(o7+(oO6lQ(ChO7+(oO#=PQ`O7+(oO6bQ`O7+(oO!0`Q!bO7+(oO$%hQ,UO7+(oOOQSG27_G27_O%AXQ`OG27_OJRQ&jOG27_OOQSG27bG27bO6lQ(ChOG27bOOQSG27jG27jO&@yQ!LUOG24{OOQOAN?SAN?SO%F[Q(C|OAN?SOOQOAN>wAN>wO;dQ`OAN>wO$}QdOAN?SO!0`Q!bOAN>wO&ATQ(ChOAN?SO$%_Q,UOAN>wO&A`Q(ChOAN?SOOQS!$(!P!$(!PO$(iQ`O!$(!PO&AnQ(C}OG26wOOQ(CWG26lG26lOOQO<<LZ<<LZO6lQ(ChO<<LZO#=PQ`O<<LZO6bQ`O<<LZO!0`Q!bO<<LZOOQSLD,yLD,yO%AXQ`OLD,yOOQSLD,|LD,|OOQOG24nG24nOOQOG24cG24cO%F[Q(C|OG24nO;dQ`OG24cO$}QdOG24nO!0`Q!bOG24cO&DPQ(ChOG24nOOQS!)9Ek!)9EkO&DmQ7]O,5:zOOQOANAuANAuO6lQ(ChOANAuO#=PQ`OANAuO6bQ`OANAuOOQS!$(!e!$(!eOOQOLD*YLD*YOOQOLD)}LD)}O%F[Q(C|OLD*YO;dQ`OLD)}O$}QdOLD*YO&EpQ!LVOG26wO&GfQ7]O,59mO&HfQ7]O,5<`O&IfQ7]O,5<bO&JfQ7]O,5<pOOQOG27aG27aO6lQ(ChOG27aO#=PQ`OG27aOOQO!$'Mt!$'MtOOQO!$'Mi!$'MiO%F[Q(C|O!$'MtO&KiQ7]O1G2gO&LiQ7]O1G2iO&MiQ7]O1G2TOOQOLD,{LD,{O6lQ(ChOLD,{OOQO!)9C`!)9C`O&NlQ7]O7+'oO' oQ7]O7+'qOOQO!$(!g!$(!gO'!rQ7]OG26wOMqQdO'#DtO.fQ`O'#EQO'#uQtO'#JQOMqQdO'#DlO'#|QtO'#ChO'&dQtO'#ChO'&tQdO,5;OO'(tQ&jO'#E`OMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO'#I^O'*UQ`O,5<_O'*^Q&jO,5;YO'+nQ&jO,5;YOMqQdO,5;nO.iQ`O'#DRO.iQ`O'#DRO.iQ`O'#DROJRQ&jO'#FtO'(tQ&jO'#FtO'*^Q&jO'#FtOJRQ&jO'#FvO'(tQ&jO'#FvO'*^Q&jO'#FvOJRQ&jO'#GUO'(tQ&jO'#GUO'*^Q&jO'#GUOMqQdO,5?zO'&tQdO1G0jO'+uQ!LUO'#ChOMqQdO1G1vOJRQ&jO,5<{O'(tQ&jO,5<{O'*^Q&jO,5<{OJRQ&jO,5<}O'(tQ&jO,5<}O'*^Q&jO,5<}OJRQ&jO,5<iO'(tQ&jO,5<iO'*^Q&jO,5<iO'&tQdO1G1wOMqQdO7+&qOJRQ&jO1G2TO'(tQ&jO1G2TO'*^Q&jO1G2TOJRQ&jO1G2VO'(tQ&jO1G2VO'*^Q&jO1G2VO'&tQdO7+'cO'&tQdO7+&UO',PQ`O7+'zOJRQ&jOANA]O'(tQ&jOANA]O'*^Q&jOANA]O',PQ`O<<KfO',PQ`OANAQO',UQ`O'#EdO',ZQ`O'#EdO',cQ`O'#FSO',hQ`O'#EnO',mQ`O'#J`O',xQ`O'#J^O'-TQ`O,5;OO'-YQ&kO,5<[O'-aQ`O'#F}O'-fQ`O'#F}O'-kQ`O'#F}O'-pQ`O,5<]O'-xQ`O,5;OO'.QQ!LUO1G1VO'.XQ`O,5<iO'.^Q`O,5<iO'.cQ`O,5<iO'.hQ`O,5<kO'.mQ`O,5<kO'.rQ`O,5<kO'.wQ`O1G1wO'.|Q`O1G0jO'/RQ`O1G2`O'/WQ&kO<<KqO'/_Q&kO<<KqO'/fQ&kO<<KqO'/mQqO7+'zO'/tQ`O7+'zO'/yQqO<<KfO4}Q&jO'#FrO6bQ`O'#FqO={Q`O'#EcOMqQdO,5;kO!(eQ`O'#F}O!(eQ`O'#F}O!(eQ`O'#F}O!(eQ`O'#GPO!(eQ`O'#GPO!(eQ`O'#GPO'0QQ`O,5<tOKhQ&jO7+(VOKhQ&jO7+(VOKhQ&jO7+(VOJRQ&jO1G2`O'0YQ`O1G2`OJRQ&jO7+'zO$:eQqO1G2kO$:eQqO1G2kO$:eQqO1G2kOJRQ&jO,5=POJRQ&jO,5=POJRQ&jO,5=P",
        stateData: "'1c~O'gOS'hOSTOSUOS~OQUORUOX}O]gO_lObrOcqOigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!VTO!aoO!fVO!iUO!jUO!kUO!lUO!mUO!ppO!uXO#lwO#|tO$QbO%[uO%^xO%`vO%avO%dyO%fzO%i{O%j{O%l|O%y!OO&P!PO&R!QO&T!RO&V!SO&Y!TO&`!UO&f!VO&h!WO&j!XO&l!YO&n!ZO'jQO'rRO'|WO(ZeO~OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!V!]O!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'j![O'rRO'|WO(ZeO~OQ[XZ[X_[Xk[Xx[Xy[X{[X!T[X!c[X!d[X!f[X!l[X#T[X#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'e[X'r[X'}[X(U[X(V[X~O!_$vX~P&}OS!cO'c!dO'd!fO~OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!V!]O!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'j;ZO'rRO'|WO(ZeO~O!S!jO!T!gO!Q'vP!Q(RP~P)jO!U!rO~P`OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!V!]O!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'rRO'|WO(ZeO~O!S!xO!uXO#^!{O#_!xO'j;[O!e(OP~P,RO!f!}O'j!|O~O!p#RO!uXO%[#SO~O#`#TO~O!_#UO#`#TO~OQ#lOZ#sOk#aOx#YOy#ZO{#[O!T#pO!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO#r#iO'rRO'}#jO(U#]O(V#^O~O_'tX'e'tX'a'tX!e'tX!Q'tX!V'tX%]'tX!_'tX~P/WO#T#tO#w#tOQ'uXZ'uX_'uXk'uXx'uXy'uX{'uX!T'uX!c'uX!d'uX!f'uX!l'uX#c'uX#d'uX#e'uX#f'uX#g'uX#h'uX#i'uX#j'uX#m'uX#o'uX#q'uX#r'uX'r'uX'}'uX(U'uX(V'uX~O#k'uX'e'uX'a'uX!Q'uX!e'uXo'uX!V'uX%]'uX!_'uX~P1nO#T#tO~O$S#vO$U#uO$]#{O~O!V#|O$QbO$`#}O$b$PO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv$fO{$[O!V$]O!a$kO!f$XO#_$lO#|$iO$i$gO$k$hO$n$jO'j$RO'n$bO'r$UOe'oP~O!f$mO~O!_$oO~O_$pO'e$pO~O'j$tO~O!f$mO'j$tO'k$vO'n$bO~Oc$|O!f$mO'j$tO~O#k#cO~O]%VOx%RO!V%OO!f%QO%^%UO'j$tO'k$vO^(cP~O!p#RO~O{%WO!V%XO'j$tO~O{%WO!V%XO%f%]O'j$tO~O'j%^O~O#lwO%^xO%`vO%avO%dyO%fzO%i{O%j{O~Ob%gOc%fO!p%dO%[%eO%n%cO~P8xOb%jOcqO!V%iO!ppO!uXO#lwO%[uO%`vO%avO%dyO%fzO%i{O%j{O%l|O~O`%mO#T%pO%^%kO'k$vO~P9wO!f%qO!i%uO~O!f!}O~O!VTO~O_$pO'b%}O'e$pO~O_$pO'b&QO'e$pO~O_$pO'b&SO'e$pO~O'a[Xo[X!Q[X!e[X%}[X!V[X%][X!_[X~P&}O]&XOl&XO{&WO!S&[O!Y&bO!Z&ZO![&ZO'k$vO's&UO!U'wP!U(TP~OP&fO!V&cO!q&eO'j$tO~Oc&kO!f$mO'j$tO~Ox%RO!f%QO~OS!cO'c!dO'd&nO~O!S&pO!Q&uX!Q&{X!T&uX!T&{X~P)jO!T&rO!Q'vX~OQ#lOZ#sOk#aOx#YOy#ZO{#[O!T&rO!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO#r#iO'rRO'}#jO(U#]O(V#^O~O!Q'vX~P?WO!Q&wO~O!Q(QX!T(QX!_(QX!e(QX'}(QX~O#T(QX#`#XX!U(QX~PA^O#T&xO!Q(SX!T(SX~O!T&yO!Q(RX~O!Q&|O~O#T#tO~PA^O!U&}O~P`Ox#YOy#ZO{#[O!d#WO!f#XO'rROQ!haZ!hak!ha!T!ha!c!ha!l!ha#c!ha#d!ha#e!ha#f!ha#g!ha#h!ha#i!ha#j!ha#k!ha#m!ha#o!ha#q!ha#r!ha'}!ha(U!ha(V!ha~O_!ha'e!ha'a!ha!Q!ha!e!hao!ha!V!ha%]!ha!_!ha~PBtO!e'OO~O{%WO!V%XO!uXO#^'RO#_'QO'j$tO~O!_#UO#T'TO'}'SO!T(PX_(PX'e(PX~O!e(PX~PExO!T'WO!e(OX~O!e'YO~O{%WO!V%XO#_'QO'j$tO~Ox'ZOy'[O!d#WO!f#XO!u!ta{!ta~O!p!ta%[!ta!V!ta#^!ta#_!ta'j!ta~PGQO!p'`O~OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!VTO!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'j![O'rRO'|WO(ZeO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;oO{$[O!V$]O!a=`O!f$XO#_;xO#|$iO$i;rO$k;uO$n$jO'j'dO'n$bO'r$UO~O#`'fO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv$fO{$[O!V$]O!a$kO!f$XO#_$lO#|$iO$i$gO$k$hO$n$jO'j'dO'n$bO'r$UO~Oe'yP~PKhO!S'jO!e'zP~P$}O's'lO'|WO~O{'nO!f#XO's'lO'|WO~OQ;VOR;VO]gOb=ZOc!`OigOk;VOlgOmgOrgOt;VOv;VO{SO!OgO!PgO!V!]O!a;YO!fVO!i;VO!j;VO!k;VO!l;VO!m;VO!p!_O#|!bO$QbO'j'|O'rRO'|WO(Z=XO~Oy(PO!f#XO~O!T#pO_$ga'e$ga'a$ga!e$ga!Q$ga!V$ga%]$ga!_$ga~O#l(TO~PJROx(WO!_(VO!V$TX$P$TX$S$TX$U$TX$]$TX~O!_(VO!V(WX$P(WX$S(WX$U(WX$](WX~Ox(WO~P!#WOx(WO!V(WX$P(WX$S(WX$U(WX$](WX~O!V(YO$P(^O$S(XO$U(XO$](_O~O!S(bO~PMqO$S#vO$U#uO$](eO~OP$oXx$oX{$oX!d$oX(U$oX(V$oX~OPgXegXe$oX!TgX#TgX~P!$|Ol(gO~OS(hO'c(iO'd(kO~OP(tOx(mO{(nO(U(pO(V(rO~Oe(lO~P!&VOe(uO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;oO{$[O!V$]O!a=`O!f$XO#_;xO#|$iO$i;rO$k;uO$n$jO'n$bO'r$UO~O!S(yO'j(vO!e([P~P!&tO#`({O~O!f(|O~O!S)RO'j)OO!Q(]P~P!&tOk)`O{)WO!Y)^O!Z)VO![)VO!f(|O#P)_O%S)YO'k$vO's)TO~O!U)]O~P!(wO!d#WOP'qXx'qX{'qX(U'qX(V'qX!T'qX#u'qX!U'qX~Oe'qX#T'qX]'qXl'qX!Y'qX!Z'qX!['qX!u'qX!y'qX!z'qX!{'qX#P'qX#Q'qX'k'qX's'qX'|'qX~P!)pOP)cO#T)bOe'pX!T'pX~O!T)dOe'oX~O'j%^Oe'oP~O!f)kO~O'j'dO~O{%WO!S!xO!V%XO!uXO#^!{O#_!xO'j$tO!e(OP~O!_#UO#`)oO~OQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO#r#iO'rRO'}#jO(U#]O(V#^O~O_!`a!T!`a'e!`a'a!`a!Q!`a!e!`ao!`a!V!`a%]!`a!_!`a~P!-ROP)wO!V&cO!q)vO%])uO'n$bO~O!_)yO!V'mX_'mX!T'mX'e'mX~O!f$mO'n$bO~O!f$mO'j$tO'n$bO~O!_#UO#`'fO~O]*UO%^*VO'j*RO!U(dP~O!T*WO^(cX~O's'lO~OZ*[O~O^*]O~O!V%OO'j$tO'k$vO^(cP~O{%WO!S*aO!T&yO!V%XO'j$tO!Q(RP~O]&_Ol&_O{*cO!S*bO's'lO~O!U(TP~P!2fO!T*dO_(`X'e(`X~O#T*hO'n$bO~OP*kO!V$]O'n$bO~O!V*mO~Ox*oO!VTO~O!p*tO~Oc*yO~O'j!|O!U(bP~Oc$|O~O%^xO'j%^O~P9wOZ+PO^+OO~OQUORUO]gObrOcqOigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!aoO!fVO!iUO!jUO!kUO!lUO!mUO!ppO!uXO$QbO%[uO'rRO'|WO(ZeO~O!V!]O#|!bO'j![O~P!4vO^+OO_$pO'e$pO~O_+TO#l+VO%`+VO%a+VO~P$}O!f%qO~O&P+[O~O!V+^O~O&b+`O&d+aOQ&_aR&_aX&_a]&_a_&_ab&_ac&_ai&_ak&_al&_am&_ar&_at&_av&_a{&_a!O&_a!P&_a!V&_a!a&_a!f&_a!i&_a!j&_a!k&_a!l&_a!m&_a!p&_a!u&_a#l&_a#|&_a$Q&_a%[&_a%^&_a%`&_a%a&_a%d&_a%f&_a%i&_a%j&_a%l&_a%y&_a&P&_a&R&_a&T&_a&V&_a&Y&_a&`&_a&f&_a&h&_a&j&_a&l&_a&n&_a'a&_a'j&_a'r&_a'|&_a(Z&_a!U&_a&W&_a`&_a&]&_a~O'j+fO~O!TzX!T!]X!UzX!U!]X!_zX!_!]X!f!]X#TzX'n!]X~O!_+kO#T+jO!T#]X!T'xX!U#]X!U'xX!_'xX!f'xX'n'xX~O!_+mO!f$mO'n$bO!T!XX!U!XX~O]&VOl&VO{+nO's)TO~OQ;VOR;VO]gOb=ZOc!`OigOk;VOlgOmgOrgOt;VOv;VO{SO!OgO!PgO!V!]O!a;YO!fVO!i;VO!j;VO!k;VO!l;VO!m;VO!p!_O#|!bO$QbO'rRO'|WO(Z=XO~O'j;}O~P!>SO!T+rO!U'wX~O!U+tO~O!_+kO#T+jO!T#]X!U#]X~O!T+uO!U(TX~O!U+wO~O]&VOl&VO{+nO'k$vO's)TO~O!Z+xO![+xO~P!AQO_+}O!U,PO!Y,QO!Z+|O![+|O!u;WO!y,UO!z,SO!{,TO!|,RO#P,VO#Q,VO'|+zO~P!AQOP,[O!V&cO!q,ZO~Oo,aO~O!Q&ua!T&ua~P!-RO!S,eO!Q&uX!T&uX~P$}O!T&rO!Q'va~O!Q'va~P?WO!T&yO!Q(Ra~O{%WO!S,iO!V%XO'j$tO!Q&{X!T&{X~O!T'WO!e(Oa~O{%WO!V%XO#_,lO'j$tO~O#T,nO!T(Pa!e(Pa_(Pa'e(Pa~O!_#UO~P!DvO{%WO!S,qO!V%XO!uXO#^,sO#_,qO'j$tO!T&}X!e&}X~Oy,wO!f#XO~OP,{O!V&cO!q,zO%],yO'n$bO~O_#Wi!T#Wi'e#Wi'a#Wi!Q#Wi!e#Wio#Wi!V#Wi%]#Wi!_#Wi~P!-ROP=mOx(mO{(nO(U(pO(V(rO~O#`#Sa!T#Sa!e#Sa#T#Sa!V#Sa_#Sa'e#Sa!Q#Sa~P!G[O!d#WOP'qXx'qX{'qX(U'qX(V'qXQ'qXZ'qXk'qXy'qX!T'qX!c'qX!f'qX!l'qX#c'qX#d'qX#e'qX#f'qX#g'qX#h'qX#i'qX#j'qX#k'qX#m'qX#o'qX#q'qX#r'qX'r'qX'}'qX~O#`'qX_'qX'e'qX!e'qX!Q'qX'a'qX!V'qX#T'qXo'qX%]'qX!_'qX~P!HZO!T-UOe'yX~P!&VOe-WO~O!T-XO!e'zX~P!-RO!e-[O~O!Q-^O~OQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO'rROZ#bi_#bik#bi!T#bi!c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi'e#bi'}#bi(U#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~O#c#bi~P!KrO#c#_O~P!KrOQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O'rROZ#bi_#bi!T#bi!c#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi'e#bi'}#bi(U#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~Ok#bi~P!NdOk#aO~P!NdOQ#lOk#aOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO'rRO_#bi!T#bi#m#bi#o#bi#q#bi#r#bi'e#bi'}#bi(U#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~OZ#bi!c#bi#h#bi#i#bi#j#bi#k#bi~P##UOZ#sO!c#cO#h#cO#i#cO#j#rO#k#cO~P##UOQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO'rRO_#bi!T#bi#o#bi#q#bi#r#bi'e#bi'}#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~O(U#bi~P#&VO(U#]O~P#&VOQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO'rRO(U#]O_#bi!T#bi#q#bi#r#bi'e#bi'}#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~O(V#bi~P#(wO(V#^O~P#(wOQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO'rRO(U#]O(V#^O~O_#bi!T#bi#r#bi'e#bi'}#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~P#+iOQ[XZ[Xk[Xx[Xy[X{[X!c[X!d[X!f[X!l[X#T[X#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'r[X'}[X(U[X(V[X!T[X!U[X~O#u[X~P#.SOQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO#o;fO#q;hO#r;iO'rRO'}#jO(U#]O(V#^O~O#u-`O~P#0aOQ'uXZ'uXk'uXx'uXy'uX{'uX!c'uX!d'uX!f'uX!l'uX#c'uX#d'uX#e'uX#f'uX#g'uX#h'uX#i'uX#j'uX#m'uX#o'uX#q'uX#r'uX'r'uX'}'uX(U'uX(V'uX!T'uX~O#T;nO#w;nO#k'uX#u'uX!U'uX~P#2_O_'Qa!T'Qa'e'Qa'a'Qa!e'Qao'Qa!Q'Qa!V'Qa%]'Qa!_'Qa~P!-ROQ#biZ#bi_#bik#biy#bi!T#bi!c#bi!d#bi!f#bi!l#bi#c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi'e#bi'r#bi'}#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~P!G[O_#vi!T#vi'e#vi'a#vi!Q#vi!e#vio#vi!V#vi%]#vi!_#vi~P!-RO$S-cO$U-cO~O$S-dO$U-dO~O!_(VO#T-eO!V$YX$P$YX$S$YX$U$YX$]$YX~O!S-fO~O!V(YO$P-hO$S(XO$U(XO$]-iO~O!T;jO!U'tX~P#0aO!U-jO~O$]-lO~OS(hO'c(iO'd-oO~O]-rOl-rO!Q-sO~O!TdX!_dX!edX!e$oX'}dX~P!$|O!e-yO~P!G[O!T-zO!_#UO'}'SO!e([X~O!e.PO~O!S(yO'j$tO!e([P~O#`.RO~O!Q$oX!T$oX!_$vX~P!$|O!T.SO!Q(]X~P!G[O!_.UO~O!Q.WO~Ok.[O!_#UO!f$mO'n$bO'}'SO~O'j.^O~O!_)yO~O_$pO!T.bO'e$pO~O!U.dO~P!(wO!Z.eO![.eO'k$vO's)TO~O{.gO's)TO~O#P.hO~O'j%^Oe'VX!T'VX~O!T)dOe'oa~Oe.mO~Ox.nOy.nO{.oOPua(Uua(Vua!Tua#Tua~Oeua#uua~P#>mOx(mO{(nOP$ha(U$ha(V$ha!T$ha#T$ha~Oe$ha#u$ha~P#?cOx(mO{(nOP$ja(U$ja(V$ja!T$ja#T$ja~Oe$ja#u$ja~P#@UO].pO~O#`.qO~Oe$xa!T$xa#T$xa#u$xa~P!&VO#`.tO~OP,{O!V&cO!q,zO%],yO~O]$SOk$TOl$SOm$SOr$dOt$eOv;oO{$[O!V$]O!a=`O!f$XO#_;xO#|$iO$i;rO$k;uO$n$jO'n$bO'r$UO~Oi.{O'j.zO~P#AvO!_)yO!V'ma_'ma!T'ma'e'ma~O#`/RO~OZ[X!TdX!UdX~O!T/SO!U(dX~O!U/UO~OZ/VO~O]/XO'j*RO~O!V%OO'j$tO^'_X!T'_X~O!T*WO^(ca~O!e/[O~P!-RO]/^O~OZ/_O~O^/`O~O!T*dO_(`a'e(`a~O#T/fO~OP/iO!V$]O~O's'lO!U(aP~OP/sO!V/oO!q/rO%]/qO'n$bO~OZ/}O!T/{O!U(bX~O!U0OO~O^0QO_$pO'e$pO~O]0RO~O]0SO'j!|O~O#k0TO%}0UO~P1nO#T#tO#k0TO%}0UO~O_0VO~P$}O_0XO~O&W0]OQ&UiR&UiX&Ui]&Ui_&Uib&Uic&Uii&Uik&Uil&Uim&Uir&Uit&Uiv&Ui{&Ui!O&Ui!P&Ui!V&Ui!a&Ui!f&Ui!i&Ui!j&Ui!k&Ui!l&Ui!m&Ui!p&Ui!u&Ui#l&Ui#|&Ui$Q&Ui%[&Ui%^&Ui%`&Ui%a&Ui%d&Ui%f&Ui%i&Ui%j&Ui%l&Ui%y&Ui&P&Ui&R&Ui&T&Ui&V&Ui&Y&Ui&`&Ui&f&Ui&h&Ui&j&Ui&l&Ui&n&Ui'a&Ui'j&Ui'r&Ui'|&Ui(Z&Ui!U&Ui`&Ui&]&Ui~O`0cO!U0aO&]0bO~P`O!VTO!f0eO~O&d+aOQ&_iR&_iX&_i]&_i_&_ib&_ic&_ii&_ik&_il&_im&_ir&_it&_iv&_i{&_i!O&_i!P&_i!V&_i!a&_i!f&_i!i&_i!j&_i!k&_i!l&_i!m&_i!p&_i!u&_i#l&_i#|&_i$Q&_i%[&_i%^&_i%`&_i%a&_i%d&_i%f&_i%i&_i%j&_i%l&_i%y&_i&P&_i&R&_i&T&_i&V&_i&Y&_i&`&_i&f&_i&h&_i&j&_i&l&_i&n&_i'a&_i'j&_i'r&_i'|&_i(Z&_i!U&_i&W&_i`&_i&]&_i~O!Q0kO~O!T!Xa!U!Xa~P#0aO!S0rO!Y&bO!Z&ZO![&ZO!T&vX!U&vX~P!AQO!T+rO!U'wa~O!T&|X!U&|X~P!2fO!T+uO!U(Ta~O!Y0{O!Z0zO![0zO!u;WO!y1OO!z0}O!{0}O!|0|O#P1PO#Q1PO'|+zO~P!AQO_$pO!_#UO!f$mO!l1UO#T1SO'e$pO'n$bO'}'SO~O]&VOl&VO{+nO's)TO'|+zO~O_+}O!U1XO!Y,QO!Z+|O![+|O!u;WO!y,UO!z,SO!{,TO!|,RO#P,VO#Q,VO'|+zO~P!AQO!Z0zO![0zO'|+zO~P!AQO!Y0{O!Z0zO![0zO'|+zO~P!AQO!VTO!Y0{O!Z0zO![0zO!|0|O#P1PO#Q1PO'|+zO~P!AQO!Y0{O!Z0zO![0zO!z0}O!{0}O!|0|O#P1PO#Q1PO'|+zO~P!AQO!V&cO~O!V&cO~P!G[O!T#pOo$ga~O!Q&ui!T&ui~P!-RO!T&rO!Q'vi~O!T&yO!Q(Ri~O!Q(Si!T(Si~P!-RO!T'WO!e(Oi~O!T(Pi!e(Pi_(Pi'e(Pi~P!-RO#T1eO!T(Pi!e(Pi_(Pi'e(Pi~O{%WO!V%XO!uXO#^1hO#_1gO'j$tO~O{%WO!V%XO#_1gO'j$tO~OP1pO!V&cO!q1oO%]1nO~OP1pO!V&cO!q1oO%]1nO'n$bO~O#`uaQuaZua_uakua!cua!dua!fua!lua#cua#dua#eua#fua#gua#hua#iua#jua#kua#mua#oua#qua#rua'eua'rua'}ua!eua!Qua'aua!Vuaoua%]ua!_ua~P#>mO#`$haQ$haZ$ha_$hak$hay$ha!c$ha!d$ha!f$ha!l$ha#c$ha#d$ha#e$ha#f$ha#g$ha#h$ha#i$ha#j$ha#k$ha#m$ha#o$ha#q$ha#r$ha'e$ha'r$ha'}$ha!e$ha!Q$ha'a$ha!V$hao$ha%]$ha!_$ha~P#?cO#`$jaQ$jaZ$ja_$jak$jay$ja!c$ja!d$ja!f$ja!l$ja#c$ja#d$ja#e$ja#f$ja#g$ja#h$ja#i$ja#j$ja#k$ja#m$ja#o$ja#q$ja#r$ja'e$ja'r$ja'}$ja!e$ja!Q$ja'a$ja!V$jao$ja%]$ja!_$ja~P#@UO#`$xaQ$xaZ$xa_$xak$xay$xa!T$xa!c$xa!d$xa!f$xa!l$xa#c$xa#d$xa#e$xa#f$xa#g$xa#h$xa#i$xa#j$xa#k$xa#m$xa#o$xa#q$xa#r$xa'e$xa'r$xa'}$xa!e$xa!Q$xa'a$xa!V$xa#T$xao$xa%]$xa!_$xa~P!G[O_#Wq!T#Wq'e#Wq'a#Wq!Q#Wq!e#Wqo#Wq!V#Wq%]#Wq!_#Wq~P!-ROe&wX!T&wX~PKhO!T-UOe'ya~O!S1xO!T&xX!e&xX~P$}O!T-XO!e'za~O!T-XO!e'za~P!-RO!Q1{O~O#u!ha!U!ha~PBtO#u!`a!T!`a!U!`a~P#0aO!V2^O$QbO$Z2_O~O!U2cO~Oo2dO~P!G[O_$dq!T$dq'e$dq'a$dq!Q$dq!e$dqo$dq!V$dq%]$dq!_$dq~P!-RO!Q2eO~O]-rOl-rO~Ox(mO{(nO(V(rOP%Ti(U%Ti!T%Ti#T%Ti~Oe%Ti#u%Ti~P$9POx(mO{(nOP%Vi(U%Vi(V%Vi!T%Vi#T%Vi~Oe%Vi#u%Vi~P$9rO'}#jO~P!G[O!S2hO'j$tO!T'RX!e'RX~O!T-zO!e([a~O!T-zO!_#UO!e([a~O!T-zO!_#UO'}'SO!e([a~Oe$qi!T$qi#T$qi#u$qi~P!&VO!S2pO'j)OO!Q'TX!T'TX~P!&tO!T.SO!Q(]a~O!T.SO!Q(]a~P!G[O!_#UO~O!_#UO#k2xO~Ok2{O!_#UO'}'SO~Oe'pi!T'pi~P!&VO#T3OOe'pi!T'pi~P!&VO!e3RO~O_$eq!T$eq'e$eq'a$eq!Q$eq!e$eqo$eq!V$eq%]$eq!_$eq~P!-RO!T3VO!V(^X~P!G[O!V&cO%]1nO~O!V&cO%]1nO~P!G[O!V$oX%Q[X_$oX!T$oX'e$oX~P!$|O%Q3XOPhXxhX{hX!VhX(UhX(VhX_hX!ThX'ehX~O%Q3XO~O]3_O%^3`O'j*RO!T'^X!U'^X~O!T/SO!U(da~OZ3dO~O^3eO~O]3hO~O!Q3iO~O_$pO'e$pO~P!G[O!V$]O~P!G[O!T3nO#T3pO!U(aX~O!U3qO~O]&VOl&VO{3sO!Y4OO!Z3wO![3wO!u;WO!y3}O!z3|O!{3|O#P3{O#Q,VO'k$vO's)TO'|+zO~O!U3zO~P$BTOP4VO!V/oO!q4UO%]4TO~OP4VO!V/oO!q4UO%]4TO'n$bO~O'j!|O!T']X!U']X~O!T/{O!U(ba~O]4aO's4`O~O]4bO~O^4dO~O!e4gO~P$}O_4iO~O_4iO~P$}O#k4kO%}4lO~PExO`0cO!U4pO&]0bO~P`O!_4rO~O!_4tO!T'xi!U'xi!_'xi!f'xi'n'xi~O!T#]i!U#]i~P#0aO#T4uO!T#]i!U#]i~O!T!Xi!U!Xi~P#0aO!Q4vO~O]!tal!ta!Y!ta!Z!ta![!ta!y!ta!z!ta!{!ta!|!ta#P!ta#Q!ta'k!ta's!ta'|!ta~PGQO_$pO!_#UO!f$mO!l5OO#T4|O'e$pO'n$bO'}'SO~O!Z5QO![5QO'|+zO~P!AQO!Y5RO!Z5QO![5QO'|+zO~P!AQO!Y5RO!Z5QO![5QO!|5TO#P5UO#Q5UO'|+zO~P!AQO!Y5RO!Z5QO![5QO!z5VO!{5VO!|5TO#P5UO#Q5UO'|+zO~P!AQO_$pO#T4|O'e$pO~O_$pO!_#UO#T4|O'e$pO~O_$pO!_#UO!l5OO#T4|O'e$pO'}'SO~O!T'WO!e(Oq~O!T(Pq!e(Pq_(Pq'e(Pq~P!-RO{%WO!V%XO#_5aO'j$tO~O!V&cO%]5cO~O!V&cO%]5cO~P!G[OP5hO!V&cO!q5gO%]5cO~O#`%TiQ%TiZ%Ti_%Tik%Tiy%Ti!c%Ti!d%Ti!f%Ti!l%Ti#c%Ti#d%Ti#e%Ti#f%Ti#g%Ti#h%Ti#i%Ti#j%Ti#k%Ti#m%Ti#o%Ti#q%Ti#r%Ti'e%Ti'r%Ti'}%Ti!e%Ti!Q%Ti'a%Ti!V%Tio%Ti%]%Ti!_%Ti~P$9PO#`%ViQ%ViZ%Vi_%Vik%Viy%Vi!c%Vi!d%Vi!f%Vi!l%Vi#c%Vi#d%Vi#e%Vi#f%Vi#g%Vi#h%Vi#i%Vi#j%Vi#k%Vi#m%Vi#o%Vi#q%Vi#r%Vi'e%Vi'r%Vi'}%Vi!e%Vi!Q%Vi'a%Vi!V%Vio%Vi%]%Vi!_%Vi~P$9rO#`$qiQ$qiZ$qi_$qik$qiy$qi!T$qi!c$qi!d$qi!f$qi!l$qi#c$qi#d$qi#e$qi#f$qi#g$qi#h$qi#i$qi#j$qi#k$qi#m$qi#o$qi#q$qi#r$qi'e$qi'r$qi'}$qi!e$qi!Q$qi'a$qi!V$qi#T$qio$qi%]$qi!_$qi~P!G[Oe&wa!T&wa~P!&VO!T&xa!e&xa~P!-RO!T-XO!e'zi~O#u#Wi!T#Wi!U#Wi~P#0aOQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO'rROZ#bik#bi!c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi#u#bi'}#bi(U#bi(V#bi!T#bi!U#bi~O#c#bi~P%&nO#c;_O~P%&nOQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O'rROZ#bi!c#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi#u#bi'}#bi(U#bi(V#bi!T#bi!U#bi~Ok#bi~P%(yOk;aO~P%(yOQ#lOk;aOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO'rRO#m#bi#o#bi#q#bi#r#bi#u#bi'}#bi(U#bi(V#bi!T#bi!U#bi~OZ#bi!c#bi#h#bi#i#bi#j#bi#k#bi~P%+UOZ;mO!c;cO#h;cO#i;cO#j;lO#k;cO~P%+UOQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO'rRO#o#bi#q#bi#r#bi#u#bi'}#bi(V#bi!T#bi!U#bi~O(U#bi~P%-pO(U#]O~P%-pOQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO#o;fO'rRO(U#]O#q#bi#r#bi#u#bi'}#bi!T#bi!U#bi~O(V#bi~P%/{O(V#^O~P%/{OQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO#o;fO#q;hO'rRO(U#]O(V#^O~O#r#bi#u#bi'}#bi!T#bi!U#bi~P%2WO_#sy!T#sy'e#sy'a#sy!Q#sy!e#syo#sy!V#sy%]#sy!_#sy~P!-ROP=oOx(mO{(nO(U(pO(V(rO~OQ#biZ#bik#biy#bi!c#bi!d#bi!f#bi!l#bi#c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi#u#bi'r#bi'}#bi!T#bi!U#bi~P%5OO#u'qX!U'qX~P!HZO#u#vi!T#vi!U#vi~P#0aO!U5tO~O!T'Qa!U'Qa~P#0aO!_#UO'}'SO!T'Ra!e'Ra~O!T-zO!e([i~O!T-zO!_#UO!e([i~Oe$qq!T$qq#T$qq#u$qq~P!&VO!Q'Ta!T'Ta~P!G[O!_5{O~O!T.SO!Q(]i~P!G[O!T.SO!Q(]i~O!Q6PO~O!_#UO#k6UO~Ok6VO!_#UO'}'SO~O!Q6XO~Oe$sq!T$sq#T$sq#u$sq~P!&VO_$ey!T$ey'e$ey'a$ey!Q$ey!e$eyo$ey!V$ey%]$ey!_$ey~P!-RO!T3VO!V(^a~O_#Wy!T#Wy'e#Wy'a#Wy!Q#Wy!e#Wyo#Wy!V#Wy%]#Wy!_#Wy~P!-ROZ6^O~O]6`O'j*RO~O!T/SO!U(di~O]6cO~O^6dO~O!_4tO~O's'lO!T'YX!U'YX~O!T3nO!U(aa~O!f$mO'n$bO_'xX!_'xX!l'xX#T'xX'e'xX'}'xX~O'j6mO~P,RO!u;WO!y6oO!z6nO!{6nO#P1PO#Q1PO~P$%_O_$pO!_#UO!l1UO#T1SO'e$pO'}'SO~O!U6rO~P$BTO]&VOl&VO{6sO's)TO'|+zO~O!Y6wO!Z6vO![6vO#P1PO#Q1PO'|+zO~P!AQO!Y6wO!Z6vO![6vO!z6xO!{6xO#P1PO#Q1PO'|+zO~P!AQO!Z6vO![6vO'k$vO's)TO'|+zO~O!V/oO~O!V/oO%]6zO~O!V/oO%]6zO~P!G[OP7PO!V/oO!q7OO%]6zO~OZ7UO!T']a!U']a~O!T/{O!U(bi~O]7XO~O!e7YO~O!e7ZO~O!e7[O~O!e7[O~P$}O_7^O~O!_7aO~O!e7bO~O!T(Si!U(Si~P#0aO_$pO#T7iO'e$pO~O_$pO!_#UO#T7iO'e$pO~O!Z7mO![7mO'|+zO~P!AQO_$pO!_#UO!f$mO!l7nO#T7iO'e$pO'n$bO'}'SO~O!Y7oO!Z7mO![7mO'|+zO~P!AQO!Y7oO!Z7mO![7mO!|7rO#P7sO#Q7sO'|+zO~P!AQO_$pO!_#UO!l7nO#T7iO'e$pO'}'SO~O_$pO'e$pO~P!-RO!T'WO!e(Oy~O!T(Py!e(Py_(Py'e(Py~P!-RO!V&cO%]7xO~O!V&cO%]7xO~P!G[O#`$qqQ$qqZ$qq_$qqk$qqy$qq!T$qq!c$qq!d$qq!f$qq!l$qq#c$qq#d$qq#e$qq#f$qq#g$qq#h$qq#i$qq#j$qq#k$qq#m$qq#o$qq#q$qq#r$qq'e$qq'r$qq'}$qq!e$qq!Q$qq'a$qq!V$qq#T$qqo$qq%]$qq!_$qq~P!G[O#`$sqQ$sqZ$sq_$sqk$sqy$sq!T$sq!c$sq!d$sq!f$sq!l$sq#c$sq#d$sq#e$sq#f$sq#g$sq#h$sq#i$sq#j$sq#k$sq#m$sq#o$sq#q$sq#r$sq'e$sq'r$sq'}$sq!e$sq!Q$sq'a$sq!V$sq#T$sqo$sq%]$sq!_$sq~P!G[O!T&xi!e&xi~P!-RO#u#Wq!T#Wq!U#Wq~P#0aOx.nOy.nO{.oOPua(Uua(Vua!Uua~OQuaZuakua!cua!dua!fua!lua#cua#dua#eua#fua#gua#hua#iua#jua#kua#mua#oua#qua#rua#uua'rua'}ua!Tua~P%LmOx(mO{(nOP$ha(U$ha(V$ha!U$ha~OQ$haZ$hak$hay$ha!c$ha!d$ha!f$ha!l$ha#c$ha#d$ha#e$ha#f$ha#g$ha#h$ha#i$ha#j$ha#k$ha#m$ha#o$ha#q$ha#r$ha#u$ha'r$ha'}$ha!T$ha~P%NtOx(mO{(nOP$ja(U$ja(V$ja!U$ja~OQ$jaZ$jak$jay$ja!c$ja!d$ja!f$ja!l$ja#c$ja#d$ja#e$ja#f$ja#g$ja#h$ja#i$ja#j$ja#k$ja#m$ja#o$ja#q$ja#r$ja#u$ja'r$ja'}$ja!T$ja~P&!{OQ$xaZ$xak$xay$xa!c$xa!d$xa!f$xa!l$xa#c$xa#d$xa#e$xa#f$xa#g$xa#h$xa#i$xa#j$xa#k$xa#m$xa#o$xa#q$xa#r$xa#u$xa'r$xa'}$xa!T$xa!U$xa~P%5OO#u$dq!T$dq!U$dq~P#0aO#u$eq!T$eq!U$eq~P#0aO!U8RO~O#u8SO~P!&VO!_#UO!T'Ri!e'Ri~O!_#UO'}'SO!T'Ri!e'Ri~O!T-zO!e([q~O!Q'Ti!T'Ti~P!G[O!T.SO!Q(]q~O!Q8YO~P!G[O!Q8YO~Oe'py!T'py~P!&VO!T'Wa!V'Wa~P!G[O!V%Pq_%Pq!T%Pq'e%Pq~P!G[OZ8_O~O!T/SO!U(dq~O]8bO~O#T8cO!T'Ya!U'Ya~O!T3nO!U(ai~P#0aOQ[XZ[Xk[Xx[Xy[X{[X!Q[X!T[X!c[X!d[X!f[X!l[X#T[X#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'r[X'}[X(U[X(V[X~O!_$}X#k$}X~P&*pO#P5UO#Q5UO~P$%_O!z8gO!{8gO#P5UO#Q5UO~P$%_O!Z8jO![8jO'k$vO's)TO'|+zO~O!Y8mO!Z8jO![8jO#P5UO#Q5UO'|+zO~P!AQO!V/oO%]8pO~O!V/oO%]8pO~P!G[O]8wO's8vO~O!T/{O!U(bq~O!e8yO~O!e8yO~P$}O!e8{O~O!e8|O~O#T9OO!T#]y!U#]y~O!T#]y!U#]y~P#0aO_$pO#T9RO'e$pO~O_$pO!_#UO#T9RO'e$pO~O!Z9WO![9WO'|+zO~P!AQO_$pO!_#UO!l9XO#T9RO'e$pO'}'SO~O!f$mO'n$bO~P&0|O!Y9YO!Z9WO![9WO'|+zO~P!AQO!V&cO%]9^O~O!V&cO%]9^O~P!G[O#u#sy!T#sy!U#sy~P#0aOQ$qiZ$qik$qiy$qi!c$qi!d$qi!f$qi!l$qi#c$qi#d$qi#e$qi#f$qi#g$qi#h$qi#i$qi#j$qi#k$qi#m$qi#o$qi#q$qi#r$qi#u$qi'r$qi'}$qi!T$qi!U$qi~P%5OOx(mO{(nO(V(rOP%Ti(U%Ti!U%Ti~OQ%TiZ%Tik%Tiy%Ti!c%Ti!d%Ti!f%Ti!l%Ti#c%Ti#d%Ti#e%Ti#f%Ti#g%Ti#h%Ti#i%Ti#j%Ti#k%Ti#m%Ti#o%Ti#q%Ti#r%Ti#u%Ti'r%Ti'}%Ti!T%Ti~P&4cOx(mO{(nOP%Vi(U%Vi(V%Vi!U%Vi~OQ%ViZ%Vik%Viy%Vi!c%Vi!d%Vi!f%Vi!l%Vi#c%Vi#d%Vi#e%Vi#f%Vi#g%Vi#h%Vi#i%Vi#j%Vi#k%Vi#m%Vi#o%Vi#q%Vi#r%Vi#u%Vi'r%Vi'}%Vi!T%Vi~P&6jO#u$ey!T$ey!U$ey~P#0aO#u#Wy!T#Wy!U#Wy~P#0aO!_#UO!T'Rq!e'Rq~O!T-zO!e([y~O!Q'Tq!T'Tq~P!G[O!Q9dO~P!G[O!T/SO!U(dy~O!T3nO!U(aq~O#P7sO#Q7sO~P$%_O!Z9nO![9nO'k$vO's)TO'|+zO~O!V/oO%]9qO~O!V/oO%]9qO~P!G[O!e9tO~O_$pO#T9zO'e$pO~O_$pO!_#UO#T9zO'e$pO~O!Z9}O![9}O'|+zO~P!AQO_$pO!_#UO!l:OO#T9zO'e$pO'}'SO~OQ$qqZ$qqk$qqy$qq!c$qq!d$qq!f$qq!l$qq#c$qq#d$qq#e$qq#f$qq#g$qq#h$qq#i$qq#j$qq#k$qq#m$qq#o$qq#q$qq#r$qq#u$qq'r$qq'}$qq!T$qq!U$qq~P%5OOQ$sqZ$sqk$sqy$sq!c$sq!d$sq!f$sq!l$sq#c$sq#d$sq#e$sq#f$sq#g$sq#h$sq#i$sq#j$sq#k$sq#m$sq#o$sq#q$sq#r$sq#u$sq'r$sq'}$sq!T$sq!U$sq~P%5OOe%X!Z!T%X!Z#T%X!Z#u%X!Z~P!&VO!T'Yq!U'Yq~P#0aO!T#]!Z!U#]!Z~P#0aO_$pO#T:aO'e$pO~O_$pO!_#UO#T:aO'e$pO~O#`%X!ZQ%X!ZZ%X!Z_%X!Zk%X!Zy%X!Z!T%X!Z!c%X!Z!d%X!Z!f%X!Z!l%X!Z#c%X!Z#d%X!Z#e%X!Z#f%X!Z#g%X!Z#h%X!Z#i%X!Z#j%X!Z#k%X!Z#m%X!Z#o%X!Z#q%X!Z#r%X!Z'e%X!Z'r%X!Z'}%X!Z!e%X!Z!Q%X!Z'a%X!Z!V%X!Z#T%X!Zo%X!Z%]%X!Z!_%X!Z~P!G[O_$pO#T:oO'e$pO~OP=nOx(mO{(nO(U(pO(V(rO~O]#Sal#Sa!U#Sa!Y#Sa!Z#Sa![#Sa!u#Sa!y#Sa!z#Sa!{#Sa#P#Sa#Q#Sa'k#Sa's#Sa'|#Sa~P&D[OQ%X!ZZ%X!Zk%X!Zy%X!Z!c%X!Z!d%X!Z!f%X!Z!l%X!Z#c%X!Z#d%X!Z#e%X!Z#f%X!Z#g%X!Z#h%X!Z#i%X!Z#j%X!Z#k%X!Z#m%X!Z#o%X!Z#q%X!Z#r%X!Z#u%X!Z'r%X!Z'}%X!Z!T%X!Z!U%X!Z~P%5OO]ualua!Yua!Zua![ua!uua!yua!zua!{ua#Pua#Qua'kua'sua'|ua~P%LmO]$hal$ha!Y$ha!Z$ha![$ha!u$ha!y$ha!z$ha!{$ha#P$ha#Q$ha'k$ha's$ha'|$ha~P%NtO]$jal$ja!Y$ja!Z$ja![$ja!u$ja!y$ja!z$ja!{$ja#P$ja#Q$ja'k$ja's$ja'|$ja~P&!{O]$xal$xa!U$xa!Y$xa!Z$xa![$xa!u$xa!y$xa!z$xa!{$xa#P$xa#Q$xa'k$xa's$xa'|$xa~P&D[O]%Til%Ti!Y%Ti!Z%Ti![%Ti!u%Ti!y%Ti!z%Ti!{%Ti#P%Ti#Q%Ti'k%Ti's%Ti'|%Ti~P&4cO]%Vil%Vi!Y%Vi!Z%Vi![%Vi!u%Vi!y%Vi!z%Vi!{%Vi#P%Vi#Q%Vi'k%Vi's%Vi'|%Vi~P&6jO]$qil$qi!U$qi!Y$qi!Z$qi![$qi!u$qi!y$qi!z$qi!{$qi#P$qi#Q$qi'k$qi's$qi'|$qi~P&D[O]$qql$qq!U$qq!Y$qq!Z$qq![$qq!u$qq!y$qq!z$qq!{$qq#P$qq#Q$qq'k$qq's$qq'|$qq~P&D[O]$sql$sq!U$sq!Y$sq!Z$sq![$sq!u$sq!y$sq!z$sq!{$sq#P$sq#Q$sq'k$sq's$sq'|$sq~P&D[O]%X!Zl%X!Z!U%X!Z!Y%X!Z!Z%X!Z![%X!Z!u%X!Z!y%X!Z!z%X!Z!{%X!Z#P%X!Z#Q%X!Z'k%X!Z's%X!Z'|%X!Z~P&D[Oo'tX~P/WO!QdX!TdX#TdX~P&*pOQ[XZ[Xk[Xx[Xy[X{[X!T[X!TdX!c[X!d[X!f[X!l[X#T[X#TdX#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'r[X'}[X(U[X(V[X~O!_dX!e[X!edX'}dX~P'$ZOQ;VOR;VO]gOb=ZOc!`OigOk;VOlgOmgOrgOt;VOv;VO{SO!OgO!PgO!VTO!a;YO!fVO!i;VO!j;VO!k;VO!l;VO!m;VO!p!_O#|!bO$QbO'j'|O'rRO'|WO(Z=XO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;pO{$[O!V$]O!a=aO!f$XO#_;yO#|$iO$i;sO$k;vO$n$jO'j'dO'n$bO'r$UO~O!T;jO!U$ga~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;qO{$[O!V$]O!a=bO!f$XO#_;zO#|$iO$i;tO$k;wO$n$jO'j'dO'n$bO'r$UO~O#l(TO~P'*^O!U[X!UdX~P'$ZO!_;^O~O#`;]O~O!_#UO#`;]O~O#T;nO~O#k;cO~O#T;{O!T(SX!U(SX~O#T;nO!T(QX!U(QX~O#`;|O~Oe<OO~P!&VO#`<VO~O#`<WO~O#`<XO~O!_#UO#`<YO~O!_#UO#`;|O~O#u<ZO~P#0aO#`<[O~O#`<]O~O#`<^O~O#`<_O~O#`<`O~O#`<aO~O#`<bO~O#`<cO~O!Q<dO~O#u<eO~P!&VO#u<fO~P!&VO#u<gO~P!&VO!Q<hO~P!G[O!Q<hO~O!Q<iO~P!G[O!_#UO#k=gO~O!_#UO#k=iO~O$Q~!d!y!{!|#P#^#_#j(Z$i$k$n%Q%[%]%^%d%f%i%j%l%n~UT$Q(Z#d!P'g'k#el#c#fkx'h's'h'j$S$U$S~",
        goto: "$(n(hPPPPPPPP(iP(yP*tPPPP.mPP/SP4y9R9fP9fPPP9fP;l9fP9fP9fP;pPP;vP<a@}PPPARPPPPARC|PPPDSE|PARPHdPPPPJbARPPPPPLlARPP! z!#O!#SP!#s!#w!#sPPPP!&|!(wPP!)P!*VP!#OARAR!-m!0q!5r!5r!9cPPP!9jARPPPPPPPPPPP!<iP!=|PPAR!?]PARPARARARARPAR!@tPP!CvP!FtP!Fx!GQ!GU!GUP!CsP!GY!GYP!JWP!J[ARAR!Jb!M_9fP9fP9f9fP!Ni9f9f#!y9f#%v9f#(Q9f9f#(n#+Q#+Q#+U#+^#+Q#+jP#+QP9f#,f9f#.T9f9f.mPPP#/vPP#0`#0`P#0`P#0u#0`PP#0{P#0rP#0r#1_!({#0r#1|#2S#2V(i#2Y(iP#2a#2a#2aP(iP(iP(iP(iPP(iP#2g#2jP#2j(iP#2nP#2qP(iP(iP(iP(iP(iP(i(iP#2w#3R#3X#3_#3m#3s#3y#4T#4Z#5U#5e#5k#5}#6T#6Z#6i#7O#8w#9V#9]#9c#9i#9o#9y#:P#:V#:a#:s#:yPPPPPPPP#;PPP#;s#?TP#@o#@v#AOPP#Fp#If$ o$ r$ u$#h$#k$#nPP$#t$#x$$q$%q$%u$&ZPP$&_$&e$&iP$&l$&p$&s$'f$'|$(R$(U$(X$(_$(b$(f$(jmlOTn!R!s$o%t%v%w%y+X+^0]0`Q${qQ%StQ%l}S&Z!]+rQ&j!`S)V$])[Q*P$|Q*^%UQ*x%fQ+x&bS+|&c,OQ,`&kQ.e)^Q/z*y[0z+y,Q,R,S,T,US3w/o3yW5Q0{0|0}1OU6v3|3}4OU7m5R5T5VS8j6w6xS9W7o7rQ9n8mR9}9Y%Q`OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oS#PX;W!l(O#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[Q)g$fQ*U%OQ*z%iQ+R%qQ-O;oQ.|)yQ/X*VQ0S+PQ3_/SQ4^/{Q5m;qQ6`3`R:q;ppiOTn}!R!s$o%k%t%v%w%y+X+^0]0`R*|%m&j[OPTUnor!R!W!a!c!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&e&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=Z=[[!lSV!g!j&[&pQ$upQ$zqS%Pt%U!U%Yvw!v!x!{$m%W&y'Q'R'W*a*b*d+V+k,i,l,p,q,s0e1g1h4t5aQ%b{Q&g!_Q&i!`Q'_#RS(x$X(|S*O${$|Q*S%OQ*s%dQ*w%fS,_&j&kQ,}'`Q.O(yQ/Q*PQ/W*VQ/Y*WQ/]*[Q/u*tS/y*x*yQ1a,`Q2g-zQ3^/SQ3b/VQ3g/_Q4]/zQ5x2hQ6_3`Q6b3dQ8^6^R9f8_x$Ze#W$g$h$l(q(s({)b)c-U.R.q2f3O8S=X=d=e=f!^$xq!`$z${$|&Y&i&j&k)U*O*P+o+{,_,`.]/Q0w0y1V1a2z5P5S7l7q9U9{:bQ)x$uQ*i%_Q*l%`Q*v%fQ,|'_Q/t*sU/x*w*x*yQ1q,}Q4W/uS4[/y/zS6l3r3vQ7T4]U8h6p6t6uU9l8i8k8lQ:W9mQ:i:X#b=]#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=od=^;^;s;v;y<Q<T<W<]<`<fg=_;l;m;t;w;z<R<U<X<^<a<gW$`e$b)d=XS%_x%kQ%`yQ%azR*g%]%X$_e#U#W#r#s$X$[$g$h$l&f(h(q(s(t({)R)b)c)u)w)y*h*k,[,y,{-U.R.S.U.q/f/i/q/s1n1p2f2p2x3O3V3X4T4V5c5h5{6U6z7P7x8S8p9^9q;^;l;m;r;s;t;u;v;w;x;y;z<P<Q<R<S<T<U<V<W<X<[<]<^<_<`<a<e<f<g=X=d=e=f=g=i=m=n=oT(i$U(jX)h$f;o;p;qU&_!]%X+uS'm#Y#ZQ*Z%RS,u'Z'[Q/j*mQ3P.nR6h3n&pgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[$a#o_!i!t$s&o&u'b'i'q'r's't'u'v'w'x'y'z'{'}(Q(U(`*Y+p,c,h,m-T-Z-_-a-p.r0l0o1d1w1|1}2O2P2Q2R2S2T2U2V2W2X2Y2]2b3T3[4x5Y5_5k5l5q5r6j7d7g7{8P8Q9Q9h9u9w:_:m:z;X<wT!dR!e&qgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[Q&]!]R0s+r!n&V!]&Z&b&c+r+x+y+|,O,Q,R,S,T,U,V0z0{0|0}1O1P3t3{5Q5R5T5U5V6n6o7m7o7r7s8g9W9Y9}S)U$])[S.])V)^Q.f)_Q/l*oQ2z.eQ2}.hS3r/o3yS6p3w4OS6t3|3}S8i6v6wQ8k6xS9m8j8mR:X9nllOTn!R!s$o%t%v%w%y+X+^0]0`Q%{!US'a#T;]Q)|$yQ*q%bQ*r%cQ,]&hS-S'f;|S.s)o<YQ/O)}Q/n*pQ0d+`Q0f+aQ0n+lQ1Y,SQ1_,^S3U.t<bQ3Y/PS3]/R<cQ4w0qQ5X1QQ5[1`Q6]3ZQ7e4yQ7f4zQ7t5]Q8}7bQ9S7kQ9x9TQ:^9yQ:l:`R:y:n$[#n_!i!t&o&u'b'i'q'r's't'u'v'w'x'y'z'{'}(Q(U(`*Y+p,c,h,m-T-Z-_-p.r0l0o1d1w1|1}2O2P2Q2R2S2T2U2V2W2X2Y2]2b3T3[4x5Y5_5k5l5q5r6j7d7g7{8P8Q9Q9h9u9w:_:m:z;X<wS'^#O0xU)a$^'e2[T)s$s-a$[#m_!i!t&o&u'b'i'q'r's't'u'v'w'x'y'z'{'}(Q(U(`*Y+p,c,h,m-T-Z-_-p.r0l0o1d1w1|1}2O2P2Q2R2S2T2U2V2W2X2Y2]2b3T3[4x5Y5_5k5l5q5r6j7d7g7{8P8Q9Q9h9u9w:_:m:z;X<wS']#O0xS'o#Z#nS)r$s-aS,v'['^Q-b(PQ.u)sR1i,w&pgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[S#PX;WQ%v!PQ%w!QQ%y!SQ%z!TR0[+[Q&d!_Q)t$uQ,Y&gS,x'_)xS1[,W,XY1m,|,}.w.x.yS5Z1]1^W5b1j1k1l1qU7w5d5e5fU9[7v7y7zQ:P9]R:d:QT+}&c,O!]YOTVZn}!R!s!v$m$o%k%m%t%v%w%y&c'W+X+^+y,O,p/o0]0`3t3yT#PX;W%SsOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oS'm#Y#ZS,u'Z'[!m<m#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[S+{&c,OW0y+y,S,T,UU1V+|,Q,RU1Z,V3t3{S3v/o3yU5P0z0{0|S5S0}1OU5W1P6n6oS6p3w4OS6u3|3}U7l5Q5R5TS7p5U8gQ7q5VS8i6v6wQ8l6xU9U7m7o7rQ9Z7sS9m8j8mS9{9W9YQ:X9nR:b9}S+}&c,OT3x/o3yS'V!w0YQ-}(xQ.Z)UU1U+{3u3vQ2l.OS2u.[.fU5O0y1Z6uQ5w2gS6S2{2}U7n5S5W8lQ8U5xQ8]6VS9X7p7qR:O9ZQ#V^S'U!w0YQ)p$nQ)z$wQ*Q$}Q,o'VQ-|(xQ.Y)UQ.`)XQ.}){Q/v*uU1T+{3u3vS2k-}.OS2t.Z.fQ2w._Q2y.aQ4Y/wW4}0y1U1Z6uQ5v2gQ5z2lS6O2u2}Q6T2|Q7R4ZW7j5O5S5W8lS8T5w5xS8X6P<dQ8Z6SQ8e6kQ8t7SU9V7n7p7qQ9b8US9c8Y<hQ9e8]Q9j8fQ9s8uS9|9X9ZS:S9d<iQ:U9kQ:c:OQ:g:VQ:v:hQ;P:wQ<p<kQ=O<uQ=P<vQ=Q=cR=V=h%S]OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oS#Vr!a!l<j#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[R<p=Z%S^OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oQ$nf!^$wq!`$z${$|&Y&i&j&k)U*O*P+o+{,_,`.]/Q0w0y1V1a2z5P5S7l7q9U9{:bS$}r!aQ){$xQ*u%fW/w*v*w*x*yU4Z/x/y/zS6k3r3vS7S4[4]W8f6l6p6t6uQ8u7TW9k8h8i8k8lS:V9l9mS:h:W:XQ:w:i!l<k#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[Q<u=YR<v=Z$vaOPTUno!R!W!c!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%t%v%w%y%}&W&e&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oY!qSV!g!j&p!U%Yvw!v!x!{$m%W&y'Q'R'W*a*b*d+V+k,i,l,p,q,s0e1g1h4t5aQ+S%q!j<l#k#|(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[R<o&[S&`!]%XR0u+u%Q`OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:o!l(O#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[R+R%q!j#e_!i$s&o&u'b'i'x'y'z'{(Q(U*Y,c,h,m-T-Z-p.r1d1w2Y3T3[5Y5_5k7g9Q9w:_:m:z;X!T;e'}(`+p-a0l0o1|2U2V2W2X2]2b4x5l5q5r6j7d7{8P8Q9h9u<w!f#g_!i$s&o&u'b'i'z'{(Q(U*Y,c,h,m-T-Z-p.r1d1w2Y3T3[5Y5_5k7g9Q9w:_:m:z;X!P;g'}(`+p-a0l0o1|2W2X2]2b4x5l5q5r6j7d7{8P8Q9h9u<w!b#k_!i$s&o&u'b'i(Q(U*Y,c,h,m-T-Z-p.r1d1w2Y3T3[5Y5_5k7g9Q9w:_:m:z;XQ2f-xz=['}(`+p-a0l0o1|2]2b4x5l5q5r6j7d7{8P8Q9h9u<wQ=d=jQ=e=kR=f=l&pgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[S#}d$OR2_-e&wcOPSTUVdno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$O$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-e-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[T#yb$PS#wb$PT(X#z(]T#xb$PT(Z#z(]&wdOPSTUVdno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$O$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-e-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[T#}d$OQ$QdR(d$O%SfOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:o!m=Y#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[#ahOPTVn!R!W!c!s!}#[#|$o%m%p%q%t%v%w%y%}&W&e'n(b)v*c+T+X+^+n,Z,z-f.o/r0T0U0V0X0]0`0b1o2^3s4U4i4k4l5g6s7O7^!^$^e#W$g$h$l(q(s({)b)c-U.R.q2f3O8S;^;s;v;y<Q<T<W<]<`<f=X=d=e=f#b'e#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=oQ)l$jQ-q(mg2[;l;m;t;w;z<R<U<X<^<a<gx$Ye#W$g$h$l(q(s({)b)c-U.R.q2f3O8S=X=d=e=fQ(}$ZS)X$])[Q)m$kQ.a)Y#b<r#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=od<s;^;s;v;y<Q<T<W<]<`<ff<t;l;m;t;w;z<R<U<X<^<a<gQ<x=]Q<y=^Q<z=_Q<{=`Q<|=aR<}=b!^$^e#W$g$h$l(q(s({)b)c-U.R.q2f3O8S;^;s;v;y<Q<T<W<]<`<f=X=d=e=f#b'e#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=og2[;l;m;t;w;z<R<U<X<^<a<gljOTn!R!s$o%t%v%w%y+X+^0]0`Q)Q$[Q+g&QQ+h&SR2o.S%W$_e#U#W#r#s$X$[$g$h$l&f(h(q(s(t({)R)b)c)u)w)y*h*k,[,y,{-U.R.S.U.q/f/i/q/s1n1p2f2p2x3O3V3X4T4V5c5h5{6U6z7P7x8S8p9^9q;^;l;m;r;s;t;u;v;w;x;y;z<P<Q<R<S<T<U<V<W<X<[<]<^<_<`<a<e<f<g=X=d=e=f=g=i=m=n=oQ*j%`Q/h*lQ3l/gR6g3mT)Z$])[S)Z$])[T3x/o3yQ._)WQ2|.gQ=c3sR=h6sQ)z$wQ.`)XQ.}){Q/v*uQ4Y/wQ7R4ZQ8e6kQ8t7SQ9j8fQ9s8uQ:U9kQ:g:VQ:v:hR;P:wp(q$V'g)n.Q.i.j1u2m3S5u6W9a<q=R=S=T!p<P'c(S(w)P,X-R-m-x.V.v.y/e/g1^1l1t2n2r3k3m4R5f5i5j5|6Q6Y6[6}7z8W8[8r:R=U=W=j=k=l[<Q:e:t:};R;S;U]<R2Z5p7|9_9`:pr(s$V'g)n-v.Q.i.j1u2m3S5u6W9a<q=R=S=T!r<S'c(S(w)P,X-R-m-x.V.v.y/e/g1^1l1r1t2n2r3k3m4R5f5i5j5|6Q6Y6[6}7z8W8[8r:R=U=W=j=k=l^<T:e:t:{:};R;S;U_<U2Z5p7|7}9_9`:ppiOTn}!R!s$o%k%t%v%w%y+X+^0]0`Q%h|R+T%qpiOTn}!R!s$o%k%t%v%w%y+X+^0]0`R%h|Q*n%aR/d*gqiOTn}!R!s$o%k%t%v%w%y+X+^0]0`Q/p*sS4S/t/uW6y4P4Q4R4WU8o6{6|6}U9o8n8q8rQ:Y9pR:j:ZQ%o}R*}%kR4a/}R8w7US%Pt%UR/Y*WQ%t!OR+X%uR+_%zT0^+^0`R+c%{Q+b%{R0g+cQnOQ!sTT$rn!sQ(j$UR-n(jQ!eRR&m!eQ!hSU&s!h&t,fQ&t!iR,f&uQ+s&]R0t+sQ-V'gR1v-VQ-Y'iS1y-Y1zR1z-ZQ,O&cR1W,OrZOTn}!R!s$o%k%m%t%v%w%y+X+^0]0`S!vV$mY#QZ!v+y,p3tS+y&c,OQ,p'WT3t/o3yS!nS%WU&z!n&{,gQ&{!oR,g&vQ+v&`R0v+vQ'X!yQ,j'PW,t'X,j1b5^Q1b,kR5^1cQ(]#zR-g(]Q$OdR(c$OQ#q_U(R#q,b;kQ,b;XR;k(`Q-{(xW2i-{2j5y8VU2j-|-}.OS5y2k2lR8V5z$m(o$V'c'g(S(w)P)i)j)n,X-P-Q-R-m-v-w-x.Q.V.i.j.v.y/e/g1^1l1r1s1t1u2Z2m2n2r3S3k3m4R5f5i5j5n5o5p5u5|6Q6W6Y6[6}7z7|7}8O8W8[8r9_9`9a:R:e:p:r:s:t:{:|:};R;S;U<q=R=S=T=U=W=j=k=lQ.T)PU2q.T2s5}Q2s.VR5}2rQ)[$]R.c)[Q)e$aR.l)eQ3W.vR6Z3WQ*e%ZR/c*eQ3o/jS6i3o8dR8d6jQ*p%bR/m*pQ3y/oR6q3yQ/|*zS4_/|7VR7V4aQ/T*SW3a/T3c6a8`Q3c/WQ6a3bR8`6bQ*X%PR/Z*XQ0`+^R4o0`WmOTn!sQ%x!RQ)q$oQ+W%tQ+Y%vQ+Z%wQ+]%yQ0Z+XS0^+^0`R4n0]Q$qkQ%|!VQ&P!XQ&R!YQ&T!ZQ*`%VQ*f%[Q*|%oQ+e&OQ.b)ZS0P*}+QQ0h+dQ0i+gQ0j+hU1R+{3u3vQ3f/^Q3j/eQ4X/vQ4c0RQ4m0[Y4{0y1T1U1Z6uQ6e3hQ6f3kQ7Q4YQ7W4b[7h4}5O5S5W5Y8lQ8a6cQ8s7RQ8x7XY9P7g7j7n7p7qQ9g8bQ9i8eQ9r8tW9v9Q9V9X9ZQ:T9jQ:[9sU:]9w9|:OQ:f:US:k:_:cQ:u:gQ:x:mQ;O:vQ;Q:zR;T;PQ$yqQ&h!`U)}$z${$|Q+l&YU,^&i&j&kQ.X)US/P*O*PQ0q+oQ1Q+{S1`,_,`Q2v.]Q3Z/QQ4y0wS4z0y1VQ5]1aQ6R2zS7k5P5SS9T7l7qQ9y9UQ:`9{R:n:bS$We=XR)f$bU$ae$b=XR.k)dQ$VeS'c#U)yQ'g#WS(S#r#sQ(w$XQ)P$[Q)i$gQ)j$hQ)n$lQ,X&fQ-P;rQ-Q;uQ-R;xQ-m(hQ-v(qQ-w(sQ-x(tQ.Q({Q.V)RQ.i)bQ.j)cf.v)u,y/q1n4T5c6z7x8p9^9qQ.y)wQ/e*hQ/g*kQ1^,[Q1l,{Q1r<PQ1s<SQ1t<VQ1u-US2Z;l;mQ2m.RQ2n.SQ2r.UQ3S.qQ3k/fQ3m/iQ4R/sQ5f1pQ5i<[Q5j<_Q5n;tQ5o;wQ5p;zQ5u2fQ5|2pQ6Q2xQ6W3OQ6Y3VQ6[3XQ6}4VQ7z5hQ7|<XQ7}<RQ8O<UQ8W5{Q8[6UQ8r7PQ9_<^Q9`<aQ9a8SQ:R<eQ:e;^Q:p<gQ:r;sQ:s;vQ:t;yQ:{<QQ:|<TQ:}<WQ;R<]Q;S<`Q;U<fQ<q=XQ=R=dQ=S=eQ=T=fQ=U=gQ=W=iQ=j=mQ=k=nR=l=olkOTn!R!s$o%t%v%w%y+X+^0]0`Q!^PS!uV!}Q&O!WQ&l!cQ'p#[Q(a#|S+Q%m%pQ+U%qQ+d%}Q+i&WQ,W&eQ-]'nQ-k(bQ.x)vQ/a*cQ0W+TU0p+n3s6sQ1],ZQ1k,zQ2a-fQ3Q.oQ4Q/rQ4e0TQ4f0UQ4h0VQ4j0XQ4q0bQ5e1oQ5s2^Q6|4UQ7]4iQ7_4kQ7`4lQ7y5gQ8q7OR8z7^#U_OPTVn!R!W!s!}#[$o%m%p%q%t%v%w%y%}&W&e'n)v*c+T+X+^+n,Z,z.o/r0T0U0V0X0]0`0b1o3s4U4i4k4l5g6s7O7^Q!iSQ!tUQ$soS&o!g&rQ&u!jQ'b#TQ'i#XQ'q#_Q'r#`Q's#aQ't#bQ'u#cQ'v#dQ'w#eQ'x#fQ'y#gQ'z#hQ'{#iQ'}#kQ(Q#pQ(U#tW(`#|(b-f2^Q*Y%QS+p&[0rS,c&p,eQ,h&xQ,m'TQ-T'fQ-Z'jQ-_;VQ-a;YQ-p(lQ.r)oQ0l+jQ0o+mQ1d,nQ1w-XQ1|;]Q1};_Q2O;`Q2P;aQ2Q;bQ2R;cQ2S;dQ2T;eQ2U;fQ2V;gQ2W;hQ2X;iQ2Y-`Q2];nQ2b;jQ3T.tQ3[/RQ4x;{Q5Y1SQ5_1eQ5k1xQ5l;|Q5q<OQ5r<YQ6j3pQ7d4uQ7g4|Q7{<ZQ8P<bQ8Q<cQ9Q7iQ9h8cQ9u9OQ9w9RQ:_9zQ:m:aQ:z:oQ;X!cR<w=[R!kSR&^!]S&Y!]+rS+o&Z&bS+{&c,OQ0w+xW0y+y,S,T,UU1V+|,Q,RY1Z,V3t3{3|3}S3u/o3yU5P0z0{0|S5S0}1OW5W1P6n6o6xU7l5Q5R5TS7p5U8gQ7q5VU9U7m7o7rQ9Z7sS9{9W9YR:b9}R'h#WR'k#XQ#OXR0x;WT!zV$mS!yV$mU%Zvw+VU'P!v!x!{S,k'Q'RQ,r'WQ/b*dQ1c,lU1f,p,q,sS5`1g1hR7u5a`!mS!g!j%W&p&y*a,it!wVvw!v!x!{$m'Q'R'W*d,l,p,q,s1g1h5aQ0Y+VQ0m+kQ4s0eQ7c4tT<n&[*bT!pS%WS!oS%WS&q!g&yS&v!j*aS+q&[*bT,d&p,iT&a!]%XQ#zbR(f$PT([#z(]R2`-eT(z$X(|R)S$[Q.w)uQ1j,yQ4P/qQ5d1nQ6{4TQ7v5cQ8n6zQ9]7xQ9p8pQ:Q9^R:Z9qllOTn!R!s$o%t%v%w%y+X+^0]0`Q%n}R*|%kV%[vw+VR/k*mR*{%iQ%TtR*_%UR*T%OT%r!O%uT%s!O%uT0_+^0`",
        nodeNames: "⚠ extends ArithOp ArithOp InterpolationStart LineComment BlockComment Script ExportDeclaration export Star as VariableName String from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression",
        maxTerm: 345,
        context: trackNewline,
        nodeProps: [["closedBy", 4, "InterpolationEnd", 43, "]", 53, "}", 68, ")", 140, "JSXSelfCloseEndTag JSXEndTag", 156, "JSXEndTag"], ["group", -26, 8, 15, 17, 60, 195, 199, 202, 203, 205, 208, 211, 222, 224, 230, 232, 234, 236, 239, 245, 251, 253, 255, 257, 259, 261, 262, "Statement", -30, 12, 13, 25, 28, 29, 34, 44, 46, 47, 49, 54, 62, 70, 76, 77, 99, 100, 109, 110, 127, 130, 132, 133, 134, 135, 137, 138, 158, 159, 161, "Expression", -23, 24, 26, 30, 33, 35, 37, 162, 164, 166, 167, 169, 170, 171, 173, 174, 175, 177, 178, 179, 189, 191, 193, 194, "Type", -3, 81, 92, 98, "ClassItem"], ["openedBy", 31, "InterpolationStart", 48, "[", 52, "{", 67, "(", 139, "JSXStartTag", 151, "JSXStartTag JSXStartCloseTag"]],
        propSources: [jsHighlight],
        skippedNodes: [0, 5, 6],
        repeatNodeCount: 29,
        tokenData: "#2k~R!bOX%ZXY%uYZ'kZ[%u[]%Z]^'k^p%Zpq%uqr(Rrs)mst7]tu9guv<avw=bwx>lxyJcyzJyz{Ka{|Lm|}MW}!OLm!O!PMn!P!Q!$v!Q!R!Er!R![!G_![!]!Nc!]!^!N{!^!_# c!_!`#!`!`!a##d!a!b#%s!b!c#'h!c!}9g!}#O#(O#O#P%Z#P#Q#(f#Q#R#(|#R#S9g#S#T#)g#T#o#)}#o#p#,w#p#q#,|#q#r#-j#r#s#.S#s$f%Z$f$g%u$g#BY9g#BY#BZ#.j#BZ$IS9g$IS$I_#.j$I_$I|9g$I|$I}#1X$I}$JO#1X$JO$JT9g$JT$JU#.j$JU$KV9g$KV$KW#.j$KW&FU9g&FU&FV#.j&FV;'S9g;'S;=`<Z<%l?HT9g?HT?HU#.j?HUO9gW%`T$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%ZW%rP;=`<%l%Z7Z%|i$`W'g7ROX%ZXY%uYZ%ZZ[%u[p%Zpq%uq!^%Z!_#o%Z#p$f%Z$f$g%u$g#BY%Z#BY#BZ%u#BZ$IS%Z$IS$I_%u$I_$JT%Z$JT$JU%u$JU$KV%Z$KV$KW%u$KW&FU%Z&FU&FV%u&FV;'S%Z;'S;=`%o<%l?HT%Z?HT?HU%u?HUO%Z7Z'rT$`W'h7RO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&y(YU$`W!l&qO!^%Z!_!`(l!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t(sU#m&l$`WO!^%Z!_!`)V!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t)^T#m&l$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z1i)t]$`W]&ZOY)mYZ*mZr)mrs,js!^)m!^!_-S!_#O)m#O#P1q#P#o)m#o#p-S#p;'S)m;'S;=`7V<%lO)m,^*rX$`WOr*mrs+_s!^*m!^!_+u!_#o*m#o#p+u#p;'S*m;'S;=`,d<%lO*m,^+fT$Z,U$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,U+xTOr+urs,Xs;'S+u;'S;=`,^<%lO+u,U,^O$Z,U,U,aP;=`<%l+u,^,gP;=`<%l*m1i,sT$Z,U$`W]&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z1a-XX]&ZOY-SYZ+uZr-Srs-ts#O-S#O#P-{#P;'S-S;'S;=`1k<%lO-S1a-{O$Z,U]&Z1a.OUOr-Srs.bs;'S-S;'S;=`0y;=`<%l/R<%lO-S1a.iW$Z,U]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s<%lO/R&Z/WW]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s<%lO/R&Z/uO]&Z&Z/xRO;'S/R;'S;=`0R;=`O/R&Z0WX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l/R<%lO/R&Z0vP;=`<%l/R1a1OX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l-S<%lO/R1a1nP;=`<%l-S1i1vY$`WOr)mrs2fs!^)m!^!_-S!_#o)m#o#p-S#p;'S)m;'S;=`6e;=`<%l/R<%lO)m1i2o]$Z,U$`W]&ZOY3hYZ%ZZr3hrs4hs!^3h!^!_/R!_#O3h#O#P5O#P#o3h#o#p/R#p;'S3h;'S;=`6_<%lO3h&c3o]$`W]&ZOY3hYZ%ZZr3hrs4hs!^3h!^!_/R!_#O3h#O#P5O#P#o3h#o#p/R#p;'S3h;'S;=`6_<%lO3h&c4oT$`W]&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c5TW$`WO!^3h!^!_/R!_#o3h#o#p/R#p;'S3h;'S;=`5m;=`<%l/R<%lO3h&c5rX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l3h<%lO/R&c6bP;=`<%l3h1i6jX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l)m<%lO/R1i7YP;=`<%l)m#]7b]$`WOt%Ztu8Zu!^%Z!_!c%Z!c!}8Z!}#R%Z#R#S8Z#S#T%Z#T#o8Z#p$g%Z$g;'S8Z;'S;=`9a<%lO8Z#]8b_$`W'|#TOt%Ztu8Zu!Q%Z!Q![8Z![!^%Z!_!c%Z!c!}8Z!}#R%Z#R#S8Z#S#T%Z#T#o8Z#p$g%Z$g;'S8Z;'S;=`9a<%lO8Z#]9dP;=`<%l8Z,T9ra$`W's#S'j)s$SSOt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$g%Z$g;'S9g;'S;=`<Z<%lO9g[;Oa$`W$SSOt%Ztu:wu}%Z}!O:w!O!Q%Z!Q![:w![!^%Z!_!c%Z!c!}:w!}#R%Z#R#S:w#S#T%Z#T#o:w#p$g%Z$g;'S:w;'S;=`<T<%lO:w[<WP;=`<%l:w,T<^P;=`<%l9g&t<hU$`W#e&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t=RT$`W#w&lO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z(h=iW(V(`$`WOv%Zvw>Rw!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t>YU$`W#q&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z1i>s]$`W]&ZOY>lYZ?lZw>lwx,jx!^>l!^!_@|!_#O>l#O#PE_#P#o>l#o#p@|#p;'S>l;'S;=`J]<%lO>l,^?qX$`WOw?lwx+_x!^?l!^!_@^!_#o?l#o#p@^#p;'S?l;'S;=`@v<%lO?l,U@aTOw@^wx,Xx;'S@^;'S;=`@p<%lO@^,U@sP;=`<%l@^,^@yP;=`<%l?l1aARX]&ZOY@|YZ@^Zw@|wx-tx#O@|#O#PAn#P;'S@|;'S;=`EX<%lO@|1aAqUOw@|wxBTx;'S@|;'S;=`Dg;=`<%lBt<%lO@|1aB[W$Z,U]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da<%lOBt&ZByW]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da<%lOBt&ZCfRO;'SBt;'S;=`Co;=`OBt&ZCtX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%lBt<%lOBt&ZDdP;=`<%lBt1aDlX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%l@|<%lOBt1aE[P;=`<%l@|1iEdY$`WOw>lwxFSx!^>l!^!_@|!_#o>l#o#p@|#p;'S>l;'S;=`Ik;=`<%lBt<%lO>l1iF]]$Z,U$`W]&ZOYGUYZ%ZZwGUwx4hx!^GU!^!_Bt!_#OGU#O#PHU#P#oGU#o#pBt#p;'SGU;'S;=`Ie<%lOGU&cG]]$`W]&ZOYGUYZ%ZZwGUwx4hx!^GU!^!_Bt!_#OGU#O#PHU#P#oGU#o#pBt#p;'SGU;'S;=`Ie<%lOGU&cHZW$`WO!^GU!^!_Bt!_#oGU#o#pBt#p;'SGU;'S;=`Hs;=`<%lBt<%lOGU&cHxX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%lGU<%lOBt&cIhP;=`<%lGU1iIpX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%l>l<%lOBt1iJ`P;=`<%l>l,TJjT!f+{$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$PKQT!e#w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z)ZKjW$`W'k#e#f&lOz%Zz{LS{!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&tLZU$`W#c&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z*qLtU$`Wk*iO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z,TM_T!T+{$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,TMuX$`Wx(dO!O%Z!O!PNb!P!Q%Z!Q![! d![!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$oNgV$`WO!O%Z!O!PN|!P!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$o! TT!S$g$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c! k]$`Wl&ZO!Q%Z!Q![! d![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S! d#S#X%Z#X#Y!!d#Y#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!!i]$`WO{%Z{|!#b|}%Z}!O!#b!O!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!#gX$`WO!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!$ZX$`Wl&ZO!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z7Z!$}b$`W#d&lOY!&VYZ%ZZz!&Vz{!-n{!P!&V!P!Q!BV!Q!^!&V!^!_!(f!_!`!Ch!`!a!Dm!a!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!&^^$`W!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!'aa$`W!PPO!^%Z!_#Z%Z#Z#[!'Y#[#]%Z#]#^!'Y#^#a%Z#a#b!'Y#b#g%Z#g#h!'Y#h#i%Z#i#j!'Y#j#m%Z#m#n!'Y#n#o%Z#p;'S%Z;'S;=`%o<%lO%ZP!(kX!PPOY!(fZ!P!(f!P!Q!)W!Q!}!(f!}#O!)o#O#P!*n#P;'S!(f;'S;=`!*}<%lO!(fP!)]U!PP#Z#[!)W#]#^!)W#a#b!)W#g#h!)W#i#j!)W#m#n!)WP!)rVOY!)oZ#O!)o#O#P!*X#P#Q!(f#Q;'S!)o;'S;=`!*h<%lO!)oP!*[SOY!)oZ;'S!)o;'S;=`!*h<%lO!)oP!*kP;=`<%l!)oP!*qSOY!(fZ;'S!(f;'S;=`!*}<%lO!(fP!+QP;=`<%l!(fX!+Y[$`WOY!+TYZ%ZZ!^!+T!^!_!)o!_#O!+T#O#P!,O#P#Q!&V#Q#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+TX!,TX$`WOY!+TYZ%ZZ!^!+T!^!_!)o!_#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+TX!,sP;=`<%l!+TX!,{X$`WOY!&VYZ%ZZ!^!&V!^!_!(f!_#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!-kP;=`<%l!&V7Z!-u`$`W!PPOY!-nYZ!.wZz!-nz{!2U{!P!-n!P!Q!@m!Q!^!-n!^!_!4m!_!}!-n!}#O!;l#O#P!?o#P#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!.|X$`WOz!.wz{!/i{!^!.w!^!_!0w!_#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!/nZ$`WOz!.wz{!/i{!P!.w!P!Q!0a!Q!^!.w!^!_!0w!_#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!0hT$`WU7RO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z7R!0zTOz!0wz{!1Z{;'S!0w;'S;=`!1x<%lO!0w7R!1^VOz!0wz{!1Z{!P!0w!P!Q!1s!Q;'S!0w;'S;=`!1x<%lO!0w7R!1xOU7R7R!1{P;=`<%l!0w7Z!2RP;=`<%l!.w7Z!2]`$`W!PPOY!-nYZ!.wZz!-nz{!2U{!P!-n!P!Q!3_!Q!^!-n!^!_!4m!_!}!-n!}#O!;l#O#P!?o#P#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!3ha$`WU7R!PPO!^%Z!_#Z%Z#Z#[!'Y#[#]%Z#]#^!'Y#^#a%Z#a#b!'Y#b#g%Z#g#h!'Y#h#i%Z#i#j!'Y#j#m%Z#m#n!'Y#n#o%Z#p;'S%Z;'S;=`%o<%lO%Z7R!4r[!PPOY!4mYZ!0wZz!4mz{!5h{!P!4m!P!Q!:b!Q!}!4m!}#O!6|#O#P!9r#P;'S!4m;'S;=`!:[<%lO!4m7R!5m[!PPOY!4mYZ!0wZz!4mz{!5h{!P!4m!P!Q!6c!Q!}!4m!}#O!6|#O#P!9r#P;'S!4m;'S;=`!:[<%lO!4m7R!6jUU7R!PP#Z#[!)W#]#^!)W#a#b!)W#g#h!)W#i#j!)W#m#n!)W7R!7PYOY!6|YZ!0wZz!6|z{!7o{#O!6|#O#P!9S#P#Q!4m#Q;'S!6|;'S;=`!9l<%lO!6|7R!7r[OY!6|YZ!0wZz!6|z{!7o{!P!6|!P!Q!8h!Q#O!6|#O#P!9S#P#Q!4m#Q;'S!6|;'S;=`!9l<%lO!6|7R!8mVU7ROY!)oZ#O!)o#O#P!*X#P#Q!(f#Q;'S!)o;'S;=`!*h<%lO!)o7R!9VVOY!6|YZ!0wZz!6|z{!7o{;'S!6|;'S;=`!9l<%lO!6|7R!9oP;=`<%l!6|7R!9uVOY!4mYZ!0wZz!4mz{!5h{;'S!4m;'S;=`!:[<%lO!4m7R!:_P;=`<%l!4m7R!:ga!PPOz!0wz{!1Z{#Z!0w#Z#[!:b#[#]!0w#]#^!:b#^#a!0w#a#b!:b#b#g!0w#g#h!:b#h#i!0w#i#j!:b#j#m!0w#m#n!:b#n;'S!0w;'S;=`!1x<%lO!0w7Z!;q^$`WOY!;lYZ!.wZz!;lz{!<m{!^!;l!^!_!6|!_#O!;l#O#P!>q#P#Q!-n#Q#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!<r`$`WOY!;lYZ!.wZz!;lz{!<m{!P!;l!P!Q!=t!Q!^!;l!^!_!6|!_#O!;l#O#P!>q#P#Q!-n#Q#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!={[$`WU7ROY!+TYZ%ZZ!^!+T!^!_!)o!_#O!+T#O#P!,O#P#Q!&V#Q#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+T7Z!>vZ$`WOY!;lYZ!.wZz!;lz{!<m{!^!;l!^!_!6|!_#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!?lP;=`<%l!;l7Z!?tZ$`WOY!-nYZ!.wZz!-nz{!2U{!^!-n!^!_!4m!_#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!@jP;=`<%l!-n7Z!@te$`W!PPOz!.wz{!/i{!^!.w!^!_!0w!_#Z!.w#Z#[!@m#[#]!.w#]#^!@m#^#a!.w#a#b!@m#b#g!.w#g#h!@m#h#i!.w#i#j!@m#j#m!.w#m#n!@m#n#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!B^X$`WT7ROY!BVYZ%ZZ!^!BV!^!_!By!_#o!BV#o#p!By#p;'S!BV;'S;=`!Cb<%lO!BV7R!COST7ROY!ByZ;'S!By;'S;=`!C[<%lO!By7R!C_P;=`<%l!By7Z!CeP;=`<%l!BV&u!Cq^$`W#w&l!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&V]!Dv^$PS$`W!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&V&c!Eyf$`Wl&ZO!O%Z!O!P! d!P!Q%Z!Q![!G_![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S!G_#S#U%Z#U#V!IR#V#X%Z#X#Y!!d#Y#b%Z#b#c!Hk#c#d!Js#d#l%Z#l#m!L_#m#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Gfa$`Wl&ZO!O%Z!O!P! d!P!Q%Z!Q![!G_![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S!G_#S#X%Z#X#Y!!d#Y#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!HrT$`Wl&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!IWY$`WO!Q%Z!Q!R!Iv!R!S!Iv!S!^%Z!_#R%Z#R#S!Iv#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!I}[$`Wl&ZO!Q%Z!Q!R!Iv!R!S!Iv!S!^%Z!_#R%Z#R#S!Iv#S#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!JxX$`WO!Q%Z!Q!Y!Ke!Y!^%Z!_#R%Z#R#S!Ke#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!KlZ$`Wl&ZO!Q%Z!Q!Y!Ke!Y!^%Z!_#R%Z#R#S!Ke#S#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Ld]$`WO!Q%Z!Q![!M]![!^%Z!_!c%Z!c!i!M]!i#R%Z#R#S!M]#S#T%Z#T#Z!M]#Z#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Md_$`Wl&ZO!Q%Z!Q![!M]![!^%Z!_!c%Z!c!i!M]!i#R%Z#R#S!M]#S#T%Z#T#Z!M]#Z#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m!NlT!_V$`W#u(^O!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z!P# ST_w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z6i# nR'n$Y!c(O$Q,_(ZP!P!Q# w!^!_# |!_!`#!ZW# |O$bW&l#!RP#g&l!_!`#!U&l#!ZO#w&l&l#!`O#h&l(m#!gV#T(e$`WO!^%Z!_!`(l!`!a#!|!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&u##TT#`&m$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m##oVe!s#h&l$]S$`WO!^%Z!_!`#$U!`!a#$l!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#$]T#h&l$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#$sV#g&l$`WO!^%Z!_!`<z!`!a#%Y!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#%aU#g&l$`WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m#%zX'}&q$`WO!O%Z!O!P#&g!P!^%Z!_!a%Z!a!b#&}!b#o%Z#p;'S%Z;'S;=`%o<%lO%Z(i#&nTy(a$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#'UU$`W#r&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z#_#'oT!u#V$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,P#(VT{+w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$P#(mT!Q#w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#)TU#o&l$`WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z){#)nT$`W'r)sO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,T#*Ya$`W's#S'j)s$USOt%Ztu#)}u}%Z}!O#+_!O!Q%Z!Q![#)}![!^%Z!_!c%Z!c!}#)}!}#R%Z#R#S#)}#S#T%Z#T#o#)}#p$g%Z$g;'S#)};'S;=`#,q<%lO#)}[#+fa$`W$USOt%Ztu#+_u}%Z}!O#+_!O!Q%Z!Q![#+_![!^%Z!_!c%Z!c!}#+_!}#R%Z#R#S#+_#S#T%Z#T#o#+_#p$g%Z$g;'S#+_;'S;=`#,k<%lO#+_[#,nP;=`<%l#+_,T#,tP;=`<%l#)}~#,|O!V~(h#-TV(U(`$`WO!^%Z!_!`<z!`#o%Z#p#q#&}#q;'S%Z;'S;=`%o<%lO%Z(}#-sT!U(soQ$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%ZX#.ZT!mP$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z7Z#.wt$`W'g7R's#S'j)s$SSOX%ZXY%uYZ%ZZ[%u[p%Zpq%uqt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$f%Z$f$g%u$g#BY9g#BY#BZ#.j#BZ$IS9g$IS$I_#.j$I_$JT9g$JT$JU#.j$JU$KV9g$KV$KW#.j$KW&FU9g&FU&FV#.j&FV;'S9g;'S;=`<Z<%l?HT9g?HT?HU#.j?HUO9g7Z#1fa$`W'h7R's#S'j)s$SSOt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$g%Z$g;'S9g;'S;=`<Z<%lO9g",
        tokenizers: [tsExtends, noSemicolon, incdecToken, template, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, insertSemicolon],
        topRules: {
            "Script": [0, 7],
            "SingleExpression": [1, 263]
        },
        dialects: {
            jsx: 13404,
            ts: 13406
        },
        dynamicPrecedences: {
            "159": 1,
            "187": 1
        },
        specialized: [{
            term: 302,
            get: value => spec_identifier$5[value] || -1
        }, {
            term: 311,
            get: value => spec_word[value] || -1
        }, {
            term: 65,
            get: value => spec_LessThan[value] || -1
        }],
        tokenPrec: 13429
    });
    const snippets$1 = [snippetCompletion("function ${name}(${params}) {\n\t${}\n}", {
        label: "function",
        detail: "definition",
        type: "keyword"
    }), snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", {
        label: "for",
        detail: "loop",
        type: "keyword"
    }), snippetCompletion("for (let ${name} of ${collection}) {\n\t${}\n}", {
        label: "for",
        detail: "of loop",
        type: "keyword"
    }), snippetCompletion("do {\n\t${}\n} while (${})", {
        label: "do",
        detail: "loop",
        type: "keyword"
    }), snippetCompletion("while (${}) {\n\t${}\n}", {
        label: "while",
        detail: "loop",
        type: "keyword"
    }), snippetCompletion("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", {
        label: "try",
        detail: "/ catch block",
        type: "keyword"
    }), snippetCompletion("if (${}) {\n\t${}\n}", {
        label: "if",
        detail: "block",
        type: "keyword"
    }), snippetCompletion("if (${}) {\n\t${}\n} else {\n\t${}\n}", {
        label: "if",
        detail: "/ else block",
        type: "keyword"
    }), snippetCompletion("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", {
        label: "class",
        detail: "definition",
        type: "keyword"
    }), snippetCompletion("import {${names}} from \"${module}\"\n${}", {
        label: "import",
        detail: "named",
        type: "keyword"
    }), snippetCompletion("import ${name} from \"${module}\"\n${}", {
        label: "import",
        detail: "default",
        type: "keyword"
    })];
    const cache$1 = new NodeWeakMap();
    const ScopeNodes$1 = new Set(["Script", "Block", "FunctionExpression", "FunctionDeclaration", "ArrowFunction", "MethodDeclaration", "ForStatement"]);
    function defID$1(type) {
        return (node, def) => {
            let id = node.node.getChild("VariableDefinition");
            if (id)
                def(id, type);
            return true;
        };
    }
    const functionContext = ["FunctionDeclaration"];
    const gatherCompletions$1 = {
        FunctionDeclaration: defID$1("function"),
        ClassDeclaration: defID$1("class"),
        ClassExpression: () => true,
        EnumDeclaration: defID$1("constant"),
        TypeAliasDeclaration: defID$1("type"),
        NamespaceDeclaration: defID$1("namespace"),
        VariableDefinition(node, def) {
            if (!node.matchContext(functionContext))
                def(node, "variable");
        },
        TypeDefinition(node, def) {
            def(node, "type");
        },
        __proto__: null
    };
    function getScope$1(doc, node) {
        let cached = cache$1.get(node);
        if (cached)
            return cached;
        let completions = [],
            top = true;
        function def(node, type) {
            let name = doc.sliceString(node.from, node.to);
            completions.push({
                label: name,
                type
            });
        }
        node.cursor(IterMode.IncludeAnonymous).iterate(node => {
            if (top) {
                top = false;
            } else if (node.name) {
                let gather = gatherCompletions$1[node.name];
                if (gather && gather(node, def) || ScopeNodes$1.has(node.name))
                    return false;
            } else if (node.to - node.from > 8192) {
                for (let _i243 = 0, _getScope$ = getScope$1(doc, node.node), _length243 = _getScope$.length; _i243 < _length243; _i243++) {
                    let c = _getScope$[_i243];
                    completions.push(c);
                }
                return false;
            }
        });
        cache$1.set(node, completions);
        return completions;
    }
    const Identifier$3 = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
    const dontComplete$1 = ["TemplateString", "String", "RegExp", "LineComment", "BlockComment", "VariableDefinition", "TypeDefinition", "Label", "PropertyDefinition", "PropertyName", "PrivatePropertyDefinition", "PrivatePropertyName"];
    function localCompletionSource$1(context) {
        let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
        if (dontComplete$1.indexOf(inner.name) > -1)
            return null;
        let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier$3.test(context.state.sliceDoc(inner.from, inner.to));
        if (!isWord && !context.explicit)
            return null;
        let options = [];
        for (let pos = inner; pos; pos = pos.parent) {
            if (ScopeNodes$1.has(pos.name))
                options = options.concat(getScope$1(context.state.doc, pos));
        }
        return {
            options,
            from: isWord ? inner.from : context.pos,
            validFor: Identifier$3
        };
    }
    function pathFor$1(read, member, name) {
        var _a;
        let path = [];
        for (;;) {
            let obj = member.firstChild,
                prop;
            if ((obj === null || obj === void 0 ? void 0 : obj.name) == "VariableName") {
                path.push(read(obj));
                return {
                    path: path.reverse(),
                    name
                };
            } else if ((obj === null || obj === void 0 ? void 0 : obj.name) == "MemberExpression" && ((_a = prop = obj.lastChild) === null || _a === void 0 ? void 0 : _a.name) == "PropertyName") {
                path.push(read(prop));
                member = obj;
            } else {
                return null;
            }
        }
    }
    function completionPath(context) {
        let read = node => context.state.doc.sliceString(node.from, node.to);
        let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
        if (inner.name == "PropertyName") {
            return pathFor$1(read, inner.parent, read(inner));
        } else if (dontComplete$1.indexOf(inner.name) > -1) {
            return null;
        } else if (inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier$3.test(read(inner))) {
            return {
                path: [],
                name: read(inner)
            };
        } else if ((inner.name == "." || inner.name == "?.") && inner.parent.name == "MemberExpression") {
            return pathFor$1(read, inner.parent, "");
        } else if (inner.name == "MemberExpression") {
            return pathFor$1(read, inner, "");
        } else {
            return context.explicit ? {
                path: [],
                name: ""
            } : null;
        }
    }
    function enumeratePropertyCompletions(obj, top) {
        let options = [],
            seen = new Set();
        for (let depth = 0; ; depth++) {
            for (let _i244 = 0, _ref4 = (Object.getOwnPropertyNames || Object.keys)(obj), _length244 = _ref4.length; _i244 < _length244; _i244++) {
                let name = _ref4[_i244];
                if (seen.has(name))
                    continue;
                seen.add(name);
                let value;
                try {
                    value = obj[name];
                } catch (_) {
                    continue;
                }
                options.push({
                    label: name,
                    type: typeof value == "function" ? /^[A-Z]/.test(name) ? "class" : top ? "function" : "method" : top ? "variable" : "property",
                    boost: -depth
                });
            }
            let next = Object.getPrototypeOf(obj);
            if (!next)
                return options;
            obj = next;
        }
    }
    function scopeCompletionSource(scope) {
        let cache = new Map();
        return context => {
            let path = completionPath(context);
            if (!path)
                return null;
            let target = scope;
            for (let _i245 = 0, _path$path = path.path, _length245 = _path$path.length; _i245 < _length245; _i245++) {
                let step = _path$path[_i245];
                target = target[step];
                if (!target)
                    return null;
            }
            let options = cache.get(target);
            if (!options)
                cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));
            return {
                from: context.pos - path.name.length,
                options,
                validFor: Identifier$3
            };
        };
    }
    const javascriptLanguage = LRLanguage.define({
        name: "javascript",
        parser: parser$d.configure({
            props: [indentNodeProp.add({
                IfStatement: continuedIndent({
                    except: /^\s*({|else\b)/
                }),
                TryStatement: continuedIndent({
                    except: /^\s*({|catch\b|finally\b)/
                }),
                LabeledStatement: flatIndent,
                SwitchBody: context => {
                    let after = context.textAfter,
                        closed = /^\s*\}/.test(after),
                        isCase = /^\s*(case|default)\b/.test(after);
                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
                },
                Block: delimitedIndent({
                    closing: "}"
                }),
                ArrowFunction: cx => cx.baseIndent + cx.unit,
                "TemplateString BlockComment": () => null,
                "Statement Property": continuedIndent({
                    except: /^{/
                }),
                JSXElement(context) {
                    let closed = /^\s*<\//.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                JSXEscape(context) {
                    let closed = /\s*\}/.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                "JSXOpenTag JSXSelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                }
            }), foldNodeProp.add({
                "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": foldInside,
                BlockComment(tree) {
                    return {
                        from: tree.from + 2,
                        to: tree.to - 2
                    };
                }
            })]
        }),
        languageData: {
            closeBrackets: {
                brackets: ["(", "[", "{", "'", '"', "`"]
            },
            commentTokens: {
                line: "//",
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
            wordChars: "$"
        }
    });
    const typescriptLanguage = javascriptLanguage.configure({
        dialect: "ts"
    }, "typescript");
    const jsxLanguage = javascriptLanguage.configure({
        dialect: "jsx"
    });
    const tsxLanguage = javascriptLanguage.configure({
        dialect: "jsx ts"
    }, "typescript");
    const keywords$2 = "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kw => ({
        label: kw,
        type: "keyword"
    }));
    function javascript(config={}) {
        let lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;
        return new LanguageSupport(lang, [javascriptLanguage.data.of({
            autocomplete: ifNotIn(dontComplete$1, completeFromList(snippets$1.concat(keywords$2)))
        }), javascriptLanguage.data.of({
            autocomplete: localCompletionSource$1
        }), config.jsx ? autoCloseTags$1 : []]);
    }
    function findOpenTag(node) {
        for (;;) {
            if (node.name == "JSXOpenTag" || node.name == "JSXSelfClosingTag" || node.name == "JSXFragmentTag")
                return node;
            if (!node.parent)
                return null;
            node = node.parent;
        }
    }
    function elementName$2(doc, tree, max=doc.length) {
        for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {
            if (ch.name == "JSXIdentifier" || ch.name == "JSXBuiltin" || ch.name == "JSXNamespacedName" || ch.name == "JSXMemberExpression")
                return doc.sliceString(ch.from, Math.min(ch.to, max));
        }
        return "";
    }
    const android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
    const autoCloseTags$1 = EditorView.inputHandler.of((view, from, to, text) => {
        if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != ">" && text != "/" || !javascriptLanguage.isActiveAt(view.state, from, -1))
            return false;
        let {state} = view;
        let changes = state.changeByRange(range => {
            var _a,
                _b;
            let {head} = range,
                around = syntaxTree(state).resolveInner(head, -1),
                name;
            if (around.name == "JSXStartTag")
                around = around.parent;
            if (text == ">" && around.name == "JSXFragmentTag") {
                return {
                    range: EditorSelection.cursor(head + 1),
                    changes: {
                        from: head,
                        insert: `><>`
                    }
                };
            } else if (text == "/" && around.name == "JSXFragmentTag") {
                let empty = around.parent,
                    base = empty === null || empty === void 0 ? void 0 : empty.parent;
                if (empty.from == head - 1 && ((_a = base.lastChild) === null || _a === void 0 ? void 0 : _a.name) != "JSXEndTag" && (name = elementName$2(state.doc, base === null || base === void 0 ? void 0 : base.firstChild, head))) {
                    let insert = `/${name}>`;
                    return {
                        range: EditorSelection.cursor(head + insert.length),
                        changes: {
                            from: head,
                            insert
                        }
                    };
                }
            } else if (text == ">") {
                let openTag = findOpenTag(around);
                if (openTag && ((_b = openTag.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "JSXEndTag" && state.sliceDoc(head, head + 2) != "</" && (name = elementName$2(state.doc, openTag, head)))
                    return {
                        range: EditorSelection.cursor(head + 1),
                        changes: {
                            from: head,
                            insert: `></${name}>`
                        }
                    };
            }
            return {
                range
            };
        });
        if (changes.changes.empty)
            return false;
        view.dispatch(changes, {
            userEvent: "input.type",
            scrollIntoView: true
        });
        return true;
    });
    function esLint(eslint, config) {
        if (!config) {
            config = {
                parserOptions: {
                    ecmaVersion: 2019,
                    sourceType: "module"
                },
                env: {
                    browser: true,
                    node: true,
                    es6: true,
                    es2015: true,
                    es2017: true,
                    es2020: true
                },
                rules: {}
            };
            eslint.getRules().forEach((desc, name) => {
                if (desc.meta.docs.recommended)
                    config.rules[name] = 2;
            });
        }
        return view => {
            let {state} = view,
                found = [];
            for (let _i246 = 0, _javascriptLanguage$f = javascriptLanguage.findRegions(state), _length246 = _javascriptLanguage$f.length; _i246 < _length246; _i246++) {
                let {from, to} = _javascriptLanguage$f[_i246];
                let fromLine = state.doc.lineAt(from),
                    offset = {
                        line: fromLine.number - 1,
                        col: from - fromLine.from,
                        pos: from
                    };
                for (let _i247 = 0, _eslint$verify = eslint.verify(state.sliceDoc(from, to), config), _length247 = _eslint$verify.length; _i247 < _length247; _i247++) {
                    let d = _eslint$verify[_i247];
                    found.push(translateDiagnostic(d, state.doc, offset));
                }
            }
            return found;
        };
    }
    function mapPos$1(line, col, doc, offset) {
        return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);
    }
    function translateDiagnostic(input, doc, offset) {
        let start = mapPos$1(input.line, input.column, doc, offset);
        let result = {
            from: start,
            to: input.endLine != null && input.endColumn != 1 ? mapPos$1(input.endLine, input.endColumn, doc, offset) : start,
            message: input.message,
            source: input.ruleId ? "eslint:" + input.ruleId : "eslint",
            severity: input.severity == 1 ? "warning" : "error"
        };
        if (input.fix) {
            let {range, text} = input.fix,
                from = range[0] + offset.pos - start,
                to = range[1] + offset.pos - start;
            result.actions = [{
                name: "fix",
                apply(view, start) {
                    view.dispatch({
                        changes: {
                            from: start + from,
                            to: start + to,
                            insert: text
                        },
                        scrollIntoView: true
                    });
                }
            }];
        }
        return result;
    }
    var _m9 = Object.freeze({
        __proto__: null,
        autoCloseTags: autoCloseTags$1,
        completionPath: completionPath,
        esLint: esLint,
        javascript: javascript,
        javascriptLanguage: javascriptLanguage,
        jsxLanguage: jsxLanguage,
        localCompletionSource: localCompletionSource$1,
        scopeCompletionSource: scopeCompletionSource,
        snippets: snippets$1,
        tsxLanguage: tsxLanguage,
        typescriptLanguage: typescriptLanguage
    });
    const javaHighlighting = styleTags({
        null: tags$1.null,
        instanceof: tags$1.operatorKeyword,
        this: tags$1.self,
        "new super assert open to with void": tags$1.keyword,
        "class interface extends implements enum": tags$1.definitionKeyword,
        "module package import": tags$1.moduleKeyword,
        "switch while for if else case default do break continue return try catch finally throw": tags$1.controlKeyword,
        ["requires exports opens uses provides public private protected static transitive abstract final " + "strictfp synchronized native transient volatile throws"]: tags$1.modifier,
        IntegerLiteral: tags$1.integer,
        FloatLiteral: tags$1.float,
        "StringLiteral TextBlock": tags$1.string,
        CharacterLiteral: tags$1.character,
        LineComment: tags$1.lineComment,
        BlockComment: tags$1.blockComment,
        BooleanLiteral: tags$1.bool,
        PrimitiveType: tags$1.standard(tags$1.typeName),
        TypeName: tags$1.typeName,
        Identifier: tags$1.variableName,
        "MethodName/Identifier": tags$1.function(tags$1.variableName),
        Definition: tags$1.definition(tags$1.variableName),
        ArithOp: tags$1.arithmeticOperator,
        LogicOp: tags$1.logicOperator,
        BitOp: tags$1.bitwiseOperator,
        CompareOp: tags$1.compareOperator,
        AssignOp: tags$1.definitionOperator,
        UpdateOp: tags$1.updateOperator,
        Asterisk: tags$1.punctuation,
        Label: tags$1.labelName,
        "( )": tags$1.paren,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace,
        ".": tags$1.derefOperator,
        ", ;": tags$1.separator
    });
    const spec_identifier$4 = {
        __proto__: null,
        true: 34,
        false: 34,
        null: 42,
        void: 46,
        byte: 48,
        short: 48,
        int: 48,
        long: 48,
        char: 48,
        float: 48,
        double: 48,
        boolean: 48,
        extends: 62,
        super: 64,
        class: 76,
        this: 78,
        new: 84,
        public: 100,
        protected: 102,
        private: 104,
        abstract: 106,
        static: 108,
        final: 110,
        strictfp: 112,
        default: 114,
        synchronized: 116,
        native: 118,
        transient: 120,
        volatile: 122,
        throws: 150,
        implements: 160,
        interface: 166,
        enum: 176,
        instanceof: 236,
        open: 265,
        module: 267,
        requires: 272,
        transitive: 274,
        exports: 276,
        to: 278,
        opens: 280,
        uses: 282,
        provides: 284,
        with: 286,
        package: 290,
        import: 294,
        if: 306,
        else: 308,
        while: 312,
        for: 316,
        var: 323,
        assert: 330,
        switch: 334,
        case: 340,
        do: 344,
        break: 348,
        continue: 352,
        return: 356,
        throw: 362,
        try: 366,
        catch: 370,
        finally: 378
    };
    const parser$c = LRParser.deserialize({
        version: 14,
        states: "#!hQ]QPOOO&tQQO'#H[O(xQQO'#CbOOQO'#Cb'#CbO)PQPO'#CaO)XOSO'#CpOOQO'#Ha'#HaOOQO'#Cu'#CuO*tQPO'#D_O+_QQO'#HkOOQO'#Hk'#HkO-sQQO'#HfO-zQQO'#HfOOQO'#Hf'#HfOOQO'#He'#HeO0OQPO'#DUO0]QPO'#GlO3TQPO'#D_O3[QPO'#DzO)PQPO'#E[O3}QPO'#E[OOQO'#DV'#DVO5]QQO'#H_O7dQQO'#EeO7kQPO'#EdO7pQPO'#EfOOQO'#H`'#H`O5sQQO'#H`O8sQQO'#FgO8zQPO'#EwO9PQPO'#E|O9PQPO'#FOOOQO'#H_'#H_OOQO'#HW'#HWOOQO'#Gf'#GfOOQO'#HV'#HVO:aQPO'#FhOOQO'#HU'#HUOOQO'#Ge'#GeQ]QPOOOOQO'#Hq'#HqO:fQPO'#HqO:kQPO'#D{O:kQPO'#EVO:kQPO'#EQO:sQPO'#HnO;UQQO'#EfO)PQPO'#C`O;^QPO'#C`O)PQPO'#FbO;cQPO'#FdO;nQPO'#FjO;nQPO'#FmO:kQPO'#FrO;sQPO'#FoO9PQPO'#FvO;nQPO'#FxO]QPO'#F}O;xQPO'#GPO<TQPO'#GRO<`QPO'#GTO;nQPO'#GVO9PQPO'#GWO<gQPO'#GYOOQO'#H['#H[O=WQQO,58{OOQO'#HY'#HYOOOO'#Gg'#GgO>yOSO,59[OOQO,59[,59[OOQO'#Hg'#HgO?jQPO,59eO@lQPO,59yOOQO-E:d-E:dO)PQPO,58zOA`QPO,58zO)PQPO,5;|OAeQPO'#DQOAjQPO'#DQOOQO'#Gi'#GiOBjQQO,59jOOQO'#Dm'#DmODRQPO'#HsOD]QPO'#DlODkQPO'#HrODsQPO,5<^ODxQPO,59^OEcQPO'#CxOOQO,59c,59cOEjQPO,59bOGrQQO'#H[OJVQQO'#CbOJmQPO'#D_OKrQQO'#HkOLSQQO,59pOLZQPO'#DvOLiQPO'#HzOLqQPO,5:`OLvQPO,5:`OM^QPO,5;mOMiQPO'#IROMtQPO,5;dOMyQPO,5=WOOQO-E:j-E:jOOQO,5:f,5:fO! aQPO,5:fO! hQPO,5:vO! mQPO,5<^O)PQPO,5:vO:kQPO,5:gO:kQPO,5:qO:kQPO,5:lO:kQPO,5<^O!!^QPO,59qO9PQPO,5:}O!!eQPO,5;QO9PQPO,59TO!!sQPO'#DXOOQO,5;O,5;OOOQO'#El'#ElOOQO'#En'#EnO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;eOOQO,5;h,5;hOOQO,5<R,5<RO!!zQPO,5;aO!#]QPO,5;cO!!zQPO'#CyO!#dQQO'#HkO!#rQQO,5;jO]QPO,5<SOOQO-E:c-E:cOOQO,5>],5>]O!%SQPO,5:gO!%bQPO,5:qO!%jQPO,5:lO!%uQPO,5>YOLZQPO,5>YO! {QPO,59UO!&QQQO,58zO!&YQQO,5;|O!&bQQO,5<OO)PQPO,5<OO9PQPO'#DUO]QPO,5<UO]QPO,5<XO!&jQPO'#FqO]QPO,5<ZO]QPO,5<`O!&zQQO,5<bO!'UQPO,5<dO!'ZQPO,5<iOOQO'#Fi'#FiOOQO,5<k,5<kO!'`QPO,5<kOOQO,5<m,5<mO!'eQPO,5<mO!'jQQO,5<oOOQO,5<o,5<oO<jQPO,5<qO!'qQQO,5<rO!'xQPO'#GcO!)OQPO,5<tO<jQPO,5<|O)PQPO,58}O!,|QPO'#ChOOQO1G.k1G.kOOOO-E:e-E:eOOQO1G.v1G.vO!-WQPO,59jO!&QQQO1G.fO)PQPO1G.fO!-eQQO1G1hOOQO,59l,59lO!-mQPO,59lOOQO-E:g-E:gO!-rQPO,5>_O!.ZQPO,5:WO:kQPO'#GnO!.bQPO,5>^OOQO1G1x1G1xOOQO1G.x1G.xO!.{QPO'#CyO!/kQPO'#HkO!/uQPO'#CzO!0TQPO'#HjO!0]QPO,59dOOQO1G.|1G.|OEjQPO1G.|O!0sQPO,59eO!1QQQO'#H[O!1cQQO'#CbOOQO,5:b,5:bO:kQPO,5:cOOQO,5:a,5:aO!1tQQO,5:aOOQO1G/[1G/[O!1yQPO,5:bO!2[QPO'#GqO!2oQPO,5>fOOQO1G/z1G/zO!2wQPO'#DvO!3YQPO'#D_O!3aQPO1G/zO!!zQPO'#GoO!3fQPO1G1XO9PQPO1G1XO:kQPO'#GwO!3nQPO,5>mOOQO1G1O1G1OOOQO1G0Q1G0QO!3vQPO'#E]OOQO1G0b1G0bO!4gQPO1G1xO! hQPO1G0bO!%SQPO1G0RO!%bQPO1G0]O!%jQPO1G0WOOQO1G/]1G/]O!4lQQO1G.pO7kQPO1G0jO)PQPO1G0jO:sQPO'#HnO!6`QQO1G.pOOQO1G.p1G.pO!6eQQO1G0iOOQO1G0l1G0lO!6lQPO1G0lO!6wQQO1G.oO!7_QQO'#HoO!7lQPO,59sO!8{QQO1G0pO!:dQQO1G0pO!;rQQO1G0pO!<PQQO1G0pO!=UQQO1G0pO!=lQQO1G0pO!=vQQO1G1PO!=}QQO'#HkOOQO1G0{1G0{O!?QQQO1G0}OOQO1G0}1G0}OOQO1G1n1G1nO! pQPO'#DqO!ARQPO'#D[O!!zQPO'#D|O!!zQPO'#D}OOQO1G0R1G0RO!AYQPO1G0RO!A_QPO1G0RO!AgQPO1G0RO!ArQPO'#EXOOQO1G0]1G0]O!BVQPO1G0]O!B[QPO'#ETO!!zQPO'#ESOOQO1G0W1G0WO!CUQPO1G0WO!CZQPO1G0WO!CcQPO'#EhO!CjQPO'#EhOOQO'#Gv'#GvO!CrQQO1G0mO!EcQQO1G3tO7kQPO1G3tO!GbQPO'#FWOOQO1G.f1G.fOOQO1G1h1G1hO!GiQPO1G1jOOQO1G1j1G1jO!GtQQO1G1jO!G|QPO1G1pOOQO1G1s1G1sO)aQPO'#D_O+_QQO,5<aO!KtQPO,5<aO!LVQPO,5<]O!L^QPO,5<]OOQO1G1u1G1uOOQO1G1z1G1zOOQO1G1|1G1|O9PQPO1G1|O#!QQPO'#FzOOQO1G2O1G2OO;nQPO1G2TOOQO1G2V1G2VOOQO1G2X1G2XOOQO1G2Z1G2ZOOQO1G2]1G2]OOQO1G2^1G2^O#!XQQO'#H[O##SQQO'#CbO+_QQO'#HkO##}QQOOO#$kQQO'#EeO#$YQQO'#H`OLZQPO'#GdO#$rQPO,5<}OOQO'#HO'#HOO#$zQPO1G2`O#(xQPO'#G[O<jQPO'#G`OOQO1G2`1G2`O#(}QPO1G2hOOQO1G.i1G.iO#.SQQO'#EeO#.dQQO'#H^O#.tQPO'#FSOOQO'#H^'#H^O#/OQPO'#H^O#/mQPO'#IUO#/uQPO,59SOOQO7+$Q7+$QO!&QQQO7+$QOOQO7+'S7+'SOOQO1G/W1G/WO#/zQPO'#DoO#0UQQO'#HtOOQO'#Ht'#HtOOQO1G/r1G/rOOQO,5=Y,5=YOOQO-E:l-E:lO#0fQWO,58{O#0mQPO,59fOOQO,59f,59fO!!zQPO'#HmOD}QPO'#GhO#0{QPO,5>UOOQO1G/O1G/OOOQO7+$h7+$hOOQO1G/{1G/{O#1TQQO1G/{OOQO1G/}1G/}O#1YQPO1G/{OOQO1G/|1G/|O:kQPO1G/}OOQO,5=],5=]OOQO-E:o-E:oOOQO7+%f7+%fOOQO,5=Z,5=ZOOQO-E:m-E:mO9PQPO7+&sOOQO7+&s7+&sOOQO,5=c,5=cOOQO-E:u-E:uO#1_QPO'#EUO#1mQPO'#EUOOQO'#Gu'#GuO#2UQPO,5:wOOQO,5:w,5:wOOQO7+'d7+'dOOQO7+%|7+%|OOQO7+%m7+%mO!AYQPO7+%mO!A_QPO7+%mO!AgQPO7+%mOOQO7+%w7+%wO!BVQPO7+%wOOQO7+%r7+%rO!CUQPO7+%rO!CZQPO7+%rOOQO7+&U7+&UOOQO'#Ee'#EeO7kQPO7+&UO7kQPO,5>YO#2uQPO7+$[OOQO7+&T7+&TOOQO7+&W7+&WO9PQPO'#GjO#3TQPO,5>ZOOQO1G/_1G/_O9PQPO7+&kO#3`QQO,59eO#4cQPO'#DrO! pQPO'#DrO#4nQPO'#HwO#4vQPO,5:]O#5aQQO'#HgO#5|QQO'#CuO! mQPO'#HvO#6lQPO'#DpO#6vQPO'#HvO#7XQPO'#DpO#7aQPO'#IPO#7fQPO'#E`OOQO'#Hp'#HpOOQO'#Gk'#GkO#7nQPO,59vOOQO,59v,59vO#7uQPO'#HqOOQO,5:h,5:hO#9]QPO'#H|OOQO'#EP'#EPOOQO,5:i,5:iO#9hQPO'#EYO:kQPO'#EYO#9yQPO'#H}O#:UQPO,5:sO! mQPO'#HvO!!zQPO'#HvO#:^QPO'#DpOOQO'#Gs'#GsO#:eQPO,5:oOOQO,5:o,5:oOOQO,5:n,5:nOOQO,5;S,5;SO#;_QQO,5;SO#;fQPO,5;SOOQO-E:t-E:tOOQO7+&X7+&XOOQO7+)`7+)`O#;mQQO7+)`OOQO'#Gz'#GzO#=ZQPO,5;rOOQO,5;r,5;rO#=bQPO'#FXO)PQPO'#FXO)PQPO'#FXO)PQPO'#FXO#=pQPO7+'UO#=uQPO7+'UOOQO7+'U7+'UO]QPO7+'[O#>QQPO1G1{O! mQPO1G1{O#>`QQO1G1wO!!sQPO1G1wO#>gQPO1G1wO#>nQQO7+'hOOQO'#G}'#G}O#>uQPO,5<fOOQO,5<f,5<fO#>|QPO'#HqO9PQPO'#F{O#?UQPO7+'oO#?ZQPO,5=OO! mQPO,5=OO#?`QPO1G2iO#@iQPO1G2iOOQO1G2i1G2iOOQO-E:|-E:|OOQO7+'z7+'zO!2[QPO'#G^O<jQPO,5<vOOQO,5<z,5<zO#@qQPO7+(SOOQO7+(S7+(SO#DoQPO,59TO#DvQPO'#ITO#EOQPO,5;nO)PQPO'#GyO#ETQPO,5>pOOQO1G.n1G.nOOQO<<Gl<<GlO#E]QPO'#HuO#EeQPO,5:ZOOQO1G/Q1G/QOOQO,5>X,5>XOOQO,5=S,5=SOOQO-E:f-E:fO#EjQPO7+%gOOQO7+%g7+%gOOQO7+%i7+%iOOQO<<J_<<J_O#FQQPO'#H[O#FXQPO'#CbO#F`QPO,5:pO#FeQPO,5:xO#1_QPO,5:pOOQO-E:s-E:sOOQO1G0c1G0cOOQO<<IX<<IXO!AYQPO<<IXO!A_QPO<<IXOOQO<<Ic<<IcOOQO<<I^<<I^O!CUQPO<<I^OOQO<<Ip<<IpO#FjQQO<<GvO7kQPO<<IpO)PQPO<<IpOOQO<<Gv<<GvO#H^QQO,5=UOOQO-E:h-E:hO#HkQQO<<JVOOQO,5:^,5:^O!!zQPO'#DsO#IRQPO,5:^O! pQPO'#GpO#I^QPO,5>cOOQO1G/w1G/wO#IfQPO'#HsO#ImQPO,59xO#IrQPO,5>bO! mQPO,59xO#I}QPO,5:[O#7fQPO,5:zO! mQPO,5>bO!!zQPO,5>bO#7aQPO,5>kOOQO,5:[,5:[OLvQPO'#DtOOQO,5>k,5>kO#JVQPO'#EaOOQO,5:z,5:zO#MWQPO,5:zO!!zQPO'#DxOOQO-E:i-E:iOOQO1G/b1G/bOOQO,5:y,5:yO!!zQPO'#GrO#M]QPO,5>hOOQO,5:t,5:tO#MhQPO,5:tO#MvQPO,5:tO#NXQPO'#GtO#NoQPO,5>iO#NzQPO'#EZOOQO1G0_1G0_O$ RQPO1G0_O! mQPO,5:pOOQO-E:q-E:qOOQO1G0Z1G0ZOOQO1G0n1G0nO$ WQQO1G0nOOQO<<Lz<<LzOOQO-E:x-E:xOOQO1G1^1G1^O$ _QQO,5;sOOQO'#G{'#G{O#=bQPO,5;sOOQO'#IV'#IVO$ gQQO,5;sO$ xQQO,5;sOOQO<<Jp<<JpO$!QQPO<<JpOOQO<<Jv<<JvO9PQPO7+'gO$!VQPO7+'gO!!sQPO7+'cO$!eQPO7+'cO$!jQQO7+'cOOQO<<KS<<KSOOQO-E:{-E:{OOQO1G2Q1G2QOOQO,5<g,5<gO$!qQQO,5<gOOQO<<KZ<<KZO9PQPO1G2jO$!xQPO1G2jOOQO,5=l,5=lOOQO7+(T7+(TO$!}QPO7+(TOOQO-E;O-E;OO$$lQWO'#HfO$$WQWO'#HfO$$sQPO'#G_O:kQPO,5<xOLZQPO,5<xOOQO1G2b1G2bOOQO<<Kn<<KnO$%UQQO1G.oOOQO1G1Z1G1ZO$%`QPO'#GxO$%mQPO,5>oOOQO1G1Y1G1YO$%uQPO'#FTOOQO,5=e,5=eOOQO-E:w-E:wO$%zQPO'#GmO$&XQPO,5>aOOQO1G/u1G/uOOQO<<IR<<IROOQO1G0[1G0[O$&aQPO1G0dO$&fQPO1G0[O$&kQPO1G0dOOQOAN>sAN>sO!AYQPOAN>sOOQOAN>xAN>xOOQOAN?[AN?[O7kQPOAN?[O$&pQPO,5:_OOQO1G/x1G/xOOQO,5=[,5=[OOQO-E:n-E:nO$&{QPO,5>eOOQO1G/d1G/dOOQO1G3|1G3|O$'^QPO1G/dOOQO1G/v1G/vOOQO1G0f1G0fO#MWQPO1G0fO#7aQPO'#HyO$'cQPO1G3|O! mQPO1G3|OOQO1G4V1G4VOK^QPO'#DvOJmQPO'#D_OOQO,5:{,5:{O$'nQPO,5:{O$'nQPO,5:{O$'uQQO'#H_O$'|QQO'#H`O$(WQQO'#EbO$(cQPO'#EbOOQO,5:d,5:dOOQO,5=^,5=^OOQO-E:p-E:pOOQO1G0`1G0`O$(kQPO1G0`OOQO,5=`,5=`OOQO-E:r-E:rO$(yQPO,5:uOOQO7+%y7+%yOOQO7+&Y7+&YOOQO1G1_1G1_O$)QQQO1G1_OOQO-E:y-E:yO$)YQQO'#IWO$)TQPO1G1_O$ mQPO1G1_O)PQPO1G1_OOQOAN@[AN@[O$)eQQO<<KRO9PQPO<<KRO$)lQPO<<J}OOQO<<J}<<J}O!!sQPO<<J}OOQO1G2R1G2RO$)qQQO7+(UO9PQPO7+(UOOQO<<Ko<<KoP!'xQPO'#HQOLZQPO'#HPO$){QPO,5<yO$*WQPO1G2dO:kQPO1G2dOOQO,5=d,5=dOOQO-E:v-E:vO#DoQPO,5;oOOQO,5=X,5=XOOQO-E:k-E:kO$*]QPO7+&OOOQO7+%v7+%vO$*kQPO7+&OOOQOG24_G24_OOQOG24vG24vO$*pQPO1G/yO$*{QPO1G4POOQO7+%O7+%OOOQO7+&Q7+&QOOQO7+)h7+)hO$+^QPO7+)hO!0bQPO,5:aOOQO1G0g1G0gO$+iQPO1G0gO$+pQPO,59qO$,UQPO,5:|O7kQPO,5:|OOQO7+%z7+%zOOQO7+&y7+&yO)PQPO'#G|O$,ZQPO,5>rO$,cQPO7+&yO$,hQQO'#IXOOQOAN@mAN@mO$,sQQOAN@mOOQOAN@iAN@iO$,zQPOAN@iO$-PQQO<<KpO$-ZQPO,5=kOOQO-E:}-E:}OOQO7+(O7+(OO$-lQPO7+(OO$-qQPO<<IjOOQO<<Ij<<IjO#DoQPO<<IjO$-qQPO<<IjOOQO<<MS<<MSOOQO7+&R7+&RO$.PQPO1G0jO$.[QQO1G0hOOQO1G0h1G0hO$.dQPO1G0hO$.iQQO,5=hOOQO-E:z-E:zOOQO<<Je<<JeO$.tQPO,5>sOOQOG26XG26XOOQOG26TG26TOOQO<<Kj<<KjOOQOAN?UAN?UO#DoQPOAN?UO$.|QPOAN?UO$/RQPOAN?UO7kQPO7+&SO$/aQPO7+&SOOQO7+&S7+&SO$/fQPOG24pOOQOG24pG24pO#DoQPOG24pO$/kQPO<<InOOQO<<In<<InOOQOLD*[LD*[O$/pQPOLD*[OOQOAN?YAN?YOOQO!$'Mv!$'MvO)PQPO'#CaO$/uQQO'#H[O$0YQQO'#CbO!!zQPO'#Cy",
        stateData: "$0u~OPOSQOS%wOS~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~OWiXW&OXZ&OXuiXu&OX!P&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~O#o$]X~P$wOWUXW&ZXZUXuUXu&ZX!PUX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~O#o$]X~P&{O%}RO&P!bO~O&U!gO&W!eO~Og]Oh]O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO%{SO%}!hO&PVOg!RXh!RX$g!RX%}!RX&P!RX~O#x!mO#y!lO$V!nOv!RX!u!RX!z!RX&r!RX~P)aOW!xOu!oO%{SO%}!sO&P!sO&t&_X~OW!{Ou&YX%{&YX%}&YX&P&YX&t&YXY&YXw&YX&l&YX&o&YXZ&YXq&YX&[&YX!P&YX#_&YX#a&YX#c&YX#d&YX#e&YX#f&YX#g&YX#h&YX#j&YX#n&YX#q&YX}&YX!r&YX#o&YXs&YX|&YX~O&]!yO~P+sO&]&YX~P+sOZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO#eoO#qnO#soO#toO%{SO&VTO~O%}!}O&P!|OY&nP~P.RO%{SOg%`Xh%`Xv%`X!S%`X!T%`X!U%`X!V%`X!W%`X!X%`X!Y%`X!Z%`X!]%`X!^%`X!_%`X!u%`X!z%`X$g%`X%}%`X&P%`X&r%`X&]%`X~O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xOg!RXh!RXv!RX!u!RX!z!RX%}!RX&P!RX&r!RX&]!RX~O$g!RX~P1sO|#[O~P]Og]Oh]Ov#aO!u#cO!z#bO%}!hO&PVO&r#`O~O$g#dO~P3cOu#fO&t#gO!P&RX#_&RX#a&RX#c&RX#d&RX#e&RX#f&RX#g&RX#h&RX#j&RX#n&RX#q&RX&[&RX&]&RX&l&RX~OW#eOY&RX#o&RXs&RXq&RX|&RX~P4UO!b#hO#]#hOW&SXu&SX!P&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SXY&SX#o&SXs&SXq&SX|&SX~OZ#XX~P5sOZ#iO~O&t#gO~O#_#mO#a#nO#c#oO#d#oO#e#pO#f#qO#g#rO#h#rO#j#vO#n#sO#q#tO&[#kO&]#kO&l#lO~O!P#uO~P7uO&v#wO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O#eoO#qnO#soO#toO%{SO%}0iO&P0hO&VTO~O#o#{O~O![#}O~O%}!sO&P!sO~Og]Oh]O%}!hO&PVO&]!yO~OW$TO&t#gO~O#y!lO~O!W$XO%}RO&P!bO~OZ$YO~OZ$]O~O!P$dO%}$cO&P$cO~O!P$fO%}$cO&P$cO~O!P$iO~P9POZ$lO}bO~OW$oOZ$pOgTahTa%{Ta%}Ta&PTa~OvTa!STa!TTa!UTa!VTa!WTa!XTa!YTa!ZTa!]Ta!^Ta!_Ta!uTa!zTa#xTa#yTa$VTa$gTa&rTauTaYTa&]TaqTa|Ta!PTa~P<oO&U$sO&W!eO~Ou!oO%{SOqma&[maYma&lma!Pma~O&tma}ma!rma~P?RO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO~Og!Rah!Rav!Ra!u!Ra!z!Ra$g!Ra%}!Ra&P!Ra&r!Ra&]!Ra~P?wO#y$vO~Os$xO~Ou$yO%{SO~Ou!oO%{ra%}ra&Pra&traYrawra&lra&ora!Pra&[raqra~OWra#_ra#ara#cra#dra#era#fra#gra#hra#jra#nra#qra&]ra#orasra|ra~PArOu!oO%{SOq&gX!P&gX!b&gX~OY&gX#o&gX~PCpO!b$|Oq!`X!P!`XY!`X~Oq$}O!P&fX~O!P%PO~Ov%QO~Og]Oh]O%{0gO%}!hO&PVO&`%TO~O&[&^P~PD}O%{SO%}!hO&PVO~OWiXW&OXY&OXZ&OXuiXu&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~OYiXY!aXq!aXwiX&liX&oiX~PEuOWUXW&ZXYUXZUXuUXu&ZX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~OY!aXY&ZXq!aXw&ZX&l&ZX&o&ZX~PHYOg]Oh]O%{SO%}!hO&PVOg!RXh!RX%}!RX&P!RX~P?wOu!oOw%_O%{SO%}%[O&P%ZO&o%^O~OW!xOY&_X&l&_X&t&_X~PK^OY%aO~P7uOg]Oh]O%}!hO&PVO~Oq%cOY&nX~OY%eO~Og]Oh]O%{SO%}!hO&PVOY&nP~P?wOY%kO&l%iO&t#gO~Oq%lO&v#wOY&uX~OY%nO~O%{SOg%`ah%`av%`a!S%`a!T%`a!U%`a!V%`a!W%`a!X%`a!Y%`a!Z%`a!]%`a!^%`a!_%`a!u%`a!z%`a$g%`a%}%`a&P%`a&r%`a&]%`a~O|%oO~P]O}%pO~Ou!oO%{SO%}!sO&P!sO~Op%|Ow%}O%}RO&P!bO&]!yO~Oz%{O~P! {Oz&PO%}RO&P!bO&]!yO~OY&cP~P9POg]Oh]O%{SO%}!hO&PVO~O}bO~P9POW!xOu!oO%{SO&t&_X~O#q#tO!P#ra#_#ra#a#ra#c#ra#d#ra#e#ra#f#ra#g#ra#h#ra#j#ra#n#ra&[#ra&]#ra&l#raY#ra#o#ras#raq#ra|#ra~Oo&dO}&cO!r&eO&]&bO~O}&jO!r&eO~Oo&nO}&mO&]&bO~OZ#iOu&rO%{SO~OW$oO}&xO~OW$oO!P&zO~OW&{O!P&|O~O$g!VO%}0iO&P0hO!P&cP~P.RO!P'XO#o'YO~P7uO}'ZO~O$b']O~O!P'^O~O!P'_O~O!P'`O~P7uO!P'bO~P7uOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wO%P'mO%T'nOZ$|a_$|a`$|aa$|ab$|ac$|ae$|ag$|ah$|ap$|av$|aw$|az$|a}$|a!P$|a!S$|a!T$|a!U$|a!V$|a!W$|a!X$|a!Y$|a!Z$|a![$|a!]$|a!^$|a!_$|a!u$|a!z$|a#e$|a#q$|a#s$|a#t$|a#x$|a#y$|a$V$|a$X$|a$_$|a$b$|a$d$|a$g$|a$k$|a$m$|a$r$|a$t$|a$v$|a$x$|a${$|a$}$|a%u$|a%{$|a%}$|a&P$|a&V$|a&r$|a|$|a$`$|a$p$|a~O}'tOY&xP~P9PO}ra!rra&|ra~PArOW$oO!P'{O~Os'|O~Ou!oO%{SOq&ga!P&ga!b&gaY&ga#o&ga~O}'}O~P9POq$}O!P&fa~Og]Oh]O%{0gO%}!hO&PVO~O&`(UO~P!.jOu!oO%{SOq&_X&[&_XY&_X&l&_X!P&_X~O}&_X!r&_X~P!/SOo(WOp(WOqnX&[nX~Oq(XO&[&^X~O&[(ZO~Ou!oOw(]O%{SO%}RO&P!bO~OYma&lma&tma~P!0bOW&OXY!aXq!aXu!aX%{!aX~OWUXY!aXq!aXu!aX%{!aX~OW(`O~Ou!oO%{SO%}!sO&P!sO&o(bO~Og]Oh]O%{SO%}!hO&PVO~P?wOq%cOY&na~Ou!oO%{SO%}!sO&P!sO&o%^O~O%{SO~P1sOY(eO~OY(hO&l%iO~Oq%lOY&ua~Og]Oh]OvzO|(pO!u|O%{SO%}!hO&PVO&rcO~P?wO!P(qO~OW^iZ#XXu^i!P^i!b^i#]^i#_^i#a^i#c^i#d^i#e^i#f^i#g^i#h^i#j^i#n^i#q^i&[^i&]^i&l^i&t^iY^i#o^is^iq^i|^i~OW)QO~Os)RO~P7uOz)SO%}RO&P!bO~O!P]iY]i#o]is]iq]i|]i~P7uOq)TOY&cX!P&cX~P7uOY)VO~O#q#tO!P#^i#_#^i#a#^i#c#^i#d#^i#e#^i#f#^i#j#^i#n#^i&[#^i&]#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#g#rO#h#rO~P!7qO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#a#^i#c#^i#d#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#e#pO~P!9VO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#c#^i#d#^i#n#^iY#^i#o#^is#^iq#^i|#^i~O#a#nO#e#pO&l#lO~P!:kO#e#^i~P!9VO#q#tO!P#^i#a#^i#c#^i#d#^i#e#^i#f#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#_#mO#g#rO#h#rO#j#vO&[#kO&]#kO~P!<WO#g#^i#h#^i~P!7qO#o)WO~P7uO#_&_X#a&_X#c&_X#d&_X#e&_X#f&_X#g&_X#h&_X#j&_X#n&_X#q&_X&]&_X#o&_Xs&_X|&_X~P!/SO!P#kiY#ki#o#kis#kiq#ki|#ki~P7uOg]Oh]OvzO}bO!P)fO!SxO!TxO!UxO!VxO!W)jO!XxO!YxO!ZyO!]xO!^xO!_xO!u|O!z{O%{SO%})^O&P)_O&]&bO&rcO~O|)iO~P!?hO}&cO~O}&cO!r&eO~Oo&dO}&cO!r&eO~O%{SO%}!sO&P!sO|&qP!P&qP~P?wO}&jO~Og]Oh]OvzO|)xO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wO}&mO~Oo&nO}&mO~Os)zO~P9POu)|O%{SO~Ou&rO}'}O%{SOW#Zi!P#Zi#_#Zi#a#Zi#c#Zi#d#Zi#e#Zi#f#Zi#g#Zi#h#Zi#j#Zi#n#Zi#q#Zi&[#Zi&]#Zi&l#Zi&t#ZiY#Zi#o#Zis#Ziq#Zi|#Zi~O}&cOW&biu&bi!P&bi#_&bi#a&bi#c&bi#d&bi#e&bi#f&bi#g&bi#h&bi#j&bi#n&bi#q&bi&[&bi&]&bi&l&bi&t&biY&bi#o&bis&biq&bi|&bi~O#|*UO$O*VO$Q*VO$R*WO$S*XO~O|*TO~P!GPO$Y*YO%}RO&P!bO~OW*ZO!P*[O~O$`*]OZ$^i_$^i`$^ia$^ib$^ic$^ie$^ig$^ih$^ip$^iv$^iw$^iz$^i}$^i!P$^i!S$^i!T$^i!U$^i!V$^i!W$^i!X$^i!Y$^i!Z$^i![$^i!]$^i!^$^i!_$^i!u$^i!z$^i#e$^i#q$^i#s$^i#t$^i#x$^i#y$^i$V$^i$X$^i$_$^i$b$^i$d$^i$g$^i$k$^i$m$^i$r$^i$t$^i$v$^i$x$^i${$^i$}$^i%u$^i%{$^i%}$^i&P$^i&V$^i&r$^i|$^i$p$^i~Og]Oh]O$g#dO%}!hO&PVO~O!P*aO~P9PO!P*bO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!Z*gO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$p*hO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~O|*fO~P!LcOWiXW&OXY&OXZ&OXuiXu&OX!P&OX%{iX%}iX&PiX&]iX&tiX&t&OX~OWUXW&ZXYUXZUXuUXu&ZX!PUX%{&ZX%}&ZX&P&ZX&]&ZX&tUX&t&ZX~OW#eOu#fO&t#gO~OW&SXY%WXu&SX!P%WX&t&SX~OZ#XX~P#$YOY*nO!P*lO~O%P'mO%T'nOZ$|i_$|i`$|ia$|ib$|ic$|ie$|ig$|ih$|ip$|iv$|iw$|iz$|i}$|i!P$|i!S$|i!T$|i!U$|i!V$|i!W$|i!X$|i!Y$|i!Z$|i![$|i!]$|i!^$|i!_$|i!u$|i!z$|i#e$|i#q$|i#s$|i#t$|i#x$|i#y$|i$V$|i$X$|i$_$|i$b$|i$d$|i$g$|i$k$|i$m$|i$r$|i$t$|i$v$|i$x$|i${$|i$}$|i%u$|i%{$|i%}$|i&P$|i&V$|i&r$|i|$|i$`$|i$p$|i~OZ*qO~O%P'mO%T'nOZ%Ui_%Ui`%Uia%Uib%Uic%Uie%Uig%Uih%Uip%Uiv%Uiw%Uiz%Ui}%Ui!P%Ui!S%Ui!T%Ui!U%Ui!V%Ui!W%Ui!X%Ui!Y%Ui!Z%Ui![%Ui!]%Ui!^%Ui!_%Ui!u%Ui!z%Ui#e%Ui#q%Ui#s%Ui#t%Ui#x%Ui#y%Ui$V%Ui$X%Ui$_%Ui$b%Ui$d%Ui$g%Ui$k%Ui$m%Ui$r%Ui$t%Ui$v%Ui$x%Ui${%Ui$}%Ui%u%Ui%{%Ui%}%Ui&P%Ui&V%Ui&r%Ui|%Ui$`%Ui$p%Ui~OW&SXu&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SX~O!b*vO#]#hOY&SXZ#XX~P#,{OY&QXq&QX|&QX!P&QX~P7uO}'tO|&wP~P9POY&QXg%YXh%YX%{%YX%}%YX&P%YXq&QX|&QX!P&QX~Oq*yOY&xX~OY*{O~O}'}O|&iP~P9POq&hX!P&hX|&hXY&hX~P7uO&`Ta~P<oOo(WOp(WOqna&[na~Oq(XO&[&^a~OW+TO~Ow+UO~Ou!oO%{SO%}+YO&P+XO~Og]Oh]Ov#aO!u#cO%}!hO&PVO&r#`O~Og]Oh]OvzO|+_O!u|O%{SO%}!hO&PVO&rcO~P?wOw+jO%}RO&P!bO&]!yO~Oq)TOY&ca!P&ca~O#_ma#ama#cma#dma#ema#fma#gma#hma#jma#nma#qma&]ma#omasma|ma~P?ROo+oOq!fX&[!fX~Oq+qO&[&kX~O&[+sO~OW&ZXu&ZX%{&ZX%}&ZX&P&ZX&]&ZX~OZ!aX~P#4{OWiXuiX%{iX%}iX&PiX&]iX~OZ!aX~P#5hOg]Oh]Ov#aO!u#cO!z#bO&]&bO&r#`O~O%})^O&P)_O~P#6TOg]Oh]O%{SO%})^O&P)_O~O}bO!P+}O~OZ,OO~O},QO!m,TO~O|,VO~P!?hO}bOg&eXh&eXv&eX!S&eX!T&eX!U&eX!V&eX!W&eX!X&eX!Y&eX!Z&eX!]&eX!^&eX!_&eX!u&eX!z&eX%{&eX%}&eX&P&eX&]&eX&r&eX~Oq,XO}&pX!P&pX~OZ#iO}&cOq!|X|!|X!P!|X~Oq,^O|&qX!P&qX~O|,aO!P,`O~O&]&bO~P3cOg]Oh]OvzO|,eO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wOs,fO~P7uOs,fO~P9PO}&cOW&bqu&bq!P&bq#_&bq#a&bq#c&bq#d&bq#e&bq#f&bq#g&bq#h&bq#j&bq#n&bq#q&bq&[&bq&]&bq&l&bq&t&bqY&bq#o&bqs&bqq&bq|&bq~O|,jO~P!GPO!W,nO#},nO%}RO&P!bO~O!P,qO~O$Y,rO%}RO&P!bO~O!b$|O#o,tOq!`X!P!`X~O!P,vO~P7uO!P,vO~P9PO!P,yO~P7uO|,{O~P!LcO![#}O#o,|O~O!P-OO~O!b-PO~OY-SOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOY-SO!P-TO~O%P'mO%T'nOZ%Uq_%Uq`%Uqa%Uqb%Uqc%Uqe%Uqg%Uqh%Uqp%Uqv%Uqw%Uqz%Uq}%Uq!P%Uq!S%Uq!T%Uq!U%Uq!V%Uq!W%Uq!X%Uq!Y%Uq!Z%Uq![%Uq!]%Uq!^%Uq!_%Uq!u%Uq!z%Uq#e%Uq#q%Uq#s%Uq#t%Uq#x%Uq#y%Uq$V%Uq$X%Uq$_%Uq$b%Uq$d%Uq$g%Uq$k%Uq$m%Uq$r%Uq$t%Uq$v%Uq$x%Uq${%Uq$}%Uq%u%Uq%{%Uq%}%Uq&P%Uq&V%Uq&r%Uq|%Uq$`%Uq$p%Uq~O}'tO~P9POq-`O|&wX~O|-bO~Oq*yOY&xa~Oq-fO|&iX~O|-hO~Ow-iO~Oq!aXu!aX!P!aX!b!aX%{!aX~OZ&OX~P#EoOZUX~P#EoO!P-jO~OZ-kO~OW^yZ#XXu^y!P^y!b^y#]^y#_^y#a^y#c^y#d^y#e^y#f^y#g^y#h^y#j^y#n^y#q^y&[^y&]^y&l^y&t^yY^y#o^ys^yq^y|^y~OY%^aq%^a!P%^a~P7uO!P#myY#my#o#mys#myq#my|#my~P7uOo+oOq!fa&[!fa~Oq+qO&[&ka~OZ,OO~PCpO!P-xO~O!m,TO}&ja!P&ja~O}bO!P-{O~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op.ZOvzOw.YOz}O|.UO}bO!PuO![!_O!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&]!yO&rcO~P?wO},QO~Oq,XO}&pa!P&pa~O}&cOq!|a|!|a!P!|a~OZ#iO}&cOq!|a|!|a!P!|a~O%{SO%}!sO&P!sOq%hX|%hX!P%hX~P?wOq,^O|&qa!P&qa~O|!}X~P!?hO|.eO~Os.fO~P7uOW$oO!P.gO~OW$oO$P.lO%}RO&P!bO!P&zP~OW$oO$T.mO~O!P.nO~O!b$|O#o.pOq!`X!P!`X~OY.rO~O!P.sO~P7uO#o.tO~P7uO!b.vO~OY.wOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOW!{Ou&YX%{&YX%}&YX&P&YX&|&YX~O&]!yO~P$$WOu!oO%{SO&|.yO%}%RX&P%RX~OY&QXq&QX~P7uO}'tOq%lX|%lX~P9POq-`O|&wa~O!b/PO~O}'}Oq%aX|%aX~P9POq-fO|&ia~OY/SO~O!P/TO~OZ/UO~O&l%iOq!ga&[!ga~Ou!oO%{SO}&ma!P&ma!m&ma~O!P/ZO~O!m,TO}&ji!P&ji~O|/`O~P]OW/bO~P4UOZ#iO!P&SX~P#,{OW$TOZ#iO&t#gO~Op/dOw/dO~O}&cOq!|i|!|i!P!|i~O|!}a~P!?hOW$oO!P/fO~OW$oOq/gO!P&zX~OY/kO~P7uOY/mO~OY%Wq!P%Wq~P7uO&|.yO%}%Ra&P%Ra~OY/rO~Ou!oO!P/uO!Z/vO%{SO~OY/wO~O&l%iOq!gi&[!gi~Ou!oO%{SO}&mi!P&mi!m&mi~O!m,TO}&jq!P&jq~O|/yO~P]Op/{Ow%}Oz%{O%}RO&P!bO&]!yO~O!P/|O~Oq/gO!P&za~O!P0QO~OW$oOq/gO!P&{X~OY0SO~P7uOY0TO~OY%Wy!P%Wy~P7uOu!oO%{SO%}%sa&P%sa&|%sa~OY0UO~Ou!oO!P0VO!Z0WO%{SO~Op0ZO%}RO&P!bO~OW)QOZ#iO~O!P0]O~OW$oOq%pa!P%pa~Oq/gO!P&{a~O!P0_O~Ou!oO!P0_O!Z0`O%{SO~O!P0bO~O!P0cO~O!P0eO~O!P0fO~O#o&OXY&OXs&OXq&OX|&OX~P$wO#oUXYUXsUXqUX|UX~P&{O`Q_P#f&Vc~",
        goto: "#(V&|PPPP&}'b*q-tP'bPP.Y.^/rPPPPP1^P2vPP4`7P9j<T<m>bPPP>hP@|PPPAv2vPCoPPDjPEaEgPPPPPPPPPPPPFpGXPJ_JgJqKZKaKgMVMZMZMcPMrNx! k! uP!![NxP!!b!!l!!{!#TP!#r!#|!$SNx!$V!$]EaEa!$a!$k!$n2v!&Y2v2v!(RP.^P!(VP!(vPPPPPP.^P.^!)d.^PP.^P.^PP.^!*x!+SPP!+Y!+cPPPPPPPP&}P&}PP!+g!+g!+z!+gPP!+gP!+gP!,e!,hP!+g!-O!+gP!+gP!-R!-UP!+gP!+gP!+gP!+gP!+g!+gP!+gP!-YP!-`!-c!-iP!+g!-u!-x!.Q!.d!2a!2g!2m!3s!3y!4T!5X!5_!5e!5o!5u!5{!6R!6X!6_!6e!6k!6q!6w!6}!7T!7Z!7e!7k!7u!7{PPP!8R!+g!8vP!<XP!=]P!?n!@U!CQ2vPPP!Dn!HY!JwPP!Mb!MeP# n# t##b##q##w#$w#%a#&[#&e#&h#&tP#&w#'TP#'[#'cP#'fP#'oP#'r#'u#'x#'|#(SssObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/a'kqOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l$p${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e't'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q*v+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-`-f-w.Q.S.T.V.W.d.p.s.v.x/P/S/Y/_/a/p/t/v/w0W0Y0`0j#rgO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`t!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gQ#^cS%`#P.SQ%s#`U%x#e$T/bQ&P#gW'g$l*l-T.xU'q$o&{*ZQ'r$pS(^%Y/_U(}%z+i/zQ)S&QQ+[(lQ+g)QQ-c*yR-m+]u!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gT$q!c(T#upO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#tkO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`X'h$l*l-T.x#}UO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`#}jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jQ%W!{Q([%XV-V*q-Z.y%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-V*q-Z.y%t[OW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-W*q-Z.yS!zZ-VS$S}%{S%z#e$TQ&Q#gQ+i)QQ.[,QR/z/b$eYO_bnow!X!Z!^!`!y#]#f#h#i#m#n#o#p#q#r#s#v#w#{$Y$Z$[$]$^$_$l$p$|%i%k&d&e&n&r'T'Y'Z't'}(W(X(h)T)W)|*]*a*b*e*h*l*v+o,Q,T,X,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q%U!yR+R(X%u^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0j!o!qX!i!r!t#P#_#y$t${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0Y#|jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q$Z!TQ$[!UQ$a!YQ$j!_R*i']Q#jhS&v$R)PQ(|%yQ*Q&wQ+f)OQ,[)oQ-q+hQ.a,]Q/W-rS/c.Y.ZQ/}/dQ0[/{R0a0ZQ&f$OW(s%t&g&h&iQ*P&vU+`(t(u(vQ,Z)oQ,h*QS-n+a+bS.`,[,]Q/V-oR/e.aX)f&c)h,`.drdObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW#R_#U%c,OQ'S$]W'i$l*l-T.xS(m%p(oW)a&c)h,`.dS)p&j,^S)u&m)wR-Z*qh!vX!V#_#d'R(l)`)s*_+]+w,cQ(R$}Q(_%^R+V(b#rmObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`v!tX!V#P#_#d$}%^%b%f'R'e(b(l*_*k+]-Y.S.|Q#W_Q$OzQ$P{Q$Q|Q%t#aQ%u#bQ%v#cQ(j%lS)Y&b+qY)d&c)a)h,`.dS)o&j,^Q+p)ZW+t)`)s+w,cQ+|)bQ,])pT.O+z.QU(P$|'}-fR*O&uW)f&c)h,`.dT)v&m)wQ&i$OQ&q$QQ(v%tQ({%vY)b&c)a)h,`.dV)t&m)u)wQ)[&bR-u+qQ+n)YR-t+p#tmO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`Q,P)dS-w+t.OR.R+|T#U_,OU#S_#U,OR(c%cQ,S)eQ-y+vQ-}+yQ/].PR/x/^ruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$m!aQ&`#wQ'a$jQ'p$nW)f&c)h,`.dQ*s'nQ+})cQ,W)jQ-[*rR-{+xrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS(n%p(oW)f&c)h,`.dT)v&m)wQ&h$OS(u%t&iR+b(vQ&g$OQ&l$PU(t%t&h&iQ(x%uS+a(u(vR-o+bQ)n&eR)y&nQ&p$QS(z%v&qR+e({Q&o$QU(y%v&p&qS+d(z({R-p+eS(n%p(oT)v&m)wrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW)f&c)h,`.dT)v&m)wQ&k$PS(w%u&lR+c(xQ)q&jR.b,^R,b)rQ%q#^R(r%sT(n%p(oQ,R)eS-|+y,SR/[-}R.W,QWj$l*l-T.x#ukO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#|hO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`U%y#e$T/bS)O%z/zQ+h)QR-r+iT&t$R&u!]#ml#Q$`$h$k&O&R&S&V&W&X&Y&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o!V#nl#Q$`$h$k&O&R&S&W&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o#umO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`a'u$p't*v-`/P/v0W0`Q'w$pR-d*yQ&y$UQ'y$uR*|'zT*R&x*SsuObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/artObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$e![R$g!]R$^!WruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aR'T$]R$_!WR'[$aT*d'Z*eX'k$m'l'p*tR*r'mQ-Y*qR.|-ZQ'o$mQ*p'lQ*u'pR-]*tR$n!aQ'j$lV-R*l-T.xQwOQ#]bW#|w#].V/aQ.V,QR/a.WrWObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/al!kW!p#O#Y#x%R%X%g&s'Q)Z+{.T0j!j!pX!i!t#P#_#y${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0YQ#O_Q#Y`#^#xno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%i%k&d&e&n&r'T'Y't'}(W(h)T)W)|*a*b*h*v+o,T,X,t,v-P-`-f.p.s.v/P/v0W0`S%R!y(XQ%X!{j%g#U%c%p&c&j&m(o)h)w*q,^,`.dS&s$R&uY'Q$]$l*l-T.xS)Z&b+qS+{)b)tQ.T,OR0j#vQ!fTR$r!fQ(Y%UR+S(Y^!rX#P#y&]'R'e)Xx$t!i#_%S%Y%b%f(l)`)s*_*k+]+w+z,c-X.Q.S/_/p[$z!r$t${/Y/t0YS${!t+tQ/Y-wQ/t/SR0Y/wQ)U&SR+l)UQ)h&cS,U)h.dR.d,`!laO_bw!Z#U#]#{$Z$[$]$^$_$l%c%p&c&j&m'Z(o)h)w*]*e*l*q,O,Q,^,`-T.V.W.d.x/aY!jW#O%g'Q.TT#Za!jQ-g*}R/R-gQ%O!vR(S%OQ%j#VS(g%j/XR/X-sQ+r)[R-v+rQ%d#SR(d%dQ,Y)lR._,YQ)w&mR,d)wQ,_)qR.c,_Q(o%pR+^(oQ&u$RR)}&uQ%m#WR(k%mQ-a*wR/O-aQ*z'wR-e*zQ*S&xR,i*SQ,m*UR.i,mQ/h.jS0P/h0RR0R/jQ*e'ZR,z*eQ'l$mS*o'l*tR*t'pQ.z-XR/q.zQ*m'jR-U*m`vObw#],Q.V.W/aQ$b!ZQ&a#{Q'O$ZQ'P$[Q'V$^Q'W$_S*d'Z*eR,s*]'YrOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-f-w.Q.S.T.V.W.d.p.s.v.x/S/Y/_/a/p/t/w0Y0ja'v$p't*v-`/P/v0W0`Q!cSQ$U!PQ$V!RQ$W!SQ$u!lQ$w!nQ&}$XQ'z$vQ(T0gS,k*U*WQ,o*VQ,p*XQ.h,mS.j,o.lQ/j.mR0O/g%oROS_bcnow!P!R!S!X!Z!^!`!l!n#P#]#`#e#f#g#h#i#m#n#o#p#q#r#s#w#{$T$X$Y$Z$[$]$^$_$l$o$p$v$|%Y%k%z&Q&r&{'T'Y'Z't'}(h(l)Q)T)W)|*U*V*W*X*Z*]*a*b*e*h*l*v*y+]+i,Q,m,o,t,v-P-T-`-f.S.V.W.l.m.p.s.v.x/P/_/a/b/g/v/z0W0`0gQ'x$pQ*w'tS-_*v/PQ.}-`Q0X/vQ0^0WR0d0`rlObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS#Q_$YQ#tnQ#zoQ$`!XQ$h!^Q$k!`Q&O#fQ&R#hY&S#i$]*a,v.sQ&U#mQ&V#nQ&W#oQ&X#pQ&Y#qQ&Z#rQ&[#sQ&_#w^'s$p't-`/P/v0W0`U(O$|'}-fQ(i%kQ){&rQ*`'TQ*c'YQ+W(hQ+k)TQ+m)WQ,g)|Q,x*bQ,}*hQ-^*vQ.o,tQ.u-PQ/l.pR/o.v#rfO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`W'f$l*l-T.xR.X,QrXObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW!iW#x%R'QQ#P_Q#_d!|#yno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%k&r'T'Y't'}(h)T)W)|*a*b*h*v,t,v-P-`-f.p.s.v/P/v0W0`d%S!y%i&d&e&n(W(X+o,T,XQ%Y#OQ%b#RS%f#U%cQ&]#vQ'R$]W'e$l*l-T.xS(l%p(oQ)X0jW)`&c)h,`.dS)s&m)wQ*_'SQ*k'iQ+](mQ+w)aS+z)b)tQ,c)uS-X*q-ZQ.Q+{Q.S,OQ/_.TR/p.y%t^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jQ$R}Q&w$SR)P%{&PVOW_bdnow}!X!Z!^!`!y!{#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%X%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jR%V!y#ziObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q#V_Q%U!yQ&^#vQ(f%iQ)k&dU)l&e&n,TQ+Q(WQ+R(XQ-s+oR.^,XQ(V%TR+P(U#|eO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`T%w#e/bQ&T#iQ'U$]Q,w*aQ.q,vR/n.sX)g&c)h,`.d!{`OW_abw!Z!j#O#U#]#{$Z$[$]$^$_$l%c%g%p&c&j&m'Q'Z(o)h)w*]*e*l*q,O,Q,^,`-T.T.V.W.d.x/aU!wX!V'RU%r#_#d*_S+Z(l)sQ+u)`S-l+],cR-z+wj!uX!V#_#d$}%^(b(l)`)s+]+w,cU%]#P%f.SQ(a%bQ*^'RQ*j'eQ,u*_Q-Q*kQ.{-YR/s.|Q(Q$|Q*}'}R/Q-fR+O'}[)c&c&m)h)w,`.dT+x)a)uR)]&bW+v)`)s+w,cQ.P+zR/^.QS#T_,OR%h#US)m&e&nR.],TR)r&jW)e&c)h,`.dR+y)aR#X_R*x'tR'x$pT,l*U,mQ.k,oR/i.lR/i.m",
        nodeNames: "⚠ LineComment BlockComment Program ModuleDeclaration MarkerAnnotation Identifier ScopedIdentifier . Annotation ) ( AnnotationArgumentList AssignmentExpression FieldAccess IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock null ClassLiteral void PrimitiveType TypeName ScopedTypeName GenericType TypeArguments AnnotatedType Wildcard extends super , ArrayType ] Dimension [ class this ParenthesizedExpression ObjectCreationExpression new ArgumentList } { ClassBody ; FieldDeclaration Modifiers public protected private abstract static final strictfp default synchronized native transient volatile VariableDeclarator Definition AssignOp ArrayInitializer MethodDeclaration TypeParameters TypeParameter TypeBound FormalParameters ReceiverParameter FormalParameter SpreadParameter Throws throws Block ClassDeclaration Superclass SuperInterfaces implements InterfaceTypeList InterfaceDeclaration interface ExtendsInterfaces InterfaceBody ConstantDeclaration EnumDeclaration enum EnumBody EnumConstant EnumBodyDeclarations AnnotationTypeDeclaration AnnotationTypeBody AnnotationTypeElementDeclaration StaticInitializer ConstructorDeclaration ConstructorBody ExplicitConstructorInvocation ArrayAccess MethodInvocation MethodName MethodReference ArrayCreationExpression Dimension AssignOp BinaryExpression CompareOp CompareOp LogicOp BitOp BitOp LogicOp ArithOp ArithOp ArithOp BitOp InstanceofExpression instanceof LambdaExpression InferredParameters TernaryExpression LogicOp : UpdateExpression UpdateOp UnaryExpression LogicOp BitOp CastExpression ElementValueArrayInitializer ElementValuePair open module ModuleBody ModuleDirective requires transitive exports to opens uses provides with PackageDeclaration package ImportDeclaration import Asterisk ExpressionStatement LabeledStatement Label IfStatement if else WhileStatement while ForStatement for ForSpec LocalVariableDeclaration var EnhancedForStatement ForSpec AssertStatement assert SwitchStatement switch SwitchBlock SwitchLabel case DoStatement do BreakStatement break ContinueStatement continue ReturnStatement return SynchronizedStatement ThrowStatement throw TryStatement try CatchClause catch CatchFormalParameter CatchType FinallyClause finally TryWithResourcesStatement ResourceSpecification Resource",
        maxTerm: 274,
        nodeProps: [["group", -26, 4, 47, 76, 77, 82, 87, 92, 144, 146, 149, 150, 152, 155, 157, 160, 162, 164, 166, 171, 173, 175, 177, 179, 180, 182, 190, "Statement", -25, 6, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 39, 40, 41, 99, 100, 102, 103, 106, 117, 119, 121, 124, 126, 129, "Expression", -7, 23, 24, 25, 26, 27, 29, 34, "Type"], ["openedBy", 10, "(", 44, "{"], ["closedBy", 11, ")", 45, "}"]],
        propSources: [javaHighlighting],
        skippedNodes: [0, 1, 2],
        repeatNodeCount: 28,
        tokenData: "!@p_R!]OX$zXY&jYZ(`Z^&j^p$zpq&jqr)zrs+Ost$ztu1Xuv2_vw3cwx4mxy;Qyz;hz{<O{|<n|}=x}!O>`!O!P?m!P!QFa!Q!RN]!R![!#w![!]!0a!]!^!1e!^!_!1{!_!`!3Y!`!a!3v!a!b!5W!b!c!5p!c!}!;^!}#O!<d#O#P$z#P#Q!<z#Q#R!=b#R#S1X#S#T$z#T#o1X#o#p!>O#p#q!>f#q#r!?r#r#s!@Y#s#y$z#y#z&j#z$f$z$f$g&j$g#BY$z#BY#BZ&j#BZ$IS$z$IS$I_&j$I_$I|$z$I|$JO&j$JO$JT$z$JT$JU&j$JU$KV$z$KV$KW&j$KW&FU$z&FU&FV&j&FV~$zS%PT&WSOY$zYZ%`Zr$zrs%es~$zS%eO&WSS%hTOY%wYZ%`Zr%wrs&Zs~%wS%zTOY$zYZ%`Zr$zrs%es~$zS&^SOY%wYZ%`Zr%ws~%w_&qi&WS%wZOX$zXY&jYZ(`Z^&j^p$zpq&jqr$zrs%es#y$z#y#z&j#z$f$z$f$g&j$g#BY$z#BY#BZ&j#BZ$IS$z$IS$I_&j$I_$I|$z$I|$JO&j$JO$JT$z$JT$JU&j$JU$KV$z$KV$KW&j$KW&FU$z&FU&FV&j&FV~$z_(gY&WS%wZX^)Vpq)V#y#z)V$f$g)V#BY#BZ)V$IS$I_)V$I|$JO)V$JT$JU)V$KV$KW)V&FU&FV)VZ)[Y%wZX^)Vpq)V#y#z)V$f$g)V#BY#BZ)V$IS$I_)V$I|$JO)V$JT$JU)V$KV$KW)V&FU&FV)VV*RV#sP&WSOY$zYZ%`Zr$zrs%es!_$z!_!`*h!`~$zU*oT#_Q&WSOY$zYZ%`Zr$zrs%es~$zT+RVOY+hYZ%`Zr+hrs0Ss#O+h#O#P/p#P~+hT+kVOY,QYZ%`Zr,Qrs,ls#O,Q#O#P-Q#P~,QT,VV&WSOY,QYZ%`Zr,Qrs,ls#O,Q#O#P-Q#P~,QT,qTcPOY%wYZ%`Zr%wrs&Zs~%wT-VT&WSOY,QYZ-fZr,Qrs.us~,QT-kU&WSOY-}Zr-}rs.ds#O-}#O#P.i#P~-}P.QUOY-}Zr-}rs.ds#O-}#O#P.i#P~-}P.iOcPP.lROY-}YZ-}Z~-}T.xVOY+hYZ%`Zr+hrs/_s#O+h#O#P/p#P~+hT/dScPOY%wYZ%`Zr%ws~%wT/sTOY,QYZ-fZr,Qrs.us~,QT0XTcPOY%wYZ%`Zr%wrs0hs~%wT0mR&USXY0vYZ1Spq0vP0yRXY0vYZ1Spq0vP1XO&VP_1`_%}Z&WSOY$zYZ%`Zr$zrs%est$ztu1Xu!Q$z!Q![1X![!c$z!c!}1X!}#R$z#R#S1X#S#T$z#T#o1X#o~$zU2fV#gQ&WSOY$zYZ%`Zr$zrs%es!_$z!_!`2{!`~$zU3ST#]Q&WSOY$zYZ%`Zr$zrs%es~$zV3jX&lR&WSOY$zYZ%`Zr$zrs%esv$zvw4Vw!_$z!_!`2{!`~$zU4^T#aQ&WSOY$zYZ%`Zr$zrs%es~$zT4rX&WSOY5_YZ%`Zr5_rs6Psw5_wx$zx#O5_#O#P7u#P~5_T5dX&WSOY5_YZ%`Zr5_rs6Psw5_wx7_x#O5_#O#P7u#P~5_T6SXOY6oYZ%`Zr6ors9jsw6owx:Yx#O6o#O#P:n#P~6oT6rXOY5_YZ%`Zr5_rs6Psw5_wx7_x#O5_#O#P7u#P~5_T7fTbP&WSOY$zYZ%`Zr$zrs%es~$zT7zT&WSOY5_YZ8ZZr5_rs6Ps~5_T8`U&WSOY8rZw8rwx9Xx#O8r#O#P9^#P~8rP8uUOY8rZw8rwx9Xx#O8r#O#P9^#P~8rP9^ObPP9aROY8rYZ8rZ~8rT9mXOY6oYZ%`Zr6ors8rsw6owx:Yx#O6o#O#P:n#P~6oT:_TbPOY$zYZ%`Zr$zrs%es~$zT:qTOY5_YZ8ZZr5_rs6Ps~5__;XTZZ&WSOY$zYZ%`Zr$zrs%es~$zV;oTYR&WSOY$zYZ%`Zr$zrs%es~$zV<XV$YP&WS#fQOY$zYZ%`Zr$zrs%es!_$z!_!`2{!`~$zV<uX#eR&WSOY$zYZ%`Zr$zrs%es{$z{|=b|!_$z!_!`2{!`~$zV=iT#qR&WSOY$zYZ%`Zr$zrs%es~$zV>PTqR&WSOY$zYZ%`Zr$zrs%es~$zV>gY#eR&WSOY$zYZ%`Zr$zrs%es}$z}!O=b!O!_$z!_!`2{!`!a?V!a~$zV?^T&vR&WSOY$zYZ%`Zr$zrs%es~$z_?tXWY&WSOY$zYZ%`Zr$zrs%es!O$z!O!P@a!P!Q$z!Q![Ac![~$zV@fV&WSOY$zYZ%`Zr$zrs%es!O$z!O!P@{!P~$zVAST&oR&WSOY$zYZ%`Zr$zrs%es~$zTAja&WS`POY$zYZ%`Zr$zrs%es!Q$z!Q![Ac![!f$z!f!gBo!g!hCV!h!iBo!i#R$z#R#SEu#S#W$z#W#XBo#X#YCV#Y#ZBo#Z~$zTBvT&WS`POY$zYZ%`Zr$zrs%es~$zTC[Z&WSOY$zYZ%`Zr$zrs%es{$z{|C}|}$z}!OC}!O!Q$z!Q![Di![~$zTDSV&WSOY$zYZ%`Zr$zrs%es!Q$z!Q![Di![~$zTDpa&WS`POY$zYZ%`Zr$zrs%es!Q$z!Q![Di![!f$z!f!gBo!g!h$z!h!iBo!i#R$z#R#SC}#S#W$z#W#XBo#X#Y$z#Y#ZBo#Z~$zTEzV&WSOY$zYZ%`Zr$zrs%es!Q$z!Q![Ac![~$z_FhZ&WS#fQOY$zYZ%`Zr$zrs%esz$zz{GZ{!P$z!P!QL[!Q!_$z!_!`2{!`~$z_G`V&WSOYGZYZGuZrGZrsHxszGZz{Iz{~GZ_GzR&WSOzHTz{Ha{~HTZHWROzHTz{Ha{~HTZHdTOzHTz{Ha{!PHT!P!QHs!Q~HTZHxOQZ_H{VOYIbYZGuZrIbrsKSszIbz{Kl{~Ib_IeVOYGZYZGuZrGZrsHxszGZz{Iz{~GZ_JPX&WSOYGZYZGuZrGZrsHxszGZz{Iz{!PGZ!P!QJl!Q~GZ_JsT&WSQZOY$zYZ%`Zr$zrs%es~$z_KVVOYIbYZGuZrIbrsHTszIbz{Kl{~Ib_KoXOYGZYZGuZrGZrsHxszGZz{Iz{!PGZ!P!QJl!Q~GZ_LcT&WSPZOYL[YZ%`ZrL[rsLrs~L[_LwTPZOYMWYZ%`ZrMWrsMls~MW_M]TPZOYL[YZ%`ZrL[rsLrs~L[_MqTPZOYMWYZ%`ZrMWrsNQs~MWZNVQPZOYNQZ~NQTNds&WS_POY$zYZ%`Zr$zrs%es!O$z!O!P!!q!P!Q$z!Q![!#w![!d$z!d!e!&i!e!f$z!f!gBo!g!hCV!h!iBo!i!n$z!n!o!%g!o!q$z!q!r!(Z!r!z$z!z!{!)u!{#R$z#R#S!%}#S#U$z#U#V!&i#V#W$z#W#XBo#X#YCV#Y#ZBo#Z#`$z#`#a!%g#a#c$z#c#d!(Z#d#l$z#l#m!)u#m~$zT!!x_&WS`POY$zYZ%`Zr$zrs%es!Q$z!Q![Ac![!f$z!f!gBo!g!hCV!h!iBo!i#W$z#W#XBo#X#YCV#Y#ZBo#Z~$zT!$Og&WS_POY$zYZ%`Zr$zrs%es!O$z!O!P!!q!P!Q$z!Q![!#w![!f$z!f!gBo!g!hCV!h!iBo!i!n$z!n!o!%g!o#R$z#R#S!%}#S#W$z#W#XBo#X#YCV#Y#ZBo#Z#`$z#`#a!%g#a~$zT!%nT&WS_POY$zYZ%`Zr$zrs%es~$zT!&SV&WSOY$zYZ%`Zr$zrs%es!Q$z!Q![!#w![~$zT!&nW&WSOY$zYZ%`Zr$zrs%es!Q$z!Q!R!'W!R!S!'W!S~$zT!'_^&WS_POY$zYZ%`Zr$zrs%es!Q$z!Q!R!'W!R!S!'W!S!n$z!n!o!%g!o#R$z#R#S!&i#S#`$z#`#a!%g#a~$zT!(`V&WSOY$zYZ%`Zr$zrs%es!Q$z!Q!Y!(u!Y~$zT!(|]&WS_POY$zYZ%`Zr$zrs%es!Q$z!Q!Y!(u!Y!n$z!n!o!%g!o#R$z#R#S!(Z#S#`$z#`#a!%g#a~$zT!)z]&WSOY$zYZ%`Zr$zrs%es!O$z!O!P!*s!P!Q$z!Q![!,u![!c$z!c!i!,u!i#T$z#T#Z!,u#Z~$zT!*xZ&WSOY$zYZ%`Zr$zrs%es!Q$z!Q![!+k![!c$z!c!i!+k!i#T$z#T#Z!+k#Z~$zT!+pa&WSOY$zYZ%`Zr$zrs%es!Q$z!Q![!+k![!c$z!c!i!+k!i!r$z!r!sCV!s#R$z#R#S!*s#S#T$z#T#Z!+k#Z#d$z#d#eCV#e~$zT!,|g&WS_POY$zYZ%`Zr$zrs%es!O$z!O!P!.e!P!Q$z!Q![!,u![!c$z!c!i!,u!i!n$z!n!o!%g!o!r$z!r!sCV!s#R$z#R#S!/i#S#T$z#T#Z!,u#Z#`$z#`#a!%g#a#d$z#d#eCV#e~$zT!.j_&WSOY$zYZ%`Zr$zrs%es!Q$z!Q![!+k![!c$z!c!i!+k!i!r$z!r!sCV!s#T$z#T#Z!+k#Z#d$z#d#eCV#e~$zT!/nZ&WSOY$zYZ%`Zr$zrs%es!Q$z!Q![!,u![!c$z!c!i!,u!i#T$z#T#Z!,u#Z~$zV!0hV#oR&WSOY$zYZ%`Zr$zrs%es![$z![!]!0}!]~$zV!1UT&tR&WSOY$zYZ%`Zr$zrs%es~$zV!1lT!PR&WSOY$zYZ%`Zr$zrs%es~$z_!2SW&]Z&WSOY$zYZ%`Zr$zrs%es!^$z!^!_!2l!_!`*h!`~$zU!2sV#hQ&WSOY$zYZ%`Zr$zrs%es!_$z!_!`2{!`~$zV!3aV!bR&WSOY$zYZ%`Zr$zrs%es!_$z!_!`*h!`~$zV!3}W&[R&WSOY$zYZ%`Zr$zrs%es!_$z!_!`*h!`!a!4g!a~$zU!4nW#hQ&WSOY$zYZ%`Zr$zrs%es!_$z!_!`2{!`!a!2l!a~$z_!5aT&`X#nQ&WSOY$zYZ%`Zr$zrs%es~$z_!5wV%{Z&WSOY$zYZ%`Zr$zrs%es#]$z#]#^!6^#^~$zV!6cV&WSOY$zYZ%`Zr$zrs%es#b$z#b#c!6x#c~$zV!6}V&WSOY$zYZ%`Zr$zrs%es#h$z#h#i!7d#i~$zV!7iV&WSOY$zYZ%`Zr$zrs%es#X$z#X#Y!8O#Y~$zV!8TV&WSOY$zYZ%`Zr$zrs%es#f$z#f#g!8j#g~$zV!8oV&WSOY$zYZ%`Zr$zrs%es#Y$z#Y#Z!9U#Z~$zV!9ZV&WSOY$zYZ%`Zr$zrs%es#T$z#T#U!9p#U~$zV!9uV&WSOY$zYZ%`Zr$zrs%es#V$z#V#W!:[#W~$zV!:aV&WSOY$zYZ%`Zr$zrs%es#X$z#X#Y!:v#Y~$zV!:}T&rR&WSOY$zYZ%`Zr$zrs%es~$z_!;e_&PZ&WSOY$zYZ%`Zr$zrs%est$ztu!;^u!Q$z!Q![!;^![!c$z!c!}!;^!}#R$z#R#S!;^#S#T$z#T#o!;^#o~$z_!<kTuZ&WSOY$zYZ%`Zr$zrs%es~$zV!=RTsR&WSOY$zYZ%`Zr$zrs%es~$zU!=iV#cQ&WSOY$zYZ%`Zr$zrs%es!_$z!_!`2{!`~$zV!>VT}R&WSOY$zYZ%`Zr$zrs%es~$z_!>oX&|X#cQ&WSOY$zYZ%`Zr$zrs%es!_$z!_!`2{!`#p$z#p#q!?[#q~$zU!?cT#dQ&WSOY$zYZ%`Zr$zrs%es~$zV!?yT|R&WSOY$zYZ%`Zr$zrs%es~$zT!@aT#tP&WSOY$zYZ%`Zr$zrs%es~$z",
        tokenizers: [0, 1, 2, 3],
        topRules: {
            "Program": [0, 3]
        },
        dynamicPrecedences: {
            "27": 1,
            "230": -1,
            "241": -1
        },
        specialized: [{
            term: 229,
            get: value => spec_identifier$4[value] || -1
        }],
        tokenPrec: 7067
    });
    const javaLanguage = LRLanguage.define({
        parser: parser$c.configure({
            props: [indentNodeProp.add({
                IfStatement: continuedIndent({
                    except: /^\s*({|else\b)/
                }),
                TryStatement: continuedIndent({
                    except: /^\s*({|catch|finally)\b/
                }),
                LabeledStatement: flatIndent,
                SwitchBlock: context => {
                    let after = context.textAfter,
                        closed = /^\s*\}/.test(after),
                        isCase = /^\s*(case|default)\b/.test(after);
                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
                },
                Block: delimitedIndent({
                    closing: "}"
                }),
                BlockComment: () => null,
                Statement: continuedIndent({
                    except: /^{/
                })
            }), foldNodeProp.add({
                ["Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody " + "ConstructorBody InterfaceBody ArrayInitializer"]: foldInside,
                BlockComment(tree) {
                    return {
                        from: tree.from + 2,
                        to: tree.to - 2
                    };
                }
            })]
        }),
        languageData: {
            commentTokens: {
                line: "//",
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            indentOnInput: /^\s*(?:case |default:|\{|\})$/
        }
    });
    function java() {
        return new LanguageSupport(javaLanguage);
    }
    var _m10 = Object.freeze({
        __proto__: null,
        java: java,
        javaLanguage: javaLanguage
    });
    const jsonHighlighting = styleTags({
        String: tags$1.string,
        Number: tags$1.number,
        "True False": tags$1.bool,
        PropertyName: tags$1.propertyName,
        Null: tags$1.null,
        ",": tags$1.separator,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace
    });
    const parser$b = LRParser.deserialize({
        version: 14,
        states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
        stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
        goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
        nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
        maxTerm: 25,
        nodeProps: [["openedBy", 7, "{", 12, "["], ["closedBy", 8, "}", 13, "]"]],
        propSources: [jsonHighlighting],
        skippedNodes: [0],
        repeatNodeCount: 2,
        tokenData: "(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~",
        tokenizers: [0],
        topRules: {
            "JsonText": [0, 1]
        },
        tokenPrec: 0
    });
    const jsonParseLinter = () => view => {
        try {
            JSON.parse(view.state.doc.toString());
        } catch (e) {
            if (!(e instanceof SyntaxError))
                throw e;
            const pos = getErrorPosition(e, view.state.doc);
            return [{
                from: pos,
                message: e.message,
                severity: 'error',
                to: pos
            }];
        }
        return [];
    };
    function getErrorPosition(error, doc) {
        let m;
        if (m = error.message.match(/at position (\d+)/))
            return Math.min(+m[1], doc.length);
        if (m = error.message.match(/at line (\d+) column (\d+)/))
            return Math.min(doc.line(+m[1]).from + +m[2] - 1, doc.length);
        return 0;
    }
    const jsonLanguage = LRLanguage.define({
        parser: parser$b.configure({
            props: [indentNodeProp.add({
                Object: continuedIndent({
                    except: /^\s*\}/
                }),
                Array: continuedIndent({
                    except: /^\s*\]/
                })
            }), foldNodeProp.add({
                "Object Array": foldInside
            })]
        }),
        languageData: {
            closeBrackets: {
                brackets: ["[", "{", '"']
            },
            indentOnInput: /^\s*[\}\]]$/
        }
    });
    function json() {
        return new LanguageSupport(jsonLanguage);
    }
    var _m11 = Object.freeze({
        __proto__: null,
        json: json,
        jsonLanguage: jsonLanguage,
        jsonParseLinter: jsonParseLinter
    });
    const RawString$1 = 1,
        templateArgsEndFallback = 2,
        MacroName = 3;
    const R = 82,
        L = 76,
        u = 117,
        U = 85,
        a = 97,
        z = 122,
        A = 65,
        Z = 90,
        Underscore = 95,
        Zero$1 = 48,
        Quote$1 = 34,
        ParenL$2 = 40,
        ParenR$1 = 41,
        Space$1 = 32,
        GreaterThan$1 = 62;
    const rawString = new ExternalTokenizer(input => {
        if (input.next == L || input.next == U) {
            input.advance();
        } else if (input.next == u) {
            input.advance();
            if (input.next == Zero$1 + 8)
                input.advance();
        }
        if (input.next != R)
            return;
        input.advance();
        if (input.next != Quote$1)
            return;
        input.advance();
        let marker = "";
        while (input.next != ParenL$2) {
            if (input.next == Space$1 || input.next <= 13 || input.next == ParenR$1)
                return;
            marker += String.fromCharCode(input.next);
            input.advance();
        }
        input.advance();
        for (;;) {
            if (input.next < 0)
                return input.acceptToken(RawString$1);
            if (input.next == ParenR$1) {
                let match = true;
                for (let i = 0; match && i < marker.length; i++)
                    if (input.peek(i + 1) != marker.charCodeAt(i))
                        match = false;
                if (match && input.peek(marker.length + 1) == Quote$1)
                    return input.acceptToken(RawString$1, 2 + marker.length);
            }
            input.advance();
        }
    });
    const fallback = new ExternalTokenizer(input => {
        if (input.next == GreaterThan$1) {
            if (input.peek(1) == GreaterThan$1)
                input.acceptToken(templateArgsEndFallback, 1);
        } else {
            let sawLetter = false,
                i = 0;
            for (;; i++) {
                if (input.next >= A && input.next <= Z)
                    sawLetter = true;
                else if (input.next >= a && input.next <= z)
                    return;
                else if (input.next != Underscore && !(input.next >= Zero$1 && input.next <= Zero$1 + 9))
                    break;
                input.advance();
            }
            if (sawLetter && i > 1)
                input.acceptToken(MacroName);
        }
    }, {
        extend: true
    });
    const cppHighlighting = styleTags({
        "typedef struct union enum class typename decltype auto template operator friend noexcept namespace using __attribute__ __declspec __based": tags$1.definitionKeyword,
        "extern MsCallModifier MsPointerModifier extern static register inline const volatile restrict _Atomic mutable constexpr virtual explicit VirtualSpecifier Access": tags$1.modifier,
        "if else switch for while do case default return break continue goto throw try catch": tags$1.controlKeyword,
        "new sizeof delete static_assert": tags$1.operatorKeyword,
        "NULL nullptr": tags$1.null,
        this: tags$1.self,
        "True False": tags$1.bool,
        "TypeSize PrimitiveType": tags$1.standard(tags$1.typeName),
        TypeIdentifier: tags$1.typeName,
        FieldIdentifier: tags$1.propertyName,
        "CallExpression/FieldExpression/FieldIdentifier": tags$1.function(tags$1.propertyName),
        StatementIdentifier: tags$1.labelName,
        "Identifier DestructorName": tags$1.variableName,
        "CallExpression/Identifier": tags$1.function(tags$1.variableName),
        "CallExpression/ScopedIdentifier/Identifier": tags$1.function(tags$1.variableName),
        "FunctionDeclarator/Identifier FunctionDeclarator/DestructorName": tags$1.function(tags$1.definition(tags$1.variableName)),
        NamespaceIdentifier: tags$1.namespace,
        OperatorName: tags$1.operator,
        ArithOp: tags$1.arithmeticOperator,
        LogicOp: tags$1.logicOperator,
        BitOp: tags$1.bitwiseOperator,
        CompareOp: tags$1.compareOperator,
        AssignOp: tags$1.definitionOperator,
        UpdateOp: tags$1.updateOperator,
        LineComment: tags$1.lineComment,
        BlockComment: tags$1.blockComment,
        Number: tags$1.number,
        String: tags$1.string,
        "RawString SystemLibString": tags$1.special(tags$1.string),
        CharLiteral: tags$1.character,
        EscapeSequence: tags$1.escape,
        PreProcArg: tags$1.meta,
        "PreprocDirectiveName #include #ifdef #ifndef #if #define #else #endif #elif": tags$1.processingInstruction,
        MacroName: tags$1.special(tags$1.name),
        "( )": tags$1.paren,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace,
        "< >": tags$1.angleBracket,
        ". ->": tags$1.derefOperator,
        ", ;": tags$1.separator
    });
    const spec_identifier$3 = {
        __proto__: null,
        bool: 34,
        char: 34,
        int: 34,
        float: 34,
        double: 34,
        void: 34,
        size_t: 34,
        ssize_t: 34,
        intptr_t: 34,
        uintptr_t: 34,
        charptr_t: 34,
        int8_t: 34,
        int16_t: 34,
        int32_t: 34,
        int64_t: 34,
        uint8_t: 34,
        uint16_t: 34,
        uint32_t: 34,
        uint64_t: 34,
        char8_t: 34,
        char16_t: 34,
        char32_t: 34,
        char64_t: 34,
        const: 68,
        volatile: 70,
        restrict: 72,
        _Atomic: 74,
        mutable: 76,
        constexpr: 78,
        struct: 82,
        __declspec: 86,
        final: 90,
        override: 90,
        public: 94,
        private: 94,
        protected: 94,
        virtual: 154,
        extern: 156,
        static: 158,
        register: 160,
        inline: 162,
        __attribute__: 166,
        __based: 172,
        __restrict: 174,
        __uptr: 174,
        __sptr: 174,
        _unaligned: 174,
        __unaligned: 174,
        noexcept: 188,
        throw: 192,
        new: 228,
        delete: 230,
        operator: 236,
        template: 266,
        typename: 272,
        class: 274,
        using: 284,
        friend: 292,
        __cdecl: 296,
        __clrcall: 296,
        __stdcall: 296,
        __fastcall: 296,
        __thiscall: 296,
        __vectorcall: 296,
        case: 306,
        default: 308,
        if: 320,
        else: 326,
        switch: 330,
        do: 334,
        while: 336,
        for: 344,
        return: 348,
        break: 352,
        continue: 356,
        goto: 360,
        typedef: 364,
        try: 378,
        catch: 382,
        namespace: 388,
        static_assert: 394,
        explicit: 404,
        union: 420,
        enum: 442,
        signed: 446,
        unsigned: 446,
        long: 446,
        short: 446,
        decltype: 458,
        auto: 460,
        sizeof: 492,
        TRUE: 746,
        true: 746,
        FALSE: 748,
        false: 748,
        NULL: 500,
        nullptr: 518,
        this: 520
    };
    const spec_ = {
        __proto__: null,
        "<": 139
    };
    const spec_templateArgsEnd = {
        __proto__: null,
        ">": 143
    };
    const spec_scopedIdentifier = {
        __proto__: null,
        operator: 218,
        new: 504,
        delete: 510
    };
    const parser$a = LRParser.deserialize({
        version: 14,
        states: "$+^Q!QQVOOP&qOUOOO'cOWO'#CdO*|QUO'#CgO+WQUO'#FoO,nQbO'#CwO-PQUO'#CwO.oQUO'#JaO.vQUO'#CvO/ROpO'#DyO/ZQ!dO'#DbOOQQ'#I['#I[O/fQUO'#KOO1VQUO'#I`OOQQ'#I`'#I`O4XQUO'#JrO7YQUO'#JrO9aQVO'#EZO9qQUO'#EZO9vQUOOO:OQVO'#EhO<`QVO'#EiO<pQUO'#EiO?[QUO'#JvO?fQUO'#JvO?pQVO'#HwOOQQ'#Jv'#JvOAdQUO'#JvOCiQUO'#JvOCvQUO'#FaODhQUO'#FmOOQR'#Fo'#FoO,iQUO'#FoOOQR'#KS'#KSOOQR'#KR'#KRODmQVO'#JWOFeQUO'#KVOFrQUO'#KVOOQR'#Gl'#GlOGdQUO'#KXOOQR'#Gs'#GsOOQR'#Gu'#GuOOQR'#KQ'#KQOOQR'#Io'#IoQ!QQVOOOGoQVO'#FgOOQQ'#Iv'#IvOGvQUO'#HSOOQQ'#Ja'#JaOK_QUO'#JaOK{QUO'#JWOM{QVO'#HfOM{QVO'#HiOOQQ'#Hn'#HnOOQQ'#Ho'#HoO! zQUO'#HvOOQQ'#JW'#JWO!$OQUO'#JaOOQR'#J`'#J`O!$VQUO'#DWO!$[QUO'#JsOOQQ'#Js'#JsO!&hQUO'#EQO!&mQUO'#ETO!&rQ#vO'#EuO!'lQUO'#GgO!'wQUO'#FqO!(PQUO'#FvO!(UQVO'#FxO!(PQUO'#F|O!*qQUO'#F}O!*vQVO'#GPO!+QQUO'#GRO!+VQUO'#GTO!+[QUO'#GVO!+aQUO'#GXOM{QVO'#FjO!,hQUO'#FjO!,mQUO'#G`O!,rQVO'#GdO!,yQUO'#GeO!-RQUO'#GhO!/QQUO'#GkO!/bQUO'#GmO4XQUO'#FeO!0SQUO'#DUO!0hQUO'#HPO!0|QUO'#HQO!1_QUO'#HWO!1sQUO'#HXO!2hQUO'#HYO!4WQVO'#HkO!4bQUO'#HqO!4iQVO'#HtP!6V{&jO'#CbP!,|{&jO'#CbP!6b{,UO'#CbP!,|{&jO'#CbP!6g{&jO'#CbP!6rOSO'#IUPOOO)CDt)CDtOOOO'#IW'#IWO!6|OWO,59OOOQR,59O,59OOM{QVO,59UOOQQ,59W,59WOM{QVO,5<[OOQR,5<Z,5<ZO!7XQUO,59YOM{QVO,5={OOQR'#Hc'#HcOOQR'#Hd'#HdOOQR'#He'#HeOM{QVO,5=|OM{QVO,5=|OM{QVO,5=|OM{QVO,5=|OM{QVO,5=|OM{QVO,5=|OM{QVO,5=|OM{QVO,5=|OM{QVO,5=|O!9TQVO,5>TOOQQ,5>d,5>dO!:pQVO'#ChO!>YQUO'#CyOOQQ,59c,59cOOQQ,59b,59bOOQQ,5;U,5;UO!>gQ#vO,5=`O!4bQUO,5>]O!@zQVO,5>`O!ARQbO,59cO!A^QVO'#FQOOQQ,5>X,5>XO!AnQVO,59VO!AuO`O,5:eO!AzQbO'#DcO!B]QbO'#JgO!BkQbO,59|O!DmQUO'#CsO!F]QbO'#CwO!FbQUO'#CvO!IuQUO'#JaOOQQ-E<Y-E<YO!I|QUO,5@jOCvQUO,5;{O!JTQUO'#JaO4XQUO,5<POOQQ-E<^-E<^O!J_QUO,5@^O!J_QUO,5@^OOQR,5@j,5@jO!N_QUO'#CgO# TQUO,5=zO#!vQbO'#CwO##XQUO'#EjO##^QUO'#HmO##fQUO'#CvOOQR'#IX'#IXO##qQUO,5:uO#$XQUO,5:uO#$rQUO,5:uO#%dQUO'#CtO!&mQUO'#ClOOQQ'#Ia'#IaO#%lQ#vO'#EuO#$XQUO,5:uO#'XQUO,5:vO#)xQVO,5;RO#*SQUO'#EXO#*aQUO,5<gO#,eQUO'#JaO!+aQUO'#C}O#,lQUO,5;SO#,wQUO,5<gO#,|QUO'#C}O#-vQUO,5>UO#-{QUO,5;TO#.mQbO'#CwO#$XQUO'#EZO<pQUO'#EhO#.xQUO'#JvO!,|QUO'#EwO#/mQUO'#CtOOQQ,5;`,5;`O#2[QVO'#C{O#2fQUO'#KcO#5cQUO'#JzO#5jQUO'#JWO#5}QUO,5;cO#6SQVO'#F{OM{QVO'#H`O#8lQVO,5>cO?pQVO'#HwO#8vQUO,5>cO#8yQUO,5>cOOQQ,5>c,5>cO#9OQUO'#GoOOQR,5@q,5@qO#9WQUO,5@qO#9`QUO'#GqO#9hQUO,5<PO#9|QUO'#KPO#:UQUO,5;{O!(UQVO,5<XOOQR'#Is'#IsO#:ZQVO,5=UO#<aQbO'#CwO#<lQUO'#EjOAdQUO,5@qOOQQ'#It'#ItOOQQ-E<r-E<rOFrQUO,5@qO#9WQUO,5@sO#<qQUO,5@sOOQR,5@s,5@sOOQR,5@t,5@tO#<|QVO,5@tOOQR-E<m-E<mO#>mQVO,5<ROOQR,5<R,5<ROOQQ-E<t-E<tOOQQ,5=n,5=nOOQQ,59`,59`O#>tQUO,5>QO#@tQUO'#JWO#@{QUO,5>TO#A`QUO'#EbO#B}QUO'#EcO#CqQUO'#EcO#CyQVO'#EdO#DTQUO'#EeO#DqQUO'#EfOOQQ'#Jx'#JxO#E_QUO,5>bOOQQ,5>b,5>bO!,|QUO,59rO#EjQUO,5<SO!&mQUO,5:lOOQQ,5:o,5:oO#EwQUO'#JrOOQQ,5;a,5;aO#HeQUO,5;aO#HoQUO,5;aO#HtQUO,5;aO#HyQUO,5;aO! iQUO,5=`O#ITQUO,5;yO#I]QUO,5=RO#IbQUO,5=RO#LiQVO'#FsO!(UQVO,5<]O!(PQUO,5<]O!,mQUO,5<bO#LpQUO,5<dO!(UQVO,5<hO#LuQVO,5<iO$ wQUO,5<kOOQR,5<k,5<kO$#QQUO,5<kOOQR,5<m,5<mOOQR,5<o,5<oOOQQ'#Fn'#FnO$#VQUO,5<qO!+aQUO,5<sO$#[QUO,5<sO$#jQUO,5<UO$$pQVO,5<UO$&oQUO,5<zO$&tQUO,5=OOOQR,5=O,5=OOOQQ'#Cg'#CgO$'zQVO'#FiOOQR,5=P,5=PO$(RQUO,5=POM{QVO,5=SO$)kQUO'#JaO$)rQUO,5=VO$+nQUO'#FWO<pQUO,5=VO$+xQUO,5;pOM{QVO,5=XOCvQUO,5<PO$/zQUO'#JbO$0RQUO'#JbO$0]QUO'#D[O$0hQUO'#D_O$3UQUO,59pOOQQ,59p,59pO$4zQUO,59pO$5PQUO,59pO$5XQUO,59pO$7ZQUO,5=kOOQQ,5=k,5=kO$4zQUO,5=kO$5PQUO,5=kO$9PQUO,5=kO$9bQUO'#HUO$9jQUO,5=lOOQQ,5=l,5=lO$<{QUO,5=lO$>wQUO,5=rOOQQ,5=r,5=rO$4zQUO,5=rO$5PQUO,5=rO$@mQUO,5=rOOQQ,5=s,5=sOM{QVO,5=tO$AOQUO,5>VO#6SQVO'#F{OOQQ,5>V,5>VO$BqQUO,5>VO$BvQUO,5>]O!1sQUO,5>]O$DyQUO,5>`O$H]QVO,5>`P!6g{&jO,58|P$Hd{&jO,58|P$Hr{,UO,58|P$Hx{&jO,58|PO{O'#I{'#I{P$H}{&jO'#KdPOOO'#Kd'#KdP$IT{&jO'#KdPOOO,58|,58|POOO,5>p,5>pP$IYOSO,5>pOOOO-E<U-E<UOOQR1G.j1G.jO$IaQUO1G.pO$JgQUO1G1vOOQQ1G1v1G1vO$KsQUO'#CoO$NPQbO'#CwO$N[QUO'#CrO$NaQUO1G.tO#/mQUO'#CqOOQQ1G.t1G.tO%!dQUO1G3gO%#jQUO1G3hO%%]QUO1G3hO%'OQUO1G3hO%(qQUO1G3hO%*dQUO1G3hO%,VQUO1G3hO%-xQUO1G3hO%/kQUO1G3hO%1^QUO1G3hO%3PQUO1G3hO%4rQUO'#JVO%5{QUO'#JVO%6TQUO,59SOOQQ,5;W,5;WO%8YQUO,5;WO%8dQUO,5;WO%8iQUO,5;WO%8nQUO,5;WO! iQUO1G2zO%:xQUO1G3wO!1sQUO1G3wO%;PQUO1G3zO%<rQVO1G3zOOQQ1G.}1G.}OOQQ1G.|1G.|OOQQ1G0p1G0pO!>gQ#vO1G2zO%<yQUO'#J{O?pQVO'#HwO%>SQUO'#FTOOQQ'#Ik'#IkO%>XQUO'#FRO%>dQUO'#J{O%>lQUO,5;lO%>qQUO1G.qOOQQ1G.q1G.qOOQR1G0P1G0PO%@dQ!dO'#I]O%@iQbO,59}O%BzQ!eO'#DeO%CRQ!dO'#I_O%CWQbO,5@RO%CWQbO,5@ROOQQ1G/h1G/hO%CcQbO1G/hO%EeQUO'#CyO!F]QbO,59cOOQR1G6U1G6UO#9hQUO1G1kO%GQQUO1G1gOCvQUO1G1kO%G}QUO1G5xO%I^Q#vO'#ElO%JUQbO,59cOOQR-E<V-E<VO%JaQUO1G0aO##qQUO1G0aOOQQ-E<_-E<_O#$XQUO1G0aOOQQ'#Ib'#IbO%KRQUO1G0bO!+aQUO'#EaOOQQ'#Ic'#IcO%LgQUO1G0bO%MZQUO'#E]O%NnQUO'#E_O%NsQUO1G0mO& yQVO1G0mOOQQ1G0m1G0mO&!TQVO1G0mO#EpQUO'#EYO&!yQUO'#EYO&#dQUO'#JuO&#lQUO,5:sOOQQ1G2R1G2RO&#qQUO,59iOOQQ1G0n1G0nO&#qQUO,59iO&$kQUO,59iO!AnQVO1G3pO&%VQUO'#JzO&%_QUO'#K]O&&kQUO'#J_O&&yQUO'#J^O&'UQUO,59gOM{QVO'#IyO&'^QUO,5@}O!,|QUO'#IgO&'fQUO,5@fOOQQ1G0}1G0}OOQQ1G3}1G3}OM{QVO1G3}O&'nQUO'#GpO&'vQUO'#KWOOQQ,5=Z,5=ZOOQR1G6]1G6]O&(RQUO,5=]O&(WQUO,5=^O&(]QVO'#EXO&/_QVO'#FgO!AnQVO,5;|OOQQ,5;|,5;|OCvQUO'#InO&/oQUO,5@kOOQR1G1k1G1kOOQR1G1g1G1gOOQR1G1s1G1sOOQR-E<q-E<qO#9WQUO1G6]OAdQUO1G6]O#9WQUO1G6_OOQR1G6_1G6_OOQR1G6`1G6`O#<|QVO1G6`O&/wQUO1G6`O&0}QVO,5=^OOQR1G1m1G1mOOQQ'#Ie'#IeO&1UQUO,5:|O&2sQUO,5:|OOQQ'#If'#IfO&2zQUO,5:}OOQQ,5:},5:}O&2zQUO,5:}O&3nQVO,5;OO&3xQUO,5;OO&3nQVO,5;OOOQQ,5;O,5;OO&5OQVO,5;OO&5VQUO,5;PO&6PQUO,5;QOOQQ1G3|1G3|O&6WQUO1G/^O/fQUO'#FaOOQR1G1n1G1nO&6]QUO1G0WOOQQ1G0{1G0{O&6bQUO1G0{O&6gQUO1G2zO!+aQUO1G1eOOQR1G2m1G2mO&6xQUO1G2mO&6}QUO,5<_O#EpQUO'#FaOCvQUO'#FaO&7UQUO,5<_OM{QVO,5<_O&7^QUO,5<_O&7cQVO1G1wO!(UQVO1G1wOOQR1G1|1G1|O&<]QUO1G2OOOQR1G2S1G2SO&<bQUO1G2TOCvQUO1G2eO&=kQVO1G2TO&=rQUO1G2TOOQR1G2V1G2VOOQR1G2]1G2]O$#[QUO1G2_OOQQ'#Cu'#CuO&=wQUO'#GZO&>lQUO'#GZO&>qQUO'#KTO$#[QUO'#G^OOQQ'#KU'#KUO&?PQUO1G2_O&?UQVO1G1pOCvQUO'#FaOOQR'#Ip'#IpO&?UQVO1G1pO&ATQUO'#F}OOQR'#Ir'#IrO&AYQVO1G2fO&FVQUO'#GbOOQR1G2j1G2jOOQR,5<T,5<TO&F[QVO,5<TOOQR1G2k1G2kO&FcQUO1G2nOOQR1G2q1G2qOOQQ'#J}'#J}O&GlQUO'#J|O&GwQUO,5;rO&HPQUO'#FXO&HdQUO'#FXO&HwQUO'#F^O&H|QUO1G2qO&IXQUO'#JaOFrQUO'#KVO#9WQUO'#KXOOQR'#Gw'#GwOOQR'#Gx'#GxO&IcQUO'#F_O&IhQUO'#FcO&HwQUO'#FUOOQR1G1[1G1[O&JeQUO1G2sO&KkQUO1G1kO&KvQUO'#JcOOQQ,59v,59vO&LRQUO'#JcO&LZQUO'#DaO&LeQUO'#JvO&M^QUO'#DaOFrQUO'#KVOOQQ'#Gz'#GzOOQQ'#G|'#G|OOQQ'#G}'#G}OOQQ'#Je'#JeOOQQ'#IZ'#IZO&MhQUO,59yOOQQ,59y,59yO&NeQUO'#DaO&NrQUO'#HOOOQQ1G/[1G/[O$4zQUO1G/[O$5PQUO1G/[O&NwQUO1G/[OOQQ1G3V1G3VO$4zQUO1G3VO$5PQUO1G3VO'$YQUO1G3VO''kQUO'#HVO''vQUO'#K[O'(OQUO,5=pO'(TQUO'#KZOOQQ1G3W1G3WO'+qQUO1G3WO'+xQUO1G3WOOQQ1G3^1G3^O$4zQUO1G3^O$5PQUO1G3^O',PQUO1G3^O'/bQUO1G3`O'0hQUO,5@zO!,|QUO1G3qOM{QVO'#HsOOQQ1G3w1G3wO'0mQUO1G3wO'0tQVO1G3zPOOO1G.h1G.hP!6g{&jO1G.hP'2hQUO'#KfP'2s{&jO1G.hP'2x{,UO1G.hPO{O-E<y-E<yPOOO,5AO,5AOP'3Q{&jO,5AOPOOO1G4[1G4[OM{QVO7+$[O'3VQUO'#CyOOQQ,59^,59^O'3bQbO,59cOOQQ,59],59]OOQQ7+)R7+)RO!AnQVO'#IzO'3mQUO,5?qOOQQ1G.n1G.nOOQQ1G0r1G0rO'3uQUO1G0rO'3zQUO7+(fOOQQ7+)c7+)cO'6]QUO7+)cO'6dQUO7+)cO'0tQVO7+)fO! iQUO7+(fO'6kQVO'#IlO'7OQUO,5@gO'7WQUO,5;nOOQQ'#Co'#CoOOQQ,5;o,5;oOM{QVO'#FSOOQQ-E<i-E<iO!AnQVO,5;mOOQQ1G1W1G1WOOQQ,5>w,5>wOOQQ-E<Z-E<ZOOQR'#Dk'#DkOOQR'#Dm'#DmOOQR'#Dp'#DpO'8aQ!eO'#JhO'8hQ7_O'#JhO'8oQ!eO'#JhOOQR'#Jh'#JhOOQR'#I^'#I^O'8vQ!eO,5:POOQQ,5:P,5:PO'8}QbO,5>yOOQQ-E<]-E<]O'9]QbO1G5mOOQQ7+%S7+%SOOQR7+'V7+'VOOQR7+'R7+'RO&KkQUO7+'VO'9hQUO7+%{O##qQUO7+%{OOQQ-E<`-E<`O':YQUO7+%|O';kQUO,5:{O!1sQUO,5:{OOQQ-E<a-E<aO'<kQVO,5:wO'<rQUO,5:yOOQQ7+&X7+&XO'<yQUO7+&XO'>PQVO7+&XO'>xQUO,5:tO'@aQUO'#EbO'ASQUO,5:tO#CyQVO'#EdO'AZQUO'#EeO'BsQUO'#EfO'CZQUO,5:tOM{QVO,5;dO'CeQUO'#EzOOQQ,5;e,5;eO'CvQUO'#IhO'DQQUO,5@aOOQQ1G0_1G0_O'DYQUO1G/TO'ESQUO1G/TO'EnQUO7+)[OOQQ7+)_7+)_OOQQ,5=w,5=wO#/rQVO'#IxO'GaQUO,5?xOOQQ1G/R1G/RO'GlQUO,5?eOOQQ-E<w-E<wOOQQ,5?R,5?ROOQQ-E<e-E<eO'HuQUO7+)iO'HzQUO,5=[O#9OQUO'#IuO'IYQUO,5@rOOQR1G2w1G2wOOQR1G2x1G2xO'IeQUO'#J{O?pQVO'#HwO'JqQUO1G1hOOQQ1G1h1G1hO'KzQUO,5?YOOQQ,5?Y,5?YOOQQ-E<l-E<lOOQR7++w7++wO#9WQUO7++wOOQR7++y7++yO'L`QUO7++zOOQR7++z7++zOOQQ-E<c-E<cO'NTQUO1G0hOOQQ-E<d-E<dOOQQ1G0i1G0iO'N[QUO1G0iO( OQUO1G0jO(!UQVO1G0jOOQQ1G0j1G0jO(!`QVO1G0jOOQQ1G0k1G0kOOQQ7+$x7+$xOOQQ7+%r7+%rOOQQ7+&g7+&gO(!gQUO7+'POOQR7+(X7+(XOOQR1G1y1G1yOCvQUO,5;{O(!}QUO,5<`O(#UQUO1G1yO($_QUO1G1yO!(UQVO7+'cO($dQVO7+'cOM{QVO'#F{O()^QUO7+'jO()cQVO7+'oO()jQUO7+(PO()tQUO7+'oO(*zQVO7+'oO(+RQUO7+'yO(+WQUO,5<uO&=wQUO,5<uO(+xQUO,5<uO&=wQUO,5<uOOQQ,5<v,5<vO(,ZQVO,5<wO$#[QUO'#IqO(,eQUO,5@oO(,mQUO,5<xOOQR7+'y7+'yO(,xQVO7+'[O()mQUO'#KPOOQR-E<n-E<nO#LuQVO,5<iOOQR-E<p-E<pO!,mQUO,5<|OOQR1G1o1G1oO(.wQUO7+(YO(.|QVO7+(YO$)}QUO'#ImO(/UQUO,5@hOOQQ1G1^1G1^O(/aQUO,5;sO!1sQUO,5;vO(/zQUO,5;wO(0YQUO,5;sO(2]QUO,5;xOOQR7+(]7+(]O#IWQUO,5;yO(2eQUO'#JbO(2oQUO'#JbOOQR,5;},5;}O(2|QUO,5;}O!1_QUO,5;}O!0SQUO,5;}O!0hQUO,5;}OOQQ7+(_7+(_O(3RQUO'#IYO(3^QUO,5?}O(3^QUO,5?}O(3fQUO,5?}O(3qQUO,59{O4XQUO,59{OOQQ,5=g,5=gO(3{QUO'#ESO(4|QUO'#ESO(5dQUO,59{O(5nQUO'#E}O(5nQUO'#FOOOQQ'#Jt'#JtO(6YQUO'#JtOM{QVO'#FPOOQQ,59{,59{O(6wQUO,59{O!AnQVO,59{O(6|QUO,5@qOOQQ-E<X-E<XOOQQ1G/e1G/eOOQQ,5=j,5=jOOQQ7+$v7+$vO$4zQUO7+$vO$5PQUO7+$vOOQQ7+(q7+(qO$4zQUO7+(qO$5PQUO7+(qOM{QVO,5=qO(7TQUO'#IwO(7`QUO,5@vOOQQ1G3[1G3[O(7hQUO,5@uOOQQ,5@u,5@uOOQQ7+(r7+(rO(:|QUO7+(rOOQQ7+(x7+(xO$4zQUO7+(xO$5PQUO7+(xOOQQ7+(z7+(zO(?lQVO1G6fO(AnQUO7+)]O(AsQUO,5>_O(ByQUO7+)fPOOO7+$S7+$SP(DlQUO'#KgP(DtQUO,5AQP(Dy{&jO7+$SPOOO1G6j1G6jO(EOQUO<<GvOOQQ1G.x1G.xO(FqQUO,5?fOOQQ,5?f,5?fOOQQ-E<x-E<xOOQQ7+&^7+&^OOQQ<<L}<<L}O(GzQUO<<L}O(I}QUO<<MQO(KpQUO<<LQO(LRQUO,5?WOOQQ,5?W,5?WOOQQ-E<j-E<jOOQQ1G1Y1G1YO'7ZQUO,5;nO(M[QUO1G1XOOQQ1G1X1G1XOOQR,5@S,5@SO(NeQ!eO,5@SO(NlQ7_O,5@SO(NsQ!eO,5@SOOQR-E<[-E<[OOQQ1G/k1G/kO(NzQ!eO'#DzOOQQ1G4e1G4eOOQR<<Jq<<JqO) RQUO<<IgOOQQ'#Ec'#EcO)!}QUO1G0gO)#XQUO1G0gO)#lQUO1G0cOOQQ1G0c1G0cO)$rQUO'#JwO)$zQUO1G0eOOQQ<<Is<<IsO)%bQUO1G0`O)%iQUO'#EfO)%yQUO1G0`O)&QQUO'#IXOOQQ,5;g,5;gOM{QVO1G1OO)'bQUO1G1OOOQQ,5;f,5;fOOQQ,5?S,5?SOOQQ-E<f-E<fO)(qQUO7+$oO))]QUO'#K_O)*iQUO'#K^OOQQ,5?d,5?dOOQQ-E<v-E<vOOQQ<<MT<<MTOOQQ1G2v1G2vOOQQ,5?a,5?aOOQQ-E<s-E<sO'6kQVO,5<[OOQR<= c<= cOOQR<= f<= fOOQQ7+&T7+&TOOQQ7+&U7+&UO)*wQUO7+&UO)+}QVO7+&UOOQR<<Jk<<JkO!AnQVO1G1zO),UQUO1G1zOOQR7+'e7+'eOOQR<<J}<<J}O!(UQVO<<J}OOQR<<KU<<KUO),aQUO<<KZO)-gQVO<<KZO!AnQVO<<KkO)-nQUO<<KZO!(UQVO<<KZO).wQUO<<KZOOQR<<Ke<<KeO).|QUO1G2aO(+WQUO1G2aO&=wQUO1G2aO)/_QUO1G2cO)0eQVO1G2cOOQQ1G2c1G2cO)0oQVO1G2cO)0vQUO,5?]OOQQ-E<o-E<oOOQQ1G2d1G2dOOQR1G2h1G2hOOQR<<Kt<<KtO)1UQVO<<KtO)1aQUO<<KtOOQQ,5?X,5?XOOQQ-E<k-E<kO!1sQUO1G1bOOQQ1G1b1G1bOOQQ1G1c1G1cO)1fQUO'#FXOOQQ1G1d1G1dOOQR1G1i1G1iO)1zQUO1G1iO)2RQUO1G1iO)2YQUO1G1iO)2aQUO,5>tO&LRQUO,5>tOOQQ-E<W-E<WO)2lQUO1G5iO)2lQUO1G5iO)2tQUO1G/gOOQQ1G/g1G/gO)3OQUO1G/gO!AnQVO1G/gO)3TQUO1G/gO)3_QUO,5:nO(3{QUO,5:nO)3uQUO,5:nO(3{QUO,5:nO)5RQUO,5:rO)5oQVO,5;hO(5nQUO'#IjO)5yQUO1G/gO)6[QVO1G/gOOQQ1G3P1G3PO)6cQUO,5;iO)6nQUO,5;jO)7YQUO,5;kO)8`QUO1G/gOOQQ1G3R1G3ROOQQ<<Hb<<HbO$4zQUO<<HbOOQQ<<L]<<L]O$4zQUO<<L]O)9fQUO1G3]OOQQ,5?c,5?cOOQQ-E<u-E<uOOQQ<<L^<<L^OOQQ<<Ld<<LdO$4zQUO<<LdOOQQ<<Lw<<LwO):oQUO1G3yP)<rQUO'#I|P)<zQUO,5ARPO{O1G6l1G6lPOOO<<Gn<<GnOOQQANBiANBiOOQR1G5n1G5nO)=SQ!eO,5:fOOQQ,5:f,5:fO)=xQUO7+&ROOQQ7+%}7+%}O!+aQUO'#IdO)>oQUO,5@cOOQQ7+&P7+&PO)>wQUO7+&jOOQQ,5=x,5=xO)@WQUO1G1vOOQQ<<Ip<<IpO)AdQUO7+'fOOQRAN@iAN@iO)BpQVOAN@uO)BwQUOAN@uO!(UQVOAN@uO)DQQUOAN@uO)DVQUOANAVO)E]QUOANAVOOQRAN@uAN@uO)EbQUO7+'{O(+WQUO7+'{OOQQ7+'}7+'}O)EsQUO7+'}O)FyQVO7+'}O)GQQUOANA`OOQQ7+&|7+&|O)GVQUO,5;sOOQR7+'T7+'TOOQQ1G4`1G4`O)GeQUO1G4`O)GpQUO7++TO)GxQUO7+%ROOQQ7+%R7+%RO)HZQUO7+%RO)6[QVO7+%ROOQQ7+(k7+(kO)H`QUO7+%RO)IfQUO7+%RO!AnQVO7+%RO)IpQUO1G0YO)3_QUO1G0YO(3{QUO1G0YOOQQ'#Ii'#IiO)J[QUO1G0^O)JxQUO1G1SO)LOQVO1G1SOOQQ1G1S1G1SO)LYQVO1G1SO)LaQUO,5?UOOQQ-E<h-E<hOOQQ1G1T1G1TOOQQAN=|AN=|OOQQANAwANAwOOQQANBOANBOOOQQ7+)e7+)ePOQQ,5?h,5?hPOQQ-E<z-E<zOOQQ1G0Q1G0QOOQQ,5?O,5?OOOQQ-E<b-E<bO)LxQUOG26aO!(UQVOG26aO)NRQUOG26aOOQRG26aG26aO!(UQVOG26qO)NWQUO<<KgOOQQ<<Ki<<KiOOQRG26zG26zOOQQ7+)z7+)zOOQQ<<Hm<<HmO)NiQUO<<HmO!AnQVO<<HmO)NnQUO<<HmO* tQUO<<HmO)6[QVO<<HmOOQQ<<LV<<LVO*!VQUO7+%tO)3_QUO7+%tOOQQ-E<g-E<gOOQQ7+&n7+&nO*!qQUO7+&nO*#wQVO7+&nO!(UQVOLD+{OOQRLD+{LD+{OOQRLD,]LD,]OOQQAN>XAN>XO*$OQUOAN>XO*%UQUOAN>XO!AnQVOAN>XO*%ZQUO<<I`OOQQ<<JY<<JYOOQR!$( g!$( gOOQQG23sG23sO*%uQUOG23sO*&{QUOG23sOOQQLD)_LD)_O*'QQUO'#CgO'nQUO'#CgO**}QUO'#CyO*-_QUO'#CyO*.WQUO'#CyO*.hQUO'#CyO*0oQUO'#CyO*0|QUO'#CyO*2oQUO'#CyO*4fQUO'#CyO*4qQbO,59cO*4|QbO,59cO*5XQbO,59cO*5dQUO'#CgO*7hQUO'#CgO*7rQUO'#CgO*:TQUO'#CgO*<zQUO'#CgO*=[QUO'#CgO*>XQUO'#CgO*A_QUO'#CgO*AlQUO'#CgO*AvQbO'#CwO*BXQbO'#CwO*BjQbO'#CwO*B{QUO,5:uO*CcQUO,5:uO*CcQUO,5:uO*C|QbO'#CwO*DXQbO'#CwO*DdQbO'#CwO*DoQbO'#CwO*CcQUO'#EZO*DzQUO'#EZOCvQUO'#EiO*FRQUO'#EiO#3oQUO'#JzO*FsQbO'#CwO*GOQbO'#CwO*GZQUO'#CvO*G`QUO'#CvO*HYQUO'#EbO*IeQUO'#EfO*JqQUO'#CoO*KPQbO,59cO*K[QbO,59cO*KgQbO,59cO*KrQbO,59cO*K}QbO,59cO*LYQbO,59cO*LeQbO,59cO*B{QUO1G0aO*LpQUO1G0aO*CcQUO1G0aO*DzQUO1G0aO*MWQUO,5:|O*NQQUO,5:|O*NwQUO,5;QO+#OQUO'#JaO+#`QUO'#CyO+#nQbO,59cO*B{QUO7+%{O*LpQUO7+%{O+#yQUO,5:{O+$ZQUO'#EbO+$kQUO1G0hO+%|QUO1G0gO+&WQUO1G0gO+&|QUO'#EfO+'mQUO7+&RO+'tQUO'#EZO+'yQUO'#CwO+(OQUO'#EjO+(TQUO'#EjO+(YQUO'#CvO+(_QUO'#CvO+(dQUO'#CwO+(iQUO'#CwO+(nQUO'#CvO+(yQUO'#CvO+)UQUO'#CvO*LpQUO,5:uO*DzQUO,5:uO*DzQUO,5:uO+)aQUO'#JaO+)}QUO'#JaO+*XQUO'#JaO+*lQbO'#CwO+*wQUO'#CrO!+aQUO'#EaO!1sQUO,5:{O+*|QUO'#EZ",
        stateData: "++r~O'tOSSOSTOSRPQVPQ&oPQ&qPQ&rPQ&sPQ&tPQ&uPQ&vPQ&wPQ~O)[OS~OPsO]dOa!ZOdjOlTOr![Os![Ot![Ou![Ov![Ow![Oy!wO{!]O!S}O!ZiO!]!UO!^!TO!l!YO!ouO!p!^O!q!_O!r!_O!s!_O!u!`O!x!aO#S!qO#f#OO#g#PO#j!bO#y!tO#|!{O#}!zO$S!cO$Y!vO$_!nO$`!oO$f!dO$k!eO$m!fO$n!gO$r!hO$t!iO$v!jO$x!kO$z!lO$|!mO%T!pO%Y!rO%]!sO%b!uO%j!xO%u!yO%w!OO%}!|O&O!QO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'xRO(YYO(]aO(_fO(`eO(aoO(bXO)T!VO)U!WO~OR#VOV#QO&o#RO&q#SO&r#TO&s#TO&t#UO&u#UO&v#SO&w#SO~OX#XO'v#XO'w#ZO~O]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiX{iX!QZX!SiX!ZZX!ZiX!]ZX!^ZX!`ZX!bZX!cZX!eZX!fZX!gZX!iZX!jZX!kZX!piX!qiX!riX!siX!uiX!xiX#jiX'xiX'{ZX'|$bX'}ZX(OZX(WZX(]ZX(]iX(^ZX(_ZX(_iX(`ZX(`iX(aZX(mZX~O(aiX!YZX~P'nO]#pO!Q#^O!Z#aO!]#nO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O'}#`O(O#`O(W#oO(]#bO(^#cO(_#cO(`#dO(a#_O~Od#tO#a#uO&f#vO&i#wO(P#qO~Ol#xO~O!S#yO](TXd(TXr(TXs(TXt(TXu(TXv(TXw(TX{(TX!Z(TX!p(TX!q(TX!r(TX!s(TX!u(TX!x(TX#j(TX'x(TX(](TX(_(TX(`(TX(a(TX~Ol#xO~P-UOl#xO!k#{O(m#{O~OX#|O(c#|O~O!W#}O(W(ZP(e(ZP~Oa!QOl$ROr![Os![Ot![Ou![Ov![Ow![Oy!wO{!]O!p!_O!q!_O!r!_O!s!_O!u!`O#|!{O#}!zO$Y$YO%j!xO%u!yO%w!OO%}!|O&O!QO'x$QO(YYO~O]'hXa'SXd'hXl'SXl'hXr'SXr'hXs'SXs'hXt'SXt'hXu'SXu'hXv'SXv'hXw'SXw'hXy'SX{'SX!Z'hX!o'hX!p'SX!p'hX!q'SX!q'hX!r'SX!r'hX!s'SX!s'hX!u'SX!u'hX!x'hX#j'hX#|'SX#}'SX%b'hX%j'SX%u'SX%w'SX%}'SX&O'SX'x'SX'x'hX(]'hX(_'hX(`'hX~Oa!QOl$ROr![Os![Ot![Ou![Ov![Ow![Oy!wO{!]O!p!_O!q!_O!r!_O!s!_O!u!`O#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO'x$QO~Or![Os![Ot![Ou![Ov![Ow![O{!]O!p!_O!q!_O!r!_O!s!_O!u!`O](fXd(fXl(fX!Z(fX!x(fX#j(fX'x(fX(](fX(_(fX(`(fX~O(a$^O~P5rOPsO]dOdjOr![Os![Ot![Ou![Ov![Ow![O!ZiO!]!UO!^!TO!l!YO!x!aO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO(]aO(_fO(`eO(bXO)T!VO)U!WO~Oa$jOl$aO!y$kO'x$_O~P7aO(]$mO~O]$pO!Z$oO~Oa!ZOl8XOy!wO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO'x8OO~P7aOPsO]dOdjO!ZiO!]!UO!^!TO!l!YO!x!aO#f#OO#g#PO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO(]aO(_fO(`eO(bXO)T!VO)U!WO~Oa$jOl$aO#j$lO'x$_O~P:uO]${OdjOl$yO!Z$}O!x!aO#j$lO'x$_O(]$zO(_fO(`fO~Op%QO]'zX](jX!Q'zX!Z'zX!Z(jX!]'zX!^'zX!`'zX!b'zX!c'zX!e'zX!f'zX!g'zX!i'zX!j'zX'{'zX'}'zX(O'zX(W'zX(]'zX(^'zX(_'zX(`'zX(a'zX|'zX|(jX!Y'zX~O!k#{O(m#{O~P=bO!k'zX(m'zX~P=bOPsO]%VOa$jOl$aO!Z%YO![%]O!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(]%WO(`%XO(bXO(m%ZO)T!VO)U!WO~O!S}O'|%^O(m%aO](jX!Z(jX~O]'zX!Q'zX!Z'zX!]'zX!^'zX!`'zX!b'zX!c'zX!e'zX!f'zX!g'zX!i'zX!j'zX'{'zX'}'zX(O'zX(W'zX(]'zX(^'zX(_'zX(`'zX(a'zX!k'zX(m'zX|'zX!Y'zX~O](jX!Z(jX|(jX~PAuO]${OdjOl8_O!Z$}O!x!aO#j$lO'x8PO(]8cO(_8eO(`8eO~O'|%eO~OP%fO'uQO!['zX'|'zXQ'zX!h'zX~PAuO]${OdjOr![Os![Ot![Ou![Ov![Ow![O!Z$}O!p!_O!q!_O!r!_O!s!_O!u!`O!x!aO#j!bO%b!uO(]$zO(_fO(`fO~Ol%hO!o%mO'x$_O~PETO]${OdjOl%hO!Z$}O!x!aO#j!bO'x$_O(]$zO(_fO(`fO~O!S}O(a%qO(m%rO~O!Y%uO~P!QOa%wO%w!OO]%vXd%vXl%vXr%vXs%vXt%vXu%vXv%vXw%vX{%vX!Z%vX!p%vX!q%vX!r%vX!s%vX!u%vX!x%vX#j%vX'x%vX(]%vX(_%vX(`%vX(a%vX|%vX!Q%vX!S%vX!]%vX!^%vX!`%vX!b%vX!c%vX!e%vX!f%vX!g%vX!i%vX!j%vX'{%vX'}%vX(O%vX(W%vX(^%vX!k%vX(m%vXQ%vX!h%vX![%vX'|%vX!Y%vX}%vX#Q%vX#S%vX~Op%QOl(TX|(TXQ(TX!Q(TX!h(TX(W(TX(m(TX~P-UO!k#{O(m#{O]'zX!Q'zX!Z'zX!]'zX!^'zX!`'zX!b'zX!c'zX!e'zX!f'zX!g'zX!i'zX!j'zX'{'zX'}'zX(O'zX(W'zX(]'zX(^'zX(_'zX(`'zX(a'zX|'zX!['zX'|'zX!Y'zXQ'zX!h'zX~OPsO]%VOa$jOl$aO!Z%YO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(]%WO(`%WO(bXO)T!VO)U!WO~O]&QO!Z&PO(]%|O(_&RO(`&RO~O!S}O~P! iO](TXd(TXl(TXr(TXs(TXt(TXu(TXv(TXw(TX{(TX!Z(TX!p(TX!q(TX!r(TX!s(TX!u(TX!x(TX#j(TX'x(TX(](TX(_(TX(`(TX(a(TX|(TXQ(TX!Q(TX!h(TX(W(TX(m(TX~O]#pO~P!!RO]&VO~O'uQO](gXa(gXd(gXl(gXr(gXs(gXt(gXu(gXv(gXw(gXy(gX{(gX!Z(gX!o(gX!p(gX!q(gX!r(gX!s(gX!u(gX!x(gX#j(gX#|(gX#}(gX%b(gX%j(gX%u(gX%w(gX%}(gX&O(gX'x(gX(](gX(_(gX(`(gX~O]&XO~O]#pO~O]&^O!Z&_O!]&[O!k&[O#b&[O#c&[O#d&[O#e&[O#f&`O#g&`O(O&]O(m&[O~P4XOl8`O%Y&dO'x8QO~O]&eOw&gO~O]&eO~OPsO]%VOa$jOl$aO!S}O!Z%YO!]!UO!^!TO!l!YO#S!qO#f#OO#g#PO#j$lO$_!nO$`!oO$f!dO$k!eO$m!fO$n!gO$r!hO$t!iO$v!jO$x!kO$z!lO%T!pO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x7qO(]%WO(`%WO(aoO(bXO)T!VO)U!WO~O]&kO~O!S#yO(a&mO~PM{O(a&oO~O(a&pO~O'x&qO~Oa!QOl$ROr![Os![Ot![Ou![Ov![Ow![Oy!wO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO'x$QO~O'|&vO~O!S}O~O(a&yO~PM{O!S&{O'x&zO~O]'OO~O]${Oa!QOdjOr![Os![Ot![Ou![Ov![Ow![Oy!wO{!]O!Z$}O!p!_O!q!_O!r!_O!s!_O!u!`O!x!aO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO(]$zO(_fO(`fO~Ol8bOp'RO#j$lO'x8RO~P!-WO]'UOd%aXl%aX!Z%aX!x%aX#j%aX'x%aX(]%aX(_%aX(`%aX~Ol$RO{!]O}'_O!S'ZO'x$QO'|'YO~Ol$RO{!]O}'dO!S'ZO'x$QO'|'YO~Ol$ROy'iO!S'fO#}'iO'x$QO~Ol$RO{!]O}'mO!S'ZO'x$QO'|'YO~Oa!QOl$ROy!wO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO'x$QO~O]'pO~OPsOa$jOl$aO!Z%YO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(]%WO(`%WO(bXO)T!VO)U!WO~O]'rO(W'tO~P!2mO]#pO~P!1sOPsO]%VOa$jOl$aO!Z'xO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(]%WO(`%WO(bXO)T!VO)U!WO~OY'yO'uQO'x&zO~O&p'|O~OS(QOT'}O)X(PO~O]#pO't(TO~Q&xXX#XO'v#XO'w(VO~Od(`Ol([O'x(ZO~O!Q&]a!^&]a!`&]a!b&]a!c&]a!e&]a!f&]a!g&]a!i&]a!j&]a'{&]a(W&]a(]&]a(^&]a(_&]a(`&]a(a&]a!k&]a(m&]a|&]a![&]a'|&]a!Y&]aQ&]a!h&]a~OPsOa$jOl$aO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(bXO)T!VO)U!WO]&]a!Z&]a!]&]a'}&]a(O&]a~P!7dO!S#yO|'yP~PM{O]nX]#_XdnXlmXpnXp#_XrnXsnXtnXunXvnXwnX{nX!Q#_X!SnX!ZnX!Z#_X!]#_X!^#_X!`#_X!b#_X!c#_X!e#_X!f#_X!g#_X!i#_X!j#_X!kmX!pnX!qnX!rnX!snX!unX!xnX#jnX'xnX'{#_X'}#_X(O#_X(W#_X(]nX(]#_X(^#_X(_nX(_#_X(`nX(`#_X(mmX|nX|#_X~O(anX(a#_X!Y#_X~P!:zO](qO!Z(rO!](oO!k(oO#b(oO#c(oO#d(oO#e(oO#f(sO#g(sO(O(pO(m(oO~P4XOPsO]%VOa$jOl$aO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(]%WO(`%WO(bXO)T!VO)U!WO~O!Z(xO~P!?aOd({O#a(|O(P#qO~O!S#yO!Z)OO'})PO!Y(oP~P!?aO!S#yO~PM{O(d)WO~Ol)XO]!VX!Q!VX(W!VX(e!VX~O])ZO!Q)[O(W(ZX(e(ZX~O(W)`O(e)_O~O]iXdiXlgXpiXriXsiXtiXuiXviXwiX{iX!ZiX!piX!qiX!riX!siX!uiX!xiX#jiX'xiX(]iX(_iX(`iX!SiX!QiX(WiX(miX|iX~O(aiX}iX'|iX!]iX!^iX!`iX!biX!ciX!eiX!fiX!giX!iiX!jiX'{iX'}iX(OiX(^iX!kiX![iXQiX!hiX!YiX#QiX#SiX~P!BsO(P)aO~Ol)bO~O](TXd(TXr(TXs(TXt(TXu(TXv(TXw(TX{(TX!Z(TX!p(TX!q(TX!r(TX!s(TX!u(TX!x(TX#j(TX'x(TX(](TX(_(TX(`(TX(a(TX!Q(TX!S(TX!](TX!^(TX!`(TX!b(TX!c(TX!e(TX!f(TX!g(TX!i(TX!j(TX'{(TX'}(TX(O(TX(W(TX(^(TX!k(TX(m(TX|(TX![(TX'|(TXQ(TX!h(TX!Y(TX}(TX#Q(TX#S(TX~Ol)bO~P!FgO(a)cO~P5rOp%QOl(TX~P!FgOr![Os![Ot![Ou![Ov![Ow![O{!]O!p!_O!q!_O!r!_O!s!_O!u!`O](fad(fal(fa!Z(fa!x(fa#j(fa'x(fa(](fa(_(fa(`(fa|(fa!Q(fa(W(fa(m(faQ(fa!h(fa!S(fa'|(fa(a(fa~O]ZXlgXpZXpiX!QZX!SiX!ZZX!]ZX!^ZX!`ZX!bZX!cZX!eZX!fZX!gZX!iZX!jZX!kZX'{ZX'}ZX(OZX(WZX(]ZX(^ZX(_ZX(`ZX(aZX(mZX|ZX~O![ZX'|ZX!YZXQZX!hZX~P!LbO]#pO!Z#aO!]#nO'}#`O(O#`O~O!Q&Sa!^&Sa!`&Sa!b&Sa!c&Sa!e&Sa!f&Sa!g&Sa!i&Sa!j&Sa!k&Sa'{&Sa(W&Sa(]&Sa(^&Sa(_&Sa(`&Sa(a&Sa(m&Sa|&Sa![&Sa'|&Sa!Y&SaQ&Sa!h&Sa~P!NrOd#tO#a)hO&f#vO&i#wO(P7sO~Ol)iO~Ol)iO!S#yO~Ol)iO!k#{O(m#{O~Or![Os![Ot![Ou![Ov![Ow![O~P<pOr![Os![Ot![Ou![Ov![Ow![O!y$kO~P<pO]$pO!Z$oO|!}a!Q!}a!S!}a(a!}a(m!}a'|!}aQ!}a!h!}a~Op%QO!S#yO~O]&^O!Z&_O!]&[O!k&[O#b&[O#c&[O#d&[O#e&[O#f&`O#g&`O(O&]O(m&[O~Or![Os![Ot![Ou![Ov![Ow![O})rO!u!`O#Q)tO#S)uO(O)qO~O]#Oa!S#Oa!Z#Oa'|#Oa(m#Oa|#Oa!Q#Oa(a#OaQ#Oa!h#Oa~P#&dOPsO]%VOa$jOl$aOr![Os![Ot![Ou![Ov![Ow![O!Z%YO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(`%WO(bXO)T!VO)U!WO~O![)xO(])yO~P#'{O(W)|O(YYO|(iP~P4XO|*OO!Q#^O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO!S#yO](TXr(TXs(TXt(TXu(TXv(TXw(TX|(TX!Z(TX(](TX(_(TX(`(TX~Ol8oO~P#+jO]$pO|*QO!Z$oO~O|*OO~Or![Os![Ot![Ou![Ov![Ow![O|qXQqX!QqX!hqX(WqX(aqX~P! iO|*TO~O]$pO!Z$oO|#]a!Q#]a!S#]a(a#]a(m#]a'|#]aQ#]a!h#]a~Od#tO#a)hO(P7sO~Op%QO](jX!Z(jX!Q(jX!S(jX(a(jX(m(jX|(jX'|(jXQ(jX!h(jX~Op%QO~OPsO]%VOa!ZOl8YOr![Os![Ot![Ou![Ov![Ow![Oy!wO!Z%YO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x8SO(]%WO(`%WO(bXO)T!VO)U!WO~OQ(QP!h(QP~P#/rO!Q*ZO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO![)VX~P!NrOp%QO!Q*]O!k#{O(m#{O]'zX!Z'zX!['zX![(nX!]'zX!^'zX!`'zX!b'zX!c'zX!e'zX!f'zX!g'zX!i'zX!j'zX'{'zX'}'zX(O'zX(W'zX(]'zX(^'zX(_'zX(`'zX~O!Q'zX~P#3oOp%QO!['zX'|'zXQ'zX!h'zX~PAuO![*_O~OPsO]%VOa!ZOl8XOr![Os![Ot![Ou![Ov![Ow![Oy!wO!Z%YO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x8OO(]%WO(`%WO(bXO)T!VO)U!WO~O!Q*aO![*`O~PM{O!Q*aO![*`O~Ol9lO'x8nO~O!S}O(m%aO~O#g*gO$`*fO~O]*hO!Q*lO!S*iO!Z$oO(m*jO(a(sX~O!Q*lO(a(sX~O(a*oO~OP%fO'uQO]%^a!Q%^a!Z%^a!]%^a!^%^a!`%^a!b%^a!c%^a!e%^a!f%^a!g%^a!i%^a!j%^a'{%^a'}%^a(O%^a(W%^a(]%^a(^%^a(_%^a(`%^a(a%^a!k%^a(m%^a|%^a![%^a'|%^a!Y%^aQ%^a!h%^a~Od#tO#a#uO(P7sO~Ol7{O~O!S}O(a*vO(m*wO~OPsO]%VOa$jOl$aO!Z%YO!]!UO!^!TO!l!YO#f#OO#g*yO#j$lO$`*fO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(]%WO(`%WO(bXO)T!VO)U!WO~O!Y*zO~P!QO]#pO!Z#aO'}#`O(O#`O!Q&Ya!]&Ya!^&Ya!`&Ya!b&Ya!c&Ya!e&Ya!f&Ya!g&Ya!i&Ya!j&Ya'{&Ya(W&Ya(]&Ya(^&Ya(_&Ya(`&Ya(a&Ya!k&Ya(m&Ya|&Ya![&Ya'|&Ya!Y&YaQ&Ya!h&Ya~Op%QO~PK{O]#pO!Z#aO!]#nO'}#`O(O#`O~P!7dOr![Os![Ot![Ou![Ov![Ow![O|#UX!S#UX(a#UX(m#UXQ#UX!Q#UX!h#UX(W#UX~P! iOr![Os![Ot![Ou![Ov![Ow![O#Q)tO#S)uO(O9nO~O]#VX!S#VX!Z#VX|#VX(a#VX(m#VX!Q#VXQ#VX!h#VX(W#VX~P#B`O]$pO!Z+SO~O![+VO(]+WO~P#'{O]&QO!Z&PO(W)|O(YYO(]%|O(_&RO(`&RO|(iP~P4XO|#YX!S#YX(a#YX(m#YXQ#YX!Q#YX!h#YX(W#YX~P! iO!S}O](lX!Z(lX~O!S&{O$Y!vO(YYO~P4XO|(fX!Q(fX(W(fX(m(fXQ(fX!h(fX!S(fX'|(fX(a(fX~P5rO]#ia!Q#ia!]#ia!^#ia!`#ia!b#ia!c#ia!e#ia!f#ia!g#ia!i#ia!j#ia'{#ia'}#ia(O#ia(W#ia(^#ia(_#ia(`#ia(a#ia!k#ia(m#ia|#ia![#ia!S#ia'|#ia!Y#iaQ#ia!h#ia~O(]+`O!Z#ia~P#FhO|+`O~O![+`O~O!Z+aO(]#ia~P#FhOp%QO(m+cO~O(a+dO~Ol8`O'x8QO~OPsO]%VOa!ZOl8ZOr![Os![Ot![Ou![Ov![Ow![Oy!wO{!]O!Z%YO!]!UO!^!TO!l!YO!p!_O!q!_O!r!_O!s!_O!u!`O#f#OO#g#PO#j$lO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO(YYO(]%WO(`%WO(aoO(bXO)T!VO)U!WO~O'x8UO~P#IjO$n+oO~OPsO]%VOa!ZOl8ZOr![Os![Ot![Ou![Ov![Ow![Oy!wO{!]O!Z%YO!]!UO!^!TO!l!YO!p!_O!q!_O!r!_O!s!_O!u!`O#f#OO#g#PO#j$lO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x8OO(YYO(]%WO(`%WO(a+sO(bXO)T!VO)U!WO~O!Q#^O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a+uO~P!NrO(a+uO~O(a+vO~O]+|O!x!aO'x+xO(]+yO~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O'|,PO(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO!S}O$f!dO$k!eO$m!fO$n!gO$r,TO$t!iO$v!jO$x!kO$z!lO$|!mO'x7rOd$^a!o$^a!x$^a#S$^a#y$^a$S$^a$Y$^a$_$^a$`$^a%T$^a%Y$^a%]$^a%b$^a'q$^a(_$^a!Y$^a$i$^a~P#IjO%V,WO~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a,XO~P!NrO!Y,YO~P!QO!S&{O~O](TXd(TXr(TXs(TXt(TXu(TXv(TXw(TX{(TX!Z(TX!p(TX!q(TX!r(TX!s(TX!u(TX!x(TX#j(TX'x(TX(](TX(_(TX(`(TX~Ol8rO~P$(WO]$pO!Z$oO(a,^O~Oa!QOl$ROr![Os![Ot![Ou![Ov![Ow![Oy!wO{!]O!p!_O!q!_O!r!_O!s!_O!u!`O#y,dO#|,bO#},cO%j!xO%u!yO%w!OO%}!|O&O!QO'x$QO(YYO~OQ(pP!h(pP~P$)}Ol8hO!o,gO#j!bO#y,mO$S,kO$W,lO$Y!vO%b!uO'x8WO(YYO~P!-WO](UXd(UXr(UXs(UXt(UXu(UXv(UXw(UX{(UX}(UX!S(UX!Z(UX!p(UX!q(UX!r(UX!s(UX!u(UX!x(UX#j(UX'x(UX'|(UX(](UX(_(UX(`(UX(a(UX|(UX!Q(UX(W(UX!](UX!^(UX!`(UX!b(UX!c(UX!e(UX!f(UX!g(UX!i(UX!j(UX'{(UX'}(UX(O(UX(^(UX!k(UX(m(UXQ(UX!h(UX![(UX!Y(UX#Q(UX#S(UX~Ol)bO~P$,lOp%QOl(UX~P$,lOl$RO!P,sO'x$QO~Ol8iO!P-QO!Y-OO!o-PO#j!bO#y,mO$S!cO$W,lO$|!mO%]!sO%b!uO'x8VO(YYO~P!-WO}-TO!S'ZO'|'YO]xadxalxarxasxatxauxavxawxa{xa!Zxa!pxa!qxa!rxa!sxa!uxa!xxa#jxa'xxa(]xa(_xa(`xa~O(axa|xa!Qxa!]xa!^xa!`xa!bxa!cxa!exa!fxa!gxa!ixa!jxa'{xa'}xa(Oxa(Wxa(^xa!kxa(mxaQxa!hxa![xa!Yxa#Qxa#Sxa~P$1eO!S'ZO~O!S'ZO'|'YO~Ol$RO}-TO!S'ZO'x$QO'|'YO~O}-XO!S'ZO'|'YO]%sad%sal%sar%sas%sat%sau%sav%saw%sa{%sa!Z%sa!p%sa!q%sa!r%sa!s%sa!u%sa!x%sa#j%sa'x%sa(]%sa(_%sa(`%sa~O(a%sa|%sa!Q%sa!]%sa!^%sa!`%sa!b%sa!c%sa!e%sa!f%sa!g%sa!i%sa!j%sa'{%sa'}%sa(O%sa(W%sa(^%sa!k%sa(m%saQ%sa!h%sa![%sa!Y%sa#Q%sa#S%sa~P$5jOl$RO}-XO!S'ZO'x$QO'|'YO~O'x&zO!Y)OP~O!S'fO'|-^O]%tad%tal%tar%tas%tat%tau%tav%taw%ta{%ta!Z%ta!p%ta!q%ta!r%ta!s%ta!u%ta!x%ta#j%ta'x%ta(]%ta(_%ta(`%ta(a%ta|%ta!Q%ta!]%ta!^%ta!`%ta!b%ta!c%ta!e%ta!f%ta!g%ta!i%ta!j%ta'{%ta'}%ta(O%ta(W%ta(^%ta!k%ta(m%taQ%ta!h%ta![%ta!Y%ta}%ta#Q%ta#S%ta~Ol$RO!S'fO'x$QO~O}-dO!S'ZO'|'YO]%zad%zal%zar%zas%zat%zau%zav%zaw%za{%za!Z%za!p%za!q%za!r%za!s%za!u%za!x%za#j%za'x%za(]%za(_%za(`%za~O(a%za|%za!Q%za!]%za!^%za!`%za!b%za!c%za!e%za!f%za!g%za!i%za!j%za'{%za'}%za(O%za(W%za(^%za!k%za(m%zaQ%za!h%za![%za!Y%za#Q%za#S%za~P$=WOl$RO}-dO!S'ZO'x$QO'|'YO~O!^#eO!`#fO!j#mO(]#bO!Q&_a!b&_a!c&_a!e&_a!f&_a!g&_a!i&_a'{&_a(W&_a(^&_a(_&_a(`&_a(a&_a!k&_a(m&_a|&_a![&_a'|&_a!Y&_aQ&_a!h&_a~P!NrO]-hO~O]#pO!S#yO!Z-iO!Q&ea!]&ea!^&ea!`&ea!b&ea!c&ea!e&ea!f&ea!g&ea!i&ea!j&ea'{&ea'}&ea(O&ea(W&ea(]&ea(^&ea(_&ea(`&ea(a&ea!k&ea(m&ea|&ea![&ea'|&ea!Y&eaQ&ea!h&ea~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q&ha(a&ha!k&ha(m&ha|&ha![&ha'|&ha!Y&haQ&ha!h&ha~P!NrOPsO]%VOa$jOl$aO!Z%YO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(]%WO(`%XO(bXO(m%ZO)T!VO)U!WO~O![-lO~P$FlOS(QOT'}O]#pO)X(PO~O]-oO&p-pO)X-mO~OS-tOT'}O)X-sO~O]#pO~Q&xa!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O'|-vO(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO!Q#^O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a$di|$di~P!NrO]cXlgXpcXpiX!QcX!ZcX!]cX!^cX!`cX!bcX!ccX!ecX!fcX!gcX!icX!jcX!kcX'{cX'}cX(OcX(WcX(]cX(^cX(_cX(`cX(acX(mcX|cX![cX'|cX!ScX!YcXQcX!hcX~Od-xO#a)hO(P-wO~Ol-yO~Op%QO]bi!Qbi!Zbi!]bi!^bi!`bi!bbi!cbi!ebi!fbi!gbi!ibi!jbi!kbi'{bi'}bi(Obi(Wbi(]bi(^bi(_bi(`bi(abi(mbi|bi![bi'|bi!YbiQbi!hbi~O![-{O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO!`#fO(]#bO!Q&Ui!^&Ui!b&Ui!c&Ui!e&Ui!f&Ui!g&Ui!i&Ui!j&Ui'{&Ui(W&Ui(^&Ui(_&Ui(`&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!Q&Ui!^&Ui!`&Ui!b&Ui!c&Ui!e&Ui!f&Ui!g&Ui!i&Ui!j&Ui'{&Ui(W&Ui(]&Ui(^&Ui(_&Ui(`&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO(]#bO(`#dO!Q&Ui'{&Ui(W&Ui(^&Ui(_&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!^#eO!`#fO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO(]#bO(`#dO!Q&Ui!b&Ui'{&Ui(W&Ui(^&Ui(_&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!^#eO!`#fO!e#kO!f#lO!g#lO!i#lO!j#mO(]#bO(`#dO!Q&Ui!b&Ui!c&Ui'{&Ui(W&Ui(^&Ui(_&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!^#eO!`#fO!e#kO!f#lO!g#lO!i#lO!j#mO(]#bO!Q&Ui!b&Ui!c&Ui'{&Ui(W&Ui(^&Ui(_&Ui(`&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!^#eO!`#fO!f#lO!g#lO!i#lO!j#mO(]#bO!Q&Ui!b&Ui!c&Ui!e&Ui'{&Ui(W&Ui(^&Ui(_&Ui(`&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!^#eO!`#fO!j#mO(]#bO!Q&Ui!b&Ui!c&Ui!e&Ui!f&Ui!g&Ui!i&Ui'{&Ui(W&Ui(^&Ui(_&Ui(`&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!^#eO!`#fO(]#bO!Q&Ui!b&Ui!c&Ui!e&Ui!f&Ui!g&Ui!i&Ui!j&Ui'{&Ui(W&Ui(^&Ui(_&Ui(`&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO(]#bO(^#cO(_#cO(`#dO!Q&Ui'{&Ui(W&Ui(a&Ui!k&Ui(m&Ui|&Ui![&Ui'|&Ui!Y&UiQ&Ui!h&Ui~P!NrO!Q-|O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO|'yX~P!NrO!Q-|O|'yX~O|.OO~O]#`ap#`a!Q#`a!]#`a!^#`a!`#`a!b#`a!c#`a!e#`a!f#`a!g#`a!i#`a!j#`a'{#`a'}#`a(O#`a(W#`a(^#`a(_#`a(`#`a(a#`a!k#`a(m#`a|#`a![#`a!S#`a'|#`a!Y#`aQ#`a!h#`a~O(].PO!Z#`a~P%6YO|.PO~O![.PO~O!Z.QO(]#`a~P%6YO]#pO!S#yO!Q&ei!]&ei!^&ei!`&ei!b&ei!c&ei!e&ei!f&ei!g&ei!i&ei!j&ei'{&ei'}&ei(O&ei(W&ei(]&ei(^&ei(_&ei(`&ei(a&ei!k&ei(m&ei|&ei![&ei'|&ei!Y&eiQ&ei!h&ei~O!Z-iO~P%8xO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q&hi(a&hi!k&hi(m&hi|&hi![&hi'|&hi!Y&hiQ&hi!h&hi~P!NrO![.VO~P$FlO!Q.XO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Y(oX~P!NrO'x.[O~O!Z.^O'})PO(m.`O~O!Q.XO!Y(oX~O!Y.aO~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO(W#oO(]#bO(^#cO(_#cO(`#dO!Q_i'{_i(a_i!k_i(m_i|_i![_i'|_i!Y_iQ_i!h_i~P!NrO!W.bO~Ol)XO]!Va!Q!Va(W!Va(e!Va~OP.jO].iOl.jO!Q.jO!S.gO!W.jO!Z.hO!].jO!^.jO!`.jO!b.jO!c.jO!e.jO!f.jO!g.jO!i.jO!j.jO!k.jO!l.jO'uQO'|.jO'}.jO(O.jO(W.jO(].dO(^.eO(_.eO(`.fO(a.jO(bXO~O|.mO~P%@zO!W#}O~O!Q)[O(W(Za(e(Za~O(e.qO~O]nXdnXlmXpnXrnXsnXtnXunXvnXwnX{nX!ZnX!pnX!qnX!rnX!snX!unX!xnX#jnX'xnX(]nX(_nX(`nX!SnX!QnX(WnX|nXQnX!hnX~O(anX}nX'|nX!]nX!^nX!`nX!bnX!cnX!enX!fnX!gnX!inX!jnX'{nX'}nX(OnX(^nX!knX(mnX![nX!YnX#QnX#SnX~P%ChO(a.sO~Or![Os![Ot![Ou![Ov![Ow![O{!]O!p!_O!q!_O!r!_O!s!_O!u!`O~O](fid(fil(fi!Z(fi!x(fi#j(fi'x(fi(](fi(_(fi(`(fi|(fi!Q(fi(W(fi(m(fiQ(fi!h(fi!S(fi'|(fi(a(fi~P%GVO](qO!Z(rO!](oO!k(oO#b(oO#c(oO#d(oO#e(oO#f(sO#g(sO(O(pO(m(oO~Od({O#a)hO(P7sO~O]$pO!Z$oO|!}i!Q!}i!S!}i(a!}i(m!}i'|!}iQ!}i!h!}i~O]#Oi!S#Oi!Z#Oi'|#Oi(m#Oi|#Oi!Q#Oi(a#OiQ#Oi!h#Oi~P#&dOr![Os![Ot![Ou![Ov![Ow![O})rO#Q)tO#S)uO(O)qO~O]#Oi!S#Oi!Z#Oi'|#Oi(m#Oi|#Oi!Q#Oi(a#OiQ#Oi!h#Oi~P%KuO].|Or#PXs#PXt#PXu#PXv#PXw#PX}#PX!S#PX!Z#PX#Q#PX#S#PX'|#PX(O#PX(m#PX|#PX!Q#PX(a#PXQ#PX!h#PX(W#PX~O].}O~O![/OO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO![/OO(]/QO~P#'{O![/OO~PM{O]/VOdjOl8_O!Z/UO!x!aO#j$lO'x$_O(W/ZO(]/SO~O(_/WO(`/WO(m/YO|!|X!Q!|XQ!|X!h!|X~P&![O!Q/]O|(iX~O|/_O~Or![Os![Ot![Ou![Ov![Ow![O|qaQqa!Qqa!hqa(Wqa(aqa~P! iO]$pO!Z+SO|qaQqa!Qqa!hqa(Wqa(aqa~O!Q*]O![(nX~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dOQ)PX!Q)PX!h)PX~P!NrO(W/dOQ(RX!Q(RX!h(RX~O!Q/eOQ(QX!h(QX~OQ/gO!h/gO~O!Q*ZO![)Va~O!Q*]O![(na~O]#pO!S#yO~O!Q/nO!S(zX(m(zX~O(a/pO~O(a/qO~OPsO]%VOa!ZOl8YOy!wO!S#yO!Z%YO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x8TO(W)|O(YYO(]%WO(`%WO(bXO)T!VO)U!WO|'yP|(iP~P%GVOPsO]dOa!ZOdjOlTOr![Os![Ot![Ou![Ov![Ow![Oy!wO{!]O!]!UO!^!TO!l!YO!ouO!p!^O!q!_O!r!_O!s!_O!u!`O!x!aO#S!qO#f#OO#g#PO#j!bO#y!tO#|!{O#}!zO$S!cO$Y!vO$_!nO$`!oO$f!dO$k!eO$m!fO$n!gO$r!hO$t!iO$v!jO$x!kO$z!lO$|!mO%T!pO%Y!rO%]!sO%b!uO%j!xO%u!yO%w!OO%}!|O&O!QO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'xRO(YYO(]aO(_fO(`eO(aoO(bXO)T!VO)U!WO~O!S*iO!Y%uO!Z/sO'})PO~P&*tO!Q*lO(a(sa~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a/}O~P!NrO(a/qO~P!4iOr![Os![Ot![Ou![Ov![Ow![O|#Ua!S#Ua(a#Ua(m#Ua!Q#UaQ#Ua!h#Ua(W#Ua~P! iO]$pO!Z+SO|#Ua!S#Ua(a#Ua(m#Ua!Q#UaQ#Ua!h#Ua~O(W#Ua~P&2UO]#Va!S#Va!Z#Va|#Va(a#Va(m#Va!Q#VaQ#Va!h#Va(W#Va~P#B`O![0VO(]0WO~P#'{O![0VO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO![0VO~PM{O]$pO|0XO!Z+SO~O]$pO!Z+SO|#Ya!S#Ya(a#Ya(m#Ya!Q#YaQ#Ya!h#Ya~O(W#Ya~P&5bO|0YO~O|0ZO~O![0[O~O]$pO!Z+SO!S%hi(a%hi(m%hi~O(a0^O~O|0_O~P+WO|0_O(a#_O~O|0_O~O$i0dOP$ei]$eia$eid$eil$eir$eis$eit$eiu$eiv$eiw$eiy$ei{$ei!S$ei!Z$ei!]$ei!^$ei!l$ei!o$ei!p$ei!q$ei!r$ei!s$ei!u$ei!x$ei#S$ei#f$ei#g$ei#j$ei#y$ei#|$ei#}$ei$S$ei$Y$ei$_$ei$`$ei$f$ei$k$ei$m$ei$n$ei$r$ei$t$ei$v$ei$x$ei$z$ei$|$ei%T$ei%Y$ei%]$ei%b$ei%j$ei%u$ei%w$ei%}$ei&O$ei&Z$ei&[$ei&`$ei&d$ei&m$ei&n$ei'q$ei'u$ei'x$ei(Y$ei(]$ei(_$ei(`$ei(a$ei(b$ei)T$ei)U$ei!Y$ei~O]0fO~O!Q#^O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a0hO~P!NrO(a0kO~PM{O(a0hO~O]+|Or![Os![Ot![Ou![Ov![Ow![O!x!aO!y$kO'x+xO(]+yO~O(]0pO~O]$pO!Q0sO!Z0rO(a(wX~O(a0vO~O!S}O$f!dO$k!eO$m!fO$n!gO$r,TO$t!iO$v!jO$x!kO$z!lO$|!mO'x7rOd$^i!o$^i!x$^i#S$^i#y$^i$S$^i$Y$^i$_$^i$`$^i%T$^i%Y$^i%]$^i%b$^i'q$^i(_$^i!Y$^i$i$^i~P#IjO]0zO~O%V,WOP%Si]%Sia%Sid%Sil%Sir%Sis%Sit%Siu%Siv%Siw%Siy%Si{%Si!S%Si!Z%Si!]%Si!^%Si!l%Si!o%Si!p%Si!q%Si!r%Si!s%Si!u%Si!x%Si#S%Si#f%Si#g%Si#j%Si#y%Si#|%Si#}%Si$S%Si$Y%Si$_%Si$`%Si$f%Si$k%Si$m%Si$n%Si$r%Si$t%Si$v%Si$x%Si$z%Si$|%Si%T%Si%Y%Si%]%Si%b%Si%j%Si%u%Si%w%Si%}%Si&O%Si&Z%Si&[%Si&`%Si&d%Si&m%Si&n%Si'q%Si'u%Si'x%Si(Y%Si(]%Si(_%Si(`%Si(a%Si(b%Si)T%Si)U%Si!Y%Si$i%Si~O]$pO~O!Y0}O~P!QO|1OO!Q1PO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO!Q1QOQ(pX!h(pX~OQ1SO!h1SO~O(W1VO(m1UOQ#{X!Q#{X!h#{X~P!1sO(W1VO(m1UOQ#{X!Q#{X!h#{X~P!1_Op'RO~O]$pO!Z$oO(a1YO~Ol7}O(a(TX~P$(WO'x+xO~Oa!QOl$ROy1aO#|!{O#}1`O$Y!vO%j1bO%u!yO%w!OO%}!|O&O!QO'x$QO(YYO~P%GVO|1cO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO]$pO!S}O!Z$oO~O!Q1dO(W1fO!S(VX~Ol$RO'x$QO~O!o1iO(YYO~P4XO(a1jO~PAdO]1nOl([O!S#yO!x!aO#j$lO'x(ZO'|1rO(]1kO(_1oO(`1oO~O(a1sO(m1uO~P&LlOl8iO!P-QO!Y1xO!o-PO#j!bO#y,mO$S!cO$W,lO$|!mO%]!sO%b!uO'x8VO(YYO~P!-WOl8iO#j!bO'x8VO~P!-WO'|1yO~O}1|O!S'ZO'|'YO]xidxilxirxisxitxiuxivxiwxi{xi!Zxi!pxi!qxi!rxi!sxi!uxi!xxi#jxi'xxi(]xi(_xi(`xi(axi|xi!Qxi!]xi!^xi!`xi!bxi!cxi!exi!fxi!gxi!ixi!jxi'{xi'}xi(Oxi(Wxi(^xi!kxi(mxiQxi!hxi![xi!Yxi#Qxi#Sxi~O}2PO!S'ZO'|'YO]%sid%sil%sir%sis%sit%siu%siv%siw%si{%si!Z%si!p%si!q%si!r%si!s%si!u%si!x%si#j%si'x%si(]%si(_%si(`%si(a%si|%si!Q%si!]%si!^%si!`%si!b%si!c%si!e%si!f%si!g%si!i%si!j%si'{%si'}%si(O%si(W%si(^%si!k%si(m%siQ%si!h%si![%si!Y%si#Q%si#S%si~O(m2QO!Q%yX!Y%yX~O!Q2RO!Y)OX~O!Y2TO~Oa2VOl$RO%w!OO'x$QO~O!S'fO]%tid%til%tir%tis%tit%tiu%tiv%tiw%ti{%ti!Z%ti!p%ti!q%ti!r%ti!s%ti!u%ti!x%ti#j%ti'x%ti(]%ti(_%ti(`%ti(a%ti|%ti!Q%ti!]%ti!^%ti!`%ti!b%ti!c%ti!e%ti!f%ti!g%ti!i%ti!j%ti'{%ti'}%ti(O%ti(W%ti(^%ti!k%ti(m%tiQ%ti!h%ti![%ti!Y%ti}%ti#Q%ti#S%ti~O'|%ti~P'(cO'|-^O~P'(cO}2[O!S'ZO'|'YO]%zid%zil%zir%zis%zit%ziu%ziv%ziw%zi{%zi!Z%zi!p%zi!q%zi!r%zi!s%zi!u%zi!x%zi#j%zi'x%zi(]%zi(_%zi(`%zi(a%zi|%zi!Q%zi!]%zi!^%zi!`%zi!b%zi!c%zi!e%zi!f%zi!g%zi!i%zi!j%zi'{%zi'}%zi(O%zi(W%zi(^%zi!k%zi(m%ziQ%zi!h%zi![%zi!Y%zi#Q%zi#S%zi~O|2]O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO|2^O~O!Z&ei~P%8xOPsOa$jOl$aO!]!UO!^!TO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(bXO)T!VO)U!WO]&ka!S&ka!Z&ka(]&ka(_&ka(`&ka~O'x&zO(W2cO|)ZP~O)X2bO~O&p2eO)X2bO~O)X2fO~OlmXpnXp&RX~Od2hO#a)hO(P-wO~O!Q-|O|'ya~O![2lO~O]$pO!Z+SO!S%hq(a%hq(m%hq~O]#pO!S#yO!Q&eq!]&eq!^&eq!`&eq!b&eq!c&eq!e&eq!f&eq!g&eq!i&eq!j&eq'{&eq'}&eq(O&eq(W&eq(]&eq(^&eq(_&eq(`&eq(a&eq!k&eq(m&eq|&eq![&eq'|&eq!Y&eqQ&eq!h&eq~O!Z&eq~P'4]O!Z-iO~P'4]O!S#yO!Z)OO'})PO!Q'`X!Y'`X~P!?aO!Q.XO!Y(oa~O!Q*ZO![2tO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO!Y2xO~P%@zO![2xO~P%@zO|2xO~P%@zO|2}O~P%@zO]3OO!Q'Ra(W'Ra(e'Ra~O!Q)[O(W(Zi(e(Zi~O]$pO!Z$oO|!}q!Q!}q!S!}q(a!}q(m!}q'|!}qQ!}q!h!}q~O]#Oq!S#Oq!Z#Oq'|#Oq(m#Oq|#Oq!Q#Oq(a#OqQ#Oq!h#Oq~P%KuO]&QO!Z&PO!S#Ta(m#Ta|#Ta!Q#Ta(a#TaQ#Ta!h#Ta~O(]8lO(_8mO(`8mOr#Tas#Tat#Tau#Tav#Taw#Ta}#Ta#Q#Ta#S#Ta'|#Ta(O#Ta~P':|O|3WO~PM{O|(kP~P!+aO![3ZO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO![3ZO~PM{O]/VOdjOl$yO!Z/UO!x!aO#j$lO'x$_O(]9TO(_3]O(`3]O~O|!|a!Q!|aQ!|a!h!|a~P'>WO]/VOdjOr![Os![Ot![Ou![Ov![Ow![O!Z/UO!x!aO!y$kO#j$lO'x$_O|#UX!Q#UXQ#UX!h#UX~Ol8_O(]/SO(_9XO(`9XO~P'?YO]$pO|!|a!Q!|aQ!|a!h!|a~O!Z+SO~P'@qO]/VOa!QOdjOl8aOy!wO!Z/UO!x!aO#j$lO#|!{O#}!zO%j!xO%u!yO%w!OO%}!|O&O!QO'x8RO(W)|O(YYO(]9TO(_3]O(`3]O|(iP~P%GVO(_9XO(`9XO|#YX!Q#YXQ#YX!h#YX~P&![O!Z$oO(m3aO~P'@qO'x&zO|#nX!Q#nXQ#nX!h#nX~O(W3dO(YYO~P4XO!Q/]O|(ia~Or![Os![Ot![Ou![Ov![Ow![O|qiQqi!Qqi!hqi(Wqi(aqi~P! iO]$pO!Z+SO|qiQqi!Qqi!hqi(Wqi(aqi~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q&^q(a&^q!k&^q(m&^q|&^q![&^q'|&^q!Y&^qQ&^q!h&^q~P!NrO!Q/eOQ(Qa!h(Qa~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q'ma!['ma~P!NrO![3kO~O(W3lO!Q%da!S%da(m%da~O!Q/nO!S(za(m(za~O!Q3oO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a#_O!Y(oX~P!NrO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q$Ui(a$Ui~P!NrO]*hO!S#yO!Z$oO(m*jO!Q'ba(a'ba~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a3qO~P!NrO]$pO!Z+SO|#Ui!S#Ui(a#Ui(m#Ui!Q#UiQ#Ui!h#Ui~O(W#Ui~P'MfO]#Vi!S#Vi!Z#Vi|#Vi(a#Vi(m#Vi!Q#ViQ#Vi!h#Vi(W#Vi~P#B`O![3sO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO![3sO(]3uO~P#'{O![3sO~PM{O(a3vO~O]*hO!Q*lO!S#yO!Z$oO(a(sX~O(m3wO~P(!lO|3yO!Q#^O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO|3yO~O$i3{OP$eq]$eqa$eqd$eql$eqr$eqs$eqt$equ$eqv$eqw$eqy$eq{$eq!S$eq!Z$eq!]$eq!^$eq!l$eq!o$eq!p$eq!q$eq!r$eq!s$eq!u$eq!x$eq#S$eq#f$eq#g$eq#j$eq#y$eq#|$eq#}$eq$S$eq$Y$eq$_$eq$`$eq$f$eq$k$eq$m$eq$n$eq$r$eq$t$eq$v$eq$x$eq$z$eq$|$eq%T$eq%Y$eq%]$eq%b$eq%j$eq%u$eq%w$eq%}$eq&O$eq&Z$eq&[$eq&`$eq&d$eq&m$eq&n$eq'q$eq'u$eq'x$eq(Y$eq(]$eq(_$eq(`$eq(a$eq(b$eq)T$eq)U$eq!Y$eq~O(a3|O~O(a4OO~PM{O'|4PO(m*jO~P(!lO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a4OO~P!NrO|4RO~PM{O(a4TO~O]+|Or![Os![Ot![Ou![Ov![Ow![O!x!aO'x+xO(]+yO~O]$pO!Z0rO!Q$}a(a$}a|$}a~O![4ZO(]4[O~P#'{O!Q0sO(a(wa~O]$pO|4_O!Z0rO~O!S}O$f!dO$k!eO$m!fO$n!gO$r,TO$t!iO$v!jO$x!kO$z!lO$|!mO'x7rOd$^q!o$^q!x$^q#S$^q#y$^q$S$^q$Y$^q$_$^q$`$^q%T$^q%Y$^q%]$^q%b$^q'q$^q(_$^q!Y$^q$i$^q~P#IjO(a4aO~OP4bO'uQO~O!Q1QOQ(pa!h(pa~Op%QO(m4fOQ#{al(TX!Q#{a!h#{a(W(TX~P$(WO'x+xOQ$Pa!Q$Pa!h$Pa~Op%QO(m4fOQ#{a](UXd(UXl(UXr(UXs(UXt(UXu(UXv(UXw(UX{(UX}(UX!Q#{a!S(UX!Z(UX!h#{a!p(UX!q(UX!r(UX!s(UX!u(UX!x(UX#j(UX'x(UX'|(UX(W(UX(](UX(_(UX(`(UX~O#|4iO#}4iO~Ol)bO(a(UX~P$(WOp%QOl(TX(a(UX~P$(WO(a4kO~Ol$RO!P4pO'x$QO~O!Q1dO!S(Va~O!Q1dO(W4sO!S(Va~O(a4uO(m4wO~P&LlO]1nOl([Or![Os![Ot![Ou![Ov![Ow![O!x!aO!y$kO#j$lO'x(ZO(]1kO(_1oO(`1oO~O(]4|O~O]$pO!Q5PO!S*iO!Z5OO'|1rO~O(a4uO(m5RO~P(5RO]1nOl([O!x!aO#j$lO'x(ZO(]1kO(_1oO(`1oO~Op%QO](hX!Q(hX!S(hX!Z(hX'|(hX(a(hX(m(hX|(hX~O(a4uO~O(a5XO~PAdO'x&zO!Q'kX!Y'kX~O!Q2RO!Y)Oa~Op%QO](}ad(}al(}ar(}as(}at(}au(}av(}aw(}a{(}a!S(}a!Z(}a!p(}a!q(}a!r(}a!s(}a!u(}a!x(}a#j(}a'x(}a(](}a(_(}a(`(}a(a(}a|(}a!Q(}a!](}a!^(}a!`(}a!b(}a!c(}a!e(}a!f(}a!g(}a!i(}a!j(}a'{(}a'}(}a(O(}a(W(}a(^(}a!k(}a(m(}aQ(}a!h(}a![(}a'|(}a!Y(}a}(}a#Q(}a#S(}a~O!S'fO]%tqd%tql%tqr%tqs%tqt%tqu%tqv%tqw%tq{%tq!Z%tq!p%tq!q%tq!r%tq!s%tq!u%tq!x%tq#j%tq'x%tq(]%tq(_%tq(`%tq(a%tq|%tq!Q%tq!]%tq!^%tq!`%tq!b%tq!c%tq!e%tq!f%tq!g%tq!i%tq!j%tq'{%tq'}%tq(O%tq(W%tq(^%tq!k%tq(m%tqQ%tq!h%tq![%tq'|%tq!Y%tq}%tq#Q%tq#S%tq~OPsOa$jOl$aO!S#yO!l!YO#f#OO#g#PO#j$lO&Z!TO&[!TO&`!}O&d!YO&m!YO&n!YO'uQO'x$_O(bXO)T!VO)U!WO~O])Si!Q)Si!Z)Si!])Si!^)Si!`)Si!b)Si!c)Si!e)Si!f)Si!g)Si!i)Si!j)Si'{)Si'})Si(O)Si(W)Si(])Si(^)Si(_)Si(`)Si(a)Si!k)Si(m)Si|)Si![)Si'|)Si!Y)SiQ)Si!h)Si~P(>_O|5dO~O![5eO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q&hq(a&hq!k&hq(m&hq|&hq![&hq'|&hq!Y&hqQ&hq!h&hq~P!NrO!Q5fO|)ZX~O|5hO~O)X5iO~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q^y(a^y!k^y(m^y|^y![^y'|^y!Y^yQ^y!h^y~P!NrO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO|'na!Q'na~P!NrO]#pO!S#yO!Q&ey!Z&ey!]&ey!^&ey!`&ey!b&ey!c&ey!e&ey!f&ey!g&ey!i&ey!j&ey'{&ey'}&ey(O&ey(W&ey(]&ey(^&ey(_&ey(`&ey(a&ey!k&ey(m&ey|&ey![&ey'|&ey!Y&eyQ&ey!h&ey~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q&hy(a&hy!k&hy(m&hy|&hy![&hy'|&hy!Y&hyQ&hy!h&hy~P!NrO]$pO!Z+SO!S%hy(a%hy(m%hy~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q'`a!Y'`a~P!NrO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q#ui!Y#ui~P!NrO!Y5kO~P%@zO![5kO~P%@zO|5kO~P%@zO|5mO~P%@zO]$pO!Z$oO|!}y!Q!}y!S!}y(a!}y(m!}y'|!}yQ!}y!h!}y~Or#Tis#Tit#Tiu#Tiv#Tiw#Ti}#Ti!S#Ti#Q#Ti#S#Ti'|#Ti(O#Ti(m#Ti|#Ti!Q#Ti(a#TiQ#Ti!h#Ti~O]$pO!Z+SO~P) sO]&QO!Z&PO(]8lO(_8mO(`8mO~P) sO|5oO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO!Q5pO|(kX~O|5rO~O]$pO|!|i!Q!|iQ!|i!h!|i~O!Z+SO~P)%PO|#YX!Q#YXQ#YX!h#YX~P'>WO!Z$oO~P)%PO]'XXd&{Xl&{Xr'XXs'XXt'XXu'XXv'XXw'XX|'XX!Q'XX!Z'XX!x&{X#j&{X'x&{X(]'XX(_'XX(`'XXQ'XX!h'XX~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO|#li!Q#liQ#li!h#li~P!NrO]$pO!Z+SO|qqQqq!Qqq!hqq(Wqq(aqq~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dOQ)RX!Q)RX!h)RX~P!NrO(W5tOQ)QX!Q)QX!h)QX~O![5vO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO![5vO~PM{O|$hi!Q$Ua(a$Ua~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a5yO~P!NrO|5{O~PM{O|5{O!Q#^O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO|5{O~O]$pO!Z0rO!Q$}i(a$}i|$}i~O![6SO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO![6SO(]6UO~P#'{O![6SO~PM{O]$pO!Z0rO!Q'ea(a'ea~OP%fO|6VO'uQO~O|6VO~O'x+xO(W1VO(m1UOQ#{X!Q#{X!h#{X~O(a6YO~P$=WO(a6YO~P$1eO(a6YO~P$5jO(W6ZO!Q&|a!S&|a~O!Q1dO!S(Vi~O(a6_O(m6aO~P(5RO(a6_O~O(a6_O(m6eO~P&LlOr![Os![Ot![Ou![Ov![Ow![O~P(5nO]$pO!Z5OO!Q!va!S!va'|!va(a!va(m!va|!va~Or![Os![Ot![Ou![Ov![Ow![O}6iO#Q)tO#S)uO(O)qO~O]!za!Q!za!S!za!Z!za'|!za(a!za(m!za|!za~P)4aO![6mO(]6nO~P#'{O!Q5PO!S#yO'|1rO(a6_O(m6eO~O!S#yO~P#<|O]$pO|6qO!Z5OO~O]$pO!Z5OO!Q#ra!S#ra'|#ra(a#ra(m#ra|#ra~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a#sa~P!NrO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a6_O~P!NrO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Q%yi!Y%yi~P!NrO!Z-iO]&gi!Q&gi!S&gi!]&gi!^&gi!`&gi!b&gi!c&gi!e&gi!f&gi!g&gi!i&gi!j&gi'{&gi'}&gi(O&gi(W&gi(]&gi(^&gi(_&gi(`&gi(a&gi!k&gi(m&gi|&gi![&gi'|&gi!Y&giQ&gi!h&gi~O'x&zO(W6vO~O!Q5fO|)Za~O|6xO~P%@zO]$pO!Z+SO!S#Tq(m#Tq|#Tq!Q#Tq(a#TqQ#Tq!h#Tq~Or#Tqs#Tqt#Tqu#Tqv#Tqw#Tq}#Tq#Q#Tq#S#Tq'|#Tq(O#Tq~P)=ZO!Q5pO|(ka~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO|#lq!Q#lqQ#lq!h#lq~P!NrO!Q#^O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO!Y'`a(a$di~P!NrO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO|$hq!Q$Ui(a$Ui~P!NrO|6|O~PM{O|6|O!Q#^O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO|6|O~O|7PO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO|7PO~O]$pO!Z0rO!Q$}q(a$}q|$}q~O![7RO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO![7RO~PM{O(a7SO~O(m4fOQ#{a!Q#{a!h#{a~O(W7TO!Q&|i!S&|i~O!Q1dO!S(Vq~O!Q5PO!S#yO'|1rO(a7UO(m7WO~O(a7UO~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a7UO~P!NrO(a7UO(m7ZO~P(5RO]$pO!Z5OO!Q!vi!S!vi'|!vi(a!vi(m!vi|!vi~O]!zi!Q!zi!S!zi!Z!zi'|!zi(a!zi(m!zi|!zi~P)4aO![7`O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO![7`O(]7bO~P#'{O![7`O~PM{O]$pO!Z5OO!Q'^a!S'^a'|'^a(a'^a(m'^a~O|7cO!Q#^O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO|7cO~O]$pO!Z0rO!Q$}y(a$}y|$}y~O(a7fO~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a7fO~P!NrO!Q5PO!S#yO'|1rO(a7fO(m7iO~O]$pO!Z5OO!Q!vq!S!vq'|!vq(a!vq(m!vq|!vq~O![7kO!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO~P!NrO![7kO~PM{O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a7mO~P!NrO(a7mO~O]$pO!Z5OO!Q!vy!S!vy'|!vy(a!vy(m!vy|!vy~O!^#eO!`#fO!b#hO!c#iO!e#kO!f#lO!g#lO!i#lO!j#mO'{#[O(W#oO(]#bO(^#cO(_#cO(`#dO(a7pO~P!NrO(a7pO~O]ZXlgXpZXpiX!QZX!SiX!ZZX!]ZX!^ZX!`ZX!bZX!cZX!eZX!fZX!gZX!iZX!jZX!kZX'{ZX'|$bX'}ZX(OZX(WZX(]ZX(^ZX(_ZX(`ZX(aZX(mZX~O]#_XlmXpnXp#_X!Q#_X!SnX!Z#_X!]#_X!^#_X!`#_X!b#_X!c#_X!e#_X!f#_X!g#_X!i#_X!j#_X!kmX'{#_X'}#_X(O#_X(W#_X(]#_X(^#_X(_#_X(`#_X(mmX|#_XQ#_X!h#_X~O(a#_X![#_X'|#_X!Y#_X~P*(}O]nX]#_XdnXlmXpnXp#_XrnXsnXtnXunXvnXwnX{nX!ZnX!Z#_X!pnX!qnX!rnX!snX!unX!xnX#jnX'xnX(]nX(_nX(`nX|nX|#_X!QnX(WnX~O(anX(mnX~P*+_O]#_XlmXpnXp#_X!Q#_X!Z#_X|#_XQ#_X!h#_X~O!S#_X(a#_X(m#_X'|#_X~P*-iOQnXQ#_X!QnX!hnX!h#_X(WnX~P!:zO]nX]#_XlmXpnXp#_XrnXsnXtnXunXvnXwnX{nX!SnX!Z#_X!pnX!qnX!rnX!snX!unX!xnX#jnX'xnX(]nX(_nX(`nX~O'|nX(anX(mnX~P*/OOdnX|#_X!Q#_X!ZnX!]#_X!^#_X!`#_X!b#_X!c#_X!e#_X!f#_X!g#_X!i#_X!j#_X!kmX'{#_X'}#_X(O#_X(W#_X(]#_X(^#_X(_#_X(`#_X(a#_X(mmX~P*/OO]nX]#_XdnXlmXpnXp#_XrnXsnXtnXunXvnXwnX{nX!ZnX!Z#_X!pnX!qnX!rnX!snX!unX!xnX#jnX'xnX(]nX(_nX(`nX(a#_X~OlmXpnX(a#_X~Od({O#a(|O(P7sO~Od({O#a(|O(P7wO~Od({O#a(|O(P7tO~O]iXriXsiXtiXuiXviXwiX|iX!ZiX(]iX(_iX(`iXdiX{iX!piX!qiX!riX!siX!uiX!xiX#jiX'xiX~P!LbO]ZXlgXpZXpiX!QZX!ZZX(aZX(mZX~O!SZX'|ZX~P*6|OlgXpiX(aZX(miX~O]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiX{iX!ZZX!ZiX!piX!qiX!riX!siX!uiX!xiX#jiX'xiX(]iX(_iX(`iX|ZX|iX!QiX(WiX(miX~O(aZX~P*8QO]ZX]iXlgXpZXpiXriXsiXtiXuiXviXwiX!QZX!QiX!SiX!ZZX!ZiX!]ZX!^ZX!`ZX!bZX!cZX!eZX!fZX!gZX!iZX!jZX!kZX'{ZX'}ZX(OZX(WZX(WiX(]ZX(]iX(^ZX(_ZX(_iX(`ZX(`iX(mZX~OQZXQiX!hZX!hiX~P*:[OdiX{iX|ZX|iX!piX!qiX!riX!siX!uiX!xiX#jiX'xiX(miX~P*:[O]iXdiXriXsiXtiXuiXviXwiX{iX!ZiX!piX!qiX!riX!siX!uiX!xiX#jiX'xiX(]iX(_iX(`iX~P!LbO]ZX]iXlgXpZXpiXriXsiXtiXuiXviXwiX{iX!ZZX!piX!qiX!riX!siX!uiX!xiX#jiX'xiX(]iX(_iX(`iX(aiX~O!SiX'|iX(miX~P*?nOdiX!ZiX~P*?nOd#tO#a)hO&f#vO&i#wO(P#qO~Od#tO#a)hO&f#vO&i#wO(P7vO~Od#tO#a)hO&f#vO&i#wO(P7xO~Or![Os![Ot![Ou![Ov![Ow![O~PCvOr![Os![Ot![Ou![Ov![Ow![O!y$kO~PCvOd#tO#a)hO(P7uO~Od#tO#a)hO(P7zO~Od#tO#a)hO(P7tO~Od#tO#a)hO(P7yO~O]${OdjOl8_Or![Os![Ot![Ou![Ov![Ow![O!Z$}O!x!aO!y$kO#j$lO'x$_O(]8dO(_8fO(`8fO~O]${OdjOl8_O!Z$}O!x!aO#j$lO'x$_O(]8dO(_8fO(`8fO~Od#tO#a#uO(P7tO~Od#tO#a#uO(P7wO~Ol7}O~Ol7|O~O]&QOr![Os![Ot![Ou![Ov![Ow![O!Z&PO(]8lO(_8mO(`8mO~O}#UX!S#UX#Q#UX#S#UX'|#UX(O#UX(m#UX|#UX!Q#UX(a#UXQ#UX!h#UX~P*GeO]&QO!Z&PO(]8lO(_8mO(`8mO~Or#YXs#YXt#YXu#YXv#YXw#YX}#YX!S#YX#Q#YX#S#YX'|#YX(O#YX(m#YX|#YX!Q#YX(a#YXQ#YX!h#YX~P*ISO]cXlgXpiX!ScX~Od({O#a)hO(P#qO~Od({O#a)hO(P7uO~Od({O#a)hO(P7zO~Od({O#a)hO(P7yO~Od({O#a)hO(P7tO~Od({O#a)hO(P7vO~Od({O#a)hO(P7xO~Or![Os![Ot![Ou![Ov![Ow![O~P*FRO}#Ua!S#Ua#Q#Ua#S#Ua'|#Ua(O#Ua(m#Ua|#Ua!Q#Ua(a#UaQ#Ua!h#Ua~P*GeOr#Uas#Uat#Uau#Uav#Uaw#Ua}#Ua#Q#Ua#S#Ua'|#Ua(O#Ua~P&2UOr#Yas#Yat#Yau#Yav#Yaw#Ya}#Ya#Q#Ya#S#Ya'|#Ya(O#Ya~P&5bO](TXr(TXs(TXt(TXu(TXv(TXw(TX{(TX!p(TX!q(TX!r(TX!s(TX!u(TX!x(TX#j(TX'x(TX(](TX(_(TX(`(TX(m(TX~Ol7|O!S(TX'|(TX(a(TX~P+ nO]&RXlmXpnX!S&RX~Od2hO#a)hO(P9OO~O(]%|O(_&RO(`&RO(W#Ta~P':|Ol$yO(]9TO(_3]O(`3]O~P'?YOr#Uis#Uit#Uiu#Uiv#Uiw#Ui}#Ui#Q#Ui#S#Ui'|#Ui(O#Ui~P'MfO!S#Ti|#Ti(a#Ti(m#Ti!Q#TiQ#Ti!h#Ti(W#Ti~O]$pO!Z+SO~P+%bO]&QO!Z&PO(]%|O(_&RO(`&RO~P+%bOdjOl8_O!x!aO#j$lO'x$_O~O]/VO!Z/UO(]/SO(_9XO(`9XO|#YX!Q#YXQ#YX!h#YX~P+&kO(W#Tq~P)=ZO(]8^O~Ol8oO~Ol8pO~Ol8qO~Ol8rO~Ol8sO~Ol8tO~Ol8uO~Ol8oO!k#{O(m#{O~Ol8tO!k#{O(m#{O~Ol8uO!k#{O(m#{O~Ol8tO!S#yOQ(TX!Q(TX!h(TX(W(TX|(TX(m(TX~P$(WOl8uO!S#yO~P$(WOl8sO|(TX!Q(TX(W(TX(m(TX~P$(WOd-xO#a)hO(P9OO~Ol9PO~O(]9hO~OV&o&r&s&q'u(b!W'xST#b!^!`&td#c!l&[!j]&p)[&u'}!b!c&v&w&v~",
        goto: "$@Y)[PPPPPP)]P)`PP,r1vP4l4l7dP7d:[P:u;X;mAtHTNh!&_P!,h!-]!.QP!.lPPPPPP!/SP!0gPPP!1vPP!2|P!4f!4j!5]P!5cPPPPP!5fP!5fPP!5fPPPPPPPP!5r!8vPPPPP!8yP:x!:UPP:x!<Z!>c!>p!@T!ArP!ArP!BS!Bh!CV!Bh!Bh!Bh!>p!>p!>p!Cv!HP!HnPPPPPPP!Ie!MhP!>p!>c!>c##z#$Q:x:x:x#$T#$h#&p#&x#&x#'PP#'a#'hPP#'h#'h#'o#'PP#'s#(d#'YP#(oP#)R#*{#+U#+_PP#+t#,_#,{#-i#+tP#.t#/QP#+tP#+tPP#/T#+t#+tP#+tP#+tP#+tP#+tP#1zP#2_#2_#2_#2_#+_#+_P#2lP#+_#*{P#2p#2pP#2}#*{#*{#5xP#6]#6h#6n#6n#*{#7d#*{P#8O#8O!4f!4f!4f!4f!4f!4f!/S!/SP#8RP#9i#9w!/S!/S!/SPP#9}#:Q!I]#:T7d4l#<w#>g#?|4lPP4l#Af4lP4l4l4lP4lP#DY4lP#Af#Df4lPPPPPPPPPPP)]P#GY#G`#Iv#JV#J]#KY#K`#Kv#LQ#MY#NX#N_#Ni#No#N{$ V$ _$ e$ k$ y$!S$![$!b$!m$!|$#W$#^$#d$#k$#z$$Q$%i$%o$%u$%|$&T$&^PPPPPPPP$&d$&hPPPPP$,p#9}$,s$0O$2V$3YP$3]P$3a$3dPPPPPPPPP$3p$5]$6d$7V$7]$9f$9iP$;O$;U$;Y$;]$;c$;o$;y$<S$=R$=n$=t$>_$>o$>r$?S$?a$?g#9}#:Q#:Q$?jPP$?m$?xP$@S$@VR#WP&jsOadei|}!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%Q%V%W%X%Y%e%r%t&P&e&f&j&k&v&{'O'U'p'r'x(x)O)w)y*T*Z*a*h*i*j*w*y+S+U+W+j+m+s,P,S,Z-i-l-v-|.V.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iU%fs%g4bQ&W!^Q'y#Qd.j)Z.g.h.i.l2y2z2{3O5lR4b1PdgOade|}%t&{*i,Z#^$|fmtu!t$W$f$g$m$z${%m'S'T'V'Z)f)l)n){*l+h+r,Q,g,w,}-P.v/R/S/V/W0`3]8[8]8^8c8d8e8f8v8w8x8y9Q9R9T9X9f9g9hS%Si/s&O%z!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%Q%V%W%X%Y%e%r&P&e&f&j&k&v'O'U'p'r'x(x)O)w)y*T*Z*a*h*j*w*y+S+U+W+j+m+s,P,S-i-l-v-|.V.X.^.`.|/Q/Y/e0U0W0d0f0h0k0r0w0z1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iQ&c!cQ&}!rQ'y#TQ'z#QQ'{#RQ*U$}Q+[&VQ+e&dS-Z'f2RQ/j*]Q2_-hQ2c-oQ3c/ZQ6v5fR8g/U$f#]S!Z$`$j$q%R%y%{&l&u&x'q'w(W(X(a(b(c(d(e(f(g(h(i(j(k(l(w(})U)v*V*x+T+f+q,],o-f.Z/P/b/h/r/t/|0T0b0j2`2a2g2i2o2q2u2v3V3b3g3t3}4Q4X5V5W5^5s5u5w5z5}6T6c6k6{7X7a7g7nQ&Y!aQ'v#OQ(S#VQ(v#v[*k%b)d/v0a0i0xQ+_&XQ-j'uQ-n'zQ-u(TS.S(u-kQ/m*bS2m.T.UR5j2n&k!YOadei|}!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%Q%V%W%X%Y%e%r%t&P&e&f&j&k&v&{'O'U'p'r'x(x)O)w)y*T*Z*a*h*i*j*w*y+S+U+W+j+m+s,P,S,Z-i-l-v-|.V.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7i&k!SOadei|}!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%Q%V%W%X%Y%e%r%t&P&e&f&j&k&v&{'O'U'p'r'x(x)O)w)y*T*Z*a*h*i*j*w*y+S+U+W+j+m+s,P,S,Z-i-l-v-|.V.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iQ(^#`S*b%^/nQ.])Pk1q,v1h1k1n1o4x4y4z4|5P6g6h7^Q(`#`k1p,v1h1k1n1o4x4y4z4|5P6g6h7^l(_#`,v1h1k1n1o4x4y4z4|5P6g6h7^T*b%^/n^UO|}%t&{*i,Z#`$S[_!b!m!v!w!x!y!z!{#O#u#v$Y$p$s&Q&W&s'R'Y'`'e'i'n'v(v(|)q)z+]+c+g,b,c,l,s,t-^.z.}/]1Q1U1`1a1b1d1i4f4p5p9n9o&[$baefi!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$f$g$m$o$z${%W%X%Y%e%r&P&f&j'O'S'U'p'x(x)O)l)n)w)y*T*Z*a*j*w*y+S+U+W+j+m+s-i-l-v-|.V.X.^.`.v.|/Q/R/U/Y/s0U0W0d0f0h0k0r1r1u2Q2^3]3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7i9TY%itu%m,g,wl(]#`,v1h1k1n1o4x4y4z4|5P6g6h7^Q8j'TU8k'Z,}-PU9[d%V'r![9]m$W'V)f){*l+h+r,Q/S/W0`8[8]8^8c8d8e8f8v8w8x8y9Q9R9X9f9g9hS9^!c&dQ9_!tQ9`/VU9a%Q*h/e^9b&e&k&v,P,S0w0zT9m%^/n^VO|}%t&{*i,ZQ$S-^!j$T[_!b!m!v!{#O#u#v$Y$p$s&Q&W&s'R'v(v(|)q)z+]+c+g,b,t.z.}/]1Q1U1i4f5p9n9oj$bf$f$g$m$z${'S)l)n.v/R3]9T%p$caei!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%W%X%Y%e%r&P&f&j'O'U'p'x(x)O)w)y*T*Z*a*j*w*y+S+U+W+j+m+s-i-l-v-|.V.X.^.`.|/Q/U/Y/s0U0W0d0f0h0k0r1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iU$rd%V'rY%itu%m,g,wQ'P!tp'W!w!x!y!z'Y'`'e'i'n,c,s1`1a1b1d4pl(]#`,v1h1k1n1o4x4y4z4|5P6g6h7^Q,f'TQ1[,lU8}'Z,}-P![9]m$W'V)f){*l+h+r,Q/S/W0`8[8]8^8c8d8e8f8v8w8x8y9Q9R9X9f9g9hS9^!c&dU9i%Q*h/e^9j&e&k&v,P,S0w0zQ9k/VT9m%^/nx!ROd|}%Q%V%t&e&k&v&{'r*h*i,P,S,Z/e0w0z!t$X[_!b!m!t!v!{#O#u#v$Y$p$s&Q&W&s'R'T'Z'v(v(|)q)z+]+c+g,t,}-P.z.}/V/]1Q1U1i4f5p9n9o%p$iaei!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%W%X%Y%e%r&P&f&j'O'U'p'x(x)O)w)y*T*Z*a*j*w*y+S+U+W+j+m+s-i-l-v-|.V.X.^.`.|/Q/U/Y/s0U0W0d0f0h0k0r1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7i#t%Ofmtu#`$W$f$g$m$z${%^%m&d'S'V)f)l)n){*l+h+r,Q,g,v,w.v/R/S/W/n0`1h1k1n1o3]4x4y4z4|5P6g6h7^8[8]8^8c8d8e8f8v8w8x8y9Q9R9T9X9f9g9hQ&b!cn'X!w!x!y!z'Y'`'e'i'n,s1`1a1b1d4pf+}&t+w+y+|0m0n0p0s4V4W6RQ1T,bQ1W,cQ1Z,kQ1],lQ2U-^Q4h1VR6X4ix!ROd|}%Q%V%t&e&k&v&{'r*h*i,P,S,Z/e0w0z!v$X[_!b!m!t!v!{#O#u#v$Y$p$s&Q&W&s'R'T'Z'v(v(|)q)z+]+c+g,b,t,}-P.z.}/V/]1Q1U1i4f5p9n9o%p$iaei!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%W%X%Y%e%r&P&f&j'O'U'p'x(x)O)w)y*T*Z*a*j*w*y+S+U+W+j+m+s-i-l-v-|.V.X.^.`.|/Q/U/Y/s0U0W0d0f0h0k0r1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7i#v%Ofmtu!c#`$W$f$g$m$z${%^%m&d'S'V)f)l)n){*l+h+r,Q,g,v,w.v/R/S/W/n0`1h1k1n1o3]4x4y4z4|5P6g6h7^8[8]8^8c8d8e8f8v8w8x8y9Q9R9T9X9f9g9hp'X!w!x!y!z'Y'`'e'i'n,c,s1`1a1b1d4pQ1],lR2U-^^WO|}%t&{*i,Z#`$S[_!b!m!v!w!x!y!z!{#O#u#v$Y$p$s&Q&W&s'R'Y'`'e'i'n'v(v(|)q)z+]+c+g,b,c,l,s,t-^.z.}/]1Q1U1`1a1b1d1i4f4p5p9n9oj$bf$f$g$m$z${'S)l)n.v/R3]9T%p$daei!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%W%X%Y%e%r&P&f&j'O'U'p'x(x)O)w)y*T*Z*a*j*w*y+S+U+W+j+m+s-i-l-v-|.V.X.^.`.|/Q/U/Y/s0U0W0d0f0h0k0r1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iY%itu%m,g,wl(]#`,v1h1k1n1o4x4y4z4|5P6g6h7^Q8j'TU8k'Z,}-P![9]m$W'V)f){*l+h+r,Q/S/W0`8[8]8^8c8d8e8f8v8w8x8y9Q9R9X9f9g9hS9^!c&dQ9_!tQ9`/VU9cd%V'rU9d%Q*h/e^9e&e&k&v,P,S0w0zT9m%^/np#rT$R$a$y%h([8X8Y8Z8_8`8a8b8h8i9lo(y#x)b)i-y7{7|7}8o8p8q8r8s8t8u9Pp#sT$R$a$y%h([8X8Y8Z8_8`8a8b8h8i9lo(z#x)b)i-y7{7|7}8o8p8q8r8s8t8u9P^%Pgh$|%S%T%z8gd%x!R$X$i%O&b'X1T1W1]2UV-z(^(_1qS$wd%VQ*W%QQ-g'rQ0]+cQ3X.}Q3h/eR6y5p#s!QO[_d|}!b!m!t!v!{#O#u#v$Y$p$s%Q%V%t&Q&W&e&k&s&v&{'R'T'Z'r'v(v(|)q)z*h*i+]+c+g,P,S,Z,b,l,t,}-P.z.}/V/]/e0w0z1Q1U1i4f5p9n9o#O^O[_`|}!b!t!v#u$V$Y$[$]$p%t&Q&W&Z&e&k&v&{'R'T'Z(|)g)z*h*i+]+g,P,S,Z,l,t,}-P/V/]0w0z1Q1iS'`!w1aS'e!x1bV'n!z,c1`S'^!w1aS'c!x1bU'l!z,c1`W-S'['_'`4mW-W'a'd'e4nW-c'j'm'n4lS1{-T-US2O-X-YS2Z-d-eQ5Z1|Q5]2PR5c2[S']!w1aS'b!x1bU'k!z,c1`Y-R'['^'_'`4mY-V'a'c'd'e4nY-b'j'l'm'n4lU1z-S-T-UU1}-W-X-YU2Y-c-d-eS5Y1{1|S5[2O2PS5b2Z2[Q6r5ZQ6s5]R6t5cT,{'Z,}!aZO[|}$p%t&Q&W&e&k&v&{'R'T'Z)z*h*i+]+g,P,S,Z,l,t,}/V/]0w0z1QQ$OYR.n)[R)^$Oe.j)Z.g.h.i.l2y2z2{3O5l&j!YOadei|}!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%Q%V%W%X%Y%e%r%t&P&e&f&j&k&v&{'O'U'p'r'x(x)O)w)y*T*Z*a*h*i*j*w*y+S+U+W+j+m+s,P,S,Z-i-l-v-|.V.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7ie.j)Z.g.h.i.l2y2z2{3O5lR3P.nd]O|}%t&{'T'Z*i,Z,}!j^[_`!b!t!v#u$V$Y$[$]$p&Q&W&Z&e&k&v'R(|)g)z*h+]+g,P,S,l,t-P/V/]0w0z1Q1iQ%ktT)o$n)p!fbOadeftu|}!t$f$g$m$z${%m%t&{'S'T'Z)l)n*i,Z,g,w,}-P.v/R/V3]9Tf+z&t+w+y+|0m0n0p0s4V4W6Rj1l,v1h1k1n1o4x4y4z4|5P6g6h7^r9Zm$W'V)f*l+h+r,Q0`8[8]8^8c8e8v8x9Qi9p){/S/W8d8f8w8y9R9X9f9g9hv$nc$h$t$x%b'Q)d)k,e,p.t.u/X/v0a0i0x3R3^|%}!X$v%|&Q&R&a(t){*P*R*|.W/R/S/V/W/`3]9S9T9W9XY+Q3T5n8{8|9Un+R&O*S*}+X+Y+b.R/T/a0P2p3[3f9V9Y^0q+{0o0u4U4]6Q7QQ0|,WY3S.y3U8l8m8ze4}1m4t4{5T5U6d6f6o7]7jW)|$p&Q*h/VS,_'R1QR3d/]#sjOadefmtu|}!t$W$f$g$m$z${%m%t&{'S'T'V'Z)f)l)n){*i*l+h+r,Q,Z,g,w,}-P.v/R/S/V/W0`3]8[8]8^8c8d8e8f8v8w8x8y9Q9R9T9X9f9g9h#Qjadefm!t$W$f$g$m$z${'S'V)f)l)n){*l+h+r,Q.v/R/S/V/W0`3]8[8]8^8c8d8e8f8v8w8x8y9Q9R9T9X9f9g9h`kO|}%t&{'T*i,ZU%jtu,gQ*s%mS,u'Z,}T1v,w-PW)r$n)p)s.xW+O%}+P+R0ST6i4}6jW)r$n)p)s.xQ+Q%}S0R+P+RQ3r0ST6i4}6j!X&S!X$v%|&Q&R&a(t){*P*R*|.W.y/R/S/V/W/`3U3]8l8m8z9S9T9W9X!U&S$v%|&Q&R&a(t){*P*R*|.W.y/R/S/V/W/`3U3]8l8m8z9S9T9W9XR&T!XdhOade|}%t&{*i,Z#^$|fmtu!t$W$f$g$m$z${%m'S'T'V'Z)f)l)n){*l+h+r,Q,g,w,}-P.v/R/S/V/W0`3]8[8]8^8c8d8e8f8v8w8x8y9Q9R9T9X9f9g9h&U%Ti!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%Q%V%W%X%Y%e%r&P&e&f&j&k&v'O'U'p'r'x(x)O)w)y*T*Z*a*h*j*w*y+S+U+W+j+m+s,P,S-i-l-v-|.V.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iQ&c!cR+e&dj#tT$a$y%h8X8Y8Z8_8`8a8b8h8ii({#x)i7{7|7}8o8p8q8r8s8t8uj#tT$a$y%h8X8Y8Z8_8`8a8b8h8ih({#x)i7{7|7}8o8p8q8r8s8t8uS-x([9lT2h-y9P#^jfmtu!t$W$f$g$m$z${%m'S'T'V'Z)f)l)n){*l+h+r,Q,g,w,}-P.v/R/S/V/W0`3]8[8]8^8c8d8e8f8v8w8x8y9Q9R9T9X9f9g9hdlOade|}%t&{*i,Z&V!Yi!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%Q%V%W%X%Y%e%r&P&e&f&j&k&v'O'U'p'r'x(x)O)w)y*T*Z*a*h*j*w*y+S+U+W+j+m+s,P,S-i-l-v-|.V.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7i#^jfmtu!t$W$f$g$m$z${%m'S'T'V'Z)f)l)n){*l+h+r,Q,g,w,}-P.v/R/S/V/W0`3]8[8]8^8c8d8e8f8v8w8x8y9Q9R9T9X9f9g9hdlOade|}%t&{*i,Z&U!Yi!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%Q%V%W%X%Y%e%r&P&e&f&j&k&v'O'U'p'r'x(x)O)w)y*T*Z*a*h*j*w*y+S+U+W+j+m+s,P,S-i-l-v-|.V.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7ik1p,v1h1k1n1o4x4y4z4|5P6g6h7^Q/[){R3`/WR/[){Q1t,vS4v1h1mU6`4t4x5QS7V6^6dR7h7Y^#zV!R$c$i$r9i9jQ&n!iS(m#p*hS)S#y*iQ)V#{Y*k%b)d/v0i0xQ-j'uS.S(u-kS/c*T2^Q/m*bS/u*j3wQ1t,vQ2j-|S2m.T.US2r.X3oQ2w.`Q3x0aU4v1h1m1uQ5j2nQ6O4PY6`4t4w4x5Q5RW7V6^6a6d6eU7h7W7Y7ZR7o7iS)S#y*iT2r.X3oZ)Q#y)R*i.X3o^zO|}%t&{*i,ZQ,n'TT,{'Z,}S'T!t,mR1X,dS,_'R1QR4j1XT,_'R1Q^zO|}%t&{*i,ZQ+^&WQ+j&eS+s&k0zW,R&v,P,S0wQ,n'TR1^,l[%cm$W+h+r,Q0`R/w*l^zO|}%t&{*i,ZQ+^&WQ,n'TR1^,l!OqO|}!f%e%t&f&j&v&{*i+m,P,S,Z0d0w3{4R5{6|7P7cS%_k,uS%pw,hQ&U!XQ&w!pU*e%`%j1vQ*n%bS*u%n%oQ+Z&TQ+n&hS.r)d,pS/y*r*sQ/{*tQ3Q.tQ3p/zQ4`0|Q5S1mQ6b4tR7[6d_zO|}%t&{*i,ZQ&|!rQ+^&WR,[&}wrO|}!f%e%t&f&j&{*i+m,Z0d3{4R5{6|7P7c!PqO|}!f%e%t&f&j&v&{*i+m,P,S,Z0d0w3{4R5{6|7P7c!OnO|}!f%e%t&f&j&v&{*i+m,P,S,Z0d0w3{4R5{6|7P7cR&r!l!OqO|}!f%e%t&f&j&v&{*i+m,P,S,Z0d0w3{4R5{6|7P7cR+j&e!OpO|}!f%e%t&f&j&v&{*i+m,P,S,Z0d0w3{4R5{6|7P7cW$ud%V'r0fQ&n!iS(Y#^3oQ+i&eS+t&k0zQ0c+jQ4S0kQ5|4OR6}5yQ&f!dQ&h!eQ&j!gR+m&gR+k&e&b!SOadei|}!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#p#w#y#{$o%Q%V%W%X%Y%e%r%t&P&e&f&j&k&v&{'O'U'p'r'x(x)O)w)y*T*Z*a*h*i*j*w*y+S+U+W+j+m+s,P,S,Z-i-v-|.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iR0g+o^zO|}%t&{*i,ZW,R&v,P,S0wT,{'Z,}g+}&t+w+y+|0m0n0p0s4V4W6RT,U&w,V^zO|}%t&{*i,ZT,{'Z,}&j!YOadei|}!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#n#p#w#y#{$o%Q%V%W%X%Y%e%r%t&P&e&f&j&k&v&{'O'U'p'r'x(x)O)w)y*T*Z*a*h*i*j*w*y+S+U+W+j+m+s,P,S,Z-i-l-v-|.V.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q2^3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iR4c1P^uO|}%t&{*i,ZQ%mtQ,g'TT,w'Z,}S%`k,uS*r%j1vR/z*sQ*c%^R3m/nS%_k,uS%pw,hU*e%`%j1vS*u%n%oS/y*r*sQ/{*tQ3p/zQ5S1mQ6b4tR7[6dbwO|}%t&{'Z*i,Z,}S%nt,gU%ou,w-PQ*t%mR,h'TR,n'T#r!QO[_d|}!b!m!t!v!{#O#u#v$Y$p$s%Q%V%t&Q&W&e&k&s&v&{'R'T'Z'r'v(v(|)q)z*h*i+]+c+g,P,S,Z,b,l,t,}-P.z.}/V/]/e0w0z1Q1U1i4f5p9n9oR2V-^Q'h!yS-_'g'iS2W-`-aR5a2XQ-['fR5_2RR*X%QR3i/e&c!SOadei|}!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#p#w#y#{$o%Q%V%W%X%Y%e%r%t&P&e&f&j&k&v&{'O'U'p'r'x(x)O)w)y*T*Z*a*h*i*j*w*y+S+U+W+j+m+s,P,S,Z-i-v-|.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7i$Z#fS$q%R&l&u&x'q'w(W(X(a(b(d(e(f(g(h(i(j(k(l(w(})U)v*V*x+T+f+q,],o-f.Z/P/b/h/r/t/|0T0b0j2`2a2g2i2o2q2u2v3V3b3g3t3}4Q4X5V5W5^5s5u5w5z5}6T6c6k6{7X7a7g7n#w#gS$q%R&l&u&x'w(W(X(a(k(l(w(})U)v*V*x+T+f+q,],o-f.Z/P/b/h/r/t/|0T0b0j2`2a2g2i2o2q2u2v3V3b3g3t3}4Q4X5V5W5^5s5u5w5z5}6T6c6k6{7X7a7g7n#}#jS$q%R&l&u&x'w(W(X(a(d(e(f(k(l(w(})U)v*V*x+T+f+q,],o-f.Z/P/b/h/r/t/|0T0b0j2`2a2g2i2o2q2u2v3V3b3g3t3}4Q4X5V5W5^5s5u5w5z5}6T6c6k6{7X7a7g7n&c!YOadei|}!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#p#w#y#{$o%Q%V%W%X%Y%e%r%t&P&e&f&j&k&v&{'O'U'p'r'x(x)O)w)y*T*Z*a*h*i*j*w*y+S+U+W+j+m+s,P,S,Z-i-v-|.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iQ-k'uQ.T(uQ2n.UR6u5e&c!XOadei|}!T!U!f!i!n!q!}#P#[#^#a#e#f#g#h#i#j#k#l#m#p#w#y#{$o%Q%V%W%X%Y%e%r%t&P&e&f&j&k&v&{'O'U'p'r'x(x)O)w)y*T*Z*a*h*i*j*w*y+S+U+W+j+m+s,P,S,Z-i-v-|.X.^.`.|/Q/U/Y/e/s0U0W0d0f0h0k0r0w0z1r1u2Q3a3o3u3w3{4O4P4R4Y4[4w5O5R5y5{6U6a6e6l6n6|7P7W7Z7b7c7iQ#YQR(U#YU$fa$z9T`$sd%Q%V'r+c.}/e5pQ&s!m!Q)j$f$s&s)l)w*R+U.v/`0U0m4V4Y4y6R6g6l7^8[8v8w9Q9R9fS)l$g$mQ)w$oQ*R$vS+U&P/UQ.v)nQ/`*PQ0U+SQ0m+yS4V0n0pQ4Y0rQ4y1kQ6R4WS6g4z4|Q6l5OQ7^6hQ8[8cS8v8]8^S8w9g9hQ9Q8xQ9R8yT9f/S8dQ1e,qU4q1e4r6]S4r1f1gR6]4sQ,}'ZR1w,}`[O|}%t&{'T*i,ZY$U[)z+]+g,t^)z$p&Q'R*h/V/]1QS+]&W,l^+g&e&k&v,P,S0w0zT,t'Z,}Q)Y#}R.c)YQ.l)ZQ2y.gQ2z.hQ2{.iY2|.l2y2z2{5lR5l3OQ)]$OS.o)].pR.p)^!p_O[|}!b!t!v#u$Y$p%t&Q&W&e&k&v&{'R'T'Z(|)z*h*i+]+g,P,S,Z,l,t,}-P/V/]0w0z1Q1iU$Z_$])gU$]`$V&ZR)g$[U$ga$z9Td)m$g)n0n4W4z6h8]8x8y9gQ)n$mQ0n+yQ4W0pQ4z1kQ6h4|Q8]8cQ8x8^Q8y9hT9g/S8dQ)p$nR.w)pQ)s$nQ.x)pT.{)s.xQ5q3XR6z5qU*|%|/S9TS0O*|8zR8z8lQ+P%}S0Q+P0SR0S+RU*^%S*U8gR/k*^Q/^)|R3e/^Q6j4}R7_6jQ5Q1mQ6^4tU6p5Q6^7YR7Y6dW)R#y*i.X3oR._)RU.Y(})S/rR2s.YQ1R,`R4e1R[*m%b%c)d0a0i0xR/x*mQ|OU%s|%t,ZS%t}*iR,Z&{Q,S&vQ0w,PT0y,S0wQ0t+{R4^0tQ,V&wR0{,VS%gs4bR*q%gdtO|}%t&{'T'Z*i,Z,}R%ltQ/o*cR3n/o#t!PO[_d|}!b!m!t!v!{#O#u#v$Y$p$s%Q%V%t&Q&W&e&k&s&v&{'R'T'Z'r'v(v(|)q)z*h*i+]+c+g,P,S,Z,b,l,t,}-P-^.z.}/V/]/e0w0z1Q1U1i4f5p9n9oR%v!PQ2S-[R5`2SQ/f*XR3j/fS*[%R.ZR/i*[S-}(l(mR2k-}W(O#U'y'z-nR-r(OQ5g2cR6w5gT(n#p*h|SO|}!f%e%t&f&j&v&{+m,P,S,Z0d0w3{4R5{6|7P7cj$`ae%W%X)y+W/Q0W3u4[6U6n7bW$qd%V'r0fY%Ri%Y'x(x*aQ%y!TQ%{!UQ&l!iQ&u!nQ&x!qQ'q!}S'w#P*yQ(W#[Q(X#^Q(a#aQ(b#eQ(c#fQ(d#gQ(e#hQ(f#iQ(g#jQ(h#kQ(i#lQ(j#mQ(k#nS(l#p*hQ(w#wQ(}#yQ)U#{Q)v$oQ*V%QQ*x%rS+T&P/UQ+f&eS+q&k0zQ,]'OQ,o'UQ-f'pS.Z)O/sQ/P)wS/b*T2^Q/h*ZQ/r*iQ/t*jQ/|*wS0T+S+UQ0b+jQ0j+sQ2`-iQ2a-lQ2g-vQ2i-|Q2o.VQ2q.XQ2u.^Q2v.`Q3V.|Q3b/YQ3g/eQ3t0UQ3}0hQ4Q0kQ4X0rQ5V1rQ5W1uQ5^2QQ5s3aQ5u3oQ5w3wQ5z4OQ5}4PQ6T4YS6c4w5RQ6k5OQ6{5yS7X6a6eQ7a6lS7g7W7ZR7n7iR*Y%Qd]O|}%t&{'T'Z*i,Z,}!j^[_`!b!t!v#u$V$Y$[$]$p&Q&W&Z&e&k&v'R(|)g)z*h+]+g,P,S,l,t-P/V/]0w0z1Q1i#p$ead!m$f$g$m$o$s$v$z%Q%V&P&s'r)l)n)w*P*R+S+U+c+y.v.}/U/`/e0U0m0n0p0r1k4V4W4Y4y4z4|5O5p6R6g6h6l7^8[8]8^8c8d8v8w8x8y9Q9R9f9g9hQ%ktW)r$n)p)s.xW*{%|*|8l8zW+O%}+P+R0SQ.z)qS3_/S9TS6i4}6jR9o9n``O|}%t&{'T*i,ZQ$V[Q$[_`$vd%Q%V'r+c.}/e5p!^&Z!b!t!v#u$Y$p&Q&W&e&k&v'R'Z(|)z*h+]+g,P,S,l,t,}-P/V/]0w0z1Q1iQ&t!mS'o!{,bQ'u#OS(u#v'vQ*P$sQ+w&sQ.U(vQ.y)qQ3U.zQ4g1UQ6W4fQ9S9nR9W9oQ'[!wQ'a!xQ'g!yS'j!z,cQ,q'YQ-U'`Q-Y'eQ-a'iQ-e'nQ1_,lQ1g,sQ4l1`Q4m1aQ4n1bQ4o1dR6[4pR,r'YT,|'Z,}R$PYe.k)Z.g.h.i.l2y2z2{3O5ldmO|}%t&W&{'T*i,Z,lS$W[+]Q&a!bQ'S!tQ'V!vQ(t#uQ)f$Y^){$p&Q'R*h/V/]1QQ+h&eQ+r&kY,Q&v,P,S0w0zS,v'Z,}Q.W(|Q/R)zQ0`+gS1h,t-PR4x1id]O|}%t&{'T'Z*i,Z,}!j^[_`!b!t!v#u$V$Y$[$]$p&Q&W&Z&e&k&v'R(|)g)z*h+]+g,P,S,l,t-P/V/]0w0z1Q1iR%ktQ1m,vQ4t1hQ4{1kQ5T1nQ5U1oQ6d4xU6f4y4z4|Q6o5PS7]6g6hR7j7^X)}$p&Q*h/VpcOtu|}%m%t&{'T'Z*i,Z,g,w,}-P[$ha$z/S8c8d9TU$td${/V^$xef/W3]8e8f9XQ%bmQ'Q!tQ)d$Wb)k$f$g$m8[8]8^9f9g9hQ,e'SQ,p'VQ.t)f[.u)l)n8v8w8x8yQ/X){Q/v*lQ0a+hQ0i+rS0x,Q0`U3R.v9Q9RR3^/RR3Y.}Q&O!XQ*S$vU*}%|/S9TS+X&Q/VW+Y&R/W3]9XQ+b&aQ.R(tQ/T){S/a*P*RQ0P*|Q2p.WQ3T.yQ3[/RQ3f/`Q5n3UQ8{8lQ8|8mQ9U8zQ9V9SR9Y9WX%Ui$}/U/sT)T#y*iR,a'RQ,`'RR4d1Q^zO|}%t&{*i,ZR,n'TW%dm+h+r,QT)e$W0`_{O|}%t&{*i,Z^zO|}%t&{*i,ZQ&i!fQ*p%eQ+l&fQ+p&jQ0e+mQ3z0dQ5x3{Q6P4RQ7O5{Q7d6|Q7e7PR7l7cvrO|}!f%e%t&f&j&{*i+m,Z0d3{4R5{6|7P7cX,R&v,P,S0wQ,O&tR0l+wS+{&t+wQ0o+yQ0u+|U4U0m0n0pQ4]0sS6Q4V4WR7Q6R^vO|}%t&{*i,ZQ,i'TT,x'Z,}R*d%^^xO|}%t&{*i,ZQ,j'TT,y'Z,}^yO|}%t&{*i,ZT,z'Z,}Q-`'gR2X-aR-]'fR's!}[%[i%Y'x(x)O/sR/l*aQ(R#US-m'y'zR2b-nR-q'{R2d-o",
        nodeNames: "⚠ RawString > MacroName LineComment BlockComment PreprocDirective #include String EscapeSequence SystemLibString Identifier ArgumentList ( ConditionalExpression AssignmentExpression CallExpression PrimitiveType FieldExpression FieldIdentifier DestructorName TemplateMethod ScopedFieldIdentifier NamespaceIdentifier TemplateType TypeIdentifier ScopedTypeIdentifier ScopedNamespaceIdentifier :: NamespaceIdentifier TypeIdentifier TemplateArgumentList < TypeDescriptor const volatile restrict _Atomic mutable constexpr StructSpecifier struct MsDeclspecModifier __declspec ) VirtualSpecifier BaseClassClause Access , FieldDeclarationList { FieldDeclaration Attribute AttributeName Identifier AttributeArgs } [ ] UpdateOp ArithOp ArithOp ArithOp LogicOp BitOp BitOp BitOp CompareOp CompareOp CompareOp > CompareOp BitOp UpdateOp Number CharLiteral AttributeArgs virtual extern static register inline AttributeSpecifier __attribute__ PointerDeclarator MsBasedModifier __based MsPointerModifier FunctionDeclarator ParameterList ParameterDeclaration PointerDeclarator FunctionDeclarator Noexcept noexcept ThrowSpecifier throw TrailingReturnType AbstractPointerDeclarator AbstractFunctionDeclarator AbstractArrayDeclarator AbstractParenthesizedDeclarator AbstractReferenceDeclarator ArrayDeclarator ParenthesizedDeclarator ReferenceDeclarator ScopedIdentifier Identifier OperatorName operator ArithOp BitOp CompareOp LogicOp new delete TemplateFunction OperatorName operator StructuredBindingDeclarator OptionalParameterDeclaration VariadicParameterDeclaration VariadicDeclarator ReferenceDeclarator ArrayDeclarator ParenthesizedDeclarator ReferenceDeclarator BitfieldClause InitializerList InitializerPair SubscriptDesignator FieldDesignator TemplateDeclaration template TemplateParameterList TypeParameterDeclaration typename class OptionalTypeParameterDeclaration VariadicTypeParameterDeclaration TemplateTemplateParameterDeclaration AliasDeclaration using Declaration InitDeclarator FriendDeclaration friend FunctionDefinition MsCallModifier CompoundStatement LinkageSpecification DeclarationList CaseStatement case default LabeledStatement StatementIdentifier ExpressionStatement CommaExpression IfStatement if ConditionClause Declaration else SwitchStatement switch DoStatement do while ParenthesizedExpression WhileStatement ForStatement for ReturnStatement return BreakStatement break ContinueStatement continue GotoStatement goto TypeDefinition typedef PointerDeclarator FunctionDeclarator ArrayDeclarator ParenthesizedDeclarator ForRangeLoop TryStatement try CatchClause catch ThrowStatement NamespaceDefinition namespace UsingDeclaration StaticAssertDeclaration static_assert ConcatenatedString TemplateInstantiation FunctionDefinition ExplicitFunctionSpecifier explicit FieldInitializerList FieldInitializer DefaultMethodClause DeleteMethodClause FunctionDefinition OperatorCast Declaration union FunctionDefinition FunctionDefinition FunctionDefinition FunctionDefinition Declaration FunctionDefinition Declaration AccessSpecifier UnionSpecifier EnumSpecifier enum SizedTypeSpecifier TypeSize EnumeratorList Enumerator ClassSpecifier DependentType Decltype decltype auto ParameterPackExpansion ParameterPackExpansion FieldIdentifier PointerExpression SubscriptExpression BinaryExpression ArithOp LogicOp BitOp UnaryExpression LogicOp BitOp UpdateExpression CastExpression SizeofExpression sizeof CompoundLiteralExpression True False NULL NewExpression new NewDeclarator DeleteExpression delete LambdaExpression LambdaCaptureSpecifier ParameterPackExpansion nullptr this #define PreprocArg #if #ifdef #ifndef #else #endif #elif PreprocDirectiveName Macro Program",
        maxTerm: 380,
        nodeProps: [["group", -31, 1, 8, 11, 14, 15, 16, 18, 74, 75, 106, 116, 117, 169, 198, 234, 235, 236, 240, 243, 244, 245, 247, 248, 249, 250, 251, 254, 256, 258, 259, 260, "Expression", -12, 17, 24, 25, 26, 40, 219, 220, 222, 226, 227, 228, 230, "Type", -16, 149, 152, 155, 157, 159, 164, 166, 170, 171, 173, 175, 177, 179, 187, 188, 192, "Statement"]],
        propSources: [cppHighlighting],
        skippedNodes: [0, 3, 4, 5, 6, 7, 10, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 307, 308],
        repeatNodeCount: 37,
        tokenData: "%0W,TR!SOX$_XY'gYZ,cZ]$_]^)e^p$_pq'gqr,yrs.mst/[tu$_uv!/uvw!1gwx!3^xy!3{yz!4pz{!5e{|!6b|}!8Y}!O!8}!O!P!:x!P!Q!Nr!Q!R#2X!R![#Ew![!]$.t!]!^$0d!^!_$1X!_!`$;|!`!a$<w!a!b$?k!b!c$_!c!n$@`!n!o$Aq!o!w$@`!w!x$Aq!x!}$@`!}#O$D[#O#P$Ew#P#Q%$t#Q#R%&a#R#S$@`#S#T$_#T#i$@`#i#j%'^#j#o$@`#o#p%(u#p#q%)j#q#r%+d#r#s%,X#s~$_$O$hW(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_#|%XU(cW&p#tOY%QZw%Qwx%kx#O%Q#O#P%|#P~%Q#t%pS&p#tOY%kZ#O%k#O#P%|#P~%k#t&RV&p#tOY%kYZ%kZ]%k]^&h^#O%k#O#P%|#P~%k#t&mT&p#tOY%kYZ%kZ#O%k#O#P%|#P~%k#v'TU'vQ&p#tOY&|Zr&|rs%ks#O&|#O#P%|#P~&|,T't^(cW'vQ't'q&p#t)[%WOX$_XY'gYZ(pZ]$_]^)e^p$_pq'gqr$_rs%Qsw$_wx&|x#O$_#O#P*l#P~$_'q(uT't'qXY(pYZ(p]^(ppq(p#O#P)U'q)XQYZ(p]^)_'q)bPYZ(p*q)p^(cW'vQ't'q&p#tOX$_XY)eYZ(pZ]$_]^)e^p$_pq)eqr$_rs%Qsw$_wx&|x#O$_#O#P*l#P~$_*g*qV&p#tOY%kYZ+WZ]%k]^+}^#O%k#O#P%|#P~%k*g+_Y't'q&p#tOX%kXY+WYZ(pZ]%k]^+W^p%kpq+Wq#O%k#O#P*l#P~%k*g,ST&p#tOY%kYZ+WZ#O%k#O#P%|#P~%k+y,jT)X%W't'qXY(pYZ(p]^(ppq(p#O#P)U*m-WY#ep&ZP(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!_$_!_!`-v!`#O$_#O#P%|#P~$_*m.TW#dp!e&{(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_+_.xU(cW'wQ'u(_&p#tOY%QZw%Qwx%kx#O%Q#O#P%|#P~%Q*q/ed(cW'vQ&p#tOX$_XY/[Zp$_pq/[qr$_rs%Qsw$_wx&|x!c$_!c!}0s!}#O$_#O#P%|#P#T$_#T#W0s#W#X2Q#X#Y:d#Y#]0s#]#^Hj#^#o0s#o~$_*q1O`(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#o0s#o~$_*q2]b(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#X0s#X#Y3e#Y#o0s#o~$_*q3pb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#Y0s#Y#Z4x#Z#o0s#o~$_*q5Tb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#]0s#]#^6]#^#o0s#o~$_*q6hb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#b0s#b#c7p#c#o0s#o~$_*q7{b(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#X0s#X#Y9T#Y#o0s#o~$_*q9b`(cW'vQ&o'q&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#o0s#o~$_*q:od(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#`0s#`#a;}#a#b0s#b#cCO#c#o0s#o~$_*q<Yd(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#]0s#]#^=h#^#g0s#g#h@[#h#o0s#o~$_*q=sb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#Y0s#Y#Z>{#Z#o0s#o~$_*q?Y`(cW'vQ&p#t&v'q&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#o0s#o~$_*q@gb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#X0s#X#YAo#Y#o0s#o~$_*qA|`(cW'vQ&t'q&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#o0s#o~$_*qCZb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#W0s#W#XDc#X#o0s#o~$_*qDnb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#]0s#]#^Ev#^#o0s#o~$_*qFRb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#Y0s#Y#ZGZ#Z#o0s#o~$_*qGh`(cW'vQ&p#t&u'q&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#o0s#o~$_*qHud(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#Y0s#Y#ZJT#Z#b0s#b#c!'c#c#o0s#o~$_*qJbd(cW'vQ&q'q&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#W0s#W#XKp#X#b0s#b#c! w#c#o0s#o~$_*qK{b(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#X0s#X#YMT#Y#o0s#o~$_*qM`b(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#Y0s#Y#ZNh#Z#o0s#o~$_*qNu`(cW'vQ&r'q&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#o0s#o~$_*q!!Sb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#W0s#W#X!#[#X#o0s#o~$_*q!#gb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#X0s#X#Y!$o#Y#o0s#o~$_*q!$zb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#Y0s#Y#Z!&S#Z#o0s#o~$_*q!&a`(cW'vQ&s'q&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#o0s#o~$_*q!'nb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#V0s#V#W!(v#W#o0s#o~$_*q!)Rb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#`0s#`#a!*Z#a#o0s#o~$_*q!*fb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#i0s#i#j!+n#j#o0s#o~$_*q!+yb(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#W0s#W#X!-R#X#o0s#o~$_*q!-^b(cW'vQ&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#X0s#X#Y!.f#Y#o0s#o~$_*q!.s`(cW'vQV'q&p#t&w'qOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![0s![!c$_!c!}0s!}#O$_#O#P%|#P#R$_#R#S0s#S#T$_#T#o0s#o~$_*m!0SY(cW'vQ#bp!`&{&p#tOY$_Zr$_rs%Qsw$_wx&|x!_$_!_!`!0r!`#O$_#O#P%|#P~$_*m!0}W!k'm(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_*m!1tZ(`&{(cW'vQ#cp&p#tOY$_Zr$_rs%Qsv$_vw!2gwx&|x!_$_!_!`!0r!`#O$_#O#P%|#P~$_*m!2tW(_&{#ep(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_)w!3iU(dS'vQ(b&{&p#tOY&|Zr&|rs%ks#O&|#O#P%|#P~&|,T!4WW(cW'vQ]+y&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_$a!4{W|a(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_*m!5rY(]&{(cW'vQ#bp&p#tOY$_Zr$_rs%Qsw$_wx&|x!_$_!_!`!0r!`#O$_#O#P%|#P~$_*m!6o[(cW'vQ#bp!^&{&p#tOY$_Zr$_rs%Qsw$_wx&|x{$_{|!7e|!_$_!_!`!0r!`#O$_#O#P%|#P~$_*m!7pW(cW!]'m'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_*P!8eW!Q'P(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_*m!9[](cW'vQ#bp!^&{&p#tOY$_Zr$_rs%Qsw$_wx&|x}$_}!O!7e!O!_$_!_!`!0r!`!a!:T!a#O$_#O#P%|#P~$_*m!:`W(O'm(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_*P!;T[(cW'vQ&p#t'}&{OY$_Zr$_rs%Qsw$_wx&|x!O$_!O!P!;y!P!Q$_!Q![!=g![#O$_#O#P%|#P~$_*P!<SY(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!O$_!O!P!<r!P#O$_#O#P%|#P~$_*P!<}W(W'P(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_){!=rl(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx!?jx!Q$_!Q![!=g![!g$_!g!h!HY!h!i!MX!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#X$_#X#Y!HY#Y#Z!MX#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j~$_)s!?qW'vQ&p#tOY&|Zr&|rs%ks!Q&|!Q![!@Z![#O&|#O#P%|#P~&|)s!@dl'vQ!l&{&p#tOY&|Zr&|rs%ksw&|wx!?jx!Q&|!Q![!@Z![!g&|!g!h!B[!h!i!Fw!i!n&|!n!o!Fw!o!r&|!r!s!B[!s!w&|!w!x!Fw!x#O&|#O#P%|#P#X&|#X#Y!B[#Y#Z!Fw#Z#`&|#`#a!Fw#a#d&|#d#e!B[#e#i&|#i#j!Fw#j~&|)s!Bej'vQ!l&{&p#tOY&|Zr&|rs%ks{&|{|!DV|}&|}!O!DV!O!Q&|!Q![!ES![!c&|!c!h!ES!h!i!ES!i!n&|!n!o!Fw!o!w&|!w!x!Fw!x#O&|#O#P%|#P#T&|#T#Y!ES#Y#Z!ES#Z#`&|#`#a!Fw#a#i&|#i#j!Fw#j~&|)s!D^['vQ&p#tOY&|Zr&|rs%ks!Q&|!Q![!ES![!c&|!c!i!ES!i#O&|#O#P%|#P#T&|#T#Z!ES#Z~&|)s!E]h'vQ!l&{&p#tOY&|Zr&|rs%ksw&|wx!DVx!Q&|!Q![!ES![!c&|!c!h!ES!h!i!ES!i!n&|!n!o!Fw!o!w&|!w!x!Fw!x#O&|#O#P%|#P#T&|#T#Y!ES#Y#Z!ES#Z#`&|#`#a!Fw#a#i&|#i#j!Fw#j~&|)s!GQb'vQ!l&{&p#tOY&|Zr&|rs%ks!h&|!h!i!Fw!i!n&|!n!o!Fw!o!w&|!w!x!Fw!x#O&|#O#P%|#P#Y&|#Y#Z!Fw#Z#`&|#`#a!Fw#a#i&|#i#j!Fw#j~&|){!Hel(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx&|x{$_{|!J]|}$_}!O!J]!O!Q$_!Q![!Kb![!c$_!c!h!Kb!h!i!Kb!i!n$_!n!o!MX!o!w$_!w!x!MX!x#O$_#O#P%|#P#T$_#T#Y!Kb#Y#Z!Kb#Z#`$_#`#a!MX#a#i$_#i#j!MX#j~$_){!Jf^(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![!Kb![!c$_!c!i!Kb!i#O$_#O#P%|#P#T$_#T#Z!Kb#Z~$_){!Kmh(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx!DVx!Q$_!Q![!Kb![!c$_!c!h!Kb!h!i!Kb!i!n$_!n!o!MX!o!w$_!w!x!MX!x#O$_#O#P%|#P#T$_#T#Y!Kb#Y#Z!Kb#Z#`$_#`#a!MX#a#i$_#i#j!MX#j~$_){!Mdd(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx&|x!h$_!h!i!MX!i!n$_!n!o!MX!o!w$_!w!x!MX!x#O$_#O#P%|#P#Y$_#Y#Z!MX#Z#`$_#`#a!MX#a#i$_#i#j!MX#j~$_,T# P^(cW'vQ#bp!`&{&p#tOY$_Zr$_rs%Qsw$_wx&|xz$_z{# {{!P$_!P!Q#,r!Q!_$_!_!`!0r!`#O$_#O#P%|#P~$_,T#!UZ(cW'vQ&p#tOY# {YZ#!wZr# {rs##lsw# {wx#(rxz# {z{#*{{#O# {#O#P#&P#P~# {)T#!zROz#!wz{##T{~#!w)T##WTOz#!wz{##T{!P#!w!P!Q##g!Q~#!w)T##lOT)T,R##sX(cW&p#tOY##lYZ#!wZw##lwx#$`xz##lz{#']{#O##l#O#P#&P#P~##l+y#$eV&p#tOY#$`YZ#!wZz#$`z{#$z{#O#$`#O#P#&P#P~#$`+y#%PX&p#tOY#$`YZ#!wZz#$`z{#$z{!P#$`!P!Q#%l!Q#O#$`#O#P#&P#P~#$`+y#%sST)T&p#tOY%kZ#O%k#O#P%|#P~%k+y#&UX&p#tOY#$`YZ#$`Z]#$`]^#&q^z#$`z{#$z{#O#$`#O#P#&P#P~#$`+y#&vV&p#tOY#$`YZ#$`Zz#$`z{#$z{#O#$`#O#P#&P#P~#$`,R#'dZ(cW&p#tOY##lYZ#!wZw##lwx#$`xz##lz{#']{!P##l!P!Q#(V!Q#O##l#O#P#&P#P~##l,R#(`U(cWT)T&p#tOY%QZw%Qwx%kx#O%Q#O#P%|#P~%Q+{#(yX'vQ&p#tOY#(rYZ#!wZr#(rrs#$`sz#(rz{#)f{#O#(r#O#P#&P#P~#(r+{#)mZ'vQ&p#tOY#(rYZ#!wZr#(rrs#$`sz#(rz{#)f{!P#(r!P!Q#*`!Q#O#(r#O#P#&P#P~#(r+{#*iU'vQT)T&p#tOY&|Zr&|rs%ks#O&|#O#P%|#P~&|,T#+U](cW'vQ&p#tOY# {YZ#!wZr# {rs##lsw# {wx#(rxz# {z{#*{{!P# {!P!Q#+}!Q#O# {#O#P#&P#P~# {,T#,YW(cW'vQT)T&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_,T#,}W(cW'vQS)T&p#tOY#,rZr#,rrs#-gsw#,rwx#1lx#O#,r#O#P#.g#P~#,r,R#-pU(cWS)T&p#tOY#-gZw#-gwx#.Sx#O#-g#O#P#.g#P~#-g+y#.ZSS)T&p#tOY#.SZ#O#.S#O#P#.g#P~#.S+y#.nVS)T&p#tOY#.SYZ%kZ]#.S]^#/T^#O#.S#O#P#/k#P~#.S+y#/[TS)T&p#tOY#.SYZ%kZ#O#.S#O#P#.g#P~#.S+y#/rZS)T&p#tOY#.SYZ%kZ]#.S]^#/T^#O#.S#O#P#/k#P#b#.S#b#c#.S#c#f#.S#f#g#0e#g~#.S+y#0lSS)T&p#tOY#.SZ#O#.S#O#P#0x#P~#.S+y#1PXS)T&p#tOY#.SYZ%kZ]#.S]^#/T^#O#.S#O#P#/k#P#b#.S#b#c#.S#c~#.S+{#1uU'vQS)T&p#tOY#1lZr#1lrs#.Ss#O#1l#O#P#.g#P~#1l){#2dr(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx#4nx!O$_!O!P#?O!P!Q$_!Q![#Ew![!g$_!g!h!HY!h!i!MX!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#U$_#U#V#HQ#V#X$_#X#Y!HY#Y#Z!MX#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j#l$_#l#m$*y#m~$_)s#4uW'vQ&p#tOY&|Zr&|rs%ks!Q&|!Q![#5_![#O&|#O#P%|#P~&|)s#5hn'vQ!l&{&p#tOY&|Zr&|rs%ksw&|wx#4nx!O&|!O!P#7f!P!Q&|!Q![#5_![!g&|!g!h!B[!h!i!Fw!i!n&|!n!o!Fw!o!r&|!r!s!B[!s!w&|!w!x!Fw!x#O&|#O#P%|#P#X&|#X#Y!B[#Y#Z!Fw#Z#`&|#`#a!Fw#a#d&|#d#e!B[#e#i&|#i#j!Fw#j~&|)s#7ol'vQ!l&{&p#tOY&|Zr&|rs%ks!Q&|!Q![#9g![!c&|!c!g#9g!g!h#<k!h!i#9g!i!n&|!n!o!Fw!o!r&|!r!s!B[!s!w&|!w!x!Fw!x#O&|#O#P%|#P#T&|#T#X#9g#X#Y#<k#Y#Z#9g#Z#`&|#`#a!Fw#a#d&|#d#e!B[#e#i&|#i#j!Fw#j~&|)s#9pn'vQ!l&{&p#tOY&|Zr&|rs%ksw&|wx#;nx!Q&|!Q![#9g![!c&|!c!g#9g!g!h#<k!h!i#9g!i!n&|!n!o!Fw!o!r&|!r!s!B[!s!w&|!w!x!Fw!x#O&|#O#P%|#P#T&|#T#X#9g#X#Y#<k#Y#Z#9g#Z#`&|#`#a!Fw#a#d&|#d#e!B[#e#i&|#i#j!Fw#j~&|)s#;u['vQ&p#tOY&|Zr&|rs%ks!Q&|!Q![#9g![!c&|!c!i#9g!i#O&|#O#P%|#P#T&|#T#Z#9g#Z~&|)s#<tr'vQ!l&{&p#tOY&|Zr&|rs%ksw&|wx#;nx{&|{|!DV|}&|}!O!DV!O!Q&|!Q![#9g![!c&|!c!g#9g!g!h#<k!h!i#9g!i!n&|!n!o!Fw!o!r&|!r!s!B[!s!w&|!w!x!Fw!x#O&|#O#P%|#P#T&|#T#X#9g#X#Y#<k#Y#Z#9g#Z#`&|#`#a!Fw#a#d&|#d#e!B[#e#i&|#i#j!Fw#j~&|){#?Zn(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![#AX![!c$_!c!g#AX!g!h#Cb!h!i#AX!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#T$_#T#X#AX#X#Y#Cb#Y#Z#AX#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j~$_){#Adn(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx#;nx!Q$_!Q![#AX![!c$_!c!g#AX!g!h#Cb!h!i#AX!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#T$_#T#X#AX#X#Y#Cb#Y#Z#AX#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j~$_){#Cmr(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx#;nx{$_{|!J]|}$_}!O!J]!O!Q$_!Q![#AX![!c$_!c!g#AX!g!h#Cb!h!i#AX!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#T$_#T#X#AX#X#Y#Cb#Y#Z#AX#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j~$_){#FSn(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx#4nx!O$_!O!P#?O!P!Q$_!Q![#Ew![!g$_!g!h!HY!h!i!MX!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#X$_#X#Y!HY#Y#Z!MX#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j~$_){#HZ](cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!O$_!O!P#IS!P!Q$_!Q!R#I{!R![#Ew![#O$_#O#P%|#P~$_){#I]Y(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![!=g![#O$_#O#P%|#P~$_){#JWr(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx#4nx!O$_!O!P#?O!P!Q$_!Q![#Ew![!g$_!g!h!HY!h!i!MX!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#U$_#U#V#Lb#V#X$_#X#Y!HY#Y#Z!MX#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j#l$_#l#m#MZ#m~$_){#LkY(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![#Ew![#O$_#O#P%|#P~$_){#Md^(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![#N`![!c$_!c!i#N`!i#O$_#O#P%|#P#T$_#T#Z#N`#Z~$_){#Nkp(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx$!ox!O$_!O!P#?O!P!Q$_!Q![#N`![!c$_!c!g#N`!g!h$(a!h!i#N`!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#T$_#T#X#N`#X#Y$(a#Y#Z#N`#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j~$_)s$!v['vQ&p#tOY&|Zr&|rs%ks!Q&|!Q![$#l![!c&|!c!i$#l!i#O&|#O#P%|#P#T&|#T#Z$#l#Z~&|)s$#up'vQ!l&{&p#tOY&|Zr&|rs%ksw&|wx$!ox!O&|!O!P#7f!P!Q&|!Q![$#l![!c&|!c!g$#l!g!h$%y!h!i$#l!i!n&|!n!o!Fw!o!r&|!r!s!B[!s!w&|!w!x!Fw!x#O&|#O#P%|#P#T&|#T#X$#l#X#Y$%y#Y#Z$#l#Z#`&|#`#a!Fw#a#d&|#d#e!B[#e#i&|#i#j!Fw#j~&|)s$&Ss'vQ!l&{&p#tOY&|Zr&|rs%ksw&|wx$!ox{&|{|!DV|}&|}!O!DV!O!P#7f!P!Q&|!Q![$#l![!c&|!c!g$#l!g!h$%y!h!i$#l!i!n&|!n!o!Fw!o!r&|!r!s!B[!s!w&|!w!x!Fw!x#O&|#O#P%|#P#T&|#T#X$#l#X#Y$%y#Y#Z$#l#Z#`&|#`#a!Fw#a#d&|#d#e!B[#e#i&|#i#j!Fw#j~&|){$(ls(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx$!ox{$_{|!J]|}$_}!O!J]!O!P#?O!P!Q$_!Q![#N`![!c$_!c!g#N`!g!h$(a!h!i#N`!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#T$_#T#X#N`#X#Y$(a#Y#Z#N`#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j~$_){$+Sa(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!O$_!O!P#IS!P!Q$_!Q!R$,X!R![#N`![!c$_!c!i#N`!i#O$_#O#P%|#P#T$_#T#Z#N`#Z~$_){$,dt(cW'vQ!l&{&p#tOY$_Zr$_rs%Qsw$_wx$!ox!O$_!O!P#?O!P!Q$_!Q![#N`![!c$_!c!g#N`!g!h$(a!h!i#N`!i!n$_!n!o!MX!o!r$_!r!s!HY!s!w$_!w!x!MX!x#O$_#O#P%|#P#T$_#T#U#N`#U#V#N`#V#X#N`#X#Y$(a#Y#Z#N`#Z#`$_#`#a!MX#a#d$_#d#e!HY#e#i$_#i#j!MX#j#l$_#l#m#MZ#m~$_*q$/PY'|&{(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x![$_![!]$/o!]#O$_#O#P%|#P~$_*q$/zWl'q(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_){$0oW(a&{(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_,P$1f[p&{#dp(cW'vQ&p#tOY$2[Zr$2[rs$3Tsw$2[wx$7Tx!^$2[!^!_$9U!_!`$;P!`!a$8a!a#O$2[#O#P$4p#P~$2[%b$2eY(cW'vQ&p#tOY$2[Zr$2[rs$3Tsw$2[wx$7Tx!`$2[!`!a$8a!a#O$2[#O#P$4p#P~$2[%`$3[W(cW&p#tOY$3TZw$3Twx$3tx!`$3T!`!a$6h!a#O$3T#O#P$4p#P~$3T%W$3yU&p#tOY$3tZ!`$3t!`!a$4]!a#O$3t#O#P$4p#P~$3t%W$4dSY!b&p#tOY%kZ#O%k#O#P%|#P~%k%W$4uV&p#tOY$3tYZ$3tZ]$3t]^$5[^#O$3t#O#P$5v#P~$3t%W$5aV&p#tOY$3tYZ%kZ!`$3t!`!a$4]!a#O$3t#O#P$4p#P~$3t%W$5{X&p#tOY$3tYZ%kZ]$3t]^$5[^!`$3t!`!a$4]!a#O$3t#O#P$4p#P~$3t%`$6qUY!b(cW&p#tOY%QZw%Qwx%kx#O%Q#O#P%|#P~%Q%Y$7[W'vQ&p#tOY$7TZr$7Trs$3ts!`$7T!`!a$7t!a#O$7T#O#P$4p#P~$7T%Y$7}UY!b'vQ&p#tOY&|Zr&|rs%ks#O&|#O#P%|#P~&|%b$8lWY!b(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_,P$9cZ(cW'vQ#cp!j&{&p#tOY$2[Zr$2[rs$3Tsw$2[wx$7Tx!_$2[!_!`$:U!`!a$8a!a#O$2[#O#P$4p#P~$2[,P$:aY!k'm(cW'vQ&p#tOY$2[Zr$2[rs$3Tsw$2[wx$7Tx!`$2[!`!a$8a!a#O$2[#O#P$4p#P~$2[,P$;^Y#dp!f&{(cW'vQ&p#tOY$2[Zr$2[rs$3Tsw$2[wx$7Tx!`$2[!`!a$8a!a#O$2[#O#P$4p#P~$2[*m$<XY(mq(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!_$_!_!`-v!`#O$_#O#P%|#P~$_*m$=UZ#dp(cW'vQ!h&{&p#tOY$_Zr$_rs%Qsw$_wx&|x!_$_!_!`$=w!`!a$>n!a#O$_#O#P%|#P~$_*m$>UW#dp!f&{(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_*m$>{Y(cW'vQ#cp!j&{&p#tOY$_Zr$_rs%Qsw$_wx&|x!_$_!_!`!0r!`#O$_#O#P%|#P~$_$P$?vW'{P(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_,T$@o`(cW(PS'vQ!W&z'x#T&p#tOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![$@`![!c$_!c!}$@`!}#O$_#O#P%|#P#R$_#R#S$@`#S#T$_#T#o$@`#o~$_,T$BQ`(cW(PS'vQ!W&z'x#T&p#tOY$_Zr$_rs$CSsw$_wx$Cox!Q$_!Q![$@`![!c$_!c!}$@`!}#O$_#O#P%|#P#R$_#R#S$@`#S#T$_#T#o$@`#o~$_+]$C]U(cW'u(_&p#tOY%QZw%Qwx%kx#O%Q#O#P%|#P~%Q)s$CxU'vQ(b&{&p#tOY&|Zr&|rs%ks#O&|#O#P%|#P~&|*m$DgX!Z'm(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x!}$_!}#O$ES#O#P%|#P~$_$P$E_W(YP(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_*q$E|_&p#tOY$F{YZ$G`Z]$F{]^$HX^!Q$F{!Q![$Ho![!w$F{!w!x$Is!x#O$F{#O#P% w#P#i$F{#i#j$Lu#j#l$F{#l#m%!e#m~$F{$O$GSSXY&p#tOY%kZ#O%k#O#P%|#P~%k*q$GiYXY't'q&p#tOX%kXY+WYZ(pZ]%k]^+W^p%kpq+Wq#O%k#O#P*l#P~%k*q$H`TXY&p#tOY%kYZ+WZ#O%k#O#P%|#P~%k$O$HvUXY&p#tOY%kZ!Q%k!Q![$IY![#O%k#O#P%|#P~%k$O$IaUXY&p#tOY%kZ!Q%k!Q![$F{![#O%k#O#P%|#P~%k$O$IxY&p#tOY%kZ!Q%k!Q![$Jh![!c%k!c!i$Jh!i#O%k#O#P%|#P#T%k#T#Z$Jh#Z~%k$O$JmY&p#tOY%kZ!Q%k!Q![$K]![!c%k!c!i$K]!i#O%k#O#P%|#P#T%k#T#Z$K]#Z~%k$O$KbY&p#tOY%kZ!Q%k!Q![$LQ![!c%k!c!i$LQ!i#O%k#O#P%|#P#T%k#T#Z$LQ#Z~%k$O$LVY&p#tOY%kZ!Q%k!Q![$Lu![!c%k!c!i$Lu!i#O%k#O#P%|#P#T%k#T#Z$Lu#Z~%k$O$LzY&p#tOY%kZ!Q%k!Q![$Mj![!c%k!c!i$Mj!i#O%k#O#P%|#P#T%k#T#Z$Mj#Z~%k$O$MoY&p#tOY%kZ!Q%k!Q![$N_![!c%k!c!i$N_!i#O%k#O#P%|#P#T%k#T#Z$N_#Z~%k$O$NdY&p#tOY%kZ!Q%k!Q![% S![!c%k!c!i% S!i#O%k#O#P%|#P#T%k#T#Z% S#Z~%k$O% XY&p#tOY%kZ!Q%k!Q![$F{![!c%k!c!i$F{!i#O%k#O#P%|#P#T%k#T#Z$F{#Z~%k$O%!OVXY&p#tOY%kYZ%kZ]%k]^&h^#O%k#O#P%|#P~%k$O%!jY&p#tOY%kZ!Q%k!Q![%#Y![!c%k!c!i%#Y!i#O%k#O#P%|#P#T%k#T#Z%#Y#Z~%k$O%#_Y&p#tOY%kZ!Q%k!Q![%#}![!c%k!c!i%#}!i#O%k#O#P%|#P#T%k#T#Z%#}#Z~%k$O%$UYXY&p#tOY%kZ!Q%k!Q![%#}![!c%k!c!i%#}!i#O%k#O#P%|#P#T%k#T#Z%#}#Z~%k*P%%PX![&k(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P#Q%%l#Q~$_$d%%wW(ed(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_*m%&nY(cW'vQ#cp&p#t!c&{OY$_Zr$_rs%Qsw$_wx&|x!_$_!_!`!0r!`#O$_#O#P%|#P~$_,T%'mb(cW(PS'vQ!W&z'x#T&p#tOY$_Zr$_rs$CSsw$_wx$Cox!Q$_!Q!Y$@`!Y!Z$Aq!Z![$@`![!c$_!c!}$@`!}#O$_#O#P%|#P#R$_#R#S$@`#S#T$_#T#o$@`#o~$_){%)QW!S&{(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_*m%)w[(cW'vQ#cp&p#t!b&{OY$_Zr$_rs%Qsw$_wx&|x!_$_!_!`!0r!`#O$_#O#P%|#P#p$_#p#q%*m#q~$_*m%*zW(^&{#ep(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_$a%+oW!Ya(cW'vQ&p#tOY$_Zr$_rs%Qsw$_wx&|x#O$_#O#P%|#P~$_$u%,fa(cW'vQ#cp&[P&p#tOX$_XY%-kZp$_pq%-kqr$_rs%Qsw$_wx&|x!c$_!c!}%.y!}#O$_#O#P%|#P#R$_#R#S%.y#S#T$_#T#o%.y#o~$_$T%-ta(cW'vQ&p#tOX$_XY%-kZp$_pq%-kqr$_rs%Qsw$_wx&|x!c$_!c!}%.y!}#O$_#O#P%|#P#R$_#R#S%.y#S#T$_#T#o%.y#o~$_$T%/U`(cW'vQdT&p#tOY$_Zr$_rs%Qsw$_wx&|x!Q$_!Q![%.y![!c$_!c!}%.y!}#O$_#O#P%|#P#R$_#R#S%.y#S#T$_#T#o%.y#o~$_",
        tokenizers: [rawString, fallback, 0, 1, 2, 3, 4, 5, 6, 7, 8],
        topRules: {
            "Program": [0, 271]
        },
        dynamicPrecedences: {
            "84": 1,
            "91": 1,
            "98": 1,
            "104": -10,
            "105": 1,
            "119": -1,
            "125": -10,
            "126": 1,
            "183": 1,
            "186": -10,
            "227": -1,
            "231": 2,
            "232": 2,
            "270": -10,
            "325": 3,
            "369": 1,
            "370": 3,
            "371": 1,
            "372": 1
        },
        specialized: [{
            term: 316,
            get: value => spec_identifier$3[value] || -1
        }, {
            term: 32,
            get: value => spec_[value] || -1
        }, {
            term: 70,
            get: value => spec_templateArgsEnd[value] || -1
        }, {
            term: 323,
            get: value => spec_scopedIdentifier[value] || -1
        }],
        tokenPrec: 21623
    });
    const cppLanguage = LRLanguage.define({
        parser: parser$a.configure({
            props: [indentNodeProp.add({
                IfStatement: continuedIndent({
                    except: /^\s*({|else\b)/
                }),
                TryStatement: continuedIndent({
                    except: /^\s*({|catch)\b/
                }),
                LabeledStatement: flatIndent,
                CaseStatement: context => context.baseIndent + context.unit,
                BlockComment: () => null,
                CompoundStatement: delimitedIndent({
                    closing: "}"
                }),
                Statement: continuedIndent({
                    except: /^{/
                })
            }), foldNodeProp.add({
                "DeclarationList CompoundStatement EnumeratorList FieldDeclarationList InitializerList": foldInside,
                BlockComment(tree) {
                    return {
                        from: tree.from + 2,
                        to: tree.to - 2
                    };
                }
            })]
        }),
        languageData: {
            commentTokens: {
                line: "//",
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            indentOnInput: /^\s*(?:case |default:|\{|\})$/
        }
    });
    function cpp() {
        return new LanguageSupport(cppLanguage);
    }
    var _m12 = Object.freeze({
        __proto__: null,
        cpp: cpp,
        cppLanguage: cppLanguage
    });
    const castOpen = 1,
        HeredocString = 2,
        interpolatedStringContent = 263,
        EscapeSequence = 3,
        afterInterpolation = 264,
        automaticSemicolon = 265,
        eof$1 = 266,
        abstract = 4,
        and = 5,
        array = 6,
        as = 7,
        Boolean = 8,
        _break = 9,
        _case = 10,
        _catch = 11,
        clone = 12,
        _const = 13,
        _continue = 14,
        _default = 15,
        declare = 16,
        _do = 17,
        echo = 18,
        _else = 19,
        elseif = 20,
        enddeclare = 21,
        endfor = 22,
        endforeach = 23,
        endif = 24,
        endswitch = 25,
        endwhile = 26,
        _enum = 27,
        _extends = 28,
        final = 29,
        _finally = 30,
        fn = 31,
        _for = 32,
        foreach = 33,
        from = 34,
        _function = 35,
        global$1 = 36,
        goto = 37,
        _if = 38,
        _implements = 39,
        include = 40,
        include_once = 41,
        _instanceof = 42,
        insteadof = 43,
        _interface = 44,
        list = 45,
        match = 46,
        namespace = 47,
        _new = 48,
        _null = 49,
        or = 50,
        print = 51,
        require = 52,
        require_once = 53,
        _return = 54,
        _switch = 55,
        _throw = 56,
        trait = 57,
        _try = 58,
        unset = 59,
        use = 60,
        _var = 61,
        Visibility = 62,
        _while = 63,
        xor = 64,
        _yield = 65;
    const keywordMap = {
        abstract,
        and,
        array,
        as,
        true: Boolean,
        false: Boolean,
        break: _break,
        case: _case,
        catch: _catch,
        clone,
        const: _const,
        continue: _continue,
        declare,
        default: _default,
        do: _do,
        echo,
        else: _else,
        elseif,
        enddeclare,
        endfor,
        endforeach,
        endif,
        endswitch,
        endwhile,
        enum: _enum,
        extends: _extends,
        final,
        finally: _finally,
        fn,
        for: _for,
        foreach,
        from,
        function: _function,
        global: global$1,
        goto,
        if: _if,
        implements: _implements,
        include,
        include_once,
        instanceof: _instanceof,
        insteadof,
        interface: _interface,
        list,
        match,
        namespace,
        new: _new,
        null: _null,
        or,
        print,
        require,
        require_once,
        return: _return,
        switch: _switch,
        throw: _throw,
        trait,
        try: _try,
        unset,
        use,
        var: _var,
        public: Visibility,
        private: Visibility,
        protected: Visibility,
        while: _while,
        xor,
        yield: _yield,
        __proto__: null
    };
    function keywords$1(name) {
        let found = keywordMap[name.toLowerCase()];
        return found == null ? -1 : found;
    }
    function isSpace$2(ch) {
        return ch == 9 || ch == 10 || ch == 13 || ch == 32;
    }
    function isASCIILetter(ch) {
        return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
    }
    function isIdentifierStart(ch) {
        return ch == 95 || ch >= 0x80 || isASCIILetter(ch);
    }
    function isHex(ch) {
        return ch >= 48 && ch <= 55 || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70;
    }
    const castTypes = {
        int: true,
        integer: true,
        bool: true,
        boolean: true,
        float: true,
        double: true,
        real: true,
        string: true,
        array: true,
        object: true,
        unset: true,
        __proto__: null
    };
    const expression = new ExternalTokenizer(input => {
        if (input.next == 40) {
            input.advance();
            let peek = 0;
            while (isSpace$2(input.peek(peek)))
                peek++;
            let name = "",
                next;
            while (isASCIILetter(next = input.peek(peek))) {
                name += String.fromCharCode(next);
                peek++;
            }
            while (isSpace$2(input.peek(peek)))
                peek++;
            if (input.peek(peek) == 41 && castTypes[name.toLowerCase()])
                input.acceptToken(castOpen);
        } else if (input.next == 60 && input.peek(1) == 60 && input.peek(2) == 60) {
            for (let i = 0; i < 3; i++)
                input.advance();
            while (input.next == 32 || input.next == 9)
                input.advance();
            let quoted = input.next == 39;
            if (quoted)
                input.advance();
            if (!isIdentifierStart(input.next))
                return;
            let tag = String.fromCharCode(input.next);
            for (;;) {
                input.advance();
                if (!isIdentifierStart(input.next) && !(input.next >= 48 && input.next <= 55))
                    break;
                tag += String.fromCharCode(input.next);
            }
            if (quoted) {
                if (input.next != 39)
                    return;
                input.advance();
            }
            if (input.next != 10 && input.next != 13)
                return;
            for (;;) {
                let lineStart = input.next == 10 || input.next == 13;
                input.advance();
                if (input.next < 0)
                    return;
                if (lineStart) {
                    while (input.next == 32 || input.next == 9)
                        input.advance();
                    let match = true;
                    for (let i = 0; i < tag.length; i++) {
                        if (input.next != tag.charCodeAt(i)) {
                            match = false;
                            break;
                        }
                        input.advance();
                    }
                    if (match)
                        return input.acceptToken(HeredocString);
                }
            }
        }
    });
    const eofToken = new ExternalTokenizer(input => {
        if (input.next < 0)
            input.acceptToken(eof$1);
    });
    const semicolon = new ExternalTokenizer((input, stack) => {
        if (input.next == 63 && stack.canShift(automaticSemicolon) && input.peek(1) == 62)
            input.acceptToken(automaticSemicolon);
    });
    function scanEscape(input) {
        let after = input.peek(1);
        if (after == 110 || after == 114 || after == 116 || after == 118 || after == 101 || after == 102 || after == 92 || after == 36 || after == 34 || after == 123)
            return 2;
        if (after >= 48 && after <= 55) {
            let size = 2,
                next;
            while (size < 5 && (next = input.peek(size)) >= 48 && next <= 55)
                size++;
            return size;
        }
        if (after == 120 && isHex(input.peek(2))) {
            return isHex(input.peek(3)) ? 4 : 3;
        }
        if (after == 117 && input.peek(2) == 123) {
            for (let size = 3; ; size++) {
                let next = input.peek(size);
                if (next == 125)
                    return size == 2 ? 0 : size + 1;
                if (!isHex(next))
                    break;
            }
        }
        return 0;
    }
    const interpolated = new ExternalTokenizer((input, stack) => {
        let content = false;
        for (;; content = true) {
            if (input.next == 34 || input.next < 0 || input.next == 36 && (isIdentifierStart(input.peek(1)) || input.peek(1) == 123) || input.next == 123 && input.peek(1) == 36) {
                break;
            } else if (input.next == 92) {
                let escaped = scanEscape(input);
                if (escaped) {
                    if (content)
                        break;
                    else
                        return input.acceptToken(EscapeSequence, escaped);
                }
            } else if (!content && (input.next == 91 || input.next == 45 && input.peek(1) == 62 && isIdentifierStart(input.peek(2)) || input.next == 63 && input.peek(1) == 45 && input.peek(2) == 62 && isIdentifierStart(input.peek(3))) && stack.canShift(afterInterpolation)) {
                break;
            }
            input.advance();
        }
        if (content)
            input.acceptToken(interpolatedStringContent);
    });
    const phpHighlighting = styleTags({
        "Visibility abstract final static": tags$1.modifier,
        "for foreach while do if else elseif switch try catch finally return throw break continue default case": tags$1.controlKeyword,
        "endif endfor endforeach endswitch endwhile declare enddeclare goto match": tags$1.controlKeyword,
        "and or xor yield unset clone instanceof insteadof": tags$1.operatorKeyword,
        "function fn class trait implements extends const enum global interface use var": tags$1.definitionKeyword,
        "include include_once require require_once namespace": tags$1.moduleKeyword,
        "new from echo print array list as": tags$1.keyword,
        null: tags$1.null,
        Boolean: tags$1.bool,
        VariableName: tags$1.variableName,
        "NamespaceName/...": tags$1.namespace,
        "NamedType/...": tags$1.typeName,
        Name: tags$1.name,
        "CallExpression/Name": tags$1.function(tags$1.variableName),
        "LabelStatement/Name": tags$1.labelName,
        "MemberExpression/Name": tags$1.propertyName,
        "MemberExpression/VariableName": tags$1.special(tags$1.propertyName),
        "ScopedExpression/ClassMemberName/Name": tags$1.propertyName,
        "ScopedExpression/ClassMemberName/VariableName": tags$1.special(tags$1.propertyName),
        "CallExpression/MemberExpression/Name": tags$1.function(tags$1.propertyName),
        "CallExpression/ScopedExpression/ClassMemberName/Name": tags$1.function(tags$1.propertyName),
        "MethodDeclaration/Name": tags$1.function(tags$1.definition(tags$1.variableName)),
        "FunctionDefinition/Name": tags$1.function(tags$1.definition(tags$1.variableName)),
        "ClassDeclaration/Name": tags$1.definition(tags$1.className),
        UpdateOp: tags$1.updateOperator,
        ArithOp: tags$1.arithmeticOperator,
        LogicOp: tags$1.logicOperator,
        BitOp: tags$1.bitwiseOperator,
        CompareOp: tags$1.compareOperator,
        ControlOp: tags$1.controlOperator,
        AssignOp: tags$1.definitionOperator,
        "$ ConcatOp": tags$1.operator,
        LineComment: tags$1.lineComment,
        BlockComment: tags$1.blockComment,
        Integer: tags$1.integer,
        Float: tags$1.float,
        String: tags$1.string,
        ShellExpression: tags$1.special(tags$1.string),
        "=> ->": tags$1.punctuation,
        "( )": tags$1.paren,
        "#[ [ ]": tags$1.squareBracket,
        "${ { }": tags$1.brace,
        "-> ?->": tags$1.derefOperator,
        ", ; :: : \\": tags$1.separator,
        "PhpOpen PhpClose": tags$1.processingInstruction
    });
    const spec_Name = {
        __proto__: null,
        static: 311,
        STATIC: 311,
        class: 333,
        CLASS: 333
    };
    const parser$9 = LRParser.deserialize({
        version: 14,
        states: "$GSQ`OWOOQhQaOOP%oO`OOOOO#t'#H_'#H_O%tO#|O'#DtOOO#u'#Dw'#DwQ&SOWO'#DwO&XO$VOOOOQ#u'#Dx'#DxO&lQaO'#D|O(mQdO'#E}O(tQdO'#EQO*kQaO'#EWO,zQ`O'#ETO-PQ`O'#E^O/nQaO'#E^O/uQ`O'#EfO/zQ`O'#EoO*kQaO'#EoO0VQ`O'#HhO0[Q`O'#E{O0[Q`O'#E{OOQS'#Ic'#IcO0aQ`O'#EvOOQS'#IZ'#IZO2oQdO'#IWO6tQeO'#FUO*kQaO'#FeO*kQaO'#FfO*kQaO'#FgO*kQaO'#FhO*kQaO'#FhO*kQaO'#FkOOQO'#Id'#IdO7RQ`O'#FqOOQO'#Hi'#HiO7ZQ`O'#HOO7uQ`O'#FlO8QQ`O'#H]O8]Q`O'#FvO8eQaO'#FwO*kQaO'#GVO*kQaO'#GYO8}OrO'#G]OOQS'#Iq'#IqOOQS'#Ip'#IpOOQS'#IW'#IWO,zQ`O'#GdO,zQ`O'#GfO,zQ`O'#GkOhQaO'#GmO9UQ`O'#GnO9ZQ`O'#GqO9`Q`O'#GtO9eQeO'#GuO9eQeO'#GvO9eQeO'#GwO9oQ`O'#GxO9tQ`O'#GzO9yQaO'#G{O<YQ`O'#G|O<_Q`O'#G}O<dQ`O'#G}O9oQ`O'#HOO<iQ`O'#HQO<nQ`O'#HRO<sQ`O'#HSO<xQ`O'#HVO=TQ`O'#HWO9yQaO'#H[OOQ#u'#IV'#IVOOQ#u'#Ha'#HaQhQaOOO=fQ`O'#HPO7pQ`O'#HPO=kO#|O'#DrPOOO)CCw)CCwOOO#t-E;]-E;]OOO#u,5:c,5:cOOO#u'#H`'#H`O&XO$VOOO=vQ$VO'#IUOOOO'#IU'#IUQOOOOOOOQ#y,5:h,5:hO=}QaO,5:hOOQ#u,5:j,5:jO@eQaO,5:mO@lQaO,5;UO*kQaO,5;UO@sQ`O,5;VOCbQaO'#EsOOQS,5;^,5;^OCiQ`O,5;jOOQP'#F]'#F]O*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qOOQ#u'#Im'#ImOOQS,5<q,5<qOOQ#u,5:l,5:lOEbQ`O,5:rOEiQdO'#E}OF]Q`O'#FlOFeQ`O'#FlOFmQ`O,5:oOFrQaO'#E_OOQS,5:x,5:xOHyQ`O'#I]O9yQaO'#EaO9yQaO'#I]OOQS'#I]'#I]OIQQ`O'#I[OIYQ`O,5:xO-UQaO,5:xOI_QaO'#EgOOQS,5;Q,5;QOOQS,5;Z,5;ZOIiQ`O,5;ZOOQO,5>S,5>SOJ[QdO,5;gOOQO-E;f-E;fOL^Q`O,5;gOLcQpO,5;bO0aQ`O'#EyOLkQtO'#E}OOQS'#Ez'#EzOOQS'#Ib'#IbOM`QaO,5:wO*kQaO,5;nOOQS,5;p,5;pO*kQaO,5;pOMgQdO,5<POMwQdO,5<QONXQdO,5<RONiQdO,5<SO!!sQdO,5<SO!!zQdO,5<VO!#[Q`O'#FrO!#gQ`O'#IgO!#oQ`O,5<]OOQO-E;g-E;gO!#tQ`O'#IoO<_Q`O,5=iO!#|Q`O,5=iO9oQ`O,5=jO!$RQ`O,5=nO!$WQ`O,5=kO!$]Q`O,5=kO!$bQ`O'#FnO!$xQ`O,5<WO!%TQ`O,5<WO!%WQ`O,5?ZO!%]Q`O,5<WO!%eQ`O,5<bO!%mQdO'#GPO!%{QdO'#InO!&WQdO,5=wO!&`Q`O,5<bO!%WQ`O,5<bO!&hQdO,5<cO!&xQ`O,5<cO!'lQdO,5<qO!)nQdO,5<tO!*OOrO'#HsOOOQ'#It'#ItO*kQaO'#GbOOOQ'#Hs'#HsO!*pOrO,5<wOOQS,5<w,5<wO!*wQaO,5=OO!+OQ`O,5=QO!+WQeO,5=VO!+bQ`O,5=XO!+gQaO'#GoO!+WQeO,5=YO9yQaO'#GrO!+WQeO,5=]O!&WQdO,5=`O(tQdO,5=aOOQ#u,5=a,5=aO(tQdO,5=bOOQ#u,5=b,5=bO(tQdO,5=cOOQ#u,5=c,5=cO!+nQ`O,5=dO!+vQ`O,5=fO!+{QdO'#IvOOQS'#Iv'#IvO!&WQdO,5=gO>UQaO,5=hO!-eQ`O'#F}O!-jQdO'#IlO!&WQdO,5=iOOQ#u,5=j,5=jO!-uQ`O,5=lO!-xQ`O,5=mO!-}Q`O,5=nO!.YQdO,5=qOOQ#u,5=q,5=qO!.eQ`O,5=rO!.eQ`O,5=rO!.mQdO'#IwO!.{Q`O'#HXO!&WQdO,5=rO!/ZQ`O,5=rO!/fQdO'#IYO!&WQdO,5=vOOQ#u-E;_-E;_O!1RQ`O,5=kOOO#u,5:^,5:^O!1^O#|O,5:^OOO#u-E;^-E;^OOOO,5>p,5>pOOQ#y1G0S1G0SO!1fQ`O1G0XO*kQaO1G0XO!2xQ`O1G0pOOQS1G0p1G0pO!4[Q`O1G0pOOQS'#I_'#I_O*kQaO'#I_OOQS1G0q1G0qO!4cQ`O'#IaO!7lQ`O'#E}O!7yQaO'#EuOOQO'#Ia'#IaO!8TQ`O'#I`O!8]Q`O,5;_OOQS'#FQ'#FQOOQS1G1U1G1UO!8bQdO1G1]O!:dQdO1G1]O!<PQdO1G1]O!=lQdO1G1]O!?XQdO1G1]O!@tQdO1G1]O!BaQdO1G1]O!C|QdO1G1]O!EiQdO1G1]O!GUQdO1G1]O!HqQdO1G1]O!J^QdO1G1]O!KyQdO1G1]O!MfQdO1G1]O# RQdO1G1]O#!nQdO1G1]OOQT1G0^1G0^O!%WQ`O,5<WO#$ZQaO'#EXOOQS1G0Z1G0ZO#$bQ`O,5:yOFuQaO,5:yO#$gQaO,5:}O#$nQdO,5:{O#&jQdO,5>wO#(fQaO'#HdO#(vQ`O,5>vOOQS1G0d1G0dO#)OQ`O1G0dO#)TQ`O'#I^O#*mQ`O'#I^O#*uQ`O,5;ROIbQaO,5;ROOQS1G0u1G0uPOQO'#E}'#E}O#+fQdO1G1RO0aQ`O'#HgO#-hQtO,5;cO#.YQaO1G0|OOQS,5;e,5;eO#0iQtO,5;gO#0vQdO1G0cO*kQaO1G0cO#2cQdO1G1YO#4OQdO1G1[OOQO,5<^,5<^O#4`Q`O'#HjO#4nQ`O,5?ROOQO1G1w1G1wO#4vQ`O,5?ZO!&WQdO1G3TO<_Q`O1G3TOOQ#u1G3U1G3UO#4{Q`O1G3YO!1RQ`O1G3VO#5WQ`O1G3VO#5]QpO'#FoO#5kQ`O'#FoO#5{Q`O'#FoO#6WQ`O'#FoO#6`Q`O'#FsO#6eQ`O'#FtOOQO'#If'#IfO#6lQ`O'#IeO#6tQ`O,5<YOOQS1G1r1G1rO0aQ`O1G1rO#6yQ`O1G1rO#7OQ`O1G1rO!%WQ`O1G4uO#7ZQdO1G4uO!%WQ`O1G1rO#7iQ`O1G1|O!%WQ`O1G1|O9yQaO,5<kO#7qQdO'#HqO#8PQdO,5?YOOQ#u1G3c1G3cO*kQaO1G1|O0aQ`O1G1|O#8[QdO1G1}O7RQ`O'#FyO7RQ`O'#FzO#:nQ`O'#F{OOQS1G1}1G1}O!-xQ`O1G1}O!1UQ`O1G1}O!1RQ`O1G1}O#;eO`O,5<xO#;jO`O,5<xO#;uO!bO,5<yO#<TQ`O,5<|OOOQ-E;q-E;qOOQS1G2c1G2cO#<[QaO'#GeO#<uQ$VO1G2jO#AuQ`O1G2jO#BQQ`O'#GgO#B]Q`O'#GjOOQ#u1G2l1G2lO#BhQ`O1G2lOOQ#u'#Gl'#GlOOQ#u'#Iu'#IuOOQ#u1G2q1G2qO#BmQ`O1G2qO,zQ`O1G2sO#BrQaO,5=ZO#ByQ`O,5=ZOOQ#u1G2t1G2tO#COQ`O1G2tO#CTQ`O,5=^OOQ#u1G2w1G2wO#DgQ`O1G2wOOQ#u1G2z1G2zOOQ#u1G2{1G2{OOQ#u1G2|1G2|OOQ#u1G2}1G2}O#DlQ`O'#HxO9oQ`O'#HxO#DqQ$VO1G3OO#IwQ`O1G3QO9yQaO'#HwO#I|QdO,5=[OOQ#u1G3R1G3RO#JXQ`O1G3SO9yQaO,5<iO#J^QdO'#HpO#JlQdO,5?WOOQ#u1G3T1G3TOOQ#u1G3W1G3WO!-xQ`O1G3WOOQ#u1G3X1G3XO#KfQ`O'#HTOOQ#u1G3Y1G3YO#KmQ`O1G3YO0aQ`O1G3YOOQ#u1G3]1G3]O!&WQdO1G3^O#KrQ`O1G3^O#KzQdO'#HzO#L]QdO,5?cO#LhQ`O,5?cO#LmQ`O'#HYO7RQ`O'#HYO#LxQ`O'#IxO#MQQ`O,5=sOOQ#u1G3^1G3^O!.eQ`O1G3^O!.eQ`O1G3^O#MVQeO'#HbO#MgQdO,5>tOOQ#u1G3b1G3bOOQ#u1G3V1G3VO!-xQ`O1G3VO!1UQ`O1G3VOOO#u1G/x1G/xO*kQaO7+%sO#MuQdO7+%sOOQS7+&[7+&[O$ bQ`O,5>yO>UQaO,5;`O$ iQ`O,5;aO$#OQaO'#HfO$#YQ`O,5>zOOQS1G0y1G0yO$#bQ`O'#EYO$#gQ`O'#IXO$#oQ`O,5:sOOQS1G0e1G0eO$#tQ`O1G0eO$#yQ`O1G0iO9yQaO1G0iOOQO,5>O,5>OOOQO-E;b-E;bOOQS7+&O7+&OO>UQaO,5;SO$%`QaO'#HeO$%jQ`O,5>xOOQS1G0m1G0mO$%rQ`O1G0mOOQS,5>R,5>ROOQS-E;e-E;eO$%wQdO7+&hO$'yQtO1G1RO$(WQdO7+%}OOQS1G0i1G0iOOQO,5>U,5>UOOQO-E;h-E;hOOQ#u7+(o7+(oO!&WQdO7+(oOOQ#u7+(t7+(tO#KmQ`O7+(tO0aQ`O7+(tOOQ#u7+(q7+(qO!-xQ`O7+(qO!1UQ`O7+(qO!1RQ`O7+(qO$)sQ`O,5<ZO$*OQ`O,5<ZO$*WQ`O,5<_O$*]QpO,5<ZO>UQaO,5<ZOOQO,5<_,5<_O$*kQpO,5<`O$*sQ`O,5<`O$+OQ`O'#HkO$+iQ`O,5?POOQS1G1t1G1tO$+qQpO7+'^O$+yQ`O'#FuO$,UQ`O7+'^OOQS7+'^7+'^O0aQ`O7+'^O#6yQ`O7+'^O$,^QdO7+*aO0aQ`O7+*aO$,lQ`O7+'^O*kQaO7+'hO0aQ`O7+'hO$,wQ`O7+'hO$-PQdO1G2VOOQS,5>],5>]OOQS-E;o-E;oO$.iQdO7+'hO$.yQpO7+'hO$/RQdO'#IiOOQO,5<e,5<eOOQO,5<f,5<fO$/dQpO'#GOO$/lQ`O'#GOOOQO'#Ik'#IkOOQO'#Ho'#HoO$0]Q`O'#GOO<_Q`O'#F|O!&WQdO'#GOO!.YQdO'#GQO7RQ`O'#GROOQO'#Ij'#IjOOQO'#Hn'#HnO$0yQ`O,5<gOOQ#y,5<g,5<gOOQS7+'i7+'iO!-xQ`O7+'iO!1UQ`O7+'iOOOQ1G2d1G2dO$1pO`O1G2dO$1uO!bO1G2eO$2TO`O'#G`O$2YO`O1G2eOOOQ1G2h1G2hO$2_QaO,5=PO,zQ`O'#HtO$2xQ$VO7+(UOhQaO7+(UO,zQ`O'#HuO$7xQ`O7+(UO!&WQdO7+(UO$8TQ`O7+(UO$8YQaO'#GhO$:iQ`O'#GiOOQO'#Hv'#HvO$:qQ`O,5=ROOQ#u,5=R,5=RO$:|Q`O,5=UO!&WQdO7+(WO!&WQdO7+(]O!&WQdO7+(_O$;XQaO1G2uO$;`Q`O1G2uO$;eQaO1G2uO!&WQdO7+(`O9yQaO1G2xO!&WQdO7+(cO0aQ`O'#GyO9oQ`O,5>dOOQ#u,5>d,5>dOOQ#u-E;v-E;vO$;lQaO7+(lO$<TQdO,5>cOOQS-E;u-E;uO!&WQdO7+(nO$=mQdO1G2TOOQS,5>[,5>[OOQS-E;n-E;nOOQ#u7+(r7+(rO$?nQ`O'#GQO$?uQ`O'#GQO$@ZQ`O'#HUOOQO'#Hy'#HyO$@`Q`O,5=oOOQ#u,5=o,5=oO$@gQpO7+(tOOQ#u7+(x7+(xO!&WQdO7+(xO$@rQdO,5>fOOQS-E;x-E;xO$AQQdO1G4}O$A]Q`O,5=tO$AbQ`O,5=tO$AmQ`O'#H{O$BRQ`O,5?dOOQS1G3_1G3_O#KrQ`O7+(xO$BZQdO,5=|OOQS-E;`-E;`O$CvQdO<<I_OOQS1G4e1G4eO$EcQ`O1G0zOOQO,5>Q,5>QOOQO-E;d-E;dO$8YQaO,5:tO$FxQaO'#HcO$GVQ`O,5>sOOQS1G0_1G0_OOQS7+&P7+&PO$G_Q`O7+&TO$HtQ`O1G0nO$JZQ`O,5>POOQO,5>P,5>POOQO-E;c-E;cOOQS7+&X7+&XOOQS7+&T7+&TOOQ#u<<LZ<<LZOOQ#u<<L`<<L`O$@gQpO<<L`OOQ#u<<L]<<L]O!-xQ`O<<L]O!1UQ`O<<L]O>UQaO1G1uO$KsQ`O1G1uO$LOQ`O1G1yOOQO1G1y1G1yO$LTQ`O1G1uO$L]Q`O1G1uO$MrQ`O1G1zO>UQaO1G1zOOQO,5>V,5>VOOQO-E;i-E;iOOQS<<Jx<<JxO$M}Q`O'#IhO$NVQ`O'#IhO$N[Q`O,5<aO0aQ`O<<JxO$+qQpO<<JxO$NaQ`O<<JxO0aQ`O<<M{O$NiQtO<<M{O#6yQ`O<<JxO$NwQdO<<KSO% XQpO<<KSO*kQaO<<KSO0aQ`O<<KSO% aQdO'#HmO% xQdO,5?TO!&WQdO,5<jO$/dQpO,5<jO%!ZQ`O,5<jO<_Q`O,5<hO!.YQdO,5<lOOQO-E;m-E;mO!&WQdO,5<hOOQO,5<j,5<jOOQO,5<l,5<lO%!tQdO,5<mOOQO-E;l-E;lOOQ#y1G2R1G2ROOQS<<KT<<KTO!-xQ`O<<KTOOOQ7+(O7+(OO%#PO`O7+(POOOO,5<z,5<zOOOQ7+(P7+(POhQaO,5>`OOQ#u-E;r-E;rOhQaO<<KpOOQ#u<<Kp<<KpO$8TQ`O,5>aOOQO-E;s-E;sO!&WQdO<<KpO$8TQ`O<<KpO%#UQ`O<<KpO%#ZQ`O,5=SO%$pQaO,5=TOOQO-E;t-E;tOOQ#u1G2m1G2mOOQ#u<<Kr<<KrOOQ#u<<Kw<<KwOOQ#u<<Ky<<KyOOQT7+(a7+(aO%%QQ`O7+(aO%%VQaO7+(aO%%^Q`O7+(aOOQ#u<<Kz<<KzO%%cQ`O7+(dO%&xQ`O7+(dOOQ#u<<K}<<K}O%&}QpO,5=eOOQ#u1G4O1G4OO%'YQ`O<<LWOOQ#u<<LY<<LYO$?uQ`O,5<lO%'_Q`O,5=pO%'dQdO,5=pOOQO-E;w-E;wOOQ#u1G3Z1G3ZO#KmQ`O<<L`OOQ#u<<Ld<<LdO%'oQ`O1G4QO%'tQdO7+*iOOQO1G3`1G3`O%(PQ`O1G3`O%(UQ`O'#HZO7RQ`O'#HZOOQO,5>g,5>gOOQO-E;y-E;yO!&WQdO<<LdO%(aQ`O1G0`OOQO,5=},5=}OOQO-E;a-E;aO>UQaO,5;TOOQ#uANAzANAzO#KmQ`OANAzOOQ#uANAwANAwO!-xQ`OANAwO%)vQ`O7+'aO>UQaO7+'aOOQO7+'e7+'eO%+]Q`O7+'aO%+hQ`O7+'eO>UQaO7+'fO%+mQ`O7+'fO%-SQ`O'#HlO%-bQ`O,5?SO%-bQ`O,5?SOOQO1G1{1G1{O$+qQpOAN@dOOQSAN@dAN@dO0aQ`OAN@dO%-jQtOANCgO%-xQ`OAN@dO*kQaOAN@nO%.QQdOAN@nO%.bQpOAN@nOOQS,5>X,5>XOOQS-E;k-E;kOOQO1G2U1G2UO!&WQdO1G2UO$/dQpO1G2UO<_Q`O1G2SO!.YQdO1G2WO!&WQdO1G2SOOQO1G2W1G2WOOQO1G2S1G2SO%.jQaO'#GSOOQO1G2X1G2XOOQSAN@oAN@oOOOQ<<Kk<<KkOOQ#u1G3z1G3zOOQ#uANA[ANA[OOQO1G3{1G3{O%0iQ`OANA[O!&WQdOANA[O%0nQaO1G2nO%1OQaO1G2oOOQT<<K{<<K{O%1`Q`O<<K{O%1eQaO<<K{O*kQaO,5=_OOQT<<LO<<LOOOQO1G3P1G3PO%1lQ`O1G3PO!+WQeOANArO%1qQdO1G3[OOQO1G3[1G3[O%1|Q`O1G3[OOQS7+)l7+)lOOQO7+(z7+(zO%2UQ`O,5=uO%2ZQ`O,5=uOOQ#uANBOANBOO%2fQ`O1G0oOOQ#uG27fG27fOOQ#uG27cG27cO%3{Q`O<<J{O>UQaO<<J{OOQO<<KP<<KPO%5bQ`O<<KQOOQO,5>W,5>WO%6wQ`O,5>WOOQO-E;j-E;jO%6|Q`O1G4nOOQSG26OG26OO$+qQpOG26OO0aQ`OG26OO%7UQdOG26YO*kQaOG26YOOQO7+'p7+'pO!&WQdO7+'pO!&WQdO7+'nOOQO7+'r7+'rOOQO7+'n7+'nO%7fQ`OLD+tO%8uQ`O'#E}O%9PQ`O'#IZO!&WQdO'#HrO%:|QaO,5<nOOQO,5<n,5<nO!&WQdOG26vOOQ#uG26vG26vO%<{QaO7+(YOOQTANAgANAgO%=]Q`OANAgO%=bQ`O1G2yOOQO7+(k7+(kOOQ#uG27^G27^O%=iQ`OG27^OOQO7+(v7+(vO%=nQ`O7+(vO!&WQdO7+(vOOQO1G3a1G3aO%=vQ`O1G3aO%={Q`OAN@gOOQO1G3r1G3rOOQSLD+jLD+jO$+qQpOLD+jO%?bQdOLD+tOOQO<<K[<<K[OOQO<<KY<<KYO%?rQ`O,5<oO%?wQ`O,5<pOOQP,5>^,5>^OOQP-E;p-E;pOOQO1G2Y1G2YOOQ#uLD,bLD,bOOQTG27RG27RO!&WQdOLD,xO!&WQdO<<LbOOQO<<Lb<<LbOOQO7+({7+({OOQS!$( U!$( UOOQS1G2Z1G2ZOOQS1G2[1G2[O%@PQdO1G2[OOQ#u!$(!d!$(!dOOQOANA|ANA|OOQS7+'v7+'vO%@[Q`O'#E{O%@[Q`O'#E{O%@aQ`O,5;gO%@fQdO,5<cO%BbQaO,5:}O*kQaO1G0iO%BiQaO'#FwO#.YQaO'#GVO#.YQaO'#GYO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO%BpQdO'#I]O%D`QdO'#I]O#.YQaO'#EaO#.YQaO'#I]O%FbQaO,5:wO#.YQaO,5;nO#.YQaO,5;pO%FiQdO,5<PO%HeQdO,5<QO%JaQdO,5<RO%L]QdO,5<SO%NXQdO,5<SO%NoQdO,5<VO&!kQdO,5<tO#.YQaO1G0XO&$gQdO1G1]O&&cQdO1G1]O&(_QdO1G1]O&*ZQdO1G1]O&,VQdO1G1]O&.RQdO1G1]O&/}QdO1G1]O&1yQdO1G1]O&3uQdO1G1]O&5qQdO1G1]O&7mQdO1G1]O&9iQdO1G1]O&;eQdO1G1]O&=aQdO1G1]O&?]QdO1G1]O&AXQdO,5:{O&CTQdO,5>wO&EPQdO1G0cO#.YQaO1G0cO&F{QdO1G1YO&HwQdO1G1[O#.YQaO1G1|O#.YQaO7+%sO&JsQdO7+%sO&LoQdO7+%}O#.YQaO7+'hO&NkQdO7+'hO'!gQdO<<I_O'$cQdO<<KSO#.YQaO<<KSO#.YQaOAN@nO'&_QdOAN@nO'(ZQdOG26YO#.YQaOG26YO'*VQdOLD+tO',RQaO,5:}O'.QQaO1G0iO'/|QdO'#IWO'0aQeO'#FUO'4aQeO'#FUO#.YQaO'#FeO'.QQaO'#FeO#.YQaO'#FfO'.QQaO'#FfO#.YQaO'#FgO'.QQaO'#FgO#.YQaO'#FhO'.QQaO'#FhO#.YQaO'#FhO'.QQaO'#FhO#.YQaO'#FkO'.QQaO'#FkO'8gQaO,5:mO'8nQ`O,5<bO'8vQ`O1G0XO'.QQaO1G0|O':YQ`O1G1|O':bQ`O7+'hO':jQpO7+'hO':rQpO<<KSO':zQpOAN@nO';SQaO'#FwO'.QQaO'#GVO'.QQaO'#GYO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO'#EaO'.QQaO'#I]O'=RQaO,5:wO'.QQaO,5;nO'.QQaO,5;pO'?QQdO,5<PO'ASQdO,5<QO'CUQdO,5<RO'EWQdO,5<SO'GYQdO,5<SO'GvQdO,5<VO'IxQdO,5<tO'.QQaO1G0XO'KzQdO1G1]O'M|QdO1G1]O(!OQdO1G1]O($QQdO1G1]O(&SQdO1G1]O((UQdO1G1]O(*WQdO1G1]O(,YQdO1G1]O(.[QdO1G1]O(0^QdO1G1]O(2`QdO1G1]O(4bQdO1G1]O(6dQdO1G1]O(8fQdO1G1]O(:hQdO1G1]O(<jQdO,5:{O(>lQdO,5>wO(@nQdO1G0cO'.QQaO1G0cO(BpQdO1G1YO(DrQdO1G1[O'.QQaO1G1|O'.QQaO7+%sO(FtQdO7+%sO(HvQdO7+%}O'.QQaO7+'hO(JxQdO7+'hO(LzQdO<<I_O(N|QdO<<KSO'.QQaO<<KSO'.QQaOAN@nO)#OQdOAN@nO)%QQdOG26YO'.QQaOG26YO)'SQdOLD+tO))UQaO,5:}O#.YQaO1G0iO))]Q`O'#FvO))eQpO,5;bO))mQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO))uQdO,5<cO)+wQdO'#I]O)-vQdO'#IWO).aQaO,5:mO).hQ`O,5<bO).pQ`O1G0XO)0SQ`O1G1|O)0[Q`O7+'hO)0dQpO7+'hO)0lQpO<<KSO)0tQpOAN@nO0aQ`O'#EvO9yQaO'#FeO9yQaO'#FfO9yQaO'#FgO9yQaO'#FhO9yQaO'#FhO9yQaO'#FkO)0|QaO'#FwO9yQaO'#GVO9yQaO'#GYO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO)1TQ`O'#FlO*kQaO'#EaO*kQaO'#I]O)1]QaO,5:wO9yQaO,5;nO9yQaO,5;pO)1dQdO,5<PO)3`QdO,5<QO)5[QdO,5<RO)7WQdO,5<SO)9SQdO,5<SO)9jQdO,5<VO);fQdO,5<cO)=bQdO,5<tO)?^Q`O'#IvO)@sQ`O'#IYO9yQaO1G0XO)BYQdO1G1]O)DUQdO1G1]O)FQQdO1G1]O)G|QdO1G1]O)IxQdO1G1]O)KtQdO1G1]O)MpQdO1G1]O* lQdO1G1]O*#hQdO1G1]O*%dQdO1G1]O*'`QdO1G1]O*)[QdO1G1]O*+WQdO1G1]O*-SQdO1G1]O*/OQdO1G1]O*0zQaO,5:}O*1RQdO,5:{O*1cQdO,5>wO*1sQaO'#HdO*2TQ`O,5>vO*2]QdO1G0cO9yQaO1G0cO*4XQdO1G1YO*6TQdO1G1[O9yQaO1G1|O>UQaO'#HwO*8PQ`O,5=[O*8XQaO'#HbO*8cQ`O,5>tO9yQaO7+%sO*8kQdO7+%sO*:gQ`O1G0iO>UQaO1G0iO*;|QdO7+%}O9yQaO7+'hO*=xQdO7+'hO*?tQ`O,5>cO*AZQ`O,5=|O*BpQdO<<I_O*DlQ`O7+&TO*FRQdO<<KSO9yQaO<<KSO9yQaOAN@nO*G}QdOAN@nO*IyQdOG26YO9yQaOG26YO*KuQdOLD+tO*MqQaO,5:}O9yQaO1G0iO*MxQdO'#I]O*NcQ`O'#FvO*NkQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO*NsQdO'#IWO+ ^QeO'#FUO+ zQaO'#FUO+#sQaO'#FUO+%`QaO'#FUO>UQaO'#FeO>UQaO'#FfO>UQaO'#FgO>UQaO'#FhO>UQaO'#FhO>UQaO'#FkO+'XQaO'#FwO>UQaO'#GVO>UQaO'#GYO+'`QaO,5:mO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO+'gQ`O'#I]O$8YQaO'#EaO+)PQaOG26YO$8YQaO'#I]O+*{Q`O'#I[O++TQaO,5:wO>UQaO,5;nO>UQaO,5;pO++[Q`O,5<PO+,wQ`O,5<QO+.dQ`O,5<RO+0PQ`O,5<SO+1lQ`O,5<SO+3XQ`O,5<VO+4tQ`O,5<bO+4|Q`O,5<cO+6iQ`O,5<tO+8UQ`O1G0XO>UQaO1G0XO+9hQ`O1G1]O+;TQ`O1G1]O+<pQ`O1G1]O+>]Q`O1G1]O+?xQ`O1G1]O+AeQ`O1G1]O+CQQ`O1G1]O+DmQ`O1G1]O+FYQ`O1G1]O+GuQ`O1G1]O+IbQ`O1G1]O+J}Q`O1G1]O+LjQ`O1G1]O+NVQ`O1G1]O, rQ`O1G1]O,#_Q`O1G0cO>UQaO1G0cO,$zQ`O1G1YO,&gQ`O1G1[O,(SQ`O1G1|O>UQaO1G1|O>UQaO7+%sO,([Q`O7+%sO,)wQ`O7+%}O>UQaO7+'hO,+dQ`O7+'hO,+lQ`O7+'hO,-XQpO7+'hO,-aQ`O<<I_O,.|Q`O<<KSO,0iQpO<<KSO>UQaO<<KSO>UQaOAN@nO,0qQ`OAN@nO,2^QpOAN@nO,2fQ`OG26YO>UQaOG26YO,4RQ`OLD+tO,5nQaO,5:}O>UQaO1G0iO,5uQ`O'#I]O$8YQaO'#FeO$8YQaO'#FfO$8YQaO'#FgO$8YQaO'#FhO$8YQaO'#FhO+)PQaO'#FhO$8YQaO'#FkO,6SQaO'#FwO,6ZQaO'#FwO$8YQaO'#GVO+)PQaO'#GVO$8YQaO'#GYO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO,8YQ`O'#FlO>UQaO'#EaO>UQaO'#I]O,8bQaO,5:wO,8iQaO,5:wO$8YQaO,5;nO+)PQaO,5;nO$8YQaO,5;pO,:hQ`O,5<PO,<TQ`O,5<QO,=pQ`O,5<RO,?]Q`O,5<SO,@xQ`O,5<SO,BeQ`O,5<SO,CtQ`O,5<VO,EaQ`O,5<cO%7fQ`O,5<cO,F|Q`O,5<tO$8YQaO1G0XO+)PQaO1G0XO,HiQ`O1G1]O,JUQ`O1G1]O,KeQ`O1G1]O,MQQ`O1G1]O,NaQ`O1G1]O- |Q`O1G1]O-#]Q`O1G1]O-$xQ`O1G1]O-&XQ`O1G1]O-'tQ`O1G1]O-)TQ`O1G1]O-*pQ`O1G1]O-,PQ`O1G1]O--lQ`O1G1]O-.{Q`O1G1]O-0hQ`O1G1]O-1wQ`O1G1]O-3dQ`O1G1]O-4sQ`O1G1]O-6`Q`O1G1]O-7oQ`O1G1]O-9[Q`O1G1]O-:kQ`O1G1]O-<WQ`O1G1]O-=gQ`O1G1]O-?SQ`O1G1]O-@cQ`O1G1]O-BOQ`O1G1]O-C_Q`O1G1]O-DzQ`O1G1]O-FZQ`O,5:{O-GvQ`O,5>wO-IcQ`O1G0cO-KOQ`O1G0cO$8YQaO1G0cO+)PQaO1G0cO-L_Q`O1G1YO-MzQ`O1G1YO. ZQ`O1G1[O$8YQaO1G1|O$8YQaO7+%sO+)PQaO7+%sO.!vQ`O7+%sO.$cQ`O7+%sO.%rQ`O7+%}O.'_Q`O7+%}O$8YQaO7+'hO.(nQ`O7+'hO.*ZQ`O<<I_O.+vQ`O<<I_O.-VQ`O<<KSO$8YQaO<<KSO$8YQaOAN@nO..rQ`OAN@nO.0_Q`OG26YO$8YQaOG26YO.1zQ`OLD+tO.3gQaO,5:}O.3nQaO,5:}O$8YQaO1G0iO+)PQaO1G0iO.5mQ`O'#I]O.7PQ`O'#I]O.:fQ`O'#IWO.:vQ`O'#FvO.;OQaO,5:mO.;VQ`O,5<bO.;_Q`O,5<bO!%WQ`O,5<bO.;gQ`O1G0XO.<yQ`O,5:{O.>fQ`O,5>wO.@RQ`O1G1|O!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO.@ZQ`O7+'hO.@cQpO7+'hO.@kQpO<<KSO0aQ`O<<KSO.@sQpOAN@nO.@{Q`O'#IWO.A]Q`O'#IWO.CSQaO,5:mO.CZQaO,5:mO.CbQ`O,5<bO.CjQ`O7+'hO.CrQ`O1G0XO.EUQ`O1G0XO.FhQ`O1G1|O.FpQ`O7+'hO.FxQpO7+'hO.GQQpOAN@nO.GYQpO<<KSO.GbQpOAN@nO.GjQ`O'#FvO.GrQ`O'#FlO.GzQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO.HSQ`O'#FvO.H[Q`O,5<bO.HdQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O!%WQ`O1G1|O0aQ`O1G1|O0aQ`O<<KSO0aQ`O7+'hO0aQ`O<<KSO.HlQ`O'#FlO.HtQ`O'#FlO.H|Q`O'#Fl",
        stateData: ".Ic~O!dOS!eOS&vOS!gQQ~O!iTO&wRO~OPgOQ|OS!lOU^OW}OX!XO[mO]!_O^!WO`![Oa!SOb!]Ok!dOm!lOowOp!TOq!UOsuOt!gOu!VOv!POxkOykO|!bO}`O!O]O!P!eO!QxO!R}O!TpO!UlO!VlO!W!YO!X!QO!YzO!Z!cO![!ZO!]!^O!^!fO!`!`O!a!RO!cjO!mWO!oXO!sYO!y[O#W_O#bhO#daO#ebO#peO$ToO$]nO$^oO$aqO$drO$l!kO$zyO${!OO$}}O%O}O%V|O'g{O~O!g!mO~O&wRO!i!hX&p!hX&t!hX~O!i!pO~O!d!qO!e!qO!g!mO&t!tO&v!qO~PhO!n!vO~PhOT'VXz'VX!S'VX!b'VX!m'VX!o'VX!v'VX!y'VX#S'VX#W'VX#`'VX#a'VX#p#qX#s'VX#z'VX#{'VX#|'VX#}'VX$O'VX$Q'VX$R'VX$S'VX$T'VX$U'VX$V'VX$W'VX$z'VX&s'VX~O!q!xO~P&sOT#TOz#RO!S#UO!b#VO!m#cO!o!{O!v!yO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO&s#cO~OPgOQ|OU^OW}O[mOowOs#hOxkOykO}`O!O]O!QxO!R}O!TpO!UlO!VlO!YzO!cjO!s#gO!y[O#W_O#bhO#daO#ebO#peO$ToO$]nO$^oO$aqO$zyO${!OO$}}O%O}O%V|O'g{O~O!y[O~O!y#kO~OP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#S#oO#U#nO#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{O#X'OP~O!}#sO~P-UO!y#tO~O#b#vO#daO#ebO~O#p#xO~O!s#yO~OU$PO!R$PO!s$OO!v#}O#p2XO~OT&zXz&zX!S&zX!b&zX!m&zX!o&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX&s&zX!x&zX!n&zX~O#u$RO#w$SO~P0rOP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{OT#xXz#xX!S#xX!b#xX!m#xX!o#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX&s#xX!x#xX!n#xX~Or$UO#S6yO#U6xO~P2yO!s#gO#peO~OS$gO]$bOk$eOm$gOs$aO!`$cO$drO$l$fO~O!s$kO!y$hO#S$jO~Oo$mOs$lO#b$nO~O!y$hO#S$rO~O$l$tO~P*kOR$zO!o$yO#b$xO#e$yO&q$zO~O'f$|O~P8lO!y%RO~O!y%TO~O!s%VO~O!m#cO&s#cO~P*kO!oXO~O!y%_O~OP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{O~O!y%cO~O!s%dO~O]$bO~O!s%hO~O!s%iO~O!s%jO~O!oXO!s#gO#peO~O]%rOs%rO!o%pO!s#gO#p%nO~O!s%vO~O!i%wO&t%wO&wRO~O&t%zO~PhO!n%{O~PhOPgOQ|OU^OW}O[8lOo=yOs#hOx8jOy8jO}`O!O]O!Q8pO!R}O!T8oO!U8kO!V8kO!Y8rO!c8iO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T8nO$]8mO$^8nO$aqO$z8qO${!OO$}}O%O}O%V|O'g{O~O!q%}O~P>UO#X&PO~P>UO!o&SO!s&RO#b&RO~OPgOQ|OU^OW}O[8lOo=yOs#hOx8jOy8jO}`O!O]O!Q8pO!R}O!T8oO!U8kO!V8kO!Y8rO!c8iO!s&VO!y[O#U&WO#W_O#bhO#daO#ebO#peO$T8nO$]8mO$^8nO$aqO$z8qO${!OO$}}O%O}O%V|O'g{O~O!x'SP~PAOO!s&[O#b&[O~OT#TOz#RO!S#UO!b#VO!o!{O!v!yO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO~O!x&nO~PCqO!x'VX!}'VX#O'VX#X'VX!n'VXV'VX!q'VX#u'VX#w'VXw'VX~P&sO!y$hO#S&oO~Oo$mOs$lO~O!o&pO~O!}&sO#S;dO#U;cO!x'OP~P9yOT6iOz6gO!S6jO!b6kO!o!{O!v8sO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}'PX#X'PX~O#O&tO~PGSO!}&wO#X'OX~O#X&yO~O!}'OO!x'QP~P9yO!n'PO~PCqO!m#oa!o#oa#S#oa#p#qX&s#oa!x#oa#O#oaw#oa~OT#oaz#oa!S#oa!b#oa!v#oa!y#oa#W#oa#`#oa#a#oa#s#oa#z#oa#{#oa#|#oa#}#oa$O#oa$Q#oa$R#oa$S#oa$T#oa$U#oa$V#oa$W#oa$z#oa!}#oa#X#oa!n#oaV#oa!q#oa#u#oa#w#oa~PIpO!s'RO~O!x'UO#l'SO~O!x'VX#l'VX#p#qX#S'VX#U'VX#b'VX!o'VX#O'VXw'VX!m'VX&s'VX~O#S'YO~P*kO!m$Xa&s$Xa!x$Xa!n$Xa~PCqO!m$Ya&s$Ya!x$Ya!n$Ya~PCqO!m$Za&s$Za!x$Za!n$Za~PCqO!m$[a&s$[a!x$[a!n$[a~PCqO!o!{O!y!}O#W!zO#`!|O#a!|O#s#PO$z#dOT$[a!S$[a!b$[a!m$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a&s$[a!x$[a!n$[a~Oz#RO~PNyO!m$_a&s$_a!x$_a!n$_a~PCqO!y!}O!}$fX#X$fX~O!}'^O#X'ZX~O#X'`O~O!s$kO#S'aO~O]'cO~O!s'eO~O!s'fO~O$l'gO~O!`'mO#S'kO#U'lO#b'jO$drO!x'XP~P0aO!^'sO!oXO!q'rO~O!s'uO!y$hO~O!y$hO#S'wO~O!y$hO#S'yO~O#u'zO!m$sX!}$sX&s$sX~O!}'{O!m'bX&s'bX~O!m#cO&s#cO~O!q(PO#O(OO~O!m$ka&s$ka!x$ka!n$ka~PCqOl(ROw(SO!o(TO!y!}O~O!o!{O!y!}O#W!zO#`!|O#a!|O#s#PO~OT$yaz$ya!S$ya!b$ya!m$ya!v$ya#S$ya#z$ya#{$ya#|$ya#}$ya$O$ya$Q$ya$R$ya$S$ya$T$ya$U$ya$V$ya$W$ya$z$ya&s$ya!x$ya!}$ya#O$ya#X$ya!n$ya!q$yaV$ya#u$ya#w$ya~P!'WO!m$|a&s$|a!x$|a!n$|a~PCqO#W([O#`(YO#a(YO&r(ZOR&gX!o&gX#b&gX#e&gX&q&gX'f&gX~O'f(_O~P8lO!q(`O~PhO!o(cO!q(dO~O!q(`O&s(gO~PhO!a(kO~O!m(lO~P9yOZ(wOn(xO~O!s(zO~OT6iOz6gO!S6jO!b6kO!v8sO!}({O#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'jX&s'jX~P!'WO#u)PO~O!})QO!m'`X&s'`X~Ol(RO!o(TO~Ow(SO!o)WO!q)ZO~O!m#cO!oXO&s#cO~O!o%pO!s#yO~OV)aO!})_O!m'kX&s'kX~O])cOs)cO!s#gO#peO~O!o%pO!s#gO#p)hO~OT6iOz6gO!S6jO!b6kO!v8sO!})iO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&|X&s&|X#O&|X~P!'WOl(ROw(SO!o(TO~O!i)oO&t)oO~OT8vOz8tO!S8wO!b8xO!q)pO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#X)rO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!n)rO~PCqOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'TX!}'TX~P!'WOT'VXz'VX!S'VX!b'VX!o'VX!v'VX!y'VX#S'VX#W'VX#`'VX#a'VX#p#qX#s'VX#z'VX#{'VX#|'VX#}'VX$O'VX$Q'VX$R'VX$S'VX$T'VX$U'VX$V'VX$W'VX$z'VX~O!q)tO!x'VX!}'VX~P!5xO!x#iX!}#iX~P>UO!})vO!x'SX~O!x)xO~O$z#dOT#yiz#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi$W#yi&s#yi!x#yi!}#yi#O#yi#X#yi!n#yi!q#yiV#yi#u#yi#w#yi~P!'WOz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi&s#yi!x#yi!n#yi~P!'WOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi&s#yi!x#yi!n#yi~P!'WOT#TOz#RO!b#VO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO!S#yi!m#yi&s#yi!x#yi!n#yi~P!'WOT#TOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO!S#yi!b#yi!m#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi#}#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi~P!'WOz#RO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi~P!'WOz#RO$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi&s#yi!x#yi!n#yi~P!'WOz#RO$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi&s#yi!x#yi!n#yi~P!'WOz#RO$T#`O$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$S#_O$T#`O$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi&s#yi!x#yi!n#yi~P!'WO_)yO~P9yO!x)|O~O#S*PO~P9yOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Ta#X#Ta#O#Ta!m#Ta&s#Ta!x#Ta!n#TaV#Ta!q#Ta~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}'Pa#X'Pa#O'Pa!m'Pa&s'Pa!x'Pa!n'PaV'Pa!q'Pa~P!'WO#S#oO#U#nO!}&WX#X&WX~P9yO!}&wO#X'Oa~O#X*SO~OT6iOz6gO!S6jO!b6kO!v8sO!}*UO#O*TO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x'QX~P!'WO!}*UO!x'QX~O!x*WO~O!m#oi!o#oi#S#oi#p#qX&s#oi!x#oi#O#oiw#oi~OT#oiz#oi!S#oi!b#oi!v#oi!y#oi#W#oi#`#oi#a#oi#s#oi#z#oi#{#oi#|#oi#}#oi$O#oi$Q#oi$R#oi$S#oi$T#oi$U#oi$V#oi$W#oi$z#oi!}#oi#X#oi!n#oiV#oi!q#oi#u#oi#w#oi~P#*zO#l'SO!x#ka#S#ka#U#ka#b#ka!o#ka#O#kaw#ka!m#ka&s#ka~OPgOQ|OU^OW}O[4OOo5xOs#hOx3zOy3zO}`O!O]O!Q2^O!R}O!T4UO!U3|O!V3|O!Y2`O!c3xO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4SO$]4QO$^4SO$aqO$z2_O${!OO$}}O%O}O%V|O'g{O~O#l#oa#U#oa#b#oa~PIpOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#Pi!S#Pi!b#Pi!m#Pi&s#Pi!x#Pi!n#Pi~P!'WOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#vi!S#vi!b#vi!m#vi&s#vi!x#vi!n#vi~P!'WO!m#xi&s#xi!x#xi!n#xi~PCqO!s#gO#peO!}&^X#X&^X~O!}'^O#X'Za~O!s'uO~Ow(SO!o)WO!q*fO~O!s*jO~O#S*lO#U*mO#b*kO#l'SO~O#S*lO#U*mO#b*kO$drO~P0aO#u*oO!x$cX!}$cX~O#U*mO#b*kO~O#b*pO~O#b*rO~P0aO!}*sO!x'XX~O!x*uO~O!y*wO~O!^*{O!oXO!q*zO~O!q*}O!o'ci!m'ci&s'ci~O!q+QO#O+PO~O#b$nO!m&eX!}&eX&s&eX~O!}'{O!m'ba&s'ba~OT$kiz$ki!S$ki!b$ki!m$ki!o$ki!v$ki!y$ki#S$ki#W$ki#`$ki#a$ki#s$ki#u#fa#w#fa#z$ki#{$ki#|$ki#}$ki$O$ki$Q$ki$R$ki$S$ki$T$ki$U$ki$V$ki$W$ki$z$ki&s$ki!x$ki!}$ki#O$ki#X$ki!n$ki!q$kiV$ki~OS+^O]+aOm+^Os$aO!^+dO!_+^O!`+^O!n+hO#b$nO$aqO$drO~P0aO!s+lO~O#W+nO#`+mO#a+mO~O!s+pO#b+pO$}+pO%T+oO~O!n+qO~PCqOc%XXd%XXh%XXj%XXf%XXg%XXe%XX~PhOc+uOd+sOP%WiQ%WiS%WiU%WiW%WiX%Wi[%Wi]%Wi^%Wi`%Wia%Wib%Wik%Wim%Wio%Wip%Wiq%Wis%Wit%Wiu%Wiv%Wix%Wiy%Wi|%Wi}%Wi!O%Wi!P%Wi!Q%Wi!R%Wi!T%Wi!U%Wi!V%Wi!W%Wi!X%Wi!Y%Wi!Z%Wi![%Wi!]%Wi!^%Wi!`%Wi!a%Wi!c%Wi!m%Wi!o%Wi!s%Wi!y%Wi#W%Wi#b%Wi#d%Wi#e%Wi#p%Wi$T%Wi$]%Wi$^%Wi$a%Wi$d%Wi$l%Wi$z%Wi${%Wi$}%Wi%O%Wi%V%Wi&p%Wi'g%Wi&t%Wi!n%Wih%Wij%Wif%Wig%WiY%Wi_%Wii%Wie%Wi~Oc+yOd+vOh+xO~OY+zO_+{O!n,OO~OY+zO_+{Oi%^X~Oi,QO~Oj,RO~O!m,TO~P9yO!m,VO~Of,WO~OT6iOV,XOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WOg,YO~O!y,ZO~OZ(wOn(xOP%liQ%liS%liU%liW%liX%li[%li]%li^%li`%lia%lib%lik%lim%lio%lip%liq%lis%lit%liu%liv%lix%liy%li|%li}%li!O%li!P%li!Q%li!R%li!T%li!U%li!V%li!W%li!X%li!Y%li!Z%li![%li!]%li!^%li!`%li!a%li!c%li!m%li!o%li!s%li!y%li#W%li#b%li#d%li#e%li#p%li$T%li$]%li$^%li$a%li$d%li$l%li$z%li${%li$}%li%O%li%V%li&p%li'g%li&t%li!n%lic%lid%lih%lij%lif%lig%liY%li_%lii%lie%li~O#u,_O~O!}({O!m%da&s%da~O!x,bO~O!s%dO!m&dX!}&dX&s&dX~O!})QO!m'`a&s'`a~OS+^OY,iOm+^Os$aO!^+dO!_+^O!`+^O$aqO$drO~O!n,lO~P#JwO!o)WO~O!o%pO!s'RO~O!s#gO#peO!m&nX!}&nX&s&nX~O!})_O!m'ka&s'ka~O!s,rO~OV,sO!n%|X!}%|X~O!},uO!n'lX~O!n,wO~O!m&UX!}&UX&s&UX#O&UX~P9yO!})iO!m&|a&s&|a#O&|a~Oz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT!uq!S!uq!b!uq!m!uq!v!uq&s!uq!x!uq!n!uq~P!'WO!n,|O~PCqOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#ia!}#ia~P!'WO!x&YX!}&YX~PAOO!})vO!x'Sa~O#O-QO~O!}-RO!n&{X~O!n-TO~O!x-UO~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Vi#X#Vi~P!'WO!x&XX!}&XX~P9yO!}*UO!x'Qa~O!x-[O~OT#jqz#jq!S#jq!b#jq!m#jq!v#jq#S#jq#u#jq#w#jq#z#jq#{#jq#|#jq#}#jq$O#jq$Q#jq$R#jq$S#jq$T#jq$U#jq$V#jq$W#jq$z#jq&s#jq!x#jq!}#jq#O#jq#X#jq!n#jq!q#jqV#jq~P!'WO#l#oi#U#oi#b#oi~P#*zOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#Pq!S#Pq!b#Pq!m#Pq&s#Pq!x#Pq!n#Pq~P!'WO#u-dO!x$ca!}$ca~O#U-fO#b-eO~O#b-gO~O#S-hO#U-fO#b-eO#l'SO~O#b-jO#l'SO~O#u-kO!x$ha!}$ha~O!`'mO#S'kO#U'lO#b'jO$drO!x&_X!}&_X~P0aO!}*sO!x'Xa~O!oXO#l'SO~O#S-pO#b-oO!x'[P~O!oXO!q-rO~O!q-uO!o'cq!m'cq&s'cq~O!^-wO!oXO!q-rO~O!q-{O#O-zO~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m$si!}$si&s$si~P!'WO!m$jq&s$jq!x$jq!n$jq~PCqO#O-zO#l'SO~O!}-|Ow']X!o']X!m']X&s']X~O#b$nO#l'SO~OS+^O].ROm+^Os$aO!_+^O!`+^O#b$nO$aqO$drO~P0aOS+^O].ROm+^Os$aO!_+^O!`+^O#b$nO$aqO~P0aOS+^O]+aOm+^Os$aO!^+dO!_+^O!`+^O!n.ZO#b$nO$aqO$drO~P0aO!s.^O~O!s._O#b._O$}._O%T+oO~O$}.`O~O#X.aO~Oc%Xad%Xah%Xaj%Xaf%Xag%Xae%Xa~PhOc.dOd+sOP%WqQ%WqS%WqU%WqW%WqX%Wq[%Wq]%Wq^%Wq`%Wqa%Wqb%Wqk%Wqm%Wqo%Wqp%Wqq%Wqs%Wqt%Wqu%Wqv%Wqx%Wqy%Wq|%Wq}%Wq!O%Wq!P%Wq!Q%Wq!R%Wq!T%Wq!U%Wq!V%Wq!W%Wq!X%Wq!Y%Wq!Z%Wq![%Wq!]%Wq!^%Wq!`%Wq!a%Wq!c%Wq!m%Wq!o%Wq!s%Wq!y%Wq#W%Wq#b%Wq#d%Wq#e%Wq#p%Wq$T%Wq$]%Wq$^%Wq$a%Wq$d%Wq$l%Wq$z%Wq${%Wq$}%Wq%O%Wq%V%Wq&p%Wq'g%Wq&t%Wq!n%Wqh%Wqj%Wqf%Wqg%WqY%Wq_%Wqi%Wqe%Wq~Oc.iOd+vOh.hO~O!q(`O~OP6]OQ|OU^OW}O[:fOo>ROs#hOx:dOy:dO}`O!O]O!Q:kO!R}O!T:jO!U:eO!V:eO!Y:oO!c8gO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:hO$]:gO$^:hO$aqO$z:mO${!OO$}}O%O}O%V|O'g{O~O!m.lO!q.lO~OY+zO_+{O!n.nO~OY+zO_+{Oi%^a~O!x.rO~P>UO!m.tO~O!m.tO~P9yOQ|OW}O!R}O$}}O%O}O%V|O'g{O~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&ka!}&ka&s&ka~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m$qi!}$qi&s$qi~P!'WOS+^Om+^Os$aO!_+^O!`+^O$aqO$drO~OY/PO~P$?VOS+^Om+^Os$aO!_+^O!`+^O$aqO~O!s/QO~O!n/SO~P#JwOw(SO!o)WO#l'SO~OV/VO!m&na!}&na&s&na~O!})_O!m'ki&s'ki~O!s/XO~OV/YO!n%|a!}%|a~O]/[Os/[O!s#gO#peO!n&oX!}&oX~O!},uO!n'la~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&Ua!}&Ua&s&Ua#O&Ua~P!'WOz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT!uy!S!uy!b!uy!m!uy!v!uy&s!uy!x!uy!n!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#hi!}#hi~P!'WO_)yO!n&VX!}&VX~P9yO!}-RO!n&{a~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Vq#X#Vq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#[i!}#[i~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#O/cO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x&Xa!}&Xa~P!'WO#u/iO!x$ci!}$ci~O#b/jO~O#U/lO#b/kO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$ci!}$ci~P!'WO#u/mO!x$hi!}$hi~O!}/oO!x'[X~O#b/qO~O!x/rO~O!oXO!q/uO~O#l'SO!o'cy!m'cy&s'cy~O!m$jy&s$jy!x$jy!n$jy~PCqO#O/xO#l'SO~O!s#gO#peOw&aX!o&aX!}&aX!m&aX&s&aX~O!}-|Ow']a!o']a!m']a&s']a~OU$PO]0QO!R$PO!s$OO!v#}O#b$nO#p2XO~P$?uO!m#cO!o0VO&s#cO~O#X0YO~Oh0_O~OT:tOz:pO!S:vO!b:xO!m0`O!q0`O!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO~P!'WOY%]a_%]a!n%]ai%]a~PhO!x0bO~O!x0bO~P>UO!m0dO~OT6iOz6gO!S6jO!b6kO!v8sO!x0fO#O0eO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WO!x0fO~O!x0gO#b0hO#l'SO~O!x0iO~O!s0jO~O!m#cO#u0lO&s#cO~O!s0mO~O!})_O!m'kq&s'kq~O!s0nO~OV0oO!n%}X!}%}X~OT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!n!|i!}!|i~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$cq!}$cq~P!'WO#u0vO!x$cq!}$cq~O#b0wO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$hq!}$hq~P!'WO#S0zO#b0yO!x&`X!}&`X~O!}/oO!x'[a~O#l'SO!o'c!R!m'c!R&s'c!R~O!oXO!q1PO~O!m$j!R&s$j!R!x$j!R!n$j!R~PCqO#O1RO#l'SO~OP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!n1^O!s1YO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOh1_O~OY%[i_%[i!n%[ii%[i~PhOY%]i_%]i!n%]ii%]i~PhO!x1bO~O!x1bO~P>UO!x1eO~O!m#cO#u1iO&s#cO~O$}1jO%V1jO~O!s1kO~OV1lO!n%}a!}%}a~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#]i!}#]i~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$cy!}$cy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$hy!}$hy~P!'WO#b1nO~O!}/oO!x'[i~O!m$j!Z&s$j!Z!x$j!Z!n$j!Z~PCqOT:uOz:qO!S:wO!b:yO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO~P!'WOV1uO{1tO~P!5xOV1uO{1tOT&}Xz&}X!S&}X!b&}X!o&}X!v&}X!y&}X#S&}X#W&}X#`&}X#a&}X#s&}X#u&}X#w&}X#z&}X#{&}X#|&}X#}&}X$O&}X$Q&}X$R&}X$S&}X$T&}X$U&}X$V&}X$W&}X$z&}X~OP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!n1xO!s1YO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOY%[q_%[q!n%[qi%[q~PhO!x1zO~O!x%gi~PCqOe1{O~O$}1|O%V1|O~O!s2OO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$c!R!}$c!R~P!'WO!m$j!c&s$j!c!x$j!c!n$j!c~PCqO!s2QO~O!`2SO!s2RO~O!s2VO!m$xi&s$xi~O!s'WO~O!s*]O~OT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$ka#u$ka#w$ka&s$ka!x$ka!n$ka!q$ka#X$ka!}$ka~P!'WO#S2]O~P*kO$l$tO~P#.YOT6iOz6gO!S6jO!b6kO!v8sO#O2[O#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'PX&s'PX!x'PX!n'PX~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#O3uO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}'PX#X'PX#u'PX#w'PX!m'PX&s'PX!x'PX!n'PXV'PX!q'PX~P!'WO#S3dO~P#.YOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Xa#u$Xa#w$Xa&s$Xa!x$Xa!n$Xa!q$Xa#X$Xa!}$Xa~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Ya#u$Ya#w$Ya&s$Ya!x$Ya!n$Ya!q$Ya#X$Ya!}$Ya~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Za#u$Za#w$Za&s$Za!x$Za!n$Za!q$Za#X$Za!}$Za~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$[a#u$[a#w$[a&s$[a!x$[a!n$[a!q$[a#X$[a!}$[a~P!'WOz2aO#u$[a#w$[a!q$[a#X$[a!}$[a~PNyOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$_a#u$_a#w$_a&s$_a!x$_a!n$_a!q$_a#X$_a!}$_a~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$|a#u$|a#w$|a&s$|a!x$|a!n$|a!q$|a#X$|a!}$|a~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!S#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!S#yi!b#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$T2nO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$S2mO$T2nO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m#Ta#u#Ta#w#Ta&s#Ta!x#Ta!n#Ta!q#Ta#X#Ta!}#Ta~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m'Pa#u'Pa#w'Pa&s'Pa!x'Pa!n'Pa!q'Pa#X'Pa!}'Pa~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#Pi!S#Pi!b#Pi!m#Pi#u#Pi#w#Pi&s#Pi!x#Pi!n#Pi!q#Pi#X#Pi!}#Pi~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#vi!S#vi!b#vi!m#vi#u#vi#w#vi&s#vi!x#vi!n#vi!q#vi#X#vi!}#vi~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m#xi#u#xi#w#xi&s#xi!x#xi!n#xi!q#xi#X#xi!}#xi~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT!uq!S!uq!b!uq!m!uq!v!uq#u!uq#w!uq&s!uq!x!uq!n!uq!q!uq#X!uq!}!uq~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#Pq!S#Pq!b#Pq!m#Pq#u#Pq#w#Pq&s#Pq!x#Pq!n#Pq!q#Pq#X#Pq!}#Pq~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$jq#u$jq#w$jq&s$jq!x$jq!n$jq!q$jq#X$jq!}$jq~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT!uy!S!uy!b!uy!m!uy!v!uy#u!uy#w!uy&s!uy!x!uy!n!uy!q!uy#X!uy!}!uy~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$jy#u$jy#w$jy&s$jy!x$jy!n$jy!q$jy#X$jy!}$jy~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!R#u$j!R#w$j!R&s$j!R!x$j!R!n$j!R!q$j!R#X$j!R!}$j!R~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!Z#u$j!Z#w$j!Z&s$j!Z!x$j!Z!n$j!Z!q$j!Z#X$j!Z!}$j!Z~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!c#u$j!c#w$j!c&s$j!c!x$j!c!n$j!c!q$j!c#X$j!c!}$j!c~P!'WOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S3vO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lO#u2uO#w2vO!q&zX#X&zX!}&zX~P0rOP6]OU^O[4POo8^Or2wOs#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S2tO#U2sO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OOT#xXz#xX!S#xX!b#xX!m#xX!o#xX!v#xX#`#xX#a#xX#s#xX#u#xX#w#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX&s#xX!x#xX!n#xX!q#xX#X#xX!}#xX~P$;lOP6]OU^O[4POo8^Or4xOs#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S4uO#U4tO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OOT#xXz#xX!S#xX!b#xX!o#xX!v#xX!}#xX#O#xX#X#xX#`#xX#a#xX#s#xX#u#xX#w#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX!m#xX&s#xX!x#xX!n#xXV#xX!q#xX~P$;lO!q3PO~P>UO!q5}O#O3gO~OT8vOz8tO!S8wO!b8xO!q3hO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q6OO#O3kO~O!q6PO#O3oO~O#O3oO#l'SO~O#O3pO#l'SO~O#O3sO#l'SO~OP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$l$tO$z4bO${!OO~P$;lOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S5eO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Xa#O$Xa#X$Xa#u$Xa#w$Xa!m$Xa&s$Xa!x$Xa!n$XaV$Xa!q$Xa~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Ya#O$Ya#X$Ya#u$Ya#w$Ya!m$Ya&s$Ya!x$Ya!n$YaV$Ya!q$Ya~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Za#O$Za#X$Za#u$Za#w$Za!m$Za&s$Za!x$Za!n$ZaV$Za!q$Za~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$[a#O$[a#X$[a#u$[a#w$[a!m$[a&s$[a!x$[a!n$[aV$[a!q$[a~P!'WOz4dO!}$[a#O$[a#X$[a#u$[a#w$[aV$[a!q$[a~PNyOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$_a#O$_a#X$_a#u$_a#w$_a!m$_a&s$_a!x$_a!n$_aV$_a!q$_a~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$|a#O$|a#X$|a#u$|a#w$|a!m$|a&s$|a!x$|a!n$|aV$|a!q$|a~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!S#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!S#yi!b#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$T4qO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$S4pO$T4qO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}#Ta#O#Ta#X#Ta#u#Ta#w#Ta!m#Ta&s#Ta!x#Ta!n#TaV#Ta!q#Ta~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}'Pa#O'Pa#X'Pa#u'Pa#w'Pa!m'Pa&s'Pa!x'Pa!n'PaV'Pa!q'Pa~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#Pi!S#Pi!b#Pi!}#Pi#O#Pi#X#Pi#u#Pi#w#Pi!m#Pi&s#Pi!x#Pi!n#PiV#Pi!q#Pi~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#vi!S#vi!b#vi!}#vi#O#vi#X#vi#u#vi#w#vi!m#vi&s#vi!x#vi!n#viV#vi!q#vi~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}#xi#O#xi#X#xi#u#xi#w#xi!m#xi&s#xi!x#xi!n#xiV#xi!q#xi~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT!uq!S!uq!b!uq!v!uq!}!uq#O!uq#X!uq#u!uq#w!uq!m!uq&s!uq!x!uq!n!uqV!uq!q!uq~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#Pq!S#Pq!b#Pq!}#Pq#O#Pq#X#Pq#u#Pq#w#Pq!m#Pq&s#Pq!x#Pq!n#PqV#Pq!q#Pq~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$jq#O$jq#X$jq#u$jq#w$jq!m$jq&s$jq!x$jq!n$jqV$jq!q$jq~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT!uy!S!uy!b!uy!v!uy!}!uy#O!uy#X!uy#u!uy#w!uy!m!uy&s!uy!x!uy!n!uyV!uy!q!uy~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$jy#O$jy#X$jy#u$jy#w$jy!m$jy&s$jy!x$jy!n$jyV$jy!q$jy~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!R#O$j!R#X$j!R#u$j!R#w$j!R!m$j!R&s$j!R!x$j!R!n$j!RV$j!R!q$j!R~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!Z#O$j!Z#X$j!Z#u$j!Z#w$j!Z!m$j!Z&s$j!Z!x$j!Z!n$j!ZV$j!Z!q$j!Z~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!c#O$j!c#X$j!c#u$j!c#w$j!c!m$j!c&s$j!c!x$j!c!n$j!cV$j!c!q$j!c~P!'WO#S5wO~P#.YO!y$hO#S5{O~O!x4ZO#l'SO~O!y$hO#S5|O~OT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$ka#O$ka#X$ka#u$ka#w$ka!m$ka&s$ka!x$ka!n$kaV$ka!q$ka~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#O5vO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!m'PX#u'PX#w'PX&s'PX!x'PX!n'PX!q'PX#X'PX!}'PX~P!'WO#u4vO#w4wO!}&zX#O&zX#X&zXV&zX!q&zX~P0rO!q5QO~P>UO!q8bO#O5hO~OT8vOz8tO!S8wO!b8xO!q5iO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q8cO#O5lO~O!q8dO#O5pO~O#O5pO#l'SO~O#O5qO#l'SO~O#O5tO#l'SO~O$l$tO~P9yOo5zOs$lO~O#S7oO~P9yOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Xa#O$Xa#X$Xa!m$Xa&s$Xa!x$Xa!n$XaV$Xa!q$Xa~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Ya#O$Ya#X$Ya!m$Ya&s$Ya!x$Ya!n$YaV$Ya!q$Ya~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Za#O$Za#X$Za!m$Za&s$Za!x$Za!n$ZaV$Za!q$Za~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$[a#O$[a#X$[a!m$[a&s$[a!x$[a!n$[aV$[a!q$[a~P!'WOz6gO!}$[a#O$[a#X$[aV$[a!q$[a~PNyOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$_a#O$_a#X$_a!m$_a&s$_a!x$_a!n$_aV$_a!q$_a~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$ka#O$ka#X$ka!m$ka&s$ka!x$ka!n$kaV$ka!q$ka~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$|a#O$|a#X$|a!m$|a&s$|a!x$|a!n$|aV$|a!q$|a~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO!}7sO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'jX~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO!}7uO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&|X~P!'WOz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT6iOz6gO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!S#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT6iOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!S#yi!b#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi#}#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$T6tO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$S6sO$T6tO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WO#S7zO~P>UO!m#Ta&s#Ta!x#Ta!n#Ta~PCqO!m'Pa&s'Pa!x'Pa!n'Pa~PCqO#S;dO#U;cO!x&WX!}&WX~P9yO!}7lO!x'Oa~Oz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#Pi!S#Pi!b#Pi!}#Pi#O#Pi#X#Pi!m#Pi&s#Pi!x#Pi!n#PiV#Pi!q#Pi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#vi!S#vi!b#vi!}#vi#O#vi#X#vi!m#vi&s#vi!x#vi!n#viV#vi!q#vi~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#xi#O#xi#X#xi!m#xi&s#xi!x#xi!n#xiV#xi!q#xi~P!'WO!}7sO!x%da~O!x&UX!}&UX~P>UO!}7uO!x&|a~Oz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT!uq!S!uq!b!uq!v!uq!}!uq#O!uq#X!uq!m!uq&s!uq!x!uq!n!uqV!uq!q!uq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Vi!}#Vi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#Pq!S#Pq!b#Pq!}#Pq#O#Pq#X#Pq!m#Pq&s#Pq!x#Pq!n#PqV#Pq!q#Pq~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$jq#O$jq#X$jq!m$jq&s$jq!x$jq!n$jqV$jq!q$jq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&ka!}&ka~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&Ua!}&Ua~P!'WOz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT!uy!S!uy!b!uy!v!uy!}!uy#O!uy#X!uy!m!uy&s!uy!x!uy!n!uyV!uy!q!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Vq!}#Vq~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$jy#O$jy#X$jy!m$jy&s$jy!x$jy!n$jyV$jy!q$jy~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!R#O$j!R#X$j!R!m$j!R&s$j!R!x$j!R!n$j!RV$j!R!q$j!R~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!Z#O$j!Z#X$j!Z!m$j!Z&s$j!Z!x$j!Z!n$j!ZV$j!Z!q$j!Z~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!c#O$j!c#X$j!c!m$j!c&s$j!c!x$j!c!n$j!cV$j!c!q$j!c~P!'WO#S8[O~P9yO#O8ZO!m'PX&s'PX!x'PX!n'PXV'PX!q'PX~PGSO!y$hO#S8`O~O!y$hO#S8aO~O#u6zO#w6{O!}&zX#O&zX#X&zXV&zX!q&zX~P0rOr6|O#S#oO#U#nO!}#xX#O#xX#X#xXV#xX!q#xX~P2yOr;iO#S9XO#U9VOT#xXz#xX!S#xX!b#xX!m#xX!o#xX!q#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX!n#xX!}#xX~P9yOr9WO#S9WO#U9WOT#xXz#xX!S#xX!b#xX!o#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX~P9yOr9]O#S;dO#U;cOT#xXz#xX!S#xX!b#xX!o#xX!q#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX#X#xX!x#xX!}#xX~P9yO$l$tO~P>UO!q7XO~P>UOT6iOz6gO!S6jO!b6kO!v8sO#O7iO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x'PX!}'PX~P!'WOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lO!}7lO!x'OX~O#S9yO~P>UOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Xa#X$Xa!x$Xa!}$Xa~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Ya#X$Ya!x$Ya!}$Ya~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Za#X$Za!x$Za!}$Za~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$[a#X$[a!x$[a!}$[a~P!'WOz8tO$z#dOT$[a!S$[a!b$[a!q$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a#X$[a!x$[a!}$[a~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$_a#X$_a!x$_a!}$_a~P!'WO!q=dO#O7rO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$ka#X$ka!x$ka!}$ka~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$|a#X$|a!x$|a!}$|a~P!'WOT8vOz8tO!S8wO!b8xO!q7wO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#X#yi!x#yi!}#yi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi#X#yi!x#yi!}#yi~P!'WOT8vOz8tO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!S#yi!q#yi#X#yi!x#yi!}#yi~P!'WOT8vOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!S#yi!b#yi!q#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi#X#yi!x#yi!}#yi~P!'WOz8tO$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi#X#yi!x#yi!}#yi~P!'WOz8tO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi#X#yi!x#yi!}#yi~P!'WOz8tO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi#X#yi!x#yi!}#yi~P!'WOz8tO$T9RO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$S9QO$T9RO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi#X#yi!x#yi!}#yi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#Pi!S#Pi!b#Pi!q#Pi#X#Pi!x#Pi!}#Pi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#vi!S#vi!b#vi!q#vi#X#vi!x#vi!}#vi~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q#xi#X#xi!x#xi!}#xi~P!'WO!q=eO#O7|O~Oz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT!uq!S!uq!b!uq!q!uq!v!uq#X!uq!x!uq!}!uq~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#Pq!S#Pq!b#Pq!q#Pq#X#Pq!x#Pq!}#Pq~P!'WO!q=iO#O8TO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$jq#X$jq!x$jq!}$jq~P!'WO#O8TO#l'SO~Oz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT!uy!S!uy!b!uy!q!uy!v!uy#X!uy!x!uy!}!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$jy#X$jy!x$jy!}$jy~P!'WO#O8UO#l'SO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!R#X$j!R!x$j!R!}$j!R~P!'WO#O8XO#l'SO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!Z#X$j!Z!x$j!Z!}$j!Z~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!c#X$j!c!x$j!c!}$j!c~P!'WO#S:bO~P>UO#O:aO!q'PX!x'PX~PGSO$l$tO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$l$tO$z:nO${!OO~P$;lOo8_Os$lO~O#S<jO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#S<kO#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Xa!q$Xa!n$Xa!}$Xa~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Ya!q$Ya!n$Ya!}$Ya~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Za!q$Za!n$Za!}$Za~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$[a!q$[a!n$[a!}$[a~P!'WOz:pO$z#dOT$[a!S$[a!b$[a!m$[a!q$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a!n$[a!}$[a~P!'WOz:qO$z#dOT$[a!S$[a!b$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$_a!q$_a!n$_a!}$_a~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$ka!q$ka!n$ka!}$ka~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$|a!q$|a!n$|a!}$|a~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi!n#yi!}#yi~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!n#yi!}#yi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi~P!'WOT:tOz:pO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!S#yi!m#yi!q#yi!n#yi!}#yi~P!'WOT:uOz:qO!b:yO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO!S#yi~P!'WOT:tOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!S#yi!b#yi!m#yi!q#yi!n#yi!}#yi~P!'WOT:uOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO!S#yi!b#yi~P!'WOz:pO#S#QO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi!n#yi!}#yi~P!'WOz:qO#S#QO#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi~P!'WOz:pO#S#QO#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi!n#yi!}#yi~P!'WOz:qO#S#QO#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi~P!'WOz:pO#S#QO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi!n#yi!}#yi~P!'WOz:qO#S#QO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi#}#yi~P!'WOz:pO#S#QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi!n#yi!}#yi~P!'WOz:qO#S#QO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi~P!'WOz:pO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi!n#yi!}#yi~P!'WOz:qO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi~P!'WOz:pO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!n#yi!}#yi~P!'WOz:qO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi~P!'WOz:pO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!n#yi!}#yi~P!'WOz:qO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi~P!'WOz:pO$T;[O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!n#yi!}#yi~P!'WOz:qO$T;]O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi~P!'WOz:pO$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!n#yi!}#yi~P!'WOz:qO$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi~P!'WOz:pO$S;YO$T;[O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!n#yi!}#yi~P!'WOz:qO$S;ZO$T;]O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi~P!'WOz:pO$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!n#yi!}#yi~P!'WOz:qO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Ta!}#Ta!q#Ta#X#Ta~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'Pa!}'Pa!q'Pa#X'Pa~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#Pi!S#Pi!b#Pi!m#Pi!q#Pi!n#Pi!}#Pi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#Pi!S#Pi!b#Pi~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#vi!S#vi!b#vi!m#vi!q#vi!n#vi!}#vi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#vi!S#vi!b#vi~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m#xi!q#xi!n#xi!}#xi~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT!uq!S!uq!b!uq!m!uq!q!uq!v!uq!n!uq!}!uq~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT!uq!S!uq!b!uq!v!uq~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#Pq!S#Pq!b#Pq!m#Pq!q#Pq!n#Pq!}#Pq~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#Pq!S#Pq!b#Pq~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$jq!q$jq!n$jq!}$jq~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT!uy!S!uy!b!uy!m!uy!q!uy!v!uy!n!uy!}!uy~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT!uy!S!uy!b!uy!v!uy~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$jy!q$jy!n$jy!}$jy~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!R!q$j!R!n$j!R!}$j!R~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!Z!q$j!Z!n$j!Z!}$j!Z~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!c!q$j!c!n$j!c!}$j!c~P!'WO#S=TO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#S=UO#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOT6iOz6gO!S6jO!b6kO!v8sO#O=SO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#O=RO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'PX!q'PX!n'PX!}'PX~P!'WOT&zXz&zX!S&zX!b&zX!o&zX!q&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX!}&zX~O#u9ZO#w9[O#X&zX!x&zX~P.8oO!y$hO#S=^O~O!q9hO~P>UO!y$hO#S=cO~O!q>OO#O9}O~OT8vOz8tO!S8wO!b8xO!q:OO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m#Ta!q#Ta!n#Ta!}#Ta~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m'Pa!q'Pa!n'Pa!}'Pa~P!'WO!q>PO#O:RO~O!q>QO#O:YO~O#O:YO#l'SO~O#O:ZO#l'SO~O#O:_O#l'SO~O#u;eO#w;gO!m&zX!n&zX~P.8oO#u;fO#w;hOT&zXz&zX!S&zX!b&zX!o&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX~O!q;tO~P>UO!q;uO~P>UO!q>XO#O<oO~O!q>YO#O9WO~OT8vOz8tO!S8wO!b8xO!q<pO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT8vOz8tO!S8wO!b8xO!q<qO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q>ZO#O<vO~O!q>[O#O<{O~O#O<{O#l'SO~O#O9WO#l'SO~O#O<|O#l'SO~O#O=PO#l'SO~O!y$hO#S=|O~Oo=[Os$lO~O!y$hO#S=}O~O!y$hO#S>UO~O!y$hO#S>VO~O!y$hO#S>WO~Oo={Os$lO~Oo>TOs$lO~Oo>SOs$lO~O%O$U$}$d!d$V#b%V#e'g!s#d~",
        goto: "%&y'mPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP'nP'uPP'{(OPPP(hP(OP(O*ZP*ZPP2W:j:mPP*Z:sBpPBsPBsPP:sCSCVCZ:s:sPPPC^PP:sK^!$S!$S:s!$WP!$W!$W!%UP!.]!7pP!?oP*ZP*Z*ZPPPPP!?rPPPPPPP*Z*Z*Z*ZPP*Z*ZP!E]!GRP!GV!Gy!GR!GR!HP*Z*ZP!HY!Hl!Ib!J`!Jd!J`!Jo!J}!J}!KV!KY!KY*ZPP*ZPP!K^#%[#%[#%`P#%fP(O#%j(O#&S#&V#&V#&](O#&`(O(O#&f#&i(O#&r#&u(O(O(O(O(O#&x(O(O(O(O(O(O(O(O(O#&{!KR(O(O#'_#'o#'r(O(OP#'u#'|#(S#(o#(y#)P#)Z#)b#)h#*d#4X#5T#5Z#5a#5k#5q#5w#6]#6c#6i#6o#6u#6{#7R#7]#7g#7m#7s#7}PPPPPPPP#8T#8X#8}#NO#NR#N]$(f$(r$)X$)_$)b$)e$)k$,X$5v$>_$>b$>h$>k$>n$>w$>{$?X$?k$Bk$CO$C{$K{PP%%y%%}%&Z%&p%&vQ!nQT!qV!rQUOR%x!mRVO}!hPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1a|!hPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ%^!ZQ%g!aQ%l!eQ'd$dQ'q$iQ)[%kQ*y'tQ,](xU-n*v*x+OQ.W+cQ.{,[S/t-s-tQ0T.SS0}/s/wQ1V0RQ1o1OR2P1p0u!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nQ#j]Q$}!PQ%O!QQ%P!RQ,S(kQ.b+sR.f+vR&q#jQ)z&pR/a-R0uhPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR#l^k#p_j#k#s&s&w3x3y7l8f8g8h8iR#u`T&|#t'OR-Y*U0thPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR#va-r#OZ#f#m#w$V$W$X$Y$Z$[$u$v%W%Y%[%`%s%|&O&Q&U&^&_&`&a&b&c&d&e&f&g&h&i&j&k&l&m&u&v&{'X'Z'[(](p)q)s)u*O*[*^+S+V,`,c,y,{,}-V-W-X-i-x.k.w/`/h/n/y0r0u0x1Q1X1d1m1q2q2r2x2y2z2{2|2}3O3Q3R3S3T3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3e3f3i3j3l3m3n3q3r3t4Y4y4z4{4|4}5O5P5R5S5T5U5V5W5X5Y5Z5[5]5^5_5`5a5b5c5d5f5g5j5k5m5n5o5r5s5u6R6V6}7O7P7Q7R7S7U7V7W7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7j7k7n7p7q7x7y7{7}8O8P8Q8R8S8V8W8Y8]9U9^9_9`9a9b9c9f9g9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9z9{:P:Q:T:V:W:[:^:`:c;j;k;l;m;n;o;p;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<[<]<^<_<`<a<b<c<d<e<f<g<h<i<l<m<n<r<s<t<u<w<x<y<z<}=O=Q=V=W=_=`=a=q=rQ']$]Y(Q$s7T9e;q;rS(U2Z6QR(X$tT&X!})v!w$Qg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[3ZfPVX[_bgjklmnoprxyz!S!W!X!Y!]!e!f!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t#}$R$S$U$h$y$}%P%R%S%T%U%c%p%r%}&S&W&p&s&t&w'O'S'U'Y'^'i'm'r'z(O(P(R(S(T(`(l({)P)Z)_)c)i)p)t)v*P*T*U*f*o*s*z*}+P+Q+]+`+d+g+r+u+z,T,V,X,Z,u-Q-R-d-k-r-u-z-{-|.Q.b.d.l.t/[/c/i/m/u/x0V0`0a0d0e0i0v1P1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w5}6O6P6T6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8b8c8d8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=d=e=i=m=n>O>P>Q>X>Y>Z>[3scPVX[_bdegjklmnoprxyz!S!W!X!Y!]!e!f!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t#{#}$R$S$U$h$y$}%P%R%S%T%U%c%m%n%p%r%}&S&W&p&s&t&w'O'S'U'Y'^'i'm'r'z(O(P(R(S(T(`(l({)P)Z)^)_)c)g)h)i)p)t)v*P*T*U*f*o*s*z*}+P+Q+]+`+d+g+r+u+z,T,V,X,Z,u,x-Q-R-d-k-r-u-z-{-|.Q.b.d.l.t/[/c/i/m/u/x0V0`0a0d0e0i0v1P1R1]1a2W2X2Y2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w5}6O6P6T6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8b8c8d8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=d=e=i=m=n>O>P>Q>X>Y>Z>[0phPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0`0a0d0e0i0v1R1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT1Z0V1]R&]#P!n#[Z#f#w$V$W$X$Y$[$s$v%W%Y%[&Q&_&`&a&b&c&d&e&f'X'Z'[(])q)s*^+V,{-x/y1Q1d1q7j7k!Y2j2Z2x2y2z2{2}3O3Q3R3S3T3U3V3W3X3a3b3c3e3f3i3j3l3m3n3q3r3t!^4m2r4y4z4{4|5O5P5R5S5T5U5V5W5X5Y5b5c5d5f5g5j5k5m5n5o5r5s5u6Q6R#Q6p#m%`%s&u&v&{(p*O+S,`,c,y-V-X.w2q6}7O7P7Q7S7T7U7Y7Z7[7]7^7_7`7a7n7p7q7x7{7}8Q8S8V8W8Y8]9U:c=V=W#^8}%|&O&U)u,}-W-i/h/n0r0u0x1m4Y6V7V7W7y8O8P8R9^9_9`9a9c9e9f9g9i9j9k9l9m9n9o9p9x9z9{:P:Q:T:V:W:[:^:`<f<g=_=q=r!^;S.k/`;j;k;l;m;p;q;s;v;x;z;|<O<Q<S<U<h<l<n<r<t<w<x<z<}=O=Q=`=ao;T1X;r;w;y;{;}<P<R<T<V<i<m<s<u<yS$iu#hQ$qwU't$j$l&oQ'v$kS'x$m$rQ*|'uQ+O'wQ+R'yQ4X5xS4[5z5{Q4]5|Q6U8^S6W8_8`Q6X8aQ9d=YS9|=[=^Q:S=cQ=]=yS=b={=|Q=f=}Q=o>RS=p>S>VS=s>T>UR=t>WT'n$h*s!csPVXt!S!j!r!s!w$h$}%P%S%U'i(T(`)W*s+]+g+r+u,g,k.b.d.l0`0a0i1aQ$^rR*`'^Q*x'sQ-t*{R/w-wQ(W$tQ)U%hQ)n%vQ*i'fQ+k(XR-c*jQ(V$tQ)Y%jQ)m%vQ*e'eS*h'f)nS+j(W(XS-b*i*jQ.]+kQ/T,mQ/e-`R/g-cQ(U$tQ)T%hQ)V%iQ)l%vU*g'f)m)nU+i(V(W(XQ,f)UU-a*h*i*jS.[+j+kS/f-b-cQ0X.]R0t/gT+e(T+g[%e!_$b'c+a.R0QR,d)Qb$ov(T+[+]+`+g.P.Q0PR+T'{S+e(T+gT,j)W,kR0W.XT1[0V1]0w|PVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X,_-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT$x{${Q+p([R._+nT$z{${Q(b$}Q(j%PQ(o%SQ(r%UQ.j+yQ0].fQ0^.iR1g0iR(e%OX+|(c(d+},PR(f%OX(h%P%S%U0iR%S!T_%a!]%R(l,T,V.t0dR%U!UR.x,XR,[(wQ)X%jS*d'e)YS-_*e,mS/d-`/TR0s/eQ%q!fU)]%m%n%rU,o)^)g)hR/_,xR)d%pR/],uSSO!mR!oSQ!rVR%y!rQ!jPS!sV!rQ!wX[%u!j!s!w+r0a1aQ+r(`Q0a.lR1a0`Q)j%sS,z)j7vR7v7WQ-S)zR/b-SQ&x#qS*R&x7mR7m9YS*V&{&|R-Z*VQ)w&YR-P)w!l'T#|'h*n*q*v+W+[,m-`-s-v-y.P.z/s/v/z0P1O1p4^4_4`5y6Y6Z6[:U:X:]=g=h=j=u=v=w=xR*Z'T1^dPVX[_bjklmnoprxyz!S!W!X!Y!]!e!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%p%}&S&W&p&s&t&w'O'U'Y'^'z(O(R(S(`(l({)P)_)c)i)p)t)v*P*T*U*o+P+d+r+u+z,T,V,X,u-Q-R-d-k-z-|.b.d.l.t/[/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n`#zd#{%m)^)g,x2W2YQ#{eQ%m!fQ)^%nQ)g%rQ,x)h!v2Wg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[R2Y2X|tPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aW$`t'i+],gS'i$h*sS+](T+gT,g)W,kQ'_$^R*a'_Q*t'oR-m*tQ/p-oS0{/p0|R0|/qQ-}+XR/|-}Q+g(TR.Y+gS+`(T+gS,h)W,kQ.Q+]W.T+`,h.Q/OR/O,gQ)R%eR,e)RQ'|$oR+U'|Q1]0VR1w1]Q${{R(^${Q+t(aR.c+tQ+w(bR.g+wQ+}(cQ,P(dT.m+},PQ(|%`S,a(|7tR7t7VQ(y%^R,^(yQ,k)WR/R,kQ)`%oS,q)`/WR/W,rQ,v)dR/^,vT!uV!rj!iPVX!j!r!s!w(`+r.l0`0a1aQ%Q!SQ(a$}W(h%P%S%U0iQ.e+uQ0Z.bR0[.d|ZPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ#f[U#m_#s&wQ#wbQ$VkQ$WlQ$XmQ$YnQ$ZoQ$[pQ$sx^$uy2_4b6e8q:m:nQ$vzQ%W!WQ%Y!XQ%[!YW%`!]%R(l,VU%s!g&p-RQ%|!yQ&O!zQ&Q!{S&U!})v^&^#R2a4d6g8t:p:qQ&_#SQ&`#TQ&a#UQ&b#VQ&c#WQ&d#XQ&e#YQ&f#ZQ&g#[Q&h#]Q&i#^Q&j#_Q&k#`Q&l#aQ&m#bQ&u#nQ&v#oS&{#t'OQ'X$RQ'Z$SQ'[$UQ(]$yQ(p%TQ)q%}Q)s&SQ)u&WQ*O&tS*['U4ZQ*^'Y^*_2[3u5v8Z:a=R=SQ+S'zQ+V(OQ,`({Q,c)PQ,y)iQ,{)pQ,})tQ-V*PQ-W*TQ-X*U^-]2]3v5w8[:b=T=UQ-i*oQ-x+PQ.k+zQ.w,XQ/`-QQ/h-dQ/n-kQ/y-zQ0r/cQ0u/iQ0x/mQ1Q/xU1X0V1]9WQ1d0eQ1m0vQ1q1RQ2Z2^Q2qjQ2r3yQ2x3zQ2y3|Q2z4OQ2{4QQ2|4SQ2}4UQ3O2`Q3Q2bQ3R2cQ3S2dQ3T2eQ3U2fQ3V2gQ3W2hQ3X2iQ3Y2jQ3Z2kQ3[2lQ3]2mQ3^2nQ3_2oQ3`2pQ3a2sQ3b2tQ3c2uQ3e2vQ3f2wQ3i3PQ3j3dQ3l3gQ3m3hQ3n3kQ3q3oQ3r3pQ3t3sQ4Y4WQ4y3{Q4z3}Q4{4PQ4|4RQ4}4TQ5O4VQ5P4cQ5R4eQ5S4fQ5T4gQ5U4hQ5V4iQ5W4jQ5X4kQ5Y4lQ5Z4mQ5[4nQ5]4oQ5^4pQ5_4qQ5`4rQ5a4sQ5b4tQ5c4uQ5d4vQ5f4wQ5g4xQ5j5QQ5k5eQ5m5hQ5n5iQ5o5lQ5r5pQ5s5qQ5u5tQ6Q4aQ6R3xQ6V6TQ6}6^Q7O6_Q7P6`Q7Q6aQ7R6bQ7S6cQ7T6dQ7U6fU7V,T.t0dQ7W%cQ7Y6hQ7Z6iQ7[6jQ7]6kQ7^6lQ7_6mQ7`6nQ7a6oQ7b6pQ7c6qQ7d6rQ7e6sQ7f6tQ7g6uQ7h6vQ7j6xQ7k6yQ7n6zQ7p6{Q7q6|Q7x7XQ7y7iQ7{7oQ7}7rQ8O7sQ8P7uQ8Q7wQ8R7zQ8S7|Q8V8TQ8W8UQ8Y8XQ8]8fU9U#k&s7lQ9^8jQ9_8kQ9`8lQ9a8mQ9b8nQ9c8oQ9e8pQ9f8rQ9g8sQ9i8uQ9j8vQ9k8wQ9l8xQ9m8yQ9n8zQ9o8{Q9p8|Q9q8}Q9r9OQ9s9PQ9t9QQ9u9RQ9v9SQ9w9TQ9x9ZQ9z9[Q9{9]Q:P9hQ:Q9yQ:T9}Q:V:OQ:W:RQ:[:YQ:^:ZQ:`:_Q:c8iQ;j:dQ;k:eQ;l:fQ;m:gQ;n:hQ;o:iQ;p:jQ;q:kQ;r:lQ;s:oQ;v:rQ;w:sQ;x:tQ;y:uQ;z:vQ;{:wQ;|:xQ;}:yQ<O:zQ<P:{Q<Q:|Q<R:}Q<S;OQ<T;PQ<U;QQ<V;RQ<W;SQ<X;TQ<Y;UQ<Z;VQ<[;WQ<];XQ<^;YQ<_;ZQ<`;[Q<a;]Q<b;^Q<c;_Q<d;`Q<e;aQ<f;cQ<g;dQ<h;eQ<i;fQ<l;gQ<m;hQ<n;iQ<r;tQ<s;uQ<t<jQ<u<kQ<w<oQ<x<pQ<y<qQ<z<vQ<}<{Q=O<|Q=Q=PQ=V8hQ=W8gQ=_=ZQ=`9VQ=a9XQ=q=mR=r=nR){&pQ%t!gQ)O%cT)y&p-R$SiPVX[bklmnopxyz!S!W!X!Y!j!r!s!w!{#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b$R$S$U$y$}%P%S%U%}&S'Y(O(`)p+P+r+u-z.b.d.l/x0`0a0e0i1R1a2[2]6x6y!t3w'U2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3z3|4O4Q4S4U5v5w!x6S3u3v3x3y3{3}4P4R4T4V4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t$O8e_j!]!g#k#n#o#s#t%R%T&p&s&t&w'O'z(l({)P)i*P*U,V,X-R6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6z6{6|7X7l7o7r7w7|8T8U8X8Z8[8f8g8h8i#|=X!y!z!}%c&W)t)v*T*o,T-d-k.t/c/i/m0d0v4W6T7i7s7u7z8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9Z9[9]9h9y9}:O:R:Y:Z:_:a:b;c;d=Z=m=n!v=k+z-Q9V9X:d:e:f:g:h:j:k:m:o:p:r:t:v:x:z:|;O;Q;S;U;W;Y;[;^;`;e;g;i;t<j<o<p<v<{<|=P=R=T!]=l0V1]9W:i:l:n:q:s:u:w:y:{:};P;R;T;V;X;Z;];_;a;f;h;u<k<q=S=UQ#r_Q&r#kQ&z#sR)}&sS#q_#s^$Tj3x3y8f8g8h8iS*Q&w7lT9Y#k&sQ&}#tR*X'OR&T!|R&Z!}Q&Y!}R-O)vQ#|gQ'V#}S'h$h*sQ*Y'SQ*n'iQ*q'mQ*v'rQ+W(PS+[(T+gQ,m)ZQ-`*fQ-s*zQ-v*}Q-y+QS.P+]+`Q.z,ZQ/s-rQ/v-uQ/z-{Q0P.QQ1O/uQ1p1PQ4^5}Q4_6OQ4`6PQ5y6]Q6Y8bQ6Z8cQ6[8dQ:U=dQ:X=eQ:]=iQ=g>OQ=h>PQ=j>QQ=u>XQ=v>YQ=w>ZR=x>[0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n!v$Pg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[S$]r'^Q%k!eS%o!f%rQ)b%pU+X(R(S+dQ,p)_Q,t)cQ/Z,uQ/{-|R0p/[|vPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1a#U#i[bklmnopxyz!W!X!Y!{#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b$R$S$U$y%}&S'Y(O)p+P-z/x0e1R2[2]6x6yd+^(T)W+]+`+g,g,h,k.Q/O!t6w'U2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3z3|4O4Q4S4U5v5w!x;b3u3v3x3y3{3}4P4R4T4V4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t$O=z_j!]!g#k#n#o#s#t%R%T&p&s&t&w'O'z(l({)P)i*P*U,V,X-R6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6z6{6|7X7l7o7r7w7|8T8U8X8Z8[8f8g8h8i#|>]!y!z!}%c&W)t)v*T*o,T-d-k.t/c/i/m0d0v4W6T7i7s7u7z8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9Z9[9]9h9y9}:O:R:Y:Z:_:a:b;c;d=Z=m=n!v>^+z-Q9V9X:d:e:f:g:h:j:k:m:o:p:r:t:v:x:z:|;O;Q;S;U;W;Y;[;^;`;e;g;i;t<j<o<p<v<{<|=P=R=T!]>_0V1]9W:i:l:n:q:s:u:w:y:{:};P;R;T;V;X;Z;];_;a;f;h;u<k<q=S=UR'p$hQ'o$hR-l*sR$_rR-q*wQ+Y(RQ+Z(SR.X+dT+f(T+ge+_(T)W+]+`+g,g,h,k.Q/OQ%f!_Q'b$bQ*c'cQ.U+aQ0S.RR1U0QQ#eZQ%X!WQ%Z!XQ%]!YQ'}$pQ(s%VQ(t%WQ(u%YQ(v%[Q(}%bQ)S%fQ)[%kQ)f%qQ)k%tQ*b'bQ,n)]Q-^*cQ.V+bQ.W+cQ.e+xQ.o,QQ.p,RQ.q,SQ.v,WQ.y,YQ.},bQ/U,oQ/}.OQ0T.SQ0U.UQ0W.XQ0[.hQ0k/QQ0q/_Q1S0OQ1V0RQ1W0SQ1`0_Q1h0jQ1r1TQ1s1UQ1v1[Q1y1_Q1}1jQ2T1{R2U1|Q$pvS+b(T+gU.O+[+]+`S0O.P.QR1T0P|!aPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ$dtW+c(T)W+g,kW.S+]+`,g,hT0R.Q/O0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR.|,_0w}PVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X,_-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT$w{${Q(i%PQ(n%SQ(q%UR1f0iQ%b!]Q(m%RQ,U(lQ.s,TQ.u,VQ0c.tR1c0dQ%q!fR)]%rR)e%p",
        nodeNames: "⚠ ( HeredocString EscapeSequence abstract LogicOp array as Boolean break case catch clone const continue default declare do echo else elseif enddeclare endfor endforeach endif endswitch endwhile enum extends final finally fn for foreach from function global goto if implements include include_once LogicOp insteadof interface list match namespace new null LogicOp print require require_once return switch throw trait try unset use var Visibility while LogicOp yield LineComment BlockComment TextInterpolation PhpClose Text PhpOpen Template TextInterpolation EmptyStatement ; } { Block : LabelStatement Name ExpressionStatement ConditionalExpression LogicOp MatchExpression ) ( ParenthesizedExpression MatchBlock MatchArm , => AssignmentExpression ArrayExpression ValueList & VariadicUnpacking ... Pair [ ] ListExpression ValueList Pair Pair SubscriptExpression MemberExpression -> ?-> VariableName DynamicVariable $ ${ CallExpression ArgList NamedArgument SpreadArgument CastExpression UnionType LogicOp OptionalType NamedType QualifiedName \\ NamespaceName ScopedExpression :: ClassMemberName AssignOp UpdateExpression UpdateOp YieldExpression BinaryExpression LogicOp LogicOp LogicOp BitOp BitOp BitOp CompareOp CompareOp BitOp ArithOp ConcatOp ArithOp ArithOp IncludeExpression RequireExpression CloneExpression UnaryExpression ControlOp LogicOp PrintIntrinsic FunctionExpression static ParamList Parameter #[ Attributes Attribute VariadicParameter PropertyParameter UseList ArrowFunction NewExpression class BaseClause ClassInterfaceClause DeclarationList ConstDeclaration VariableDeclarator PropertyDeclaration VariableDeclarator MethodDeclaration UseDeclaration UseList UseInsteadOfClause UseAsClause UpdateExpression ArithOp ShellExpression ThrowExpression Integer Float String MemberExpression SubscriptExpression UnaryExpression ArithOp Interpolation String IfStatement ColonBlock SwitchStatement Block CaseStatement DefaultStatement ColonBlock WhileStatement EmptyStatement DoStatement ForStatement ForSpec SequenceExpression ForeachStatement ForSpec Pair GotoStatement ContinueStatement BreakStatement ReturnStatement TryStatement CatchDeclarator DeclareStatement EchoStatement UnsetStatement ConstDeclaration FunctionDefinition ClassDeclaration InterfaceDeclaration TraitDeclaration EnumDeclaration EnumBody EnumCase NamespaceDefinition NamespaceUseDeclaration UseGroup UseClause UseClause GlobalDeclaration FunctionStaticDeclaration Program",
        maxTerm: 304,
        nodeProps: [["group", -36, 2, 8, 49, 81, 83, 85, 88, 93, 94, 102, 106, 107, 110, 111, 114, 118, 123, 126, 130, 132, 133, 147, 148, 149, 150, 153, 154, 164, 165, 179, 181, 182, 183, 184, 185, 191, "Expression", -28, 74, 78, 80, 82, 192, 194, 199, 201, 202, 205, 208, 209, 210, 211, 212, 214, 215, 216, 217, 218, 219, 220, 221, 222, 225, 226, 230, 231, "Statement", -3, 119, 121, 122, "Type"], ["openedBy", 69, "phpOpen", 76, "{", 86, "(", 101, "#["], ["closedBy", 71, "phpClose", 77, "}", 87, ")", 158, "]"]],
        propSources: [phpHighlighting],
        skippedNodes: [0],
        repeatNodeCount: 29,
        tokenData: "!5z_R!ZOX$tXY%qYZ'QZ]$t]^%q^p$tpq%qqr(`rs)zst*dtu/tuv2evw3fwx4mxy8Xyz8oz{9V{|:a|};h}!O<O!O!P=[!P!QBu!Q!RGO!R![Hz![!]! W!]!^!![!^!_!!r!_!`!%b!`!a!&f!a!b!'j!b!c!*d!c!d!*z!d!e!,Q!e!}!*z!}#O!-z#O#P!.b#P#Q!.x#Q#R!/`#R#S!*z#S#T!/y#T#U!*z#U#V!,Q#V#o!*z#o#p!3]#p#q!3s#q#r!4|#r#s!5d#s$f$t$f$g%q$g&j!*z&j$I_$t$I_$I`%q$I`$KW$t$KW$KX%q$KX?HT$t?HT?HU%q?HU~$tP$yT&wPOY$tYZ%YZ!^$t!^!_%_!_~$tP%_O&wPP%bTOY$tYZ%YZ!a$t!b~$t~~%YV%xb&wP&vUOX$tXY%qYZ'QZ]$t]^%q^p$tpq%qq!^$t!^!_%_!_$f$t$f$g%q$g$I_$t$I_$I`%q$I`$KW$t$KW$KX%q$KX?HT$t?HT?HU%q?HU~$tV'XW&wP&vUXY'qYZ'q]^'qpq'q$f$g'q$I_$I`'q$KW$KX'q?HT?HU'qU'vW&vUXY'qYZ'q]^'qpq'q$f$g'q$I_$I`'q$KW$KX'q?HT?HU'qR(gU$^Q&wPOY$tYZ%YZ!^$t!^!_%_!_!`(y!`~$tR)QU$QQ&wPOY$tYZ%YZ!^$t!^!_%_!_!`)d!`~$tR)kT$QQ&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV*TT'fS&wP'gQOY$tYZ%YZ!^$t!^!_%_!_~$tV*kZ&wP!dUOY+^YZ%YZ]+^]^$t^!^+^!^!_,Q!_!a+^!a!b-o!b!}+^!}#O/O#O~+^V+eX&wP!dUOY+^YZ%YZ]+^]^$t^!^+^!^!_,Q!_!a+^!a!b-o!b~+^V,VW!dUOY+^YZ%YZ]+^]^$t^!a+^!a!b,o!b~+^~~%YU,rUOY-UYZ-jZ]-U]^-j^!`-U!a~-UU-ZT!dUOY-UZ]-U^!a-U!a!b,o!b~-UU-oO!dUV-tX&wPOY+^YZ.aZ]+^]^.h^!^+^!^!_,Q!_!`+^!`!a$t!a~+^V.hO&wP!dUV.oT&wP!dUOY$tYZ%YZ!^$t!^!_%_!_~$tV/XX&wP$dQ!dUOY+^YZ%YZ]+^]^$t^!^+^!^!_,Q!_!a+^!a!b-o!b~+^_/{^&wP#dQOY$tYZ%YZ!^$t!^!_%_!_!c$t!c!}0w!}#R$t#R#S0w#S#T$t#T#o0w#o#p1}#p$g$t$g&j0w&j~$t_1O_&wP#b^OY$tYZ%YZ!Q$t!Q![0w![!^$t!^!_%_!_!c$t!c!}0w!}#R$t#R#S0w#S#T$t#T#o0w#o$g$t$g&j0w&j~$tV2UT&wP#eUOY$tYZ%YZ!^$t!^!_%_!_~$tR2lU&wP$VQOY$tYZ%YZ!^$t!^!_%_!_!`3O!`~$tR3VT#wQ&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV3mW#SU&wPOY$tYZ%YZv$tvw4Vw!^$t!^!_%_!_!`3O!`~$tR4^T#|Q&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR4tX&wP%VQOY4mYZ5aZw4mwx6hx!^4m!^!_7O!_#O4m#O#P7s#P~4mR5hT&wP%VQOw5wwx6]x#O5w#O#P6b#P~5wQ5|T%VQOw5wwx6]x#O5w#O#P6b#P~5wQ6bO%VQQ6ePO~5wR6oT&wP%VQOY$tYZ%YZ!^$t!^!_%_!_~$tR7TY%VQOY4mYZ5aZw4mwx6hx!a4m!a!b5w!b#O4m#O#P7s#P~4m~~%YR7xT&wPOY4mYZ5aZ!^4m!^!_7O!_~4mR8`T!yQ&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV8vT!xU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR9^W&wP$VQOY$tYZ%YZz$tz{9v{!^$t!^!_%_!_!`3O!`~$tR9}U$WQ&wPOY$tYZ%YZ!^$t!^!_%_!_!`3O!`~$tR:hW$TQ&wPOY$tYZ%YZ{$t{|;Q|!^$t!^!_%_!_!`3O!`~$tR;XT$zQ&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR;oT!}Q&wPOY$tYZ%YZ!^$t!^!_%_!_~$t_<XX$TQ%TW&wPOY$tYZ%YZ}$t}!O;Q!O!^$t!^!_%_!_!`3O!`!a<t!a~$tV<{T#`U&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV=cY&wP$UQOY$tYZ%YZ!O$t!O!P>R!P!Q$t!Q![?T![!^$t!^!_%_!_!`3O!`~$tV>WV&wPOY$tYZ%YZ!O$t!O!P>m!P!^$t!^!_%_!_~$tV>tT#UU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR?[]&wP%OQOY$tYZ%YZ!Q$t!Q![?T![!^$t!^!_%_!_!g$t!g!h@T!h#R$t#R#SBZ#S#X$t#X#Y@T#Y~$tR@YZ&wPOY$tYZ%YZ{$t{|@{|}$t}!O@{!O!Q$t!Q![Ag![!^$t!^!_%_!_~$tRAQV&wPOY$tYZ%YZ!Q$t!Q![Ag![!^$t!^!_%_!_~$tRAnX&wP%OQOY$tYZ%YZ!Q$t!Q![Ag![!^$t!^!_%_!_#R$t#R#S@{#S~$tRB`V&wPOY$tYZ%YZ!Q$t!Q![?T![!^$t!^!_%_!_~$tVB|Y&wP$VQOY$tYZ%YZz$tz{Cl{!P$t!P!Q+^!Q!^$t!^!_%_!_!`3O!`~$tVCqV&wPOYClYZDWZzClz{EZ{!^Cl!^!_Fc!_~ClVD]R&wPOzDfz{Dr{~DfUDiROzDfz{Dr{~DfUDuTOzDfz{Dr{!PDf!P!QEU!Q~DfUEZO!eUVE`X&wPOYClYZDWZzClz{EZ{!PCl!P!QE{!Q!^Cl!^!_Fc!_~ClVFST!eU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tVFfWOYClYZDWZzClz{EZ{!aCl!a!bDf!b~Cl~~%YZGVk&wP$}YOY$tYZ%YZ!O$t!O!P?T!P!Q$t!Q![Hz![!^$t!^!_%_!_!d$t!d!eJl!e!g$t!g!h@T!h!q$t!q!rLQ!r!z$t!z!{M`!{#R$t#R#SJQ#S#U$t#U#VJl#V#X$t#X#Y@T#Y#c$t#c#dLQ#d#l$t#l#mM`#m~$tZIR_&wP$}YOY$tYZ%YZ!O$t!O!P?T!P!Q$t!Q![Hz![!^$t!^!_%_!_!g$t!g!h@T!h#R$t#R#SJQ#S#X$t#X#Y@T#Y~$tZJVV&wPOY$tYZ%YZ!Q$t!Q![Hz![!^$t!^!_%_!_~$tZJqW&wPOY$tYZ%YZ!Q$t!Q!RKZ!R!SKZ!S!^$t!^!_%_!_~$tZKbY&wP$}YOY$tYZ%YZ!Q$t!Q!RKZ!R!SKZ!S!^$t!^!_%_!_#R$t#R#SJl#S~$tZLVV&wPOY$tYZ%YZ!Q$t!Q!YLl!Y!^$t!^!_%_!_~$tZLsX&wP$}YOY$tYZ%YZ!Q$t!Q!YLl!Y!^$t!^!_%_!_#R$t#R#SLQ#S~$tZMeZ&wPOY$tYZ%YZ!Q$t!Q![NW![!^$t!^!_%_!_!c$t!c!iNW!i#T$t#T#ZNW#Z~$tZN_]&wP$}YOY$tYZ%YZ!Q$t!Q![NW![!^$t!^!_%_!_!c$t!c!iNW!i#R$t#R#SM`#S#T$t#T#ZNW#Z~$tR! _V!qQ&wPOY$tYZ%YZ![$t![!]! t!]!^$t!^!_%_!_~$tR! {T#sQ&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV!!cT!mU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR!!wX$RQOY$tYZ%YZ!^$t!^!_!#d!_!`!#}!`!a)d!a!b!$k!b~$t~~%YR!#kU$SQ&wPOY$tYZ%YZ!^$t!^!_%_!_!`3O!`~$tR!$UV$RQ&wPOY$tYZ%YZ!^$t!^!_%_!_!`$t!`!a)d!a~$tP!$pR!iP!_!`!$y!r!s!%O#d#e!%OP!%OO!iPP!%RQ!j!k!%X#[#]!%XP!%[Q!r!s!$y#d#e!$yV!%iV#uQ&wPOY$tYZ%YZ!^$t!^!_%_!_!`(y!`!a!&O!a~$tV!&VT#OU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR!&mV$RQ&wPOY$tYZ%YZ!^$t!^!_%_!_!`!'S!`!a!#d!a~$tR!'ZT$RQ&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV!'qY!vQ&wPOY$tYZ%YZ}$t}!O!(a!O!^$t!^!_%_!_!`$t!`!a!)c!a!b!)y!b~$tV!(fV&wPOY$tYZ%YZ!^$t!^!_%_!_!`$t!`!a!({!a~$tV!)ST#aU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV!)jT!gU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR!*QU#zQ&wPOY$tYZ%YZ!^$t!^!_%_!_!`3O!`~$tR!*kT$]Q&wPOY$tYZ%YZ!^$t!^!_%_!_~$t_!+R_&wP!s^OY$tYZ%YZ!Q$t!Q![!*z![!^$t!^!_%_!_!c$t!c!}!*z!}#R$t#R#S!*z#S#T$t#T#o!*z#o$g$t$g&j!*z&j~$t_!,Xc&wP!s^OY$tYZ%YZr$trs!-dsw$twx4mx!Q$t!Q![!*z![!^$t!^!_%_!_!c$t!c!}!*z!}#R$t#R#S!*z#S#T$t#T#o!*z#o$g$t$g&j!*z&j~$tR!-kT&wP'gQOY$tYZ%YZ!^$t!^!_%_!_~$tV!.RT#WU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV!.iT#pU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR!/PT#XQ&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR!/gU$OQ&wPOY$tYZ%YZ!^$t!^!_%_!_!`3O!`~$tR!0OX&wPOY!/yYZ!0kZ!^!/y!^!_!1n!_#O!/y#O#P!2a#P#S!/y#S#T!2u#T~!/yR!0pT&wPO#O!1P#O#P!1c#P#S!1P#S#T!1i#T~!1PQ!1STO#O!1P#O#P!1c#P#S!1P#S#T!1i#T~!1PQ!1fPO~!1PQ!1nO${QR!1qYOY!/yYZ!0kZ!a!/y!a!b!1P!b#O!/y#O#P!2a#P#S!/y#S#T!2u#T~!/y~~%YR!2fT&wPOY!/yYZ!0kZ!^!/y!^!_!1n!_~!/yR!2|T${Q&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV!3dT!oU&wPOY$tYZ%YZ!^$t!^!_%_!_~$tV!3|W#}Q#lS&wPOY$tYZ%YZ!^$t!^!_%_!_!`3O!`#p$t#p#q!4f#q~$tR!4mT#{Q&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR!5TT!nQ&wPOY$tYZ%YZ!^$t!^!_%_!_~$tR!5kT$^Q&wPOY$tYZ%YZ!^$t!^!_%_!_~$t",
        tokenizers: [expression, interpolated, semicolon, 0, 1, 2, 3, eofToken],
        topRules: {
            "Template": [0, 72],
            "Program": [1, 232]
        },
        dynamicPrecedences: {
            "284": 1
        },
        specialized: [{
            term: 81,
            get: (value, stack) => keywords$1(value) << 1
        }, {
            term: 81,
            get: value => spec_Name[value] || -1
        }],
        tokenPrec: 29354
    });
    const scriptText = 54,
        StartCloseScriptTag = 1,
        styleText = 55,
        StartCloseStyleTag = 2,
        textareaText = 56,
        StartCloseTextareaTag = 3,
        StartTag$1 = 4,
        StartScriptTag = 5,
        StartStyleTag = 6,
        StartTextareaTag = 7,
        StartSelfClosingTag = 8,
        StartCloseTag$1 = 9,
        NoMatchStartCloseTag = 10,
        MismatchedStartCloseTag = 11,
        missingCloseTag = 57,
        IncompleteCloseTag = 12,
        commentContent$1$1 = 58,
        Element$4 = 18,
        TagName = 20,
        Attribute = 21,
        AttributeName = 22,
        AttributeValue = 24,
        UnquotedAttributeValue = 25,
        ScriptText = 27,
        StyleText = 30,
        TextareaText = 33,
        OpenTag$1 = 35,
        Dialect_noMatch = 0;
    const selfClosers = {
        area: true,
        base: true,
        br: true,
        col: true,
        command: true,
        embed: true,
        frame: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true,
        menuitem: true
    };
    const implicitlyClosed = {
        dd: true,
        li: true,
        optgroup: true,
        option: true,
        p: true,
        rp: true,
        rt: true,
        tbody: true,
        td: true,
        tfoot: true,
        th: true,
        tr: true
    };
    const closeOnOpen = {
        dd: {
            dd: true,
            dt: true
        },
        dt: {
            dd: true,
            dt: true
        },
        li: {
            li: true
        },
        option: {
            option: true,
            optgroup: true
        },
        optgroup: {
            optgroup: true
        },
        p: {
            address: true,
            article: true,
            aside: true,
            blockquote: true,
            dir: true,
            div: true,
            dl: true,
            fieldset: true,
            footer: true,
            form: true,
            h1: true,
            h2: true,
            h3: true,
            h4: true,
            h5: true,
            h6: true,
            header: true,
            hgroup: true,
            hr: true,
            menu: true,
            nav: true,
            ol: true,
            p: true,
            pre: true,
            section: true,
            table: true,
            ul: true
        },
        rp: {
            rp: true,
            rt: true
        },
        rt: {
            rp: true,
            rt: true
        },
        tbody: {
            tbody: true,
            tfoot: true
        },
        td: {
            td: true,
            th: true
        },
        tfoot: {
            tbody: true
        },
        th: {
            td: true,
            th: true
        },
        thead: {
            tbody: true,
            tfoot: true
        },
        tr: {
            tr: true
        }
    };
    function nameChar$1(ch) {
        return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
    }
    function isSpace$1(ch) {
        return ch == 9 || ch == 10 || ch == 13 || ch == 32;
    }
    let cachedName$1 = null,
        cachedInput$1 = null,
        cachedPos$1 = 0;
    function tagNameAfter$1(input, offset) {
        let pos = input.pos + offset;
        if (cachedPos$1 == pos && cachedInput$1 == input)
            return cachedName$1;
        let next = input.peek(offset);
        while (isSpace$1(next))
            next = input.peek(++offset);
        let name = "";
        for (;;) {
            if (!nameChar$1(next))
                break;
            name += String.fromCharCode(next);
            next = input.peek(++offset);
        }
        cachedInput$1 = input;
        cachedPos$1 = pos;
        return cachedName$1 = name ? name.toLowerCase() : next == question || next == bang ? undefined : null;
    }
    const lessThan = 60,
        greaterThan = 62,
        slash = 47,
        question = 63,
        bang = 33,
        dash$1 = 45;
    function ElementContext$1(name, parent) {
        this.name = name;
        this.parent = parent;
        this.hash = parent ? parent.hash : 0;
        for (let i = 0; i < name.length; i++)
            this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);
    }
    const startTagTerms = [StartTag$1, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];
    const elementContext$1 = new ContextTracker({
        start: null,
        shift(context, term, stack, input) {
            return startTagTerms.indexOf(term) > -1 ? new ElementContext$1(tagNameAfter$1(input, 1) || "", context) : context;
        },
        reduce(context, term) {
            return term == Element$4 && context ? context.parent : context;
        },
        reuse(context, node, stack, input) {
            let type = node.type.id;
            return type == StartTag$1 || type == OpenTag$1 ? new ElementContext$1(tagNameAfter$1(input, 1) || "", context) : context;
        },
        hash(context) {
            return context ? context.hash : 0;
        },
        strict: false
    });
    const tagStart = new ExternalTokenizer((input, stack) => {
        if (input.next != lessThan) {
            if (input.next < 0 && stack.context)
                input.acceptToken(missingCloseTag);
            return;
        }
        input.advance();
        let close = input.next == slash;
        if (close)
            input.advance();
        let name = tagNameAfter$1(input, 0);
        if (name === undefined)
            return;
        if (!name)
            return input.acceptToken(close ? IncompleteCloseTag : StartTag$1);
        let parent = stack.context ? stack.context.name : null;
        if (close) {
            if (name == parent)
                return input.acceptToken(StartCloseTag$1);
            if (parent && implicitlyClosed[parent])
                return input.acceptToken(missingCloseTag, -2);
            if (stack.dialectEnabled(Dialect_noMatch))
                return input.acceptToken(NoMatchStartCloseTag);
            for (let cx = stack.context; cx; cx = cx.parent)
                if (cx.name == name)
                    return;
            input.acceptToken(MismatchedStartCloseTag);
        } else {
            if (name == "script")
                return input.acceptToken(StartScriptTag);
            if (name == "style")
                return input.acceptToken(StartStyleTag);
            if (name == "textarea")
                return input.acceptToken(StartTextareaTag);
            if (selfClosers.hasOwnProperty(name))
                return input.acceptToken(StartSelfClosingTag);
            if (parent && closeOnOpen[parent] && closeOnOpen[parent][name])
                input.acceptToken(missingCloseTag, -1);
            else
                input.acceptToken(StartTag$1);
        }
    }, {
        contextual: true
    });
    const commentContent$2 = new ExternalTokenizer(input => {
        for (let dashes = 0, i = 0; ; i++) {
            if (input.next < 0) {
                if (i)
                    input.acceptToken(commentContent$1$1);
                break;
            }
            if (input.next == dash$1) {
                dashes++;
            } else if (input.next == greaterThan && dashes >= 2) {
                if (i > 3)
                    input.acceptToken(commentContent$1$1, -2);
                break;
            } else {
                dashes = 0;
            }
            input.advance();
        }
    });
    function contentTokenizer(tag, textToken, endToken) {
        let lastState = 2 + tag.length;
        return new ExternalTokenizer(input => {
            for (let state = 0, matchedLen = 0, i = 0; ; i++) {
                if (input.next < 0) {
                    if (i)
                        input.acceptToken(textToken);
                    break;
                }
                if (state == 0 && input.next == lessThan || state == 1 && input.next == slash || state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
                    state++;
                    matchedLen++;
                } else if ((state == 2 || state == lastState) && isSpace$1(input.next)) {
                    matchedLen++;
                } else if (state == lastState && input.next == greaterThan) {
                    if (i > matchedLen)
                        input.acceptToken(textToken, -matchedLen);
                    else
                        input.acceptToken(endToken, -(matchedLen - 2));
                    break;
                } else if ((input.next == 10 || input.next == 13) && i) {
                    input.acceptToken(textToken, 1);
                    break;
                } else {
                    state = matchedLen = 0;
                }
                input.advance();
            }
        });
    }
    const scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);
    const styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);
    const textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);
    const htmlHighlighting = styleTags({
        "Text RawText": tags$1.content,
        "StartTag StartCloseTag SelfClosingEndTag EndTag": tags$1.angleBracket,
        TagName: tags$1.tagName,
        "MismatchedCloseTag/TagName": [tags$1.tagName, tags$1.invalid],
        AttributeName: tags$1.attributeName,
        "AttributeValue UnquotedAttributeValue": tags$1.attributeValue,
        Is: tags$1.definitionOperator,
        "EntityReference CharacterReference": tags$1.character,
        Comment: tags$1.blockComment,
        ProcessingInst: tags$1.processingInstruction,
        DoctypeDecl: tags$1.documentMeta
    });
    const parser$8 = LRParser.deserialize({
        version: 14,
        states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DTO$tQ!bO'#DVO$yQ!bO'#DWOOOW'#Dk'#DkOOOW'#DY'#DYQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%sQ#tO,59mOOOX'#D^'#D^O%{OXO'#CwO&WOXO,59YOOOY'#D_'#D_O&`OYO'#CzO&kOYO,59YOOO['#D`'#D`O&sO[O'#C}O'OO[O,59YOOOW'#Da'#DaO'WOxO,59YO'_Q!bO'#DQOOOW,59Y,59YOOO`'#Db'#DbO'dO!rO,59oOOOW,59o,59oO'lQ!bO,59qO'qQ!bO,59rOOOW-E7W-E7WO'vQ#tO'#CqOOQO'#DZ'#DZO(UQ#tO1G.uOOOX1G.u1G.uO(^Q#tO1G/POOOY1G/P1G/PO(fQ#tO1G/SOOO[1G/S1G/SO(nQ#tO1G/VOOOW1G/V1G/VOOOW1G/X1G/XO(yQ#tO1G/XOOOX-E7[-E7[O)RQ!bO'#CxOOOW1G.t1G.tOOOY-E7]-E7]O)WQ!bO'#C{OOO[-E7^-E7^O)]Q!bO'#DOOOOW-E7_-E7_O)bQ!bO,59lOOO`-E7`-E7`OOOW1G/Z1G/ZOOOW1G/]1G/]OOOW1G/^1G/^O)gQ&jO,59]OOQO-E7X-E7XOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)rQ!bO,59dO)wQ!bO,59gO)|Q!bO,59jOOOW1G/W1G/WO*RO,UO'#CtO*dO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#D['#D[O*uO,UO,59`OOQO,59`,59`OOOO'#D]'#D]O+WO7[O,59`OOOO-E7Y-E7YOOQO1G.z1G.zOOOO-E7Z-E7Z",
        stateData: "+u~O!^OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ox^O{_O!dZO~OdaO~OdbO~OdcO~OddO~OdeO~O!WfOPkP!ZkP~O!XiOQnP!ZnP~O!YlORqP!ZqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SOv!TO~OfyOj!TO~O!WfOPkX!ZkX~OP!WO!Z!XO~O!XiOQnX!ZnX~OQ!ZO!Z!XO~O!YlORqX!ZqX~OR!]O!Z!XO~O!Z!XO~P#dOd!_O~O![sO!e!aO~Oj!bO~Oj!cO~Og!dOfeXjeXveX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iOv!jO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!`!oO!b!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uOa!uO!`!wO!a!uO~O_!xO`!xOa!xO!b!wO!c!xO~O_!uO`!uOa!uO!`!{O!a!uO~O_!xO`!xOa!xO!b!{O!c!xO~Ov~vj`!dx{_a_~",
        goto: "%p!`PPPPPPPPPPPPPPPPPP!a!gP!mPP!yPP!|#P#S#Y#]#`#f#i#l#r#xP!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
        nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag SelfClosingEndTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
        maxTerm: 67,
        context: elementContext$1,
        nodeProps: [["closedBy", -10, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, "EndTag", 4, "EndTag SelfClosingEndTag", -4, 19, 29, 32, 35, "CloseTag"], ["group", -9, 12, 15, 16, 17, 18, 39, 40, 41, 42, "Entity", 14, "Entity TextContent", -3, 27, 30, 33, "TextContent Entity"], ["openedBy", 26, "StartTag StartCloseTag", -4, 28, 31, 34, 36, "OpenTag", 38, "StartTag"]],
        propSources: [htmlHighlighting],
        skippedNodes: [0],
        repeatNodeCount: 9,
        tokenData: "#,c!aR!ZOX$tXY)sYZ)sZ[$t[]&U]^)s^p$tpq)sqr*zrs5wsv*zvw6awxM^x}*z}!OMy!O!P*z!P!Q!$x!Q![*z![!]!'P!]!^*z!^!_!,l!_!`#+P!`!a#+q!a!c*z!c!}!'P!}#R*z#R#S!'P#S#T2Q#T#o!'P#o#s*z#s$f$t$f%W*z%W%o!'P%o%p*z%p&a!'P&a&b*z&b1p!'P1p4U*z4U4d!'P4d4e*z4e$IS!'P$IS$I`*z$I`$Ib!'P$Ib$Kh*z$Kh%#t!'P%#t&/x*z&/x&Et!'P&Et&FV*z&FV;'S!'P;'S;:j!+U;:j;=`4a;=`<%l$t<%l?&r*z?&r?Ah!'P?Ah?BY$t?BY?Mn!'P?Mn~$t!Z%Pa^PiW!a`!cpOX$tXZ&UZ[$t[^&U^p$tpq&Uqr$trs&tsv$tvw)Uwx'ux!^$t!^!_(n!_!a&U!a#S$t#S#T&U#T~$t!R&_V^P!a`!cpOr&Urs&tsv&Uwx'ux!^&U!^!_(n!_~&Uq&{T^P!cpOv&twx'[x!^&t!^!_'j!_~&tP'aR^POv'[w!^'[!_~'[p'oQ!cpOv'jx~'ja'|U^P!a`Or'urs'[sv'uw!^'u!^!_(`!_~'u`(eR!a`Or(`sv(`w~(`!Q(uT!a`!cpOr(nrs'jsv(nwx(`x~(nW)ZWiWOX)UZ[)U^p)Uqr)Usw)Ux!^)U!a#S)U#T~)U!a*O^^P!a`!cp!^^OX&UXY)sYZ)sZ]&U]^)s^p&Upq)sqr&Urs&tsv&Uwx'ux!^&U!^!_(n!_~&U!_+XkfS^PiW!a`!cpOX$tXZ&UZ[$t[^&U^p$tpq&Uqr*zrs&tsv*zvw,|wx'ux!P*z!P!Q$t!Q!^*z!^!_0O!_!a&U!a#S*z#S#T2Q#T#s*z#s$f$t$f;'S*z;'S;=`4a;=`<%l$t<%l?Ah*z?Ah?BY$t?BY?Mn*z?Mn~$t[-TdfSiWOX)UZ[)U^p)Uqr,|sw,|x!P,|!P!Q)U!Q!^,|!^!_.c!a#S,|#S#T.c#T#s,|#s$f)U$f;'S,|;'S;=`/Z;=`<%l)U<%l?Ah,|?Ah?BY)U?BY?Mn,|?Mn~)US.hXfSqr.csw.cx!P.c!Q!_.c!a#s.c$f;'S.c;'S;=`/T<%l?Ah.c?BY?Mn.cS/WP;=`<%l.c[/`YiWOX)UZ[)U^p)Uqr)Usw)Ux!^)U!a#S)U#T;=`)U;=`<%l,|<%l~)U!U0XcfS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!U1kV!a`!cpOr(nrs'jsv(nwx(`x;=`(n;=`<%l0O<%l~(n!V2]dfS^P!a`!cpOq&Uqr2Qrs&tsv2Qvw.cwx'ux!P2Q!P!Q&U!Q!^2Q!^!_0O!_!a&U!a#s2Q#s$f&U$f;'S2Q;'S;=`3k;=`<%l&U<%l?Ah2Q?Ah?BY&U?BY?Mn2Q?Mn~&U!V3tX^P!a`!cpOr&Urs&tsv&Uwx'ux!^&U!^!_(n!_;=`&U;=`<%l2Q<%l~&U!_4lc^PiW!a`!cpOX$tXZ&UZ[$t[^&U^p$tpq&Uqr$trs&tsv$tvw)Uwx'ux!^$t!^!_(n!_!a&U!a#S$t#S#T&U#T;=`$t;=`<%l*z<%l~$t!Z6QT!`h^P!cpOv&twx'[x!^&t!^!_'j!_~&t!_6jkfSiWa!ROX8_XZ9fZ[8_[^9f^p8_qr:nrs9fstBStw:nwx9fx!P:n!P!Q8_!Q!]:n!]!^,|!^!_>R!_!a9f!a#S:n#S#T>R#T#s:n#s$f8_$f;'S:n;'S;=`@u;=`<%l8_<%l?Ah:n?Ah?BY8_?BY?Mn:n?Mn~8_!Z8d`iWOX8_XZ9fZ[8_[^9f^p8_qr8_rs9fst)Utw8_wx9fx!]8_!]!^9}!^!a9f!a#S8_#S#T9f#T~8_!R9iTOp9fqs9ft!]9f!]!^9x!^~9f!R9}O_!R!Z:UWiW_!ROX)UZ[)U^p)Uqr)Usw)Ux!^)U!a#S)U#T~)U!_:ukfSiWOX8_XZ9fZ[8_[^9f^p8_qr:nrs9fst,|tw:nwx9fx!P:n!P!Q8_!Q!]:n!]!^<j!^!_>R!_!a9f!a#S:n#S#T>R#T#s:n#s$f8_$f;'S:n;'S;=`@u;=`<%l8_<%l?Ah:n?Ah?BY8_?BY?Mn:n?Mn~8_!_<sdfSiW_!ROX)UZ[)U^p)Uqr,|sw,|x!P,|!P!Q)U!Q!^,|!^!_.c!a#S,|#S#T.c#T#s,|#s$f)U$f;'S,|;'S;=`/Z;=`<%l)U<%l?Ah,|?Ah?BY)U?BY?Mn,|?Mn~)U!V>WefSOp9fqr>Rrs9fst.ctw>Rwx9fx!P>R!P!Q9f!Q!]>R!]!^?i!^!_>R!_!a9f!a#s>R#s$f9f$f;'S>R;'S;=`@];=`<%l9f<%l?Ah>R?Ah?BY9f?BY?Mn>R?Mn~9f!V?pXfS_!Rqr.csw.cx!P.c!Q!_.c!a#s.c$f;'S.c;'S;=`/T<%l?Ah.c?BY?Mn.c!V@`VOp9fqs9ft!]9f!]!^9x!^;=`9f;=`<%l>R<%l~9f!_@zbiWOX8_XZ9fZ[8_[^9f^p8_qr8_rs9fst)Utw8_wx9fx!]8_!]!^9}!^!a9f!a#S8_#S#T9f#T;=`8_;=`<%l:n<%l~8_!_BZjfSiWOXC{XZEPZ[C{[^EP^pC{qrFUrsEPswFUwxEPx!PFU!P!QC{!Q!]FU!]!^,|!^!_If!_!aEP!a#SFU#S#TIf#T#sFU#s$fC{$f;'SFU;'S;=`LS;=`<%lC{<%l?AhFU?Ah?BYC{?BY?MnFU?Mn~C{!ZDQ_iWOXC{XZEPZ[C{[^EP^pC{qrC{rsEPswC{wxEPx!]C{!]!^Ee!^!aEP!a#SC{#S#TEP#T~C{!RESSOpEPq!]EP!]!^E`!^~EP!REeO`!R!ZElWiW`!ROX)UZ[)U^p)Uqr)Usw)Ux!^)U!a#S)U#T~)U!_F]jfSiWOXC{XZEPZ[C{[^EP^pC{qrFUrsEPswFUwxEPx!PFU!P!QC{!Q!]FU!]!^G}!^!_If!_!aEP!a#SFU#S#TIf#T#sFU#s$fC{$f;'SFU;'S;=`LS;=`<%lC{<%l?AhFU?Ah?BYC{?BY?MnFU?Mn~C{!_HWdfSiW`!ROX)UZ[)U^p)Uqr,|sw,|x!P,|!P!Q)U!Q!^,|!^!_.c!a#S,|#S#T.c#T#s,|#s$f)U$f;'S,|;'S;=`/Z;=`<%l)U<%l?Ah,|?Ah?BY)U?BY?Mn,|?Mn~)U!VIkdfSOpEPqrIfrsEPswIfwxEPx!PIf!P!QEP!Q!]If!]!^Jy!^!_If!_!aEP!a#sIf#s$fEP$f;'SIf;'S;=`Km;=`<%lEP<%l?AhIf?Ah?BYEP?BY?MnIf?Mn~EP!VKQXfS`!Rqr.csw.cx!P.c!Q!_.c!a#s.c$f;'S.c;'S;=`/T<%l?Ah.c?BY?Mn.c!VKpUOpEPq!]EP!]!^E`!^;=`EP;=`<%lIf<%l~EP!_LXaiWOXC{XZEPZ[C{[^EP^pC{qrC{rsEPswC{wxEPx!]C{!]!^Ee!^!aEP!a#SC{#S#TEP#T;=`C{;=`<%lFU<%l~C{!ZMgU!bx^P!a`Or'urs'[sv'uw!^'u!^!_(`!_~'u!aNWmfS^PiW!a`!cpOX$tXZ&UZ[$t[^&U^p$tpq&Uqr*zrs&tsv*zvw,|wx'ux}*z}!O!!R!O!P*z!P!Q$t!Q!^*z!^!_0O!_!a&U!a#S*z#S#T2Q#T#s*z#s$f$t$f;'S*z;'S;=`4a;=`<%l$t<%l?Ah*z?Ah?BY$t?BY?Mn*z?Mn~$t!a!!`lfS^PiW!a`!cpOX$tXZ&UZ[$t[^&U^p$tpq&Uqr*zrs&tsv*zvw,|wx'ux!P*z!P!Q$t!Q!^*z!^!_0O!_!`&U!`!a!$W!a#S*z#S#T2Q#T#s*z#s$f$t$f;'S*z;'S;=`4a;=`<%l$t<%l?Ah*z?Ah?BY$t?BY?Mn*z?Mn~$t!T!$cV^P!a`!cp!eQOr&Urs&tsv&Uwx'ux!^&U!^!_(n!_~&U!a!%Tb^PiW!a`!cpOX$tXZ&UZ[$t[^&U^p$tpq&Uqr$trs&tsv$tvw)Uwx'ux!^$t!^!_(n!_!`&U!`!a!&]!a#S$t#S#T&U#T~$t!X!&jV^P!a`!cpvSjUOr&Urs&tsv&Uwx'ux!^&U!^!_(n!_~&U!a!'`![fSdQ^PiW!a`!cpOX$tXZ&UZ[$t[^&U^p$tpq&Uqr*zrs&tsv*zvw,|wx'ux}*z}!O!'P!O!P!'P!P!Q$t!Q![!'P![!]!'P!]!^*z!^!_0O!_!a&U!a!c*z!c!}!'P!}#R*z#R#S!'P#S#T2Q#T#o!'P#o#s*z#s$f$t$f$}*z$}%O!'P%O%W*z%W%o!'P%o%p*z%p&a!'P&a&b*z&b1p!'P1p4U!'P4U4d!'P4d4e*z4e$IS!'P$IS$I`*z$I`$Ib!'P$Ib$Je*z$Je$Jg!'P$Jg$Kh*z$Kh%#t!'P%#t&/x*z&/x&Et!'P&Et&FV*z&FV;'S!'P;'S;:j!+U;:j;=`4a;=`<%l$t<%l?&r*z?&r?Ah!'P?Ah?BY$t?BY?Mn!'P?Mn~$t!a!+ac^PiW!a`!cpOX$tXZ&UZ[$t[^&U^p$tpq&Uqr$trs&tsv$tvw)Uwx'ux!^$t!^!_(n!_!a&U!a#S$t#S#T&U#T;=`$t;=`<%l!'P<%l~$t!V!,udfS!a`!cpOq(nqr!.Trs'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a!b!MO!b#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!.^ifS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x}0O}!O!/{!O!P0O!P!Q(n!Q!_0O!_!a(n!a!f0O!f!g!2}!g#W0O#W#X!Cl#X#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!0UefS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x}0O}!O!1g!O!P0O!P!Q(n!Q!_0O!_!a(n!a#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!1rcfS!a`!cp!dPOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!3WefS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a!q0O!q!r!4i!r#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!4refS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a!e0O!e!f!6T!f#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!6^efS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a!v0O!v!w!7o!w#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!7xefS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a!{0O!{!|!9Z!|#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!9defS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a!r0O!r!s!:u!s#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!;OefS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a!g0O!g!h!<a!h#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!<jdfS!a`!cpOq!=xqr!<ars!>isv!<avw!ARwx!?mx!P!<a!P!Q!=x!Q!_!<a!_!`!=x!`!a!@i!a#s!<a#s$f!=x$f;'S!<a;'S;=`!Bu;=`<%l!=x<%l?Ah!<a?Ah?BY!=x?BY?Mn!<a?Mn~!=x!R!>PW!a`!cpOr!=xrs!>isv!=xvw!>}wx!?mx!`!=x!`!a!@i!a~!=xq!>nT!cpOv!>ivx!>}x!`!>i!`!a!?`!a~!>iP!?QRO!`!>}!`!a!?Z!a~!>}P!?`O{Pq!?gQ!cp{POv'jx~'ja!?rV!a`Or!?mrs!>}sv!?mvw!>}w!`!?m!`!a!@X!a~!?ma!@`R!a`{POr(`sv(`w~(`!R!@rT!a`!cp{POr(nrs'jsv(nwx(`x~(nT!AWcfSOq!>}qr!ARrs!>}sw!ARwx!>}x!P!AR!P!Q!>}!Q!_!AR!_!`!>}!`!a!?Z!a#s!AR#s$f!>}$f;'S!AR;'S;=`!Bc;=`<%l!>}<%l?Ah!AR?Ah?BY!>}?BY?Mn!AR?Mn~!>}T!BfTO!`!>}!`!a!?Z!a;=`!>};=`<%l!AR<%l~!>}!V!B|Y!a`!cpOr!=xrs!>isv!=xvw!>}wx!?mx!`!=x!`!a!@i!a;=`!=x;=`<%l!<a<%l~!=x!V!CuefS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a#c0O#c#d!EW#d#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!EaefS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a#V0O#V#W!Fr#W#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!F{efS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a#h0O#h#i!H^#i#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!HgefS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a#m0O#m#n!Ix#n#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!JRefS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a#d0O#d#e!Kd#e#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!KmefS!a`!cpOq(nqr0Ors'jsv0Ovw.cwx(`x!P0O!P!Q(n!Q!_0O!_!a(n!a#X0O#X#Y!<a#Y#s0O#s$f(n$f;'S0O;'S;=`1d;=`<%l(n<%l?Ah0O?Ah?BY(n?BY?Mn0O?Mn~(n!V!MXdfS!a`!cpOq!Ngqr!MOrs# Wsv!MOvw#%mwx#!|x!P!MO!P!Q!Ng!Q!_!MO!_!a!Ng!a!b#(q!b#s!MO#s$f!Ng$f;'S!MO;'S;=`#*Y;=`<%l!Ng<%l?Ah!MO?Ah?BY!Ng?BY?Mn!MO?Mn~!Ng!R!NnW!a`!cpOr!Ngrs# Wsv!Ngvw# lwx#!|x!a!Ng!a!b#$d!b~!Ngq# ]T!cpOv# Wvx# lx!a# W!a!b#!Z!b~# WP# oRO!a# l!a!b# x!b~# lP# {RO!`# l!`!a#!U!a~# lP#!ZOxPq#!`T!cpOv# Wvx# lx!`# W!`!a#!o!a~# Wq#!vQ!cpxPOv'jx~'ja##RV!a`Or#!|rs# lsv#!|vw# lw!a#!|!a!b##h!b~#!|a##mV!a`Or#!|rs# lsv#!|vw# lw!`#!|!`!a#$S!a~#!|a#$ZR!a`xPOr(`sv(`w~(`!R#$kW!a`!cpOr!Ngrs# Wsv!Ngvw# lwx#!|x!`!Ng!`!a#%T!a~!Ng!R#%^T!a`!cpxPOr(nrs'jsv(nwx(`x~(nT#%rcfSOq# lqr#%mrs# lsw#%mwx# lx!P#%m!P!Q# l!Q!_#%m!_!a# l!a!b#&}!b#s#%m#s$f# l$f;'S#%m;'S;=`#(_;=`<%l# l<%l?Ah#%m?Ah?BY# l?BY?Mn#%m?Mn~# lT#'ScfSOq# lqr#%mrs# lsw#%mwx# lx!P#%m!P!Q# l!Q!_#%m!_!`# l!`!a#!U!a#s#%m#s$f# l$f;'S#%m;'S;=`#(_;=`<%l# l<%l?Ah#%m?Ah?BY# l?BY?Mn#%m?Mn~# lT#(bTO!a# l!a!b# x!b;=`# l;=`<%l#%m<%l~# l!V#(zdfS!a`!cpOq!Ngqr!MOrs# Wsv!MOvw#%mwx#!|x!P!MO!P!Q!Ng!Q!_!MO!_!`!Ng!`!a#%T!a#s!MO#s$f!Ng$f;'S!MO;'S;=`#*Y;=`<%l!Ng<%l?Ah!MO?Ah?BY!Ng?BY?Mn!MO?Mn~!Ng!V#*aY!a`!cpOr!Ngrs# Wsv!Ngvw# lwx#!|x!a!Ng!a!b#$d!b;=`!Ng;=`<%l!MO<%l~!Ng!V#+[VgS^P!a`!cpOr&Urs&tsv&Uwx'ux!^&U!^!_(n!_~&U!X#+|V^P!a`!cpjUOr&Urs&tsv&Uwx'ux!^&U!^!_(n!_~&U",
        tokenizers: [scriptTokens, styleTokens, textareaTokens, tagStart, commentContent$2, 0, 1, 2, 3, 4, 5],
        topRules: {
            "Document": [0, 13]
        },
        dialects: {
            noMatch: 0,
            selfClosing: 485
        },
        tokenPrec: 487
    });
    function getAttrs(element, input) {
        let attrs = Object.create(null);
        for (let _i248 = 0, _element$firstChild$g = element.firstChild.getChildren(Attribute), _length248 = _element$firstChild$g.length; _i248 < _length248; _i248++) {
            let att = _element$firstChild$g[_i248];
            let name = att.getChild(AttributeName),
                value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);
            if (name)
                attrs[input.read(name.from, name.to)] = !value ? "" : value.type.id == AttributeValue ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
        }
        return attrs;
    }
    function maybeNest(node, input, tags) {
        let attrs;
        for (let _i249 = 0, _length249 = tags.length; _i249 < _length249; _i249++) {
            let tag = tags[_i249];
            if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent, input))))
                return {
                    parser: tag.parser
                };
        }
        return null;
    }
    function configureNesting(tags=[], attributes=[]) {
        let script = [],
            style = [],
            textarea = [];
        for (let _i250 = 0, _length250 = tags.length; _i250 < _length250; _i250++) {
            let tag = tags[_i250];
            let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : null;
            if (!array)
                throw new RangeError("Only script, style, and textarea tags can host nested parsers");
            array.push(tag);
        }
        let attrs = attributes.length ? Object.create(null) : null;
        for (let _i251 = 0, _length251 = attributes.length; _i251 < _length251; _i251++) {
            let attr = attributes[_i251];
            (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);
        }
        return parseMixed((node, input) => {
            let id = node.type.id;
            if (id == ScriptText)
                return maybeNest(node, input, script);
            if (id == StyleText)
                return maybeNest(node, input, style);
            if (id == TextareaText)
                return maybeNest(node, input, textarea);
            if (attrs && id == Attribute) {
                let n = node.node,
                    nameNode;
                if (nameNode = n.firstChild) {
                    let matches = attrs[input.read(nameNode.from, nameNode.to)];
                    if (matches)
                        for (let _i252 = 0, _length252 = matches.length; _i252 < _length252; _i252++) {
                            let attr = matches[_i252];
                            if (attr.tagName) {
                                if (!tagName) {
                                    let tagNameNode = n.parent.getChild(TagName);
                                    tagName = tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : " ";
                                }
                                if (attrTagName != tagName)
                                    continue;
                            }
                            let value = n.lastChild;
                            if (value.type.id == AttributeValue)
                                return {
                                    parser: attr.parser,
                                    overlay: [{
                                        from: value.from + 1,
                                        to: value.to - 1
                                    }]
                                };
                            else if (value.type.id == UnquotedAttributeValue)
                                return {
                                    parser: attr.parser,
                                    overlay: [{
                                        from: value.from,
                                        to: value.to
                                    }]
                                };
                        }
                }
            }
            return null;
        });
    }
    const descendantOp = 95,
        Unit = 1,
        callee = 96,
        identifier$2 = 97,
        VariableName = 2;
    const space$2 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];
    const colon = 58,
        parenL = 40,
        underscore = 95,
        bracketL = 91,
        dash = 45,
        period = 46,
        hash$1 = 35,
        percent = 37;
    function isAlpha$1(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161;
    }
    function isDigit(ch) {
        return ch >= 48 && ch <= 57;
    }
    const identifiers = new ExternalTokenizer((input, stack) => {
        for (let inside = false, dashes = 0, i = 0; ; i++) {
            let {next} = input;
            if (isAlpha$1(next) || next == dash || next == underscore || inside && isDigit(next)) {
                if (!inside && (next != dash || i > 0))
                    inside = true;
                if (dashes === i && next == dash)
                    dashes++;
                input.advance();
            } else {
                if (inside)
                    input.acceptToken(next == parenL ? callee : dashes == 2 && stack.canShift(VariableName) ? VariableName : identifier$2);
                break;
            }
        }
    });
    const descendant = new ExternalTokenizer(input => {
        if (space$2.includes(input.peek(-1))) {
            let {next} = input;
            if (isAlpha$1(next) || next == underscore || next == hash$1 || next == period || next == bracketL || next == colon || next == dash)
                input.acceptToken(descendantOp);
        }
    });
    const unitToken = new ExternalTokenizer(input => {
        if (!space$2.includes(input.peek(-1))) {
            let {next} = input;
            if (next == percent) {
                input.advance();
                input.acceptToken(Unit);
            }
            if (isAlpha$1(next)) {
                do {
                    input.advance();
                } while (isAlpha$1(input.next));
                input.acceptToken(Unit);
            }
        }
    });
    const cssHighlighting = styleTags({
        "AtKeyword import charset namespace keyframes media supports": tags$1.definitionKeyword,
        "from to selector": tags$1.keyword,
        NamespaceName: tags$1.namespace,
        KeyframeName: tags$1.labelName,
        TagName: tags$1.tagName,
        ClassName: tags$1.className,
        PseudoClassName: tags$1.constant(tags$1.className),
        IdName: tags$1.labelName,
        "FeatureName PropertyName": tags$1.propertyName,
        AttributeName: tags$1.attributeName,
        NumberLiteral: tags$1.number,
        KeywordQuery: tags$1.keyword,
        UnaryQueryOp: tags$1.operatorKeyword,
        "CallTag ValueName": tags$1.atom,
        VariableName: tags$1.variableName,
        Callee: tags$1.operatorKeyword,
        Unit: tags$1.unit,
        "UniversalSelector NestingSelector": tags$1.definitionOperator,
        MatchOp: tags$1.compareOperator,
        "ChildOp SiblingOp, LogicOp": tags$1.logicOperator,
        BinOp: tags$1.arithmeticOperator,
        Important: tags$1.modifier,
        Comment: tags$1.blockComment,
        ParenthesizedContent: tags$1.special(tags$1.name),
        ColorLiteral: tags$1.color,
        StringLiteral: tags$1.string,
        ":": tags$1.punctuation,
        "PseudoOp #": tags$1.derefOperator,
        "; ,": tags$1.separator,
        "( )": tags$1.paren,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace
    });
    const spec_callee = {
        __proto__: null,
        lang: 32,
        "nth-child": 32,
        "nth-last-child": 32,
        "nth-of-type": 32,
        "nth-last-of-type": 32,
        dir: 32,
        "host-context": 32,
        url: 60,
        "url-prefix": 60,
        domain: 60,
        regexp: 60,
        selector: 134
    };
    const spec_AtKeyword = {
        __proto__: null,
        "@import": 114,
        "@media": 138,
        "@charset": 142,
        "@namespace": 146,
        "@keyframes": 152,
        "@supports": 164
    };
    const spec_identifier$2 = {
        __proto__: null,
        not: 128,
        only: 128,
        from: 158,
        to: 160
    };
    const parser$7 = LRParser.deserialize({
        version: 14,
        states: "8SQYQ[OOO!ZQ[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO!cQ[O'#CfO#VQXO'#CaO#^Q[O'#ChO#iQ[O'#DPO#nQ[O'#DTOOQP'#Ee'#EeO#sQdO'#DeO$_Q[O'#DrO#sQdO'#DtO$pQ[O'#DvO${Q[O'#DyO%QQ[O'#EPO%`Q[O'#EROOQS'#Ed'#EdOOQS'#ET'#ETQYQ[OOOOQO'#Db'#DbO%gQWO'#DaQ%lQWOOOOQP'#Cg'#CgOOQP,59Q,59QO!cQ[O,59QO%qQ[O'#EWO&]QWO,58{O&eQ[O,59SO#iQ[O,59kO#nQ[O,59oO%qQ[O,59sO%qQ[O,59uO%qQ[O,59vO'tQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO'{QWO,59SO(QQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO(VQ`O,59oOOQS'#Cp'#CpO#sQdO'#CqO(_QvO'#CsO)lQtO,5:POOQO'#Cx'#CxO(QQWO'#CwO*QQWO'#CyOOQS'#Eh'#EhOOQO'#Dh'#DhO*VQ[O'#DoO*eQWO'#EkO%QQ[O'#DmO*sQWO'#DpOOQO'#El'#ElO&`QWO,5:^O*xQpO,5:`OOQS'#Dx'#DxO+QQWO,5:bO+VQ[O,5:bOOQO'#D{'#D{O+_QWO,5:eO+dQWO,5:kO+lQWO,5:mOOQS-E8R-E8RO#sQdO,59{O+tQ[O'#E]Q%lQWOOOOQP1G.l1G.lO,nQXO,5:rOOQO-E8U-E8UOOQS1G.g1G.gOOQP1G.n1G.nO'{QWO1G.nO(QQWO1G.nOOQP1G/V1G/VO,{Q`O1G/ZO-fQXO1G/_O-|QXO1G/aO.dQXO1G/bO.zQXO'#CdOOQS,59z,59zO/oQWO,59zO/wQ[O,59zO0OQ[O'#DOO0VQdO'#CoOOQP1G/Z1G/ZO#sQdO1G/ZO0^QpO,59]OOQS,59_,59_O#sQdO,59aO0fQWO1G/kOOQS,59c,59cO0kQ!bO,59eO0sQWO'#DhO1OQWO,5:TO1TQWO,5:ZO%QQ[O,5:VO%QQ[O'#EZO1]QWO,5;VO1hQWO,5:XO%qQ[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O1yQWO1G/|O2OQdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO2^QtO1G/gOOQO,5:w,5:wOOQO-E8Z-E8ZOOQP7+$Y7+$YOOQP7+$u7+$uO#sQdO7+$uO2tQ[O'#EYO3OQWO1G/fOOQS1G/f1G/fO3OQWO1G/fO3WQXO'#EjO3_QWO,59jO3dQtO'#EUO4XQdO'#EgO4cQWO,59ZO4hQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO4pQWO1G/PO#sQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO4uQWO,5:uOOQO-E8X-E8XO5TQXO1G/vOOQS7+%h7+%hO5[QYO'#CsO&`QWO'#E[O5dQdO,5:hOOQS,5:h,5:hO5rQtO'#EXO#sQdO'#EXO6pQdO7+%ROOQO7+%R7+%RO7TQpO<<HaOOQO,5:t,5:tO7]Q[O,5:tOOQO-E8W-E8WOOQS7+%Q7+%QO7gQWO7+%QO7oQWO,5;UOOQP1G/U1G/UOOQS-E8S-E8SO#sQdO'#EVO7wQWO,5;ROOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO8PQdO7+%ZOOQO7+%b7+%bOOQS,5:v,5:vOOQS-E8Y-E8YOOQS1G0S1G0SO8WQtO,5:sOOQS-E8V-E8VOOQO<<Hm<<HmOOQPAN={AN={OOQO1G0`1G0`OOQS<<Hl<<HlO9UQdO,5:qOOQO-E8T-E8TOOQO<<Hu<<Hu",
        stateData: "9f~O#VOSROS~OUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#TQO#YSO~OQeO#TdO~O#TgO~O]lO^lOpjOtmOxnO|oO!PqO#RpO#YiO~O!RrO~P!hO`xO#SuO#TtO~O#TyO~O#T{O~OQ!UOb!OOf!UOh!UOn!TO#S!RO#T}O#]!PO~Ob!WO!b!YO!e!ZO#T!VO!R#_P~Oh!`On!TO#T!_O~O#T!bO~Ob!WO!b!YO!e!ZO#T!VO~O!W#_P~P$_O]!gO~O!W!hO~OUXOXXO]UO^UOtVOxWO#TQO#YSO~OpjO!RrO~O`!pO#SuO#TtO~OQeOUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#T!vO#YSO~O!Q!wO~P&pOb!zO~Ob!{O~Ov!|Oz!}O~OP#PObgXjgX!WgX!bgX!egX#TgXagXQgXfgXhgXngXpgX!VgX#QgX#SgX#]gXvgX!QgX~Ob!WOj#QO!b!YO!e!ZO#T!VO!W#_P~Ob#TO~Ob!WO!b!YO!e!ZO#T#UO~Op#YO!`#XO!R#_X!W#_X~Ob#]O~Oj#QO!W#_O~O!W#`O~Oh#aOn!TO~O!R#bO~O!RrO!`#XO~O!RrO!W#eO~OQeO#TdO!W#PX#Q#PX~O]lO^lOtmOxnO|oO!PqO#RpO#YiO~Op!za!R!zaa!za~P,SOv#jOz#kO~O]lO^lOtmOxnO#YiO~Op{i|{i!P{i!R{i#R{ia{i~P-TOp}i|}i!P}i!R}i#R}ia}i~P-TOp!Oi|!Oi!P!Oi!R!Oi#R!Oia!Oi~P-TO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#RWX#YWX~O!Q#nO!W#lO~O!Q#nO~P&pOa#^P~P%qOa#ZP~P#sOa#vOj#QO~O!W#xO~Oh#yOo#yO~O]!^Xa![X!`![X~O]#zO~Oa#{O!`#XO~Op#YO!R#_a!W#_a~O!`#XOp!aa!R!aa!W!aaa!aa~O!W$QO~O!Q$UO!q$SO!r$SO#]$RO~Oj#QOp$WO!V$YO!W!Ti#Q!Ti!Q!Ti~P#sO!Q!|X!W!|X~P&pO!Q$_O!W#lO~Oa#^X~P!hOa$bO~Oj#QOQ!xXa!xXb!xXf!xXh!xXn!xXp!xX#S!xX#T!xX#]!xX~Op$dOa#ZX~P#sOa$fO~Oj#QOv$gO~Oa$hO~O!`#XOp!}a!R!}a!W!}a~Oa$jO~P,SOP#PO!RgX~O!Q$mO!q$SO!r$SO#]$RO~Oj#QOQ!{Xb!{Xf!{Xh!{Xn!{Xp!{X!V!{X!W!{X#Q!{X#S!{X#T!{X#]!{X!Q!{X~Op$WO!V$pO!W!Tq#Q!Tq!Q!Tq~P#sOj#QOv$qO~O!Q!|a!W!|a~P&pO!Q$sO!W#lO~OpjOa#^a~Op$dOa#Za~Oa$vO~P#sOj#QOQ!{ab!{af!{ah!{an!{ap!{a!V!{a!W!{a#Q!{a#S!{a#T!{a#]!{a!Q!{a~Oa!yap!ya~P#sOo#]j!Pj~",
        goto: ",`#aPPPPP#bP#j#xP#j$W#jPP$^PPP$d$m$mP%PP$mP$m%g%yPPP&c&i#jP&oP#jP&uP#jP#j#jPPP&{'_'qPP#bPP'y'y(T'yP'yP'y'yP#bP#bP#bP(W#bP(Z(^PP#bP#bP(a(o(})T)_)e)o)u){PPPPPP*R*ZP*u*xP+n+q+z]aOcr!y#l$]iXOcjopqr!y!z#]#l$]iROcjopqr!y!z#]#l$]QhSR!jiQvUR!nlQ!nxQ#S!SR#i!pq!UY[!O!g!{!}#Q#f#k#s#z$W$X$d$i$tp!UY[!O!g!{!}#Q#f#k#s#z$W$X$d$i$tT$S#b$Tq!SY[!O!g!{!}#Q#f#k#s#z$W$X$d$i$tp!UY[!O!g!{!}#Q#f#k#s#z$W$X$d$i$tQ!`]R#a!aQwUR!olQ!nwR#i!oQzVR!qmQ|WR!rnQsTQ!mkQ#^!]Q#d!dQ#e!eR$k$SQfPQ!xrQ#g!hQ#o!yQ$[#lR$r$]]ePr!h!y#l$]a![Z_`!Q!W!Y#X#YR#V!WR!a]R!c^R#c!cQcOU!fc!y$]Q!yrR$]#lQ#s!{U$c#s$i$tQ$i#zR$t$dQ$e#sR$u$eQkTS!lk$aR$a#pQ$X#fR$o$XQ#m!xS$^#m$`R$`#oQ#Z!XR$O#ZQ$T#bR$l$TQ!ifR#h!i]bOcr!y#l$][TOcr!y#l$]Q!kjQ!soQ!tpQ!uqQ#p!zR$P#]R#t!{Q!QYQ!^[Q#O!OQ#f!g[#r!{#s#z$d$i$tQ#u!}Q#w#QS$V#f$XQ$Z#kR$n$WR#q!zQ!]ZQ!e`R#R!QU!XZ`!QQ!d_Q#W!WQ#[!YQ#|#XR#}#Y",
        nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule Styles",
        maxTerm: 108,
        nodeProps: [["openedBy", 17, "(", 48, "{"], ["closedBy", 18, ")", 49, "}"]],
        propSources: [cssHighlighting],
        skippedNodes: [0, 3],
        repeatNodeCount: 9,
        tokenData: "Ay~R![OX$wX^%]^p$wpq%]qr(crs+}st,otu2Uuv$wvw2rwx2}xy3jyz3uz{3z{|4_|}8U}!O8a!O!P8x!P!Q9Z!Q![;e![!]<Y!]!^<x!^!_$w!_!`=T!`!a=`!a!b$w!b!c>O!c!}$w!}#O?[#O#P$w#P#Q?g#Q#R2U#R#T$w#T#U?r#U#c$w#c#d@q#d#o$w#o#pAQ#p#q2U#q#rA]#r#sAh#s#y$w#y#z%]#z$f$w$f$g%]$g#BY$w#BY#BZ%]#BZ$IS$w$IS$I_%]$I_$I|$w$I|$JO%]$JO$JT$w$JT$JU%]$JU$KV$w$KV$KW%]$KW&FU$w&FU&FV%]&FV~$wW$zQOy%Qz~%QW%VQoWOy%Qz~%Q~%bf#V~OX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q~&}f#V~oWOX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q^(fSOy%Qz#]%Q#]#^(r#^~%Q^(wSoWOy%Qz#a%Q#a#b)T#b~%Q^)YSoWOy%Qz#d%Q#d#e)f#e~%Q^)kSoWOy%Qz#c%Q#c#d)w#d~%Q^)|SoWOy%Qz#f%Q#f#g*Y#g~%Q^*_SoWOy%Qz#h%Q#h#i*k#i~%Q^*pSoWOy%Qz#T%Q#T#U*|#U~%Q^+RSoWOy%Qz#b%Q#b#c+_#c~%Q^+dSoWOy%Qz#h%Q#h#i+p#i~%Q^+wQ!VUoWOy%Qz~%Q~,QUOY+}Zr+}rs,ds#O+}#O#P,i#P~+}~,iOh~~,lPO~+}_,tWtPOy%Qz!Q%Q!Q![-^![!c%Q!c!i-^!i#T%Q#T#Z-^#Z~%Q^-cWoWOy%Qz!Q%Q!Q![-{![!c%Q!c!i-{!i#T%Q#T#Z-{#Z~%Q^.QWoWOy%Qz!Q%Q!Q![.j![!c%Q!c!i.j!i#T%Q#T#Z.j#Z~%Q^.qWfUoWOy%Qz!Q%Q!Q![/Z![!c%Q!c!i/Z!i#T%Q#T#Z/Z#Z~%Q^/bWfUoWOy%Qz!Q%Q!Q![/z![!c%Q!c!i/z!i#T%Q#T#Z/z#Z~%Q^0PWoWOy%Qz!Q%Q!Q![0i![!c%Q!c!i0i!i#T%Q#T#Z0i#Z~%Q^0pWfUoWOy%Qz!Q%Q!Q![1Y![!c%Q!c!i1Y!i#T%Q#T#Z1Y#Z~%Q^1_WoWOy%Qz!Q%Q!Q![1w![!c%Q!c!i1w!i#T%Q#T#Z1w#Z~%Q^2OQfUoWOy%Qz~%QY2XSOy%Qz!_%Q!_!`2e!`~%QY2lQzQoWOy%Qz~%QX2wQXPOy%Qz~%Q~3QUOY2}Zw2}wx,dx#O2}#O#P3d#P~2}~3gPO~2}_3oQbVOy%Qz~%Q~3zOa~_4RSUPjSOy%Qz!_%Q!_!`2e!`~%Q_4fUjS!PPOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q^4}SoWOy%Qz!Q%Q!Q![5Z![~%Q^5bWoW#]UOy%Qz!Q%Q!Q![5Z![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q^6PWoWOy%Qz{%Q{|6i|}%Q}!O6i!O!Q%Q!Q![6z![~%Q^6nSoWOy%Qz!Q%Q!Q![6z![~%Q^7RSoW#]UOy%Qz!Q%Q!Q![6z![~%Q^7fYoW#]UOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q_8ZQpVOy%Qz~%Q^8fUjSOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q_8}S#YPOy%Qz!Q%Q!Q![5Z![~%Q~9`RjSOy%Qz{9i{~%Q~9nSoWOy9iyz9zz{:o{~9i~9}ROz9zz{:W{~9z~:ZTOz9zz{:W{!P9z!P!Q:j!Q~9z~:oOR~~:tUoWOy9iyz9zz{:o{!P9i!P!Q;W!Q~9i~;_QoWR~Oy%Qz~%Q^;jY#]UOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%QX<_S]POy%Qz![%Q![!]<k!]~%QX<rQ^PoWOy%Qz~%Q_<}Q!WVOy%Qz~%QY=YQzQOy%Qz~%QX=eS|POy%Qz!`%Q!`!a=q!a~%QX=xQ|PoWOy%Qz~%QX>RUOy%Qz!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX>lY!YPoWOy%Qz}%Q}!O>e!O!Q%Q!Q![>e![!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX?aQxPOy%Qz~%Q^?lQvUOy%Qz~%QX?uSOy%Qz#b%Q#b#c@R#c~%QX@WSoWOy%Qz#W%Q#W#X@d#X~%QX@kQ!`PoWOy%Qz~%QX@tSOy%Qz#f%Q#f#g@d#g~%QXAVQ!RPOy%Qz~%Q_AbQ!QVOy%Qz~%QZAmS!PPOy%Qz!_%Q!_!`2e!`~%Q",
        tokenizers: [descendant, unitToken, identifiers, 0, 1, 2, 3],
        topRules: {
            "StyleSheet": [0, 4],
            "Styles": [1, 84]
        },
        specialized: [{
            term: 96,
            get: value => spec_callee[value] || -1
        }, {
            term: 56,
            get: value => spec_AtKeyword[value] || -1
        }, {
            term: 97,
            get: value => spec_identifier$2[value] || -1
        }],
        tokenPrec: 1120
    });
    let _properties = null;
    function properties() {
        if (!_properties && typeof document == "object" && document.body) {
            let names = [];
            for (let prop in document.body.style) {
                if (!/[A-Z]|^-|^(item|length)$/.test(prop))
                    names.push(prop);
            }
            _properties = names.sort().map(name => ({
                type: "property",
                label: name
            }));
        }
        return _properties || [];
    }
    const pseudoClasses = ["active", "after", "before", "checked", "default", "disabled", "empty", "enabled", "first-child", "first-letter", "first-line", "first-of-type", "focus", "hover", "in-range", "indeterminate", "invalid", "lang", "last-child", "last-of-type", "link", "not", "nth-child", "nth-last-child", "nth-last-of-type", "nth-of-type", "only-of-type", "only-child", "optional", "out-of-range", "placeholder", "read-only", "read-write", "required", "root", "selection", "target", "valid", "visited"].map(name => ({
        type: "class",
        label: name
    }));
    const values = ["above", "absolute", "activeborder", "additive", "activecaption", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "antialiased", "appworkspace", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic-abegede-gez", "ethiopic-halehame-aa-er", "ethiopic-halehame-gez", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "graytext", "grid", "groove", "hand", "hard-light", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "keep-all", "landscape", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lowercase", "ltr", "luminosity", "manipulation", "match", "matrix", "matrix3d", "medium", "menu", "menutext", "message-box", "middle", "min-intrinsic", "mix", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "perspective", "pinch-zoom", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub", "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "text", "text-bottom", "text-top", "textarea", "textfield", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "to", "top", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up", "upper-latin", "uppercase", "url", "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"].map(name => ({
        type: "keyword",
        label: name
    })).concat(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"].map(name => ({
        type: "constant",
        label: name
    })));
    const tags = ["a", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "figcaption", "figure", "footer", "form", "header", "hgroup", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "meter", "nav", "ol", "output", "p", "pre", "ruby", "section", "select", "small", "source", "span", "strong", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "tr", "u", "ul"].map(name => ({
        type: "type",
        label: name
    }));
    const identifier$1 = /^[\w-]*/;
    const cssCompletionSource = context => {
        let {state, pos} = context,
            node = syntaxTree(state).resolveInner(pos, -1);
        if (node.name == "PropertyName")
            return {
                from: node.from,
                options: properties(),
                validFor: identifier$1
            };
        if (node.name == "ValueName")
            return {
                from: node.from,
                options: values,
                validFor: identifier$1
            };
        if (node.name == "PseudoClassName")
            return {
                from: node.from,
                options: pseudoClasses,
                validFor: identifier$1
            };
        if (node.name == "TagName") {
            for (let {parent} = node; parent; parent = parent.parent)
                if (parent.name == "Block")
                    return {
                        from: node.from,
                        options: properties(),
                        validFor: identifier$1
                    };
            return {
                from: node.from,
                options: tags,
                validFor: identifier$1
            };
        }
        if (!context.explicit)
            return null;
        let above = node.resolve(pos),
            before = above.childBefore(pos);
        if (before && before.name == ":" && above.name == "PseudoClassSelector")
            return {
                from: pos,
                options: pseudoClasses,
                validFor: identifier$1
            };
        if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList")
            return {
                from: pos,
                options: values,
                validFor: identifier$1
            };
        if (above.name == "Block")
            return {
                from: pos,
                options: properties(),
                validFor: identifier$1
            };
        return null;
    };
    const cssLanguage = LRLanguage.define({
        parser: parser$7.configure({
            props: [indentNodeProp.add({
                Declaration: continuedIndent()
            }), foldNodeProp.add({
                Block: foldInside
            })]
        }),
        languageData: {
            commentTokens: {
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            indentOnInput: /^\s*\}$/,
            wordChars: "-"
        }
    });
    function css() {
        return new LanguageSupport(cssLanguage, cssLanguage.data.of({
            autocomplete: cssCompletionSource
        }));
    }
    var _m15 = Object.freeze({
        __proto__: null,
        css: css,
        cssCompletionSource: cssCompletionSource,
        cssLanguage: cssLanguage
    });
    const Targets = ["_blank", "_self", "_top", "_parent"];
    const Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
    const Methods = ["get", "post", "put", "delete"];
    const Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
    const Bool$1 = ["true", "false"];
    const S = {};
    const Tags = {
        a: {
            attrs: {
                href: null,
                ping: null,
                type: null,
                media: null,
                target: Targets,
                hreflang: null
            }
        },
        abbr: S,
        address: S,
        area: {
            attrs: {
                alt: null,
                coords: null,
                href: null,
                target: null,
                ping: null,
                media: null,
                hreflang: null,
                type: null,
                shape: ["default", "rect", "circle", "poly"]
            }
        },
        article: S,
        aside: S,
        audio: {
            attrs: {
                src: null,
                mediagroup: null,
                crossorigin: ["anonymous", "use-credentials"],
                preload: ["none", "metadata", "auto"],
                autoplay: ["autoplay"],
                loop: ["loop"],
                controls: ["controls"]
            }
        },
        b: S,
        base: {
            attrs: {
                href: null,
                target: Targets
            }
        },
        bdi: S,
        bdo: S,
        blockquote: {
            attrs: {
                cite: null
            }
        },
        body: S,
        br: S,
        button: {
            attrs: {
                form: null,
                formaction: null,
                name: null,
                value: null,
                autofocus: ["autofocus"],
                disabled: ["autofocus"],
                formenctype: Encs,
                formmethod: Methods,
                formnovalidate: ["novalidate"],
                formtarget: Targets,
                type: ["submit", "reset", "button"]
            }
        },
        canvas: {
            attrs: {
                width: null,
                height: null
            }
        },
        caption: S,
        center: S,
        cite: S,
        code: S,
        col: {
            attrs: {
                span: null
            }
        },
        colgroup: {
            attrs: {
                span: null
            }
        },
        command: {
            attrs: {
                type: ["command", "checkbox", "radio"],
                label: null,
                icon: null,
                radiogroup: null,
                command: null,
                title: null,
                disabled: ["disabled"],
                checked: ["checked"]
            }
        },
        data: {
            attrs: {
                value: null
            }
        },
        datagrid: {
            attrs: {
                disabled: ["disabled"],
                multiple: ["multiple"]
            }
        },
        datalist: {
            attrs: {
                data: null
            }
        },
        dd: S,
        del: {
            attrs: {
                cite: null,
                datetime: null
            }
        },
        details: {
            attrs: {
                open: ["open"]
            }
        },
        dfn: S,
        div: S,
        dl: S,
        dt: S,
        em: S,
        embed: {
            attrs: {
                src: null,
                type: null,
                width: null,
                height: null
            }
        },
        eventsource: {
            attrs: {
                src: null
            }
        },
        fieldset: {
            attrs: {
                disabled: ["disabled"],
                form: null,
                name: null
            }
        },
        figcaption: S,
        figure: S,
        footer: S,
        form: {
            attrs: {
                action: null,
                name: null,
                "accept-charset": Charsets,
                autocomplete: ["on", "off"],
                enctype: Encs,
                method: Methods,
                novalidate: ["novalidate"],
                target: Targets
            }
        },
        h1: S,
        h2: S,
        h3: S,
        h4: S,
        h5: S,
        h6: S,
        head: {
            children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
        },
        header: S,
        hgroup: S,
        hr: S,
        html: {
            attrs: {
                manifest: null
            }
        },
        i: S,
        iframe: {
            attrs: {
                src: null,
                srcdoc: null,
                name: null,
                width: null,
                height: null,
                sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
                seamless: ["seamless"]
            }
        },
        img: {
            attrs: {
                alt: null,
                src: null,
                ismap: null,
                usemap: null,
                width: null,
                height: null,
                crossorigin: ["anonymous", "use-credentials"]
            }
        },
        input: {
            attrs: {
                alt: null,
                dirname: null,
                form: null,
                formaction: null,
                height: null,
                list: null,
                max: null,
                maxlength: null,
                min: null,
                name: null,
                pattern: null,
                placeholder: null,
                size: null,
                src: null,
                step: null,
                value: null,
                width: null,
                accept: ["audio/*", "video/*", "image/*"],
                autocomplete: ["on", "off"],
                autofocus: ["autofocus"],
                checked: ["checked"],
                disabled: ["disabled"],
                formenctype: Encs,
                formmethod: Methods,
                formnovalidate: ["novalidate"],
                formtarget: Targets,
                multiple: ["multiple"],
                readonly: ["readonly"],
                required: ["required"],
                type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month", "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio", "file", "submit", "image", "reset", "button"]
            }
        },
        ins: {
            attrs: {
                cite: null,
                datetime: null
            }
        },
        kbd: S,
        keygen: {
            attrs: {
                challenge: null,
                form: null,
                name: null,
                autofocus: ["autofocus"],
                disabled: ["disabled"],
                keytype: ["RSA"]
            }
        },
        label: {
            attrs: {
                for: null,
                form: null
            }
        },
        legend: S,
        li: {
            attrs: {
                value: null
            }
        },
        link: {
            attrs: {
                href: null,
                type: null,
                hreflang: null,
                media: null,
                sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
            }
        },
        map: {
            attrs: {
                name: null
            }
        },
        mark: S,
        menu: {
            attrs: {
                label: null,
                type: ["list", "context", "toolbar"]
            }
        },
        meta: {
            attrs: {
                content: null,
                charset: Charsets,
                name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
                "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
            }
        },
        meter: {
            attrs: {
                value: null,
                min: null,
                low: null,
                high: null,
                max: null,
                optimum: null
            }
        },
        nav: S,
        noscript: S,
        object: {
            attrs: {
                data: null,
                type: null,
                name: null,
                usemap: null,
                form: null,
                width: null,
                height: null,
                typemustmatch: ["typemustmatch"]
            }
        },
        ol: {
            attrs: {
                reversed: ["reversed"],
                start: null,
                type: ["1", "a", "A", "i", "I"]
            },
            children: ["li", "script", "template", "ul", "ol"]
        },
        optgroup: {
            attrs: {
                disabled: ["disabled"],
                label: null
            }
        },
        option: {
            attrs: {
                disabled: ["disabled"],
                label: null,
                selected: ["selected"],
                value: null
            }
        },
        output: {
            attrs: {
                for: null,
                form: null,
                name: null
            }
        },
        p: S,
        param: {
            attrs: {
                name: null,
                value: null
            }
        },
        pre: S,
        progress: {
            attrs: {
                value: null,
                max: null
            }
        },
        q: {
            attrs: {
                cite: null
            }
        },
        rp: S,
        rt: S,
        ruby: S,
        samp: S,
        script: {
            attrs: {
                type: ["text/javascript"],
                src: null,
                async: ["async"],
                defer: ["defer"],
                charset: Charsets
            }
        },
        section: S,
        select: {
            attrs: {
                form: null,
                name: null,
                size: null,
                autofocus: ["autofocus"],
                disabled: ["disabled"],
                multiple: ["multiple"]
            }
        },
        slot: {
            attrs: {
                name: null
            }
        },
        small: S,
        source: {
            attrs: {
                src: null,
                type: null,
                media: null
            }
        },
        span: S,
        strong: S,
        style: {
            attrs: {
                type: ["text/css"],
                media: null,
                scoped: null
            }
        },
        sub: S,
        summary: S,
        sup: S,
        table: S,
        tbody: S,
        td: {
            attrs: {
                colspan: null,
                rowspan: null,
                headers: null
            }
        },
        template: S,
        textarea: {
            attrs: {
                dirname: null,
                form: null,
                maxlength: null,
                name: null,
                placeholder: null,
                rows: null,
                cols: null,
                autofocus: ["autofocus"],
                disabled: ["disabled"],
                readonly: ["readonly"],
                required: ["required"],
                wrap: ["soft", "hard"]
            }
        },
        tfoot: S,
        th: {
            attrs: {
                colspan: null,
                rowspan: null,
                headers: null,
                scope: ["row", "col", "rowgroup", "colgroup"]
            }
        },
        thead: S,
        time: {
            attrs: {
                datetime: null
            }
        },
        title: S,
        tr: S,
        track: {
            attrs: {
                src: null,
                label: null,
                default: null,
                kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
                srclang: null
            }
        },
        ul: {
            children: ["li", "script", "template", "ul", "ol"]
        },
        var: S,
        video: {
            attrs: {
                src: null,
                poster: null,
                width: null,
                height: null,
                crossorigin: ["anonymous", "use-credentials"],
                preload: ["auto", "metadata", "none"],
                autoplay: ["autoplay"],
                mediagroup: ["movie"],
                muted: ["muted"],
                controls: ["controls"]
            }
        },
        wbr: S
    };
    const GlobalAttrs = {
        accesskey: null,
        class: null,
        contenteditable: Bool$1,
        contextmenu: null,
        dir: ["ltr", "rtl", "auto"],
        draggable: ["true", "false", "auto"],
        dropzone: ["copy", "move", "link", "string:", "file:"],
        hidden: ["hidden"],
        id: null,
        inert: ["inert"],
        itemid: null,
        itemprop: null,
        itemref: null,
        itemscope: ["itemscope"],
        itemtype: null,
        lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
        spellcheck: Bool$1,
        autocorrect: Bool$1,
        autocapitalize: Bool$1,
        style: null,
        tabindex: null,
        title: null,
        translate: ["yes", "no"],
        rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
        role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
        "aria-activedescendant": null,
        "aria-atomic": Bool$1,
        "aria-autocomplete": ["inline", "list", "both", "none"],
        "aria-busy": Bool$1,
        "aria-checked": ["true", "false", "mixed", "undefined"],
        "aria-controls": null,
        "aria-describedby": null,
        "aria-disabled": Bool$1,
        "aria-dropeffect": null,
        "aria-expanded": ["true", "false", "undefined"],
        "aria-flowto": null,
        "aria-grabbed": ["true", "false", "undefined"],
        "aria-haspopup": Bool$1,
        "aria-hidden": Bool$1,
        "aria-invalid": ["true", "false", "grammar", "spelling"],
        "aria-label": null,
        "aria-labelledby": null,
        "aria-level": null,
        "aria-live": ["off", "polite", "assertive"],
        "aria-multiline": Bool$1,
        "aria-multiselectable": Bool$1,
        "aria-owns": null,
        "aria-posinset": null,
        "aria-pressed": ["true", "false", "mixed", "undefined"],
        "aria-readonly": Bool$1,
        "aria-relevant": null,
        "aria-required": Bool$1,
        "aria-selected": ["true", "false", "undefined"],
        "aria-setsize": null,
        "aria-sort": ["ascending", "descending", "none", "other"],
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null,
        "aria-valuetext": null
    };
    const eventAttributes = ("beforeunload copy cut dragstart dragover dragleave dragenter dragend " + "drag paste focus blur change click load mousedown mouseenter mouseleave " + "mouseup keydown keyup resize scroll unload").split(" ").map(n => "on" + n);
    for (let _i253 = 0, _length253 = eventAttributes.length; _i253 < _length253; _i253++) {
        let a = eventAttributes[_i253];
        GlobalAttrs[a] = null;
    }
    class Schema {
        constructor(extraTags, extraAttrs)
        {
            this.tags = Object.assign(Object.assign({}, Tags), extraTags);
            this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
            this.allTags = Object.keys(this.tags);
            this.globalAttrNames = Object.keys(this.globalAttrs);
        }
    }
    Schema.default = new Schema();
    function elementName$1(doc, tree, max=doc.length) {
        if (!tree)
            return "";
        let tag = tree.firstChild;
        let name = tag && tag.getChild("TagName");
        return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
    }
    function findParentElement$1(tree, skip=false) {
        for (let cur = tree.parent; cur; cur = cur.parent)
            if (cur.name == "Element") {
                if (skip)
                    skip = false;
                else
                    return cur;
            }
        return null;
    }
    function allowedChildren(doc, tree, schema) {
        let parentInfo = schema.tags[elementName$1(doc, findParentElement$1(tree, true))];
        return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
    }
    function openTags(doc, tree) {
        let open = [];
        for (let parent = tree; parent = findParentElement$1(parent);) {
            let tagName = elementName$1(doc, parent);
            if (tagName && parent.lastChild.name == "CloseTag")
                break;
            if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
                open.push(tagName);
        }
        return open;
    }
    const identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
    function completeTag(state, schema, tree, from, to) {
        let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
        return {
            from,
            to,
            options: allowedChildren(state.doc, tree, schema).map(tagName => ({
                label: tagName,
                type: "type"
            })).concat(openTags(state.doc, tree).map((tag, i) => ({
                label: "/" + tag,
                apply: "/" + tag + end,
                type: "type",
                boost: 99 - i
            }))),
            validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
        };
    }
    function completeCloseTag(state, tree, from, to) {
        let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
        return {
            from,
            to,
            options: openTags(state.doc, tree).map((tag, i) => ({
                label: tag,
                apply: tag + end,
                type: "type",
                boost: 99 - i
            })),
            validFor: identifier
        };
    }
    function completeStartTag(state, schema, tree, pos) {
        let options = [],
            level = 0;
        for (let _i254 = 0, _allowedChildren = allowedChildren(state.doc, tree, schema), _length254 = _allowedChildren.length; _i254 < _length254; _i254++) {
            let tagName = _allowedChildren[_i254];
            options.push({
                label: "<" + tagName,
                type: "type"
            });
        }
        for (let _i255 = 0, _openTags = openTags(state.doc, tree), _length255 = _openTags.length; _i255 < _length255; _i255++) {
            let open = _openTags[_i255];
            options.push({
                label: "</" + open + ">",
                type: "type",
                boost: 99 - level++
            });
        }
        return {
            from: pos,
            to: pos,
            options,
            validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
        };
    }
    function completeAttrName(state, schema, tree, from, to) {
        let elt = findParentElement$1(tree),
            info = elt ? schema.tags[elementName$1(state.doc, elt)] : null;
        let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];
        let names = info && info.globalAttrs === false ? localAttrs : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;
        return {
            from,
            to,
            options: names.map(attrName => ({
                label: attrName,
                type: "property"
            })),
            validFor: identifier
        };
    }
    function completeAttrValue(state, schema, tree, from, to) {
        var _a;
        let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild("AttributeName");
        let options = [],
            token = undefined;
        if (nameNode) {
            let attrName = state.sliceDoc(nameNode.from, nameNode.to);
            let attrs = schema.globalAttrs[attrName];
            if (!attrs) {
                let elt = findParentElement$1(tree),
                    info = elt ? schema.tags[elementName$1(state.doc, elt)] : null;
                attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
            }
            if (attrs) {
                let base = state.sliceDoc(from, to).toLowerCase(),
                    quoteStart = '"',
                    quoteEnd = '"';
                if (/^['"]/.test(base)) {
                    token = base[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
                    quoteStart = "";
                    quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? "" : base[0];
                    base = base.slice(1);
                    from++;
                } else {
                    token = /^[^\s<>='"]*$/;
                }
                for (let _i256 = 0, _attrs = attrs, _length256 = _attrs.length; _i256 < _length256; _i256++) {
                    let value = _attrs[_i256];
                    options.push({
                        label: value,
                        apply: quoteStart + value + quoteEnd,
                        type: "constant"
                    });
                }
            }
        }
        return {
            from,
            to,
            options,
            validFor: token
        };
    }
    function htmlCompletionFor(schema, context) {
        let {state, pos} = context,
            around = syntaxTree(state).resolveInner(pos),
            tree = around.resolve(pos, -1);
        for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {
            let last = before.lastChild;
            if (!last || !last.type.isError || last.from < last.to)
                break;
            around = tree = before;
            scan = last.from;
        }
        if (tree.name == "TagName") {
            return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos) : completeTag(state, schema, tree, tree.from, pos);
        } else if (tree.name == "StartTag") {
            return completeTag(state, schema, tree, pos, pos);
        } else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
            return completeCloseTag(state, tree, pos, pos);
        } else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") {
            return completeAttrName(state, schema, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
        } else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
            return completeAttrValue(state, schema, tree, tree.name == "Is" ? pos : tree.from, pos);
        } else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
            return completeStartTag(state, schema, tree, pos);
        } else {
            return null;
        }
    }
    function htmlCompletionSource(context) {
        return htmlCompletionFor(Schema.default, context);
    }
    function htmlCompletionSourceWith(config) {
        let {extraTags, extraGlobalAttributes: extraAttrs} = config;
        let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
        return context => htmlCompletionFor(schema, context);
    }
    const defaultNesting = [{
        tag: "script",
        attrs: attrs => attrs.type == "text/typescript" || attrs.lang == "ts",
        parser: typescriptLanguage.parser
    }, {
        tag: "script",
        attrs: attrs => attrs.type == "text/babel" || attrs.type == "text/jsx",
        parser: jsxLanguage.parser
    }, {
        tag: "script",
        attrs: attrs => attrs.type == "text/typescript-jsx",
        parser: tsxLanguage.parser
    }, {
        tag: "script",
        attrs(attrs) {
            return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
        },
        parser: javascriptLanguage.parser
    }, {
        tag: "style",
        attrs(attrs) {
            return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
        },
        parser: cssLanguage.parser
    }];
    const defaultAttrs = [{
        name: "style",
        parser: cssLanguage.parser.configure({
            top: "Styles"
        })
    }].concat(eventAttributes.map(name => ({
        name,
        parser: javascriptLanguage.parser
    })));
    const htmlLanguage = LRLanguage.define({
        name: "html",
        parser: parser$8.configure({
            props: [indentNodeProp.add({
                Element(context) {
                    let after = /^(\s*)(<\/)?/.exec(context.textAfter);
                    if (context.node.to <= context.pos + after[0].length)
                        return context.continue();
                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
                },
                "OpenTag CloseTag SelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                },
                Document(context) {
                    if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
                        return context.continue();
                    let endElt = null,
                        close;
                    for (let cur = context.node; ;) {
                        let last = cur.lastChild;
                        if (!last || last.name != "Element" || last.to != cur.to)
                            break;
                        endElt = cur = last;
                    }
                    if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
                        return context.lineIndent(endElt.from) + context.unit;
                    return null;
                }
            }), foldNodeProp.add({
                Element(node) {
                    let first = node.firstChild,
                        last = node.lastChild;
                    if (!first || first.name != "OpenTag")
                        return null;
                    return {
                        from: first.to,
                        to: last.name == "CloseTag" ? last.from : node.to
                    };
                }
            }), bracketMatchingHandle.add({
                "OpenTag CloseTag": node => node.getChild("TagName")
            })],
            wrap: configureNesting(defaultNesting, defaultAttrs)
        }),
        languageData: {
            commentTokens: {
                block: {
                    open: "<!--",
                    close: "-->"
                }
            },
            indentOnInput: /^\s*<\/\w+\W$/,
            wordChars: "-._"
        }
    });
    function html(config={}) {
        let dialect = "",
            wrap;
        if (config.matchClosingTags === false)
            dialect = "noMatch";
        if (config.selfClosingTags === true)
            dialect = (dialect ? dialect + " " : "") + "selfClosing";
        if (config.nestedLanguages && config.nestedLanguages.length || config.nestedAttributes && config.nestedAttributes.length)
            wrap = configureNesting((config.nestedLanguages || []).concat(defaultNesting), (config.nestedAttributes || []).concat(defaultAttrs));
        let lang = wrap || dialect ? htmlLanguage.configure({
            dialect,
            wrap
        }) : htmlLanguage;
        return new LanguageSupport(lang, [htmlLanguage.data.of({
            autocomplete: htmlCompletionSourceWith(config)
        }), config.autoCloseTags !== false ? autoCloseTags : [], javascript().support, css().support]);
    }
    const autoCloseTags = EditorView.inputHandler.of((view, from, to, text) => {
        if (view.composing || view.state.readOnly || from != to || text != ">" && text != "/" || !htmlLanguage.isActiveAt(view.state, from, -1))
            return false;
        let {state} = view;
        let changes = state.changeByRange(range => {
            var _a,
                _b,
                _c;
            let {head} = range,
                around = syntaxTree(state).resolveInner(head, -1),
                name;
            if (around.name == "TagName" || around.name == "StartTag")
                around = around.parent;
            if (text == ">" && around.name == "OpenTag") {
                if (((_b = (_a = around.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name = elementName$1(state.doc, around.parent, head))) {
                    let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
                    let insert = `${hasRightBracket ? "" : ">"}</${name}>`;
                    return {
                        range: EditorSelection.cursor(head + 1),
                        changes: {
                            from: head + (hasRightBracket ? 1 : 0),
                            insert
                        }
                    };
                }
            } else if (text == "/" && around.name == "OpenTag") {
                let empty = around.parent,
                    base = empty === null || empty === void 0 ? void 0 : empty.parent;
                if (empty.from == head - 1 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name = elementName$1(state.doc, base, head))) {
                    let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
                    let insert = `/${name}${hasRightBracket ? "" : ">"}`;
                    let pos = head + insert.length + (hasRightBracket ? 1 : 0);
                    return {
                        range: EditorSelection.cursor(pos),
                        changes: {
                            from: head,
                            insert
                        }
                    };
                }
            }
            return {
                range
            };
        });
        if (changes.changes.empty)
            return false;
        view.dispatch(changes, {
            userEvent: "input.type",
            scrollIntoView: true
        });
        return true;
    });
    var _m16 = Object.freeze({
        __proto__: null,
        autoCloseTags: autoCloseTags,
        html: html,
        htmlCompletionSource: htmlCompletionSource,
        htmlCompletionSourceWith: htmlCompletionSourceWith,
        htmlLanguage: htmlLanguage
    });
    const phpLanguage = LRLanguage.define({
        parser: parser$9.configure({
            props: [indentNodeProp.add({
                IfStatement: continuedIndent({
                    except: /^\s*({|else\b|elseif\b|endif\b)/
                }),
                TryStatement: continuedIndent({
                    except: /^\s*({|catch\b|finally\b)/
                }),
                SwitchBody: context => {
                    let after = context.textAfter,
                        closed = /^\s*\}/.test(after),
                        isCase = /^\s*(case|default)\b/.test(after);
                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
                },
                ColonBlock: cx => cx.baseIndent + cx.unit,
                "Block EnumBody DeclarationList": delimitedIndent({
                    closing: "}"
                }),
                ArrowFunction: cx => cx.baseIndent + cx.unit,
                "String BlockComment": () => null,
                Statement: continuedIndent({
                    except: /^({|end(for|foreach|switch|while)\b)/
                })
            }), foldNodeProp.add({
                "Block EnumBody DeclarationList SwitchBody ArrayExpression ValueList": foldInside,
                ColonBlock(tree) {
                    return {
                        from: tree.from + 1,
                        to: tree.to
                    };
                },
                BlockComment(tree) {
                    return {
                        from: tree.from + 2,
                        to: tree.to - 2
                    };
                }
            })]
        }),
        languageData: {
            commentTokens: {
                block: {
                    open: "/*",
                    close: "*/"
                },
                line: "//"
            },
            indentOnInput: /^\s*(?:case |default:|end(?:if|for(?:each)?|switch|while)|else(?:if)?|\{|\})$/,
            wordChars: "$"
        }
    });
    function php(config={}) {
        let support = [],
            base;
        if (config.baseLanguage === null)
            ;
        else if (config.baseLanguage) {
            base = config.baseLanguage;
        } else {
            let htmlSupport = html({
                matchClosingTags: false
            });
            support.push(htmlSupport.support);
            base = htmlSupport.language;
        }
        return new LanguageSupport(phpLanguage.configure({
            wrap: base && parseMixed(node => {
                if (!node.type.isTop)
                    return null;
                return {
                    parser: base.parser,
                    overlay: node => node.name == "Text"
                };
            }),
            top: config.plain ? "Program" : "Template"
        }), support);
    }
    var _m13 = Object.freeze({
        __proto__: null,
        php: php,
        phpLanguage: phpLanguage
    });
    const printKeyword = 1,
        indent = 189,
        dedent = 190,
        newline$1 = 191,
        newlineBracketed = 192,
        newlineEmpty = 193,
        eof = 194,
        ParenL$1 = 22,
        ParenthesizedExpression = 23,
        TupleExpression = 47,
        ComprehensionExpression = 48,
        BracketL$1 = 53,
        ArrayExpression = 54,
        ArrayComprehensionExpression = 55,
        BraceL$1 = 57,
        DictionaryExpression = 58,
        DictionaryComprehensionExpression = 59,
        SetExpression = 60,
        SetComprehensionExpression = 61,
        ArgList = 63,
        subscript = 230,
        FormatReplacement = 71,
        importList = 255,
        ParamList = 121,
        SequencePattern = 142,
        MappingPattern = 143,
        PatternArgList = 146;
    const newline = 10,
        carriageReturn = 13,
        space$1 = 32,
        tab = 9,
        hash = 35,
        parenOpen = 40,
        dot = 46;
    const bracketed = new Set([ParenthesizedExpression, TupleExpression, ComprehensionExpression, importList, ArgList, ParamList, ArrayExpression, ArrayComprehensionExpression, subscript, SetExpression, SetComprehensionExpression, DictionaryExpression, DictionaryComprehensionExpression, FormatReplacement, SequencePattern, MappingPattern, PatternArgList]);
    const newlines = new ExternalTokenizer((input, stack) => {
        if (input.next < 0) {
            input.acceptToken(eof);
        } else if (input.next != newline && input.next != carriageReturn)
            ;
        else if (stack.context.depth < 0) {
            input.acceptToken(newlineBracketed, 1);
        } else {
            input.advance();
            let spaces = 0;
            while (input.next == space$1 || input.next == tab) {
                input.advance();
                spaces++;
            }
            let empty = input.next == newline || input.next == carriageReturn || input.next == hash;
            input.acceptToken(empty ? newlineEmpty : newline$1, -spaces);
        }
    }, {
        contextual: true,
        fallback: true
    });
    const indentation = new ExternalTokenizer((input, stack) => {
        let cDepth = stack.context.depth;
        if (cDepth < 0)
            return;
        let prev = input.peek(-1);
        if ((prev == newline || prev == carriageReturn) && stack.context.depth >= 0) {
            let depth = 0,
                chars = 0;
            for (;;) {
                if (input.next == space$1)
                    depth++;
                else if (input.next == tab)
                    depth += 8 - depth % 8;
                else
                    break;
                input.advance();
                chars++;
            }
            if (depth != cDepth && input.next != newline && input.next != carriageReturn && input.next != hash) {
                if (depth < cDepth)
                    input.acceptToken(dedent, -chars);
                else
                    input.acceptToken(indent);
            }
        }
    });
    function IndentLevel(parent, depth) {
        this.parent = parent;
        this.depth = depth;
        this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4);
    }
    const topIndent = new IndentLevel(null, 0);
    function countIndent(space) {
        let depth = 0;
        for (let i = 0; i < space.length; i++)
            depth += space.charCodeAt(i) == tab ? 8 - depth % 8 : 1;
        return depth;
    }
    const trackIndent = new ContextTracker({
        start: topIndent,
        reduce(context, term) {
            return context.depth < 0 && bracketed.has(term) ? context.parent : context;
        },
        shift(context, term, stack, input) {
            if (term == indent)
                return new IndentLevel(context, countIndent(input.read(input.pos, stack.pos)));
            if (term == dedent)
                return context.parent;
            if (term == ParenL$1 || term == BracketL$1 || term == BraceL$1)
                return new IndentLevel(context, -1);
            return context;
        },
        hash(context) {
            return context.hash;
        }
    });
    const legacyPrint = new ExternalTokenizer(input => {
        for (let i = 0; i < 5; i++) {
            if (input.next != "print".charCodeAt(i))
                return;
            input.advance();
        }
        if (/\w/.test(String.fromCharCode(input.next)))
            return;
        for (let off = 0; ; off++) {
            let next = input.peek(off);
            if (next == space$1 || next == tab)
                continue;
            if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)
                input.acceptToken(printKeyword);
            return;
        }
    });
    const pythonHighlighting = styleTags({
        "async \"*\" \"**\" FormatConversion FormatSpec": tags$1.modifier,
        "for while if elif else try except finally return raise break continue with pass assert await yield match case": tags$1.controlKeyword,
        "in not and or is del": tags$1.operatorKeyword,
        "from def class global nonlocal lambda": tags$1.definitionKeyword,
        import: tags$1.moduleKeyword,
        "with as print": tags$1.keyword,
        Boolean: tags$1.bool,
        None: tags$1.null,
        VariableName: tags$1.variableName,
        "CallExpression/VariableName": tags$1.function(tags$1.variableName),
        "FunctionDefinition/VariableName": tags$1.function(tags$1.definition(tags$1.variableName)),
        "ClassDefinition/VariableName": tags$1.definition(tags$1.className),
        PropertyName: tags$1.propertyName,
        "CallExpression/MemberExpression/PropertyName": tags$1.function(tags$1.propertyName),
        Comment: tags$1.lineComment,
        Number: tags$1.number,
        String: tags$1.string,
        FormatString: tags$1.special(tags$1.string),
        UpdateOp: tags$1.updateOperator,
        ArithOp: tags$1.arithmeticOperator,
        BitOp: tags$1.bitwiseOperator,
        CompareOp: tags$1.compareOperator,
        AssignOp: tags$1.definitionOperator,
        Ellipsis: tags$1.punctuation,
        At: tags$1.meta,
        "( )": tags$1.paren,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace,
        ".": tags$1.derefOperator,
        ", ;": tags$1.separator
    });
    const spec_identifier$1 = {
        __proto__: null,
        await: 40,
        or: 50,
        and: 52,
        in: 56,
        not: 58,
        is: 60,
        if: 66,
        else: 68,
        lambda: 72,
        yield: 90,
        from: 92,
        async: 98,
        for: 100,
        None: 152,
        True: 154,
        False: 154,
        del: 168,
        pass: 172,
        break: 176,
        continue: 180,
        return: 184,
        raise: 192,
        import: 196,
        as: 198,
        global: 202,
        nonlocal: 204,
        assert: 208,
        elif: 218,
        while: 222,
        try: 228,
        except: 230,
        finally: 232,
        with: 236,
        def: 240,
        class: 250,
        match: 261,
        case: 267
    };
    const parser$6 = LRParser.deserialize({
        version: 14,
        states: "!L`O`Q$IXOOO%fQ$I[O'#G|OOQ$IS'#Cm'#CmOOQ$IS'#Cn'#CnO'UQ$IWO'#ClO(wQ$I[O'#G{OOQ$IS'#G|'#G|OOQ$IS'#DS'#DSOOQ$IS'#G{'#G{O)eQ$IWO'#CsO)uQ$IWO'#DdO*VQ$IWO'#DhOOQ$IS'#Ds'#DsO*jO`O'#DsO*rOpO'#DsO*zO!bO'#DtO+VO#tO'#DtO+bO&jO'#DtO+mO,UO'#DtO-oQ$I[O'#GmOOQ$IS'#Gm'#GmO'UQ$IWO'#GlO/RQ$I[O'#GlOOQ$IS'#E]'#E]O/jQ$IWO'#E^OOQ$IS'#Gk'#GkO/tQ$IWO'#GjOOQ$IV'#Gj'#GjO0PQ$IWO'#FPOOQ$IS'#GX'#GXO0UQ$IWO'#FOOOQ$IV'#Hx'#HxOOQ$IV'#Gi'#GiOOQ$IT'#Fh'#FhQ`Q$IXOOO'UQ$IWO'#CoO0dQ$IWO'#C{O0kQ$IWO'#DPO0yQ$IWO'#HQO1ZQ$I[O'#EQO'UQ$IWO'#EROOQ$IS'#ET'#ETOOQ$IS'#EV'#EVOOQ$IS'#EX'#EXO1oQ$IWO'#EZO2VQ$IWO'#E_O0PQ$IWO'#EaO2jQ$I[O'#EaO0PQ$IWO'#EdO/jQ$IWO'#EgO/jQ$IWO'#EkO/jQ$IWO'#EnO2uQ$IWO'#EpO2|Q$IWO'#EuO3XQ$IWO'#EqO/jQ$IWO'#EuO0PQ$IWO'#EwO0PQ$IWO'#E|O3^Q$IWO'#FROOQ$IS'#Cc'#CcOOQ$IS'#Cd'#CdOOQ$IS'#Ce'#CeOOQ$IS'#Cf'#CfOOQ$IS'#Cg'#CgOOQ$IS'#Ch'#ChOOQ$IS'#Cj'#CjO'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O3eQ$IWO'#DmOOQ$IS,5:W,5:WO3xQ$IWO'#H[OOQ$IS,5:Z,5:ZO4VQ%1`O,5:ZO4[Q$I[O,59WO0dQ$IWO,59`O0dQ$IWO,59`O0dQ$IWO,59`O6zQ$IWO,59`O7PQ$IWO,59`O7WQ$IWO,59hO7_Q$IWO'#G{O8eQ$IWO'#GzOOQ$IS'#Gz'#GzOOQ$IS'#DY'#DYO8|Q$IWO,59_O'UQ$IWO,59_O9[Q$IWO,59_O9aQ$IWO,5:PO'UQ$IWO,5:POOQ$IS,5:O,5:OO9oQ$IWO,5:OO9tQ$IWO,5:VO'UQ$IWO,5:VO'UQ$IWO,5:TOOQ$IS,5:S,5:SO:VQ$IWO,5:SO:[Q$IWO,5:UOOOO'#Fp'#FpO:aO`O,5:_OOQ$IS,5:_,5:_OOOO'#Fq'#FqO:iOpO,5:_O:qQ$IWO'#DuOOOO'#Fr'#FrO;RO!bO,5:`OOQ$IS,5:`,5:`OOOO'#Fu'#FuO;^O#tO,5:`OOOO'#Fv'#FvO;iO&jO,5:`OOOO'#Fw'#FwO;tO,UO,5:`OOQ$IS'#Fx'#FxO<PQ$I[O,5:dO>qQ$I[O,5=WO?[Q%GlO,5=WO?{Q$I[O,5=WOOQ$IS,5:x,5:xO@dQ$IXO'#GQOAsQ$IWO,5;TOOQ$IV,5=U,5=UOBOQ$I[O'#HtOBgQ$IWO,5;kOOQ$IS-E:V-E:VOOQ$IV,5;j,5;jO3SQ$IWO'#EwOOQ$IT-E9f-E9fOBoQ$I[O,59ZODvQ$I[O,59gOEaQ$IWO'#G}OElQ$IWO'#G}O0PQ$IWO'#G}OEwQ$IWO'#DROFPQ$IWO,59kOFUQ$IWO'#HRO'UQ$IWO'#HRO/jQ$IWO,5=lOOQ$IS,5=l,5=lO/jQ$IWO'#D|OOQ$IS'#D}'#D}OFsQ$IWO'#FzOGTQ$IWO,58zOGTQ$IWO,58zO)hQ$IWO,5:jOGcQ$I[O'#HTOOQ$IS,5:m,5:mOOQ$IS,5:u,5:uOGvQ$IWO,5:yOHXQ$IWO,5:{OOQ$IS'#F}'#F}OHgQ$I[O,5:{OHuQ$IWO,5:{OHzQ$IWO'#HwOOQ$IS,5;O,5;OOIYQ$IWO'#HsOOQ$IS,5;R,5;RO3XQ$IWO,5;VO3XQ$IWO,5;YOIkQ$I[O'#HyO'UQ$IWO'#HyOIuQ$IWO,5;[O2uQ$IWO,5;[O/jQ$IWO,5;aO0PQ$IWO,5;cOIzQ$IXO'#ElOKTQ$IZO,5;]ONiQ$IWO'#HzO3XQ$IWO,5;aONtQ$IWO,5;cONyQ$IWO,5;hO! RQ$I[O,5;mO'UQ$IWO,5;mO!#uQ$I[O1G.hO!#|Q$I[O1G.hO!&mQ$I[O1G.hO!&wQ$I[O1G.hO!)bQ$I[O1G.hO!)uQ$I[O1G.hO!*YQ$IWO'#HZO!*hQ$I[O'#GmO/jQ$IWO'#HZO!*rQ$IWO'#HYOOQ$IS,5:X,5:XO!*zQ$IWO,5:XO!+PQ$IWO'#H]O!+[Q$IWO'#H]O!+oQ$IWO,5=vOOQ$IS'#Dq'#DqOOQ$IS1G/u1G/uOOQ$IS1G.z1G.zO!,oQ$I[O1G.zO!,vQ$I[O1G.zO0dQ$IWO1G.zO!-cQ$IWO1G/SOOQ$IS'#DX'#DXO/jQ$IWO,59rOOQ$IS1G.y1G.yO!-jQ$IWO1G/cO!-zQ$IWO1G/cO!.SQ$IWO1G/dO'UQ$IWO'#HSO!.XQ$IWO'#HSO!.^Q$I[O1G.yO!.nQ$IWO,59gO!/tQ$IWO,5=rO!0UQ$IWO,5=rO!0^Q$IWO1G/kO!0cQ$I[O1G/kOOQ$IS1G/j1G/jO!0sQ$IWO,5=mO!1jQ$IWO,5=mO/jQ$IWO1G/oO!2XQ$IWO1G/qO!2^Q$I[O1G/qO!2nQ$I[O1G/oOOQ$IS1G/n1G/nOOQ$IS1G/p1G/pOOOO-E9n-E9nOOQ$IS1G/y1G/yOOOO-E9o-E9oO!3OQ$IWO'#HhO/jQ$IWO'#HhO!3^Q$IWO,5:aOOOO-E9p-E9pOOQ$IS1G/z1G/zOOOO-E9s-E9sOOOO-E9t-E9tOOOO-E9u-E9uOOQ$IS-E9v-E9vO!3iQ%GlO1G2rO!4YQ$I[O1G2rO'UQ$IWO,5<eOOQ$IS,5<e,5<eOOQ$IS-E9w-E9wOOQ$IS,5<l,5<lOOQ$IS-E:O-E:OOOQ$IV1G0o1G0oO0PQ$IWO'#F|O!4qQ$I[O,5>`OOQ$IS1G1V1G1VO!5YQ$IWO1G1VOOQ$IS'#DT'#DTO/jQ$IWO,5=iOOQ$IS,5=i,5=iO!5_Q$IWO'#FiO!5jQ$IWO,59mO!5rQ$IWO1G/VO!5|Q$I[O,5=mOOQ$IS1G3W1G3WOOQ$IS,5:h,5:hO!6mQ$IWO'#GlOOQ$IS,5<f,5<fOOQ$IS-E9x-E9xO!7OQ$IWO1G.fOOQ$IS1G0U1G0UO!7^Q$IWO,5=oO!7nQ$IWO,5=oO/jQ$IWO1G0eO/jQ$IWO1G0eO0PQ$IWO1G0gOOQ$IS-E9{-E9{O!8PQ$IWO1G0gO!8[Q$IWO1G0gO!8aQ$IWO,5>cO!8oQ$IWO,5>cO!8}Q$IWO,5>_O!9eQ$IWO,5>_O!9vQ$IZO1G0qO!=XQ$IZO1G0tO!@gQ$IWO,5>eO!@qQ$IWO,5>eO!@yQ$I[O,5>eO/jQ$IWO1G0vO!ATQ$IWO1G0vO3XQ$IWO1G0{ONtQ$IWO1G0}OOQ$IV,5;W,5;WO!AYQ$IYO,5;WO!A_Q$IZO1G0wO!DsQ$IWO'#GUO3XQ$IWO1G0wO3XQ$IWO1G0wO!EQQ$IWO,5>fO!E_Q$IWO,5>fO0PQ$IWO,5>fOOQ$IV1G0{1G0{O!EgQ$IWO'#EyO!ExQ%1`O1G0}OOQ$IV1G1S1G1SO3XQ$IWO1G1SO!FQQ$IWO'#FTOOQ$IV1G1X1G1XO! RQ$I[O1G1XOOQ$IS,5=u,5=uOOQ$IS'#Dn'#DnO/jQ$IWO,5=uO!FVQ$IWO,5=tO!FjQ$IWO,5=tOOQ$IS1G/s1G/sO!FrQ$IWO,5=wO!GSQ$IWO,5=wO!G[Q$IWO,5=wO!GoQ$IWO,5=wO!HPQ$IWO,5=wOOQ$IS1G3b1G3bOOQ$IS7+$f7+$fO!5rQ$IWO7+$nO!IrQ$IWO1G.zO!IyQ$IWO1G.zOOQ$IS1G/^1G/^OOQ$IS,5<V,5<VO'UQ$IWO,5<VOOQ$IS7+$}7+$}O!JQQ$IWO7+$}OOQ$IS-E9i-E9iOOQ$IS7+%O7+%OO!JbQ$IWO,5=nO'UQ$IWO,5=nOOQ$IS7+$e7+$eO!JgQ$IWO7+$}O!JoQ$IWO7+%OO!JtQ$IWO1G3^OOQ$IS7+%V7+%VO!KUQ$IWO1G3^O!K^Q$IWO7+%VOOQ$IS,5<U,5<UO'UQ$IWO,5<UO!KcQ$IWO1G3XOOQ$IS-E9h-E9hO!LYQ$IWO7+%ZOOQ$IS7+%]7+%]O!LhQ$IWO1G3XO!MVQ$IWO7+%]O!M[Q$IWO1G3_O!MlQ$IWO1G3_O!MtQ$IWO7+%ZO!MyQ$IWO,5>SO!NaQ$IWO,5>SO!NaQ$IWO,5>SO!NoO!LQO'#DwO!NzOSO'#HiOOOO1G/{1G/{O# PQ$IWO1G/{O# XQ%GlO7+(^O# xQ$I[O1G2PP#!cQ$IWO'#FyOOQ$IS,5<h,5<hOOQ$IS-E9z-E9zOOQ$IS7+&q7+&qOOQ$IS1G3T1G3TOOQ$IS,5<T,5<TOOQ$IS-E9g-E9gOOQ$IS7+$q7+$qO#!pQ$IWO,5=WO##ZQ$IWO,5=WO##lQ$I[O,5<WO#$PQ$IWO1G3ZOOQ$IS-E9j-E9jOOQ$IS7+&P7+&PO#$aQ$IWO7+&POOQ$IS7+&R7+&RO#$oQ$IWO'#HvO0PQ$IWO'#HuO#%TQ$IWO7+&ROOQ$IS,5<k,5<kO#%`Q$IWO1G3}OOQ$IS-E9}-E9}OOQ$IS,5<g,5<gO#%nQ$IWO1G3yOOQ$IS-E9y-E9yO#&UQ$IZO7+&]O!DsQ$IWO'#GSO3XQ$IWO7+&]O3XQ$IWO7+&`O#)gQ$I[O,5<oO'UQ$IWO,5<oO#)qQ$IWO1G4POOQ$IS-E:R-E:RO#){Q$IWO1G4PO3XQ$IWO7+&bO/jQ$IWO7+&bOOQ$IV7+&g7+&gO!ExQ%1`O7+&iO#*TQ$IXO1G0rOOQ$IV-E:S-E:SO3XQ$IWO7+&cO3XQ$IWO7+&cOOQ$IV,5<p,5<pO#+yQ$IWO,5<pOOQ$IV7+&c7+&cO#,UQ$IZO7+&cO#/dQ$IWO,5<qO#/oQ$IWO1G4QOOQ$IS-E:T-E:TO#/|Q$IWO1G4QO#0UQ$IWO'#H|O#0dQ$IWO'#H|O0PQ$IWO'#H|OOQ$IS'#H|'#H|O#0oQ$IWO'#H{OOQ$IS,5;e,5;eO#0wQ$IWO,5;eO/jQ$IWO'#E{OOQ$IV7+&i7+&iO3XQ$IWO7+&iOOQ$IV7+&n7+&nO#0|Q$IYO,5;oOOQ$IV7+&s7+&sOOQ$IS1G3a1G3aOOQ$IS,5<Y,5<YO#1RQ$IWO1G3`OOQ$IS-E9l-E9lO#1fQ$IWO,5<ZO#1qQ$IWO,5<ZO#2UQ$IWO1G3cOOQ$IS-E9m-E9mO#2fQ$IWO1G3cO#2nQ$IWO1G3cO#3OQ$IWO1G3cO#2fQ$IWO1G3cOOQ$IS<<HY<<HYO#3ZQ$I[O1G1qOOQ$IS<<Hi<<HiP#3hQ$IWO'#FkO7WQ$IWO1G3YO#3uQ$IWO1G3YO#3zQ$IWO<<HiOOQ$IS<<Hj<<HjO#4[Q$IWO7+(xOOQ$IS<<Hq<<HqO#4lQ$I[O1G1pP#5]Q$IWO'#FjO#5jQ$IWO7+(yO#5zQ$IWO7+(yO#6SQ$IWO<<HuO#6XQ$IWO7+(sOOQ$IS<<Hw<<HwO#7OQ$IWO,5<XO'UQ$IWO,5<XOOQ$IS-E9k-E9kOOQ$IS<<Hu<<HuOOQ$IS,5<_,5<_O/jQ$IWO,5<_O#7TQ$IWO1G3nOOQ$IS-E9q-E9qO#7kQ$IWO1G3nOOOO'#Ft'#FtO#7yO!LQO,5:cOOOO,5>T,5>TOOOO7+%g7+%gO#8UQ$IWO1G2rO#8oQ$IWO1G2rP'UQ$IWO'#FlO/jQ$IWO<<IkO#9QQ$IWO,5>bO#9cQ$IWO,5>bO0PQ$IWO,5>bO#9tQ$IWO,5>aOOQ$IS<<Im<<ImP0PQ$IWO'#GPP/jQ$IWO'#F{OOQ$IV-E:Q-E:QO3XQ$IWO<<IwOOQ$IV,5<n,5<nO3XQ$IWO,5<nOOQ$IV<<Iw<<IwOOQ$IV<<Iz<<IzO#9yQ$I[O1G2ZP#:TQ$IWO'#GTO#:[Q$IWO7+)kO#:fQ$IZO<<I|O3XQ$IWO<<I|OOQ$IV<<JT<<JTO3XQ$IWO<<JTOOQ$IV'#GR'#GRO#=tQ$IZO7+&^OOQ$IV<<I}<<I}O#?pQ$IZO<<I}OOQ$IV1G2[1G2[O0PQ$IWO1G2[O3XQ$IWO<<I}O0PQ$IWO1G2]P/jQ$IWO'#GVO#COQ$IWO7+)lO#C]Q$IWO7+)lOOQ$IS'#Ez'#EzO/jQ$IWO,5>hO#CeQ$IWO,5>hOOQ$IS,5>h,5>hO#CpQ$IWO,5>gO#DRQ$IWO,5>gOOQ$IS1G1P1G1POOQ$IS,5;g,5;gO#DZQ$IWO1G1ZP#D`Q$IWO'#FnO#DpQ$IWO1G1uO#ETQ$IWO1G1uO#EeQ$IWO1G1uP#EpQ$IWO'#FoO#E}Q$IWO7+(}O#F_Q$IWO7+(}O#F_Q$IWO7+(}O#FgQ$IWO7+(}O#FwQ$IWO7+(tO7WQ$IWO7+(tOOQ$ISAN>TAN>TO#GbQ$IWO<<LeOOQ$ISAN>aAN>aO/jQ$IWO1G1sO#GrQ$I[O1G1sP#G|Q$IWO'#FmOOQ$IS1G1y1G1yP#HZQ$IWO'#FsO#HhQ$IWO7+)YOOOO-E9r-E9rO#IOQ$IWO7+(^OOQ$ISAN?VAN?VO#IiQ$IWO,5<jO#I}Q$IWO1G3|OOQ$IS-E9|-E9|O#J`Q$IWO1G3|OOQ$IS1G3{1G3{OOQ$IVAN?cAN?cOOQ$IV1G2Y1G2YO3XQ$IWOAN?hO#JqQ$IZOAN?hOOQ$IVAN?oAN?oOOQ$IV-E:P-E:POOQ$IV<<Ix<<IxO3XQ$IWOAN?iO3XQ$IWO7+'vOOQ$IVAN?iAN?iOOQ$IS7+'w7+'wO#NPQ$IWO<<MWOOQ$IS1G4S1G4SO/jQ$IWO1G4SOOQ$IS,5<r,5<rO#N^Q$IWO1G4ROOQ$IS-E:U-E:UOOQ$IU'#GY'#GYO#NoQ$IYO7+&uO#NzQ$IWO'#FUO$ rQ$IWO7+'aO$!SQ$IWO7+'aOOQ$IS7+'a7+'aO$!_Q$IWO<<LiO$!oQ$IWO<<LiO$!oQ$IWO<<LiO$!wQ$IWO'#HUOOQ$IS<<L`<<L`O$#RQ$IWO<<L`OOQ$IS7+'_7+'_O0PQ$IWO1G2UP0PQ$IWO'#GOO$#lQ$IWO7+)hO$#}Q$IWO7+)hOOQ$IVG25SG25SO3XQ$IWOG25SOOQ$IVG25TG25TOOQ$IV<<Kb<<KbOOQ$IS7+)n7+)nP$$`Q$IWO'#GWOOQ$IU-E:W-E:WOOQ$IV<<Ja<<JaO$%SQ$I[O'#FWOOQ$IS'#FY'#FYO$%dQ$IWO'#FXO$&UQ$IWO'#FXOOQ$IS'#FX'#FXO$&ZQ$IWO'#IOO#NzQ$IWO'#F`O#NzQ$IWO'#F`O$&rQ$IWO'#FaO#NzQ$IWO'#FbO$&yQ$IWO'#IPOOQ$IS'#IP'#IPO$'hQ$IWO,5;pOOQ$IS<<J{<<J{O$'pQ$IWO<<J{O$(QQ$IWOANBTO$(bQ$IWOANBTO$(jQ$IWO'#HVOOQ$IS'#HV'#HVO0kQ$IWO'#DaO$)TQ$IWO,5=pOOQ$ISANAzANAzOOQ$IS7+'p7+'pO$)lQ$IWO<<MSOOQ$IVLD*nLD*nO4VQ%1`O'#G[O$)}Q$I[O,5;yO#NzQ$IWO'#FdOOQ$IS,5;},5;}OOQ$IS'#FZ'#FZO$*oQ$IWO,5;sO$*tQ$IWO,5;sOOQ$IS'#F^'#F^O#NzQ$IWO'#GZO$+fQ$IWO,5;wO$,QQ$IWO,5>jO$,bQ$IWO,5>jO0PQ$IWO,5;vO$,sQ$IWO,5;zO$,xQ$IWO,5;zO#NzQ$IWO'#IQO$,}Q$IWO'#IQO$-SQ$IWO,5;{OOQ$IS,5;|,5;|O'UQ$IWO'#FgOOQ$IU1G1[1G1[O3XQ$IWO1G1[OOQ$ISAN@gAN@gO$-XQ$IWOG27oO$-iQ$IWO,59{OOQ$IS1G3[1G3[OOQ$IS,5<v,5<vOOQ$IS-E:Y-E:YO$-nQ$I[O'#FWO$-uQ$IWO'#IRO$.TQ$IWO'#IRO$.]Q$IWO,5<OOOQ$IS1G1_1G1_O$.bQ$IWO1G1_O$.gQ$IWO,5<uOOQ$IS-E:X-E:XO$/RQ$IWO,5<yO$/jQ$IWO1G4UOOQ$IS-E:]-E:]OOQ$IS1G1b1G1bOOQ$IS1G1f1G1fO$/zQ$IWO,5>lO#NzQ$IWO,5>lOOQ$IS1G1g1G1gO$0YQ$I[O,5<ROOQ$IU7+&v7+&vO$!wQ$IWO1G/gO#NzQ$IWO,5<PO$0aQ$IWO,5>mO$0hQ$IWO,5>mOOQ$IS1G1j1G1jOOQ$IS7+&y7+&yP#NzQ$IWO'#G_O$0pQ$IWO1G4WO$0zQ$IWO1G4WO$1SQ$IWO1G4WOOQ$IS7+%R7+%RO$1bQ$IWO1G1kO$1pQ$I[O'#FWO$1wQ$IWO,5<xOOQ$IS,5<x,5<xO$2VQ$IWO1G4XOOQ$IS-E:[-E:[O#NzQ$IWO,5<wO$2^Q$IWO,5<wO$2cQ$IWO7+)rOOQ$IS-E:Z-E:ZO$2mQ$IWO7+)rO#NzQ$IWO,5<QP#NzQ$IWO'#G^O$2uQ$IWO1G2cO#NzQ$IWO1G2cP$3TQ$IWO'#G]O$3[Q$IWO<<M^O$3fQ$IWO1G1lO$3tQ$IWO7+'}O7WQ$IWO'#C{O7WQ$IWO,59`O7WQ$IWO,59`O7WQ$IWO,59`O$4SQ$I[O,5=WO7WQ$IWO1G.zO/jQ$IWO1G/VO/jQ$IWO7+$nP$4gQ$IWO'#FyO'UQ$IWO'#GlO$4tQ$IWO,59`O$4yQ$IWO,59`O$5QQ$IWO,59kO$5VQ$IWO1G/SO0kQ$IWO'#DPO7WQ$IWO,59h",
        stateData: "$5m~O%[OS%XOS%WOSQOS~OPhOTeOdsOfXOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!VYO!ZZO!fdO!mdO!ndO!odO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O%VqO%gQO%hQO%lRO%mVO&R[O&S]O&V^O&Y_O&``O&caO&ebO~OT!bO]!bO_!cOf!jO!V!lO!d!nO%b!]O%c!^O%d!_O%e!`O%f!`O%g!aO%h!aO%i!bO%j!bO%k!bO~Oi%pXj%pXk%pXl%pXm%pXn%pXq%pXx%pXy%pX!s%pX#^%pX%V%pX%Y%pX%r%pXe%pX!R%pX!S%pX%s%pX!U%pX!Y%pX!O%pX#V%pXr%pX!j%pX~P$bOdsOfXO!VYO!ZZO!fdO!mdO!ndO!odO%gQO%hQO%lRO%mVO&R[O&S]O&V^O&Y_O&``O&caO&ebO~Ox%oXy%oX#^%oX%V%oX%Y%oX%r%oX~Oi!qOj!rOk!pOl!pOm!sOn!tOq!uO!s%oX~P(cOT!{Om/iOt/wO}vO~P'UOT#OOm/iOt/wO!U#PO~P'UOT#SO_#TOm/iOt/wO!Y#UO~P'UO&T#XO&U#ZO~O&W#[O&X#ZO~O!Z#^O&Z#_O&_#aO~O!Z#^O&a#bO&b#aO~O!Z#^O&U#aO&d#dO~O!Z#^O&X#aO&f#fO~OT%aX]%aX_%aXf%aXi%aXj%aXk%aXl%aXm%aXn%aXq%aXx%aX!V%aX!d%aX%b%aX%c%aX%d%aX%e%aX%f%aX%g%aX%h%aX%i%aX%j%aX%k%aXe%aX!R%aX!S%aX~O&R[O&S]O&V^O&Y_O&``O&caO&ebOy%aX!s%aX#^%aX%V%aX%Y%aX%r%aX%s%aX!U%aX!Y%aX!O%aX#V%aXr%aX!j%aX~P+xOx#kOy%`X!s%`X#^%`X%V%`X%Y%`X%r%`X~Om/iOt/wO~P'UO#^#nO%V#pO%Y#pO~O%mVO~O!R#uO#l!YO#q!ZO#tlO~OmtO~P'UOT#zO_#{O%mVOyuP~OT$POm/iOt/wO!O$QO~P'UOy$SO!s$XO%r$TO#^!tX%V!tX%Y!tX~OT$POm/iOt/wO#^!}X%V!}X%Y!}X~P'UOm/iOt/wO#^#RX%V#RX%Y#RX~P'UO!d$_O!m$_O%mVO~OT$iO~P'UO!S$kO#j$lO#l$mO~Oy$nO~OT$uO~P'UOT%OO_%OOe%QOm/iOt/wO~P'UOm/iOt/wOy%TO~P'UO&Q%VO~O_!cOf!jO!V!lO!d!nOT`a]`ai`aj`ak`al`am`an`aq`ax`ay`a!s`a#^`a%V`a%Y`a%b`a%c`a%d`a%e`a%f`a%g`a%h`a%i`a%j`a%k`a%r`ae`a!R`a!S`a%s`a!U`a!Y`a!O`a#V`ar`a!j`a~Ol%[O~Om%[O~P'UOm/iO~P'UOi/kOj/lOk/jOl/jOm/sOn/tOq/xOe%oX!R%oX!S%oX%s%oX!U%oX!Y%oX!O%oX#V%oX!j%oX~P(cO%s%^Oe%nXx%nX!R%nX!S%nX!U%nXy%nX~Oe%`Ox%aO!R%eO!S%dO~Oe%`O~Ox%hO!R%eO!S%dO!U%zX~O!U%lO~Ox%mOy%oO!R%eO!S%dO!Y%uX~O!Y%sO~O!Y%tO~O&T#XO&U%vO~O&W#[O&X%vO~OT%yOm/iOt/wO}vO~P'UO!Z#^O&Z#_O&_%|O~O!Z#^O&a#bO&b%|O~O!Z#^O&U%|O&d#dO~O!Z#^O&X%|O&f#fO~OT!la]!la_!laf!lai!laj!lak!lal!lam!lan!laq!lax!lay!la!V!la!d!la!s!la#^!la%V!la%Y!la%b!la%c!la%d!la%e!la%f!la%g!la%h!la%i!la%j!la%k!la%r!lae!la!R!la!S!la%s!la!U!la!Y!la!O!la#V!lar!la!j!la~P#yOx&ROy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~P$bOT&TOmtOtuOy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~P'UOx&ROy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#^$tX%V$tX%Y$tX~P'UO#^#nO%V&YO%Y&YO~O!d&ZOf&hX%V&hX#V&hX#^&hX%Y&hX#U&hX~Of!jO%V&]O~Oicajcakcalcamcancaqcaxcayca!sca#^ca%Vca%Yca%rcaeca!Rca!Sca%sca!Uca!Yca!Oca#Vcarca!jca~P$bOqoaxoayoa#^oa%Voa%Yoa%roa~Oi!qOj!rOk!pOl!pOm!sOn!tO!soa~PD_O%r&_Ox%qXy%qX~O%mVOx%qXy%qX~Ox&bOyuX~Oy&dO~Ox%mO#^%uX%V%uX%Y%uXe%uXy%uX!Y%uX!j%uX%r%uX~OT/rOm/iOt/wO}vO~P'UO%r$TO#^Sa%VSa%YSa~Ox&mO#^%wX%V%wX%Y%wXl%wX~P$bOx&pO!O&oO#^#Ra%V#Ra%Y#Ra~O#V&qO#^#Ta%V#Ta%Y#Ta~O!d$_O!m$_O#U&sO%mVO~O#U&sO~Ox&uO#^&kX%V&kX%Y&kX~Ox&wO#^&gX%V&gX%Y&gXy&gX~Ox&{Ol&mX~P$bOl'OO~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO%V'TO~P'UOr'XO#g'VO#h'WOP#eaT#ead#eaf#eam#eaq#eat#ea}#ea!O#ea!R#ea!S#ea!V#ea!Z#ea!f#ea!m#ea!n#ea!o#ea!v#ea!x#ea!z#ea!|#ea#O#ea#S#ea#U#ea#X#ea#Y#ea#[#ea#c#ea#f#ea#j#ea#l#ea#q#ea#t#ea#v#ea%S#ea%V#ea%g#ea%h#ea%l#ea%m#ea&R#ea&S#ea&V#ea&Y#ea&`#ea&c#ea&e#ea%U#ea%Y#ea~Ox'YO#V'[Oy&nX~Of'^O~Of!jOy$nO~Oy'bO~P$bOT!bO]!bO_!cOf!jO!V!lO!d!nO%d!_O%e!`O%f!`O%g!aO%h!aO%i!bO%j!bO%k!bOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~O%c!^O~P! YO%cUi~P! YOT!bO]!bO_!cOf!jO!V!lO!d!nO%g!aO%h!aO%i!bO%j!bO%k!bOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%cUi%dUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~O%e!`O%f!`O~P!$TO%eUi%fUi~P!$TO_!cOf!jO!V!lO!d!nOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%cUi%dUi%eUi%fUi%gUi%hUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~OT!bO]!bO%i!bO%j!bO%k!bO~P!'ROTUi]Ui%iUi%jUi%kUi~P!'RO!R%eO!S%dOe%}Xx%}X~O%r'fO%s'fO~P+xOx'hOe%|X~Oe'jO~Ox'kOy'mO!U&PX~Om/iOt/wOx'kOy'nO!U&PX~P'UO!U'pO~Ok!pOl!pOm!sOn!tOihiqhixhiyhi!shi#^hi%Vhi%Yhi%rhi~Oj!rO~P!+tOjhi~P!+tOi/kOj/lOk/jOl/jOm/sOn/tO~Or'rO~P!,}OT'wOe'xOm/iOt/wO~P'UOe'xOx'yO~Oe'{O~O!S'}O~Oe(OOx'yO!R%eO!S%dO~P$bOi/kOj/lOk/jOl/jOm/sOn/tOeoa!Roa!Soa%soa!Uoa!Yoa!Ooa#Voaroa!joa~PD_OT'wOm/iOt/wO!U%za~P'UOx(RO!U%za~O!U(SO~Ox(RO!R%eO!S%dO!U%za~P$bOT(WOm/iOt/wO!Y%ua#^%ua%V%ua%Y%uae%uay%ua!j%ua%r%ua~P'UOx(XO!Y%ua#^%ua%V%ua%Y%uae%uay%ua!j%ua%r%ua~O!Y([O~Ox(XO!R%eO!S%dO!Y%ua~P$bOx(_O!R%eO!S%dO!Y%{a~P$bOx(bOy&[X!Y&[X!j&[X~Oy(eO!Y(gO!j(hO~OT&TOmtOtuOy%`i!s%`i#^%`i%V%`i%Y%`i%r%`i~P'UOx(iOy%`i!s%`i#^%`i%V%`i%Y%`i%r%`i~O!d&ZOf&ha%V&ha#V&ha#^&ha%Y&ha#U&ha~O%V(nO~OT#zO_#{O%mVO~Ox&bOyua~OmtOtuO~P'UOx(XO#^%ua%V%ua%Y%uae%uay%ua!Y%ua!j%ua%r%ua~P$bOx(sO#^%`X%V%`X%Y%`X%r%`X~O%r$TO#^Si%VSi%YSi~O#^%wa%V%wa%Y%wal%wa~P'UOx(vO#^%wa%V%wa%Y%wal%wa~OT(zOf(|O%mVO~O#U(}O~O%mVO#^&ka%V&ka%Y&ka~Ox)PO#^&ka%V&ka%Y&ka~Om/iOt/wO#^&ga%V&ga%Y&gay&ga~P'UOx)SO#^&ga%V&ga%Y&gay&ga~Or)WO#a)VOP#_iT#_id#_if#_im#_iq#_it#_i}#_i!O#_i!R#_i!S#_i!V#_i!Z#_i!f#_i!m#_i!n#_i!o#_i!v#_i!x#_i!z#_i!|#_i#O#_i#S#_i#U#_i#X#_i#Y#_i#[#_i#c#_i#f#_i#j#_i#l#_i#q#_i#t#_i#v#_i%S#_i%V#_i%g#_i%h#_i%l#_i%m#_i&R#_i&S#_i&V#_i&Y#_i&`#_i&c#_i&e#_i%U#_i%Y#_i~Or)XOP#biT#bid#bif#bim#biq#bit#bi}#bi!O#bi!R#bi!S#bi!V#bi!Z#bi!f#bi!m#bi!n#bi!o#bi!v#bi!x#bi!z#bi!|#bi#O#bi#S#bi#U#bi#X#bi#Y#bi#[#bi#c#bi#f#bi#j#bi#l#bi#q#bi#t#bi#v#bi%S#bi%V#bi%g#bi%h#bi%l#bi%m#bi&R#bi&S#bi&V#bi&Y#bi&`#bi&c#bi&e#bi%U#bi%Y#bi~OT)ZOl&ma~P'UOx)[Ol&ma~Ox)[Ol&ma~P$bOl)`O~O%T)cO~Or)fO#g'VO#h)eOP#eiT#eid#eif#eim#eiq#eit#ei}#ei!O#ei!R#ei!S#ei!V#ei!Z#ei!f#ei!m#ei!n#ei!o#ei!v#ei!x#ei!z#ei!|#ei#O#ei#S#ei#U#ei#X#ei#Y#ei#[#ei#c#ei#f#ei#j#ei#l#ei#q#ei#t#ei#v#ei%S#ei%V#ei%g#ei%h#ei%l#ei%m#ei&R#ei&S#ei&V#ei&Y#ei&`#ei&c#ei&e#ei%U#ei%Y#ei~Om/iOt/wOy$nO~P'UOm/iOt/wOy&na~P'UOx)lOy&na~OT)pO_)qOe)tO%i)rO%mVO~Oy$nO&q)vO~O%V)zO~OT%OO_%OOm/iOt/wOe%|a~P'UOx*OOe%|a~Om/iOt/wOy*RO!U&Pa~P'UOx*SO!U&Pa~Om/iOt/wOx*SOy*VO!U&Pa~P'UOm/iOt/wOx*SO!U&Pa~P'UOx*SOy*VO!U&Pa~Ok/jOl/jOm/sOn/tOehiihiqhixhi!Rhi!Shi%shi!Uhiyhi!Yhi#^hi%Vhi%Yhi!Ohi#Vhirhi!jhi%rhi~Oj/lO~P!H[Ojhi~P!H[OT'wOe*[Om/iOt/wO~P'UOl*^O~Oe*[Ox*`O~Oe*aO~OT'wOm/iOt/wO!U%zi~P'UOx*bO!U%zi~O!U*cO~OT(WOm/iOt/wO!Y%ui#^%ui%V%ui%Y%uie%uiy%ui!j%ui%r%ui~P'UOx*fO!R%eO!S%dO!Y%{i~Ox*iO!Y%ui#^%ui%V%ui%Y%uie%uiy%ui!j%ui%r%ui~O!Y*jO~O_*lOm/iOt/wO!Y%{i~P'UOx*fO!Y%{i~O!Y*nO~OT*pOm/iOt/wOy&[a!Y&[a!j&[a~P'UOx*qOy&[a!Y&[a!j&[a~O!Z#^O&^*tO!Y!kX~O!Y*vO~Oy(eO!Y*wO~OT&TOmtOtuOy%`q!s%`q#^%`q%V%`q%Y%`q%r%`q~P'UOx$miy$mi!s$mi#^$mi%V$mi%Y$mi%r$mi~P$bOT&TOmtOtuO~P'UOT&TOm/iOt/wO#^%`a%V%`a%Y%`a%r%`a~P'UOx*xO#^%`a%V%`a%Y%`a%r%`a~Ox$`a#^$`a%V$`a%Y$`al$`a~P$bO#^%wi%V%wi%Y%wil%wi~P'UOx*{O#^#Rq%V#Rq%Y#Rq~Ox*|O#V+OO#^&jX%V&jX%Y&jXe&jX~OT+QOf(|O%mVO~O%mVO#^&ki%V&ki%Y&ki~Om/iOt/wO#^&gi%V&gi%Y&giy&gi~P'UOr+UO#a)VOP#_qT#_qd#_qf#_qm#_qq#_qt#_q}#_q!O#_q!R#_q!S#_q!V#_q!Z#_q!f#_q!m#_q!n#_q!o#_q!v#_q!x#_q!z#_q!|#_q#O#_q#S#_q#U#_q#X#_q#Y#_q#[#_q#c#_q#f#_q#j#_q#l#_q#q#_q#t#_q#v#_q%S#_q%V#_q%g#_q%h#_q%l#_q%m#_q&R#_q&S#_q&V#_q&Y#_q&`#_q&c#_q&e#_q%U#_q%Y#_q~Ol$wax$wa~P$bOT)ZOl&mi~P'UOx+]Ol&mi~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O~P'UOx+gOy$nO#V+gO~O#h+hOP#eqT#eqd#eqf#eqm#eqq#eqt#eq}#eq!O#eq!R#eq!S#eq!V#eq!Z#eq!f#eq!m#eq!n#eq!o#eq!v#eq!x#eq!z#eq!|#eq#O#eq#S#eq#U#eq#X#eq#Y#eq#[#eq#c#eq#f#eq#j#eq#l#eq#q#eq#t#eq#v#eq%S#eq%V#eq%g#eq%h#eq%l#eq%m#eq&R#eq&S#eq&V#eq&Y#eq&`#eq&c#eq&e#eq%U#eq%Y#eq~O#V+iOx$yay$ya~Om/iOt/wOy&ni~P'UOx+kOy&ni~Oy$SO%r+mOe&pXx&pX~O%mVOe&pXx&pX~Ox+qOe&oX~Oe+sO~O%T+uO~OT%OO_%OOm/iOt/wOe%|i~P'UOy+wOx$ca!U$ca~Om/iOt/wOy+xOx$ca!U$ca~P'UOm/iOt/wOy*RO!U&Pi~P'UOx+{O!U&Pi~Om/iOt/wOx+{O!U&Pi~P'UOx+{Oy,OO!U&Pi~Oe$_ix$_i!U$_i~P$bOT'wOm/iOt/wO~P'UOl,QO~OT'wOe,ROm/iOt/wO~P'UOT'wOm/iOt/wO!U%zq~P'UOx$^i!Y$^i#^$^i%V$^i%Y$^ie$^iy$^i!j$^i%r$^i~P$bOT(WOm/iOt/wO~P'UO_*lOm/iOt/wO!Y%{q~P'UOx,SO!Y%{q~O!Y,TO~OT(WOm/iOt/wO!Y%uq#^%uq%V%uq%Y%uqe%uqy%uq!j%uq%r%uq~P'UOy,UO~OT*pOm/iOt/wOy&[i!Y&[i!j&[i~P'UOx,ZOy&[i!Y&[i!j&[i~O!Z#^O&^*tO!Y!ka~OT&TOm/iOt/wO#^%`i%V%`i%Y%`i%r%`i~P'UOx,]O#^%`i%V%`i%Y%`i%r%`i~O%mVO#^&ja%V&ja%Y&jae&ja~Ox,`O#^&ja%V&ja%Y&jae&ja~Oe,cO~Ol$wix$wi~P$bOT)ZO~P'UOT)ZOl&mq~P'UOr,fOP#dyT#dyd#dyf#dym#dyq#dyt#dy}#dy!O#dy!R#dy!S#dy!V#dy!Z#dy!f#dy!m#dy!n#dy!o#dy!v#dy!x#dy!z#dy!|#dy#O#dy#S#dy#U#dy#X#dy#Y#dy#[#dy#c#dy#f#dy#j#dy#l#dy#q#dy#t#dy#v#dy%S#dy%V#dy%g#dy%h#dy%l#dy%m#dy&R#dy&S#dy&V#dy&Y#dy&`#dy&c#dy&e#dy%U#dy%Y#dy~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O%U,jO%Y,jO~P'UO#h,kOP#eyT#eyd#eyf#eym#eyq#eyt#ey}#ey!O#ey!R#ey!S#ey!V#ey!Z#ey!f#ey!m#ey!n#ey!o#ey!v#ey!x#ey!z#ey!|#ey#O#ey#S#ey#U#ey#X#ey#Y#ey#[#ey#c#ey#f#ey#j#ey#l#ey#q#ey#t#ey#v#ey%S#ey%V#ey%g#ey%h#ey%l#ey%m#ey&R#ey&S#ey&V#ey&Y#ey&`#ey&c#ey&e#ey%U#ey%Y#ey~Om/iOt/wOy&nq~P'UOx,oOy&nq~O%r+mOe&pax&pa~OT)pO_)qO%i)rO%mVOe&oa~Ox,sOe&oa~O#y,wO~OT%OO_%OOm/iOt/wO~P'UOm/iOt/wOy,xOx$ci!U$ci~P'UOm/iOt/wOx$ci!U$ci~P'UOy,xOx$ci!U$ci~Om/iOt/wOy*RO~P'UOm/iOt/wOy*RO!U&Pq~P'UOx,{O!U&Pq~Om/iOt/wOx,{O!U&Pq~P'UOq-OO!R%eO!S%dOe%vq!U%vq!Y%vqx%vq~P!,}O_*lOm/iOt/wO!Y%{y~P'UOx$ai!Y$ai~P$bO_*lOm/iOt/wO~P'UOT*pOm/iOt/wO~P'UOT*pOm/iOt/wOy&[q!Y&[q!j&[q~P'UOT&TOm/iOt/wO#^%`q%V%`q%Y%`q%r%`q~P'UO#V-SOx$ra#^$ra%V$ra%Y$rae$ra~O%mVO#^&ji%V&ji%Y&jie&ji~Ox-UO#^&ji%V&ji%Y&jie&ji~Or-XOP#d!RT#d!Rd#d!Rf#d!Rm#d!Rq#d!Rt#d!R}#d!R!O#d!R!R#d!R!S#d!R!V#d!R!Z#d!R!f#d!R!m#d!R!n#d!R!o#d!R!v#d!R!x#d!R!z#d!R!|#d!R#O#d!R#S#d!R#U#d!R#X#d!R#Y#d!R#[#d!R#c#d!R#f#d!R#j#d!R#l#d!R#q#d!R#t#d!R#v#d!R%S#d!R%V#d!R%g#d!R%h#d!R%l#d!R%m#d!R&R#d!R&S#d!R&V#d!R&Y#d!R&`#d!R&c#d!R&e#d!R%U#d!R%Y#d!R~Om/iOt/wOy&ny~P'UOT)pO_)qO%i)rO%mVOe&oi~O#y,wO%U-_O%Y-_O~OT-iOf-gO!V-fO!Z-hO!f-bO!n-dO!o-dO%h-aO%mVO&R[O&S]O&V^O~Om/iOt/wOx$cq!U$cq~P'UOy-nOx$cq!U$cq~Om/iOt/wOy*RO!U&Py~P'UOx-oO!U&Py~Om/iOt-sO~P'UOq-OO!R%eO!S%dOe%vy!U%vy!Y%vyx%vy~P!,}O%mVO#^&jq%V&jq%Y&jqe&jq~Ox-wO#^&jq%V&jq%Y&jqe&jq~OT)pO_)qO%i)rO%mVO~Of-{O!d-yOx#zX#V#zX%b#zXe#zX~Oq#zXy#zX!U#zX!Y#zX~P$$nO%g-}O%h-}Oq#{Xx#{Xy#{X#V#{X%b#{X!U#{Xe#{X!Y#{X~O!f.PO~Ox.TO#V.VO%b.QOq&rXy&rX!U&rXe&rX~O_.YO~P$ WOf-{Oq&sXx&sXy&sX#V&sX%b&sX!U&sXe&sX!Y&sX~Oq.^Oy$nO~Om/iOt/wOx$cy!U$cy~P'UOm/iOt/wOy*RO!U&P!R~P'UOx.bO!U&P!R~Oe%yXq%yX!R%yX!S%yX!U%yX!Y%yXx%yX~P!,}Oq-OO!R%eO!S%dOe%xa!U%xa!Y%xax%xa~O%mVO#^&jy%V&jy%Y&jye&jy~O!d-yOf$Raq$Rax$Ray$Ra#V$Ra%b$Ra!U$Rae$Ra!Y$Ra~O!f.kO~O%g-}O%h-}Oq#{ax#{ay#{a#V#{a%b#{a!U#{ae#{a!Y#{a~O%b.QOq$Pax$Pay$Pa#V$Pa!U$Pae$Pa!Y$Pa~Oq&ray&ra!U&rae&ra~P#NzOx.pOq&ray&ra!U&rae&ra~O!U.sO~Oe.sO~Oy.uO~O!Y.vO~Om/iOt/wOy*RO!U&P!Z~P'UOy.yO~O%r.zO~P$$nOx.{O#V.VO%b.QOe&uX~Ox.{Oe&uX~Oe.}O~O!f/OO~O#V.VOq$}ax$}ay$}a%b$}a!U$}ae$}a!Y$}a~O#V.VO%b.QOq%Rax%Ray%Ra!U%Rae%Ra~Oq&riy&ri!U&rie&ri~P#NzOx/QO#V.VO%b.QO!Y&ta~Oy$Za~P$bOe&ua~P#NzOx/YOe&ua~O_/[O!Y&ti~P$ WOx/^O!Y&ti~Ox/^O#V.VO%b.QO!Y&ti~O#V.VO%b.QOe$Xix$Xi~O%r/aO~P$$nO#V.VO%b.QOe%Qax%Qa~Oe&ui~P#NzOy/dO~O_/[O!Y&tq~P$ WOx/fO!Y&tq~O#V.VO%b.QOx%Pi!Y%Pi~O_/[O~P$ WO_/[O!Y&ty~P$ WO#V.VO%b.QOe$Yix$Yi~O#V.VO%b.QOx%Pq!Y%Pq~Ox*xO#^%`a%V%`a%Y%`a%r%`a~P$bOT&TOm/iOt/wO~P'UOl/nO~Om/nO~P'UOy/oO~Or/pO~P!,}O&S&V&c&e&R!Z&Z&a&d&f&Y&`&Y%m~",
        goto: "!9p&vPPPP&wP'P*e*}+h,S,o-]P-zP'P.k.k'PPPP'P2PPPPPPP2P4oPP4oP6{7U=QPP=T=c=fPP'P'PPP=rPP'P'PPP'P'P'P'P'P=v>m'PP>pP>vByFcPFw'PPPPF{GR&wP&w&wP&wP&wP&wP&wP&w&w&wP&wPP&wPP&wPGXPG`GfPG`PG`G`PPPG`PIePInItIzIePG`JQPG`PJXJ_PJcJwKfLPJcJcLVLdJcJcJcJcLxMOMRMWMZMaMgMsNVN]NgNm! Z! a! g! m! w! }!!T!!Z!!a!!g!!y!#T!#Z!#a!#g!#q!#w!#}!$T!$Z!$e!$k!$u!${!%U!%[!%k!%s!%}!&UPPPPPPPPP!&[!&d!&m!&w!'SPPPPPPPPPPPP!+r!,[!0j!3vPP!4O!4^!4g!5]!5S!5f!5l!5o!5r!5u!5}!6nPPPPPPPPPP!6q!6tPPPPPPPPP!6z!7W!7d!7j!7s!7v!7|!8S!8Y!8]P!8e!8n!9j!9m]iOr#n$n)c+c'udOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/x}!dP#j#w$Y$h$t%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!P!eP#j#w$Y$h$t$v%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!R!fP#j#w$Y$h$t$v$w%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!T!gP#j#w$Y$h$t$v$w$x%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!V!hP#j#w$Y$h$t$v$w$x$y%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!X!iP#j#w$Y$h$t$v$w$x$y$z%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!]!iP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m'uSOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/x&ZUOXYZhrtv|}!R!S!T!X!j!l!p!q!r!t!u#^#k#n$Q$S$U$X$l$n%O%T%[%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.b.y/i/j/k/l/n/o/p/q/t/x%eWOXYZhrv|}!R!S!T!X!j!l#^#k#n$Q$S$U$X$l$n%O%T%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,S,U,W,Y,Z,],o,q,x,{-n-o.b/o/p/qQ#}uQ.c-sR/u/w'ldOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xW#ql!O!P$`W#yu&b-s/wQ$b!QQ$r!YQ$s!ZW$}!j'h*O+vS&a#z#{Q'R$mQ(l&ZQ(z&qU({&s(|(}U)O&u)P+RQ)n'[W)o'^+q,s-]S+p)p)qY,_*|,`-T-U-wQ,b+OQ,l+gQ,n+il-`,w-f-g-i.R.T.Y.p.u.z/P/[/a/dQ-v-SQ.Z-hQ.g-{Q.r.VU/V.{/Y/bX/]/Q/^/e/fR&`#yi!xXY!S!T%a%h'y(R)V*]*`*bR%_!wQ!|XQ%z#^Q&i$UR&l$XT-r-O.y![!kP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/mQ&^#rR'a$sR'g$}Q%W!nR.e-y'tcOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xS#hc#i!P-d,w-f-g-h-i-{.R.T.Y.p.u.z.{/P/Q/Y/[/^/a/b/d/e/f'tcOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xT#hc#iS#__#`S#b`#cS#da#eS#fb#gT*t(e*uT(f%z(hQ$WwR+o)oX$Uw$V$W&kZkOr$n)c+cXoOr)c+cQ$o!WQ&y$fQ&z$gQ']$qQ'`$sQ)a'QQ)g'VQ)i'WQ)j'XQ)w'_Q)y'aQ+V)VQ+X)WQ+Y)XQ+^)_S+`)b)xQ+d)eQ+e)fQ+f)hQ,d+UQ,e+WQ,g+_Q,h+aQ,m+hQ-W,fQ-Y,kQ-Z,lQ-x-XQ._-lR.x.`WoOr)c+cR#tnQ'_$rR)b'RQ+n)oR,q+oQ)x'_R+a)bZmOnr)c+cQ'c$tR){'dT,u+u,vu-k,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dt-k,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dQ.Z-hX/]/Q/^/e/f!P-c,w-f-g-h-i-{.R.T.Y.p.u.z.{/P/Q/Y/[/^/a/b/d/e/fQ.O-bR.l.Pg.R-e.S.h.o.t/S/U/W/c/g/hu-j,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dX-|-`-j.g/VR.i-{V/X.{/Y/bR.`-lQrOR#vrQ&c#|R(q&cS%n#R$OS(Y%n(]T(]%q&eQ%b!zQ%i!}W'z%b%i(P(TQ(P%fR(T%kQ&n$YR(w&nQ(`%rQ*g(ZT*m(`*gQ'i%PR*P'iS'l%S%TY*T'l*U+|,|-pU*U'm'n'oU+|*V*W*XS,|+},OR-p,}Q#Y]R%u#YQ#]^R%w#]Q#`_R%{#`Q(c%xS*r(c*sR*s(dQ*u(eR,[*uQ#c`R%}#cQ#eaR&O#eQ#gbR&P#gQ#icR&Q#iQ#lfQ&S#jW&V#l&S(t*yQ(t&hR*y/mQ$VwS&j$V&kR&k$WQ&x$dR)T&xQ&[#qR(m&[Q$`!PR&r$`Q*}({S,a*}-VR-V,bQ&v$bR)Q&vQ#ojR&X#oQ+c)cR,i+cQ)U&yR+T)UQ&|$hS)]&|)^R)^&}Q'U$oR)d'UQ'Z$pS)m'Z+lR+l)nQ+r)sR,t+rWnOr)c+cR#snQ,v+uR-^,vd.S-e.h.o.t/S/U/W/c/g/hR.n.SU-z-`.g/VR.f-zQ/R.tS/_/R/`R/`/SS.|.h.iR/Z.|Q.U-eR.q.USqOrT+b)c+cWpOr)c+cR'S$nYjOr$n)c+cR&W#n[wOr#n$n)c+cR&i$U&YPOXYZhrtv|}!R!S!T!X!j!l!p!q!r!t!u#^#k#n$Q$S$U$X$l$n%O%T%[%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.b.y/i/j/k/l/n/o/p/q/t/xQ!oSQ#jeQ#wsU$Yx%d'}S$h!U$kQ$t![Q$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ${!iQ%f!{Q%k#OQ%q#SQ%r#TQ&e$PQ&}$iQ'd$uQ(j&TU(u&m(v*zW)Y&{)[+[+]Q*Z'wQ*d(WQ+Z)ZQ,V*lQ.w.^R/m/rQ!zXQ!}YQ$f!SQ$g!T^'v%a%h'y(R*]*`*bR+W)V[fOr#n$n)c+ch!wXY!S!T%a%h'y(R)V*]*`*bQ#RZQ#mhS$Ov|Q$]}W$d!R$X'O)`S$p!X$lW$|!j'h*O+vQ%S!lQ%x#^`&U#k&R(i(k(s*x,]/qQ&f$QQ&g$SQ&h$UQ'e%OQ'o%TQ'u%_W(V%m(X*e*iQ(Z%oQ(d%yQ(o&`S(r&d/oQ(x&oQ(y&pU)R&w)S+SQ)h'VY)k'Y)l+j+k,oQ)|'g^*Q'k*S+z+{,{-o.bQ*W'mQ*X'nS*Y'r/pW*k(_*f,S,WW*o(b*q,Y,ZQ+t)vQ+y*RQ+}*VQ,X*pQ,^*{Q,p+nQ,y+wQ,z+xQ,},OQ-R,UQ-[,qQ-m,xR.a-nhTOr#k#n$n&R&d'r(i(k)c+c$z!vXYZhv|}!R!S!T!X!j!l#^$Q$S$U$X$l%O%T%_%a%h%m%o%y&`&o&p&w'O'V'Y'g'h'k'm'n'y(R(X(_(b(s)S)V)`)l)v*O*R*S*V*]*`*b*e*f*i*p*q*x*{+S+j+k+n+v+w+x+z+{,O,S,U,W,Y,Z,],o,q,x,{-n-o.b/o/p/qQ#xtW%X!p!t/j/tQ%Y!qQ%Z!rQ%]!uQ%g/iS'q%[/nQ's/kQ't/lQ,P*^Q-Q,QS-q-O.yR/v/xU#|u-s/wR(p&b[gOr#n$n)c+cX!yX#^$U$XQ#WZQ$RvR$[|Q%c!zQ%j!}Q%p#RQ'e$|Q(Q%fQ(U%kQ(^%qQ(a%rQ*h(ZQ-P,PQ-u-QR.d-tQ$ZxQ'|%dR*_'}Q-t-OR/T.yR#QYR#VZR%R!jQ%P!jV)}'h*O+v!]!mP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/mR%U!lR%z#^Q(g%zR*w(hQ$e!RQ&l$XQ)_'OR+_)`Q#rlQ$^!OQ$a!PR&t$`Q(z&sR+Q(}Q(z&sQ+P(|R+Q(}R$c!QXpOr)c+cQ$j!UR'P$kQ$q!XR'Q$lR)u'^Q)s'^V,r+q,s-]Q-l,wQ.W-fR.X-gU-e,w-f-gQ.]-iQ.h-{Q.m.RU.o.T.p/PQ.t.YQ/S.uQ/U.zU/W.{/Y/bQ/c/[Q/g/aR/h/dR.[-hR.j-{",
        nodeNames: "⚠ print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
        maxTerm: 267,
        context: trackIndent,
        nodeProps: [["group", -14, 4, 80, 82, 83, 85, 87, 89, 91, 93, 94, 95, 97, 100, 103, "Statement Statement", -22, 6, 16, 19, 23, 38, 47, 48, 54, 55, 58, 59, 60, 61, 62, 65, 68, 69, 70, 74, 75, 76, 77, "Expression", -10, 105, 107, 110, 112, 113, 117, 119, 124, 126, 129, "Statement", -9, 134, 135, 138, 139, 141, 142, 143, 144, 145, "Pattern"], ["openedBy", 21, "(", 52, "[", 56, "{"], ["closedBy", 22, ")", 53, "]", 57, "}"]],
        propSources: [pythonHighlighting],
        skippedNodes: [0, 2],
        repeatNodeCount: 38,
        tokenData: ")'WMgR!`OX%TXY!EQY[%T[]!EQ]p%Tpq!EQqr!Gkrs!Ktst#J]tu%Tuv&'{vw&*kwx&+}xy'*fyz'+rz{'-O{|'/z|}'1^}!O'2j!O!P'5]!P!Q'Ae!Q!R'Da!R!['Ho![!](&g!]!^()V!^!_(*c!_!`(-_!`!a(.q!a!b%T!b!c(1j!c!d(3O!d!e(4|!e!h(3O!h!i(?z!i!t(3O!t!u(J[!u!w(3O!w!x(>S!x!}(3O!}#O(Ll#O#P!Fp#P#Q(Mx#Q#R) U#R#S(3O#S#T%T#T#U(3O#U#V(4|#V#Y(3O#Y#Z(?z#Z#f(3O#f#g(J[#g#i(3O#i#j(>S#j#o(3O#o#p)!h#p#q)#d#q#r)$v#r#s)%z#s$g%T$g;'S(3O;'S;=`(4v<%lO(3O<r%f]&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<Q&j]&^7[&TS&Z`&d!bOr'crs!,gsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'c<Q'r]&^7[&TS&WW&Z`&d!b&f#tOr'crs&_sw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'c;p(t]&^7[&WW&f#tOr)mrs*ssw)mwxKmx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m;p)z]&^7[&TS&WW&d!b&f#tOr)mrs*ssw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m;p*|]&^7[&TS&d!bOr)mrs+usw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m;p,O]&^7[&TS&d!bOr)mrs,wsw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m8r-QZ&^7[&TS&d!bOw,wwx-sx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,w8r-xZ&^7[Ow,wwx.kx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,w8r.pZ&^7[Ow,wwx/cx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,w7[/hT&^7[O#o/c#p#q/c#r;'S/c;'S;=`/w<%lO/c7[/zP;=`<%l/c8r0SW&^7[O#o,w#o#p0l#p#q,w#q#r0l#r;'S,w;'S;=`7Q;=`<%l0l<%lO,w!f0sX&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l!f1cXOw0lwx2Ox#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l!f2RWOw0lx#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l!f2nRO;'S0l;'S;=`2w;=`O0l!f3OY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l0l<%lO0l!f3sX&TSOw4`wx4zx#O4`#O#P5y#P#o4`#o#p0l#p;'S4`;'S;=`6t<%lO4`S4eV&TSOw4`wx4zx#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`S4}VOw4`wx5dx#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`S5gUOw4`x#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`S5|RO;'S4`;'S;=`6V;=`O4`S6[W&TSOw4`wx4zx#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`S6wP;=`<%l4`!f6}P;=`<%l0l8r7XY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l,w<%lO0l8r7zP;=`<%l,w;p8SW&^7[O#o)m#o#p8l#p#q)m#q#r8l#r;'S)m;'S;=`Jf;=`<%l8l<%lO)m%d8wZ&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d9qZ&TS&d!bOr8lrs:dsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d:kZ&TS&d!bOr8lrs0lsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d;eZ&WW&f#tOr8lrs9jsw8lwx<Wx#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d<_Z&WW&f#tOr8lrs9jsw8lwx=Qx#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l#|=XX&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q#|=wXOr=Qrs>ds#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q#|>gWOr=Qs#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q#|?SRO;'S=Q;'S;=`?];=`O=Q#|?dY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%l=Q<%lO=Q#|@XX&WWOr@trsA`s#O@t#O#PB_#P#o@t#o#p=Q#p;'S@t;'S;=`CY<%lO@tW@yV&WWOr@trsA`s#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@tWAcVOr@trsAxs#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@tWA{UOr@ts#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@tWBbRO;'S@t;'S;=`Bk;=`O@tWBpW&WWOr@trsA`s#O@t#O#PB_#P;'S@t;'S;=`CY;=`<%l@t<%lO@tWC]P;=`<%l@t#|CcP;=`<%l=Q%dCiRO;'S8l;'S;=`Cr;=`O8l%dC}[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l8l<%lO8l%dDzZ&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p8l#p;'SEm;'S;=`JY<%lOEm[EtX&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[FfX&TSOrEmrsGRswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[GWX&TSOrEmrs4`swEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[GxX&WWOrEmrsFaswEmwxHex#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[HjX&WWOrEmrsFaswEmwx@tx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[IYRO;'SEm;'S;=`Ic;=`OEm[IjY&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY;=`<%lEm<%lOEm[J]P;=`<%lEm%dJcP;=`<%l8l;pJq[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l)m<%lO8l;pKjP;=`<%l)m;pKv]&^7[&WW&f#tOr)mrs*ssw)mwxLox#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m:YLxZ&^7[&WW&f#tOrLorsMks#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLo:YMpZ&^7[OrLorsNcs#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLo:YNhZ&^7[OrLors/cs#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLo:Y! `W&^7[O#oLo#o#p=Q#p#qLo#q#r=Q#r;'SLo;'S;=`! x;=`<%l=Q<%lOLo:Y!!PY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%lLo<%lO=Q:Y!!rP;=`<%lLo<Q!!zW&^7[O#o'c#o#p!#d#p#q'c#q#r!#d#r;'S'c;'S;=`!+^;=`<%l!#d<%lO'c%t!#qZ&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d%t!$mZ&TS&Z`&d!bOr!#drs!%`sw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d%t!%iZ&TS&Z`&d!bOr!#drs!&[sw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d!v!&eX&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w<%lO!&[!v!'TRO;'S!&[;'S;=`!'^;=`O!&[!v!'gY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l!&[<%lO!&[!v!([X&TSOw4`wx4zx#O4`#O#P5y#P#o4`#o#p!&[#p;'S4`;'S;=`6t<%lO4`!v!(zP;=`<%l!&[%t!)QRO;'S!#d;'S;=`!)Z;=`O!#d%t!)h[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l!#d<%lO!#d%t!*eZ&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!#d#p;'SEm;'S;=`JY<%lOEm%t!+ZP;=`<%l!#d<Q!+k[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l'c<%lO!#d<Q!,dP;=`<%l'c<Q!,r]&^7[&TS&Z`&d!bOr'crs!-ksw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'c9S!-vZ&^7[&TS&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-k9S!.nW&^7[O#o!-k#o#p!&[#p#q!-k#q#r!&[#r;'S!-k;'S;=`!/W;=`<%l!&[<%lO!-k9S!/aY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l!-k<%lO!&[9S!0SP;=`<%l!-k<b!0b]&^7[&WW&ap&f#tOr!1Zrs*ssw!1Zwx!<Tx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1Z<b!1j]&^7[&TS&WW&ap&d!b&f#tOr!1Zrs*ssw!1Zwx!0Vx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1Z<b!2hW&^7[O#o!1Z#o#p!3Q#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!:z;=`<%l!3Q<%lO!1Z&U!3_Z&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q&U!4ZZ&WW&ap&f#tOr!3Qrs9jsw!3Qwx!4|x#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q&U!5VZ&WW&ap&f#tOr!3Qrs9jsw!3Qwx!5xx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q$n!6RX&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e<%lO!5x$n!6qRO;'S!5x;'S;=`!6z;=`O!5x$n!7TY&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l!5x<%lO!5x$n!7xX&WWOr@trsA`s#O@t#O#PB_#P#o@t#o#p!5x#p;'S@t;'S;=`CY<%lO@t$n!8hP;=`<%l!5x&U!8nRO;'S!3Q;'S;=`!8w;=`O!3Q&U!9U[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l!3Q<%lO!3Q&U!:RZ&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!3Q#p;'SEm;'S;=`JY<%lOEm&U!:wP;=`<%l!3Q<b!;X[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l!1Z<%lO!3Q<b!<QP;=`<%l!1Z<b!<`]&^7[&WW&ap&f#tOr!1Zrs*ssw!1Zwx!=Xx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1Z:z!=dZ&^7[&WW&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=X:z!>[W&^7[O#o!=X#o#p!5x#p#q!=X#q#r!5x#r;'S!=X;'S;=`!>t;=`<%l!5x<%lO!=X:z!>}Y&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l!=X<%lO!5x:z!?pP;=`<%l!=X<r!?xW&^7[O#o%T#o#p!@b#p#q%T#q#r!@b#r;'S%T;'S;=`!Cu;=`<%l!@b<%lO%T&f!@qZ&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co<%lO!@b&f!AgRO;'S!@b;'S;=`!Ap;=`O!@b&f!BP[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l!@b<%lO!@b&f!B|Z&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!@b#p;'SEm;'S;=`JY<%lOEm&f!CrP;=`<%l!@b<r!DU[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l%T<%lO!@b<r!D}P;=`<%l%TMg!Eec&^7[&TS&WW%[1s&Z`&ap&d!b&f#tOX%TXY!EQY[%T[]!EQ]p%Tpq!EQqr%Trs&_sw%Twx!0Vx#O%T#O#P!Fp#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg!Fu[&^7[OY%TYZ!EQZ]%T]^!EQ^#o%T#o#p!@b#p#q%T#q#r!@b#r;'S%T;'S;=`!Cu;=`<%l!@b<%lO%T<u!G|d&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`!I[!`#O%T#O#P!?s#P#T%T#T#U!Jh#U#f%T#f#g!Jh#g#h!Jh#h#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u!Io]kR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u!J{]!jR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{!LTa&bp&^7[&TS&R,X&Z`&d!bOY!MYYZ'cZ]!MY]^'c^r!MYrs#HTsw!MYwx# vx#O!MY#O#P#@t#P#o!MY#o#p#E^#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#G}<%lO!MYGZ!Mka&^7[&TS&WW&R,X&Z`&d!b&f#tOY!MYYZ'cZ]!MY]^'c^r!MYrs!Npsw!MYwx# vx#O!MY#O#P#@t#P#o!MY#o#p#E^#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#G}<%lO!MYGZ!N}]&^7[&TS&R,X&Z`&d!bOr'crs!,gsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cFy#!Ra&^7[&WW&R,X&f#tOY##WYZ)mZ]##W]^)m^r##Wrs#$lsw##Wwx#;fx#O##W#O#P#%p#P#o##W#o#p#3d#p#q##W#q#r#&_#r;'S##W;'S;=`#;`<%lO##WFy##ga&^7[&TS&WW&R,X&d!b&f#tOY##WYZ)mZ]##W]^)m^r##Wrs#$lsw##Wwx# vx#O##W#O#P#%p#P#o##W#o#p#3d#p#q##W#q#r#&_#r;'S##W;'S;=`#;`<%lO##WFy#$w]&^7[&TS&R,X&d!bOr)mrs+usw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)mFy#%uW&^7[O#o##W#o#p#&_#p#q##W#q#r#&_#r;'S##W;'S;=`#:P;=`<%l#&_<%lO##W0m#&l_&TS&WW&R,X&d!b&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#(gx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y<%lO#&_0m#'tZ&TS&R,X&d!bOr8lrs:dsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l0m#(p_&WW&R,X&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#)ox#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y<%lO#&_0m#)x_&WW&R,X&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#*wx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y<%lO#&_/V#+Q]&WW&R,X&f#tOY#*wYZ=QZ]#*w]^=Q^r#*wrs#+ys#O#*w#O#P#,k#P#o#*w#o#p#-|#p;'S#*w;'S;=`#1q<%lO#*w/V#,OX&R,XOr=Qrs>ds#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q/V#,nRO;'S#*w;'S;=`#,w;=`O#*w/V#-Q^&WW&R,X&f#tOY#*wYZ=QZ]#*w]^=Q^r#*wrs#+ys#O#*w#O#P#,k#P#o#*w#o#p#-|#p;'S#*w;'S;=`#1q;=`<%l#*w<%lO#*w/V#.T]&WW&R,XOY#.|YZ@tZ]#.|]^@t^r#.|rs#/vs#O#.|#O#P#0b#P#o#.|#o#p#*w#p;'S#.|;'S;=`#1k<%lO#.|,a#/TZ&WW&R,XOY#.|YZ@tZ]#.|]^@t^r#.|rs#/vs#O#.|#O#P#0b#P;'S#.|;'S;=`#1k<%lO#.|,a#/{V&R,XOr@trsAxs#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@t,a#0eRO;'S#.|;'S;=`#0n;=`O#.|,a#0u[&WW&R,XOY#.|YZ@tZ]#.|]^@t^r#.|rs#/vs#O#.|#O#P#0b#P;'S#.|;'S;=`#1k;=`<%l#.|<%lO#.|,a#1nP;=`<%l#.|/V#1tP;=`<%l#*w0m#1zRO;'S#&_;'S;=`#2T;=`O#&_0m#2b`&TS&WW&R,X&d!b&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#(gx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y;=`<%l#&_<%lO#&_0m#3m_&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P#o#4l#o#p#&_#p;'S#4l;'S;=`#9s<%lO#4l,e#4u]&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P;'S#4l;'S;=`#9s<%lO#4l,e#5uX&TS&R,XOrEmrsGRswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm,e#6i]&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#7bx#O#4l#O#P#8b#P;'S#4l;'S;=`#9s<%lO#4l,e#7i]&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#.|x#O#4l#O#P#8b#P;'S#4l;'S;=`#9s<%lO#4l,e#8eRO;'S#4l;'S;=`#8n;=`O#4l,e#8w^&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P;'S#4l;'S;=`#9s;=`<%l#4l<%lO#4l,e#9vP;=`<%l#4l0m#9|P;=`<%l#&_Fy#:^`&TS&WW&R,X&d!b&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#(gx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y;=`<%l##W<%lO#&_Fy#;cP;=`<%l##WFy#;qa&^7[&WW&R,X&f#tOY##WYZ)mZ]##W]^)m^r##Wrs#$lsw##Wwx#<vx#O##W#O#P#%p#P#o##W#o#p#3d#p#q##W#q#r#&_#r;'S##W;'S;=`#;`<%lO##WEc#=R_&^7[&WW&R,X&f#tOY#<vYZLoZ]#<v]^Lo^r#<vrs#>Qs#O#<v#O#P#>z#P#o#<v#o#p#-|#p#q#<v#q#r#*w#r;'S#<v;'S;=`#@n<%lO#<vEc#>XZ&^7[&R,XOrLorsNcs#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLoEc#?PW&^7[O#o#<v#o#p#*w#p#q#<v#q#r#*w#r;'S#<v;'S;=`#?i;=`<%l#*w<%lO#<vEc#?r^&WW&R,X&f#tOY#*wYZ=QZ]#*w]^=Q^r#*wrs#+ys#O#*w#O#P#,k#P#o#*w#o#p#-|#p;'S#*w;'S;=`#1q;=`<%l#<v<%lO#*wEc#@qP;=`<%l#<vGZ#@yW&^7[O#o!MY#o#p#Ac#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#Fl;=`<%l#Ac<%lO!MY0}#Ar_&TS&WW&R,X&Z`&d!b&f#tOY#AcYZ!#dZ]#Ac]^!#d^r#Acrs#Bqsw#Acwx#(gx#O#Ac#O#P#Co#P#o#Ac#o#p#E^#p;'S#Ac;'S;=`#Ff<%lO#Ac0}#B|Z&TS&R,X&Z`&d!bOr!#drs!%`sw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d0}#CrRO;'S#Ac;'S;=`#C{;=`O#Ac0}#D[`&TS&WW&R,X&Z`&d!b&f#tOY#AcYZ!#dZ]#Ac]^!#d^r#Acrs#Bqsw#Acwx#(gx#O#Ac#O#P#Co#P#o#Ac#o#p#E^#p;'S#Ac;'S;=`#Ff;=`<%l#Ac<%lO#Ac0}#Eg_&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P#o#4l#o#p#Ac#p;'S#4l;'S;=`#9s<%lO#4l0}#FiP;=`<%l#AcGZ#F{`&TS&WW&R,X&Z`&d!b&f#tOY#AcYZ!#dZ]#Ac]^!#d^r#Acrs#Bqsw#Acwx#(gx#O#Ac#O#P#Co#P#o#Ac#o#p#E^#p;'S#Ac;'S;=`#Ff;=`<%l!MY<%lO#AcGZ#HQP;=`<%l!MYGZ#Hb]&^7[&TS&R,X&Z`&d!bOr'crs#IZsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cGZ#IjZ&X#|&^7[&TS&V,X&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-kMg#JpaQ1s&^7[&TS&WW&Z`&ap&d!b&f#tOY#J]YZ%TZ]#J]]^%T^r#J]rs#Kusw#J]wx%;ax#O#J]#O#P& a#P#o#J]#o#p&%b#p#q#J]#q#r&!^#r;'S#J];'S;=`&'u<%lO#J]Lu#LSaQ1s&^7[&TS&Z`&d!bOY#MXYZ'cZ]#MX]^'c^r#MXrs%6usw#MXwx#Nox#O#MX#O#P%*Z#P#o#MX#o#p%4^#p#q#MX#q#r%+W#r;'S#MX;'S;=`%6o<%lO#MXLu#MjaQ1s&^7[&TS&WW&Z`&d!b&f#tOY#MXYZ'cZ]#MX]^'c^r#MXrs#Kusw#MXwx#Nox#O#MX#O#P%*Z#P#o#MX#o#p%4^#p#q#MX#q#r%+W#r;'S#MX;'S;=`%6o<%lO#MXLe#NzaQ1s&^7[&WW&f#tOY$!PYZ)mZ]$!P]^)m^r$!Prs$#esw$!Pwx%#ix#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PLe$!`aQ1s&^7[&TS&WW&d!b&f#tOY$!PYZ)mZ]$!P]^)m^r$!Prs$#esw$!Pwx#Nox#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PLe$#paQ1s&^7[&TS&d!bOY$!PYZ)mZ]$!P]^)m^r$!Prs$$usw$!Pwx#Nox#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PLe$%QaQ1s&^7[&TS&d!bOY$!PYZ)mZ]$!P]^)m^r$!Prs$&Vsw$!Pwx#Nox#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PIg$&b_Q1s&^7[&TS&d!bOY$&VYZ,wZ]$&V]^,w^w$&Vwx$'ax#O$&V#O#P$+X#P#o$&V#o#p$0h#p#q$&V#q#r$,U#r;'S$&V;'S;=`$6a<%lO$&VIg$'h_Q1s&^7[OY$&VYZ,wZ]$&V]^,w^w$&Vwx$(gx#O$&V#O#P$+X#P#o$&V#o#p$0h#p#q$&V#q#r$,U#r;'S$&V;'S;=`$6a<%lO$&VIg$(n_Q1s&^7[OY$&VYZ,wZ]$&V]^,w^w$&Vwx$)mx#O$&V#O#P$+X#P#o$&V#o#p$0h#p#q$&V#q#r$,U#r;'S$&V;'S;=`$6a<%lO$&VHP$)tZQ1s&^7[OY$)mYZ/cZ]$)m]^/c^#o$)m#o#p$*g#p#q$)m#q#r$*g#r;'S$)m;'S;=`$+R<%lO$)m1s$*lTQ1sOY$*gZ]$*g^;'S$*g;'S;=`$*{<%lO$*g1s$+OP;=`<%l$*gHP$+UP;=`<%l$)mIg$+`[Q1s&^7[OY$&VYZ,wZ]$&V]^,w^#o$&V#o#p$,U#p#q$&V#q#r$,U#r;'S$&V;'S;=`$5j;=`<%l0l<%lO$&V3Z$,_]Q1s&TS&d!bOY$,UYZ0lZ]$,U]^0l^w$,Uwx$-Wx#O$,U#O#P$/S#P#o$,U#o#p$0h#p;'S$,U;'S;=`$5d<%lO$,U3Z$-]]Q1sOY$,UYZ0lZ]$,U]^0l^w$,Uwx$.Ux#O$,U#O#P$/S#P#o$,U#o#p$0h#p;'S$,U;'S;=`$5d<%lO$,U3Z$.Z]Q1sOY$,UYZ0lZ]$,U]^0l^w$,Uwx$*gx#O$,U#O#P$/S#P#o$,U#o#p$0h#p;'S$,U;'S;=`$5d<%lO$,U3Z$/XWQ1sOY$,UYZ0lZ]$,U]^0l^;'S$,U;'S;=`$/q;=`<%l0l<%lO$,U3Z$/xY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l$,U<%lO0l3Z$0o]Q1s&TSOY$1hYZ4`Z]$1h]^4`^w$1hwx$2bx#O$1h#O#P$4Q#P#o$1h#o#p$,U#p;'S$1h;'S;=`$5^<%lO$1h1w$1oZQ1s&TSOY$1hYZ4`Z]$1h]^4`^w$1hwx$2bx#O$1h#O#P$4Q#P;'S$1h;'S;=`$5^<%lO$1h1w$2gZQ1sOY$1hYZ4`Z]$1h]^4`^w$1hwx$3Yx#O$1h#O#P$4Q#P;'S$1h;'S;=`$5^<%lO$1h1w$3_ZQ1sOY$1hYZ4`Z]$1h]^4`^w$1hwx$*gx#O$1h#O#P$4Q#P;'S$1h;'S;=`$5^<%lO$1h1w$4VWQ1sOY$1hYZ4`Z]$1h]^4`^;'S$1h;'S;=`$4o;=`<%l4`<%lO$1h1w$4tW&TSOw4`wx4zx#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l$1h<%lO4`1w$5aP;=`<%l$1h3Z$5gP;=`<%l$,UIg$5qY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l$&V<%lO0lIg$6dP;=`<%l$&VLe$6n[Q1s&^7[OY$!PYZ)mZ]$!P]^)m^#o$!P#o#p$7d#p#q$!P#q#r$7d#r;'S$!P;'S;=`%!b;=`<%l8l<%lO$!P6X$7q_Q1s&TS&WW&d!b&f#tOY$7dYZ8lZ]$7d]^8l^r$7drs$8psw$7dwx$;Qx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$8y_Q1s&TS&d!bOY$7dYZ8lZ]$7d]^8l^r$7drs$9xsw$7dwx$;Qx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$:R_Q1s&TS&d!bOY$7dYZ8lZ]$7d]^8l^r$7drs$,Usw$7dwx$;Qx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$;Z_Q1s&WW&f#tOY$7dYZ8lZ]$7d]^8l^r$7drs$8psw$7dwx$<Yx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$<c_Q1s&WW&f#tOY$7dYZ8lZ]$7d]^8l^r$7drs$8psw$7dwx$=bx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d4q$=k]Q1s&WW&f#tOY$=bYZ=QZ]$=b]^=Q^r$=brs$>ds#O$=b#O#P$@`#P#o$=b#o#p$At#p;'S$=b;'S;=`$Fp<%lO$=b4q$>i]Q1sOY$=bYZ=QZ]$=b]^=Q^r$=brs$?bs#O$=b#O#P$@`#P#o$=b#o#p$At#p;'S$=b;'S;=`$Fp<%lO$=b4q$?g]Q1sOY$=bYZ=QZ]$=b]^=Q^r$=brs$*gs#O$=b#O#P$@`#P#o$=b#o#p$At#p;'S$=b;'S;=`$Fp<%lO$=b4q$@eWQ1sOY$=bYZ=QZ]$=b]^=Q^;'S$=b;'S;=`$@};=`<%l=Q<%lO$=b4q$AUY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%l$=b<%lO=Q4q$A{]Q1s&WWOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Cns#O$Bt#O#P$E^#P#o$Bt#o#p$=b#p;'S$Bt;'S;=`$Fj<%lO$Bt1{$B{ZQ1s&WWOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Cns#O$Bt#O#P$E^#P;'S$Bt;'S;=`$Fj<%lO$Bt1{$CsZQ1sOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Dfs#O$Bt#O#P$E^#P;'S$Bt;'S;=`$Fj<%lO$Bt1{$DkZQ1sOY$BtYZ@tZ]$Bt]^@t^r$Btrs$*gs#O$Bt#O#P$E^#P;'S$Bt;'S;=`$Fj<%lO$Bt1{$EcWQ1sOY$BtYZ@tZ]$Bt]^@t^;'S$Bt;'S;=`$E{;=`<%l@t<%lO$Bt1{$FQW&WWOr@trsA`s#O@t#O#PB_#P;'S@t;'S;=`CY;=`<%l$Bt<%lO@t1{$FmP;=`<%l$Bt4q$FsP;=`<%l$=b6X$F{WQ1sOY$7dYZ8lZ]$7d]^8l^;'S$7d;'S;=`$Ge;=`<%l8l<%lO$7d6X$Gp[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l$7d<%lO8l6X$Ho_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p$7d#p;'S$In;'S;=`%!U<%lO$In2P$Iw]Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Jw]Q1s&TSOY$InYZEmZ]$In]^Em^r$Inrs$Kpsw$Inwx$Lpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Kw]Q1s&TSOY$InYZEmZ]$In]^Em^r$Inrs$1hsw$Inwx$Lpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Lw]Q1s&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Mpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Mw]Q1s&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Btx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$NuWQ1sOY$InYZEmZ]$In]^Em^;'S$In;'S;=`% _;=`<%lEm<%lO$In2P% fY&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY;=`<%l$In<%lOEm2P%!XP;=`<%l$In6X%!_P;=`<%l$7dLe%!m[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l$!P<%lO8lLe%#fP;=`<%l$!PLe%#taQ1s&^7[&WW&f#tOY$!PYZ)mZ]$!P]^)m^r$!Prs$#esw$!Pwx%$yx#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PJ}%%U_Q1s&^7[&WW&f#tOY%$yYZLoZ]%$y]^Lo^r%$yrs%&Ts#O%$y#O#P%(a#P#o%$y#o#p$At#p#q%$y#q#r$=b#r;'S%$y;'S;=`%*T<%lO%$yJ}%&[_Q1s&^7[OY%$yYZLoZ]%$y]^Lo^r%$yrs%'Zs#O%$y#O#P%(a#P#o%$y#o#p$At#p#q%$y#q#r$=b#r;'S%$y;'S;=`%*T<%lO%$yJ}%'b_Q1s&^7[OY%$yYZLoZ]%$y]^Lo^r%$yrs$)ms#O%$y#O#P%(a#P#o%$y#o#p$At#p#q%$y#q#r$=b#r;'S%$y;'S;=`%*T<%lO%$yJ}%(h[Q1s&^7[OY%$yYZLoZ]%$y]^Lo^#o%$y#o#p$=b#p#q%$y#q#r$=b#r;'S%$y;'S;=`%)^;=`<%l=Q<%lO%$yJ}%)eY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%l%$y<%lO=QJ}%*WP;=`<%l%$yLu%*b[Q1s&^7[OY#MXYZ'cZ]#MX]^'c^#o#MX#o#p%+W#p#q#MX#q#r%+W#r;'S#MX;'S;=`%5l;=`<%l!#d<%lO#MX6i%+g_Q1s&TS&WW&Z`&d!b&f#tOY%+WYZ!#dZ]%+W]^!#d^r%+Wrs%,fsw%+Wwx$;Qx#O%+W#O#P%2l#P#o%+W#o#p%4^#p;'S%+W;'S;=`%5f<%lO%+W6i%,q_Q1s&TS&Z`&d!bOY%+WYZ!#dZ]%+W]^!#d^r%+Wrs%-psw%+Wwx$;Qx#O%+W#O#P%2l#P#o%+W#o#p%4^#p;'S%+W;'S;=`%5f<%lO%+W6i%-{_Q1s&TS&Z`&d!bOY%+WYZ!#dZ]%+W]^!#d^r%+Wrs%.zsw%+Wwx$;Qx#O%+W#O#P%2l#P#o%+W#o#p%4^#p;'S%+W;'S;=`%5f<%lO%+W3k%/V]Q1s&TS&Z`&d!bOY%.zYZ!&[Z]%.z]^!&[^w%.zwx$-Wx#O%.z#O#P%0O#P#o%.z#o#p%1f#p;'S%.z;'S;=`%2f<%lO%.z3k%0TWQ1sOY%.zYZ!&[Z]%.z]^!&[^;'S%.z;'S;=`%0m;=`<%l!&[<%lO%.z3k%0vY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l%.z<%lO!&[3k%1m]Q1s&TSOY$1hYZ4`Z]$1h]^4`^w$1hwx$2bx#O$1h#O#P$4Q#P#o$1h#o#p%.z#p;'S$1h;'S;=`$5^<%lO$1h3k%2iP;=`<%l%.z6i%2qWQ1sOY%+WYZ!#dZ]%+W]^!#d^;'S%+W;'S;=`%3Z;=`<%l!#d<%lO%+W6i%3h[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l%+W<%lO!#d6i%4g_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p%+W#p;'S$In;'S;=`%!U<%lO$In6i%5iP;=`<%l%+WLu%5y[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l#MX<%lO!#dLu%6rP;=`<%l#MXLu%7SaQ1s&^7[&TS&Z`&d!bOY#MXYZ'cZ]#MX]^'c^r#MXrs%8Xsw#MXwx#Nox#O#MX#O#P%*Z#P#o#MX#o#p%4^#p#q#MX#q#r%+W#r;'S#MX;'S;=`%6o<%lO#MXIw%8f_Q1s&^7[&TS&Z`&d!bOY%8XYZ!-kZ]%8X]^!-k^w%8Xwx$'ax#O%8X#O#P%9e#P#o%8X#o#p%1f#p#q%8X#q#r%.z#r;'S%8X;'S;=`%;Z<%lO%8XIw%9l[Q1s&^7[OY%8XYZ!-kZ]%8X]^!-k^#o%8X#o#p%.z#p#q%8X#q#r%.z#r;'S%8X;'S;=`%:b;=`<%l!&[<%lO%8XIw%:kY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l%8X<%lO!&[Iw%;^P;=`<%l%8XMV%;naQ1s&^7[&WW&ap&f#tOY%<sYZ!1ZZ]%<s]^!1Z^r%<srs$#esw%<swx%Jux#O%<s#O#P%>Z#P#o%<s#o#p%H^#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Jo<%lO%<sMV%=UaQ1s&^7[&TS&WW&ap&d!b&f#tOY%<sYZ!1ZZ]%<s]^!1Z^r%<srs$#esw%<swx%;ax#O%<s#O#P%>Z#P#o%<s#o#p%H^#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Jo<%lO%<sMV%>b[Q1s&^7[OY%<sYZ!1ZZ]%<s]^!1Z^#o%<s#o#p%?W#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Il;=`<%l!3Q<%lO%<s6y%?g_Q1s&TS&WW&ap&d!b&f#tOY%?WYZ!3QZ]%?W]^!3Q^r%?Wrs$8psw%?Wwx%@fx#O%?W#O#P%Fl#P#o%?W#o#p%H^#p;'S%?W;'S;=`%If<%lO%?W6y%@q_Q1s&WW&ap&f#tOY%?WYZ!3QZ]%?W]^!3Q^r%?Wrs$8psw%?Wwx%Apx#O%?W#O#P%Fl#P#o%?W#o#p%H^#p;'S%?W;'S;=`%If<%lO%?W6y%A{_Q1s&WW&ap&f#tOY%?WYZ!3QZ]%?W]^!3Q^r%?Wrs$8psw%?Wwx%Bzx#O%?W#O#P%Fl#P#o%?W#o#p%H^#p;'S%?W;'S;=`%If<%lO%?W5c%CV]Q1s&WW&ap&f#tOY%BzYZ!5xZ]%Bz]^!5x^r%Bzrs$>ds#O%Bz#O#P%DO#P#o%Bz#o#p%Ef#p;'S%Bz;'S;=`%Ff<%lO%Bz5c%DTWQ1sOY%BzYZ!5xZ]%Bz]^!5x^;'S%Bz;'S;=`%Dm;=`<%l!5x<%lO%Bz5c%DvY&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l%Bz<%lO!5x5c%Em]Q1s&WWOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Cns#O$Bt#O#P$E^#P#o$Bt#o#p%Bz#p;'S$Bt;'S;=`$Fj<%lO$Bt5c%FiP;=`<%l%Bz6y%FqWQ1sOY%?WYZ!3QZ]%?W]^!3Q^;'S%?W;'S;=`%GZ;=`<%l!3Q<%lO%?W6y%Gh[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l%?W<%lO!3Q6y%Hg_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p%?W#p;'S$In;'S;=`%!U<%lO$In6y%IiP;=`<%l%?WMV%Iy[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l%<s<%lO!3QMV%JrP;=`<%l%<sMV%KSaQ1s&^7[&WW&ap&f#tOY%<sYZ!1ZZ]%<s]^!1Z^r%<srs$#esw%<swx%LXx#O%<s#O#P%>Z#P#o%<s#o#p%H^#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Jo<%lO%<sKo%Lf_Q1s&^7[&WW&ap&f#tOY%LXYZ!=XZ]%LX]^!=X^r%LXrs%&Ts#O%LX#O#P%Me#P#o%LX#o#p%Ef#p#q%LX#q#r%Bz#r;'S%LX;'S;=`& Z<%lO%LXKo%Ml[Q1s&^7[OY%LXYZ!=XZ]%LX]^!=X^#o%LX#o#p%Bz#p#q%LX#q#r%Bz#r;'S%LX;'S;=`%Nb;=`<%l!5x<%lO%LXKo%NkY&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l%LX<%lO!5xKo& ^P;=`<%l%LXMg& h[Q1s&^7[OY#J]YZ%TZ]#J]]^%T^#o#J]#o#p&!^#p#q#J]#q#r&!^#r;'S#J];'S;=`&&p;=`<%l!@b<%lO#J]7Z&!o_Q1s&TS&WW&Z`&ap&d!b&f#tOY&!^YZ!@bZ]&!^]^!@b^r&!^rs%,fsw&!^wx%@fx#O&!^#O#P&#n#P#o&!^#o#p&%b#p;'S&!^;'S;=`&&j<%lO&!^7Z&#sWQ1sOY&!^YZ!@bZ]&!^]^!@b^;'S&!^;'S;=`&$];=`<%l!@b<%lO&!^7Z&$l[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l&!^<%lO!@b7Z&%k_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p&!^#p;'S$In;'S;=`%!U<%lO$In7Z&&mP;=`<%l&!^Mg&'P[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l#J]<%lO!@bMg&'xP;=`<%l#J]Gz&(`_%jQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz&)r]!s,W&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz&+O_%dQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{&,^a&_`&^7[&WW&R,X&ap&f#tOY&-cYZ!1ZZ]&-c]^!1Z^r&-crs&.ysw&-cwx'(^x#O&-c#O#P&N}#P#o&-c#o#p'%g#p#q&-c#q#r' l#r;'S&-c;'S;=`'(W<%lO&-cGk&-ta&^7[&TS&WW&R,X&ap&d!b&f#tOY&-cYZ!1ZZ]&-c]^!1Z^r&-crs&.ysw&-cwx&Mwx#O&-c#O#P&N}#P#o&-c#o#p'%g#p#q&-c#q#r' l#r;'S&-c;'S;=`'(W<%lO&-cFy&/Ua&^7[&TS&R,X&d!bOY&0ZYZ)mZ]&0Z]^)m^r&0Zrs&Hisw&0Zwx&1ox#O&0Z#O#P&2s#P#o&0Z#o#p&@g#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&Hc<%lO&0ZFy&0ja&^7[&TS&WW&R,X&d!b&f#tOY&0ZYZ)mZ]&0Z]^)m^r&0Zrs&.ysw&0Zwx&1ox#O&0Z#O#P&2s#P#o&0Z#o#p&@g#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&Hc<%lO&0ZFy&1z]&^7[&WW&R,X&f#tOr)mrs*ssw)mwxKmx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)mFy&2xW&^7[O#o&0Z#o#p&3b#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&GS;=`<%l&3b<%lO&0Z0m&3o_&TS&WW&R,X&d!b&f#tOY&3bYZ8lZ]&3b]^8l^r&3brs&4nsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|<%lO&3b0m&4w_&TS&R,X&d!bOY&3bYZ8lZ]&3b]^8l^r&3brs&5vsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|<%lO&3b0m&6P_&TS&R,X&d!bOY&3bYZ8lZ]&3b]^8l^r&3brs&7Osw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|<%lO&3b-o&7X]&TS&R,X&d!bOY&7OYZ0lZ]&7O]^0l^w&7Owx&8Qx#O&7O#O#P&8r#P#o&7O#o#p&:T#p;'S&7O;'S;=`&=x<%lO&7O-o&8VX&R,XOw0lwx2Ox#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l-o&8uRO;'S&7O;'S;=`&9O;=`O&7O-o&9X^&TS&R,X&d!bOY&7OYZ0lZ]&7O]^0l^w&7Owx&8Qx#O&7O#O#P&8r#P#o&7O#o#p&:T#p;'S&7O;'S;=`&=x;=`<%l&7O<%lO&7O-o&:[]&TS&R,XOY&;TYZ4`Z]&;T]^4`^w&;Twx&;}x#O&;T#O#P&<i#P#o&;T#o#p&7O#p;'S&;T;'S;=`&=r<%lO&;T,]&;[Z&TS&R,XOY&;TYZ4`Z]&;T]^4`^w&;Twx&;}x#O&;T#O#P&<i#P;'S&;T;'S;=`&=r<%lO&;T,]&<SV&R,XOw4`wx5dx#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`,]&<lRO;'S&;T;'S;=`&<u;=`O&;T,]&<|[&TS&R,XOY&;TYZ4`Z]&;T]^4`^w&;Twx&;}x#O&;T#O#P&<i#P;'S&;T;'S;=`&=r;=`<%l&;T<%lO&;T,]&=uP;=`<%l&;T-o&={P;=`<%l&7O0m&>XZ&WW&R,X&f#tOr8lrs9jsw8lwx<Wx#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l0m&>}RO;'S&3b;'S;=`&?W;=`O&3b0m&?e`&TS&WW&R,X&d!b&f#tOY&3bYZ8lZ]&3b]^8l^r&3brs&4nsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|;=`<%l&3b<%lO&3b0m&@p_&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P#o&Ao#o#p&3b#p;'S&Ao;'S;=`&Fv<%lO&Ao,e&Ax]&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv<%lO&Ao,e&Bx]&TS&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Cqsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv<%lO&Ao,e&Cx]&TS&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&;Tsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv<%lO&Ao,e&DxX&WW&R,XOrEmrsFaswEmwxHex#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm,e&EhRO;'S&Ao;'S;=`&Eq;=`O&Ao,e&Ez^&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv;=`<%l&Ao<%lO&Ao,e&FyP;=`<%l&Ao0m&GPP;=`<%l&3bFy&Ga`&TS&WW&R,X&d!b&f#tOY&3bYZ8lZ]&3b]^8l^r&3brs&4nsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|;=`<%l&0Z<%lO&3bFy&HfP;=`<%l&0ZFy&Hta&^7[&TS&R,X&d!bOY&0ZYZ)mZ]&0Z]^)m^r&0Zrs&Iysw&0Zwx&1ox#O&0Z#O#P&2s#P#o&0Z#o#p&@g#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&Hc<%lO&0ZC{&JU_&^7[&TS&R,X&d!bOY&IyYZ,wZ]&Iy]^,w^w&Iywx&KTx#O&Iy#O#P&K}#P#o&Iy#o#p&:T#p#q&Iy#q#r&7O#r;'S&Iy;'S;=`&Mq<%lO&IyC{&K[Z&^7[&R,XOw,wwx.kx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,wC{&LSW&^7[O#o&Iy#o#p&7O#p#q&Iy#q#r&7O#r;'S&Iy;'S;=`&Ll;=`<%l&7O<%lO&IyC{&Lu^&TS&R,X&d!bOY&7OYZ0lZ]&7O]^0l^w&7Owx&8Qx#O&7O#O#P&8r#P#o&7O#o#p&:T#p;'S&7O;'S;=`&=x;=`<%l&Iy<%lO&7OC{&MtP;=`<%l&IyGk&NU]&^7[&WW&R,X&ap&f#tOr!1Zrs*ssw!1Zwx!<Tx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZGk' SW&^7[O#o&-c#o#p' l#p#q&-c#q#r' l#r;'S&-c;'S;=`'&u;=`<%l' l<%lO&-c1_' {_&TS&WW&R,X&ap&d!b&f#tOY' lYZ!3QZ]' l]^!3Q^r' lrs&4nsw' lwx'!zx#O' l#O#P'#x#P#o' l#o#p'%g#p;'S' l;'S;=`'&o<%lO' l1_'#VZ&WW&R,X&ap&f#tOr!3Qrs9jsw!3Qwx!4|x#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q1_'#{RO;'S' l;'S;=`'$U;=`O' l1_'$e`&TS&WW&R,X&ap&d!b&f#tOY' lYZ!3QZ]' l]^!3Q^r' lrs&4nsw' lwx'!zx#O' l#O#P'#x#P#o' l#o#p'%g#p;'S' l;'S;=`'&o;=`<%l' l<%lO' l1_'%p_&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P#o&Ao#o#p' l#p;'S&Ao;'S;=`&Fv<%lO&Ao1_'&rP;=`<%l' lGk''U`&TS&WW&R,X&ap&d!b&f#tOY' lYZ!3QZ]' l]^!3Q^r' lrs&4nsw' lwx'!zx#O' l#O#P'#x#P#o' l#o#p'%g#p;'S' l;'S;=`'&o;=`<%l&-c<%lO' lGk'(ZP;=`<%l&-cGk'(k]&^7[&WW&R,X&ap&f#tOr!1Zrs*ssw!1Zwx')dx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZGk')sZ&U!f&^7[&WW&S,X&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=XG{'*y]f,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u',V]eR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'-caT,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vxz%Tz{'.h{!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'.{__R&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'0__%g,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u'1q]xR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg'2}`%h,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`!a'4P!a#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TB^'4d]&q&j&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'5pa!dQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'6u!P!Q%T!Q!['9c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'7W_&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'8V!P#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'8j]!m,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'9vi!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['9c![!g%T!g!h';e!h!l%T!l!m'@X!m#O%T#O#P!?s#P#R%T#R#S'9c#S#X%T#X#Y';e#Y#^%T#^#_'@X#_#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy';vc&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx{%T{|'=R|}%T}!O'=R!O!Q%T!Q!['>c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'=d_&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['>c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'>ve!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['>c![!l%T!l!m'@X!m#O%T#O#P!?s#P#R%T#R#S'>c#S#^%T#^#_'@X#_#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'@l]!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'Axa%iR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!P%T!P!Q'B}!Q!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz'Cb_%kQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'Dtw!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'G_!P!Q%T!Q!['Ho![!d%T!d!e'Jw!e!g%T!g!h';e!h!l%T!l!m'@X!m!q%T!q!r'M}!r!z%T!z!{(!}!{#O%T#O#P!?s#P#R%T#R#S'Ho#S#U%T#U#V'Jw#V#X%T#X#Y';e#Y#^%T#^#_'@X#_#c%T#c#d'M}#d#l%T#l#m(!}#m#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'Gp_&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['9c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'ISk!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'G_!P!Q%T!Q!['Ho![!g%T!g!h';e!h!l%T!l!m'@X!m#O%T#O#P!?s#P#R%T#R#S'Ho#S#X%T#X#Y';e#Y#^%T#^#_'@X#_#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'KYb&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!R'Lb!R!S'Lb!S#O%T#O#P!?s#P#R%T#R#S'Lb#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'Lub!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!R'Lb!R!S'Lb!S#O%T#O#P!?s#P#R%T#R#S'Lb#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'N`a&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!Y( e!Y#O%T#O#P!?s#P#R%T#R#S( e#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy( xa!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!Y( e!Y#O%T#O#P!?s#P#R%T#R#S( e#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy(#`e&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q![($q![!c%T!c!i($q!i#O%T#O#P!?s#P#R%T#R#S($q#S#T%T#T#Z($q#Z#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy(%Ue!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q![($q![!c%T!c!i($q!i#O%T#O#P!?s#P#R%T#R#S($q#S#T%T#T#Z($q#Z#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg(&z_y1s&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`('y!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u((^]%sR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{()j]#^,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(*vakR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!^%T!^!_(+{!_!`!I[!`!a!I[!a#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz(,`_%eQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(-r_%r,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`!I[!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(/U`kR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`!I[!`!a(0W!a#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz(0k_%fQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(2P_]Q#tP&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg(3ee&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs&_sw%Twx!0Vx!Q%T!Q![(3O![!c%T!c!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OMg(4yP;=`<%l(3OMg(5ci&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(7Qsw%Twx(:jx!Q%T!Q![(3O![!c%T!c!t(3O!t!u(>S!u!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#f(3O#f#g(>S#g#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OGZ(7_a&^7[&TS&R,X&Z`&d!bOY!MYYZ'cZ]!MY]^'c^r!MYrs(8dsw!MYwx# vx#O!MY#O#P#@t#P#o!MY#o#p#E^#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#G}<%lO!MYGZ(8q]&^7[&TS&R,X&Z`&d!bOr'crs(9jsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cD](9wZ&^7[&TS&V,X&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-kGk(:wa&^7[&WW&R,X&ap&f#tOY&-cYZ!1ZZ]&-c]^!1Z^r&-crs&.ysw&-cwx(;|x#O&-c#O#P&N}#P#o&-c#o#p'%g#p#q&-c#q#r' l#r;'S&-c;'S;=`'(W<%lO&-cGk(<Z]&^7[&WW&R,X&ap&f#tOr!1Zrs*ssw!1Zwx(=Sx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZFT(=aZ&^7[&WW&S,X&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=XMg(>ie&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(7Qsw%Twx(:jx!Q%T!Q![(3O![!c%T!c!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OMg(@ai&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(BOsw%Twx(EYx!Q%T!Q![(3O![!c%T!c!t(3O!t!u(Hd!u!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#f(3O#f#g(Hd#g#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OGZ(B]]&^7[&TS&Z`&d!b&`,XOr'crs(CUsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cGZ(Ca]&^7[&TS&Z`&d!bOr'crs(DYsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cD](DgZ&^7[&TS&e,X&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-kGk(Eg]&^7[&WW&ap&f#t&Y,XOr!1Zrs*ssw!1Zwx(F`x#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZGk(Fk]&^7[&WW&ap&f#tOr!1Zrs*ssw!1Zwx(Gdx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZFT(GqZ&^7[&WW&c,X&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=XMg(Hye&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(BOsw%Twx(EYx!Q%T!Q![(3O![!c%T!c!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OMg(Jqm&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(7Qsw%Twx(:jx!Q%T!Q![(3O![!c%T!c!h(3O!h!i(Hd!i!t(3O!t!u(>S!u!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#U(3O#U#V(>S#V#Y(3O#Y#Z(Hd#Z#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OG{(MP]!V,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u(N]]!UR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz) i_%cQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy)!qZ&TS&WW!ZGmOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!@b#p;'SEm;'S;=`JY<%lOEmG{)#w_%bR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u)%XZ!Y7_&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co<%lO!@bGy)&_]%l,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T",
        tokenizers: [legacyPrint, indentation, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines],
        topRules: {
            "Script": [0, 3]
        },
        specialized: [{
            term: 213,
            get: value => spec_identifier$1[value] || -1
        }],
        tokenPrec: 7282
    });
    const cache = new NodeWeakMap();
    const ScopeNodes = new Set(["Script", "Body", "FunctionDefinition", "ClassDefinition", "LambdaExpression", "ForStatement", "MatchClause"]);
    function defID(type) {
        return (node, def, outer) => {
            if (outer)
                return false;
            let id = node.node.getChild("VariableName");
            if (id)
                def(id, type);
            return true;
        };
    }
    const gatherCompletions = {
        FunctionDefinition: defID("function"),
        ClassDefinition: defID("class"),
        ForStatement(node, def, outer) {
            if (outer)
                for (let child = node.node.firstChild; child; child = child.nextSibling) {
                    if (child.name == "VariableName")
                        def(child, "variable");
                    else if (child.name == "in")
                        break;
                }
        },
        ImportStatement(_node, def) {
            var _a,
                _b;
            let {node} = _node;
            let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == "from";
            for (let ch = node.getChild("import"); ch; ch = ch.nextSibling) {
                if (ch.name == "VariableName" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != "as")
                    def(ch, isFrom ? "variable" : "namespace");
            }
        },
        AssignStatement(node, def) {
            for (let child = node.node.firstChild; child; child = child.nextSibling) {
                if (child.name == "VariableName")
                    def(child, "variable");
                else if (child.name == ":" || child.name == "AssignOp")
                    break;
            }
        },
        ParamList(node, def) {
            for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {
                if (child.name == "VariableName" && (!prev || !/\*|AssignOp/.test(prev.name)))
                    def(child, "variable");
                prev = child;
            }
        },
        CapturePattern: defID("variable"),
        AsPattern: defID("variable"),
        __proto__: null
    };
    function getScope(doc, node) {
        let cached = cache.get(node);
        if (cached)
            return cached;
        let completions = [],
            top = true;
        function def(node, type) {
            let name = doc.sliceString(node.from, node.to);
            completions.push({
                label: name,
                type
            });
        }
        node.cursor(IterMode.IncludeAnonymous).iterate(node => {
            if (node.name) {
                let gather = gatherCompletions[node.name];
                if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name))
                    return false;
                top = false;
            } else if (node.to - node.from > 8192) {
                for (let _i257 = 0, _getScope = getScope(doc, node.node), _length257 = _getScope.length; _i257 < _length257; _i257++) {
                    let c = _getScope[_i257];
                    completions.push(c);
                }
                return false;
            }
        });
        cache.set(node, completions);
        return completions;
    }
    const Identifier$2 = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/;
    const dontComplete = ["String", "FormatString", "Comment", "PropertyName"];
    function localCompletionSource(context) {
        let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
        if (dontComplete.indexOf(inner.name) > -1)
            return null;
        let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier$2.test(context.state.sliceDoc(inner.from, inner.to));
        if (!isWord && !context.explicit)
            return null;
        let options = [];
        for (let pos = inner; pos; pos = pos.parent) {
            if (ScopeNodes.has(pos.name))
                options = options.concat(getScope(context.state.doc, pos));
        }
        return {
            options,
            from: isWord ? inner.from : context.pos,
            validFor: Identifier$2
        };
    }
    const globals = ["__annotations__", "__builtins__", "__debug__", "__doc__", "__import__", "__name__", "__loader__", "__package__", "__spec__", "False", "None", "True"].map(n => ({
        label: n,
        type: "constant"
    })).concat(["ArithmeticError", "AssertionError", "AttributeError", "BaseException", "BlockingIOError", "BrokenPipeError", "BufferError", "BytesWarning", "ChildProcessError", "ConnectionAbortedError", "ConnectionError", "ConnectionRefusedError", "ConnectionResetError", "DeprecationWarning", "EOFError", "Ellipsis", "EncodingWarning", "EnvironmentError", "Exception", "FileExistsError", "FileNotFoundError", "FloatingPointError", "FutureWarning", "GeneratorExit", "IOError", "ImportError", "ImportWarning", "IndentationError", "IndexError", "InterruptedError", "IsADirectoryError", "KeyError", "KeyboardInterrupt", "LookupError", "MemoryError", "ModuleNotFoundError", "NameError", "NotADirectoryError", "NotImplemented", "NotImplementedError", "OSError", "OverflowError", "PendingDeprecationWarning", "PermissionError", "ProcessLookupError", "RecursionError", "ReferenceError", "ResourceWarning", "RuntimeError", "RuntimeWarning", "StopAsyncIteration", "StopIteration", "SyntaxError", "SyntaxWarning", "SystemError", "SystemExit", "TabError", "TimeoutError", "TypeError", "UnboundLocalError", "UnicodeDecodeError", "UnicodeEncodeError", "UnicodeError", "UnicodeTranslateError", "UnicodeWarning", "UserWarning", "ValueError", "Warning", "ZeroDivisionError"].map(n => ({
        label: n,
        type: "type"
    }))).concat(["bool", "bytearray", "bytes", "classmethod", "complex", "float", "frozenset", "int", "list", "map", "memoryview", "object", "range", "set", "staticmethod", "str", "super", "tuple", "type"].map(n => ({
        label: n,
        type: "class"
    }))).concat(["abs", "aiter", "all", "anext", "any", "ascii", "bin", "breakpoint", "callable", "chr", "compile", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "exit", "filter", "format", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "isinstance", "issubclass", "iter", "len", "license", "locals", "max", "min", "next", "oct", "open", "ord", "pow", "print", "property", "quit", "repr", "reversed", "round", "setattr", "slice", "sorted", "sum", "vars", "zip"].map(n => ({
        label: n,
        type: "function"
    })));
    const snippets = [snippetCompletion("def ${name}(${params}):\n\t${}", {
        label: "def",
        detail: "function",
        type: "keyword"
    }), snippetCompletion("for ${name} in ${collection}:\n\t${}", {
        label: "for",
        detail: "loop",
        type: "keyword"
    }), snippetCompletion("while ${}:\n\t${}", {
        label: "while",
        detail: "loop",
        type: "keyword"
    }), snippetCompletion("try:\n\t${}\nexcept ${error}:\n\t${}", {
        label: "try",
        detail: "/ except block",
        type: "keyword"
    }), snippetCompletion("if ${}:\n\t\n", {
        label: "if",
        detail: "block",
        type: "keyword"
    }), snippetCompletion("if ${}:\n\t${}\nelse:\n\t${}", {
        label: "if",
        detail: "/ else block",
        type: "keyword"
    }), snippetCompletion("class ${name}:\n\tdef __init__(self, ${params}):\n\t\t\t${}", {
        label: "class",
        detail: "definition",
        type: "keyword"
    }), snippetCompletion("import ${module}", {
        label: "import",
        detail: "statement",
        type: "keyword"
    }), snippetCompletion("from ${module} import ${names}", {
        label: "from",
        detail: "import",
        type: "keyword"
    })];
    const globalCompletion = ifNotIn(dontComplete, completeFromList(globals.concat(snippets)));
    function indentBody(context, node) {
        let base = context.lineIndent(node.from);
        let line = context.lineAt(context.pos, -1),
            to = line.from + line.text.length;
        if (!/\S/.test(line.text) && context.node.to < to + 100 && !/\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base)
            return null;
        if (/^\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
            return null;
        return base + context.unit;
    }
    const pythonLanguage = LRLanguage.define({
        name: "python",
        parser: parser$6.configure({
            props: [indentNodeProp.add({
                Body: context => {
                    var _a;
                    return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue();
                },
                IfStatement: cx => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
                TryStatement: cx => /^\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
                "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": delimitedIndent({
                    closing: ")"
                }),
                "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": delimitedIndent({
                    closing: "}"
                }),
                "ArrayExpression ArrayComprehensionExpression": delimitedIndent({
                    closing: "]"
                }),
                "String FormatString": () => null,
                Script: context => {
                    if (context.pos + /\s*/.exec(context.textAfter)[0].length >= context.node.to) {
                        let endBody = null;
                        for (let cur = context.node, to = cur.to; ;) {
                            cur = cur.lastChild;
                            if (!cur || cur.to != to)
                                break;
                            if (cur.type.name == "Body")
                                endBody = cur;
                        }
                        if (endBody) {
                            let bodyIndent = indentBody(context, endBody);
                            if (bodyIndent != null)
                                return bodyIndent;
                        }
                    }
                    return context.continue();
                }
            }), foldNodeProp.add({
                "ArrayExpression DictionaryExpression SetExpression TupleExpression": foldInside,
                Body: (node, state) => ({
                    from: node.from + 1,
                    to: node.to - (node.to == state.doc.length ? 0 : 1)
                })
            })]
        }),
        languageData: {
            closeBrackets: {
                brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
                stringPrefixes: ["f", "fr", "rf", "r", "u", "b", "br", "rb", "F", "FR", "RF", "R", "U", "B", "BR", "RB"]
            },
            commentTokens: {
                line: "#"
            },
            indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
        }
    });
    function python() {
        return new LanguageSupport(pythonLanguage, [pythonLanguage.data.of({
            autocomplete: localCompletionSource
        }), pythonLanguage.data.of({
            autocomplete: globalCompletion
        })]);
    }
    var _m14 = Object.freeze({
        __proto__: null,
        globalCompletion: globalCompletion,
        localCompletionSource: localCompletionSource,
        python: python,
        pythonLanguage: pythonLanguage
    });
    const whitespace = 36,
        LineComment = 1,
        BlockComment = 2,
        String$1 = 3,
        Number = 4,
        Bool = 5,
        Null = 6,
        ParenL = 7,
        ParenR = 8,
        BraceL = 9,
        BraceR = 10,
        BracketL = 11,
        BracketR = 12,
        Semi = 13,
        Dot$1 = 14,
        Operator = 15,
        Punctuation$1 = 16,
        SpecialVar = 17,
        Identifier$1 = 18,
        QuotedIdentifier = 19,
        Keyword = 20,
        Type$1 = 21,
        Bits = 22,
        Bytes = 23,
        Builtin = 24;
    function isAlpha(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57;
    }
    function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70;
    }
    function readLiteral(input, endQuote, backslashEscapes) {
        for (let escaped = false; ;) {
            if (input.next < 0)
                return;
            if (input.next == endQuote && !escaped) {
                input.advance();
                return;
            }
            escaped = backslashEscapes && !escaped && input.next == 92;
            input.advance();
        }
    }
    function readDoubleDollarLiteral(input) {
        for (;;) {
            if (input.next < 0 || input.peek(1) < 0)
                return;
            if (input.next == 36 && input.peek(1) == 36) {
                input.advance(2);
                return;
            }
            input.advance();
        }
    }
    function readWord(input, result) {
        for (;;) {
            if (input.next != 95 && !isAlpha(input.next))
                break;
            if (result != null)
                result += String.fromCharCode(input.next);
            input.advance();
        }
        return result;
    }
    function readWordOrQuoted(input) {
        if (input.next == 39 || input.next == 34 || input.next == 96) {
            let quote = input.next;
            input.advance();
            readLiteral(input, quote, false);
        } else {
            readWord(input);
        }
    }
    function readBits(input, endQuote) {
        while (input.next == 48 || input.next == 49)
            input.advance();
        if (endQuote && input.next == endQuote)
            input.advance();
    }
    function readNumber(input, sawDot) {
        for (;;) {
            if (input.next == 46) {
                if (sawDot)
                    break;
                sawDot = true;
            } else if (input.next < 48 || input.next > 57) {
                break;
            }
            input.advance();
        }
        if (input.next == 69 || input.next == 101) {
            input.advance();
            if (input.next == 43 || input.next == 45)
                input.advance();
            while (input.next >= 48 && input.next <= 57)
                input.advance();
        }
    }
    function eol(input) {
        while (!(input.next < 0 || input.next == 10))
            input.advance();
    }
    function inString(ch, str) {
        for (let i = 0; i < str.length; i++)
            if (str.charCodeAt(i) == ch)
                return true;
        return false;
    }
    const Space = " \t\r\n";
    function keywords(keywords, types, builtin) {
        let result = Object.create(null);
        result["true"] = result["false"] = Bool;
        result["null"] = result["unknown"] = Null;
        for (let _i258 = 0, _keywords$split = keywords.split(" "), _length258 = _keywords$split.length; _i258 < _length258; _i258++) {
            let kw = _keywords$split[_i258];
            if (kw)
                result[kw] = Keyword;
        }
        for (let _i259 = 0, _types$split = types.split(" "), _length259 = _types$split.length; _i259 < _length259; _i259++) {
            let tp = _types$split[_i259];
            if (tp)
                result[tp] = Type$1;
        }
        for (let _i260 = 0, _split = (builtin || "").split(" "), _length260 = _split.length; _i260 < _length260; _i260++) {
            let kw = _split[_i260];
            if (kw)
                result[kw] = Builtin;
        }
        return result;
    }
    const SQLTypes = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ";
    const SQLKeywords = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ";
    const defaults = {
        backslashEscapes: false,
        hashComments: false,
        spaceAfterDashes: false,
        slashComments: false,
        doubleQuotedStrings: false,
        doubleDollarQuotedStrings: false,
        unquotedBitLiterals: false,
        treatBitsAsBytes: false,
        charSetCasts: false,
        operatorChars: "*+\-%<>!=&|~^/",
        specialVar: "?",
        identifierQuotes: '"',
        words: keywords(SQLKeywords, SQLTypes)
    };
    function dialect(spec, kws, types, builtin) {
        let dialect = {};
        for (let prop in defaults)
            dialect[prop] = (spec.hasOwnProperty(prop) ? spec : defaults)[prop];
        if (kws)
            dialect.words = keywords(kws, types || "", builtin);
        return dialect;
    }
    function tokensFor(d) {
        return new ExternalTokenizer(input => {
            var _a;
            let {next} = input;
            input.advance();
            if (inString(next, Space)) {
                while (inString(input.next, Space))
                    input.advance();
                input.acceptToken(whitespace);
            } else if (next == 36 && input.next == 36 && d.doubleDollarQuotedStrings) {
                readDoubleDollarLiteral(input);
                input.acceptToken(String$1);
            } else if (next == 39 || next == 34 && d.doubleQuotedStrings) {
                readLiteral(input, next, d.backslashEscapes);
                input.acceptToken(String$1);
            } else if (next == 35 && d.hashComments || next == 47 && input.next == 47 && d.slashComments) {
                eol(input);
                input.acceptToken(LineComment);
            } else if (next == 45 && input.next == 45 && (!d.spaceAfterDashes || input.peek(1) == 32)) {
                eol(input);
                input.acceptToken(LineComment);
            } else if (next == 47 && input.next == 42) {
                input.advance();
                for (let prev = -1, depth = 1; ;) {
                    if (input.next < 0)
                        break;
                    input.advance();
                    if (prev == 42 && input.next == 47) {
                        depth--;
                        if (!depth) {
                            input.advance();
                            break;
                        }
                        prev = -1;
                    } else if (prev == 47 && input.next == 42) {
                        depth++;
                        prev = -1;
                    } else {
                        prev = input.next;
                    }
                }
                input.acceptToken(BlockComment);
            } else if ((next == 101 || next == 69) && input.next == 39) {
                input.advance();
                readLiteral(input, 39, true);
            } else if ((next == 110 || next == 78) && input.next == 39 && d.charSetCasts) {
                input.advance();
                readLiteral(input, 39, d.backslashEscapes);
                input.acceptToken(String$1);
            } else if (next == 95 && d.charSetCasts) {
                for (let i = 0; ; i++) {
                    if (input.next == 39 && i > 1) {
                        input.advance();
                        readLiteral(input, 39, d.backslashEscapes);
                        input.acceptToken(String$1);
                        break;
                    }
                    if (!isAlpha(input.next))
                        break;
                    input.advance();
                }
            } else if (next == 40) {
                input.acceptToken(ParenL);
            } else if (next == 41) {
                input.acceptToken(ParenR);
            } else if (next == 123) {
                input.acceptToken(BraceL);
            } else if (next == 125) {
                input.acceptToken(BraceR);
            } else if (next == 91) {
                input.acceptToken(BracketL);
            } else if (next == 93) {
                input.acceptToken(BracketR);
            } else if (next == 59) {
                input.acceptToken(Semi);
            } else if (d.unquotedBitLiterals && next == 48 && input.next == 98) {
                input.advance();
                readBits(input);
                input.acceptToken(Bits);
            } else if ((next == 98 || next == 66) && (input.next == 39 || input.next == 34)) {
                const quoteStyle = input.next;
                input.advance();
                if (d.treatBitsAsBytes) {
                    readLiteral(input, quoteStyle, d.backslashEscapes);
                    input.acceptToken(Bytes);
                } else {
                    readBits(input, quoteStyle);
                    input.acceptToken(Bits);
                }
            } else if (next == 48 && (input.next == 120 || input.next == 88) || (next == 120 || next == 88) && input.next == 39) {
                let quoted = input.next == 39;
                input.advance();
                while (isHexDigit(input.next))
                    input.advance();
                if (quoted && input.next == 39)
                    input.advance();
                input.acceptToken(Number);
            } else if (next == 46 && input.next >= 48 && input.next <= 57) {
                readNumber(input, true);
                input.acceptToken(Number);
            } else if (next == 46) {
                input.acceptToken(Dot$1);
            } else if (next >= 48 && next <= 57) {
                readNumber(input, false);
                input.acceptToken(Number);
            } else if (inString(next, d.operatorChars)) {
                while (inString(input.next, d.operatorChars))
                    input.advance();
                input.acceptToken(Operator);
            } else if (inString(next, d.specialVar)) {
                if (input.next == next)
                    input.advance();
                readWordOrQuoted(input);
                input.acceptToken(SpecialVar);
            } else if (inString(next, d.identifierQuotes)) {
                readLiteral(input, next, false);
                input.acceptToken(QuotedIdentifier);
            } else if (next == 58 || next == 44) {
                input.acceptToken(Punctuation$1);
            } else if (isAlpha(next)) {
                let word = readWord(input, String.fromCharCode(next));
                input.acceptToken(input.next == 46 ? Identifier$1 : (_a = d.words[word.toLowerCase()]) !== null && _a !== void 0 ? _a : Identifier$1);
            }
        });
    }
    const tokens = tokensFor(defaults);
    const parser$1$1 = LRParser.deserialize({
        version: 14,
        states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
        stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
        goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
        nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) [ ] { } ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
        maxTerm: 38,
        skippedNodes: [0, 1, 2],
        repeatNodeCount: 3,
        tokenData: "RORO",
        tokenizers: [0, tokens],
        topRules: {
            "Script": [0, 25]
        },
        tokenPrec: 0
    });
    function tokenBefore(tree) {
        let cursor = tree.cursor().moveTo(tree.from, -1);
        while (/Comment/.test(cursor.name))
            cursor.moveTo(cursor.from, -1);
        return cursor.node;
    }
    function idName(doc, node) {
        let text = doc.sliceString(node.from, node.to);
        let quoted = /^([`'"])(.*)\1$/.exec(text);
        return quoted ? quoted[2] : text;
    }
    function plainID(node) {
        return node && (node.name == "Identifier" || node.name == "QuotedIdentifier");
    }
    function pathFor(doc, id) {
        if (id.name == "CompositeIdentifier") {
            let path = [];
            for (let ch = id.firstChild; ch; ch = ch.nextSibling)
                if (plainID(ch))
                    path.push(idName(doc, ch));
            return path;
        }
        return [idName(doc, id)];
    }
    function parentsFor(doc, node) {
        for (let path = []; ;) {
            if (!node || node.name != ".")
                return path;
            let name = tokenBefore(node);
            if (!plainID(name))
                return path;
            path.unshift(idName(doc, name));
            node = tokenBefore(name);
        }
    }
    function sourceContext(state, startPos) {
        let pos = syntaxTree(state).resolveInner(startPos, -1);
        let aliases = getAliases(state.doc, pos);
        if (pos.name == "Identifier" || pos.name == "QuotedIdentifier" || pos.name == "Keyword") {
            return {
                from: pos.from,
                quoted: pos.name == "QuotedIdentifier" ? state.doc.sliceString(pos.from, pos.from + 1) : null,
                parents: parentsFor(state.doc, tokenBefore(pos)),
                aliases
            };
        }
        if (pos.name == ".") {
            return {
                from: startPos,
                quoted: null,
                parents: parentsFor(state.doc, pos),
                aliases
            };
        } else {
            return {
                from: startPos,
                quoted: null,
                parents: [],
                empty: true,
                aliases
            };
        }
    }
    const EndFrom = new Set("where group having order union intersect except all distinct limit offset fetch for".split(" "));
    function getAliases(doc, at) {
        let statement;
        for (let parent = at; !statement; parent = parent.parent) {
            if (!parent)
                return null;
            if (parent.name == "Statement")
                statement = parent;
        }
        let aliases = null;
        for (let scan = statement.firstChild, sawFrom = false, prevID = null; scan; scan = scan.nextSibling) {
            let kw = scan.name == "Keyword" ? doc.sliceString(scan.from, scan.to).toLowerCase() : null;
            let alias = null;
            if (!sawFrom) {
                sawFrom = kw == "from";
            } else if (kw == "as" && prevID && plainID(scan.nextSibling)) {
                alias = idName(doc, scan.nextSibling);
            } else if (kw && EndFrom.has(kw)) {
                break;
            } else if (prevID && plainID(scan)) {
                alias = idName(doc, scan);
            }
            if (alias) {
                if (!aliases)
                    aliases = Object.create(null);
                aliases[alias] = pathFor(doc, prevID);
            }
            prevID = /Identifier$/.test(scan.name) ? scan : null;
        }
        return aliases;
    }
    function maybeQuoteCompletions(quote, completions) {
        if (!quote)
            return completions;
        return completions.map(c => Object.assign(Object.assign({}, c), {
            label: quote + c.label + quote,
            apply: undefined
        }));
    }
    const Span = /^\w*$/,
        QuotedSpan = /^[`'"]?\w*[`'"]?$/;
    class CompletionLevel {
        constructor()
        {
            this.list = [];
            this.children = undefined;
        }
        child(name)
        {
            let children = this.children || (this.children = Object.create(null));
            return children[name] || (children[name] = new CompletionLevel());
        }
        childCompletions(type)
        {
            return this.children ? Object.keys(this.children).filter(x => x).map(name => ({
                label: name,
                type
            })) : [];
        }
    }
    function completeFromSchema$1(schema, tables, defaultTableName, defaultSchemaName) {
        let top = new CompletionLevel();
        let defaultSchema = top.child(defaultSchemaName || "");
        for (let table in schema) {
            let dot = table.indexOf(".");
            let schemaCompletions = dot > -1 ? top.child(table.slice(0, dot)) : defaultSchema;
            let tableCompletions = schemaCompletions.child(dot > -1 ? table.slice(dot + 1) : table);
            tableCompletions.list = schema[table].map(val => typeof val == "string" ? {
                label: val,
                type: "property"
            } : val);
        }
        defaultSchema.list = (tables || defaultSchema.childCompletions("type")).concat(defaultTableName ? defaultSchema.child(defaultTableName).list : []);
        for (let sName in top.children) {
            let schema = top.child(sName);
            if (!schema.list.length)
                schema.list = schema.childCompletions("type");
        }
        top.list = defaultSchema.list.concat(top.childCompletions("type"));
        return context => {
            let {parents, from, quoted, empty, aliases} = sourceContext(context.state, context.pos);
            if (empty && !context.explicit)
                return null;
            if (aliases && parents.length == 1)
                parents = aliases[parents[0]] || parents;
            let level = top;
            for (let _i261 = 0, _parents = parents, _length261 = _parents.length; _i261 < _length261; _i261++) {
                let name = _parents[_i261];
                while (!level.children || !level.children[name]) {
                    if (level == top)
                        level = defaultSchema;
                    else if (level == defaultSchema && defaultTableName)
                        level = level.child(defaultTableName);
                    else
                        return null;
                }
                level = level.child(name);
            }
            let quoteAfter = quoted && context.state.sliceDoc(context.pos, context.pos + 1) == quoted;
            let options = level.list;
            if (level == top && aliases)
                options = options.concat(Object.keys(aliases).map(name => ({
                    label: name,
                    type: "constant"
                })));
            return {
                from,
                to: quoteAfter ? context.pos + 1 : undefined,
                options: maybeQuoteCompletions(quoted, options),
                validFor: quoted ? QuotedSpan : Span
            };
        };
    }
    function completeKeywords(keywords, upperCase) {
        let completions = Object.keys(keywords).map(keyword => ({
            label: upperCase ? keyword.toUpperCase() : keyword,
            type: keywords[keyword] == Type$1 ? "type" : keywords[keyword] == Keyword ? "keyword" : "variable",
            boost: -1
        }));
        return ifNotIn(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], completeFromList(completions));
    }
    let parser$5 = parser$1$1.configure({
        props: [indentNodeProp.add({
            Statement: continuedIndent()
        }), foldNodeProp.add({
            Statement(tree) {
                return {
                    from: tree.firstChild.to,
                    to: tree.to
                };
            },
            BlockComment(tree) {
                return {
                    from: tree.from + 2,
                    to: tree.to - 2
                };
            }
        }), styleTags({
            Keyword: tags$1.keyword,
            Type: tags$1.typeName,
            Builtin: tags$1.standard(tags$1.name),
            Bits: tags$1.number,
            Bytes: tags$1.string,
            Bool: tags$1.bool,
            Null: tags$1.null,
            Number: tags$1.number,
            String: tags$1.string,
            Identifier: tags$1.name,
            QuotedIdentifier: tags$1.special(tags$1.string),
            SpecialVar: tags$1.special(tags$1.name),
            LineComment: tags$1.lineComment,
            BlockComment: tags$1.blockComment,
            Operator: tags$1.operator,
            "Semi Punctuation": tags$1.punctuation,
            "( )": tags$1.paren,
            "{ }": tags$1.brace,
            "[ ]": tags$1.squareBracket
        })]
    });
    class SQLDialect {
        constructor(dialect, language)
        {
            this.dialect = dialect;
            this.language = language;
        }
        get extension()
        {
            return this.language.extension;
        }
        static define(spec)
        {
            let d = dialect(spec, spec.keywords, spec.types, spec.builtin);
            let language = LRLanguage.define({
                name: "sql",
                parser: parser$5.configure({
                    tokenizers: [{
                        from: tokens,
                        to: tokensFor(d)
                    }]
                }),
                languageData: {
                    commentTokens: {
                        line: "--",
                        block: {
                            open: "/*",
                            close: "*/"
                        }
                    },
                    closeBrackets: {
                        brackets: ["(", "[", "{", "'", '"', "`"]
                    }
                }
            });
            return new SQLDialect(d, language);
        }
    }
    function keywordCompletionSource(dialect, upperCase=false) {
        return completeKeywords(dialect.dialect.words, upperCase);
    }
    function keywordCompletion(dialect, upperCase=false) {
        return dialect.language.data.of({
            autocomplete: keywordCompletionSource(dialect, upperCase)
        });
    }
    function schemaCompletionSource(config) {
        return config.schema ? completeFromSchema$1(config.schema, config.tables, config.defaultTable, config.defaultSchema) : () => null;
    }
    function schemaCompletion(config) {
        return config.schema ? (config.dialect || StandardSQL).language.data.of({
            autocomplete: schemaCompletionSource(config)
        }) : [];
    }
    function sql(config={}) {
        let lang = config.dialect || StandardSQL;
        return new LanguageSupport(lang.language, [schemaCompletion(config), keywordCompletion(lang, !!config.upperCaseKeywords)]);
    }
    const StandardSQL = SQLDialect.define({});
    const PostgreSQL = SQLDialect.define({
        charSetCasts: true,
        doubleDollarQuotedStrings: true,
        operatorChars: "+-*/<>=~!@#%^&|`?",
        specialVar: "",
        keywords: SQLKeywords + "a abort abs absent access according ada admin aggregate alias also always analyse analyze array_agg array_max_cardinality asensitive assert assignment asymmetric atomic attach attribute attributes avg backward base64 begin_frame begin_partition bernoulli bit_length blocked bom c cache called cardinality catalog_name ceil ceiling chain char_length character_length character_set_catalog character_set_name character_set_schema characteristics characters checkpoint class class_origin cluster coalesce cobol collation_catalog collation_name collation_schema collect column_name columns command_function command_function_code comment comments committed concurrently condition_number configuration conflict connection_name constant constraint_catalog constraint_name constraint_schema contains content control conversion convert copy corr cost covar_pop covar_samp csv cume_dist current_catalog current_row current_schema cursor_name database datalink datatype datetime_interval_code datetime_interval_precision db debug defaults defined definer degree delimiter delimiters dense_rank depends derived detach detail dictionary disable discard dispatch dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue document dump dynamic_function dynamic_function_code element elsif empty enable encoding encrypted end_frame end_partition endexec enforced enum errcode error event every exclude excluding exclusive exp explain expression extension extract family file filter final first_value flag floor following force foreach fortran forward frame_row freeze fs functions fusion g generated granted greatest groups handler header hex hierarchy hint id ignore ilike immediately immutable implementation implicit import include including increment indent index indexes info inherit inherits inline insensitive instance instantiable instead integrity intersection invoker isnull k key_member key_type label lag last_value lead leakproof least length library like_regex link listen ln load location lock locked log logged lower m mapping matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text min minvalue mod mode more move multiset mumps name namespace nfc nfd nfkc nfkd nil normalize normalized nothing notice notify notnull nowait nth_value ntile nullable nullif nulls number occurrences_regex octet_length octets off offset oids operator options ordering others over overlay overriding owned owner p parallel parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partition pascal passing passthrough password percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding prepared print_strict_params procedural procedures program publication query quote raise range rank reassign recheck recovery refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex rename repeatable replace replica requiring reset respect restart restore result_oid returned_cardinality returned_length returned_octet_length returned_sqlstate returning reverse routine_catalog routine_name routine_schema routines row_count row_number rowtype rule scale schema_name schemas scope scope_catalog scope_name scope_schema security selective self sensitive sequence sequences serializable server server_name setof share show simple skip slice snapshot source specific_name sqlcode sqlerror sqrt stable stacked standalone statement statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time t table_name tables tablesample tablespace temp template ties token top_level_count transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex trigger_catalog trigger_name trigger_schema trim trim_array truncate trusted type types uescape unbounded uncommitted unencrypted unlink unlisten unlogged unnamed untyped upper uri use_column use_variable user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema vacuum valid validate validator value_of var_pop var_samp varbinary variable_conflict variadic verbose version versioning views volatile warning whitespace width_bucket window within wrapper xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate yes",
        types: SQLTypes + "bigint int8 bigserial serial8 varbit bool box bytea cidr circle precision float8 inet int4 json jsonb line lseg macaddr macaddr8 money numeric pg_lsn point polygon float4 int2 smallserial serial2 serial serial4 text timetz timestamptz tsquery tsvector txid_snapshot uuid xml"
    });
    const MySQLKeywords = "accessible algorithm analyze asensitive authors auto_increment autocommit avg avg_row_length binlog btree cache catalog_name chain change changed checkpoint checksum class_origin client_statistics coalesce code collations columns comment committed completion concurrent consistent contains contributors convert database databases day_hour day_microsecond day_minute day_second delay_key_write delayed delimiter des_key_file dev_pop dev_samp deviance directory disable discard distinctrow div dual dumpfile enable enclosed ends engine engines enum errors escaped even event events every explain extended fast field fields flush force found_rows fulltext grants handler hash high_priority hosts hour_microsecond hour_minute hour_second ignore ignore_server_ids import index index_statistics infile innodb insensitive insert_method install invoker iterate keys kill linear lines list load lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modify mutex mysql_errno no_write_to_binlog offline offset one online optimize optionally outfile pack_keys parser partition partitions password phase plugin plugins prev processlist profile profiles purge query quick range read_write rebuild recover regexp relaylog remove rename reorganize repair repeatable replace require resume rlike row_format rtree schedule schema_name schemas second_microsecond security sensitive separator serializable server share show slave slow snapshot soname spatial sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result ssl starting starts std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace terminated triggers truncate uncommitted uninstall unlock upgrade use use_frm user_resources user_statistics utc_date utc_time utc_timestamp variables views warnings xa xor year_month zerofill";
    const MySQLTypes = SQLTypes + "bool blob long longblob longtext medium mediumblob mediumint mediumtext tinyblob tinyint tinytext text bigint int1 int2 int3 int4 int8 float4 float8 varbinary varcharacter precision datetime unsigned signed";
    const MySQLBuiltin = "charset clear edit ego help nopager notee nowarning pager print prompt quit rehash source status system tee";
    const MySQL = SQLDialect.define({
        operatorChars: "*+-%<>!=&|^",
        charSetCasts: true,
        doubleQuotedStrings: true,
        unquotedBitLiterals: true,
        hashComments: true,
        spaceAfterDashes: true,
        specialVar: "@?",
        identifierQuotes: "`",
        keywords: SQLKeywords + "group_concat " + MySQLKeywords,
        types: MySQLTypes,
        builtin: MySQLBuiltin
    });
    const MariaSQL = SQLDialect.define({
        operatorChars: "*+-%<>!=&|^",
        charSetCasts: true,
        doubleQuotedStrings: true,
        unquotedBitLiterals: true,
        hashComments: true,
        spaceAfterDashes: true,
        specialVar: "@?",
        identifierQuotes: "`",
        keywords: SQLKeywords + "always generated groupby_concat hard persistent shutdown soft virtual " + MySQLKeywords,
        types: MySQLTypes,
        builtin: MySQLBuiltin
    });
    const MSSQL = SQLDialect.define({
        keywords: SQLKeywords + "trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock pivot readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx unpivot updlock with",
        types: SQLTypes + "bigint smallint smallmoney tinyint money real text nvarchar ntext varbinary image hierarchyid uniqueidentifier sql_variant xml",
        builtin: "binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id",
        operatorChars: "*+-%<>!=^&|/",
        specialVar: "@"
    });
    const SQLite = SQLDialect.define({
        keywords: SQLKeywords + "abort analyze attach autoincrement conflict database detach exclusive fail glob ignore index indexed instead isnull notnull offset plan pragma query raise regexp reindex rename replace temp vacuum virtual",
        types: SQLTypes + "bool blob long longblob longtext medium mediumblob mediumint mediumtext tinyblob tinyint tinytext text bigint int2 int8 unsigned signed real",
        builtin: "auth backup bail changes clone databases dbinfo dump echo eqp explain fullschema headers help import imposter indexes iotrace lint load log mode nullvalue once print prompt quit restore save scanstats separator shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width",
        operatorChars: "*+-%<>!=&|/~",
        identifierQuotes: "`\"",
        specialVar: "@:?$"
    });
    const Cassandra = SQLDialect.define({
        keywords: "add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime infinity NaN",
        types: SQLTypes + "ascii bigint blob counter frozen inet list map static text timeuuid tuple uuid varint",
        slashComments: true
    });
    const PLSQL = SQLDialect.define({
        keywords: SQLKeywords + "abort accept access add all alter and any arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body by case cast char_base check close cluster clusters colauth column comment commit compress connected constant constraint crash create current currval cursor data_base database dba deallocate debugoff debugon declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry exception exception_init exchange exclusive exists external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base of off offline on online only option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw rebuild record ref references refresh rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work",
        builtin: "appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define echo editfile embedded feedback flagger flush heading headsep instance linesize lno loboffset logsource longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar repfooter repheader serveroutput shiftinout show showmode spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout timing trimout trimspool ttitle underline verify version wrap",
        types: SQLTypes + "ascii bfile bfilename bigserial bit blob dec long number nvarchar nvarchar2 serial smallint string text uid varchar2 xml",
        operatorChars: "*/+-%<>!=~",
        doubleQuotedStrings: true,
        charSetCasts: true
    });
    var _m17 = Object.freeze({
        __proto__: null,
        Cassandra: Cassandra,
        MSSQL: MSSQL,
        MariaSQL: MariaSQL,
        MySQL: MySQL,
        PLSQL: PLSQL,
        PostgreSQL: PostgreSQL,
        SQLDialect: SQLDialect,
        SQLite: SQLite,
        StandardSQL: StandardSQL,
        keywordCompletion: keywordCompletion,
        keywordCompletionSource: keywordCompletionSource,
        schemaCompletion: schemaCompletion,
        schemaCompletionSource: schemaCompletionSource,
        sql: sql
    });
    const closureParamDelim = 1,
        tpOpen = 2,
        tpClose = 3,
        RawString = 4,
        Float = 5;
    const _b = 98,
        _e = 101,
        _f = 102,
        _r = 114,
        _E = 69,
        Zero = 48,
        Dot = 46,
        Plus = 43,
        Minus = 45,
        Hash = 35,
        Quote = 34,
        Pipe = 124,
        LessThan = 60,
        GreaterThan = 62;
    function isNum(ch) {
        return ch >= 48 && ch <= 57;
    }
    function isNum_(ch) {
        return isNum(ch) || ch == 95;
    }
    const literalTokens = new ExternalTokenizer((input, stack) => {
        if (isNum(input.next)) {
            let isFloat = false;
            do {
                input.advance();
            } while (isNum_(input.next));
            if (input.next == Dot) {
                isFloat = true;
                input.advance();
                if (isNum(input.next)) {
                    do {
                        input.advance();
                    } while (isNum_(input.next));
                } else if (input.next == Dot || input.next > 0x7f || /\w/.test(String.fromCharCode(input.next))) {
                    return;
                }
            }
            if (input.next == _e || input.next == _E) {
                isFloat = true;
                input.advance();
                if (input.next == Plus || input.next == Minus)
                    input.advance();
                if (!isNum_(input.next))
                    return;
                do {
                    input.advance();
                } while (isNum_(input.next));
            }
            if (input.next == _f) {
                let after = input.peek(1);
                if (after == Zero + 3 && input.peek(2) == Zero + 2 || after == Zero + 6 && input.peek(2) == Zero + 4) {
                    input.advance(3);
                    isFloat = true;
                } else {
                    return;
                }
            }
            if (isFloat)
                input.acceptToken(Float);
        } else if (input.next == _b || input.next == _r) {
            if (input.next == _b)
                input.advance();
            if (input.next != _r)
                return;
            input.advance();
            let count = 0;
            while (input.next == Hash) {
                count++;
                input.advance();
            }
            if (input.next != Quote)
                return;
            input.advance();
            content:
            for (;;) {
                if (input.next < 0)
                    return;
                let isQuote = input.next == Quote;
                input.advance();
                if (isQuote) {
                    for (let i = 0; i < count; i++) {
                        if (input.next != Hash)
                            continue content;
                        input.advance();
                    }
                    input.acceptToken(RawString);
                    return;
                }
            }
        }
    });
    const closureParam = new ExternalTokenizer(input => {
        if (input.next == Pipe)
            input.acceptToken(closureParamDelim, 1);
    });
    const tpDelim = new ExternalTokenizer(input => {
        if (input.next == LessThan)
            input.acceptToken(tpOpen, 1);
        else if (input.next == GreaterThan)
            input.acceptToken(tpClose, 1);
    });
    const rustHighlighting = styleTags({
        "const macro_rules struct union enum type fn impl trait let static": tags$1.definitionKeyword,
        "mod use crate": tags$1.moduleKeyword,
        "pub unsafe async mut extern default move": tags$1.modifier,
        "for if else loop while match continue break return await": tags$1.controlKeyword,
        "as in ref": tags$1.operatorKeyword,
        "where _ crate super dyn": tags$1.keyword,
        "self": tags$1.self,
        String: tags$1.string,
        Char: tags$1.character,
        RawString: tags$1.special(tags$1.string),
        Boolean: tags$1.bool,
        Identifier: tags$1.variableName,
        "CallExpression/Identifier": tags$1.function(tags$1.variableName),
        BoundIdentifier: tags$1.definition(tags$1.variableName),
        "FunctionItem/BoundIdentifier": tags$1.function(tags$1.definition(tags$1.variableName)),
        LoopLabel: tags$1.labelName,
        FieldIdentifier: tags$1.propertyName,
        "CallExpression/FieldExpression/FieldIdentifier": tags$1.function(tags$1.propertyName),
        Lifetime: tags$1.special(tags$1.variableName),
        ScopeIdentifier: tags$1.namespace,
        TypeIdentifier: tags$1.typeName,
        "MacroInvocation/Identifier MacroInvocation/ScopedIdentifier/Identifier": tags$1.macroName,
        "MacroInvocation/TypeIdentifier MacroInvocation/ScopedIdentifier/TypeIdentifier": tags$1.macroName,
        "\"!\"": tags$1.macroName,
        UpdateOp: tags$1.updateOperator,
        LineComment: tags$1.lineComment,
        BlockComment: tags$1.blockComment,
        Integer: tags$1.integer,
        Float: tags$1.float,
        ArithOp: tags$1.arithmeticOperator,
        LogicOp: tags$1.logicOperator,
        BitOp: tags$1.bitwiseOperator,
        CompareOp: tags$1.compareOperator,
        "=": tags$1.definitionOperator,
        ".. ... => ->": tags$1.punctuation,
        "( )": tags$1.paren,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace,
        ". DerefOp": tags$1.derefOperator,
        "&": tags$1.operator,
        ", ; ::": tags$1.separator,
        "Attribute/...": tags$1.meta
    });
    const spec_identifier = {
        __proto__: null,
        self: 28,
        super: 32,
        crate: 34,
        impl: 46,
        true: 72,
        false: 72,
        pub: 88,
        in: 92,
        const: 96,
        unsafe: 104,
        async: 108,
        move: 110,
        if: 114,
        let: 118,
        ref: 142,
        mut: 144,
        _: 198,
        else: 200,
        match: 204,
        as: 248,
        return: 252,
        await: 262,
        break: 270,
        continue: 276,
        while: 312,
        loop: 316,
        for: 320,
        macro_rules: 327,
        mod: 334,
        extern: 342,
        struct: 346,
        where: 364,
        union: 379,
        enum: 382,
        type: 390,
        default: 395,
        fn: 396,
        trait: 412,
        use: 420,
        static: 438,
        dyn: 476
    };
    const parser$4 = LRParser.deserialize({
        version: 14,
        states: "$2xQ]Q_OOP$wOWOOO&sQWO'#CnO)WQWO'#I`OOQP'#I`'#I`OOQQ'#Ie'#IeO)hO`O'#C}OOQR'#Ih'#IhO)sQWO'#IuOOQO'#Hk'#HkO)xQWO'#DpOOQR'#Iw'#IwO)xQWO'#DpO*ZQWO'#DpOOQO'#Iv'#IvO,SQWO'#J`O,ZQWO'#EiOOQV'#Hp'#HpO,cQYO'#F{OOQV'#El'#ElOOQV'#Em'#EmOOQV'#En'#EnO.YQ_O'#EkO0_Q_O'#EoO2gQWOOO4QQ_O'#FPO7hQWO'#J`OOQV'#FY'#FYO7{Q_O'#F^O:WQ_O'#FaOOQO'#F`'#F`O=sQ_O'#FcO=}Q_O'#FbO@VQWO'#FgOOQO'#J`'#J`OOQV'#Io'#IoOA]Q_O'#InOEPQWO'#InOOQV'#Fw'#FwOF[QWO'#JuOFcQWO'#F|OOQO'#IO'#IOOGrQWO'#GhOOQV'#Im'#ImOOQV'#Il'#IlOOQV'#Hj'#HjQGyQ_OOOKeQ_O'#DUOKlQYO'#CqOOQP'#I_'#I_OOQV'#Hg'#HgQ]Q_OOOLuQWO'#I`ONsQYO'#DXO!!eQWO'#JuO!!lQWO'#JuO!!vQ_O'#DfO!%]Q_O'#E}O!(sQ_O'#FWO!,ZQWO'#FZO!.^QXO'#FbO!.cQ_O'#EeO!!vQ_O'#FmO!0uQWO'#FoO!0zQWO'#FoO!1PQ^O'#FqO!1WQWO'#JuO!1_QWO'#FtO!1dQWO'#FxO!2WQWO'#JjO!2_QWO'#GOO!2_QWO'#G`O!2_QWO'#GbO!2_QWO'#GsOOQO'#Ju'#JuO!2dQWO'#GhO!2lQYO'#GpO!2_QWO'#GqO!3uQ^O'#GtO!3|QWO'#GuO!4hQWO'#HOP!4sOpO'#CcPOOO)CC})CC}OOOO'#Hi'#HiO!5OO`O,59iOOQV,59i,59iO!5ZQYO,5?aOOQO-E;i-E;iOOQO,5:[,5:[OOQP,59Z,59ZO)xQWO,5:[O)xQWO,5:[O!5oQWO,5?kO!5zQYO,5;qO!6PQYO,5;TO!6hQWO,59QO!7kQXO'#CnO!7xQXO'#I`O!9SQWO'#CoO,^QWO'#EiOOQV-E;n-E;nO!9eQWO'#FsOOQV,5<g,5<gO!9SQWO'#CoO!9jQWO'#CoO!9oQWO'#I`O! yQWO'#JuO!9yQWO'#J`O!:aQWO,5;VOOQO'#In'#InO!0zQWO'#DaO!<aQWO'#DcO!<iQWO,5;ZO.YQ_O,5;ZOOQO,5;[,5;[OOQV'#Er'#ErOOQV'#Es'#EsOOQV'#Et'#EtOOQV'#Eu'#EuOOQV'#Ev'#EvOOQV'#Ew'#EwOOQV'#Ex'#ExOOQV'#Ey'#EyO.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;fO!=PQ_O,5;kO!@gQ_O'#FROOQO,5;l,5;lO!BrQWO,5;pO.YQ_O,5;wOKlQYO,5;gO!D_QWO,5;kO!EOQWO,5;xOOQO,5;x,5;xO!E]QWO,5;xO!EbQ_O,5;xO!GmQWO'#CfO!GrQWO,5<QO!G|Q_O,5<QOOQO,5;{,5;{O!JjQXO'#CnO!K{QXO'#I`OOQS'#Dk'#DkOOQP'#Ir'#IrO!LuQ[O'#IrO!L}QXO'#DjO!M{QWO'#DnO!M{QWO'#DnO!N^QWO'#DnOOQP'#It'#ItO!NcQXO'#ItO# ^Q^O'#DoO# hQWO'#DrO# pQ^O'#DzO# zQ^O'#D|O#!RQWO'#EPO#!^QXO'#FdOOQP'#ES'#ESOOQP'#Iq'#IqO#!lQXO'#JfOOQP'#Je'#JeO#!tQXO,5;}O#!yQXO'#I`O!1PQ^O'#DyO!1PQ^O'#FdO##sQWO,5;|OOQO,5;|,5;|OKlQYO,5;|O#$ZQWO'#FhOOQO,5<R,5<ROOQV,5=l,5=lO#&`QYO'#FzOOQV,5<h,5<hO#&gQWO,5<hO#&nQWO,5=SO!1WQWO,59rO!1dQWO,5<dO#&uQWO,5=iO!2_QWO,5<jO!2_QWO,5<zO!2_QWO,5<|O!2_QWO,5=QO#&|QWO,5=]O#'TQWO,5=SO!2_QWO,5=]O!3|QWO,5=aO#']QWO,5=jOOQO-E;|-E;|O#'hQWO'#JjOOQV-E;h-E;hO#(PQWO'#HRO#(WQ_O,59pOOQV,59p,59pO#(_QWO,59pO#(dQ_O,59pO#)SQZO'#CuO#+[QZO'#CvOOQV'#C|'#C|O#-wQWO'#HTO#.OQYO'#IdOOQO'#Hh'#HhO#.WQWO'#CwO#.WQWO'#CwO#.iQWO'#CwOOQR'#Ic'#IcO#.nQZO'#IbO#1TQYO'#HTO#1qQYO'#H[O#2}QYO'#H_OKlQYO'#H`OOQR'#Hb'#HbO#4ZQWO'#HeO#4`QYO,59]OOQR'#Ib'#IbO#5PQZO'#CtO#7[QYO'#HUO#7aQWO'#HTO#7fQYO'#CrO#8VQWO'#H]O#7fQYO'#HcOOQV-E;e-E;eO#8_QWO,59sOOQV,59{,59{O#8mQYO,5=[OOQV,59},59}O!0zQWO,59}O#;aQWO'#IpOOQO'#Ip'#IpO!1PQ^O'#DhO!0zQWO,5:QO#;hQWO,5;iO#<OQWO,5;rO#<fQ_O,5;rOOQO,5;u,5;uO#@PQ_O,5;|O#BXQWO,5;PO!0zQWO,5<XO#B`QWO,5<ZOOQV,5<Z,5<ZO#BkQWO,5<]O!1PQ^O'#EOOOQQ'#D_'#D_O#BsQWO,59rO#BxQWO,5<`O#B}QWO,5<dOOQO,5@U,5@UO#CVQWO,5=iOOQQ'#Cv'#CvO#C[QYO,5<jO#CmQYO,5<zO#CxQYO,5<|O#DTQYO,5=_O#DcQYO,5=SO#E{QYO'#GQO#FYQYO,5=[O#FmQWO,5=[O#F{QYO,5=[O#HUQYO,5=]O#HdQWO,5=`O!1PQ^O,5=`O#HrQWO'#CnO#ITQWO'#I`OOQO'#Jy'#JyO#IfQWO'#IQO#IkQWO'#GwOOQO'#Jz'#JzO#JSQWO'#GzOOQO'#G|'#G|OOQO'#Jx'#JxO#IkQWO'#GwO#JZQWO'#GxO#J`QWO,5=aO#JeQWO,5=jO!1dQWO,5=jO#'`QWO,5=jPOOO'#Hf'#HfP#JjOpO,58}POOO,58},58}OOOO-E;g-E;gOOQV1G/T1G/TO#JuQWO1G4{O#JzQ^O'#CyPOQQ'#Cx'#CxOOQO1G/v1G/vOOQP1G.u1G.uO)xQWO1G/vO#NTQ!fO'#ETO#N[Q!fO'#EaO#NcQ!fO'#EbO$ kQWO1G1yO$!_Q_O1G1yOOQP1G5V1G5VOOQO1G1]1G1]O$&RQWO1G0oO$&WQWO'#CiO!7xQXO'#I`O!6PQYO1G.lO!5oQWO,5<_O!9SQWO,59ZO!9SQWO,59ZO!5oQWO,5?kO$&iQWO1G0uO$(vQWO1G0wO$*nQWO1G0wO$+UQWO1G0wO$-YQWO1G0wO$-aQWO1G0wO$/bQWO1G0wO$/iQWO1G0wO$1jQWO1G0wO$1qQWO1G0wO$3YQWO1G1QO$5ZQWO1G1VO$5zQ_O'#JcO$8SQWO'#JcOOQO'#Jb'#JbO$8^QWO,5;mOOQO'#Dw'#DwOOQO1G1[1G1[OOQO1G1Y1G1YO$8cQWO1G1cOOQO1G1R1G1RO$8jQ_O'#HrO$:xQWO,5@OO.YQ_O1G1dOOQO1G1d1G1dO$;QQWO1G1dO$;_QWO1G1dO$;dQWO1G1eOOQO1G1l1G1lO$;lQWO1G1lOOQP,5?^,5?^O$;vQ^O,5:kO$<aQXO,5:YO!M{QWO,5:YO!M{QWO,5:YO!1PQ^O,5:gO$=bQWO'#IyOOQO'#Ix'#IxO$=pQWO,5:ZO# ^Q^O,5:ZO$=uQWO'#DsOOQP,5:^,5:^O$>WQWO,5:fOOQP,5:h,5:hO!1PQ^O,5:hO!1PQ^O,5:mO$>]QYO,5<OO$>gQ_O'#HsO$>tQXO,5@QOOQV1G1i1G1iOOQP,5:e,5:eO$>|QXO,5<OO$?[QWO1G1hO$?dQWO'#CnO$?oQWO'#FiOOQO'#Fi'#FiO$?wQWO'#FjO.YQ_O'#FkOOQO'#Ji'#JiO$?|QWO'#JhOOQO'#Jg'#JgO$@UQWO,5<SOOQQ'#Hv'#HvO$@ZQYO,5<fOOQV,5<f,5<fO$@bQYO,5<fOOQV1G2S1G2SO$@iQWO1G2nO$@qQWO1G/^O$@vQWO1G2OO#CVQWO1G3TO$AOQYO1G2UO#CmQYO1G2fO#CxQYO1G2hO$AaQYO1G2lO!2_QWO1G2wO#DcQYO1G2nO#HUQYO1G2wO$AiQWO1G2{O$AnQWO1G3UO!1dQWO1G3UO$AsQWO1G3UOOQV1G/[1G/[O$A{QWO1G/[O$BQQ_O1G/[O#7aQWO,5=oO$BXQYO,5?OO$BmQWO,5?OO$BrQZO'#IeOOQO-E;f-E;fOOQR,59c,59cO#.WQWO,59cO#.WQWO,59cOOQR,5=n,5=nO$E_QYO'#HVO$FwQZO,5=oO!5oQWO,5={O$IZQWO,5=oO$IbQZO,5=vO$KqQYO,5=vO$>]QYO,5=vO$LRQWO'#KRO$L^QWO,5=xOOQR,5=y,5=yO$LcQWO,5=zO$>]QYO,5>PO$>]QYO,5>POOQO1G.w1G.wO$>]QYO1G.wO$LnQYO,5=pO$LvQZO,59^OOQR,59^,59^O$>]QYO,5=wO% YQZO,5=}OOQR,5=},5=}O%#lQWO1G/_O!6PQYO1G/_O#FYQYO1G2vO%#qQWO1G2vO%$PQYO1G2vOOQV1G/i1G/iO%%YQWO,5:SO%%bQ_O1G/lO%*kQWO1G1^O%+RQWO1G1hOOQO1G1h1G1hO$>]QYO1G1hO%+iQ^O'#EgOOQV1G0k1G0kOOQV1G1s1G1sO!!vQ_O1G1sO!0zQWO1G1uO!1PQ^O1G1wO!.cQ_O1G1wOOQP,5:j,5:jO$>]QYO1G/^OOQO'#Cn'#CnO%+vQWO1G1zOOQV1G2O1G2OO%,OQWO'#CnO%,WQWO1G3TO%,]QWO1G3TO%,bQYO'#GQO%,sQWO'#G]O%-UQYO'#G_O%.hQYO'#GXOOQV1G2U1G2UO%/wQWO1G2UO%/|QWO1G2UO$ARQWO1G2UOOQV1G2f1G2fO%/wQWO1G2fO#CpQWO1G2fO%0UQWO'#GdOOQV1G2h1G2hO%0gQWO1G2hO#C{QWO1G2hO%0lQYO'#GSO$>]QYO1G2lO$AdQWO1G2lOOQV1G2y1G2yO%1xQWO1G2yO%3hQ^O'#GkO%3rQWO1G2nO#DfQWO1G2nO%4QQYO,5<lO%4[QYO,5<lO%4jQYO,5<lO%5XQYO,5<lOOQQ,5<l,5<lO!1WQWO'#JuO%5dQYO,5<lO%5lQWO1G2vOOQV1G2v1G2vO%5tQWO1G2vO$>]QYO1G2vOOQV1G2w1G2wO%5tQWO1G2wO%5yQWO1G2wO#HXQWO1G2wOOQV1G2z1G2zO.YQ_O1G2zO$>]QYO1G2zO%6RQWO1G2zOOQO,5>l,5>lOOQO-E<O-E<OOOQO,5=c,5=cOOQO,5=e,5=eOOQO,5=g,5=gOOQO,5=h,5=hO%6aQWO'#J|OOQO'#J{'#J{O%6iQWO,5=fO%6nQWO,5=cO!1dQWO,5=dOOQV1G2{1G2{O$>]QYO1G3UPOOO-E;d-E;dPOOO1G.i1G.iOOQO7+*g7+*gO%7VQYO'#IcO%7nQYO'#IfO%7yQYO'#IfO%8RQYO'#IfO%8^QYO,59eOOQO7+%b7+%bOOQP7+$a7+$aO%8cQ!fO'#JTOOQS'#EX'#EXOOQS'#EY'#EYOOQS'#EZ'#EZOOQS'#JT'#JTO%;UQWO'#EWOOQS'#E`'#E`OOQS'#JR'#JROOQS'#Hn'#HnO%;ZQ!fO,5:oOOQV,5:o,5:oOOQV'#JQ'#JQO%;bQ!fO,5:{OOQV,5:{,5:{O%;iQ!fO,5:|OOQV,5:|,5:|OOQV7+'e7+'eOOQV7+&Z7+&ZO%;pQ!fO,59TOOQO,59T,59TO%>YQWO7+$WO%>_QWO1G1yOOQV1G1y1G1yO!9SQWO1G.uO%>dQWO,5?}O%>nQ_O'#HqO%@|QWO,5?}OOQO1G1X1G1XOOQO7+&}7+&}O%AUQWO,5>^OOQO-E;p-E;pO%AcQWO7+'OO.YQ_O7+'OOOQO7+'O7+'OOOQO7+'P7+'PO%AjQWO7+'POOQO7+'W7+'WOOQP1G0V1G0VO%ArQXO1G/tO!M{QWO1G/tO%BsQXO1G0RO%CkQ^O'#HlO%C{QWO,5?eOOQP1G/u1G/uO%DWQWO1G/uO%D]QWO'#D_OOQO'#Dt'#DtO%DhQWO'#DtO%DmQWO'#I{OOQO'#Iz'#IzO%DuQWO,5:_O%DzQWO'#DtO%EPQWO'#DtOOQP1G0Q1G0QOOQP1G0S1G0SOOQP1G0X1G0XO%EXQXO1G1jO%EdQXO'#FeOOQP,5>_,5>_O!1PQ^O'#FeOOQP-E;q-E;qO$>]QYO1G1jOOQO7+'S7+'SOOQO,5<T,5<TO%ErQWO,5<UO.YQ_O,5<UO%EwQWO,5<VO%FRQWO'#HtO%FdQWO,5@SOOQO1G1n1G1nOOQQ-E;t-E;tOOQV1G2Q1G2QO%FlQYO1G2QO#DcQYO7+(YO$>]QYO7+$xOOQV7+'j7+'jO%FsQWO7+(oO%FxQWO7+(oOOQV7+'p7+'pO%/wQWO7+'pO%F}QWO7+'pO%GVQWO7+'pOOQV7+(Q7+(QO%/wQWO7+(QO#CpQWO7+(QOOQV7+(S7+(SO%0gQWO7+(SO#C{QWO7+(SO$>]QYO7+(WO%GeQWO7+(WO#HUQYO7+(cO%GjQWO7+(YO#DfQWO7+(YOOQV7+(c7+(cO%5tQWO7+(cO%5yQWO7+(cO#HXQWO7+(cOOQV7+(g7+(gO$>]QYO7+(pO%GxQWO7+(pO!1dQWO7+(pOOQV7+$v7+$vO%G}QWO7+$vO%HSQZO1G3ZO%JfQWO1G4jOOQO1G4j1G4jOOQR1G.}1G.}O#.WQWO1G.}O%JkQWO'#KQOOQO'#HW'#HWO%J|QWO'#HXO%KXQWO'#KQOOQO'#KP'#KPO%KaQWO,5=qO%KfQYO'#H[O%LrQWO'#GmO%L}QYO'#CtO%MXQWO'#GmO$>]QYO1G3ZOOQR1G3g1G3gO#7aQWO1G3ZO%M^QZO1G3bO$>]QYO1G3bO& mQYO'#IVO& }QWO,5@mOOQR1G3d1G3dOOQR1G3f1G3fO.YQ_O1G3fOOQR1G3k1G3kO&!VQYO7+$cO&!_QYO'#KOOOQQ'#J}'#J}O&!gQYO1G3[O&!lQZO1G3cOOQQ7+$y7+$yO&${QWO7+$yO&%QQWO7+(bOOQV7+(b7+(bO%5tQWO7+(bO$>]QYO7+(bO#FYQYO7+(bO&%YQWO7+(bO!.cQ_O1G/nO&%hQWO7+%WO$?[QWO7+'SO&%pQWO'#EhO&%{Q^O'#EhOOQU'#Ho'#HoO&%{Q^O,5;ROOQV,5;R,5;RO&&VQWO,5;RO&&[Q^O,5;RO!0zQWO7+'_OOQV7+'a7+'aO&&iQWO7+'cO&&qQWO7+'cO&&xQWO7+$xO&'TQ!fO7+'fO&'[Q!fO7+'fOOQV7+(o7+(oO!1dQWO7+(oO&'cQYO,5<lO&'nQYO,5<lO!1dQWO'#GWO&'|QWO'#JpO&([QWO'#G^O!BxQWO'#G^O&(aQWO'#JpOOQO'#Jo'#JoO&(iQWO,5<wOOQO'#DX'#DXO&(nQYO'#JrO&)}QWO'#JrO$>]QYO'#JrOOQO'#Jq'#JqO&*YQWO,5<yO&*_QWO'#GZO#D^QWO'#G[O&*gQWO'#G[O&*oQWO'#JmOOQO'#Jl'#JlO&*zQYO'#GTOOQO,5<s,5<sO&+PQWO7+'pO&+UQWO'#JtO&+dQWO'#GeO#BxQWO'#GeO&+uQWO'#JtOOQO'#Js'#JsO&+}QWO,5=OO$>]QYO'#GUO&,SQYO'#JkOOQQ,5<n,5<nO&,kQWO7+(WOOQV7+(e7+(eO&.TQ^O'#D|O&._QWO'#GlO&.gQ^O'#JwOOQO'#Gn'#GnO&.nQWO'#JwOOQO'#Jv'#JvO&.vQWO,5=VO&.{QWO'#I`O&/]Q^O'#GmO&/dQWO'#IqO&/rQWO'#GmOOQV7+(Y7+(YO&/zQWO7+(YO$>]QYO7+(YO&0SQYO'#HxO&0hQYO1G2WOOQQ1G2W1G2WOOQQ,5<m,5<mO$>]QYO,5<qO&0pQWO,5<rO&0uQWO7+(bO&1QQWO7+(fO&1XQWO7+(fOOQV7+(f7+(fO.YQ_O7+(fO$>]QYO7+(fO&1dQWO'#IRO&1nQWO,5@hOOQO1G3Q1G3QOOQO1G2}1G2}OOQO1G3P1G3POOQO1G3R1G3ROOQO1G3S1G3SOOQO1G3O1G3OO&1vQWO7+(pO$>]QYO,59fO&2RQ^O'#ISO&2xQYO,5?QOOQR1G/P1G/PO&3QQ!bO,5:pO&3VQ!fO,5:rOOQS-E;l-E;lOOQV1G0Z1G0ZOOQV1G0g1G0gOOQV1G0h1G0hO&3^QWO'#JTOOQO1G.o1G.oOOQV<<Gr<<GrO&3iQWO1G5iO$5zQ_O,5>]O&3qQWO,5>]OOQO-E;o-E;oOOQO<<Jj<<JjO&3{QWO<<JjOOQO<<Jk<<JkO&4SQXO7+%`O&5TQWO,5>WOOQO-E;j-E;jOOQP7+%a7+%aO!1PQ^O,5:`O&5cQWO'#HmO&5wQWO,5?gOOQP1G/y1G/yOOQO,5:`,5:`O&6PQWO,5:`O%DzQWO,5:`O$>]QYO,5<PO&6UQXO,5<PO&6dQXO7+'UO.YQ_O1G1pO&6oQWO1G1pOOQO,5>`,5>`OOQO-E;r-E;rOOQV7+'l7+'lO&6yQWO<<KtO#DfQWO<<KtO&7XQWO<<HdOOQV<<LZ<<LZO!1dQWO<<LZOOQV<<K[<<K[O&7dQWO<<K[O%/wQWO<<K[O&7iQWO<<K[OOQV<<Kl<<KlO%/wQWO<<KlOOQV<<Kn<<KnO%0gQWO<<KnO&7qQWO<<KrO$>]QYO<<KrOOQV<<K}<<K}O%5tQWO<<K}O%5yQWO<<K}O#HXQWO<<K}OOQV<<Kt<<KtO&7yQWO<<KtO$>]QYO<<KtO&8RQWO<<L[O$>]QYO<<L[O&8^QWO<<L[OOQV<<Hb<<HbO$>]QYO7+(uOOQO7+*U7+*UOOQR7+$i7+$iO&8cQWO,5@lOOQO'#Gm'#GmO&8kQWO'#GmO&8vQYO'#IUO&8cQWO,5@lOOQR1G3]1G3]O&:cQYO,5=vO&;rQYO,5=XO&;|QWO,5=XOOQO,5=X,5=XOOQR7+(u7+(uO&<RQZO7+(uO&>eQZO7+(|O&@tQWO,5>qOOQO-E<T-E<TO&APQWO7+)QOOQO<<G}<<G}O&AWQYO'#ITO&AcQYO,5@jOOQQ7+(v7+(vOOQQ<<He<<HeO$>]QYO<<K|OOQV<<K|<<K|O&0uQWO<<K|O&AkQWO<<K|O%5tQWO<<K|O&AsQWO7+%YOOQV<<Hr<<HrOOQO<<Jn<<JnO.YQ_O,5;SO&AzQWO,5;SO.YQ_O'#EjO&BPQWO,5;SOOQU-E;m-E;mO&B[QWO1G0mOOQV1G0m1G0mO&%{Q^O1G0mOOQV<<Jy<<JyO!.cQ_O<<J}OOQV<<J}<<J}OOQV<<Hd<<HdO.YQ_O<<HdO&BaQWO'#FvO&BfQWO<<KQO&BnQ!fO<<KQO&BuQWO<<KQO&BzQWO<<KQO&CSQ!fO<<KQOOQV<<KQ<<KQO&CZQWO<<LZO&C`QWO,5@[O$>]QYO,5<xO&ChQWO,5<xO&CmQWO'#H{O&C`QWO,5@[OOQV1G2c1G2cO&DRQWO,5@^O$>]QYO,5@^O&D^QYO'#H|O&EsQWO,5@^OOQO1G2e1G2eO%,nQWO,5<uOOQO,5<v,5<vO&E{QYO'#HzO&G_QWO,5@XO%,bQYO,5=pO$>]QYO,5<oO&GjQWO,5@`O.YQ_O,5=PO&GrQWO,5=PO&G}QWO,5=PO&H`QWO'#H}O&GjQWO,5@`OOQV1G2j1G2jO&HtQYO,5<pO%0lQYO,5>PO&I]QYO,5@VOOQV<<Kr<<KrO&ItQWO,5=XO&KfQ^O,5:hO&KmQWO,5=XO$>]QYO,5=WO&KuQWO,5@cO&K}QWO,5@cO&MvQ^O'#IPO&KuQWO,5@cOOQO1G2q1G2qO&NTQWO,5=WO&N]QWO<<KtO&NkQYO,5>oO&NvQYO,5>dO' UQYO,5>dOOQQ,5>d,5>dOOQQ-E;v-E;vOOQQ7+'r7+'rO' aQYO1G2]O$>]QYO1G2^OOQV<<LQ<<LQO.YQ_O<<LQO' lQWO<<LQO' sQWO<<LQOOQO,5>m,5>mOOQO-E<P-E<POOQV<<L[<<L[O.YQ_O<<L[O'!OQYO1G/QO'!ZQYO,5>nOOQQ,5>n,5>nO'!fQYO,5>nOOQQ-E<Q-E<QOOQS1G0[1G0[O'$tQ!fO1G0^O'%RQ!fO1G0^O'%YQWO1G3wOOQOAN@UAN@UO'%dQWO1G/zOOQO,5>X,5>XOOQO-E;k-E;kO!1PQ^O1G/zOOQO1G/z1G/zO'%oQWO1G/zO'%tQXO1G1kO$>]QYO1G1kO'&PQWO7+'[OOQVANA`ANA`O'&ZQWOANA`O$>]QYOANA`O'&cQWOANA`OOQVAN>OAN>OO.YQ_OAN>OO'&qQWOANAuOOQVAN@vAN@vO'&vQWOAN@vOOQVANAWANAWOOQVANAYANAYOOQVANA^ANA^O'&{QWOANA^OOQVANAiANAiO%5tQWOANAiO%5yQWOANAiO''TQWOANA`OOQVANAvANAvO.YQ_OANAvO''cQWOANAvO$>]QYOANAvOOQR<<La<<LaO''nQWO1G6WO%JkQWO,5>pOOQO'#HY'#HYO''vQWO'#HZOOQO,5>p,5>pOOQO-E<S-E<SO'(RQYO1G2sO'(]QWO1G2sOOQO1G2s1G2sO$>]QYO<<LaOOQR<<Ll<<LlOOQQ,5>o,5>oOOQQ-E<R-E<RO&0uQWOANAhOOQVANAhANAhO%5tQWOANAhO$>]QYOANAhO'(bQWO1G1rO')UQ^O1G0nO.YQ_O1G0nO'*zQWO,5;UO'+RQWO1G0nP'+WQWO'#ERP&%{Q^O'#HpOOQV7+&X7+&XO'+cQWO7+&XO&&qQWOAN@iO'+hQWOAN>OO!5oQWO,5<bOOQS,5>a,5>aO'+oQWOAN@lO'+tQWOAN@lOOQS-E;s-E;sOOQVAN@lAN@lO'+|QWOAN@lOOQVANAuANAuO',UQWO1G5vO',^QWO1G2dO$>]QYO1G2dO&'|QWO,5>gOOQO,5>g,5>gOOQO-E;y-E;yO',iQWO1G5xO',qQWO1G5xO&(nQYO,5>hO',|QWO,5>hO$>]QYO,5>hOOQO-E;z-E;zO'-XQWO'#JnOOQO1G2a1G2aOOQO,5>f,5>fOOQO-E;x-E;xO&'cQYO,5<lO'-gQYO1G2ZO'.RQWO1G5zO'.ZQWO1G2kO.YQ_O1G2kO'.eQWO1G2kO&+UQWO,5>iOOQO,5>i,5>iOOQO-E;{-E;{OOQQ,5>c,5>cOOQQ-E;u-E;uO'.pQWO1G2sO'/QQWO1G2rO'/]QWO1G5}O'/eQ^O,5>kOOQO'#Go'#GoOOQO,5>k,5>kO'/lQWO,5>kOOQO-E;}-E;}O$>]QYO1G2rO'/zQYO7+'xO'0VQWOANAlOOQVANAlANAlO.YQ_OANAlO'0^QWOANAvOOQS7+%x7+%xO'0eQWO7+%xO'0pQ!fO7+%xO'0}QWO7+%fO!1PQ^O7+%fO'1YQXO7+'VOOQVG26zG26zO'1eQWOG26zO'1sQWOG26zO$>]QYOG26zO'1{QWOG23jOOQVG27aG27aOOQVG26bG26bOOQVG26xG26xOOQVG27TG27TO%5tQWOG27TO'2SQWOG27bOOQVG27bG27bO.YQ_OG27bO'2ZQWOG27bOOQO1G4[1G4[OOQO7+(_7+(_OOQRANA{ANA{OOQVG27SG27SO%5tQWOG27SO&0uQWOG27SO'2fQ^O7+&YO'4PQWO7+'^O'4sQ^O7+&YO.YQ_O7+&YP.YQ_O,5;SP'6PQWO,5;SP'6UQWO,5;SOOQV<<Is<<IsOOQVG26TG26TOOQVG23jG23jOOQO1G1|1G1|OOQVG26WG26WO'6aQWOG26WP&B}QWO'#HuO'6fQWO7+(OOOQO1G4R1G4RO'6qQWO7++dO'6yQWO1G4SO$>]QYO1G4SO%,nQWO'#HyO'7UQWO,5@YO'7dQWO7+(VO.YQ_O7+(VOOQO1G4T1G4TOOQO1G4V1G4VO'7nQWO1G4VO'7|QWO7+(^OOQVG27WG27WO'8XQWOG27WOOQS<<Id<<IdO'8`QWO<<IdO'8kQWO<<IQOOQVLD,fLD,fO'8vQWOLD,fO'9OQWOLD,fOOQVLD)ULD)UOOQVLD,oLD,oOOQVLD,|LD,|O'9^QWOLD,|O.YQ_OLD,|OOQVLD,nLD,nO%5tQWOLD,nO'9eQ^O<<ItO';OQWO<<JxO';rQ^O<<ItP'=OQWO1G0nP'=oQ^O1G0nP.YQ_O1G0nP'?bQWO1G0nOOQVLD+rLD+rO'?gQWO7+)nOOQO,5>e,5>eOOQO-E;w-E;wO'?rQWO<<KqOOQVLD,rLD,rOOQSAN?OAN?OOOQV!$(!Q!$(!QO'?|QWO!$(!QOOQV!$(!h!$(!hO'@UQWO!$(!hOOQV!$(!Y!$(!YO'@]Q^OAN?`POQU7+&Y7+&YP'AvQWO7+&YP'BgQ^O7+&YP.YQ_O7+&YOOQV!)9El!)9ElOOQV!)9FS!)9FSPOQU<<It<<ItP'DYQWO<<ItP'DyQ^O<<ItPOQUAN?`AN?`O'FlQWO'#CnO'FsQXO'#CnO'GlQWO'#I`O'IRQXO'#I`O'IxQWO'#DpO'IxQWO'#DpO!.cQ_O'#EkO'JZQ_O'#EoO'JbQ_O'#FPO'MfQ_O'#FbO'MmQXO'#I`O'NdQ_O'#E}O( gQ_O'#FWO'IxQWO,5:[O'IxQWO,5:[O!.cQ_O,5;ZO!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;fO(!jQ_O,5;kO(%nQWO,5;kO(&OQWO,5;|O(&VQYO'#CuO(&bQYO'#CvO(&mQWO'#CwO(&mQWO'#CwO('OQYO'#CtO('ZQWO,5;iO('bQWO,5;rO('iQ_O,5;rO((oQ_O,5;|O'IxQWO1G/vO((vQWO1G0uO(*eQWO1G0wO(*oQWO1G0wO(,dQWO1G0wO(,kQWO1G0wO(.]QWO1G0wO(.dQWO1G0wO(0UQWO1G0wO(0]QWO1G0wO(0dQWO1G1QO(0tQWO1G1VO(1UQYO'#IeO(&mQWO,59cO(&mQWO,59cO(1aQWO1G1^O(1hQWO1G1hO(&mQWO1G.}O(1oQWO'#DpO!.^QXO'#FbO(1tQWO,5;ZO(1{QWO'#Cw",
        stateData: "(2_~O&|OSUOS&}PQ~OPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q`O'TQO'ZkO'^UO'gcO'qiO(QdO~O&}!sO~OZbX[bXdbXdlXobXwjX}bX!lbX!qbX!tbX#ObX#PbX#pbX'gbX'qbX'rbX'xbX'ybX'zbX'{bX'|bX'}bX(ObX(PbX(QbX(RbX(TbX~OybXXbX!ebX!PbXvbX#RbX~P$|OZ'SX['SXd'SXd'XXo'SXw'kXy'SX}'SX!l'SX!q'SX!t'SX#O'SX#P'SX#p'SX'g'SX'q'SX'r'SX'x'SX'y'SX'z'SX'{'SX'|'SX'}'SX(O'SX(P'SX(Q'SX(R'SX(T'SXv'SX~OX'SX!e'SX!P'SX#R'SX~P'ZOr!uO']!wO'_!uO~Od!xO~O^RO_RO`ROaRO'TQO~Od!}O~Od#PO[(SXo(SXy(SX}(SX!l(SX!q(SX!t(SX#O(SX#P(SX#p(SX'g(SX'q(SX'r(SX'x(SX'y(SX'z(SX'{(SX'|(SX'}(SX(O(SX(P(SX(Q(SX(R(SX(T(SXv(SX~OZ#OO~P*`OZ#RO[#QO~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q#VO'T#SO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!j#eO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xO[#}Oo#xO}#zO!l#yO!q#jO!t#yO#O#xO#P#uO#p$OO'g#gO'q#yO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~OPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sXo#sXy#sX}#sX!l#sX!q#sX!t#sX#O#sX#P#sX#p#sX'g#sX'q#sX'r#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sXX#sX!e#sX!P#sXv#sX#R#sX~P)xOX(SX!e(SX!P(SXw(SX#R(SX~P*`OPoOQ!QOSVOTVOX$ROZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!P$XO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOQ!QOSVOTVO[$gO^$pO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O!j$rOP(XP~P<cOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Q$uO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOw$vO~Oo'bX#O'bX#P'bX#p'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(R'bX(T'bX~OP%tXQ%tXS%tXT%tXZ%tX[%tX^%tX_%tX`%tXa%tXd%tXg%tXs%tXt%tXu%tXw%tXy%tX|%tX}%tX!Q%tX!U%tX!W%tX!X%tX!Z%tX!]%tX!l%tX!q%tX!t%tX#Y%tX#r%tX#{%tX$O%tX$b%tX$d%tX$f%tX$i%tX$m%tX$q%tX$s%tX%T%tX%V%tX%Z%tX%]%tX%^%tX%f%tX%j%tX%s%tX&z%tX'Q%tX'T%tX'Z%tX'^%tX'g%tX'q%tX(Q%tXv%tX~P@[Oy$xO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bXv'bX~P@[Ow$yO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Oy$zO~PEsO!Q$}O!U%UO!W!lO$m%OO$q%PO$s%QO%T%RO%V%SO%Z%TO%]!lO%^%VO%f%WO%j%XO%s%YO~O!Q!lO!U!lO!W!lO$q%[O%]!lO~O%^%VO~PGaOPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q#VO'TQO'ZkO'^UO'gcO'qiO(QdO~Ov%`O~P]OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~P'ZO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~O}%}O'T{XQ{XZ{X[{X^{X_{X`{Xa{Xd{Xg{X!q{X$f{X&W{X'Z{X(Q{X~PMuOg&PO%f%WO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Ow!PO~P! yOw!PO!X&RO~PEvOPoOQ!QOSVOTVOZeO[lO^9qO_9qO`9qOa9qOd9tOsVOtVOuVOw!PO}mO!U#bO!W#cO!X:zO!Z!YO!]&UO!l9wO!q9vO!t9wO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'T9oO'ZkO'^UO'gcO'q9wO(QdO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#qXy#qX#O#qX#P#qX#p#qX'r#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qXX#qX!e#qX!P#qXv#qX#R#qX~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#zXy#zX#O#zX#P#zX#p#zX'r#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zXX#zX!e#zX!P#zXv#zX#R#zX~P)xO'ZkO[#}Xo#}Xy#}X}#}X!l#}X!q#}X!t#}X#O#}X#P#}X#p#}X'g#}X'q#}X'r#}X'x#}X'y#}X'z#}X'{#}X'|#}X'}#}X(O#}X(P#}X(Q#}X(R#}X(T#}XX#}X!e#}X!P#}Xv#}Xw#}X#R#}X~OPoO~OPoOQ!QOSVOTVOZeO[lO^9qO_9qO`9qOa9qOd9tOsVOtVOuVOw!PO}mO!U#bO!W#cO!X:zO!Z!YO!l9wO!q9vO!t9wO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'T9oO'ZkO'^UO'gcO'q9wO(QdO~O!S&_O~Ow!PO~O!j&bO~P<cO'T&cO~PEvOZ&eO~O'T&cO~O'^UOw(^Xy(^X!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Oa&hO~P!1iO'T&iO~O_&nO'T&cO~OQ&oOZ&pO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO!j&uO~P<cO^&wO_&wO`&wOa&wOd'POw&|O'T&vO(Q&}O~O!i'UO!j'TO'T&cO~O&}!sO'O'VO'P'XO~Or!uO']'ZO'_!uO~OQ']O^'ia_'ia`'iaa'ia'T'ia~O['cOw'dO}'bO~OQ']O~OQ!QO^#TO_#TO`#TOa'kOd#ZO'T#SO~O['lO~OZbXdlXXbXobXPbX!SbX!ebX'rbX!PbX!ObXybX!ZbX#RbXvbX~O[bXwbX}bX~P!6mOZ'SXd'XXX'SX['SXo'SXw'SX}'SX#p'SXP'SX!S'SX!e'SX'r'SX!P'SX!O'SXy'SX!Z'SX#R'SXv'SX~O^#TO_#TO`#TOa'kO'T#SO~OZ'mO~Od'oO~OZ'SXd'XX~PMuOZ'pOX(SX!e(SX!P(SXw(SX#R(SX~P*`O[#}O}#zO(O#|O(R#fOo#_ay#_a!l#_a!q#_a!t#_a#O#_a#P#_a#p#_a'g#_a'q#_a'r#_a'x#_a'y#_a'z#_a'{#_a'|#_a'}#_a(P#_a(Q#_a(T#_aX#_a!e#_a!P#_av#_aw#_a#R#_a~Ow!PO!X&RO~Oy#caX#ca!e#ca!P#cav#ca#R#ca~P2gOPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sao#say#sa}#sa!l#sa!q#sa!t#sa#O#sa#P#sa#p#sa'g#sa'q#sa'r#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#saX#sa!e#sa!P#sav#sa#R#sa~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO!P(UP~P)xOu(SO#w(TO'T(RO~O[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#sa!t#sa#p#sa'q#sa~Oo#xO#O#xO#P#uOy#saX#sa!e#sa!P#sav#sa#R#sa~P!B}Oy(YO!e(WOX(WX~P2gOX(ZO~OPoOQ!QOSVOTVOX(ZOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOZ#RO~O!P(_O!e(WO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOZbXdlXwjX}jX!tbX'qbX~OP!RX!S!RX!e!RX'p!RX'r!RX!O!RXo!RXy!RX!P!RXX!RX!Z!RX#R!RXv!RX~P!JUOZ'SXd'XXw'kX}'kX!t'SX'q'SX~OP!`X!S!`X!e!`X'r!`X!O!`Xo!`Xy!`X!P!`XX!`X!Z!`X#R!`Xv!`X~P!KgOT(aOu(aO~O!t(bO'q(bOP!^X!S!^X!e!^X'r!^X!O!^Xo!^Xy!^X!P!^XX!^X!Z!^X#R!^Xv!^X~O^9rO_9rO`9yOa9yO'T9pO~Od(eO~O'p(fOP'hX!S'hX!e'hX'r'hX!O'hXo'hXy'hX!P'hXX'hX!Z'hX#R'hXv'hX~O!j&bO!P'lP~P<cOw(kO}(jO~O!j&bOX'lP~P<cO!j(oO~P<cOZ'pO!t(bO'q(bO~O!S(qO'r(pOP$WX!e$WX~O!e(rOP(YX~OP(tO~OP!aX!S!aX!e!aX'r!aX!O!aXo!aXy!aX!P!aXX!aX!Z!aX#R!aXv!aX~P!KgOy$UaX$Ua!e$Ua!P$Uav$Ua#R$Ua~P2gO!l(|O'Q#VO'T(xOv(ZP~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q`O'T#SO~Ov)TO~P#$iOy)VO~PEsO%^)WO~PGaOa)ZO~P!1iO%f)`O~PEvO_)aO'T&cO~O!i)fO!j)eO'T&cO~O'^UO!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Ov%uX~P2gOv)gO~PGyOv)gO~Ov)gO~P]OQiXQ'XXZiXd'XX}iX#piX(PiX~ORiXwiX$fiX$|iX[iXoiXyiX!liX!qiX!tiX#OiX#PiX'giX'qiX'riX'xiX'yiX'ziX'{iX'|iX'}iX(OiX(QiX(RiX(TiX!PiX!eiXXiXPiXviX!SiX#RiX~P#(kOQjXQlXRjXZjXdlX}jX#pjX(PjXwjX$fjX$|jX[jXojXyjX!ljX!qjX!tjX#OjX#PjX'gjX'qjX'rjX'xjX'yjX'zjX'{jX'|jX'}jX(OjX(QjX(RjX(TjX!PjX!ejXXjX!SjXPjXvjX#RjX~O%^)jO~PGaOQ']Od)kO~O^)mO_)mO`)mOa)mO'T%dO~Od)qO~OQ']OZ)uO})sOR'UX#p'UX(P'UXw'UX$f'UX$|'UX['UXo'UXy'UX!l'UX!q'UX!t'UX#O'UX#P'UX'g'UX'q'UX'r'UX'x'UX'y'UX'z'UX'{'UX'|'UX'}'UX(O'UX(Q'UX(R'UX(T'UX!P'UX!e'UXX'UXP'UXv'UX!S'UX#R'UX~OQ!QO^:bO_:^O`TOaTOd:aO%^)jO'T:_O~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!j)yO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!P)|O!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO(P*OO~OR*QO#p*RO(P*PO~OQhXQ'XXZhXd'XX}hX(PhX~ORhX#phXwhX$fhX$|hX[hXohXyhX!lhX!qhX!thX#OhX#PhX'ghX'qhX'rhX'xhX'yhX'zhX'{hX'|hX'}hX(OhX(QhX(RhX(ThX!PhX!ehXXhXPhXvhX!ShX#RhX~P#4kOQ*SO~O})sO~OQ!QO^%vO_%cO`TOaTOd%jO$f%wO%^%xO'T%dO~PGaO!Q*VO!j*VO~O^*YO`*YOa*YO!O*ZO~OQ&oOZ*[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO[#}Oo:YO}#zO!l:ZO!q#jO!t:ZO#O:YO#P:VO#p$OO'g#gO'q:ZO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~Ow'dX~P#9vOy#qaX#qa!e#qa!P#qav#qa#R#qa~P2gOy#zaX#za!e#za!P#zav#za#R#za~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!S&_O!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#zay#za#O#za#P#za#p#za'r#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#zaX#za!e#za!P#zav#za#R#za~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Q*eO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOw*fO~P#9vO$b*iO$d*jO$f*kO~O!O*lO'r(pO~O!S*nO~O'T*oO~Ow$yOy*qO~O'T*rO~OQ*uOw*vOy*yO}*wO$|*xO~OQ*uOw*vO$|*xO~OQ*uOw+QO$|*xO~OQ*uOo+VOy+XO!S+UO~OQ*uO}+ZO~OQ!QOZ%rO[%qO^%vO`TOaTOd%jOg%yO}%pO!U!lO!W!lO!q%oO$f%wO$q%[O%]!lO%^%xO&W%{O'T%dO'Z%eO(Q%zO~OR+bO_+^O!Q+cO~P#DkO_%cO!Q!lOw&UX$|&UX(P&UX~P#DkOw$yO$f+hO$|*xO(P*PO~OQ!QOZ*[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOQ*uOw$yO!S+UO$|*xO~Oo+nOy+mO!S+oO'r(pO~OdlXy!RX#pbXv!RX!e!RX~Od'XXy(mX#p'SXv(mX!e(mX~Od+qO~O^#TO_#TO`#TOa'kOw&|O'T&vO(Q+vO~Ov(oP~P!3|O#p+{O~Oy+|O~O!S+}O~O&}!sO'O'VO'P,PO~Od,QO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'^UO~P#DkOS,^OT,^OZ,^O['cO_,YOd,^Oo,^Os,^Ou,^Ow'dOy,^O}'bO!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'v,_O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O(P,`O(Q,`O(R,aO~O!P,dO~P#KkOX,gO~P#KkOv,iO~P#KkOo'tX#O'tX#P'tX#p'tX'r'tX'x'tX'y'tX'z'tX'{'tX'|'tX'}'tX(O'tX(P'tX(R'tX(T'tX~Oy,jO['tX}'tX!l'tX!q'tX!t'tX'g'tX'q'tX(Q'tXv'tX~P#NjOP$giQ$giS$giT$giZ$gi[$gi^$gi_$gi`$gia$gid$gig$gis$git$giu$giw$giy$gi|$gi}$gi!Q$gi!U$gi!W$gi!X$gi!Z$gi!]$gi!l$gi!q$gi!t$gi#Y$gi#r$gi#{$gi$O$gi$b$gi$d$gi$f$gi$i$gi$m$gi$q$gi$s$gi%T$gi%V$gi%Z$gi%]$gi%^$gi%f$gi%j$gi%s$gi&z$gi'Q$gi'T$gi'Z$gi'^$gi'g$gi'q$gi(Q$giv$gi~P#NjOX,kO~O['cOo,lOw'dO}'bOX]X~Oy#ciX#ci!e#ci!P#civ#ci#R#ci~P2gO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'g#ei(P#ei~P$'PO[#}O}#zO(O#|O(R#fOo#eiy#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'g#ei'x#ei(P#ei(Q#ei(T#eiw#ei~P$)QO'g#gO(P#gO~P$'PO[#}O}#zO'g#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O!q#ei~P$+`O!q#jO~P$+`O[#}O}#zO!q#jO'g#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'r#ei~P$-hO'r#lO~P$-hO[#}O}#zO!q#jO#P#uO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#p#ei'q#ei'|#eiX#ei!e#ei!P#eiv#ei#R#ei~O'}#ei~P$/pO'}#mO~P$/pO[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#ni!t#ni#p#ni'q#ni~Oo#xO#O#xO#P#uOy#niX#ni!e#ni!P#niv#ni#R#ni~P$1xO[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#si!t#si#p#si'q#si~Oo#xO#O#xO#P#uOy#siX#si!e#si!P#siv#si#R#si~P$3yOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO~P)xO!e,sO!P(VX~P2gO!P,uO~OX,vO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOX&fX!e&fX!P&fX~P)xO!e(WOX(Wa~Oy,zO!e(WOX(WX~P2gOX,{O~O!P,|O!e(WO~O!P-OO!e(WO~P2gOSVOTVOsVOtVOuVO'^UO'g$[O~P!6POP!baZca!S!ba!e!ba!tca'qca'r!ba!O!bao!bay!ba!P!baX!ba!Z!ba#R!bav!ba~O!e-TO'r(pO!P'mXX'mX~O!P-VO~O!i-`O!j-_O!l-[O'T-XOv'nP~OX-aO~O_%cO!Q!lO~P#DkO!j-gOP&gX!e&gX~P<cO!e(rOP(Ya~O!S-iO'r(pOP$Wa!e$Wa~Ow!PO(P*PO~OvbX!S!kX!ebX~O'Q#VO'T(xO~O!S-mO~O!e-oOv([X~Ov-qO~Ov-sO~P,cOv-sO~P#$iO_-uO'T&cO~O!S-vO~Ow$yOy-wO~OQ*uOw*vOy-zO}*wO$|*xO~OQ*uOo.UO~Oy._O~O!S.`O~O!j.bO'T&cO~Ov.cO~Ov.cO~PGyOQ']O^'Wa_'Wa`'Waa'Wa'T'Wa~Od.gO~OQ'XXQ'kXR'kXZ'kXd'XX}'kX#p'kX(P'kXw'kX$f'kX$|'kX['kXo'kXy'kX!l'kX!q'kX!t'kX#O'kX#P'kX'g'kX'q'kX'r'kX'x'kX'y'kX'z'kX'{'kX'|'kX'}'kX(O'kX(Q'kX(R'kX(T'kX!P'kX!e'kXX'kXP'kXv'kX!S'kX#R'kX~OQ!QOZ%rO[%qO^.rO_%cO`TOaTOd%jOg%yO}%pO!j.sO!q.pO!t.kO#V.mO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P(sP~PGaO#Q.tOR%wa#p%wa(P%waw%wa$f%wa$|%wa[%wao%way%wa}%wa!l%wa!q%wa!t%wa#O%wa#P%wa'g%wa'q%wa'r%wa'x%wa'y%wa'z%wa'{%wa'|%wa'}%wa(O%wa(Q%wa(R%wa(T%wa!P%wa!e%waX%waP%wav%wa!S%wa#R%wa~O%^.vO~PGaO(P*POR&Oa#p&Oaw&Oa$f&Oa$|&Oa[&Oao&Oay&Oa}&Oa!l&Oa!q&Oa!t&Oa#O&Oa#P&Oa'g&Oa'q&Oa'r&Oa'x&Oa'y&Oa'z&Oa'{&Oa'|&Oa'}&Oa(O&Oa(Q&Oa(R&Oa(T&Oa!P&Oa!e&OaX&OaP&Oav&Oa!S&Oa#R&Oa~O_%cO!Q!lO!j.xO(P*OO~P#DkO!e.yO(P*PO!P(uX~O!P.{O~OX.|Oy.}O(P*PO~O'Z%eOR(qP~OQ']O})sORfa#pfa(Pfawfa$ffa$|fa[faofayfa!lfa!qfa!tfa#Ofa#Pfa'gfa'qfa'rfa'xfa'yfa'zfa'{fa'|fa'}fa(Ofa(Qfa(Rfa(Tfa!Pfa!efaXfaPfavfa!Sfa#Rfa~OQ']O})sOR&Va#p&Va(P&Vaw&Va$f&Va$|&Va[&Vao&Vay&Va!l&Va!q&Va!t&Va#O&Va#P&Va'g&Va'q&Va'r&Va'x&Va'y&Va'z&Va'{&Va'|&Va'}&Va(O&Va(Q&Va(R&Va(T&Va!P&Va!e&VaX&VaP&Vav&Va!S&Va#R&Va~O!P/UO~Ow$yO$f/ZO$|*xO(P*PO~OQ!QOZ/[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOo/^O'r(pO~O#W/_OP!YiQ!YiS!YiT!YiZ!Yi[!Yi^!Yi_!Yi`!Yia!Yid!Yig!Yio!Yis!Yit!Yiu!Yiw!Yiy!Yi|!Yi}!Yi!Q!Yi!U!Yi!W!Yi!X!Yi!Z!Yi!]!Yi!l!Yi!q!Yi!t!Yi#O!Yi#P!Yi#Y!Yi#p!Yi#r!Yi#{!Yi$O!Yi$b!Yi$d!Yi$f!Yi$i!Yi$m!Yi$q!Yi$s!Yi%T!Yi%V!Yi%Z!Yi%]!Yi%^!Yi%f!Yi%j!Yi%s!Yi&z!Yi'Q!Yi'T!Yi'Z!Yi'^!Yi'g!Yi'q!Yi'r!Yi'x!Yi'y!Yi'z!Yi'{!Yi'|!Yi'}!Yi(O!Yi(P!Yi(Q!Yi(R!Yi(T!YiX!Yi!e!Yi!P!Yiv!Yi!i!Yi!j!Yi#V!Yi#R!Yi~Oy#ziX#zi!e#zi!P#ziv#zi#R#zi~P2gOy$UiX$Ui!e$Ui!P$Uiv$Ui#R$Ui~P2gOv/eO!j&bO'Q`O~P<cOw/nO}/mO~Oy!RX#pbX~Oy/oO~O#p/pO~OR+bO_+dO!Q/sO'T&iO'Z%eO~Oa/zO|!VO'Q#VO'T(ROv(cP~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P(eP~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zOw(`Py(`P~PGaOw*vO~Oy-zO$|*xO~Oa/zO|!VO'Q#VO'T*oOv(gP~Ow+QO~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zO(R0`O~PGaOy0dO~OQ!QOSVOTVO[$gO^0lO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j0mO!l$lO!q0eO!t0hO'Q#VO'T$YO'Z%eO'^UO'g$[O~O#V0nO!P(jP~P%1}Ow!POy0pO#Q0rO$|*xO~OR0uO!e0sO~P#(kOR0uO!S+UO!e0sO(P*OO~OR0uOo0wO!S+UO!e0sOQ'VXZ'VX}'VX#p'VX(P'VX~OR0uOo0wO!e0sO~OR0uO!e0sO~O$f/ZO(P*PO~Ow$yO~Ow$yO$|*xO~Oo0}Oy0|O!S1OO'r(pO~O!e1POv(pX~Ov1RO~O^#TO_#TO`#TOa'kOw&|O'T&vO(Q1VO~Oo1YOQ'VXR'VXZ'VX}'VX!e'VX(P'VX~O!e1ZO(P*POR'YX~O!e1ZOR'YX~O!e1ZO(P*OOR'YX~OR1]O~O!S1^OS'wXT'wXZ'wX['wX_'wXd'wXo'wXs'wXu'wXw'wXy'wX}'wX!P'wX!e'wX!l'wX!q'wX!t'wX!y'wX#O'wX#P'wX#Q'wX#R'wX'Q'wX'Z'wX'^'wX'g'wX'r'wX'v'wX'x'wX'y'wX'z'wX'{'wX'|'wX'}'wX(O'wX(P'wX(Q'wX(R'wXX'wXv'wX~O}1_O~O!P1aO~P#KkOX1bO~P#KkOv1cO~P#KkOS,^OT,^OZ,^O['cO_1dOd,^Oo,^Os,^Ou,^Ow'dOy,^O}'bO!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'v,_O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O(P,`O(Q,`O(R,aO~OX1fO~Oy,jO~O!e,sO!P(Va~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO!P&eX!e&eX~P)xO!e,sO!P(Va~OX&fa!e&fa!P&fa~P2gOX1kO~P2gO!P1mO!e(WO~OP!biZci!S!bi!e!bi!tci'qci'r!bi!O!bio!biy!bi!P!biX!bi!Z!bi#R!biv!bi~O'r(pOP!oi!S!oi!e!oi!O!oio!oiy!oi!P!oiX!oi!Z!oi#R!oiv!oi~O!j&bO!P&`X!e&`XX&`X~P<cO!e-TO!P'maX'ma~O!P1qO~Ov!RX!S!kX!e!RX~O!S1rO~O!e1sOv'oX~Ov1uO~O'T-XO~O!j1xO'T-XO~O(P*POP$Wi!e$Wi~O!S1yO'r(pOP$XX!e$XX~O!S1|O~Ov$_a!e$_a~P2gO!l(|O'Q#VO'T(xOv&hX!e&hX~O!e-oOv([a~Ov2QO~P,cOy2UO~O#p2VO~Oy2WO$|*xO~Ow*vOy2WO}*wO$|*xO~Oo2aO~Ow!POy2fO#Q2hO$|*xO~O!S2jO~Ov2lO~O#Q2mOR%wi#p%wi(P%wiw%wi$f%wi$|%wi[%wio%wiy%wi}%wi!l%wi!q%wi!t%wi#O%wi#P%wi'g%wi'q%wi'r%wi'x%wi'y%wi'z%wi'{%wi'|%wi'}%wi(O%wi(Q%wi(R%wi(T%wi!P%wi!e%wiX%wiP%wiv%wi!S%wi#R%wi~Od2nO~O^2qO!j.sO!q2rO'Q#VO'Z%eO~O(P*PO!P%{X!e%{X~O!e2sO!P(tX~O!P2uO~OQ!QOZ%rO[%qO^2wO_%cO`TOaTOd%jOg%yO}%pO!j2xO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO^2yO!j2xO(P*OO~O!P%aX!e%aX~P#4kO^2yO~O(P*POR&Oi#p&Oiw&Oi$f&Oi$|&Oi[&Oio&Oiy&Oi}&Oi!l&Oi!q&Oi!t&Oi#O&Oi#P&Oi'g&Oi'q&Oi'r&Oi'x&Oi'y&Oi'z&Oi'{&Oi'|&Oi'}&Oi(O&Oi(Q&Oi(R&Oi(T&Oi!P&Oi!e&OiX&OiP&Oiv&Oi!S&Oi#R&Oi~O_%cO!Q!lO!P&yX!e&yX~P#DkO!e.yO!P(ua~OR3QO(P*PO~O!e3ROR(rX~OR3TO~O(P*POR&Pi#p&Piw&Pi$f&Pi$|&Pi[&Pio&Piy&Pi}&Pi!l&Pi!q&Pi!t&Pi#O&Pi#P&Pi'g&Pi'q&Pi'r&Pi'x&Pi'y&Pi'z&Pi'{&Pi'|&Pi'}&Pi(O&Pi(Q&Pi(R&Pi(T&Pi!P&Pi!e&PiX&PiP&Piv&Pi!S&Pi#R&Pi~O!P3UO~O$f3VO(P*PO~Ow$yO$f3VO$|*xO(P*PO~Ow!PO!Z!YO~O!Z3aO#R3_O'r(pO~O!j&bO'Q#VO~P<cOv3eO~Ov3eO!j&bO'Q`O~P<cO!O3hO'r(pO~Ow!PO~P#9vOo3kOy3jO(P*PO~O!P3oO~P%;pOv3rO~P%;pOR0uO!S+UO!e0sO~OR0uOo0wO!S+UO!e0sO~Oa/zO|!VO'Q#VO'T(RO~O!S3uO~O!e3wOv(dX~Ov3yO~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO~PGaO!e3|O(P*PO!P(fX~O!P4OO~O!S4PO(P*OO~O!S+UO(P*PO~O!e4ROw(aXy(aX~OQ4TO~Oy2WO~Oa/zO|!VO'Q#VO'T*oO~Oo4WOw*vO}*wOv%XX!e%XX~O!e4ZOv(hX~Ov4]O~O(P4_Oy(_Xw(_X$|(_XR(_Xo(_X!e(_X~Oy4aO(P*PO~OQ!QOSVOTVO[$gO^4bO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O!j4cO'Z%eO~P&,sO!S4eO'r(pO~O#V4gO~P%1}O!e4hO!P(kX~O!P4jO~O!P%aX!S!aX!e%aX'r!aX~P!KgO!j&bO~P&,sO!e4hO!P(kX!S'eX'r'eX~O^2yO!j2xO~Ow!POy2fO~O_4pO!Q/sO'T&iO'Z%eOR&lX!e&lX~OR4rO!e0sO~O!S4tO~Ow$yO$|*xO(P*PO~Oy4uO~P2gOo4vOy4uO(P*PO~Ov&uX!e&uX~P!3|O!e1POv(pa~Oo4|Oy4{O(P*PO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'^UOR&vX!e&vX~P#DkO!e1ZOR'Ya~O!y5SO~O!P5TO~P#KkO!S1^OX'wX#R'wX~O!e,sO!P(Vi~O!P&ea!e&ea~P2gOX5WO~P2gOP!bqZcq!S!bq!e!bq!tcq'qcq'r!bq!O!bqo!bqy!bq!P!bqX!bq!Z!bq#R!bqv!bq~O'r(pO!P&`a!e&`aX&`a~O!i-`O!j-_O!l5YO'T-XOv&aX!e&aX~O!e1sOv'oa~O!S5[O~O!S5`O'r(pOP$Xa!e$Xa~O(P*POP$Wq!e$Wq~Ov$^i!e$^i~P2gOw!POy5bO#Q5dO$|*xO~Oo5gOy5fO(P*PO~Oy5iO~Oy5iO$|*xO~Oy5mO(P*PO~Ow!POy5bO~Oo5tOy5sO(P*PO~O!S5vO~O!e2sO!P(ta~O^2yO!j2xO'Z%eO~OQ!QOZ%rO[%qO^.rO_%cO`TOaTOd%jOg%yO}%pO!j.sO!q.pO!t5zO#V5|O$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P&xX!e&xX~PGaOQ!QOZ%rO[%qO^6OO_%cO`TOaTOd%jOg%yO}%pO!j6PO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(P*OO(Q%zO~PGaO!P%aa!e%aa~P#4kO^6QO~O#Q6ROR%wq#p%wq(P%wqw%wq$f%wq$|%wq[%wqo%wqy%wq}%wq!l%wq!q%wq!t%wq#O%wq#P%wq'g%wq'q%wq'r%wq'x%wq'y%wq'z%wq'{%wq'|%wq'}%wq(O%wq(Q%wq(R%wq(T%wq!P%wq!e%wqX%wqP%wqv%wq!S%wq#R%wq~O(P*POR&Oq#p&Oqw&Oq$f&Oq$|&Oq[&Oqo&Oqy&Oq}&Oq!l&Oq!q&Oq!t&Oq#O&Oq#P&Oq'g&Oq'q&Oq'r&Oq'x&Oq'y&Oq'z&Oq'{&Oq'|&Oq'}&Oq(O&Oq(Q&Oq(R&Oq(T&Oq!P&Oq!e&OqX&OqP&Oqv&Oq!S&Oq#R&Oq~O(P*PO!P&ya!e&ya~OX6SO~P2gO'Z%eOR&wX!e&wX~O!e3ROR(ra~O$f6YO(P*PO~Ow![q~P#9vO#R6]O~O!Z3aO#R6]O'r(pO~Ov6bO~O#R6fO~Oy6gO!P6hO~O!P6hO~P%;pOy6kO~Ov6kOy6gO~Ov6kO~P%;pOy6mO~O!e3wOv(da~O!S6pO~Oa/zO|!VO'Q#VO'T(ROv&oX!e&oX~O!e3|O(P*PO!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P&pX!e&pX~PGaO!e3|O!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zOw&nX!e&nXy&nX~PGaO!e4ROw(aay(aa~O!e4ZOv(ha~Oo7SOv%Xa!e%Xa~Oo7SOw*vO}*wOv%Xa!e%Xa~Oa/zO|!VO'Q#VO'T*oOv&qX!e&qX~O(P*POy$xaw$xa$|$xaR$xao$xa!e$xa~O(P4_Oy(_aw(_a$|(_aR(_ao(_a!e(_a~O!P%aa!S!aX!e%aa'r!aX~P!KgOQ!QOSVOTVO[$gO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j&bO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O^7ZO~P&JUO^6QO!j6PO~O!e4hO!P(ka~O!e4hO!P(ka!S'eX'r'eX~OQ!QOSVOTVO[$gO^0lO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j0mO!l$lO!q0eO!t7_O'Q#VO'T$YO'Z%eO'^UO'g$[O~O#V7aO!P&sX!e&sX~P&L]O!S7cO'r(pO~Ow!POy5bO$|*xO(P*PO~O!S+UOR&la!e&la~Oo0wO!S+UOR&la!e&la~Oo0wOR&la!e&la~O(P*POR$yi!e$yi~Oy7fO~P2gOo7gOy7fO(P*PO~O(P*PORni!eni~O(P*POR&va!e&va~O(P*OOR&va!e&va~OS,^OT,^OZ,^O_,^Od,^Oo,^Os,^Ou,^Oy,^O!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O~O(P7iO(Q7iO(R7iO~P'!qO!P7kO~P#KkO!P&ei!e&ei~P2gO'r(pOv!hi!e!hi~O!S7mO~O(P*POP$Xi!e$Xi~Ov$^q!e$^q~P2gOw!POy7oO~Ow!POy7oO#Q7rO$|*xO~Oy7tO~Oy7uO~Oy7vO(P*PO~Ow!POy7oO$|*xO(P*PO~Oo7{Oy7zO(P*PO~O!e2sO!P(ti~O(P*PO!P%}X!e%}X~O!P%ai!e%ai~P#4kO^8OO~O!e8TO['bXv$`i}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[iv$`i}#[i!i#[i!j#[i!l#[i!q#[i!t'bX#V#[i'Q#[i'T#[i'^#[i'g#[i'q'bX(Q'bX~P@[O#R#^a~P2gO#R8WO~O!Z3aO#R8XO'r(pO~Ov8[O~Oy8^O~P2gOy8`O~Oy6gO!P8aO~Ov8`Oy6gO~O!e3wOv(di~O(P*POv%Qi!e%Qi~O!e3|O!P(fi~O!e3|O(P*PO!P(fi~O(P*PO!P&pa!e&pa~O(P8hOw(bX!e(bXy(bX~O(P*PO!S$wiy$wiw$wi$|$wiR$wio$wi!e$wi~O!e4ZOv(hi~Ov%Xi!e%Xi~P2gOo8kOv%Xi!e%Xi~O!P%ai!S!aX!e%ai'r!aX~P!KgO(P*PO!P%`i!e%`i~O!e4hO!P(ki~O#V8nO~P&L]O!P&sa!S'eX!e&sa'r'eX~O(P*POR$zq!e$zq~Oy8pO~P2gOy7zO~P2gO(P8rO(Q8rO(R8rO~O(P8rO(Q8rO(R8rO~P'!qO'r(pOv!hq!e!hq~O(P*POP$Xq!e$Xq~Ow!POy8uO$|*xO(P*PO~Ow!POy8uO~Oy8xO~P2gOy8zO~P2gOo8|Oy8zO(P*PO~OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[qv$`q}#[q!i#[q!j#[q!l#[q!q#[q#V#[q'Q#[q'T#[q'^#[q'g#[q~O!e9PO['bXv$`q}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[Oo'bX!t'bX#O'bX#P'bX#p'bX'q'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(Q'bX(R'bX(T'bX~P'2fO#R9UO~O!Z3aO#R9UO'r(pO~Oy9WO~O(P*POv%Qq!e%Qq~O!e3|O!P(fq~O(P*PO!P&pi!e&pi~O(P8hOw(ba!e(bay(ba~Ov%Xq!e%Xq~P2gO!P&si!S'eX!e&si'r'eX~O(P*PO!P%`q!e%`q~Oy9]O~P2gO(P9^O(Q9^O(R9^O~O'r(pOv!hy!e!hy~Ow!POy9_O~Ow!POy9_O$|*xO(P*PO~Oy9aO~P2gOQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[yv$`y}#[y!i#[y!j#[y!l#[y!q#[y#V#[y'Q#[y'T#[y'^#[y'g#[y~O!e9dO['bXv$`y}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[Oo'bX!t'bX#O'bX#P'bX#p'bX'q'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(Q'bX(R'bX(T'bX~P'9eO!e9eO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[i}#[i!i#[i!j#[i!l#[i!q#[i!t'bX#V#[i'Q#[i'T#[i'^#[i'g#[i'q'bX(Q'bX~P@[O#R9hO~O(P*PO!P&pq!e&pq~Ov%Xy!e%Xy~P2gOw!POy9iO~Oy9jO~P2gOQ#[!RS#[!RT#[!R[#[!R^#[!R_#[!R`#[!Ra#[!Rd#[!Rs#[!Rt#[!Ru#[!Rv$`!R}#[!R!i#[!R!j#[!R!l#[!R!q#[!R#V#[!R'Q#[!R'T#[!R'^#[!R'g#[!R~O!e9kO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[q}#[q!i#[q!j#[q!l#[q!q#[q!t'bX#V#[q'Q#[q'T#[q'^#[q'g#[q'q'bX(Q'bX~P@[O!e9nO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[y}#[y!i#[y!j#[y!l#[y!q#[y!t'bX#V#[y'Q#[y'T#[y'^#[y'g#[y'q'bX(Q'bX~P@[OwbX~P$|OwjX}jX!tbX'qbX~P!6mOZ'SXd'XXo'SXw'kX!t'SX'q'SX'r'SX~O['SXd'SXw'SX}'SX!l'SX!q'SX#O'SX#P'SX#p'SX'g'SX'x'SX'y'SX'z'SX'{'SX'|'SX'}'SX(O'SX(P'SX(Q'SX(R'SX(T'SX~P'GTOP'SX}'kX!S'SX!e'SX!O'SXy'SX!P'SXX'SX!Z'SX#R'SXv'SX~P'GTO^9qO_9qO`9qOa9qO'T9oO~O!j:OO~P!.cOPoOQ!QOSVOTVOZeOd9tOsVOtVOuVO!U#bO!W#cO!X:zO!Z!YO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sXo#sXw#sX}#sX!l#sX!q#sX!t#sX#O#sX#P#sX#p#sX'g#sX'q#sX'r#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sX~P'IxO#Q$uO~P!.cO}'kXP'SX!S'SX!e'SX!O'SXy'SX!P'SXX'SX!Z'SX#R'SXv'SX~P'GTOo#qX#O#qX#P#qX#p#qX'r#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qX~P!.cOo#zX#O#zX#P#zX#p#zX'r#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zX~P!.cOPoOQ!QOSVOTVOZeOd9tOsVOtVOuVO!U#bO!W#cO!X:zO!Z!YO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sao#saw#sa}#sa!l#sa!q#sa!t#sa#O#sa#P#sa#p#sa'g#sa'q#sa'r#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#sa~P'IxOo:YO#O:YO#P:VOw#sa~P!B}Ow$Ua~P#9vOQ'XXd'XX}iX~OQlXdlX}jX~O^:sO_:sO`:sOa:sO'T:_O~OQ'XXd'XX}hX~Ow#qa~P#9vOw#za~P#9vO!S&_Oo#za#O#za#P#za#p#za'r#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#za~P!.cO#Q*eO~P!.cOw#ci~P#9vO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#ei~O'g#ei(P#ei~P((}O'g#gO(P#gO~P((}O[#}O}#zO'g#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'{#ei'|#ei'}#ei~O!q#ei~P(*yO!q#jO~P(*yO[#}O}#zO!q#jO'g#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'|#ei'}#ei~O'r#ei~P(,rO'r#lO~P(,rO[#}O}#zO!q#jO#P:VO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#p#ei'q#ei'|#ei~O'}#ei~P(.kO'}#mO~P(.kOo:YO#O:YO#P:VOw#ni~P$1xOo:YO#O:YO#P:VOw#si~P$3yOQ'XXd'XX}'kX~Ow#zi~P#9vOw$Ui~P#9vOd9}O~Ow#ca~P#9vOd:uO~OU'x_'v'P'O'^s!y'^'T'Z~",
        goto: "$Ku(vPPPPPPP(wPP)OPP)^PPPP)d-hP0f5aP7R7R8v7R>wD_DpPDvHQPPPPPPK`P! P! _PPPPP!!VP!$oP!$oPP!&oP!(rP!(w!)n!*f!*f!*f!(w!+]P!(w!.Q!.TPP!.ZP!(w!(w!(w!(wP!(w!(wP!(w!(w!.y!/dP!/dJ}J}J}PPPP!/d!.y!/sPP!$oP!0^!0a!0g!1h!1t!3t!3t!5r!7t!1t!1t!9p!;_!=O!>k!@U!Am!CS!De!1t!1tP!1tP!1t!1t!Et!1tP!Ge!1t!1tP!Ie!1tP!1t!7t!7t!1t!7t!1t!Kl!Mt!Mw!7t!1t!Mz!M}!M}!M}!NR!$oP!$oP!$oP! P! PP!N]! P! PP!Ni# }! PP! PP#!^##c##k#$Z#$_#$e#$e#$mP#&s#&s#&y#'o#'{! PP! PP#(]#(l! PP! PPP#(x#)W#)d#)|#)^! P! PP! P! P! PP#*S#*S#*Y#*`#*S#*S! P! PP#*m#*v#+Q#+Q#,x#.l#.x#.x#.{#.{5a5a5a5a5a5a5a5aP5a#/O#/U#/p#1{#2R#2b#6^#6d#6j#6|#7W#8w#9R#9b#9h#9n#9x#:S#:Y#:g#:m#:s#:}#;]#;g#=u#>R#>`#>f#>n#>u#?PPPPPPPP#?V#BaP#F^#Jx#Ls#Nr$&^P$&aPPP$)_$)h$)z$/U$1d$1m$3fP!(w$4`$7r$:i$>T$>^$>c$>fPPP$>i$A`$A|P$BaPPPPPPPPPP$BvP$EU$EX$E[$Eb$Ee$Eh$Ek$En$Et$HO$HR$HU$HX$H[$H_$Hb$He$Hh$Hk$Hn$Jt$Jw$Jz#*S$KW$K^$Ka$Kd$Kh$Kl$Ko$KrQ!tPT'V!s'Wi!SOlm!P!T$T$W$y%b)U*f/gQ'i#QR,n'l(OSOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%X%_%b&U&Y&[&b&u&z&|'P'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n+z,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1P1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:gS(z$v-oQ*p&eQ*t&hQ-k(yQ-y)ZW0Z+Q0Y4Z7UR4Y0[&w!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'l'}(W(Y(b(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,s,z-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f#r]Ofgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hb#[b#Q$y'l(b)S)U*Z-t!h$bo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m$b%k!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g!W:y!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR:|%n$_%u!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g$e%l!Q!n$O$u%n%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g'hZOY[fgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r%_%b%i%j&U&Y&[&b&u'a'}(W(Y(d(e(f(j(o(p(r(|)i)p)q*f*i*k*l+Z+n,s,z-R-T-g-m.i.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:`:a:e:f:g:t:u:x$^%l!Q!n$O$u%n%o%p%q%y%{&P&p&r(q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ&j!hQ&k!iQ&l!jQ&m!kQ&s!oQ)[%QQ)]%RQ)^%SQ)_%TQ)b%WQ+`&oS,R']1ZQ.W)`S/r*u4TR4n0s+yTOY[bfgilmop!O!P!Q!T!Y!Z![!_!`!c!n!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$O$T$W$`$a$e$g$h$q$r$u$y%X%_%b%i%j%n%o%p%q%y%{&P&U&Y&[&b&o&p&r&u&z&|'P']'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(q(r(|)S)U)i)p)q)s)x)y*O*P*R*V*Z*[*^*e*f*i*k*l*n*w*x+U+V+Z+h+n+o+z+},q,s,z-R-T-g-i-m-t-v.U.`.i.p.t.x.y.}/Z/[/^/b/d/g/{/}0`0e0g0m0r0w0}1O1P1Y1Z1h1r1y1|2a2h2j2m2s2v3V3_3a3f3h3k3u3{3|4R4U4W4_4c4e4h4t4v4|5[5`5d5g5t5v6R6Y6]6a6p6v6x7S7^7c7g7m7r7{8W8X8g8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:`:a:e:f:g:t:u:xQ'[!xQ'h#PQ)l%gU)r%m*T*WR.f)kQ,T']R5P1Z#t%s!Q!n$O$u%p%q&P&p&r(q)x)y*O*R*V*[*^*e*n*w+V+h+o+}-i-v.U.`.t.x.y/Z/[/{/}0`0r0w1O1Y1y2a2h2j2m2v3V3u3{3|4U4e4t5`5d5v6R6Y6p6v6x7c7r8gQ)x%oQ+_&oQ,U']n,^'b'c'd,c,f,h,l/m/n1_3n3q5T5U7kS.q)s2sQ/O*PQ/Q*SQ/q*uS0Q*x4RQ0a+U[0o+Z.j0g4h5y7^Q2v.pS4d0e2rQ4m0sQ5Q1ZQ6T3RQ6z4PQ7O4TQ7X4_R9Y8h&jVOfgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u']'}(W(Y(b(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1Z1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fU&g!g%P%[o,^'b'c'd,c,f,h,l/m/n1_3n3q5T5U7k$nsOfgilm!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y'}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9z9{:O:P:Q:R:S:T:U:V:W:X:Y:eS$tp9xS&O!W#bS&Q!X#cQ&`!bQ*_&RQ*a&VS*d&[:fQ*h&^Q,T']Q-j(wQ/i*jQ0p+[S2f.X0qQ3]/_Q3^/`Q3g/hQ3i/kQ5P1ZU5b2R2g4lU7o5c5e5rQ8]6dS8u7p7qS9_8v8wR9i9`i{Ob!O!P!T$y%_%b)S)U)i-thxOb!O!P!T$y%_%b)S)U)i-tW/v*v/t3w6qQ/}*wW0[+Q0Y4Z7UQ3{/{Q6x3|R8g6v!h$do!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ&d!dQ&f!fQ&n!mW&x!q%X&|1PQ'S!rQ)X$}Q)Y%OQ)a%VU)d%Y'T'UQ*s&hS+s&z'PS-Y(k1sQ-u)WQ-x)ZS.a)e)fS0x+c/sQ1S+zQ1W+{S1v-_-`Q2k.bQ3s/pQ5]1xR5h2V${sOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$zsOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR3]/_V&T!Y!`*i!i$lo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m!k$^o!c!p$e$g$h$q$r&U&b&u(b(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m!i$co!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m&e^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'}(W(Y(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR(l$fQ-[(kR5Y1sQ(S#|S({$v-oS-Z(k1sQ-l(yW/u*v/t3w6qS1w-_-`Q3v/vR5^1xQ'e#Or,e'b'c'd'j'p)u,c,f,h,l/m/n1_3n3q5U6fR,o'mk,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ'f#Or,e'b'c'd'j'p)u,c,f,h,l/m/n1_3n3q5U6fR,p'mR*g&]X/c*f/d/g3f!}aOb!O!P!T#z$v$y%_%b'}(y)S)U)i)s*f*v*w+Q+Z,s-o-t.j/b/d/g/t/{0Y0g1h2s3f3w3|4Z4h5y6a6q6v7U7^Q3`/aQ6_3bQ8Y6`R9V8Z${rOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f#nfOfglmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h!T9u!Y!_!`*i*l/^3h9u9v9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:e:f#rfOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h!X9u!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$srOfglmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:e:f#U#oh#d$P$Q$V$s%^&W&X'q't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b}:P&S&]/k3[6d:[:]:c:d:h:j:k:l:m:n:o:p:q:r:v:w:{#W#ph#d$P$Q$V$s%^&W&X'q'r't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b!P:Q&S&]/k3[6d:[:]:c:d:h:i:j:k:l:m:n:o:p:q:r:v:w:{#S#qh#d$P$Q$V$s%^&W&X'q'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b{:R&S&]/k3[6d:[:]:c:d:h:k:l:m:n:o:p:q:r:v:w:{#Q#rh#d$P$Q$V$s%^&W&X'q'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9by:S&S&]/k3[6d:[:]:c:d:h:l:m:n:o:p:q:r:v:w:{#O#sh#d$P$Q$V$s%^&W&X'q'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bw:T&S&]/k3[6d:[:]:c:d:h:m:n:o:p:q:r:v:w:{!|#th#d$P$Q$V$s%^&W&X'q'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bu:U&S&]/k3[6d:[:]:c:d:h:n:o:p:q:r:v:w:{!x#vh#d$P$Q$V$s%^&W&X'q'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bq:W&S&]/k3[6d:[:]:c:d:h:p:q:r:v:w:{!v#wh#d$P$Q$V$s%^&W&X'q'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bo:X&S&]/k3[6d:[:]:c:d:h:q:r:v:w:{$]#{h#`#d$P$Q$V$s%^&S&W&X&]'q'r's't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n/k0z1i1l1}3P3[4w5V5a6^6d6e7R7e7h7s7y8j8q8{9[9b:[:]:c:d:h:i:j:k:l:m:n:o:p:q:r:v:w:{${jOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$v!aOfgilmp!O!P!T!Y!Z!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ&Y![Q&Z!]R:e9{#rpOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hQ&[!^!W9x!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR:f:zR$moR-f(rR$wqT(}$v-oQ/f*fS3d/d/gR6c3fQ3m/mQ3p/nQ6i3nR6l3qQ$zwQ)V${Q*q&fQ+f&qQ+i&sQ-w)YW.Z)b+j+k+lS/X*]+gW2b.W.[.].^U3W/Y/]0yU5o2c2d2eS6W3X3ZS7w5p5qS8Q6V6XQ8y7xS8}8R8SR9c9O^|O!O!P!T%_%b)iX)R$y)S)U-tQ&r!nQ*^&PQ*|&jQ+P&kQ+T&lQ+W&mQ+]&nQ+l&sQ-})[Q.Q)]Q.T)^Q.V)_Q.Y)aQ.^)bQ2S-uQ2e.WR4U0VU+a&o*u4TR4o0sQ+Y&mQ+k&sS.])b+l^0v+_+`/q/r4m4n7OS2d.W.^S4Q0R0SR5q2eS0R*x4RQ0a+UR7X4_U+d&o*u4TR4p0sQ*z&jQ+O&kQ+S&lQ+g&qQ+j&sS-{)[*|S.P)]+PS.S)^+TU.[)b+k+lQ/Y*]Q0X*{Q0q+[Q2X-|Q2Y-}Q2].QQ2_.TU2c.W.].^Q2g.XS3Z/]0yS5c2R4lQ5j2ZS5p2d2eQ6X3XS7q5e5rQ7x5qQ8R6VQ8v7pQ9O8SR9`8wQ0T*xR6|4RQ*y&jQ*}&kU-z)[*z*|U.O)]+O+PS2W-{-}S2[.P.QQ4X0ZQ5i2YQ5k2]R7T4YQ/w*vQ3t/tQ6r3wR8d6qQ*{&jS-|)[*|Q2Z-}Q4X0ZR7T4YQ+R&lU.R)^+S+TS2^.S.TR5l2_Q0]+QQ4V0YQ7V4ZR8l7UQ+[&nS.X)a+]S2R-u.YR5e2SQ0i+ZQ4f0gQ7`4hR8m7^Q.m)sQ0i+ZQ2p.jQ4f0gQ5|2sQ7`4hQ7}5yR8m7^Q0i+ZR4f0gX'O!q%X&|1PX&{!q%X&|1PW'O!q%X&|1PS+u&z'PR1U+z_|O!O!P!T%_%b)iQ%a!PS)h%_%bR.d)i$^%u!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ*U%yR*X%{$c%n!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gW)t%m%x*T*WQ.e)jR2{.vR.m)sR5|2sQ'W!sR,O'WQ!TOQ$TlQ$WmQ%b!P[%|!T$T$W%b)U/gQ)U$yR/g*f$b%i!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g[)n%i)p.i:`:t:xQ)p%jQ.i)qQ:`%nQ:t:aR:x:uQ!vUR'Y!vS!OO!TU%]!O%_)iQ%_!PR)i%b#rYOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hh!yY!|#U$`'a'n(d,q-R9s9|:gQ!|[b#Ub#Q$y'l(b)S)U*Z-t!h$`o!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ'a!}Q'n#ZQ(d$aQ,q'oQ-R(e!W9s!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ9|9tR:g9}Q-U(gR1p-UQ1t-[R5Z1tQ,c'bQ,f'cQ,h'dW1`,c,f,h5UR5U1_Q/d*fS3c/d3fR3f/gfbO!O!P!T$y%_%b)S)U)i-tp#Wb'}(y.j/b/t/{0Y0g1h5y6a6q6v7U7^Q'}#zS(y$v-oQ.j)sW/b*f/d/g3fQ/t*vQ/{*wQ0Y+QQ0g+ZQ1h,sQ5y2sQ6q3wQ6v3|Q7U4ZR7^4hQ,t(OQ1g,rT1j,t1gS(X$Q([Q(^$VU,x(X(^,}R,}(`Q(s$mR-h(sQ-p)OR2P-pQ3n/mQ3q/nT6j3n3qQ)S$yS-r)S-tR-t)UQ4`0aR7Y4``0t+^+_+`+a+d/q/r7OR4q0tQ8i6zR9Z8iQ4S0TR6}4SQ3x/wQ6n3tT6s3x6nQ3}/|Q6t3zU6y3}6t8eR8e6uQ4[0]Q7Q4VT7W4[7QhzOb!O!P!T$y%_%b)S)U)i-tQ$|xW%Zz$|%f)v$b%f!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR)v%nS4i0i0nS7]4f4gT7b4i7]W&z!q%X&|1PS+r&z+zR+z'PQ1Q+wR4z1QU1[,S,T,UR5R1[S3S/Q7OR6U3SQ2t.mQ5x2pT5}2t5xQ.z)zR3O.z^_O!O!P!T%_%b)iY#Xb$y)S)U-t$l#_fgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!h$io!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mS'j#Q'lQ-P(bR/V*Z&v!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'l'}(W(Y(b(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,s,z-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f[!{Y[#U#Z9s9tW&{!q%X&|1P['`!|!}'n'o9|9}S(c$`$aS+t&z'PU,X'a,q:gS-Q(d(eQ1T+zR1n-RS%t!Q&oQ&q!nQ(V$OQ(w$uS)w%o.pQ)z%pQ)}%qS*]&P&rQ+e&pQ,S']Q-d(qQ.l)sU.w)x)y2vS/O*O*PQ/P*RQ/T*VQ/W*[Q/]*^Q/`*eQ/l*nQ/|*wS0S*x4RQ0a+UQ0c+VQ0y+hQ0{+oQ1X+}Q1{-iQ2T-vQ2`.UQ2i.`Q2z.tQ2|.xQ2}.yQ3X/ZQ3Y/[S3z/{/}Q4^0`Q4l0rQ4s0wQ4x1OQ4}1YQ5O1ZQ5_1yQ5n2aQ5r2hQ5u2jQ5w2mQ5{2sQ6V3VQ6o3uQ6u3{Q6w3|Q7P4UQ7X4_Q7[4eQ7d4tQ7n5`Q7p5dQ7|5vQ8P6RQ8S6YQ8c6pS8f6v6xQ8o7cQ8w7rR9X8g$^%m!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ)j%nQ*T%yR*W%{$y%h!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](q)p)q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.i.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g:`:a:t:u:x'pWOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:g$x%g!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](q)p)q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.i.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g:`:a:t:u:x_&y!q%X&z&|'P+z1PR,V']$zrOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!j$]o!c!p$e$g$h$q$r&U&b&u(b(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ,T']R5P1Z_}O!O!P!T%_%b)i^|O!O!P!T%_%b)iQ#YbX)R$y)S)U-tbhO!O!T3_6]8W8X9U9hS#`f9uQ#dgQ$PiQ$QlQ$VmQ$spW%^!P%_%b)iU&S!Y!`*iQ&W!ZQ&X![Q&]!_Q'q#eQ'r#oS's#p:QQ't#qQ'u#rQ'v#sQ'w#tQ'x#uQ'y#vQ'z#wQ'{#xQ'|#yQ(O#zQ(U#}Q([$TQ(`$WQ*b&YQ*c&[Q,r'}Q,w(WQ,y(YQ-n(|Q/k*lQ0z+nQ1i,sQ1l,zQ1}-mQ3P.}Q3[/^Q4w0}Q5V1hQ5a1|Q6^3aQ6d3hQ6e3kQ7R4WQ7e4vQ7h4|Q7s5gQ7y5tQ8j7SQ8q7gQ8{7{Q9[8kQ9b8|Q:[9wQ:]9xQ:c9zQ:d9{Q:h:OQ:i:PQ:j:RQ:k:SQ:l:TQ:m:UQ:n:VQ:o:WQ:p:XQ:q:YQ:r:ZQ:v:eQ:w:fR:{9v^tO!O!P!T%_%b)i$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3a3h3k4W4v4|5g5t7S7g7{8k8|9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ6[3_Q8V6]Q9R8WQ9T8XQ9g9UR9m9hQ&V!YQ&^!`R/h*iQ$joQ&a!cQ&t!pU(g$e$g(jS(n$h0eQ(u$qQ(v$rQ*`&UQ*m&bQ+p&uQ-S(fS-b(o4cQ-c(pQ-e(rW/a*f/d/g3fQ/j*kW0f+Z0g4h7^Q1o-TQ1z-gQ3b/bQ4k0mQ5X1rQ7l5[Q8Z6aR8t7m!h$_o!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mR-P(b'qXOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:g$zqOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!i$fo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m&d^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'}(W(Y(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f[!zY[$`$a9s9t['_!|!}(d(e9|9}W)o%i%j:`:aU,W'a-R:gW.h)p)q:t:uT2o.i:xQ(i$eQ(m$gR-W(jV(h$e$g(jR-^(kR-](k$znOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!i$ko!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mS'g#O'pj,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ,m'jQ.u)uR8_6f`,b'b'c'd,c,f,h1_5UQ1e,lX3l/m/n3n3qj,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ7j5TR8s7k^uO!O!P!T%_%b)i$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3a3h3k4W4v4|5g5t7S7g7{8k8|9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ6Z3_Q8U6]Q9Q8WQ9S8XQ9f9UR9l9hR(Q#zR(P#zQ$SlR(]$TR$ooR$noR)Q$vR)P$vQ)O$vR2O-ohwOb!O!P!T$y%_%b)S)U)i-t$l!lz!Q!n$O$u$|%f%n%o%p%q%y%{&P&o&p&r'](q)s)v)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR${xR0b+UR0W*xR0U*xR6{4PR/y*vR/x*vR0P*wR0O*wR0_+QR0^+Q%XyObxz!O!P!Q!T!n$O$u$y$|%_%b%f%n%o%p%q%y%{&P&o&p&r'](q)S)U)i)s)v)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-t-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR0k+ZR0j+ZQ'R!qQ)c%XQ+w&|R4y1PX'Q!q%X&|1PR+y&|R+x&|T/S*S4TT/R*S4TR.o)sR.n)sR){%p",
        nodeNames: "⚠ | < > RawString Float LineComment BlockComment SourceFile ] InnerAttribute ! [ MetaItem self Metavariable super crate Identifier ScopedIdentifier :: QualifiedScope AbstractType impl SelfType MetaType TypeIdentifier ScopedTypeIdentifier ScopeIdentifier TypeArgList TypeBinding = Lifetime String Escape Char Boolean Integer } { Block ; ConstItem Vis pub ( in ) const BoundIdentifier : UnsafeBlock unsafe AsyncBlock async move IfExpression if LetDeclaration let LiteralPattern ArithOp MetaPattern SelfPattern ScopedIdentifier TuplePattern ScopedTypeIdentifier , StructPattern FieldPatternList FieldPattern ref mut FieldIdentifier .. RefPattern SlicePattern CapturedPattern ReferencePattern & MutPattern RangePattern ... OrPattern MacroPattern ParenthesizedTokens TokenBinding Identifier TokenRepetition ArithOp BitOp LogicOp UpdateOp CompareOp -> => ArithOp BracketedTokens BracedTokens _ else MatchExpression match MatchBlock MatchArm Attribute Guard UnaryExpression ArithOp DerefOp LogicOp ReferenceExpression TryExpression BinaryExpression ArithOp ArithOp BitOp BitOp BitOp BitOp LogicOp LogicOp AssignmentExpression TypeCastExpression as ReturnExpression return RangeExpression CallExpression ArgList AwaitExpression await FieldExpression GenericFunction BreakExpression break LoopLabel ContinueExpression continue IndexExpression ArrayExpression TupleExpression MacroInvocation UnitExpression ClosureExpression ParamList Parameter Parameter ParenthesizedExpression StructExpression FieldInitializerList ShorthandFieldInitializer FieldInitializer BaseFieldInitializer MatchArm WhileExpression while LoopExpression loop ForExpression for MacroInvocation MacroDefinition macro_rules MacroRule EmptyStatement ModItem mod DeclarationList AttributeItem ForeignModItem extern StructItem struct TypeParamList ConstrainedTypeParameter TraitBounds HigherRankedTraitBound RemovedTraitBound OptionalTypeParameter ConstParameter WhereClause where LifetimeClause TypeBoundClause FieldDeclarationList FieldDeclaration OrderedFieldDeclarationList UnionItem union EnumItem enum EnumVariantList EnumVariant TypeItem type FunctionItem default fn ParamList Parameter SelfParameter VariadicParameter VariadicParameter ImplItem TraitItem trait AssociatedType LetDeclaration UseDeclaration use ScopedIdentifier UseAsClause ScopedIdentifier UseList ScopedUseList UseWildcard ExternCrateDeclaration StaticItem static ExpressionStatement ExpressionStatement GenericType FunctionType ForLifetimes ParamList VariadicParameter Parameter VariadicParameter Parameter ReferenceType PointerType TupleType UnitType ArrayType MacroInvocation EmptyType DynamicType dyn BoundedType",
        maxTerm: 359,
        nodeProps: [["group", -42, 4, 5, 14, 15, 16, 17, 18, 19, 33, 35, 36, 37, 40, 51, 53, 56, 101, 107, 111, 112, 113, 122, 123, 125, 127, 128, 130, 132, 133, 134, 137, 139, 140, 141, 142, 143, 144, 148, 149, 155, 157, 159, "Expression", -16, 22, 24, 25, 26, 27, 222, 223, 230, 231, 232, 233, 234, 235, 236, 237, 239, "Type", -20, 42, 161, 162, 165, 166, 169, 170, 172, 188, 190, 194, 196, 204, 205, 207, 208, 209, 217, 218, 220, "Statement", -17, 49, 60, 62, 63, 64, 65, 68, 74, 75, 76, 77, 78, 80, 81, 83, 84, 99, "Pattern"], ["openedBy", 9, "[", 38, "{", 47, "("], ["closedBy", 12, "]", 39, "}", 45, ")"]],
        propSources: [rustHighlighting],
        skippedNodes: [0, 6, 7, 240],
        repeatNodeCount: 32,
        tokenData: "#?|_R!VOX$hXY1_YZ2ZZ]$h]^1_^p$hpq1_qr2srs4qst5Ztu6Vuv9lvw;jwx=nxy!!ayz!#]z{!$X{|!&R|}!'T}!O!(P!O!P!*Q!P!Q!-|!Q!R!6X!R![!7|![!]!Jw!]!^!Lu!^!_!Mq!_!`# x!`!a##y!a!b#&Q!b!c#&|!c!}#'x!}#O#)o#O#P#*k#P#Q#1b#Q#R#2^#R#S#'x#S#T$h#T#U#'x#U#V#3`#V#f#'x#f#g#6s#g#o#'x#o#p#<Q#p#q#<|#q#r#?Q#r${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$hU$oZ'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU%iT'_Q'OSOz%xz{&^{!P%x!P!Q'S!Q~%xS%}T'OSOz%xz{&^{!P%x!P!Q'S!Q~%xS&aTOz&pz{&^{!P&p!P!Q({!Q~&pS&sTOz%xz{&^{!P%x!P!Q'S!Q~%xS'VSOz&p{!P&p!P!Q'c!Q~&pS'fSOz'r{!P'r!P!Q'c!Q~'rS'uTOz(Uz{(l{!P(U!P!Q'c!Q~(US(]T'PS'OSOz(Uz{(l{!P(U!P!Q'c!Q~(US(oSOz'rz{(l{!P'r!Q~'rS)QO'PSU)VZ'_QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)xU)}Z'_QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU*uZ'_QOY)xYZ+hZr)xrs&psz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)xU+mT'_QOz%xz{&^{!P%x!P!Q'S!Q~%xQ,RT'_QOY+|YZ,bZr+|s#O+|#P~+|Q,gO'_QU,lZ'_QOY-_YZ0cZr-_rs'rsz-_z{+|{!P-_!P!Q,g!Q#O-_#O#P'r#P~-_U-dZ'_QOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU.`Z'_Q'PS'OSOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU/[T'_Q'PS'OSOz(Uz{(l{!P(U!P!Q'c!Q~(UU/pZ'_QOY-_YZ0cZr-_rs'rsz-_z{/k{!P-_!P!Q+|!Q#O-_#O#P'r#P~-_U0hT'_QOz(Uz{(l{!P(U!P!Q'c!Q~(UU1OT'_Q'PSOY+|YZ,bZr+|s#O+|#P~+|_1hZ'_Q&|X'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_2dT'_Q&|X'OSOz%xz{&^{!P%x!P!Q'S!Q~%x_2|]ZX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`#O$h#O#P%x#P~$h_4OZ#PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_4zT']Q'OS'^XOz%xz{&^{!P%x!P!Q'S!Q~%x_5dZ'QX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_6`g'_Q'vW'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_8Qh'_Q_X'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![7w![!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_9u](TP'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_:wZ#OX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_;s_!qX'_Q'OSOY$hYZ%bZr$hrs%xsv$hvw<rwz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_<{Z'}X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_=ui'_Q'OSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q!c?d!c!}Et!}#O?d#O#PId#P#R?d#R#SEt#S#T?d#T#oEt#o${?d${$|Et$|4w?d4w5bEt5b5i?d5i6SEt6S~?d_?k]'_Q'OSOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_@mZ'_Q'OSsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_AgV'_Q'OSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x]BTT'OSsXOz%xz{&^{!P%x!P!Q'S!Q~%x]BiV'OSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x_CT]'_QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)x_DTZ'_QsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_D{]'_QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)x_E}j'_Q'OS'ZXOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h_Gxh'_Q'OS'ZXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h]IiX'OSOzBdz{JU{!PBd!P!QKS!Q#iBd#i#jKi#j#lBd#l#mMX#m~Bd]JXVOw&pwxJnxz&pz{&^{!P&p!P!Q({!Q~&p]JsTsXOz%xz{&^{!P%x!P!Q'S!Q~%x]KVUOw&pwxJnxz&p{!P&p!P!Q'c!Q~&p]Kn['OSOz%xz{&^{!P%x!P!Q'S!Q![Ld![!c%x!c!iLd!i#T%x#T#ZLd#Z#o%x#o#pNq#p~%x]LiY'OSOz%xz{&^{!P%x!P!Q'S!Q![MX![!c%x!c!iMX!i#T%x#T#ZMX#Z~%x]M^Y'OSOz%xz{&^{!P%x!P!Q'S!Q![M|![!c%x!c!iM|!i#T%x#T#ZM|#Z~%x]NRY'OSOz%xz{&^{!P%x!P!Q'S!Q![Bd![!c%x!c!iBd!i#T%x#T#ZBd#Z~%x]NvY'OSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z~%x]! k['OSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z#q%x#q#rBd#r~%x_!!jZ}X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!#fZ!PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!$`](QX'_QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q!_)x!_!`!%X!`#O)x#O#P&p#P~)x_!%`Z#OX'_QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!&[](PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_!'^Z!eX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!(Y^'gX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`!a!)U!a#O$h#O#P%x#P~$h_!)_Z#QX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!*Z[(OX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!+P!P!Q*p!Q#O$h#O#P%x#P~$h_!+Y^!lX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!,U!P!Q*p!Q!_$h!_!`!-Q!`#O$h#O#P%x#P~$h_!,_Z!tX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV!-ZZ'qP'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!.T]'_Q'xXOY)xYZ+hZr)xrs&psz)xz{!.|{!P)x!P!Q!/d!Q!_)x!_!`!%X!`#O)x#O#P&p#P~)x_!/TT&}]'_QOY+|YZ,bZr+|s#O+|#P~+|_!/kZ'_QUXOY!0^YZ0cZr!0^rs!3`sz!0^z{!5k{!P!0^!P!Q!/d!Q#O!0^#O#P!3`#P~!0^_!0eZ'_QUXOY!1WYZ/RZr!1Wrs!2Usz!1Wz{!4q{!P!1W!P!Q!/d!Q#O!1W#O#P!2U#P~!1W_!1cZ'_QUX'PS'OSOY!1WYZ/RZr!1Wrs!2Usz!1Wz{!4q{!P!1W!P!Q!/d!Q#O!1W#O#P!2U#P~!1W]!2_VUX'PS'OSOY!2UYZ(UZz!2Uz{!2t{!P!2U!P!Q!3z!Q~!2U]!2yVUXOY!3`YZ'rZz!3`z{!2t{!P!3`!P!Q!4f!Q~!3`]!3eVUXOY!2UYZ(UZz!2Uz{!2t{!P!2U!P!Q!3z!Q~!2U]!4PVUXOY!3`YZ'rZz!3`z{!4f{!P!3`!P!Q!3z!Q~!3`X!4kQUXOY!4fZ~!4f_!4xZ'_QUXOY!0^YZ0cZr!0^rs!3`sz!0^z{!4q{!P!0^!P!Q!5k!Q#O!0^#O#P!3`#P~!0^Z!5rV'_QUXOY!5kYZ,bZr!5krs!4fs#O!5k#O#P!4f#P~!5k_!6bhuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!7|![#O$h#O#P%x#P#R$h#R#S!7|#S#U$h#U#V!By#V#]$h#]#^!9_#^#c$h#c#d!Ee#d#i$h#i#j!9_#j#l$h#l#m!Gy#m~$h_!8VbuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!7|![#O$h#O#P%x#P#R$h#R#S!7|#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!9fe'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R$h!R!S!:w!S!T$h!T!U!=y!U!W$h!W!X!>y!X!Y$h!Y!Z!<}!Z#O$h#O#P%x#P#g$h#g#h!?y#h~$h_!;O_'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!;}!T!W$h!W!X!<}!X#O$h#O#P%x#P~$h_!<U]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y$h!Y!Z!<}!Z#O$h#O#P%x#P~$h_!=WZuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!>Q]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!<}!T#O$h#O#P%x#P~$h_!?Q]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!U$h!U!V!<}!V#O$h#O#P%x#P~$h_!@Q]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#]$h#]#^!@y#^~$h_!AQ]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#n$h#n#o!Ay#o~$h_!BQ]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#X$h#X#Y!<}#Y~$h_!CQ_'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!DP!R!S!DP!S#O$h#O#P%x#P#R$h#R#S!DP#S~$h_!DYcuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!DP!R!S!DP!S#O$h#O#P%x#P#R$h#R#S!DP#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!El^'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!Fh!Y#O$h#O#P%x#P#R$h#R#S!Fh#S~$h_!FqbuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!Fh!Y#O$h#O#P%x#P#R$h#R#S!Fh#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!HQb'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!IY![!c$h!c!i!IY!i#O$h#O#P%x#P#R$h#R#S!IY#S#T$h#T#Z!IY#Z~$h_!IcfuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!IY![!c$h!c!i!IY!i#O$h#O#P%x#P#R$h#R#S!IY#S#T$h#T#Z!IY#Z#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!KQ]!SX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![$h![!]!Ky!]#O$h#O#P%x#P~$h_!LSZdX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!MOZyX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!Mz^#PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!^$h!^!_!Nv!_!`3u!`#O$h#O#P%x#P~$h_# P]'yX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#!R^oX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#!}!a#O$h#O#P%x#P~$h_##WZ#RX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#$S^#PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#%O!a#O$h#O#P%x#P~$h_#%X]'zX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#&ZZ(RX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV#'VZ'pP'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#(Th'_Q'OS!yW'TPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$h_#)xZ[X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU#*pX'OSOz#+]z{#+s{!P#+]!P!Q#,X!Q#i#+]#i#j#,j#j#l#+]#l#m#.Y#m~#+]U#+dTrQ'OSOz%xz{&^{!P%x!P!Q'S!Q~%xU#+xTrQOz&pz{&^{!P&p!P!Q({!Q~&pU#,^SrQOz&p{!P&p!P!Q'c!Q~&pU#,o['OSOz%xz{&^{!P%x!P!Q'S!Q![#-e![!c%x!c!i#-e!i#T%x#T#Z#-e#Z#o%x#o#p#/r#p~%xU#-jY'OSOz%xz{&^{!P%x!P!Q'S!Q![#.Y![!c%x!c!i#.Y!i#T%x#T#Z#.Y#Z~%xU#._Y'OSOz%xz{&^{!P%x!P!Q'S!Q![#.}![!c%x!c!i#.}!i#T%x#T#Z#.}#Z~%xU#/SY'OSOz%xz{&^{!P%x!P!Q'S!Q![#+]![!c%x!c!i#+]!i#T%x#T#Z#+]#Z~%xU#/wY'OSOz%xz{&^{!P%x!P!Q'S!Q![#0g![!c%x!c!i#0g!i#T%x#T#Z#0g#Z~%xU#0l['OSOz%xz{&^{!P%x!P!Q'S!Q![#0g![!c%x!c!i#0g!i#T%x#T#Z#0g#Z#q%x#q#r#+]#r~%x_#1kZXX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#2g]'{X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#3kj'_Q'OS!yW'TPOY$hYZ%bZr$hrs#5]sw$hwx#5sxz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$h]#5dT'OS'^XOz%xz{&^{!P%x!P!Q'S!Q~%x_#5z]'_Q'OSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q#O?d#O#PId#P~?d_#7Oi'_Q'OS!yW'TPOY$hYZ%bZr$hrs%xst#8mtz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$hV#8tg'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}#:]!}#O$h#O#P%x#P#R$h#R#S#:]#S#T$h#T#o#:]#o${$h${$|#:]$|4w$h4w5b#:]5b5i$h5i6S#:]6S~$hV#:fh'_Q'OS'TPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#:]![!c$h!c!}#:]!}#O$h#O#P%x#P#R$h#R#S#:]#S#T$h#T#o#:]#o${$h${$|#:]$|4w$h4w5b#:]5b5i$h5i6S#:]6S~$h_#<ZZwX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#=V_'rX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P#p$h#p#q#>U#q~$h_#>_Z'|X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#?ZZvX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h",
        tokenizers: [closureParam, tpDelim, literalTokens, 0, 1, 2, 3],
        topRules: {
            "SourceFile": [0, 8]
        },
        specialized: [{
            term: 281,
            get: value => spec_identifier[value] || -1
        }],
        tokenPrec: 15596
    });
    const rustLanguage = LRLanguage.define({
        parser: parser$4.configure({
            props: [indentNodeProp.add({
                IfExpression: continuedIndent({
                    except: /^\s*({|else\b)/
                }),
                "String BlockComment": () => null,
                "AttributeItem": cx => cx.continue(),
                "Statement MatchArm": continuedIndent()
            }), foldNodeProp.add(type => {
                if (/(Block|edTokens|List)$/.test(type.name))
                    return foldInside;
                if (type.name == "BlockComment")
                    return tree => ({
                        from: tree.from + 2,
                        to: tree.to - 2
                    });
                return undefined;
            })]
        }),
        languageData: {
            commentTokens: {
                line: "//",
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            indentOnInput: /^\s*(?:\{|\})$/
        }
    });
    function rust() {
        return new LanguageSupport(rustLanguage);
    }
    var _m18 = Object.freeze({
        __proto__: null,
        rust: rust,
        rustLanguage: rustLanguage
    });
    const StartTag = 1,
        StartCloseTag = 2,
        MissingCloseTag = 3,
        mismatchedStartCloseTag = 4,
        incompleteStartCloseTag = 5,
        commentContent$1 = 35,
        piContent$1 = 36,
        cdataContent$1 = 37,
        Element$3 = 11,
        OpenTag = 13;
    function nameChar(ch) {
        return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
    }
    function isSpace(ch) {
        return ch == 9 || ch == 10 || ch == 13 || ch == 32;
    }
    let cachedName = null,
        cachedInput = null,
        cachedPos = 0;
    function tagNameAfter(input, offset) {
        let pos = input.pos + offset;
        if (cachedInput == input && cachedPos == pos)
            return cachedName;
        while (isSpace(input.peek(offset)))
            offset++;
        let name = "";
        for (;;) {
            let next = input.peek(offset);
            if (!nameChar(next))
                break;
            name += String.fromCharCode(next);
            offset++;
        }
        cachedInput = input;
        cachedPos = pos;
        return cachedName = name || null;
    }
    function ElementContext(name, parent) {
        this.name = name;
        this.parent = parent;
        this.hash = parent ? parent.hash : 0;
        for (let i = 0; i < name.length; i++)
            this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);
    }
    const elementContext = new ContextTracker({
        start: null,
        shift(context, term, stack, input) {
            return term == StartTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
        },
        reduce(context, term) {
            return term == Element$3 && context ? context.parent : context;
        },
        reuse(context, node, _stack, input) {
            let type = node.type.id;
            return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
        },
        hash(context) {
            return context ? context.hash : 0;
        },
        strict: false
    });
    const startTag = new ExternalTokenizer((input, stack) => {
        if (input.next != 60)
            return;
        input.advance();
        if (input.next == 47) {
            input.advance();
            let name = tagNameAfter(input, 0);
            if (!name)
                return input.acceptToken(incompleteStartCloseTag);
            if (stack.context && name == stack.context.name)
                return input.acceptToken(StartCloseTag);
            for (let cx = stack.context; cx; cx = cx.parent)
                if (cx.name == name)
                    return input.acceptToken(MissingCloseTag, -2);
            input.acceptToken(mismatchedStartCloseTag);
        } else if (input.next != 33 && input.next != 63) {
            return input.acceptToken(StartTag);
        }
    }, {
        contextual: true
    });
    function scanTo(type, end) {
        return new ExternalTokenizer(input => {
            for (let endPos = 0, len = 0; ; len++) {
                if (input.next < 0) {
                    if (len)
                        input.acceptToken(type);
                    break;
                }
                if (input.next == end.charCodeAt(endPos)) {
                    endPos++;
                    if (endPos == end.length) {
                        if (len > end.length)
                            input.acceptToken(type, 1 - end.length);
                        break;
                    }
                } else {
                    endPos = input.next == end.charCodeAt(0) ? 1 : 0;
                }
                input.advance();
            }
        });
    }
    const commentContent = scanTo(commentContent$1, "-->");
    const piContent = scanTo(piContent$1, "?>");
    const cdataContent = scanTo(cdataContent$1, "]]>");
    const xmlHighlighting = styleTags({
        Text: tags$1.content,
        "StartTag StartCloseTag EndTag SelfCloseEndTag": tags$1.angleBracket,
        TagName: tags$1.tagName,
        "MismatchedCloseTag/Tagname": [tags$1.tagName, tags$1.invalid],
        AttributeName: tags$1.attributeName,
        AttributeValue: tags$1.attributeValue,
        Is: tags$1.definitionOperator,
        "EntityReference CharacterReference": tags$1.character,
        Comment: tags$1.blockComment,
        ProcessingInst: tags$1.processingInstruction,
        DoctypeDecl: tags$1.documentMeta,
        Cdata: tags$1.special(tags$1.string)
    });
    const parser$3 = LRParser.deserialize({
        version: 14,
        states: ",SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.t",
        stateData: ")Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O",
        goto: "%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb",
        nodeNames: "⚠ StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
        maxTerm: 47,
        context: elementContext,
        nodeProps: [["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"], ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"]],
        propSources: [xmlHighlighting],
        skippedNodes: [0],
        repeatNodeCount: 8,
        tokenData: "Az~R!WOX$kXY%rYZ%rZ]$k]^%r^p$kpq%rqr$krs&tsv$kvw'Uw}$k}!O(q!O!P$k!P!Q*n!Q![$k![!]+z!]!^$k!^!_/s!_!`=i!`!a>U!a!b>q!b!c$k!c!}+z!}#P$k#P#Q?}#Q#R$k#R#S+z#S#T$k#T#o+z#o%W$k%W%o+z%o%p$k%p&a+z&a&b$k&b1p+z1p4U$k4U4d+z4d4e$k4e$IS+z$IS$I`$k$I`$Ib+z$Ib$Kh$k$Kh%#t+z%#t&/x$k&/x&Et+z&Et&FV$k&FV;'S+z;'S;:j/S;:j?&r$k?&r?Ah+z?Ah?BY$k?BY?Mn+z?Mn~$kX$rUVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$kP%ZRVPOv%Uw!^%U!_~%UW%iR{WOr%dsv%dw~%d_%{]VP{WyUOX$kXY%rYZ%rZ]$k]^%r^p$kpq%rqr$krs%Usv$kw!^$k!^!_%d!_~$kZ&{RzYVPOv%Uw!^%U!_~%U~'XTOp'hqs'hst(Pt!]'h!^~'h~'kTOp'hqs'ht!]'h!]!^'z!^~'h~(POW~~(SROp(]q!](]!^~(]~(`SOp(]q!](]!]!^(l!^~(]~(qOX~Z(xWVP{WOr$krs%Usv$kw}$k}!O)b!O!^$k!^!_%d!_~$kZ)iWVP{WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a*R!a~$kZ*[U|QVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$k]*uWVP{WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a+_!a~$k]+hUdSVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$k_,V}`S^QVP{WOr$krs%Usv$kw}$k}!O+z!O!P+z!P!Q$k!Q![+z![!]+z!]!^$k!^!_%d!_!c$k!c!}+z!}#R$k#R#S+z#S#T$k#T#o+z#o$}$k$}%O+z%O%W$k%W%o+z%o%p$k%p&a+z&a&b$k&b1p+z1p4U+z4U4d+z4d4e$k4e$IS+z$IS$I`$k$I`$Ib+z$Ib$Je$k$Je$Jg+z$Jg$Kh$k$Kh%#t+z%#t&/x$k&/x&Et+z&Et&FV$k&FV;'S+z;'S;:j/S;:j?&r$k?&r?Ah+z?Ah?BY$k?BY?Mn+z?Mn~$k_/ZWVP{WOr$krs%Usv$kw!^$k!^!_%d!_;=`$k;=`<%l+z<%l~$kX/xU{WOq%dqr0[sv%dw!a%d!a!b=X!b~%dX0aZ{WOr%dsv%dw}%d}!O1S!O!f%d!f!g1x!g!}%d!}#O5s#O#W%d#W#X:k#X~%dX1XT{WOr%dsv%dw}%d}!O1h!O~%dX1oR}P{WOr%dsv%dw~%dX1}T{WOr%dsv%dw!q%d!q!r2^!r~%dX2cT{WOr%dsv%dw!e%d!e!f2r!f~%dX2wT{WOr%dsv%dw!v%d!v!w3W!w~%dX3]T{WOr%dsv%dw!{%d!{!|3l!|~%dX3qT{WOr%dsv%dw!r%d!r!s4Q!s~%dX4VT{WOr%dsv%dw!g%d!g!h4f!h~%dX4kV{WOr4frs5Qsv4fvw5Qw!`4f!`!a5c!a~4fP5TRO!`5Q!`!a5^!a~5QP5cOiPX5jRiP{WOr%dsv%dw~%dX5xV{WOr%dsv%dw!e%d!e!f6_!f#V%d#V#W8w#W~%dX6dT{WOr%dsv%dw!f%d!f!g6s!g~%dX6xT{WOr%dsv%dw!c%d!c!d7X!d~%dX7^T{WOr%dsv%dw!v%d!v!w7m!w~%dX7rT{WOr%dsv%dw!c%d!c!d8R!d~%dX8WT{WOr%dsv%dw!}%d!}#O8g#O~%dX8nR{WxPOr%dsv%dw~%dX8|T{WOr%dsv%dw#W%d#W#X9]#X~%dX9bT{WOr%dsv%dw#T%d#T#U9q#U~%dX9vT{WOr%dsv%dw#h%d#h#i:V#i~%dX:[T{WOr%dsv%dw#T%d#T#U8R#U~%dX:pT{WOr%dsv%dw#c%d#c#d;P#d~%dX;UT{WOr%dsv%dw#V%d#V#W;e#W~%dX;jT{WOr%dsv%dw#h%d#h#i;y#i~%dX<OT{WOr%dsv%dw#m%d#m#n<_#n~%dX<dT{WOr%dsv%dw#d%d#d#e<s#e~%dX<xT{WOr%dsv%dw#X%d#X#Y4f#Y~%dX=`R!PP{WOr%dsv%dw~%dZ=rUaQVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$k_>_U[UVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$kZ>xWVP{WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a?b!a~$kZ?kU!OQVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$kZ@UWVP{WOr$krs%Usv$kw!^$k!^!_%d!_#P$k#P#Q@n#Q~$kZ@uWVP{WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!aA_!a~$kZAhUwQVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$k",
        tokenizers: [startTag, commentContent, piContent, cdataContent, 0, 1, 2, 3],
        topRules: {
            "Document": [0, 6]
        },
        tokenPrec: 0
    });
    function tagName$1(doc, tag) {
        let name = tag && tag.getChild("TagName");
        return name ? doc.sliceString(name.from, name.to) : "";
    }
    function elementName(doc, tree) {
        let tag = tree && tree.firstChild;
        return !tag || tag.name != "OpenTag" ? "" : tagName$1(doc, tag);
    }
    function attrName(doc, tag, pos) {
        let attr = tag && tag.getChildren("Attribute").find(a => a.from <= pos && a.to >= pos);
        let name = attr && attr.getChild("AttributeName");
        return name ? doc.sliceString(name.from, name.to) : "";
    }
    function findParentElement(tree) {
        for (let cur = tree && tree.parent; cur; cur = cur.parent)
            if (cur.name == "Element")
                return cur;
        return null;
    }
    function findLocation(state, pos) {
        var _a;
        let at = syntaxTree(state).resolveInner(pos, -1),
            inTag = null;
        for (let cur = at; !inTag && cur.parent; cur = cur.parent)
            if (cur.name == "OpenTag" || cur.name == "CloseTag" || cur.name == "SelfClosingTag" || cur.name == "MismatchedCloseTag")
                inTag = cur;
        if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {
            let elt = inTag.parent;
            if (at.name == "TagName")
                return inTag.name == "CloseTag" || inTag.name == "MismatchedCloseTag" ? {
                    type: "closeTag",
                    from: at.from,
                    context: elt
                } : {
                    type: "openTag",
                    from: at.from,
                    context: findParentElement(elt)
                };
            if (at.name == "AttributeName")
                return {
                    type: "attrName",
                    from: at.from,
                    context: inTag
                };
            if (at.name == "AttributeValue")
                return {
                    type: "attrValue",
                    from: at.from,
                    context: inTag
                };
            let before = at == inTag || at.name == "Attribute" ? at.childBefore(pos) : at;
            if ((before === null || before === void 0 ? void 0 : before.name) == "StartTag")
                return {
                    type: "openTag",
                    from: pos,
                    context: findParentElement(elt)
                };
            if ((before === null || before === void 0 ? void 0 : before.name) == "StartCloseTag" && before.to <= pos)
                return {
                    type: "closeTag",
                    from: pos,
                    context: elt
                };
            if ((before === null || before === void 0 ? void 0 : before.name) == "Is")
                return {
                    type: "attrValue",
                    from: pos,
                    context: inTag
                };
            if (before)
                return {
                    type: "attrName",
                    from: pos,
                    context: inTag
                };
            return null;
        } else if (at.name == "StartCloseTag") {
            return {
                type: "closeTag",
                from: pos,
                context: at.parent
            };
        }
        while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError))
            at = at.parent;
        if (at.name == "Element" || at.name == "Text" || at.name == "Document")
            return {
                type: "tag",
                from: pos,
                context: at.name == "Element" ? at : findParentElement(at)
            };
        return null;
    }
    class Element$2 {
        constructor(spec, attrs, attrValues)
        {
            this.attrs = attrs;
            this.attrValues = attrValues;
            this.children = [];
            this.name = spec.name;
            this.completion = Object.assign(Object.assign({
                type: "type"
            }, spec.completion || {}), {
                label: this.name
            });
            this.openCompletion = Object.assign(Object.assign({}, this.completion), {
                label: "<" + this.name
            });
            this.closeCompletion = Object.assign(Object.assign({}, this.completion), {
                label: "</" + this.name + ">",
                boost: 2
            });
            this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), {
                label: this.name + ">"
            });
            this.text = spec.textContent ? spec.textContent.map(s => ({
                label: s,
                type: "text"
            })) : [];
        }
    }
    const Identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
    function attrCompletion(spec) {
        return Object.assign(Object.assign({
            type: "property"
        }, spec.completion || {}), {
            label: spec.name
        });
    }
    function valueCompletion(spec) {
        return typeof spec == "string" ? {
            label: `"${spec}"`,
            type: "constant"
        } : /^"/.test(spec.label) ? spec : Object.assign(Object.assign({}, spec), {
            label: `"${spec.label}"`
        });
    }
    function completeFromSchema(eltSpecs, attrSpecs) {
        let allAttrs = [],
            globalAttrs = [];
        let attrValues = Object.create(null);
        for (let _i262 = 0, _length262 = attrSpecs.length; _i262 < _length262; _i262++) {
            let s = attrSpecs[_i262];
            let completion = attrCompletion(s);
            allAttrs.push(completion);
            if (s.global)
                globalAttrs.push(completion);
            if (s.values)
                attrValues[s.name] = s.values.map(valueCompletion);
        }
        let allElements = [],
            topElements = [];
        let byName = Object.create(null);
        for (let _i263 = 0, _length263 = eltSpecs.length; _i263 < _length263; _i263++) {
            let s = eltSpecs[_i263];
            let attrs = globalAttrs,
                attrVals = attrValues;
            if (s.attributes)
                attrs = attrs.concat(s.attributes.map(s => {
                    if (typeof s == "string")
                        return allAttrs.find(a => a.label == s) || {
                                label: s,
                                type: "property"
                            };
                    if (s.values) {
                        if (attrVals == attrValues)
                            attrVals = Object.create(attrVals);
                        attrVals[s.name] = s.values.map(valueCompletion);
                    }
                    return attrCompletion(s);
                }));
            let elt = new Element$2(s, attrs, attrVals);
            byName[elt.name] = elt;
            allElements.push(elt);
            if (s.top)
                topElements.push(elt);
        }
        if (!topElements.length)
            topElements = allElements;
        for (let i = 0; i < allElements.length; i++) {
            let s = eltSpecs[i],
                elt = allElements[i];
            if (s.children) {
                for (let _i264 = 0, _s$children = s.children, _length264 = _s$children.length; _i264 < _length264; _i264++) {
                    let ch = _s$children[_i264];
                    if (byName[ch])
                        elt.children.push(byName[ch]);
                }
            } else {
                elt.children = allElements;
            }
        }
        return cx => {
            var _a;
            let {doc} = cx.state,
                loc = findLocation(cx.state, cx.pos);
            if (!loc || loc.type == "tag" && !cx.explicit)
                return null;
            let {type, from, context} = loc;
            if (type == "openTag") {
                let children = topElements;
                let parentName = elementName(doc, context);
                if (parentName) {
                    let parent = byName[parentName];
                    children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;
                }
                return {
                    from,
                    options: children.map(ch => ch.completion),
                    validFor: Identifier
                };
            } else if (type == "closeTag") {
                let parentName = elementName(doc, context);
                return parentName ? {
                    from,
                    to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == ">" ? 1 : 0),
                    options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || {
                        label: parentName + ">",
                        type: "type"
                    }],
                    validFor: Identifier
                } : null;
            } else if (type == "attrName") {
                let parent = byName[tagName$1(doc, context)];
                return {
                    from,
                    options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,
                    validFor: Identifier
                };
            } else if (type == "attrValue") {
                let attr = attrName(doc, context, from);
                if (!attr)
                    return null;
                let parent = byName[tagName$1(doc, context)];
                let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];
                if (!values || !values.length)
                    return null;
                return {
                    from,
                    to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '"' ? 1 : 0),
                    options: values,
                    validFor: /^"[^"]*"?$/
                };
            } else if (type == "tag") {
                let parentName = elementName(doc, context),
                    parent = byName[parentName];
                let closing = [],
                    last = context && context.lastChild;
                if (parentName && (!last || last.name != "CloseTag" || tagName$1(doc, last) != parentName))
                    closing.push(parent ? parent.closeCompletion : {
                        label: "</" + parentName + ">",
                        type: "type",
                        boost: 2
                    });
                let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));
                if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {
                    let openTag = context.firstChild;
                    if (openTag.to > cx.pos - 20 && !/\S/.test(cx.state.sliceDoc(openTag.to, cx.pos)))
                        options = options.concat(parent.text);
                }
                return {
                    from,
                    options,
                    validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
                };
            } else {
                return null;
            }
        };
    }
    const xmlLanguage = LRLanguage.define({
        name: "xml",
        parser: parser$3.configure({
            props: [indentNodeProp.add({
                Element(context) {
                    let closed = /^\s*<\//.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                "OpenTag CloseTag SelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                }
            }), foldNodeProp.add({
                Element(subtree) {
                    let first = subtree.firstChild,
                        last = subtree.lastChild;
                    if (!first || first.name != "OpenTag")
                        return null;
                    return {
                        from: first.to,
                        to: last.name == "CloseTag" ? last.from : subtree.to
                    };
                }
            }), bracketMatchingHandle.add({
                "OpenTag CloseTag": node => node.getChild("TagName")
            })]
        }),
        languageData: {
            commentTokens: {
                block: {
                    open: "<!--",
                    close: "-->"
                }
            },
            indentOnInput: /^\s*<\/$/
        }
    });
    function xml(conf={}) {
        return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({
            autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])
        }));
    }
    var _m19 = Object.freeze({
        __proto__: null,
        completeFromSchema: completeFromSchema,
        xml: xml,
        xmlLanguage: xmlLanguage
    });
    class CompositeBlock {
        constructor(type, value, from, hash, end, children, positions)
        {
            this.type = type;
            this.value = value;
            this.from = from;
            this.hash = hash;
            this.end = end;
            this.children = children;
            this.positions = positions;
            this.hashProp = [[NodeProp.contextHash, hash]];
        }
        static create(type, value, from, parentHash, end)
        {
            let hash = parentHash + (parentHash << 8) + type + (value << 4) | 0;
            return new CompositeBlock(type, value, from, hash, end, [], []);
        }
        addChild(child, pos)
        {
            if (child.prop(NodeProp.contextHash) != this.hash)
                child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);
            this.children.push(child);
            this.positions.push(pos);
        }
        toTree(nodeSet, end=this.end)
        {
            let last = this.children.length - 1;
            if (last >= 0)
                end = Math.max(end, this.positions[last] + this.children[last].length + this.from);
            let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({
                makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)
            });
            return tree;
        }
    }
    var Type;
    (function(Type) {
        Type[Type["Document"] = 1] = "Document";
        Type[Type["CodeBlock"] = 2] = "CodeBlock";
        Type[Type["FencedCode"] = 3] = "FencedCode";
        Type[Type["Blockquote"] = 4] = "Blockquote";
        Type[Type["HorizontalRule"] = 5] = "HorizontalRule";
        Type[Type["BulletList"] = 6] = "BulletList";
        Type[Type["OrderedList"] = 7] = "OrderedList";
        Type[Type["ListItem"] = 8] = "ListItem";
        Type[Type["ATXHeading1"] = 9] = "ATXHeading1";
        Type[Type["ATXHeading2"] = 10] = "ATXHeading2";
        Type[Type["ATXHeading3"] = 11] = "ATXHeading3";
        Type[Type["ATXHeading4"] = 12] = "ATXHeading4";
        Type[Type["ATXHeading5"] = 13] = "ATXHeading5";
        Type[Type["ATXHeading6"] = 14] = "ATXHeading6";
        Type[Type["SetextHeading1"] = 15] = "SetextHeading1";
        Type[Type["SetextHeading2"] = 16] = "SetextHeading2";
        Type[Type["HTMLBlock"] = 17] = "HTMLBlock";
        Type[Type["LinkReference"] = 18] = "LinkReference";
        Type[Type["Paragraph"] = 19] = "Paragraph";
        Type[Type["CommentBlock"] = 20] = "CommentBlock";
        Type[Type["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
        Type[Type["Escape"] = 22] = "Escape";
        Type[Type["Entity"] = 23] = "Entity";
        Type[Type["HardBreak"] = 24] = "HardBreak";
        Type[Type["Emphasis"] = 25] = "Emphasis";
        Type[Type["StrongEmphasis"] = 26] = "StrongEmphasis";
        Type[Type["Link"] = 27] = "Link";
        Type[Type["Image"] = 28] = "Image";
        Type[Type["InlineCode"] = 29] = "InlineCode";
        Type[Type["HTMLTag"] = 30] = "HTMLTag";
        Type[Type["Comment"] = 31] = "Comment";
        Type[Type["ProcessingInstruction"] = 32] = "ProcessingInstruction";
        Type[Type["URL"] = 33] = "URL";
        Type[Type["HeaderMark"] = 34] = "HeaderMark";
        Type[Type["QuoteMark"] = 35] = "QuoteMark";
        Type[Type["ListMark"] = 36] = "ListMark";
        Type[Type["LinkMark"] = 37] = "LinkMark";
        Type[Type["EmphasisMark"] = 38] = "EmphasisMark";
        Type[Type["CodeMark"] = 39] = "CodeMark";
        Type[Type["CodeText"] = 40] = "CodeText";
        Type[Type["CodeInfo"] = 41] = "CodeInfo";
        Type[Type["LinkTitle"] = 42] = "LinkTitle";
        Type[Type["LinkLabel"] = 43] = "LinkLabel";
    })(Type || (Type = {}));
    class LeafBlock {
        constructor(start, content)
        {
            this.start = start;
            this.content = content;
            this.marks = [];
            this.parsers = [];
        }
    }
    class Line {
        constructor()
        {
            this.text = "";
            this.baseIndent = 0;
            this.basePos = 0;
            this.depth = 0;
            this.markers = [];
            this.pos = 0;
            this.indent = 0;
            this.next = -1;
        }
        forward()
        {
            if (this.basePos > this.pos)
                this.forwardInner();
        }
        forwardInner()
        {
            let newPos = this.skipSpace(this.basePos);
            this.indent = this.countIndent(newPos, this.pos, this.indent);
            this.pos = newPos;
            this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
        }
        skipSpace(from)
        {
            return skipSpace(this.text, from);
        }
        reset(text)
        {
            this.text = text;
            this.baseIndent = this.basePos = this.pos = this.indent = 0;
            this.forwardInner();
            this.depth = 1;
            while (this.markers.length)
                this.markers.pop();
        }
        moveBase(to)
        {
            this.basePos = to;
            this.baseIndent = this.countIndent(to, this.pos, this.indent);
        }
        moveBaseColumn(indent)
        {
            this.baseIndent = indent;
            this.basePos = this.findColumn(indent);
        }
        addMarker(elt)
        {
            this.markers.push(elt);
        }
        countIndent(to, from=0, indent=0)
        {
            for (let i = from; i < to; i++)
                indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
            return indent;
        }
        findColumn(goal)
        {
            let i = 0;
            for (let indent = 0; i < this.text.length && indent < goal; i++)
                indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
            return i;
        }
        scrub()
        {
            if (!this.baseIndent)
                return this.text;
            let result = "";
            for (let i = 0; i < this.basePos; i++)
                result += " ";
            return result + this.text.slice(this.basePos);
        }
    }
    function skipForList(bl, cx, line) {
        if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent)
            return true;
        if (line.indent >= line.baseIndent + 4)
            return false;
        let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);
        return size > 0 && (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;
    }
    const DefaultSkipMarkup = {
        [Type.Blockquote](bl, cx, line) {
            if (line.next != 62)
                return false;
            line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));
            line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));
            bl.end = cx.lineStart + line.text.length;
            return true;
        },
        [Type.ListItem](bl, _cx, line) {
            if (line.indent < line.baseIndent + bl.value && line.next > -1)
                return false;
            line.moveBaseColumn(line.baseIndent + bl.value);
            return true;
        },
        [Type.OrderedList]: skipForList,
        [Type.BulletList]: skipForList,
        [Type.Document]() {
            return true;
        }
    };
    function space(ch) {
        return ch == 32 || ch == 9 || ch == 10 || ch == 13;
    }
    function skipSpace(line, i=0) {
        while (i < line.length && space(line.charCodeAt(i)))
            i++;
        return i;
    }
    function skipSpaceBack(line, i, to) {
        while (i > to && space(line.charCodeAt(i - 1)))
            i--;
        return i;
    }
    function isFencedCode(line) {
        if (line.next != 96 && line.next != 126)
            return -1;
        let pos = line.pos + 1;
        while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
            pos++;
        if (pos < line.pos + 3)
            return -1;
        if (line.next == 96)
            for (let i = pos; i < line.text.length; i++)
                if (line.text.charCodeAt(i) == 96)
                    return -1;
        return pos;
    }
    function isBlockquote(line) {
        return line.next != 62 ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;
    }
    function isHorizontalRule(line, cx, breaking) {
        if (line.next != 42 && line.next != 45 && line.next != 95)
            return -1;
        let count = 1;
        for (let pos = line.pos + 1; pos < line.text.length; pos++) {
            let ch = line.text.charCodeAt(pos);
            if (ch == line.next)
                count++;
            else if (!space(ch))
                return -1;
        }
        if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)
            return -1;
        return count < 3 ? -1 : 1;
    }
    function inList(cx, type) {
        for (let i = cx.stack.length - 1; i >= 0; i--)
            if (cx.stack[i].type == type)
                return true;
        return false;
    }
    function isBulletList(line, cx, breaking) {
        return (line.next == 45 || line.next == 43 || line.next == 42) && (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;
    }
    function isOrderedList(line, cx, breaking) {
        let pos = line.pos,
            next = line.next;
        for (;;) {
            if (next >= 48 && next <= 57)
                pos++;
            else
                break;
            if (pos == line.text.length)
                return -1;
            next = line.text.charCodeAt(pos);
        }
        if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41 || pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49))
            return -1;
        return pos + 1 - line.pos;
    }
    function isAtxHeading(line) {
        if (line.next != 35)
            return -1;
        let pos = line.pos + 1;
        while (pos < line.text.length && line.text.charCodeAt(pos) == 35)
            pos++;
        if (pos < line.text.length && line.text.charCodeAt(pos) != 32)
            return -1;
        let size = pos - line.pos;
        return size > 6 ? -1 : size;
    }
    function isSetextUnderline(line) {
        if (line.next != 45 && line.next != 61 || line.indent >= line.baseIndent + 4)
            return -1;
        let pos = line.pos + 1;
        while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
            pos++;
        let end = pos;
        while (pos < line.text.length && space(line.text.charCodeAt(pos)))
            pos++;
        return pos == line.text.length ? end : -1;
    }
    const EmptyLine = /^[ \t]*$/,
        CommentEnd = /-->/,
        ProcessingEnd = /\?>/;
    const HTMLBlockStyle = [[/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i], [/^\s*<!--/, CommentEnd], [/^\s*<\?/, ProcessingEnd], [/^\s*<![A-Z]/, />/], [/^\s*<!\[CDATA\[/, /\]\]>/], [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine], [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]];
    function isHTMLBlock(line, _cx, breaking) {
        if (line.next != 60)
            return -1;
        let rest = line.text.slice(line.pos);
        for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)
            if (HTMLBlockStyle[i][0].test(rest))
                return i;
        return -1;
    }
    function getListIndent(line, pos) {
        let indentAfter = line.countIndent(pos, line.pos, line.indent);
        let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);
        return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
    }
    function addCodeText(marks, from, to) {
        let last = marks.length - 1;
        if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)
            marks[last].to = to;
        else
            marks.push(elt(Type.CodeText, from, to));
    }
    const DefaultBlockParsers = {
        LinkReference: undefined,
        IndentedCode(cx, line) {
            let base = line.baseIndent + 4;
            if (line.indent < base)
                return false;
            let start = line.findColumn(base);
            let from = cx.lineStart + start,
                to = cx.lineStart + line.text.length;
            let marks = [],
                pendingMarks = [];
            addCodeText(marks, from, to);
            while (cx.nextLine() && line.depth >= cx.stack.length) {
                if (line.pos == line.text.length) {
                    addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
                    for (let _i265 = 0, _line$markers = line.markers, _length265 = _line$markers.length; _i265 < _length265; _i265++) {
                        let m = _line$markers[_i265];
                        pendingMarks.push(m);
                    }
                } else if (line.indent < base) {
                    break;
                } else {
                    if (pendingMarks.length) {
                        for (let _i266 = 0, _pendingMarks = pendingMarks, _length266 = _pendingMarks.length; _i266 < _length266; _i266++) {
                            let m = _pendingMarks[_i266];
                            if (m.type == Type.CodeText)
                                addCodeText(marks, m.from, m.to);
                            else
                                marks.push(m);
                        }
                        pendingMarks = [];
                    }
                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);
                    for (let _i267 = 0, _line$markers2 = line.markers, _length267 = _line$markers2.length; _i267 < _length267; _i267++) {
                        let m = _line$markers2[_i267];
                        marks.push(m);
                    }
                    to = cx.lineStart + line.text.length;
                    let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);
                    if (codeStart < to)
                        addCodeText(marks, codeStart, to);
                }
            }
            if (pendingMarks.length) {
                pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);
                if (pendingMarks.length)
                    line.markers = pendingMarks.concat(line.markers);
            }
            cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);
            return true;
        },
        FencedCode(cx, line) {
            let fenceEnd = isFencedCode(line);
            if (fenceEnd < 0)
                return false;
            let from = cx.lineStart + line.pos,
                ch = line.next,
                len = fenceEnd - line.pos;
            let infoFrom = line.skipSpace(fenceEnd),
                infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);
            let marks = [elt(Type.CodeMark, from, from + len)];
            if (infoFrom < infoTo)
                marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
            for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {
                let i = line.pos;
                if (line.indent - line.baseIndent < 4)
                    while (i < line.text.length && line.text.charCodeAt(i) == ch)
                        i++;
                if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {
                    for (let _i268 = 0, _line$markers3 = line.markers, _length268 = _line$markers3.length; _i268 < _length268; _i268++) {
                        let m = _line$markers3[_i268];
                        marks.push(m);
                    }
                    marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));
                    cx.nextLine();
                    break;
                } else {
                    if (!first)
                        addCodeText(marks, cx.lineStart - 1, cx.lineStart);
                    for (let _i269 = 0, _line$markers4 = line.markers, _length269 = _line$markers4.length; _i269 < _length269; _i269++) {
                        let m = _line$markers4[_i269];
                        marks.push(m);
                    }
                    let textStart = cx.lineStart + line.basePos,
                        textEnd = cx.lineStart + line.text.length;
                    if (textStart < textEnd)
                        addCodeText(marks, textStart, textEnd);
                }
            }
            cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.FencedCode, cx.prevLineEnd() - from), from);
            return true;
        },
        Blockquote(cx, line) {
            let size = isBlockquote(line);
            if (size < 0)
                return false;
            cx.startContext(Type.Blockquote, line.pos);
            cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);
            line.moveBase(line.pos + size);
            return null;
        },
        HorizontalRule(cx, line) {
            if (isHorizontalRule(line, cx, false) < 0)
                return false;
            let from = cx.lineStart + line.pos;
            cx.nextLine();
            cx.addNode(Type.HorizontalRule, from);
            return true;
        },
        BulletList(cx, line) {
            let size = isBulletList(line, cx, false);
            if (size < 0)
                return false;
            if (cx.block.type != Type.BulletList)
                cx.startContext(Type.BulletList, line.basePos, line.next);
            let newBase = getListIndent(line, line.pos + 1);
            cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
            cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
            line.moveBaseColumn(newBase);
            return null;
        },
        OrderedList(cx, line) {
            let size = isOrderedList(line, cx, false);
            if (size < 0)
                return false;
            if (cx.block.type != Type.OrderedList)
                cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));
            let newBase = getListIndent(line, line.pos + size);
            cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
            cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
            line.moveBaseColumn(newBase);
            return null;
        },
        ATXHeading(cx, line) {
            let size = isAtxHeading(line);
            if (size < 0)
                return false;
            let off = line.pos,
                from = cx.lineStart + off;
            let endOfSpace = skipSpaceBack(line.text, line.text.length, off),
                after = endOfSpace;
            while (after > off && line.text.charCodeAt(after - 1) == line.next)
                after--;
            if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))
                after = line.text.length;
            let buf = cx.buffer.write(Type.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);
            if (after < line.text.length)
                buf.write(Type.HeaderMark, after - off, endOfSpace - off);
            let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);
            cx.nextLine();
            cx.addNode(node, from);
            return true;
        },
        HTMLBlock(cx, line) {
            let type = isHTMLBlock(line, cx, false);
            if (type < 0)
                return false;
            let from = cx.lineStart + line.pos,
                end = HTMLBlockStyle[type][1];
            let marks = [],
                trailing = end != EmptyLine;
            while (!end.test(line.text) && cx.nextLine()) {
                if (line.depth < cx.stack.length) {
                    trailing = false;
                    break;
                }
                for (let _i270 = 0, _line$markers5 = line.markers, _length270 = _line$markers5.length; _i270 < _length270; _i270++) {
                    let m = _line$markers5[_i270];
                    marks.push(m);
                }
            }
            if (trailing)
                cx.nextLine();
            let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;
            let to = cx.prevLineEnd();
            cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);
            return true;
        },
        SetextHeading: undefined
    };
    class LinkReferenceParser {
        constructor(leaf)
        {
            this.stage = 0;
            this.elts = [];
            this.pos = 0;
            this.start = leaf.start;
            this.advance(leaf.content);
        }
        nextLine(cx, line, leaf)
        {
            if (this.stage == -1)
                return false;
            let content = leaf.content + "\n" + line.scrub();
            let finish = this.advance(content);
            if (finish > -1 && finish < content.length)
                return this.complete(cx, leaf, finish);
            return false;
        }
        finish(cx, leaf)
        {
            if ((this.stage == 2 || this.stage == 3) && skipSpace(leaf.content, this.pos) == leaf.content.length)
                return this.complete(cx, leaf, leaf.content.length);
            return false;
        }
        complete(cx, leaf, len)
        {
            cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));
            return true;
        }
        nextStage(elt)
        {
            if (elt) {
                this.pos = elt.to - this.start;
                this.elts.push(elt);
                this.stage++;
                return true;
            }
            if (elt === false)
                this.stage = -1;
            return false;
        }
        advance(content)
        {
            for (;;) {
                if (this.stage == -1) {
                    return -1;
                } else if (this.stage == 0) {
                    if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))
                        return -1;
                    if (content.charCodeAt(this.pos) != 58)
                        return this.stage = -1;
                    this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));
                    this.pos++;
                } else if (this.stage == 1) {
                    if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))
                        return -1;
                } else if (this.stage == 2) {
                    let skip = skipSpace(content, this.pos),
                        end = 0;
                    if (skip > this.pos) {
                        let title = parseLinkTitle(content, skip, this.start);
                        if (title) {
                            let titleEnd = lineEnd(content, title.to - this.start);
                            if (titleEnd > 0) {
                                this.nextStage(title);
                                end = titleEnd;
                            }
                        }
                    }
                    if (!end)
                        end = lineEnd(content, this.pos);
                    return end > 0 && end < content.length ? end : -1;
                } else {
                    return lineEnd(content, this.pos);
                }
            }
        }
    }
    function lineEnd(text, pos) {
        for (; pos < text.length; pos++) {
            let next = text.charCodeAt(pos);
            if (next == 10)
                break;
            if (!space(next))
                return -1;
        }
        return pos;
    }
    class SetextHeadingParser {
        nextLine(cx, line, leaf)
        {
            let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);
            let next = line.next;
            if (underline < 0)
                return false;
            let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);
            cx.nextLine();
            cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [...cx.parser.parseInline(leaf.content, leaf.start), underlineMark]));
            return true;
        }
        finish()
        {
            return false;
        }
    }
    const DefaultLeafBlocks = {
        LinkReference(_, leaf) {
            return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
        },
        SetextHeading() {
            return new SetextHeadingParser();
        }
    };
    const DefaultEndLeaf = [(_, line) => isAtxHeading(line) >= 0, (_, line) => isFencedCode(line) >= 0, (_, line) => isBlockquote(line) >= 0, (p, line) => isBulletList(line, p, true) >= 0, (p, line) => isOrderedList(line, p, true) >= 0, (p, line) => isHorizontalRule(line, p, true) >= 0, (p, line) => isHTMLBlock(line, p, true) >= 0];
    const scanLineResult = {
        text: "",
        end: 0
    };
    class BlockContext {
        constructor(parser, input, fragments, ranges)
        {
            this.parser = parser;
            this.input = input;
            this.ranges = ranges;
            this.line = new Line();
            this.atEnd = false;
            this.dontInject = new Set();
            this.stoppedAt = null;
            this.rangeI = 0;
            this.to = ranges[ranges.length - 1].to;
            this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
            this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);
            this.stack = [this.block];
            this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;
            this.readLine();
        }
        get parsedPos()
        {
            return this.absoluteLineStart;
        }
        advance()
        {
            if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
                return this.finish();
            let {line} = this;
            for (;;) {
                while (line.depth < this.stack.length)
                    this.finishContext();
                for (let _i271 = 0, _line$markers6 = line.markers, _length271 = _line$markers6.length; _i271 < _length271; _i271++) {
                    let mark = _line$markers6[_i271];
                    this.addNode(mark.type, mark.from, mark.to);
                }
                if (line.pos < line.text.length)
                    break;
                if (!this.nextLine())
                    return this.finish();
            }
            if (this.fragments && this.reuseFragment(line.basePos))
                return null;
            start:
            for (;;) {
                for (let _i272 = 0, _this$parser$blockPar = this.parser.blockParsers, _length272 = _this$parser$blockPar.length; _i272 < _length272; _i272++) {
                    let type = _this$parser$blockPar[_i272];
                    if (type) {
                        let result = type(this, line);
                        if (result != false) {
                            if (result == true)
                                return null;
                            line.forward();
                            continue start;
                        }
                    }
                }
                break;
            }
            let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));
            for (let _i273 = 0, _this$parser$leafBloc = this.parser.leafBlockParsers, _length273 = _this$parser$leafBloc.length; _i273 < _length273; _i273++) {
                let parse = _this$parser$leafBloc[_i273];
                if (parse) {
                    let parser = parse(this, leaf);
                    if (parser)
                        leaf.parsers.push(parser);
                }
            }
            lines:
            while (this.nextLine()) {
                if (line.pos == line.text.length)
                    break;
                if (line.indent < line.baseIndent + 4) {
                    for (let _i274 = 0, _this$parser$endLeafB = this.parser.endLeafBlock, _length274 = _this$parser$endLeafB.length; _i274 < _length274; _i274++) {
                        let stop = _this$parser$endLeafB[_i274];
                        if (stop(this, line, leaf))
                            break lines;
                    }
                }
                for (let _i275 = 0, _leaf$parsers = leaf.parsers, _length275 = _leaf$parsers.length; _i275 < _length275; _i275++) {
                    let parser = _leaf$parsers[_i275];
                    if (parser.nextLine(this, line, leaf))
                        return null;
                }
                leaf.content += "\n" + line.scrub();
                for (let _i276 = 0, _line$markers7 = line.markers, _length276 = _line$markers7.length; _i276 < _length276; _i276++) {
                    let m = _line$markers7[_i276];
                    leaf.marks.push(m);
                }
            }
            this.finishLeaf(leaf);
            return null;
        }
        stopAt(pos)
        {
            if (this.stoppedAt != null && this.stoppedAt < pos)
                throw new RangeError("Can't move stoppedAt forward");
            this.stoppedAt = pos;
        }
        reuseFragment(start)
        {
            if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
                return false;
            let taken = this.fragments.takeNodes(this);
            if (!taken)
                return false;
            let withoutGaps = taken,
                end = this.absoluteLineStart + taken;
            for (let i = 1; i < this.ranges.length; i++) {
                let gapFrom = this.ranges[i - 1].to,
                    gapTo = this.ranges[i].from;
                if (gapFrom >= this.lineStart && gapTo < end)
                    withoutGaps -= gapTo - gapFrom;
            }
            this.lineStart += withoutGaps;
            this.absoluteLineStart += taken;
            this.moveRangeI();
            if (this.absoluteLineStart < this.to) {
                this.lineStart++;
                this.absoluteLineStart++;
                this.readLine();
            } else {
                this.atEnd = true;
                this.readLine();
            }
            return true;
        }
        get depth()
        {
            return this.stack.length;
        }
        parentType(depth=this.depth - 1)
        {
            return this.parser.nodeSet.types[this.stack[depth].type];
        }
        nextLine()
        {
            this.lineStart += this.line.text.length;
            if (this.absoluteLineEnd >= this.to) {
                this.absoluteLineStart = this.absoluteLineEnd;
                this.atEnd = true;
                this.readLine();
                return false;
            } else {
                this.lineStart++;
                this.absoluteLineStart = this.absoluteLineEnd + 1;
                this.moveRangeI();
                this.readLine();
                return true;
            }
        }
        moveRangeI()
        {
            while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {
                this.rangeI++;
                this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
            }
        }
        scanLine(start)
        {
            let r = scanLineResult;
            r.end = start;
            if (start >= this.to) {
                r.text = "";
            } else {
                r.text = this.lineChunkAt(start);
                r.end += r.text.length;
                if (this.ranges.length > 1) {
                    let textOffset = this.absoluteLineStart,
                        rangeI = this.rangeI;
                    while (this.ranges[rangeI].to < r.end) {
                        rangeI++;
                        let nextFrom = this.ranges[rangeI].from;
                        let after = this.lineChunkAt(nextFrom);
                        r.end = nextFrom + after.length;
                        r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
                        textOffset = r.end - r.text.length;
                    }
                }
            }
            return r;
        }
        readLine()
        {
            let {line} = this,
                {text, end} = this.scanLine(this.absoluteLineStart);
            this.absoluteLineEnd = end;
            line.reset(text);
            for (; line.depth < this.stack.length; line.depth++) {
                let cx = this.stack[line.depth],
                    handler = this.parser.skipContextMarkup[cx.type];
                if (!handler)
                    throw new Error("Unhandled block context " + Type[cx.type]);
                if (!handler(cx, this, line))
                    break;
                line.forward();
            }
        }
        lineChunkAt(pos)
        {
            let next = this.input.chunk(pos),
                text;
            if (!this.input.lineChunks) {
                let eol = next.indexOf("\n");
                text = eol < 0 ? next : next.slice(0, eol);
            } else {
                text = next == "\n" ? "" : next;
            }
            return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;
        }
        prevLineEnd()
        {
            return this.atEnd ? this.lineStart : this.lineStart - 1;
        }
        startContext(type, start, value=0)
        {
            this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
            this.stack.push(this.block);
        }
        startComposite(type, start, value=0)
        {
            this.startContext(this.parser.getNodeType(type), start, value);
        }
        addNode(block, from, to)
        {
            if (typeof block == "number")
                block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);
            this.block.addChild(block, from - this.block.from);
        }
        addElement(elt)
        {
            this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);
        }
        addLeafElement(leaf, elt)
        {
            this.addNode(this.buffer.writeElements(injectMarks(elt.children, leaf.marks), -elt.from).finish(elt.type, elt.to - elt.from), elt.from);
        }
        finishContext()
        {
            let cx = this.stack.pop();
            let top = this.stack[this.stack.length - 1];
            top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);
            this.block = top;
        }
        finish()
        {
            while (this.stack.length > 1)
                this.finishContext();
            return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
        }
        addGaps(tree)
        {
            return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;
        }
        finishLeaf(leaf)
        {
            for (let _i277 = 0, _leaf$parsers2 = leaf.parsers, _length277 = _leaf$parsers2.length; _i277 < _length277; _i277++) {
                let parser = _leaf$parsers2[_i277];
                if (parser.finish(this, leaf))
                    return;
            }
            let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
            this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);
        }
        elt(type, from, to, children)
        {
            if (typeof type == "string")
                return elt(this.parser.getNodeType(type), from, to, children);
            return new TreeElement(type, from);
        }
        get buffer()
        {
            return new Buffer(this.parser.nodeSet);
        }
    }
    function injectGaps(ranges, rangeI, tree, offset, dont) {
        if (dont.has(tree.tree))
            return tree.tree;
        let rangeEnd = ranges[rangeI].to;
        let children = [],
            positions = [],
            start = tree.from + offset;
        function movePastNext(upto, inclusive) {
            while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {
                let size = ranges[rangeI + 1].from - rangeEnd;
                offset += size;
                upto += size;
                rangeI++;
                rangeEnd = ranges[rangeI].to;
            }
        }
        for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {
            movePastNext(ch.from + offset, true);
            let from = ch.from + offset,
                node;
            if (ch.to + offset > rangeEnd) {
                node = injectGaps(ranges, rangeI, ch, offset, dont);
                movePastNext(ch.to + offset, false);
            } else {
                node = ch.toTree();
            }
            children.push(node);
            positions.push(from - start);
        }
        movePastNext(tree.to + offset, false);
        return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);
    }
    class MarkdownParser extends Parser {
        constructor(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers)
        {
            super();
            this.nodeSet = nodeSet;
            this.blockParsers = blockParsers;
            this.leafBlockParsers = leafBlockParsers;
            this.blockNames = blockNames;
            this.endLeafBlock = endLeafBlock;
            this.skipContextMarkup = skipContextMarkup;
            this.inlineParsers = inlineParsers;
            this.inlineNames = inlineNames;
            this.wrappers = wrappers;
            this.nodeTypes = Object.create(null);
            for (let _i278 = 0, _nodeSet$types = nodeSet.types, _length278 = _nodeSet$types.length; _i278 < _length278; _i278++) {
                let t = _nodeSet$types[_i278];
                this.nodeTypes[t.name] = t.id;
            }
        }
        createParse(input, fragments, ranges)
        {
            let parse = new BlockContext(this, input, fragments, ranges);
            for (let _i279 = 0, _this$wrappers2 = this.wrappers, _length279 = _this$wrappers2.length; _i279 < _length279; _i279++) {
                let w = _this$wrappers2[_i279];
                parse = w(parse, input, fragments, ranges);
            }
            return parse;
        }
        configure(spec)
        {
            let config = resolveConfig(spec);
            if (!config)
                return this;
            let {nodeSet, skipContextMarkup} = this;
            let blockParsers = this.blockParsers.slice(),
                leafBlockParsers = this.leafBlockParsers.slice(),
                blockNames = this.blockNames.slice(),
                inlineParsers = this.inlineParsers.slice(),
                inlineNames = this.inlineNames.slice(),
                endLeafBlock = this.endLeafBlock.slice(),
                wrappers = this.wrappers;
            if (nonEmpty(config.defineNodes)) {
                skipContextMarkup = Object.assign({}, skipContextMarkup);
                let nodeTypes = nodeSet.types.slice(),
                    styles;
                for (let _i280 = 0, _config$defineNodes = config.defineNodes, _length280 = _config$defineNodes.length; _i280 < _length280; _i280++) {
                    let s = _config$defineNodes[_i280];
                    let {name, block, composite, style} = typeof s == "string" ? {
                        name: s
                    } : s;
                    if (nodeTypes.some(t => t.name == name))
                        continue;
                    if (composite)
                        skipContextMarkup[nodeTypes.length] = (bl, cx, line) => composite(cx, line, bl.value);
                    let id = nodeTypes.length;
                    let group = composite ? ["Block", "BlockContext"] : !block ? undefined : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
                    nodeTypes.push(NodeType.define({
                        id,
                        name,
                        props: group && [[NodeProp.group, group]]
                    }));
                    if (style) {
                        if (!styles)
                            styles = {};
                        if (Array.isArray(style) || style instanceof Tag)
                            styles[name] = style;
                        else
                            Object.assign(styles, style);
                    }
                }
                nodeSet = new NodeSet(nodeTypes);
                if (styles)
                    nodeSet = nodeSet.extend(styleTags(styles));
            }
            if (nonEmpty(config.props))
                nodeSet = nodeSet.extend(...config.props);
            if (nonEmpty(config.remove)) {
                for (let _i281 = 0, _config$remove = config.remove, _length281 = _config$remove.length; _i281 < _length281; _i281++) {
                    let rm = _config$remove[_i281];
                    let block = this.blockNames.indexOf(rm),
                        inline = this.inlineNames.indexOf(rm);
                    if (block > -1)
                        blockParsers[block] = leafBlockParsers[block] = undefined;
                    if (inline > -1)
                        inlineParsers[inline] = undefined;
                }
            }
            if (nonEmpty(config.parseBlock)) {
                for (let _i282 = 0, _config$parseBlock = config.parseBlock, _length282 = _config$parseBlock.length; _i282 < _length282; _i282++) {
                    let spec = _config$parseBlock[_i282];
                    let found = blockNames.indexOf(spec.name);
                    if (found > -1) {
                        blockParsers[found] = spec.parse;
                        leafBlockParsers[found] = spec.leaf;
                    } else {
                        let pos = spec.before ? findName(blockNames, spec.before) : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;
                        blockParsers.splice(pos, 0, spec.parse);
                        leafBlockParsers.splice(pos, 0, spec.leaf);
                        blockNames.splice(pos, 0, spec.name);
                    }
                    if (spec.endLeaf)
                        endLeafBlock.push(spec.endLeaf);
                }
            }
            if (nonEmpty(config.parseInline)) {
                for (let _i283 = 0, _config$parseInline = config.parseInline, _length283 = _config$parseInline.length; _i283 < _length283; _i283++) {
                    let spec = _config$parseInline[_i283];
                    let found = inlineNames.indexOf(spec.name);
                    if (found > -1) {
                        inlineParsers[found] = spec.parse;
                    } else {
                        let pos = spec.before ? findName(inlineNames, spec.before) : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;
                        inlineParsers.splice(pos, 0, spec.parse);
                        inlineNames.splice(pos, 0, spec.name);
                    }
                }
            }
            if (config.wrap)
                wrappers = wrappers.concat(config.wrap);
            return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
        }
        getNodeType(name)
        {
            let found = this.nodeTypes[name];
            if (found == null)
                throw new RangeError(`Unknown node type '${name}'`);
            return found;
        }
        parseInline(text, offset)
        {
            let cx = new InlineContext(this, text, offset);
            outer:
            for (let pos = offset; pos < cx.end;) {
                let next = cx.char(pos);
                for (let _i284 = 0, _this$inlineParsers = this.inlineParsers, _length284 = _this$inlineParsers.length; _i284 < _length284; _i284++) {
                    let token = _this$inlineParsers[_i284];
                    if (token) {
                        let result = token(cx, next, pos);
                        if (result >= 0) {
                            pos = result;
                            continue outer;
                        }
                    }
                }
                pos++;
            }
            return cx.resolveMarkers(0);
        }
    }
    function nonEmpty(a) {
        return a != null && a.length > 0;
    }
    function resolveConfig(spec) {
        if (!Array.isArray(spec))
            return spec;
        if (spec.length == 0)
            return null;
        let conf = resolveConfig(spec[0]);
        if (spec.length == 1)
            return conf;
        let rest = resolveConfig(spec.slice(1));
        if (!rest || !conf)
            return conf || rest;
        let conc = (a, b) => (a || none).concat(b || none);
        let wrapA = conf.wrap,
            wrapB = rest.wrap;
        return {
            props: conc(conf.props, rest.props),
            defineNodes: conc(conf.defineNodes, rest.defineNodes),
            parseBlock: conc(conf.parseBlock, rest.parseBlock),
            parseInline: conc(conf.parseInline, rest.parseInline),
            remove: conc(conf.remove, rest.remove),
            wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
        };
    }
    function findName(names, name) {
        let found = names.indexOf(name);
        if (found < 0)
            throw new RangeError(`Position specified relative to unknown parser ${name}`);
        return found;
    }
    let nodeTypes = [NodeType.none];
    for (let i = 1, name; name = Type[i]; i++) {
        nodeTypes[i] = NodeType.define({
            id: i,
            name,
            props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]]
        });
    }
    const none = [];
    class Buffer {
        constructor(nodeSet)
        {
            this.nodeSet = nodeSet;
            this.content = [];
            this.nodes = [];
        }
        write(type, from, to, children=0)
        {
            this.content.push(type, from, to, 4 + children * 4);
            return this;
        }
        writeElements(elts, offset=0)
        {
            for (let _i285 = 0, _length285 = elts.length; _i285 < _length285; _i285++) {
                let e = elts[_i285];
                e.writeTo(this, offset);
            }
            return this;
        }
        finish(type, length)
        {
            return Tree.build({
                buffer: this.content,
                nodeSet: this.nodeSet,
                reused: this.nodes,
                topID: type,
                length
            });
        }
    }
    class Element$1 {
        constructor(type, from, to, children=none)
        {
            this.type = type;
            this.from = from;
            this.to = to;
            this.children = children;
        }
        writeTo(buf, offset)
        {
            let startOff = buf.content.length;
            buf.writeElements(this.children, offset);
            buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);
        }
        toTree(nodeSet)
        {
            return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
        }
    }
    class TreeElement {
        constructor(tree, from)
        {
            this.tree = tree;
            this.from = from;
        }
        get to()
        {
            return this.from + this.tree.length;
        }
        get type()
        {
            return this.tree.type.id;
        }
        get children()
        {
            return none;
        }
        writeTo(buf, offset)
        {
            buf.nodes.push(this.tree);
            buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);
        }
        toTree()
        {
            return this.tree;
        }
    }
    function elt(type, from, to, children) {
        return new Element$1(type, from, to, children);
    }
    const EmphasisUnderscore = {
        resolve: "Emphasis",
        mark: "EmphasisMark"
    };
    const EmphasisAsterisk = {
        resolve: "Emphasis",
        mark: "EmphasisMark"
    };
    const LinkStart = {},
        ImageStart = {};
    class InlineDelimiter {
        constructor(type, from, to, side)
        {
            this.type = type;
            this.from = from;
            this.to = to;
            this.side = side;
        }
    }
    const Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    let Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
    try {
        Punctuation = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
    } catch (_) {}
    const DefaultInline = {
        Escape(cx, next, start) {
            if (next != 92 || start == cx.end - 1)
                return -1;
            let escaped = cx.char(start + 1);
            for (let i = 0; i < Escapable.length; i++)
                if (Escapable.charCodeAt(i) == escaped)
                    return cx.append(elt(Type.Escape, start, start + 2));
            return -1;
        },
        Entity(cx, next, start) {
            if (next != 38)
                return -1;
            let m = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
            return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;
        },
        InlineCode(cx, next, start) {
            if (next != 96 || start && cx.char(start - 1) == 96)
                return -1;
            let pos = start + 1;
            while (pos < cx.end && cx.char(pos) == 96)
                pos++;
            let size = pos - start,
                curSize = 0;
            for (; pos < cx.end; pos++) {
                if (cx.char(pos) == 96) {
                    curSize++;
                    if (curSize == size && cx.char(pos + 1) != 96)
                        return cx.append(elt(Type.InlineCode, start, pos + 1, [elt(Type.CodeMark, start, start + size), elt(Type.CodeMark, pos + 1 - size, pos + 1)]));
                } else {
                    curSize = 0;
                }
            }
            return -1;
        },
        HTMLTag(cx, next, start) {
            if (next != 60 || start == cx.end - 1)
                return -1;
            let after = cx.slice(start + 1, cx.end);
            let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
            if (url)
                return cx.append(elt(Type.URL, start, start + 1 + url[0].length));
            let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
            if (comment)
                return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));
            let procInst = /^\?[^]*?\?>/.exec(after);
            if (procInst)
                return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));
            let m = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
            if (!m)
                return -1;
            return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));
        },
        Emphasis(cx, next, start) {
            if (next != 95 && next != 42)
                return -1;
            let pos = start + 1;
            while (cx.char(pos) == next)
                pos++;
            let before = cx.slice(start - 1, start),
                after = cx.slice(pos, pos + 1);
            let pBefore = Punctuation.test(before),
                pAfter = Punctuation.test(after);
            let sBefore = /\s|^$/.test(before),
                sAfter = /\s|^$/.test(after);
            let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
            let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
            let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
            let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
            return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 : 0) | (canClose ? 2 : 0)));
        },
        HardBreak(cx, next, start) {
            if (next == 92 && cx.char(start + 1) == 10)
                return cx.append(elt(Type.HardBreak, start, start + 2));
            if (next == 32) {
                let pos = start + 1;
                while (cx.char(pos) == 32)
                    pos++;
                if (cx.char(pos) == 10 && pos >= start + 2)
                    return cx.append(elt(Type.HardBreak, start, pos + 1));
            }
            return -1;
        },
        Link(cx, next, start) {
            return next == 91 ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1)) : -1;
        },
        Image(cx, next, start) {
            return next == 33 && cx.char(start + 1) == 91 ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1)) : -1;
        },
        LinkEnd(cx, next, start) {
            if (next != 93)
                return -1;
            for (let i = cx.parts.length - 1; i >= 0; i--) {
                let part = cx.parts[i];
                if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
                    if (!part.side || cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
                        cx.parts[i] = null;
                        return -1;
                    }
                    let content = cx.takeContent(i);
                    let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);
                    if (part.type == LinkStart)
                        for (let j = 0; j < i; j++) {
                            let p = cx.parts[j];
                            if (p instanceof InlineDelimiter && p.type == LinkStart)
                                p.side = 0;
                        }
                    return link.to;
                }
            }
            return -1;
        }
    };
    function finishLink(cx, content, type, start, startPos) {
        let {text} = cx,
            next = cx.char(startPos),
            endPos = startPos;
        content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));
        content.push(elt(Type.LinkMark, startPos - 1, startPos));
        if (next == 40) {
            let pos = cx.skipSpace(startPos + 1);
            let dest = parseURL(text, pos - cx.offset, cx.offset),
                title;
            if (dest) {
                pos = cx.skipSpace(dest.to);
                title = parseLinkTitle(text, pos - cx.offset, cx.offset);
                if (title)
                    pos = cx.skipSpace(title.to);
            }
            if (cx.char(pos) == 41) {
                content.push(elt(Type.LinkMark, startPos, startPos + 1));
                endPos = pos + 1;
                if (dest)
                    content.push(dest);
                if (title)
                    content.push(title);
                content.push(elt(Type.LinkMark, pos, endPos));
            }
        } else if (next == 91) {
            let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);
            if (label) {
                content.push(label);
                endPos = label.to;
            }
        }
        return elt(type, start, endPos, content);
    }
    function parseURL(text, start, offset) {
        let next = text.charCodeAt(start);
        if (next == 60) {
            for (let pos = start + 1; pos < text.length; pos++) {
                let ch = text.charCodeAt(pos);
                if (ch == 62)
                    return elt(Type.URL, start + offset, pos + 1 + offset);
                if (ch == 60 || ch == 10)
                    return false;
            }
            return null;
        } else {
            let depth = 0,
                pos = start;
            for (let escaped = false; pos < text.length; pos++) {
                let ch = text.charCodeAt(pos);
                if (space(ch)) {
                    break;
                } else if (escaped) {
                    escaped = false;
                } else if (ch == 40) {
                    depth++;
                } else if (ch == 41) {
                    if (!depth)
                        break;
                    depth--;
                } else if (ch == 92) {
                    escaped = true;
                }
            }
            return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;
        }
    }
    function parseLinkTitle(text, start, offset) {
        let next = text.charCodeAt(start);
        if (next != 39 && next != 34 && next != 40)
            return false;
        let end = next == 40 ? 41 : next;
        for (let pos = start + 1, escaped = false; pos < text.length; pos++) {
            let ch = text.charCodeAt(pos);
            if (escaped)
                escaped = false;
            else if (ch == end)
                return elt(Type.LinkTitle, start + offset, pos + 1 + offset);
            else if (ch == 92)
                escaped = true;
        }
        return null;
    }
    function parseLinkLabel(text, start, offset, requireNonWS) {
        for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {
            let ch = text.charCodeAt(pos);
            if (escaped)
                escaped = false;
            else if (ch == 93)
                return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);
            else {
                if (requireNonWS && !space(ch))
                    requireNonWS = false;
                if (ch == 91)
                    return false;
                else if (ch == 92)
                    escaped = true;
            }
        }
        return null;
    }
    class InlineContext {
        constructor(parser, text, offset)
        {
            this.parser = parser;
            this.text = text;
            this.offset = offset;
            this.parts = [];
        }
        char(pos)
        {
            return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
        }
        get end()
        {
            return this.offset + this.text.length;
        }
        slice(from, to)
        {
            return this.text.slice(from - this.offset, to - this.offset);
        }
        append(elt)
        {
            this.parts.push(elt);
            return elt.to;
        }
        addDelimiter(type, from, to, open, close)
        {
            return this.append(new InlineDelimiter(type, from, to, (open ? 1 : 0) | (close ? 2 : 0)));
        }
        addElement(elt)
        {
            return this.append(elt);
        }
        resolveMarkers(from)
        {
            for (let i = from; i < this.parts.length; i++) {
                let close = this.parts[i];
                if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2))
                    continue;
                let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
                let closeSize = close.to - close.from;
                let open,
                    j = i - 1;
                for (; j >= from; j--) {
                    let part = this.parts[j];
                    if (!(part instanceof InlineDelimiter && part.side & 1 && part.type == close.type) || emp && (close.side & 1 || part.side & 2) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))
                        continue;
                    open = part;
                    break;
                }
                if (!open)
                    continue;
                let type = close.type.resolve,
                    content = [];
                let start = open.from,
                    end = close.to;
                if (emp) {
                    let size = Math.min(2, open.to - open.from, closeSize);
                    start = open.to - size;
                    end = close.from + size;
                    type = size == 1 ? "Emphasis" : "StrongEmphasis";
                }
                if (open.type.mark)
                    content.push(this.elt(open.type.mark, start, open.to));
                for (let k = j + 1; k < i; k++) {
                    if (this.parts[k] instanceof Element$1)
                        content.push(this.parts[k]);
                    this.parts[k] = null;
                }
                if (close.type.mark)
                    content.push(this.elt(close.type.mark, close.from, end));
                let element = this.elt(type, start, end, content);
                this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;
                let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
                if (keep)
                    this.parts.splice(i, 0, element);
                else
                    this.parts[i] = element;
            }
            let result = [];
            for (let i = from; i < this.parts.length; i++) {
                let part = this.parts[i];
                if (part instanceof Element$1)
                    result.push(part);
            }
            return result;
        }
        findOpeningDelimiter(type)
        {
            for (let i = this.parts.length - 1; i >= 0; i--) {
                let part = this.parts[i];
                if (part instanceof InlineDelimiter && part.type == type)
                    return i;
            }
            return null;
        }
        takeContent(startIndex)
        {
            let content = this.resolveMarkers(startIndex);
            this.parts.length = startIndex;
            return content;
        }
        skipSpace(from)
        {
            return skipSpace(this.text, from - this.offset) + this.offset;
        }
        elt(type, from, to, children)
        {
            if (typeof type == "string")
                return elt(this.parser.getNodeType(type), from, to, children);
            return new TreeElement(type, from);
        }
    }
    function injectMarks(elements, marks) {
        if (!marks.length)
            return elements;
        if (!elements.length)
            return marks;
        let elts = elements.slice(),
            eI = 0;
        for (let _i286 = 0, _length286 = marks.length; _i286 < _length286; _i286++) {
            let mark = marks[_i286];
            while (eI < elts.length && elts[eI].to < mark.to)
                eI++;
            if (eI < elts.length && elts[eI].from < mark.from) {
                let e = elts[eI];
                if (e instanceof Element$1)
                    elts[eI] = new Element$1(e.type, e.from, e.to, injectMarks(e.children, [mark]));
            } else {
                elts.splice(eI++, 0, mark);
            }
        }
        return elts;
    }
    const NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];
    class FragmentCursor {
        constructor(fragments, input)
        {
            this.fragments = fragments;
            this.input = input;
            this.i = 0;
            this.fragment = null;
            this.fragmentEnd = -1;
            this.cursor = null;
            if (fragments.length)
                this.fragment = fragments[this.i++];
        }
        nextFragment()
        {
            this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
            this.cursor = null;
            this.fragmentEnd = -1;
        }
        moveTo(pos, lineStart)
        {
            while (this.fragment && this.fragment.to <= pos)
                this.nextFragment();
            if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
                return false;
            if (this.fragmentEnd < 0) {
                let end = this.fragment.to;
                while (end > 0 && this.input.read(end - 1, end) != "\n")
                    end--;
                this.fragmentEnd = end ? end - 1 : 0;
            }
            let c = this.cursor;
            if (!c) {
                c = this.cursor = this.fragment.tree.cursor();
                c.firstChild();
            }
            let rPos = pos + this.fragment.offset;
            while (c.to <= rPos)
                if (!c.parent())
                    return false;
            for (;;) {
                if (c.from >= rPos)
                    return this.fragment.from <= lineStart;
                if (!c.childAfter(rPos))
                    return false;
            }
        }
        matches(hash)
        {
            let tree = this.cursor.tree;
            return tree && tree.prop(NodeProp.contextHash) == hash;
        }
        takeNodes(cx)
        {
            let cur = this.cursor,
                off = this.fragment.offset,
                fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
            let start = cx.absoluteLineStart,
                end = start,
                blockI = cx.block.children.length;
            let prevEnd = end,
                prevI = blockI;
            for (;;) {
                if (cur.to - off > fragEnd) {
                    if (cur.type.isAnonymous && cur.firstChild())
                        continue;
                    break;
                }
                cx.dontInject.add(cur.tree);
                cx.addNode(cur.tree, cur.from - off);
                if (cur.type.is("Block")) {
                    if (NotLast.indexOf(cur.type.id) < 0) {
                        end = cur.to - off;
                        blockI = cx.block.children.length;
                    } else {
                        end = prevEnd;
                        blockI = prevI;
                        prevEnd = cur.to - off;
                        prevI = cx.block.children.length;
                    }
                }
                if (!cur.nextSibling())
                    break;
            }
            while (cx.block.children.length > blockI) {
                cx.block.children.pop();
                cx.block.positions.pop();
            }
            return end - start;
        }
    }
    const markdownHighlighting = styleTags({
        "Blockquote/...": tags$1.quote,
        HorizontalRule: tags$1.contentSeparator,
        "ATXHeading1/... SetextHeading1/...": tags$1.heading1,
        "ATXHeading2/... SetextHeading2/...": tags$1.heading2,
        "ATXHeading3/...": tags$1.heading3,
        "ATXHeading4/...": tags$1.heading4,
        "ATXHeading5/...": tags$1.heading5,
        "ATXHeading6/...": tags$1.heading6,
        "Comment CommentBlock": tags$1.comment,
        Escape: tags$1.escape,
        Entity: tags$1.character,
        "Emphasis/...": tags$1.emphasis,
        "StrongEmphasis/...": tags$1.strong,
        "Link/... Image/...": tags$1.link,
        "OrderedList/... BulletList/...": tags$1.list,
        "BlockQuote/...": tags$1.quote,
        "InlineCode CodeText": tags$1.monospace,
        URL: tags$1.url,
        "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": tags$1.processingInstruction,
        "CodeInfo LinkLabel": tags$1.labelName,
        LinkTitle: tags$1.string,
        Paragraph: tags$1.content
    });
    const parser$2 = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);
    function leftOverSpace(node, from, to) {
        let ranges = [];
        for (let n = node.firstChild, pos = from; ; n = n.nextSibling) {
            let nextPos = n ? n.from : to;
            if (nextPos > pos)
                ranges.push({
                    from: pos,
                    to: nextPos
                });
            if (!n)
                break;
            pos = n.to;
        }
        return ranges;
    }
    function parseCode(config) {
        let {codeParser, htmlParser} = config;
        let wrap = parseMixed((node, input) => {
            let id = node.type.id;
            if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {
                let info = "";
                if (id == Type.FencedCode) {
                    let infoNode = node.node.getChild(Type.CodeInfo);
                    if (infoNode)
                        info = input.read(infoNode.from, infoNode.to);
                }
                let parser = codeParser(info);
                if (parser)
                    return {
                        parser,
                        overlay: node => node.type.id == Type.CodeText
                    };
            } else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {
                return {
                    parser: htmlParser,
                    overlay: leftOverSpace(node.node, node.from, node.to)
                };
            }
            return null;
        });
        return {
            wrap
        };
    }
    const StrikethroughDelim = {
        resolve: "Strikethrough",
        mark: "StrikethroughMark"
    };
    const Strikethrough = {
        defineNodes: [{
            name: "Strikethrough",
            style: {
                "Strikethrough/...": tags$1.strikethrough
            }
        }, {
            name: "StrikethroughMark",
            style: tags$1.processingInstruction
        }],
        parseInline: [{
            name: "Strikethrough",
            parse(cx, next, pos) {
                if (next != 126 || cx.char(pos + 1) != 126)
                    return -1;
                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);
            },
            after: "Emphasis"
        }]
    };
    function parseRow(cx, line, startI=0, elts, offset=0) {
        let count = 0,
            first = true,
            cellStart = -1,
            cellEnd = -1,
            esc = false;
        let parseCell = () => {
            elts.push(cx.elt("TableCell", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));
        };
        for (let i = startI; i < line.length; i++) {
            let next = line.charCodeAt(i);
            if (next == 124 && !esc) {
                if (!first || cellStart > -1)
                    count++;
                first = false;
                if (elts) {
                    if (cellStart > -1)
                        parseCell();
                    elts.push(cx.elt("TableDelimiter", i + offset, i + offset + 1));
                }
                cellStart = cellEnd = -1;
            } else if (esc || next != 32 && next != 9) {
                if (cellStart < 0)
                    cellStart = i;
                cellEnd = i + 1;
            }
            esc = !esc && next == 92;
        }
        if (cellStart > -1) {
            count++;
            if (elts)
                parseCell();
        }
        return count;
    }
    function hasPipe(str, start) {
        for (let i = start; i < str.length; i++) {
            let next = str.charCodeAt(i);
            if (next == 124)
                return true;
            if (next == 92)
                i++;
        }
        return false;
    }
    const delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
    class TableParser {
        constructor()
        {
            this.rows = null;
        }
        nextLine(cx, line, leaf)
        {
            if (this.rows == null) {
                this.rows = false;
                let lineText;
                if ((line.next == 45 || line.next == 58 || line.next == 124) && delimiterLine.test(lineText = line.text.slice(line.pos))) {
                    let firstRow = [],
                        firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
                    if (firstCount == parseRow(cx, lineText, line.pos))
                        this.rows = [cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow), cx.elt("TableDelimiter", cx.lineStart + line.pos, cx.lineStart + line.text.length)];
                }
            } else if (this.rows) {
                let content = [];
                parseRow(cx, line.text, line.pos, content, cx.lineStart);
                this.rows.push(cx.elt("TableRow", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));
            }
            return false;
        }
        finish(cx, leaf)
        {
            if (!this.rows)
                return false;
            cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
            return true;
        }
    }
    const Table = {
        defineNodes: [{
            name: "Table",
            block: true
        }, {
            name: "TableHeader",
            style: {
                "TableHeader/...": tags$1.heading
            }
        }, "TableRow", {
            name: "TableCell",
            style: tags$1.content
        }, {
            name: "TableDelimiter",
            style: tags$1.processingInstruction
        }],
        parseBlock: [{
            name: "Table",
            leaf(_, leaf) {
                return hasPipe(leaf.content, 0) ? new TableParser() : null;
            },
            endLeaf(cx, line, leaf) {
                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))
                    return false;
                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;
                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);
            },
            before: "SetextHeading"
        }]
    };
    class TaskParser {
        nextLine()
        {
            return false;
        }
        finish(cx, leaf)
        {
            cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [cx.elt("TaskMarker", leaf.start, leaf.start + 3), ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)]));
            return true;
        }
    }
    const TaskList = {
        defineNodes: [{
            name: "Task",
            block: true,
            style: tags$1.list
        }, {
            name: "TaskMarker",
            style: tags$1.atom
        }],
        parseBlock: [{
            name: "TaskList",
            leaf(cx, leaf) {
                return /^\[[ xX]\]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser() : null;
            },
            after: "SetextHeading"
        }]
    };
    const GFM = [Table, TaskList, Strikethrough];
    function parseSubSuper(ch, node, mark) {
        return (cx, next, pos) => {
            if (next != ch || cx.char(pos + 1) == ch)
                return -1;
            let elts = [cx.elt(mark, pos, pos + 1)];
            for (let i = pos + 1; i < cx.end; i++) {
                let next = cx.char(i);
                if (next == ch)
                    return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));
                if (next == 92)
                    elts.push(cx.elt("Escape", i, i++ + 2));
                if (space(next))
                    break;
            }
            return -1;
        };
    }
    const Superscript = {
        defineNodes: [{
            name: "Superscript",
            style: tags$1.special(tags$1.content)
        }, {
            name: "SuperscriptMark",
            style: tags$1.processingInstruction
        }],
        parseInline: [{
            name: "Superscript",
            parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
        }]
    };
    const Subscript = {
        defineNodes: [{
            name: "Subscript",
            style: tags$1.special(tags$1.content)
        }, {
            name: "SubscriptMark",
            style: tags$1.processingInstruction
        }],
        parseInline: [{
            name: "Subscript",
            parse: parseSubSuper(126, "Subscript", "SubscriptMark")
        }]
    };
    const Emoji = {
        defineNodes: [{
            name: "Emoji",
            style: tags$1.character
        }],
        parseInline: [{
            name: "Emoji",
            parse(cx, next, pos) {
                let match;
                if (next != 58 || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
                    return -1;
                return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match[0].length));
            }
        }]
    };
    const data = defineLanguageFacet({
        block: {
            open: "<!--",
            close: "-->"
        }
    });
    const commonmark = parser$2.configure({
        props: [foldNodeProp.add(type => {
            if (!type.is("Block") || type.is("Document"))
                return undefined;
            return (tree, state) => ({
                from: state.doc.lineAt(tree.from).to,
                to: tree.to
            });
        }), indentNodeProp.add({
            Document: () => null
        }), languageDataProp.add({
            Document: data
        })]
    });
    function mkLang(parser) {
        return new Language(data, parser, [], "markdown");
    }
    const commonmarkLanguage = mkLang(commonmark);
    const extended = commonmark.configure([GFM, Subscript, Superscript, Emoji]);
    const markdownLanguage = mkLang(extended);
    function getCodeParser(languages, defaultLanguage) {
        return info => {
            if (info && languages) {
                let found = null;
                info = /\S*/.exec(info)[0];
                if (typeof languages == "function")
                    found = languages(info);
                else
                    found = LanguageDescription.matchLanguageName(languages, info, true);
                if (found instanceof LanguageDescription)
                    return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());
                else if (found)
                    return found.parser;
            }
            return defaultLanguage ? defaultLanguage.parser : null;
        };
    }
    class Context {
        constructor(node, from, to, spaceBefore, spaceAfter, type, item)
        {
            this.node = node;
            this.from = from;
            this.to = to;
            this.spaceBefore = spaceBefore;
            this.spaceAfter = spaceAfter;
            this.type = type;
            this.item = item;
        }
        blank(maxWidth, trailing=true)
        {
            let result = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
            if (maxWidth != null) {
                while (result.length < maxWidth)
                    result += " ";
                return result;
            } else {
                for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)
                    result += " ";
                return result + (trailing ? this.spaceAfter : "");
            }
        }
        marker(doc, add)
        {
            let number = this.node.name == "OrderedList" ? String(+itemNumber(this.item, doc)[2] + add) : "";
            return this.spaceBefore + number + this.type + this.spaceAfter;
        }
    }
    function getContext(node, doc) {
        let nodes = [];
        for (let cur = node; cur && cur.name != "Document"; cur = cur.parent) {
            if (cur.name == "ListItem" || cur.name == "Blockquote" || cur.name == "FencedCode")
                nodes.push(cur);
        }
        let context = [];
        for (let i = nodes.length - 1; i >= 0; i--) {
            let node = nodes[i],
                match;
            let line = doc.lineAt(node.from),
                startPos = node.from - line.from;
            if (node.name == "FencedCode") {
                context.push(new Context(node, startPos, startPos, "", "", "", null));
            } else if (node.name == "Blockquote" && (match = /^[ \t]*>( ?)/.exec(line.text.slice(startPos)))) {
                context.push(new Context(node, startPos, startPos + match[0].length, "", match[1], ">", null));
            } else if (node.name == "ListItem" && node.parent.name == "OrderedList" && (match = /^([ \t]*)\d+([.)])([ \t]*)/.exec(line.text.slice(startPos)))) {
                let after = match[3],
                    len = match[0].length;
                if (after.length >= 4) {
                    after = after.slice(0, after.length - 4);
                    len -= 4;
                }
                context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));
            } else if (node.name == "ListItem" && node.parent.name == "BulletList" && (match = /^([ \t]*)([-+*])([ \t]{1,4}\[[ xX]\])?([ \t]+)/.exec(line.text.slice(startPos)))) {
                let after = match[4],
                    len = match[0].length;
                if (after.length > 4) {
                    after = after.slice(0, after.length - 4);
                    len -= 4;
                }
                let type = match[2];
                if (match[3])
                    type += match[3].replace(/[xX]/, ' ');
                context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));
            }
        }
        return context;
    }
    function itemNumber(item, doc) {
        return /^(\s*)(\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));
    }
    function renumberList(after, doc, changes, offset=0) {
        for (let prev = -1, node = after; ;) {
            if (node.name == "ListItem") {
                let m = itemNumber(node, doc);
                let number = +m[2];
                if (prev >= 0) {
                    if (number != prev + 1)
                        return;
                    changes.push({
                        from: node.from + m[1].length,
                        to: node.from + m[0].length,
                        insert: String(prev + 2 + offset)
                    });
                }
                prev = number;
            }
            let next = node.nextSibling;
            if (!next)
                break;
            node = next;
        }
    }
    const insertNewlineContinueMarkup = ({state, dispatch}) => {
        let tree = syntaxTree(state),
            {doc} = state;
        let dont = null,
            changes = state.changeByRange(range => {
                if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))
                    return dont = {
                        range
                    };
                let pos = range.from,
                    line = doc.lineAt(pos);
                let context = getContext(tree.resolveInner(pos, -1), doc);
                while (context.length && context[context.length - 1].from > pos - line.from)
                    context.pop();
                if (!context.length)
                    return dont = {
                        range
                    };
                let inner = context[context.length - 1];
                if (inner.to - inner.spaceAfter.length > pos - line.from)
                    return dont = {
                        range
                    };
                let emptyLine = pos >= inner.to - inner.spaceAfter.length && !/\S/.test(line.text.slice(inner.to));
                if (inner.item && emptyLine) {
                    if (inner.node.firstChild.to >= pos || line.from > 0 && !/[^\s>]/.test(doc.lineAt(line.from - 1).text)) {
                        let next = context.length > 1 ? context[context.length - 2] : null;
                        let delTo,
                            insert = "";
                        if (next && next.item) {
                            delTo = line.from + next.from;
                            insert = next.marker(doc, 1);
                        } else {
                            delTo = line.from + (next ? next.to : 0);
                        }
                        let changes = [{
                            from: delTo,
                            to: pos,
                            insert
                        }];
                        if (inner.node.name == "OrderedList")
                            renumberList(inner.item, doc, changes, -2);
                        if (next && next.node.name == "OrderedList")
                            renumberList(next.item, doc, changes);
                        return {
                            range: EditorSelection.cursor(delTo + insert.length),
                            changes
                        };
                    } else {
                        let insert = "";
                        for (let i = 0, e = context.length - 2; i <= e; i++) {
                            insert += context[i].blank(i < e ? context[i + 1].from - insert.length : null, i < e);
                        }
                        insert += state.lineBreak;
                        return {
                            range: EditorSelection.cursor(pos + insert.length),
                            changes: {
                                from: line.from,
                                insert
                            }
                        };
                    }
                }
                if (inner.node.name == "Blockquote" && emptyLine && line.from) {
                    let prevLine = doc.lineAt(line.from - 1),
                        quoted = />\s*$/.exec(prevLine.text);
                    if (quoted && quoted.index == inner.from) {
                        let changes = state.changes([{
                            from: prevLine.from + quoted.index,
                            to: prevLine.to
                        }, {
                            from: line.from + inner.from,
                            to: line.to
                        }]);
                        return {
                            range: range.map(changes),
                            changes
                        };
                    }
                }
                let changes = [];
                if (inner.node.name == "OrderedList")
                    renumberList(inner.item, doc, changes);
                let continued = inner.item && inner.item.from < line.from;
                let insert = "";
                if (!continued || /^[\s\d.)\-+*>]*/.exec(line.text)[0].length >= inner.to) {
                    for (let i = 0, e = context.length - 1; i <= e; i++) {
                        insert += i == e && !continued ? context[i].marker(doc, 1) : context[i].blank(i < e ? context[i + 1].from - insert.length : null);
                    }
                }
                let from = pos;
                while (from > line.from && /\s/.test(line.text.charAt(from - line.from - 1)))
                    from--;
                insert = state.lineBreak + insert;
                changes.push({
                    from,
                    to: pos,
                    insert
                });
                return {
                    range: EditorSelection.cursor(from + insert.length),
                    changes
                };
            });
        if (dont)
            return false;
        dispatch(state.update(changes, {
            scrollIntoView: true,
            userEvent: "input"
        }));
        return true;
    };
    function isMark(node) {
        return node.name == "QuoteMark" || node.name == "ListMark";
    }
    function contextNodeForDelete(tree, pos) {
        let node = tree.resolveInner(pos, -1),
            scan = pos;
        if (isMark(node)) {
            scan = node.from;
            node = node.parent;
        }
        for (let prev; prev = node.childBefore(scan);) {
            if (isMark(prev)) {
                scan = prev.from;
            } else if (prev.name == "OrderedList" || prev.name == "BulletList") {
                node = prev.lastChild;
                scan = node.to;
            } else {
                break;
            }
        }
        return node;
    }
    const deleteMarkupBackward = ({state, dispatch}) => {
        let tree = syntaxTree(state);
        let dont = null,
            changes = state.changeByRange(range => {
                let pos = range.from,
                    {doc} = state;
                if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {
                    let line = doc.lineAt(pos);
                    let context = getContext(contextNodeForDelete(tree, pos), doc);
                    if (context.length) {
                        let inner = context[context.length - 1];
                        let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);
                        if (pos - line.from > spaceEnd && !/\S/.test(line.text.slice(spaceEnd, pos - line.from)))
                            return {
                                range: EditorSelection.cursor(line.from + spaceEnd),
                                changes: {
                                    from: line.from + spaceEnd,
                                    to: pos
                                }
                            };
                        if (pos - line.from == spaceEnd) {
                            let start = line.from + inner.from;
                            if (inner.item && inner.node.from < inner.item.from && /\S/.test(line.text.slice(inner.from, inner.to)))
                                return {
                                    range,
                                    changes: {
                                        from: start,
                                        to: line.from + inner.to,
                                        insert: inner.blank(inner.to - inner.from)
                                    }
                                };
                            if (start < pos)
                                return {
                                    range: EditorSelection.cursor(start),
                                    changes: {
                                        from: start,
                                        to: pos
                                    }
                                };
                        }
                    }
                }
                return dont = {
                    range
                };
            });
        if (dont)
            return false;
        dispatch(state.update(changes, {
            scrollIntoView: true,
            userEvent: "delete"
        }));
        return true;
    };
    const markdownKeymap = [{
        key: "Enter",
        run: insertNewlineContinueMarkup
    }, {
        key: "Backspace",
        run: deleteMarkupBackward
    }];
    const htmlNoMatch = html({
        matchClosingTags: false
    });
    function markdown(config={}) {
        let {codeLanguages, defaultCodeLanguage, addKeymap=true, base: {parser}=commonmarkLanguage} = config;
        if (!(parser instanceof MarkdownParser))
            throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
        let extensions = config.extensions ? [config.extensions] : [];
        let support = [htmlNoMatch.support],
            defaultCode;
        if (defaultCodeLanguage instanceof LanguageSupport) {
            support.push(defaultCodeLanguage.support);
            defaultCode = defaultCodeLanguage.language;
        } else if (defaultCodeLanguage) {
            defaultCode = defaultCodeLanguage;
        }
        let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;
        extensions.push(parseCode({
            codeParser,
            htmlParser: htmlNoMatch.language.parser
        }));
        if (addKeymap)
            support.push(Prec.high(keymap.of(markdownKeymap)));
        return new LanguageSupport(mkLang(parser.configure(extensions)), support);
    }
    var _m20 = Object.freeze({
        __proto__: null,
        commonmarkLanguage: commonmarkLanguage,
        deleteMarkupBackward: deleteMarkupBackward,
        insertNewlineContinueMarkup: insertNewlineContinueMarkup,
        markdown: markdown,
        markdownKeymap: markdownKeymap,
        markdownLanguage: markdownLanguage
    });
    const lezerHighlighting = styleTags({
        LineComment: tags$1.lineComment,
        BlockComment: tags$1.blockComment,
        AnyChar: tags$1.character,
        Literal: tags$1.string,
        "tokens from grammar as empty prop extend specialize": tags$1.keyword,
        "@top @left @right @cut @external": tags$1.modifier,
        "@precedence @tokens @context @dialects @skip @detectDelim @conflict": tags$1.definitionKeyword,
        "@extend @specialize": tags$1.operatorKeyword,
        "CharSet InvertedCharSet": tags$1.regexp,
        "CharClass": tags$1.atom,
        RuleName: tags$1.variableName,
        "RuleDeclaration/RuleName InlineRule/RuleName TokensBody/RuleName": tags$1.definition(tags$1.variableName),
        PrecedenceName: tags$1.labelName,
        Name: tags$1.name,
        "( )": tags$1.paren,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace,
        '"!" ~ "*" + ? |': tags$1.operator
    });
    const spec_AtName = {
        __proto__: null,
        "@asciiLetter": 232,
        "@asciiUpperCase": 232,
        "@asciiLowerCase": 232,
        "@digit": 232,
        "@whitespace": 232,
        "@eof": 232,
        "@specialize": 76,
        "@extend": 78,
        "@top": 98,
        "@precedence": 102,
        "@left": 108,
        "@right": 110,
        "@cut": 112,
        "@tokens": 116,
        "@conflict": 126,
        "@external": 134,
        "@context": 162,
        "@dialects": 166,
        "@skip": 172,
        "@detectDelim": 180
    };
    const spec_keyword = {
        __proto__: null,
        tokens: 136,
        from: 138,
        prop: 146,
        as: 148,
        propSource: 152,
        extend: 156,
        specialize: 158
    };
    const parser$1 = LRParser.deserialize({
        version: 14,
        states: ";`Q]QPOOOOQO'#Ca'#CaOzQPO'#C`OOQO'#Ek'#EkOOQO'#EZ'#EZQ]QPOOOuQPO'#D^O!VQPO'#D`O![QPO'#DgO!aQQO'#DvO!rQPO'#EOO!wQPO'#EQO!|QPO'#ETOOQO'#EX'#EXO#RQPO'#CdO#^QPO'#CnO$aQPO'#CoOOQO,58z,58zO!|QPO,58zO}QPO,58zOOQO-E8X-E8XOzQPO,59xO$hQPO'#DbOOQO,59z,59zO$pQPO'#DiOOQO,5:R,5:RO!rQPO,5:[O!rQPO,5:bO!rQPO,5:eO!|QPO,5:gOOQO'#Cg'#CgO%RQQO,5:jO%WQPO'#ESOOQO,5:l,5:lO%`QPO,5:oO&TQPO'#CeO&`QPO,59OO#UQPO,59OOOQO,59O,59OOOQO,59Y,59YO&hQPO,59YO(QQPO'#EsO(_QPO'#EsOOQO'#Es'#EsOOQO'#Cv'#CvO)^QPO'#EqO!|QPO'#C}O)zQPO'#DQOOQO'#Er'#ErO$kQPO'#DVO!rQPO'#DYOOQO'#Eu'#EuO*RQPO'#DUOOQO'#Eq'#EqO*fQPO'#EaO*yQPO'#D[O+[QPO'#EpOOQO'#Ep'#EpOOQO,59Z,59ZO+mQPO,59ZO+rQPO'#DROOQO1G.f1G.fO!|QPO1G.fOOQO1G/d1G/dO!|QPO1G/dO}QPO1G/dOOQO'#DX'#DXO+zQPO'#DcO,`QPO'#EbO,kQPO,59|OOQO,59|,59|O,sQPO'#DoOOQO'#Ev'#EvOOQO'#Ec'#EcO-XQPO,5:TOOQO,5:T,5:TO-jQPO'#DjO-oQPO'#DlO-tQQO1G/vO-yQQO1G/|O.RQQO1G0PO!rQPO1G0RO.WQPO1G0UO.]QPO'#EfO.hQPO,5:nOOQO,5:n,5:nO.pQPO'#EWOOQO1G0]1G0]O.{QPO,59POOQO,5:v,5:vOOQO1G.j1G.jO/aQPO1G.jOOQO-E8Y-E8YO!rQPO'#E^O/iQPO1G.tOOQO1G.t1G.tOuQPO,59_O/qQPO'#CuOOQO,59`,59`OOQO,59i,59iO!|QPO,59iO/xQPO'#E`OOQO,59d,59dOOQO,59f,59fOOQO,59h,59hOOQO'#E`'#E`O1YQPO,59pOOQO,59l,59lO1mQPO,59lOOQO,59q,59qOOQO,59t,59tOOQO,5:{,5:{OOQO-E8_-E8_O1rQPO,59vOOQO1G.u1G.uOOQO,59m,59mO+uQPO,59mOOQO7+$Q7+$QOOQO7+%O7+%OO!|QPO7+%OOOQO,59},59}OOQO,5:|,5:|OOQO-E8`-E8`OOQO1G/h1G/hOOQO,5:Z,5:ZOOQO-E8a-E8aOOQO1G/o1G/oO2TQPO'#DkOOQO,5:U,5:UO2`QPO'#DnOOQO,5:W,5:WO2hQPO7+%bO2mQPO7+%hO!rQPO7+%hO2rQPO7+%kO2wQQO7+%mOOQO7+%p7+%pOOQO,5;Q,5;QOOQO-E8d-E8dOOQO1G0Y1G0YOOQO'#Eg'#EgO2|QPO,5:rOOQO,5:r,5:rOuQPO'#CmOOQO'#E]'#E]O3XQPO1G.kOOQO7+$U7+$UP&cQPO'#E[OOQO,5:x,5:xOOQO-E8[-E8[OOQO7+$`7+$`OOQO1G.y1G.yOOQO,59a,59aO3mQPO,59aOOQO1G/T1G/TOOQO-E8^-E8^OOQO1G/W1G/WOOQO1G/X1G/XOOQO<<Hj<<HjO3uQPO'#EsO4ZQPO'#EdO4iQPO,5:VOOQO,5:V,5:VO4tQPO,5:YO5PQPO<<H|OOQO<<IS<<ISO5UQQO<<ISOOQO<<IV<<IVO5ZQPO<<IXOOQO-E8e-E8eOOQO1G0^1G0^O5`QPO,59XOOQO-E8Z-E8ZO#fQPO'#E_O5eQPO1G.{OOQO1G.{1G.{OOQO,5;O,5;OOOQO-E8b-E8bOOQO1G/q1G/qO5mQPO1G/tO5rQPO1G/tO5zQPO'#DtOOQOAN>hAN>hO6SQPOAN>nO5PQPOAN>sOOQO1G.s1G.sOOQO,5:y,5:yOOQO-E8]-E8]OOQO7+$g7+$gOOQO7+%`7+%`O6XQPO7+%`O6^QPO'#DuO6lQPO'#EeO6wQPO,5:`OOQO,5:`,5:`OOQOG24YG24YOOQOG24_G24_OOQO<<Hz<<HzOOQO,5:a,5:aOOQO,5;P,5;POOQO-E8c-E8cOOQO1G/z1G/z",
        stateData: "7T~O#^OSPOSQOS~O!RUO!TVO![WO!eXO!sYO!uZO!x[O!|]O#`PO~OV^O``O#c_O~O`fO~O`hO~O!fjO!kkO!nlO!pmO!qmO~O#`nO~O`pO~O``O~OUvOYsO#`nO~O#`nO#bwO~OV^O]!QOd!QOe!QOf!QOs!POv!^Ow!^Oz!RO}!SO!P!WO#`PO#h|O~O_![O~P#fO_!hO#`!dO~O]!iO_!mO!T!nO!a!oO#`PO~O!g!tO~O_!wO#`nO~O`!xO!R!wa!T!wa![!wa!e!wa!s!wa!u!wa!x!wa!|!wa#[!wa#`!wa~O[!zOUXX#aXX~OU!|O#a!{O~O#a#PO#b#RO~O#c#TO]#gX_#gXd#gXe#gXf#gXk#gXm#gXo#gXs#gXv#gXw#gXz#gX}#gX!P#gX#`#gX#h#gXr#gX#a#gX#b#gX~OV^O^#SO``O~P&pOV#gX~P&pOV^O]!QOd!QOe!QOf!QOs!POv!^Ow!^Oz!RO}!SO#`PO#h|O~Ok#YOm#ZOo#[O_#eX!P#eXr#eX#a#eX#b#eX~P(fOr#_O~P#fO_xX!PxXrxX#axX#bxX~P(fO_#TX!P#TXr#TX#a#TX#b#TX~P(fO!P!WO_!OXr!OX#a!OX#b!OX~O!P!WO_#dXr#dX#a#dX#b#dX~O_#fO~OV^O#c#TO~O!W#lO!X#lO!Y#lO_!VX#`!VX#a!VX~O#a#mO_#UX#`#UX~O_#oO#`!dO~OV^O]!cX_!cX!T!cX!a!cX#`!cX~O]!iO_#rO!T!nO!a!oO#`PO~O`#sO~O`#uO~O!g#wO~O!g#xO!l#yO~O!g#zO~O]#|O~O#a#}O_#YX#`#YX~O_$PO#`nO~O_$SO!RUO#`PO~O]$UO^$UO`$TO#`nOUXa#aXa~OU$WO#a!{O~O#a#PO#b$[O~O#b$^O~P#fOk#YOm#ZOo#[OV#SX]#SX_#SXd#SXe#SXf#SXs#SXv#SXw#SXz#SX}#SX!P#SX#`#SX#h#SXr#SX#a#SX#b#SX~O_xa!Pxarxa#axa#bxa~P(fOr$bO~O!P!WO_!Oar!Oa#a!Oa#b!Oa~O]$fO_$hO#`PO~O]$iO#`PO~O]$jO~O]$kO~O]$mO~O!g$nO~O_$pO!RUO#`PO~O]$UO^$UO`$TO#`nOUXi#aXi~O#a$sO#b$uO~O^#SO#c#TO]#gX_#gX#`#gX#a#gX~O#a$vO]#WX_#WX#`#WX~O]$fO_$xO#`PO~O]$yO#`PO#a$zO~O`${O~O!g$}O~O]%OO~O_%PO~O#a$sO#b%SO~O_%TO~O]%UO#`PO~O_%YO#`PO~O]%ZO~O_%]O~OV^O_!iX#`!iX#a!iX~O#a%_O_#XX#`#XX~O_%aO#`PO~Oe#`#k~",
        goto: "-o#kPPPP#l#xPP$p%^P%dPPPPP&]&a&mPPP'`'o(O(ZP(ZP(ZP(Z(ZPP(Z(ZPP(e(lP(v(lP(}P)TP)]P)a)dPPP)]P)h)k)o)kP)r)k)]PPP)u){)]PP)]P)]PP)]P)]P*P)]P)]*S)]P*V*]*c*i*o*u*|+Z+a+g+m+s+yPPP,PPPPP,T,a,j,vP-_-kSROTS!jh!lT$Q!x$R[QOTh!l!x$RQeU`y`}!P!U!W#T#^$sQ$]#SY$e#s#u$g$i$zQ$q$TT%V${%XQcQ`!O`}!P!U!W#T#^$sQ!ceQ#WyQ#h!^Q#p!iR%^%VQt^R!}uQoYSs^uQx_Q!pjQ!qkQ!rlS!up!vQ#b!SQ#{!sS$U!z$VQ$Y#PR$l#yT$U!z$VQbQQ!`cQ!beR#k!cQaQQr[S!_bcQ!aeQ!smS#Vy!OQ#i!`S#j!b!cQ$`#WR$d#kkz`}!P!U!W#T#^#s#u$g$i$s$zk{`}!P!U!W#T#^#s#u$g$i$s$zU#Uyz$eQ#g!^R$c#ha!Q`}!P!U!W#T#^$sZ!V`!P!W#T$sa!T`}!P!U!W#T#^$sS!ef!gR#a!RX!Z`!P#T$sSROTT$Q!x$RTROTRgVT!ff!gRiWT!jh!lR#t!nR#v!oQ$|$jR%[%OT%W${%XRqZR!yrQTORdTQu^R#OuQ$V!zR$r$VQ#QxR$Z#QQ$t$_R%R$tS#^}!UR$a#^W!X`!P#T$sS#d!X#eR#e!YQ!gfR#n!gQ!lhR#q!lQ$g#sR$w$gQ%X${R%`%XQ!vpR$O!vQ$R!xR$o$RTSOTQ!]`Q#`!PQ$_#TR%Q$sW!Y`!P#T$sR#c!WY}`!P!W#T$sV#X}!U#^`!Q`}!P!U!W#T#^$sS$f#s$gQ$i#uQ$y$iR%U$zY!U`!P!W#T$sV#]}!U#^T!kh!l",
        nodeNames: "⚠ LineComment BlockComment Grammar RuleDeclaration RuleName ] [ Props Prop AtName Name = Literal . } { PropEsc ParamList Body CharSet AnyChar InvertedCharSet ScopedName Call ArgList CharClass ? Optional * Repeat + Repeat1 InlineRule ) ( ParenExpression Specialization @specialize @extend Sequence PrecedenceMarker ! PrecedenceName AmbiguityMarker ~ Choice | RuleDeclaration @top PrecedenceDeclaration @precedence PrecedenceBody Precedence @left @right @cut TokensDeclaration @tokens TokensBody TokenPrecedenceDeclaration PrecedenceBody TokenConflictDeclaration @conflict ConflictBody LiteralTokenDeclaration ExternalTokensDeclaration @external tokens from TokensBody Token ExternalPropDeclaration prop as ExternalPropSourceDeclaration propSource ExternalSpecializeDeclaration extend specialize ContextDeclaration @context DialectsDeclaration @dialects DialectBody TopSkipDeclaration @skip SkipScope SkipBody DetectDelimDeclaration @detectDelim",
        maxTerm: 119,
        nodeProps: [["group", 4, "Declaration Declaration", -16, 5, 13, 20, 21, 22, 23, 24, 26, 28, 30, 32, 33, 36, 37, 40, 46, "Expression", -15, 48, 50, 57, 60, 62, 65, 66, 72, 75, 77, 80, 82, 85, 87, 89, "Declaration"], ["openedBy", 6, "[", 15, "{", 34, "("], ["closedBy", 7, "]", 16, "}", 35, ")"]],
        propSources: [lezerHighlighting],
        skippedNodes: [0, 1, 2],
        repeatNodeCount: 13,
        tokenData: ".V~R|X^#{pq#{qr$prs%dtu&Wwx&xxy'gyz'lz{'q{|'v|}'{}!O(Q!O!P(k!P!Q(p!Q![(Q!^!_)y!_!`*O!`!a*T!a!b*Y!b!c*_!c!}(Q!}#O+]#P#Q+b#R#S+g#T#o(Q#o#p,S#p#q,X#q#r,^#r#s,c#y#z#{$f$g#{$g#BY(Q#BY#BZ,h#BZ$IS(Q$IS$I_,h$I_$I|(Q$I|$JO,h$JO$JT(Q$JT$JU,h$JU$KV(Q$KV$KW,h$KW&FU(Q&FU&FV,h&FV~(Q~$QY#^~X^#{pq#{#y#z#{$f$g#{#BY#BZ#{$IS$I_#{$I|$JO#{$JT$JU#{$KV$KW#{&FU&FV#{~$uPz~!}#O$x~${SO#O$x#O#P%X#P#Q%_#Q~$x~%[PO~$x~%dOf~~%iU]~OY%dZr%drs%{s#O%d#O#P&Q#P~%d~&QO]~~&TPO~%d~&ZP!}#O&^~&aSO#O&^#O#P&m#P#Q&s#Q~&^~&pPO~&^~&xOd~~&}U]~OY&xZw&xwx%{x#O&x#O#P'a#P~&x~'dPO~&x~'lOs~~'qOr~~'vOm~~'{Oo~~(QO#a~R(XU#`P#kQ}!O(Q!Q![(Q!c!}(Q#R#S(Q#T#o(Q$g~(Q~(pO^~~(sQz{(y!P!Q)n~(|ROz(yz{)V{~(y~)YTOz(yz{)V{!P(y!P!Q)i!Q~(y~)nOQ~~)sQP~OY)nZ~)n~*OO#c~~*TO[~~*YO#b~~*_Ok~~*bU}!O*t!Q![*t!c!}*t#R#S*t#T#o*t$g~*t~*yUY~}!O*t!Q![*t!c!}*t#R#S*t#T#o*t$g~*t~+bOV~~+gOU~R+pUeP#`P#kQ}!O(Q!Q![(Q!c!}(Q#R#S(Q#T#o(Q$g~(Q~,XO`~~,^O!P~~,cO_~~,hO}~~,qf#^~#`P#kQX^#{pq#{}!O(Q!Q![(Q!c!}(Q#R#S(Q#T#o(Q#y#z#{$f$g#{$g#BY(Q#BY#BZ,h#BZ$IS(Q$IS$I_,h$I_$I|(Q$I|$JO,h$JO$JT(Q$JT$JU,h$JU$KV(Q$KV$KW,h$KW&FU(Q&FU&FV,h&FV~(Q",
        tokenizers: [0, 1],
        topRules: {
            "Grammar": [0, 3]
        },
        specialized: [{
            term: 10,
            get: value => spec_AtName[value] || -1
        }, {
            term: 119,
            get: value => spec_keyword[value] || -1
        }],
        tokenPrec: 1013
    });
    const lezerLanguage = LRLanguage.define({
        parser: parser$1.configure({
            props: [foldNodeProp.add({
                "Body TokensBody SkipBody PrecedenceBody": foldInside
            })]
        }),
        languageData: {
            commentTokens: {
                block: {
                    open: "/*",
                    close: "*/"
                },
                line: "//"
            },
            indentOnInput: /^\s*\}$/
        }
    });
    function lezer() {
        return new LanguageSupport(lezerLanguage);
    }
    var _m21 = Object.freeze({
        __proto__: null,
        lezer: lezer,
        lezerLanguage: lezerLanguage
    });
    const spec_Keyword = {
        __proto__: null,
        anyref: 34,
        dataref: 34,
        eqref: 34,
        externref: 34,
        i31ref: 34,
        funcref: 34,
        i8: 34,
        i16: 34,
        i32: 34,
        i64: 34,
        f32: 34,
        f64: 34
    };
    const parser = LRParser.deserialize({
        version: 14,
        states: "!^Q]QPOOOqQPO'#CbOOQO'#Cd'#CdOOQO'#Cl'#ClOOQO'#Ch'#ChQ]QPOOOOQO,58|,58|OxQPO,58|OOQO-E6f-E6fOOQO1G.h1G.h",
        stateData: "!P~O_OSPOSQOS~OTPOVROXROYROZROaQO~OSUO~P]OSXO~P]O",
        goto: "xaPPPPPPbPbPPPhPPPrXROPTVQTOQVPTWTVXSOPTV",
        nodeNames: "⚠ LineComment BlockComment Module ) ( App Identifier Type Keyword Number String",
        maxTerm: 17,
        nodeProps: [["openedBy", 4, "("], ["closedBy", 5, ")"], ["group", -6, 6, 7, 8, 9, 10, 11, "Expression"]],
        skippedNodes: [0, 1, 2],
        repeatNodeCount: 1,
        tokenData: "/Q~R^XY}YZ}]^}pq}rs!Stu!qxy&Vyz'S{|'X}!O'X!Q!R'b!R![)_!]!^,{#T#o-^~!SO_~~!VTOr!Srs!fs#O!S#O#P!k#P~!S~!kOZ~~!nPO~!S~!tiqr$cst$ctu$cuv$cvw$cwx$cz{$c{|$c}!O$c!O!P$c!P!Q$c!Q![$c![!]$c!^!_$c!_!`$c!`!a$c!a!b$c!b!c$c!c!}$c#Q#R$c#R#S$c#S#T$c#T#o$c#p#q$c#r#s$c~$hiV~qr$cst$ctu$cuv$cvw$cwx$cz{$c{|$c}!O$c!O!P$c!P!Q$c!Q![$c![!]$c!^!_$c!_!`$c!`!a$c!a!b$c!b!c$c!c!}$c#Q#R$c#R#S$c#S#T$c#T#o$c#p#q$c#r#s$c~&[PT~!]!^&_~&bRO!]&_!]!^&k!^~&_~&nTOy&_yz&}z!]&_!]!^&k!^~&_~'SOQ~~'XOS~~'[Q!Q!R'b!R![)_~'gUY~!O!P'y!Q![)_!g!h(j#R#S)s#X#Y(j#l#m)y~(ORY~!Q![(X!g!h(j#X#Y(j~(^SY~!Q![(X!g!h(j#R#S)X#X#Y(j~(mR{|(v}!O(v!Q![(|~(yP!Q![(|~)RQY~!Q![(|#R#S(v~)[P!Q![(X~)dTY~!O!P'y!Q![)_!g!h(j#R#S)s#X#Y(j~)vP!Q![)_~)|R!Q![*V!c!i*V#T#Z*V~*[VY~!O!P*q!Q![*V!c!i*V!r!s+n#R#S)y#T#Z*V#d#e+n~*vTY~!Q![+V!c!i+V!r!s+n#T#Z+V#d#e+n~+[UY~!Q![+V!c!i+V!r!s+n#R#S,o#T#Z+V#d#e+n~+qT{|,Q}!O,Q!Q![,^!c!i,^#T#Z,^~,TR!Q![,^!c!i,^#T#Z,^~,cSY~!Q![,^!c!i,^#R#S,Q#T#Z,^~,rR!Q![+V!c!i+V#T#Z+V~-OP!]!^-R~-WQP~OY-RZ~-R~-ciX~qr-^st-^tu-^uv-^vw-^wx-^z{-^{|-^}!O-^!O!P-^!P!Q-^!Q![-^![!]-^!^!_-^!_!`-^!`!a-^!a!b-^!b!c-^!c!}-^#Q#R-^#R#S-^#S#T-^#T#o-^#p#q-^#r#s-^",
        tokenizers: [0],
        topRules: {
            "Module": [0, 3]
        },
        specialized: [{
            term: 9,
            get: value => spec_Keyword[value] || -1
        }],
        tokenPrec: 0
    });
    const wastLanguage = LRLanguage.define({
        parser: parser.configure({
            props: [indentNodeProp.add({
                App: delimitedIndent({
                    closing: ")",
                    align: false
                })
            }), foldNodeProp.add({
                App: foldInside,
                BlockComment(tree) {
                    return {
                        from: tree.from + 2,
                        to: tree.to - 2
                    };
                }
            }), styleTags({
                Keyword: tags$1.keyword,
                Type: tags$1.typeName,
                Number: tags$1.number,
                String: tags$1.string,
                Identifier: tags$1.variableName,
                LineComment: tags$1.lineComment,
                BlockComment: tags$1.blockComment,
                "( )": tags$1.paren
            })]
        }),
        languageData: {
            commentTokens: {
                line: ";;",
                block: {
                    open: "(;",
                    close: ";)"
                }
            },
            closeBrackets: {
                brackets: ["(", '"']
            }
        }
    });
    function wast() {
        return new LanguageSupport(wastLanguage);
    }
    var _m22 = Object.freeze({
        __proto__: null,
        wast: wast,
        wastLanguage: wastLanguage
    });
    const chalky = "#e5c07b",
        coral = "#e06c75",
        cyan = "#56b6c2",
        invalid = "#ffffff",
        ivory = "#abb2bf",
        stone = "#7d8799",
        malibu = "#61afef",
        sage = "#98c379",
        whiskey = "#d19a66",
        violet = "#c678dd",
        darkBackground = "#21252b",
        highlightBackground = "#2c313a",
        background = "#282c34",
        tooltipBackground = "#353a42",
        selection = "#3E4451",
        cursor = "#528bff";
    const oneDarkTheme = EditorView.theme({
        "&": {
            color: ivory,
            backgroundColor: background
        },
        ".cm-content": {
            caretColor: cursor
        },
        ".cm-cursor, .cm-dropCursor": {
            borderLeftColor: cursor
        },
        "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {
            backgroundColor: selection
        },
        ".cm-panels": {
            backgroundColor: darkBackground,
            color: ivory
        },
        ".cm-panels.cm-panels-top": {
            borderBottom: "2px solid black"
        },
        ".cm-panels.cm-panels-bottom": {
            borderTop: "2px solid black"
        },
        ".cm-searchMatch": {
            backgroundColor: "#72a1ff59",
            outline: "1px solid #457dff"
        },
        ".cm-searchMatch.cm-searchMatch-selected": {
            backgroundColor: "#6199ff2f"
        },
        ".cm-activeLine": {
            backgroundColor: highlightBackground
        },
        ".cm-selectionMatch": {
            backgroundColor: "#aafe661a"
        },
        "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
            backgroundColor: "#bad0f847",
            outline: "1px solid #515a6b"
        },
        ".cm-gutters": {
            backgroundColor: background,
            color: stone,
            border: "none"
        },
        ".cm-activeLineGutter": {
            backgroundColor: highlightBackground
        },
        ".cm-foldPlaceholder": {
            backgroundColor: "transparent",
            border: "none",
            color: "#ddd"
        },
        ".cm-tooltip": {
            border: "none",
            backgroundColor: tooltipBackground
        },
        ".cm-tooltip .cm-tooltip-arrow:before": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        },
        ".cm-tooltip .cm-tooltip-arrow:after": {
            borderTopColor: tooltipBackground,
            borderBottomColor: tooltipBackground
        },
        ".cm-tooltip-autocomplete": {
            "& > ul > li[aria-selected]": {
                backgroundColor: highlightBackground,
                color: ivory
            }
        }
    }, {
        dark: true
    });
    const oneDarkHighlightStyle = HighlightStyle.define([{
        tag: tags$1.keyword,
        color: violet
    }, {
        tag: [tags$1.name, tags$1.deleted, tags$1.character, tags$1.propertyName, tags$1.macroName],
        color: coral
    }, {
        tag: [tags$1.function(tags$1.variableName), tags$1.labelName],
        color: malibu
    }, {
        tag: [tags$1.color, tags$1.constant(tags$1.name), tags$1.standard(tags$1.name)],
        color: whiskey
    }, {
        tag: [tags$1.definition(tags$1.name), tags$1.separator],
        color: ivory
    }, {
        tag: [tags$1.typeName, tags$1.className, tags$1.number, tags$1.changed, tags$1.annotation, tags$1.modifier, tags$1.self, tags$1.namespace],
        color: chalky
    }, {
        tag: [tags$1.operator, tags$1.operatorKeyword, tags$1.url, tags$1.escape, tags$1.regexp, tags$1.link, tags$1.special(tags$1.string)],
        color: cyan
    }, {
        tag: [tags$1.meta, tags$1.comment],
        color: stone
    }, {
        tag: tags$1.strong,
        fontWeight: "bold"
    }, {
        tag: tags$1.emphasis,
        fontStyle: "italic"
    }, {
        tag: tags$1.strikethrough,
        textDecoration: "line-through"
    }, {
        tag: tags$1.link,
        color: stone,
        textDecoration: "underline"
    }, {
        tag: tags$1.heading,
        fontWeight: "bold",
        color: coral
    }, {
        tag: [tags$1.atom, tags$1.bool, tags$1.special(tags$1.variableName)],
        color: whiskey
    }, {
        tag: [tags$1.processingInstruction, tags$1.string, tags$1.inserted],
        color: sage
    }, {
        tag: tags$1.invalid,
        color: invalid
    }]);
    const oneDark = [oneDarkTheme, syntaxHighlighting(oneDarkHighlightStyle)];
    var _m23 = Object.freeze({
        __proto__: null,
        oneDark: oneDark,
        oneDarkHighlightStyle: oneDarkHighlightStyle,
        oneDarkTheme: oneDarkTheme
    });
    class Change {
        constructor(fromA, toA, fromB, toB)
        {
            this.fromA = fromA;
            this.toA = toA;
            this.fromB = fromB;
            this.toB = toB;
        }
        offset(offA, offB)
        {
            return new Change(this.fromA + offA, this.toA + offA, this.fromB + offB, this.toB + offB);
        }
    }
    function findDiff(a, fromA, toA, b, fromB, toB) {
        if (a == b)
            return [];
        let prefix = commonPrefix(a, fromA, toA, b, fromB, toB);
        let suffix = commonSuffix(a, fromA + prefix, toA, b, fromB + prefix, toB);
        fromA += prefix;
        toA -= suffix;
        fromB += prefix;
        toB -= suffix;
        let lenA = toA - fromA,
            lenB = toB - fromB;
        if (!lenA || !lenB)
            return [new Change(fromA, toA, fromB, toB)];
        if (lenA > lenB) {
            let found = a.slice(fromA, toA).indexOf(b.slice(fromB, toB));
            if (found > -1)
                return [new Change(fromA, fromA + found, fromB, fromB), new Change(fromA + found + lenB, toA, toB, toB)];
        } else if (lenB > lenA) {
            let found = b.slice(fromB, toB).indexOf(a.slice(fromA, toA));
            if (found > -1)
                return [new Change(fromA, fromA, fromB, fromB + found), new Change(toA, toA, fromB + found + lenA, toB)];
        }
        if (lenA == 1 || lenB == 1)
            return [new Change(fromA, toA, fromB, toB)];
        let half = halfMatch(a, fromA, toA, b, fromB, toB);
        if (half) {
            let [sharedA, sharedB, sharedLen] = half;
            return findDiff(a, fromA, sharedA, b, fromB, sharedB).concat(findDiff(a, sharedA + sharedLen, toA, b, sharedB + sharedLen, toB));
        }
        return findSnake(a, fromA, toA, b, fromB, toB);
    }
    function findSnake(a, fromA, toA, b, fromB, toB) {
        let lenA = toA - fromA,
            lenB = toB - fromB;
        let off = Math.ceil((lenA + lenB) / 2);
        frontier1.reset(off);
        frontier2.reset(off);
        let match1 = (x, y) => a.charCodeAt(fromA + x) == b.charCodeAt(fromB + y);
        let match2 = (x, y) => a.charCodeAt(toA - x - 1) == b.charCodeAt(toB - y - 1);
        let test1 = (lenA - lenB) % 2 != 0 ? frontier2 : null,
            test2 = test1 ? null : frontier1;
        for (let depth = 0; depth < off; depth++) {
            let done = frontier1.advance(depth, lenA, lenB, off, test1, false, match1) || frontier2.advance(depth, lenA, lenB, off, test2, true, match2);
            if (done)
                return bisect(a, fromA, toA, fromA + done[0], b, fromB, toB, fromB + done[1]);
        }
        return [new Change(fromA, toA, fromB, toB)];
    }
    class Frontier {
        constructor()
        {
            this.vec = [];
        }
        reset(off)
        {
            this.len = off << 1;
            for (let i = 0; i < this.len; i++)
                this.vec[i] = -1;
            this.vec[off + 1] = 0;
            this.start = this.end = 0;
        }
        advance(depth, lenX, lenY, vOff, other, fromBack, match)
        {
            for (let k = -depth + this.start; k <= depth - this.end; k += 2) {
                let off = vOff + k;
                let x = k == -depth || k != depth && this.vec[off - 1] < this.vec[off + 1] ? this.vec[off + 1] : this.vec[off - 1] + 1;
                let y = x - k;
                while (x < lenX && y < lenY && match(x, y)) {
                    x++;
                    y++;
                }
                this.vec[off] = x;
                if (x > lenX) {
                    this.end += 2;
                } else if (y > lenY) {
                    this.start += 2;
                } else if (other) {
                    let offOther = vOff + (lenX - lenY) - k;
                    if (offOther >= 0 && offOther < this.len && other.vec[offOther] != -1) {
                        if (!fromBack) {
                            let xOther = lenX - other.vec[offOther];
                            if (x >= xOther)
                                return [x, y];
                        } else {
                            let xOther = other.vec[offOther];
                            if (xOther >= lenX - x)
                                return [xOther, vOff + xOther - offOther];
                        }
                    }
                }
            }
            return null;
        }
    }
    const frontier1 = new Frontier(),
        frontier2 = new Frontier();
    function bisect(a, fromA, toA, splitA, b, fromB, toB, splitB) {
        let stop = false;
        if (!validIndex(a, splitA) && ++splitA == toA)
            stop = true;
        if (!validIndex(b, splitB) && ++splitB == toB)
            stop = true;
        if (stop)
            return [new Change(fromA, toA, fromB, toB)];
        return findDiff(a, fromA, splitA, b, fromB, splitB).concat(findDiff(a, splitA, toA, b, splitB, toB));
    }
    function chunkSize(lenA, lenB) {
        let size = 1,
            max = Math.min(lenA, lenB);
        while (size < max)
            size = size << 1;
        return size;
    }
    function commonPrefix(a, fromA, toA, b, fromB, toB) {
        if (fromA == toA || fromA == toB || a.charCodeAt(fromA) != b.charCodeAt(fromB))
            return 0;
        let chunk = chunkSize(toA - fromA, toB - fromB);
        for (let pA = fromA, pB = fromB; ;) {
            let endA = pA + chunk,
                endB = pB + chunk;
            if (endA > toA || endB > toB || a.slice(pA, endA) != b.slice(pB, endB)) {
                if (chunk == 1)
                    return pA - fromA - (validIndex(a, pA) ? 0 : 1);
                chunk = chunk >> 1;
            } else if (endA == toA || endB == toB) {
                return endA - fromA;
            } else {
                pA = endA;
                pB = endB;
            }
        }
    }
    function commonSuffix(a, fromA, toA, b, fromB, toB) {
        if (fromA == toA || fromB == toB || a.charCodeAt(toA - 1) != b.charCodeAt(toB - 1))
            return 0;
        let chunk = chunkSize(toA - fromA, toB - fromB);
        for (let pA = toA, pB = toB; ;) {
            let sA = pA - chunk,
                sB = pB - chunk;
            if (sA < fromA || sB < fromB || a.slice(sA, pA) != b.slice(sB, pB)) {
                if (chunk == 1)
                    return toA - pA - (validIndex(a, pA) ? 0 : 1);
                chunk = chunk >> 1;
            } else if (sA == fromA || sB == fromB) {
                return toA - sA;
            } else {
                pA = sA;
                pB = sB;
            }
        }
    }
    function halfMatch(a, fromA, toA, b, fromB, toB) {
        let lenA = toA - fromA,
            lenB = toB - fromB;
        if (lenA < lenB) {
            let result = halfMatch(b, fromB, toB, a, fromA, toA);
            return result && [result[1], result[0], result[2]];
        }
        if (lenA < 4 || lenB * 2 < lenA)
            return null;
        let rangeB = b.slice(fromB, toB);
        function scanFrom(seedFrom) {
            let seedTo = seedFrom + Math.floor(lenA / 4);
            if (!validIndex(a, seedFrom))
                seedFrom++;
            if (!validIndex(a, seedTo))
                seedTo--;
            if (seedFrom >= seedTo)
                return null;
            let seed = a.slice(seedFrom, seedTo);
            let found = -1,
                best;
            while ((found = rangeB.indexOf(seed, found + 1)) != -1) {
                let prefixAfter = commonPrefix(a, seedTo, toA, b, fromB + found + seed.length, toB);
                let suffixBefore = commonSuffix(a, fromA, seedFrom, b, fromB, fromB + found);
                let length = seed.length + prefixAfter + suffixBefore;
                if (!best || best[2] < length)
                    best = [seedFrom - suffixBefore, fromB + found - suffixBefore, length];
            }
            return best && best[2] * 2 > lenA ? best : null;
        }
        let match1 = scanFrom(fromA + Math.ceil(lenA / 4));
        let match2 = scanFrom(fromA + Math.ceil(lenA / 2));
        return match1 && (!match2 || match2[2] < match1[2]) ? match1 : match2;
    }
    function mergeAdjacent(changes, minGap) {
        for (let i = 1; i < changes.length; i++) {
            let prev = changes[i - 1],
                cur = changes[i];
            if (prev.toA > cur.fromA - minGap && prev.toB > cur.fromB - minGap) {
                changes[i - 1] = new Change(prev.fromA, cur.toA, prev.fromB, cur.toB);
                changes.splice(i--, 1);
            }
        }
    }
    function normalize(a, b, changes) {
        for (;;) {
            mergeAdjacent(changes, 1);
            let moved = false;
            for (let i = 0; i < changes.length; i++) {
                let ch = changes[i],
                    pre,
                    post;
                if (pre = commonPrefix(a, ch.fromA, ch.toA, b, ch.fromB, ch.toB))
                    ch = changes[i] = new Change(ch.fromA + pre, ch.toA, ch.fromB + pre, ch.toB);
                if (post = commonSuffix(a, ch.fromA, ch.toA, b, ch.fromB, ch.toB))
                    ch = changes[i] = new Change(ch.fromA, ch.toA - post, ch.fromB, ch.toB - post);
                let lenA = ch.toA - ch.fromA,
                    lenB = ch.toB - ch.fromB;
                if (lenA && lenB)
                    continue;
                let beforeLen = ch.fromA - (i ? changes[i - 1].toA : 0);
                let afterLen = (i < changes.length - 1 ? changes[i + 1].fromA : a.length) - ch.toA;
                if (!beforeLen || !afterLen)
                    continue;
                let text = lenA ? a.slice(ch.fromA, ch.toA) : b.slice(ch.fromB, ch.toB);
                if (beforeLen <= text.length && a.slice(ch.fromA - beforeLen, ch.fromA) == text.slice(text.length - beforeLen)) {
                    changes[i] = new Change(ch.fromA - beforeLen, ch.toA - beforeLen, ch.fromB - beforeLen, ch.toB - beforeLen);
                    moved = true;
                } else if (afterLen <= text.length && a.slice(ch.toA, ch.toA + afterLen) == text.slice(0, afterLen)) {
                    changes[i] = new Change(ch.fromA + afterLen, ch.toA + afterLen, ch.fromB + afterLen, ch.toB + afterLen);
                    moved = true;
                }
            }
            if (!moved)
                break;
        }
        return changes;
    }
    function makePresentable(changes, a, b) {
        for (let posA = 0, i = 0; i < changes.length; i++) {
            let change = changes[i];
            let lenA = change.toA - change.fromA,
                lenB = change.toB - change.fromB;
            if (lenA && lenB || lenA > 3 || lenB > 3) {
                let nextChangeA = i == changes.length - 1 ? a.length : changes[i + 1].fromA;
                let maxScanBefore = change.fromA - posA,
                    maxScanAfter = nextChangeA - change.toA;
                let boundBefore = findWordBoundaryBefore(a, change.fromA, Math.min(maxScanBefore, 5));
                let boundAfter = findWordBoundaryAfter(a, change.toA, Math.min(maxScanAfter, 5));
                let lenBefore = change.fromA - boundBefore,
                    lenAfter = boundAfter - change.toA;
                if (!lenA || !lenB) {
                    let changeLen = Math.max(lenA, lenB);
                    let [changeText, changeFrom, changeTo] = lenA ? [a, change.fromA, change.toA] : [b, change.fromB, change.toB];
                    let indentBefore,
                        indentLen;
                    if (lenBefore && lenAfter) {
                        if (changeLen > lenBefore && a.slice(boundBefore, change.fromA) == changeText.slice(changeTo - lenBefore, changeTo)) {
                            change = changes[i] = new Change(boundBefore, boundBefore + lenA, change.fromB - lenBefore, change.toB - lenBefore);
                            boundBefore = change.fromA;
                            boundAfter = findWordBoundaryAfter(a, change.toA, Math.min(nextChangeA - change.toA, 5));
                        } else if (changeLen > lenAfter && a.slice(change.toA, boundAfter) == changeText.slice(changeFrom, changeFrom + lenAfter)) {
                            change = changes[i] = new Change(boundAfter - lenA, boundAfter, change.fromB + lenAfter, change.toB + lenAfter);
                            boundAfter = change.toA;
                            boundBefore = findWordBoundaryBefore(a, change.fromA, Math.min(change.fromA - posA, 5));
                        }
                        lenBefore = change.fromA - boundBefore;
                        lenAfter = boundAfter - change.toA;
                    } else if (!lenBefore && !lenAfter && (indentLen = change.fromA - (indentBefore = findIndentBefore(a, change.fromA, maxScanBefore))) && a.slice(indentBefore, change.fromA) == changeText.slice(changeTo - indentLen, changeTo)) {
                        change = changes[i] = new Change(indentBefore, indentBefore + lenA, change.fromB - indentLen, change.toB - indentLen);
                    }
                }
                if (lenBefore || lenAfter) {
                    change = changes[i] = new Change(change.fromA - lenBefore, change.toA + lenAfter, change.fromB - lenBefore, change.toB + lenAfter);
                }
                posA = change.toA;
            }
        }
        mergeAdjacent(changes, 3);
        return changes;
    }
    let wordChar;
    try {
        wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}]", "u");
    } catch (_) {}
    function asciiWordChar(code) {
        return code > 48 && code < 58 || code > 64 && code < 91 || code > 96 && code < 123;
    }
    function wordCharAfter(s, pos) {
        if (pos == s.length)
            return 0;
        let next = s.charCodeAt(pos);
        if (next < 192)
            return asciiWordChar(next) ? 1 : 0;
        if (!wordChar)
            return 0;
        if (!isSurrogate1(next) || pos == s.length - 1)
            return wordChar.test(String.fromCharCode(next)) ? 1 : 0;
        return wordChar.test(s.slice(pos, pos + 2)) ? 2 : 0;
    }
    function wordCharBefore(s, pos) {
        if (!pos)
            return 0;
        let prev = s.charCodeAt(pos - 1);
        if (prev < 192)
            return asciiWordChar(prev) ? 1 : 0;
        if (!wordChar)
            return 0;
        if (!isSurrogate2(prev) || pos == 1)
            return wordChar.test(String.fromCharCode(prev)) ? 1 : 0;
        return wordChar.test(s.slice(pos - 2, pos)) ? 2 : 0;
    }
    function findWordBoundaryAfter(s, pos, max) {
        if (pos == s.length || !wordCharBefore(s, pos))
            return pos;
        for (let cur = pos, end = pos + max; ;) {
            let size = wordCharAfter(s, cur);
            if (!size)
                return cur;
            cur += size;
            if (cur > end)
                return pos;
        }
    }
    function findWordBoundaryBefore(s, pos, max) {
        if (!pos || !wordCharAfter(s, pos))
            return pos;
        for (let cur = pos, end = pos - max; ;) {
            let size = wordCharBefore(s, cur);
            if (!size)
                return cur;
            cur -= size;
            if (cur < end)
                return pos;
        }
    }
    function findIndentBefore(s, pos, max) {
        for (let cur = pos, end = pos - max; ;) {
            let next = cur ? s.charCodeAt(cur - 1) : 10;
            if (next == 10)
                return cur;
            cur--;
            if (cur < end || next != 32 && next != 9)
                return pos;
        }
    }
    const isSurrogate1 = code => code >= 0xD800 && code <= 0xDBFF;
    const isSurrogate2 = code => code >= 0xDC00 && code <= 0xDFFF;
    function validIndex(s, index) {
        return !index || index == s.length || !isSurrogate1(s.charCodeAt(index - 1)) || !isSurrogate2(s.charCodeAt(index));
    }
    function diff(a, b) {
        return normalize(a, b, findDiff(a, 0, a.length, b, 0, b.length));
    }
    function presentableDiff(a, b) {
        return makePresentable(diff(a, b), a, b);
    }
    class Chunk {
        constructor(changes, fromA, toA, fromB, toB)
        {
            this.changes = changes;
            this.fromA = fromA;
            this.toA = toA;
            this.fromB = fromB;
            this.toB = toB;
        }
        offset(offA, offB)
        {
            return offA || offB ? new Chunk(this.changes, this.fromA + offA, this.toA + offA, this.fromB + offB, this.toB + offB) : this;
        }
        get endA()
        {
            return Math.max(this.fromA, this.toA - 1);
        }
        get endB()
        {
            return Math.max(this.fromB, this.toB - 1);
        }
    }
    function fromLine(fromA, fromB, a, b) {
        let lineA = a.lineAt(fromA),
            lineB = b.lineAt(fromB);
        return lineA.to == fromA && lineB.to == fromB ? [Math.min(a.length, fromA + 1), Math.min(b.length, fromB + 1)] : [lineA.from, lineB.from];
    }
    function toLine(toA, toB, a, b) {
        let lineA = a.lineAt(toA),
            lineB = b.lineAt(toB);
        return lineA.from == toA && lineB.from == toB ? [toA, toB] : [lineA.to + 1, lineB.to + 1];
    }
    function toChunks(changes, a, b, offA, offB) {
        let chunks = [];
        for (let i = 0; i < changes.length; i++) {
            let change = changes[i];
            let [fromA, fromB] = fromLine(change.fromA + offA, change.fromB + offB, a, b);
            let [toA, toB] = toLine(change.toA + offA, change.toB + offB, a, b);
            let chunk = [change.offset(-fromA + offA, -fromB + offB)];
            while (i < changes.length - 1) {
                let next = changes[i + 1];
                let [nextA, nextB] = fromLine(next.fromA + offA, next.fromB + offB, a, b);
                if (nextA > toA + 1 && nextB > toB + 1)
                    break;
                chunk.push(next.offset(-fromA + offA, -fromB + offB));
                [toA, toB] = toLine(next.toA + offA, next.toB + offB, a, b);
                i++;
            }
            chunks.push(new Chunk(chunk, fromA, Math.max(fromA, toA), fromB, Math.max(fromB, toB)));
        }
        return chunks;
    }
    function buildChunks(a, b) {
        return toChunks(presentableDiff(a.toString(), b.toString()), a, b, 0, 0);
    }
    const updateMargin = 1000;
    function findPos(chunks, pos, isA, start) {
        let lo = 0,
            hi = chunks.length;
        for (;;) {
            if (lo == hi) {
                let refA = 0,
                    refB = 0;
                if (lo)
                    ({toA: refA, toB: refB} = chunks[lo - 1]);
                let off = pos - (isA ? refA : refB);
                return [refA + off, refB + off];
            }
            let mid = lo + hi >> 1,
                chunk = chunks[mid];
            let [from, to] = isA ? [chunk.fromA, chunk.toA] : [chunk.fromB, chunk.toB];
            if (from > pos)
                hi = mid;
            else if (to <= pos)
                lo = mid + 1;
            else
                return start ? [chunk.fromA, chunk.fromB] : [chunk.toA, chunk.toB];
        }
    }
    function findRangesForChange(chunks, changes, isA, otherLen) {
        let ranges = [];
        changes.iterChangedRanges((cFromA, cToA, cFromB, cToB) => {
            let fromA = 0,
                toA = isA ? changes.length : otherLen;
            let fromB = 0,
                toB = isA ? otherLen : changes.length;
            if (cFromA > updateMargin)
                [fromA, fromB] = findPos(chunks, cFromA - updateMargin, isA, true);
            if (cToA < changes.length - updateMargin)
                [toA, toB] = findPos(chunks, cToA + updateMargin, isA, false);
            let lenDiff = cToB - cFromB - (cToA - cFromA),
                last;
            let [diffA, diffB] = isA ? [lenDiff, 0] : [0, lenDiff];
            if (ranges.length && (last = ranges[ranges.length - 1]).toA >= fromA)
                ranges[ranges.length - 1] = {
                    fromA: last.fromA,
                    fromB: last.fromB,
                    toA,
                    toB,
                    diffA: last.diffA + diffA,
                    diffB: last.diffB + diffB
                };
            else
                ranges.push({
                    fromA,
                    toA,
                    fromB,
                    toB,
                    diffA,
                    diffB
                });
        });
        return ranges;
    }
    function updateChunks(ranges, chunks, a, b) {
        if (!ranges.length)
            return chunks;
        let chunkI = 0,
            offA = 0,
            offB = 0;
        let result = [];
        for (let _i287 = 0, _length287 = ranges.length; _i287 < _length287; _i287++) {
            let range = ranges[_i287];
            let fromA = range.fromA + offA,
                toA = range.toA + offA + range.diffA;
            let fromB = range.fromB + offB,
                toB = range.toB + offB + range.diffB;
            while (chunkI < chunks.length) {
                let next = chunks[chunkI];
                if (next.toA + offA <= fromA)
                    result.push(next.offset(offA, offB));
                else if (next.fromA + offA > toA)
                    break;
                chunkI++;
            }
            for (let _i288 = 0, _toChunks = toChunks(presentableDiff(a.sliceString(fromA, toA), b.sliceString(fromB, toB)), a, b, fromA, fromB), _length288 = _toChunks.length; _i288 < _length288; _i288++) {
                let chunk = _toChunks[_i288];
                result.push(chunk);
            }
            offA += range.diffA;
            offB += range.diffB;
        }
        while (chunkI < chunks.length)
            result.push(chunks[chunkI++].offset(offA, offB));
        return result;
    }
    function updateChunksA(chunks, transaction, b) {
        return updateChunks(findRangesForChange(chunks, transaction.changes, true, b.length), chunks, transaction.newDoc, b);
    }
    function updateChunksB(chunks, transaction, a) {
        return updateChunks(findRangesForChange(chunks, transaction.changes, false, a.length), chunks, a, transaction.newDoc);
    }
    const setChunks = StateEffect.define();
    const ChunkField = StateField.define({
        create(state) {
            return null;
        },
        update(current, tr) {
            for (let _i289 = 0, _tr$effects16 = tr.effects, _length289 = _tr$effects16.length; _i289 < _length289; _i289++) {
                let e = _tr$effects16[_i289];
                if (e.is(setChunks))
                    current = e.value;
            }
            return current;
        }
    });
    const mergeConfig = Facet.define({
        combine: values => values[0]
    });
    const decorateChunks = ViewPlugin.fromClass(class {
        constructor(view)
        {
            ({deco: this.deco, gutter: this.gutter} = getChunkDeco(view));
        }
        update(update)
        {
            if (update.docChanged || update.viewportChanged || chunksChanged(update.startState, update.state) || configChanged(update.startState, update.state))
                ({deco: this.deco, gutter: this.gutter} = getChunkDeco(update.view));
        }
    }
    , {
        decorations: d => d.deco
    });
    const changeGutter = Prec.low(gutter({
        class: "cm-changeGutter",
        markers: view => {
            var _a;
            return ((_a = view.plugin(decorateChunks)) === null || _a === void 0 ? void 0 : _a.gutter) || RangeSet.empty;
        },
        renderEmptyElements: false
    }));
    function chunksChanged(s1, s2) {
        return s1.field(ChunkField, false) != s2.field(ChunkField, false);
    }
    function configChanged(s1, s2) {
        return s1.facet(mergeConfig) != s2.facet(mergeConfig);
    }
    const changedLine = Decoration.line({
        class: "cm-changedLine"
    });
    const changedText = Decoration.mark({
        class: "cm-changedText"
    });
    const changedLineGutterMarker = new class  extends GutterMarker{
        constructor()
        {
            super(...arguments);
            this.elementClass = "cm-changedLineGutter";
        }
    }
    ();
    function buildChunkDeco(chunk, doc, isA, highlight, builder, gutterBuilder) {
        let from = isA ? chunk.fromA : chunk.fromB,
            to = isA ? chunk.toA : chunk.toB;
        let changeI = 0;
        if (from != to) {
            builder.add(from, from, changedLine);
            if (gutterBuilder)
                gutterBuilder.add(from, from, changedLineGutterMarker);
            for (let iter = doc.iterRange(from, to - 1), pos = from; !iter.next().done;) {
                if (iter.lineBreak) {
                    pos++;
                    builder.add(pos, pos, changedLine);
                    if (gutterBuilder)
                        gutterBuilder.add(pos, pos, changedLineGutterMarker);
                    continue;
                }
                let lineEnd = pos + iter.value.length;
                if (highlight)
                    while (changeI < chunk.changes.length) {
                        let nextChange = chunk.changes[changeI];
                        let nextFrom = from + (isA ? nextChange.fromA : nextChange.fromB);
                        let nextTo = from + (isA ? nextChange.toA : nextChange.toB);
                        let chFrom = Math.max(pos, nextFrom),
                            chTo = Math.min(lineEnd, nextTo);
                        if (chFrom < chTo)
                            builder.add(chFrom, chTo, changedText);
                        if (nextTo < lineEnd)
                            changeI++;
                        else
                            break;
                    }
                pos = lineEnd;
            }
        }
    }
    function getChunkDeco(view) {
        let chunks = view.state.field(ChunkField);
        let {side, highlightChanges, markGutter} = view.state.facet(mergeConfig),
            isA = side == "a";
        let builder = new RangeSetBuilder();
        let gutterBuilder = markGutter ? new RangeSetBuilder() : null;
        let {from, to} = view.viewport;
        for (let _i290 = 0, _length290 = chunks.length; _i290 < _length290; _i290++) {
            let chunk = chunks[_i290];
            if ((isA ? chunk.fromA : chunk.fromB) >= to)
                break;
            if ((isA ? chunk.toA : chunk.toB) > from)
                buildChunkDeco(chunk, view.state.doc, isA, highlightChanges, builder, gutterBuilder);
        }
        return {
            deco: builder.finish(),
            gutter: gutterBuilder && gutterBuilder.finish()
        };
    }
    class Spacer extends WidgetType {
        constructor(height)
        {
            super();
            this.height = height;
        }
        eq(other)
        {
            return this.height == other.height;
        }
        toDOM()
        {
            let elt = document.createElement("div");
            elt.className = "cm-mergeSpacer";
            elt.style.height = this.height + "px";
            return elt;
        }
        updateDOM(dom)
        {
            dom.style.height = this.height + "px";
            return true;
        }
        get estimatedHeight()
        {
            return this.height;
        }
        ignoreEvent()
        {
            return false;
        }
    }
    const adjustSpacers = StateEffect.define({
        map: (value, mapping) => value.map(mapping)
    });
    const Spacers = StateField.define({
        create: () => Decoration.none,
        update: (spacers, tr) => {
            for (let _i291 = 0, _tr$effects17 = tr.effects, _length291 = _tr$effects17.length; _i291 < _length291; _i291++) {
                let e = _tr$effects17[_i291];
                if (e.is(adjustSpacers))
                    return e.value;
            }
            return spacers.map(tr.changes);
        },
        provide: f => EditorView.decorations.from(f)
    });
    const epsilon = .0001;
    function updateSpacers(a, b, chunks) {
        let buildA = new RangeSetBuilder(),
            buildB = new RangeSetBuilder();
        let linesA = a.viewportLineBlocks,
            linesB = b.viewportLineBlocks,
            iA = 0,
            iB = 0;
        let spacersA = a.state.field(Spacers).iter(),
            spacersB = b.state.field(Spacers).iter();
        let posA = 0,
            posB = 0,
            offA = 0,
            offB = 0;
        chunks:
        for (let chunkI = 0; ; chunkI++) {
            let chunk = chunkI < chunks.length ? chunks[chunkI] : null;
            let [endA, endB] = chunk ? [chunk.fromA, chunk.fromB] : [a.state.doc.length, b.state.doc.length];
            if (posA < endA && posB < endB)
                for (;;) {
                    if (iA == linesA.length || iB == linesB.length)
                        break chunks;
                    let lineA = linesA[iA],
                        lineB = linesB[iB];
                    while (spacersA.value && spacersA.from < lineA.from) {
                        offA -= spacersA.value.spec.widget.height;
                        spacersA.next();
                    }
                    while (spacersB.value && spacersB.from < lineB.from) {
                        offB -= spacersB.value.spec.widget.height;
                        spacersB.next();
                    }
                    if (lineA.from >= endA || lineB.from >= endB)
                        break;
                    let relA = lineA.from - posA,
                        relB = lineB.from - posB;
                    if (relA < 0 || relA < relB) {
                        iA++;
                    } else if (relB < 0 || relB < relA) {
                        iB++;
                    } else {
                        let diff = lineA.top + offA - (lineB.top + offB);
                        if (diff < -epsilon) {
                            offA -= diff;
                            buildA.add(lineA.from, lineA.from, Decoration.widget({
                                widget: new Spacer(-diff),
                                block: true,
                                side: -1
                            }));
                        } else if (diff > epsilon) {
                            offB += diff;
                            buildB.add(lineB.from, lineB.from, Decoration.widget({
                                widget: new Spacer(diff),
                                block: true,
                                side: -1
                            }));
                        }
                        iA++;
                        iB++;
                    }
                }
            if (!chunk)
                break;
            posA = chunk.toA;
            posB = chunk.toB;
        }
        while (spacersA.value) {
            offA -= spacersA.value.spec.widget.height;
            spacersA.next();
        }
        while (spacersB.value) {
            offB -= spacersB.value.spec.widget.height;
            spacersB.next();
        }
        let docDiff = a.contentHeight + offA - (b.contentHeight + offB);
        if (docDiff < epsilon)
            buildA.add(a.state.doc.length, a.state.doc.length, Decoration.widget({
                widget: new Spacer(-docDiff),
                block: true,
                side: 1
            }));
        else if (docDiff > epsilon)
            buildB.add(b.state.doc.length, b.state.doc.length, Decoration.widget({
                widget: new Spacer(docDiff),
                block: true,
                side: 1
            }));
        let decoA = buildA.finish(),
            decoB = buildB.finish();
        if (!RangeSet.eq([decoA], [a.state.field(Spacers)]))
            a.dispatch({
                effects: adjustSpacers.of(decoA)
            });
        if (!RangeSet.eq([decoB], [b.state.field(Spacers)]))
            b.dispatch({
                effects: adjustSpacers.of(decoB)
            });
    }
    const uncollapse = StateEffect.define({
        map: (value, change) => change.mapPos(value)
    });
    class CollapseWidget extends WidgetType {
        constructor(lines)
        {
            super();
            this.lines = lines;
        }
        eq(other)
        {
            return this.lines == other.lines;
        }
        toDOM(view)
        {
            let outer = document.createElement("div");
            outer.className = "cm-collapsedLines";
            outer.textContent = "⦚ " + view.state.phrase("$ unchanged lines", this.lines) + " ⦚";
            outer.addEventListener("click", e => {
                let pos = view.posAtDOM(e.target);
                view.dispatch({
                    effects: uncollapse.of(pos)
                });
                let {side, sibling} = view.state.facet(mergeConfig);
                sibling().dispatch({
                    effects: uncollapse.of(mapPos(pos, view.state.field(ChunkField), side == "a"))
                });
            });
            return outer;
        }
        ignoreEvent(e)
        {
            return e instanceof MouseEvent;
        }
        get estimatedHeight()
        {
            return 27;
        }
    }
    function mapPos(pos, chunks, isA) {
        let startOur = 0,
            startOther = 0;
        for (let i = 0; ; i++) {
            let next = i < chunks.length ? chunks[i] : null;
            if (!next || (isA ? next.fromA : next.fromB) >= pos)
                return startOther + (pos - startOur);
            [startOur, startOther] = isA ? [next.toA, next.toB] : [next.toB, next.toA];
        }
    }
    const CollapsedRanges = StateField.define({
        create(state) {
            return Decoration.none;
        },
        update(deco, tr) {
            deco = deco.map(tr.changes);
            for (let _i292 = 0, _tr$effects18 = tr.effects, _length292 = _tr$effects18.length; _i292 < _length292; _i292++) {
                let e = _tr$effects18[_i292];
                if (e.is(uncollapse))
                    deco = deco.update({
                        filter: from => from != e.value
                    });
            }
            return deco;
        },
        provide: f => EditorView.decorations.from(f)
    });
    function collapseUnchanged({margin=3, minSize=4}) {
        return CollapsedRanges.init(state => buildCollapsedRanges(state, margin, minSize));
    }
    function buildCollapsedRanges(state, margin, minLines) {
        let builder = new RangeSetBuilder();
        let isA = state.facet(mergeConfig).side == "a";
        let chunks = state.field(ChunkField);
        let prevLine = 1;
        for (let i = 0; ; i++) {
            let chunk = i < chunks.length ? chunks[i] : null;
            let collapseFrom = i ? prevLine + margin : 1;
            let collapseTo = chunk ? state.doc.lineAt(isA ? chunk.fromA : chunk.fromB).number - 1 - margin : state.doc.lines;
            let lines = collapseTo - collapseFrom + 1;
            if (lines >= minLines) {
                builder.add(state.doc.line(collapseFrom).from, state.doc.line(collapseTo).to, Decoration.replace({
                    widget: new CollapseWidget(lines),
                    block: true
                }));
            }
            if (!chunk)
                break;
            prevLine = state.doc.lineAt(Math.min(state.doc.length, isA ? chunk.toA : chunk.toB)).number;
        }
        return builder.finish();
    }
    const externalTheme = EditorView.styleModule.of(new StyleModule({
        ".cm-mergeView": {
            overflowY: "auto"
        },
        ".cm-mergeViewEditors": {
            display: "flex",
            alignItems: "stretch"
        },
        ".cm-mergeViewEditor": {
            flexGrow: 1,
            flexBasis: 0,
            overflow: "hidden"
        },
        ".cm-merge-revert": {
            width: "1.6em",
            flexGrow: 0,
            flexShrink: 0,
            position: "relative"
        },
        ".cm-merge-revert button": {
            position: "absolute",
            display: "block",
            width: "100%",
            boxSizing: "border-box",
            textAlign: "center",
            background: "none",
            border: "none",
            font: "inherit",
            cursor: "pointer"
        }
    }));
    const baseTheme = EditorView.baseTheme({
        "& .cm-scroller, &": {
            height: "auto !important",
            overflowY: "visible !important"
        },
        "&.cm-merge-a .cm-changedLine": {
            backgroundColor: "rgba(160, 128, 100, .08)"
        },
        "&.cm-merge-b .cm-changedLine": {
            backgroundColor: "rgba(100, 160, 128, .08)"
        },
        "&light.cm-merge-a .cm-changedText": {
            background: "linear-gradient(#ee443366, #ee443366) bottom/100% 2px no-repeat"
        },
        "&dark.cm-merge-a .cm-changedText": {
            background: "linear-gradient(#ffaa9966, #ffaa9966) bottom/100% 2px no-repeat"
        },
        "&light.cm-merge-b .cm-changedText": {
            background: "linear-gradient(#22bb2266, #22bb2266) bottom/100% 2px no-repeat"
        },
        "&dark.cm-merge-b .cm-changedText": {
            background: "linear-gradient(#88ff8866, #88ff8866) bottom/100% 2px no-repeat"
        },
        ".cm-collapsedLines": {
            padding: "5px 5px 5px 10px",
            cursor: "pointer"
        },
        "&light .cm-collapsedLines": {
            color: "#444",
            background: "linear-gradient(to bottom, transparent 0, #f3f3f3 30%, #f3f3f3 70%, transparent 100%)"
        },
        "&dark .cm-collapsedLines": {
            color: "#ddd",
            background: "linear-gradient(to bottom, transparent 0, #222 30%, #222 70%, transparent 100%)"
        },
        ".cm-changeGutter": {
            width: "3px",
            paddingLeft: "1px"
        },
        "&light.cm-merge-a .cm-changedLineGutter": {
            background: "#e43"
        },
        "&dark.cm-merge-a .cm-changedLineGutter": {
            background: "#fa9"
        },
        "&light.cm-merge-b .cm-changedLineGutter": {
            background: "#2b2"
        },
        "&dark.cm-merge-b .cm-changedLineGutter": {
            background: "#8f8"
        }
    });
    const collapseCompartment = new Compartment(),
        configCompartment = new Compartment();
    class MergeView {
        constructor(config)
        {
            this.revertDOM = null;
            this.revertToA = false;
            this.revertToLeft = false;
            this.measuring = -1;
            let sharedExtensions = [Prec.low(decorateChunks), baseTheme, externalTheme, Spacers, EditorView.updateListener.of(update => {
                if (this.measuring < 0 && (update.heightChanged || update.viewportChanged) && !update.transactions.some(tr => tr.effects.some(e => e.is(adjustSpacers))))
                    this.measure();
            })];
            let configA = [mergeConfig.of({
                side: "a",
                sibling: () => this.b,
                highlightChanges: config.highlightChanges !== false,
                markGutter: config.gutter !== false
            })];
            if (config.gutter !== false)
                configA.push(changeGutter);
            let stateA = EditorState.create({
                doc: config.a.doc,
                selection: config.a.selection,
                extensions: [config.a.extensions || [], EditorView.editorAttributes.of({
                    class: "cm-merge-a"
                }), configCompartment.of(configA), sharedExtensions]
            });
            let configB = [mergeConfig.of({
                side: "b",
                sibling: () => this.a,
                highlightChanges: config.highlightChanges !== false,
                markGutter: config.gutter !== false
            })];
            if (config.gutter !== false)
                configB.push(changeGutter);
            let stateB = EditorState.create({
                doc: config.b.doc,
                selection: config.b.selection,
                extensions: [config.b.extensions || [], EditorView.editorAttributes.of({
                    class: "cm-merge-b"
                }), configCompartment.of(configB), sharedExtensions]
            });
            this.chunks = buildChunks(stateA.doc, stateB.doc);
            let add = [ChunkField.init(() => this.chunks), collapseCompartment.of(config.collapseUnchanged ? collapseUnchanged(config.collapseUnchanged) : [])];
            stateA = stateA.update({
                effects: StateEffect.appendConfig.of(add)
            }).state;
            stateB = stateB.update({
                effects: StateEffect.appendConfig.of(add)
            }).state;
            this.dom = document.createElement("div");
            this.dom.className = "cm-mergeView";
            this.editorDOM = this.dom.appendChild(document.createElement("div"));
            this.editorDOM.className = "cm-mergeViewEditors";
            let orientation = config.orientation || "a-b";
            let wrapA = document.createElement("div");
            wrapA.className = "cm-mergeViewEditor";
            let wrapB = document.createElement("div");
            wrapB.className = "cm-mergeViewEditor";
            this.editorDOM.appendChild(orientation == "a-b" ? wrapA : wrapB);
            this.editorDOM.appendChild(orientation == "a-b" ? wrapB : wrapA);
            this.a = new EditorView({
                state: stateA,
                parent: wrapA,
                root: config.root,
                dispatch: tr => this.dispatch(tr, this.a)
            });
            this.b = new EditorView({
                state: stateB,
                parent: wrapB,
                root: config.root,
                dispatch: tr => this.dispatch(tr, this.b)
            });
            this.setupRevertControls(!!config.revertControls, config.revertControls == "b-to-a", config.renderRevertControl);
            if (config.parent)
                config.parent.appendChild(this.dom);
            this.scheduleMeasure();
        }
        dispatch(tr, target)
        {
            if (tr.docChanged) {
                this.chunks = target == this.a ? updateChunksA(this.chunks, tr, this.b.state.doc) : updateChunksB(this.chunks, tr, this.a.state.doc);
                target.update([tr, tr.state.update({
                    effects: setChunks.of(this.chunks)
                })]);
                let other = target == this.a ? this.b : this.a;
                other.update([other.state.update({
                    effects: setChunks.of(this.chunks)
                })]);
                this.scheduleMeasure();
            } else {
                target.update([tr]);
            }
        }
        reconfigure(config)
        {
            if ("orientation" in config) {
                let aB = config.orientation != "b-a";
                if (aB != (this.editorDOM.firstChild == this.a.dom.parentNode)) {
                    let domA = this.a.dom.parentNode,
                        domB = this.b.dom.parentNode;
                    domA.remove();
                    domB.remove();
                    this.editorDOM.insertBefore(aB ? domA : domB, this.editorDOM.firstChild);
                    this.editorDOM.appendChild(aB ? domB : domA);
                    this.revertToLeft = !this.revertToLeft;
                    if (this.revertDOM)
                        this.revertDOM.textContent = "";
                }
            }
            if ("revertControls" in config || "renderRevertControl" in config) {
                let controls = !!this.revertDOM,
                    toA = this.revertToA,
                    render = this.renderRevert;
                if ("revertControls" in config) {
                    controls = !!config.revertControls;
                    toA = config.revertControls == "b-to-a";
                }
                if ("renderRevertControl" in config)
                    render = config.renderRevertControl;
                this.setupRevertControls(controls, toA, render);
            }
            let highlight = ("highlightChanges" in config),
                gutter = ("gutter" in config),
                collapse = ("collapseUnchanged" in config);
            if (highlight || gutter || collapse) {
                let effectsA = [],
                    effectsB = [];
                if (highlight || gutter) {
                    let currentConfig = this.a.state.facet(mergeConfig);
                    let markGutter = gutter ? config.gutter !== false : currentConfig.markGutter;
                    let highlightChanges = highlight ? config.highlightChanges !== false : currentConfig.highlightChanges;
                    effectsA.push(configCompartment.reconfigure([mergeConfig.of({
                        side: "a",
                        sibling: () => this.b,
                        highlightChanges,
                        markGutter
                    }), markGutter ? changeGutter : []]));
                    effectsB.push(configCompartment.reconfigure([mergeConfig.of({
                        side: "b",
                        sibling: () => this.a,
                        highlightChanges,
                        markGutter
                    }), markGutter ? changeGutter : []]));
                }
                if (collapse) {
                    let effect = collapseCompartment.reconfigure(config.collapseUnchanged ? collapseUnchanged(config.collapseUnchanged) : []);
                    effectsA.push(effect);
                    effectsB.push(effect);
                }
                this.a.dispatch({
                    effects: effectsA
                });
                this.b.dispatch({
                    effects: effectsB
                });
            }
            this.scheduleMeasure();
        }
        setupRevertControls(controls, toA, render)
        {
            this.revertToA = toA;
            this.revertToLeft = this.revertToA == (this.editorDOM.firstChild == this.a.dom.parentNode);
            this.renderRevert = render;
            if (!controls && this.revertDOM) {
                this.revertDOM.remove();
                this.revertDOM = null;
            } else if (controls && !this.revertDOM) {
                this.revertDOM = this.editorDOM.insertBefore(document.createElement("div"), this.editorDOM.firstChild.nextSibling);
                this.revertDOM.addEventListener("mousedown", e => this.revertClicked(e));
                this.revertDOM.className = "cm-merge-revert";
            } else if (this.revertDOM) {
                this.revertDOM.textContent = "";
            }
        }
        scheduleMeasure()
        {
            if (this.measuring < 0) {
                let win = this.dom.ownerDocument.defaultView || window;
                this.measuring = win.requestAnimationFrame(() => {
                    this.measuring = -1;
                    this.measure();
                });
            }
        }
        measure()
        {
            updateSpacers(this.a, this.b, this.chunks);
            if (this.revertDOM)
                this.updateRevertButtons();
        }
        updateRevertButtons()
        {
            let dom = this.revertDOM,
                next = dom.firstChild;
            let vpA = this.a.viewport,
                vpB = this.b.viewport;
            for (let i = 0; i < this.chunks.length; i++) {
                let chunk = this.chunks[i];
                if (chunk.fromA > vpA.to || chunk.fromB > vpB.to)
                    break;
                if (chunk.fromA < vpA.from || chunk.fromB < vpB.from)
                    continue;
                let top = this.a.lineBlockAt(chunk.fromA).top + "px";
                while (next && +next.dataset.chunk < i)
                    next = rm(next);
                if (next && next.dataset.chunk == String(i)) {
                    if (next.style.top != top)
                        next.style.top = top;
                    next = next.nextSibling;
                } else {
                    dom.insertBefore(this.renderRevertButton(top, i), next);
                }
            }
            while (next)
                next = rm(next);
        }
        renderRevertButton(top, chunk)
        {
            let elt;
            if (this.renderRevert) {
                elt = this.renderRevert();
            } else {
                elt = document.createElement("button");
                let text = this.a.state.phrase("Revert this chunk");
                elt.setAttribute("aria-label", text);
                elt.setAttribute("title", text);
                elt.textContent = this.revertToLeft ? "⇜" : "⇝";
            }
            elt.style.top = top;
            elt.setAttribute("data-chunk", String(chunk));
            return elt;
        }
        revertClicked(e)
        {
            let target = e.target,
                chunk;
            while (target && target.parentNode != this.revertDOM)
                target = target.parentNode;
            if (target && (chunk = this.chunks[target.dataset.chunk])) {
                let [source, dest, srcFrom, srcTo, destFrom, destTo] = this.revertToA ? [this.b, this.a, chunk.fromB, chunk.toB, chunk.fromA, chunk.toA] : [this.a, this.b, chunk.fromA, chunk.toA, chunk.fromB, chunk.toB];
                let insert = source.state.sliceDoc(srcFrom, Math.max(srcFrom, srcTo - 1));
                if (srcFrom != srcTo)
                    insert += source.state.lineBreak;
                dest.dispatch({
                    changes: {
                        from: destFrom,
                        to: Math.min(dest.state.doc.length, destTo),
                        insert
                    },
                    userEvent: "revert"
                });
                e.preventDefault();
            }
        }
        destroy()
        {
            this.a.destroy();
            this.b.destroy();
            if (this.measuring > -1)
                (this.dom.ownerDocument.defaultView || window).cancelAnimationFrame(this.measuring);
            this.dom.remove();
        }
    }
    function rm(elt) {
        let next = elt.nextSibling;
        elt.remove();
        return next;
    }
    function getChunks(state) {
        let field = state.field(ChunkField, false);
        if (!field)
            return null;
        return {
            chunks: field,
            side: state.facet(mergeConfig).side
        };
    }
    const __test = {
        buildChunks,
        updateChunksA,
        updateChunksB
    };
    var _m24 = Object.freeze({
        __proto__: null,
        Change: Change,
        Chunk: Chunk,
        MergeView: MergeView,
        __test: __test,
        diff: diff,
        getChunks: getChunks,
        presentableDiff: presentableDiff
    });
    window.CM = {
        "@codemirror/state": _m0,
        "@codemirror/view": _m1,
        "@codemirror/language": _m2,
        "@codemirror/commands": _m3,
        "@codemirror/search": _m4,
        "@codemirror/autocomplete": _m5,
        "@codemirror/lint": _m6,
        "@codemirror/collab": _m7,
        "codemirror": _m8,
        "@codemirror/lang-javascript": _m9,
        "@codemirror/lang-java": _m10,
        "@codemirror/lang-json": _m11,
        "@codemirror/lang-cpp": _m12,
        "@codemirror/lang-php": _m13,
        "@codemirror/lang-python": _m14,
        "@codemirror/lang-css": _m15,
        "@codemirror/lang-html": _m16,
        "@codemirror/lang-sql": _m17,
        "@codemirror/lang-rust": _m18,
        "@codemirror/lang-xml": _m19,
        "@codemirror/lang-markdown": _m20,
        "@codemirror/lang-lezer": _m21,
        "@codemirror/lang-wast": _m22,
        "@codemirror/theme-one-dark": _m23,
        "@codemirror/merge": _m24,
        "@lezer/lr": _m25,
        "@lezer/common": _m26,
        "@lezer/highlight": _m27,
        "crelt": _m28
    };
})();

