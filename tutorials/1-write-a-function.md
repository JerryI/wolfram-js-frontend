# 1 How to add a new function to the frontend
Let us start with a neat one - `ListContourPlot` or `ContourPlot`. 
The steps without much details are shown at the bottom at [TL;DR](#tldr) section

### Preliminary steps
The simplest approach will be to take the existing `.js` library and fetch for a given function. The one I found [ploty.js](https://plotly.com/javascript/contour-plots/)

```js
var size = 100, x = new Array(size), y = new Array(size), z = new Array(size), i, j;

for(var i = 0; i < size; i++) {
	x[i] = y[i] = -2 * Math.PI + 4 * Math.PI * i / size;
  	z[i] = new Array(size);
}

for(var i = 0; i < size; i++) {
  	for(j = 0; j < size; j++) {
    	var r2 = x[i]*x[i] + y[j]*y[j];
    	z[i][j] = Math.sin(x[i]) * Math.cos(y[j]) * Math.sin(r2) / Math.log(r2+1);
 	}
}

var data = [ {
		z: z,
		x: x,
		y: y,
		type: 'contour'
	}
];

Plotly.newPlot('myDiv', data);
```

### Adding a new function to the kernel

Since we want to keep the original function from Wolfram Engine untouched (one can still use them using `//SVGForm`), let us create a new one

__all new graphical or interactive objects are stored in `src/webobjects.wls`__

Those definitions are visible for both `master` kernel and any wolfram engine `processes` spawned by the core.
> in the present implementations, the `webobjects.wls` syncs with `shared/webobjects.wls`, which is the first folder which is loaded by `master.wls` and by a child process, located in `svcore/run.wls`

Let's start from the basic functionality of `ListContourPlot`
```mathematica
ListContourPlot[
 Partition[Table[{x, y, x y}, {x, -2, 2}, {y, -2, 2}] // Flatten, 3]]
```
Then the input data has a form of `{x,y,f[x,y]}, ...`. Let's write a prototype. If one compare in the input form of the data passed to `ploty.js`, the data is transposed in way like

```js
var data = [ {
		z: z,
		x: x,
		y: y,
		type: 'contour'
	}
];
```
Therefore there are two possibilities how we can do this:
- transpose it on client's side using JS tools
- write a wrapped function for mathematica, which will do the job

Since our webbrowser is already suffering from drawing stuff and etc. Here is the last option

***src/webobjects.wls***
```mathematica
...
ListContourPloty[s_List] := WListContourPloty[Transpose[s//N]];
...
```

Using a wrapped function `WListContourPloty` might looks unnecessary, but I can help to prepare the data in a more complicated cases. This is just an example.

Now we need to register this one in `src/converter.wls`, that the system will know that this has to be executed on the frontend and not just return as a string

add the function to the list

***src/converter.wls***
```mathematica
$SupportedGraphicsObjectList = {WListContourPloty, Graphics3D, HTMLForm, WListPloty, TableForm};
...
...
```

>Mb one can generalize all those calls to a single `ListPloty[data, typeofdiagram, settings]` with a couple of parameters, which will tell how to display the given data, instead of writting the same code all over again

Now the entire function with its data will be replaced by `FrontEndExecutable["id"]` - a reference to the JSON object, where the function `WListContourPloty[data]` is presented. 

>Actually `src/converter.wls` does a simple 
>```mathematica
>ExportString[WListContourPloty[data], "ExpressionJSON"]
>``` 
>and saves it as a cell's property, which will arrive to the browser as well.

>On the browsers's side CodeMirror will replace all string which match the pattern of `FrontEndExecutable["id"]` with the output generated by JS Wolfram Language interpreter acting on the JSON object received with the cell's data. 

>Every time, when such object is received by wolfram kernel, the reference is replaced by the original function and evaluation continues as if nothing was changed.

### Writting the JS representation of the function

Go to `src/misc.js` for example. This is a good place to start. Let us write the the name and the body of the function 1:1

***src/misc.js***
```js
...

core.WListContourPloty = function(args, env) {
  const data = interpretate(args[0], env);
  console.log(data);

} 

...
```
if your data can have rational numbers and other symbolic stuff, you can specify, the the output has to be numerical by setting
```js
const data = interpretate(args[0], {...env, numerical:true});
```
it will force all functions like `core.Rational`, `core.Times` to return a numerical result.

However, since there is no point in overloading the browser with the data processing in such particular case, one can pre convert to the numerical form `data//N` (what we've done already) on the wolfram kernel.

#### Testing
Save our modified files
- *src/webobjects.wls*
- *src/converter.wls*
- *src/misc.js*

open the folder in the terminal and run
```bash
wolframscript start.wls dev
```
or if you use in for the first time, install `nodejs` (used for the bundeling js files) and then
```bash
npm i
wolframscript start.wls dev
```

Open the browser and write in a new notebook's cell

```mathematica
ListContourPloty[Partition[Table[{x, y, x y}, {x, -2, 2}, {y, -2, 2}] // Flatten, 3]]
```

![image](../imgs/tutor-1-img-emptycell.png)

This is right, there is nothing to display. In the developer console we will see our arrays

![image](../imgs/tutor-1-img-consolelog.png)

#### Making DOM objects
The dom element in the cell created for each interactive object is accessible from the argument `env.element`
>This is rather simple, every time when the `FrontEndExecutable` runs, it creates a `<span>` element and puts it's id into the `env` variable
>
>*src/frontend.js*
>```js
>let elt = document.createElement("span");
>interpretate(JSON.parse($objetsstorage[this.name]), { element: elt });
>```

Then let's add the rest of the code 

***src/misc.js***
```js
...

core.WListContourPloty = function(args, env) {
  const data = interpretate(args[0], env);
  console.log(data);

  Plotly.newPlot(env.element, [{z:data[2], x:data[0], y:data[1], type: 'contour'}]);
} 

...
```
Easy, ha?
Save the modified files
- *src/misc.js*

The result is following

![img](../imgs/tutor-1-img-contourplot.png)

fully interactive; zooming, panning is there

## TL;DR

Added lines
***src/webobjects.wls***
```mathematica
...
ListContourPloty[s_List] := WListContourPloty[Transpose[s//N]];
...
```

***src/converter.wls***
```mathematica
$SupportedGraphicsObjectList = {WListContourPloty, ...};
...
...
```

***src/misc.js***
```js
...

core.WListContourPloty = function(args, env) {
  const data = interpretate(args[0], env);
  console.log(data);

  Plotly.newPlot(env.element, [{z:data[2], x:data[0], y:data[1], type: 'contour'}]);
} 

...
```
