<|"Notebook" -> <|"Controller" -> "43d76a96-827c-4fa3-aed4-09902c984d6d", 
   "FocusedCell" -> CellObj[JerryI`Notebook`CellObj`$96], 
   "MessangerChannel" -> Messanger, "ModalsChannel" -> 
    "11870e7b-6439-4065-bece-e4e1cf0fb349", 
   "Objects" -> <|"bcb3e485-f716-4f53-bc06-81af27eda67a" -> 
      <|"Public" -> Hold[ForceGraph3D[{"pea" -> "peak", "pea" -> "peal", 
           "peace" -> "peaces", "peace" -> "peach", "peaceable" -> 
            "peaceably", "peaceable" -> "peaceful", "peaceably" -> 
            "peaceable", "peaceably" -> "peaceful", "peaceful" -> 
            "peacefully", "peaceful" -> "peace", "peacefuller" -> 
            "peacefullest", "peacefuller" -> "peacefully", 
           "peacefullest" -> "peacefuller", "peacefullest" -> "peacefulness", 
           "peacefully" -> "peaceful", "peacefully" -> "peacefuller", 
           "peacefulness" -> "peacefullest", "peacefulness" -> "peacefuller", 
           "peacekeeper" -> "peacekeepers", "peacekeeper" -> "peacekeeping", 
           "peacekeepers" -> "peacekeeper", "peacekeepers" -> "peacekeeping", 
           "peacekeeping" -> "peacekeeper", "peacekeeping" -> "peacekeepers", 
           "peacemaker" -> "peacemakers", "peacemaker" -> "peacemaking", 
           "peacemakers" -> "peacemaker", "peacemakers" -> "peacemaking", 
           "peacemaking" -> "peacemaker", "peacemaking" -> "peacemakers", 
           "peaces" -> "peace", "peaces" -> "peaches", "peacetime" -> 
            "peaceable", "peacetime" -> "peace", "peach" -> "peace", 
           "peach" -> "peachy", "peaches" -> "peaces", "peaches" -> "peace", 
           "peachier" -> "peaches", "peachier" -> "peachiest", 
           "peachiest" -> "peaches", "peachiest" -> "peachier", 
           "peachy" -> "peach", "peachy" -> "peace", "peacock" -> "peacocks", 
           "peacock" -> "peace", "peacocks" -> "peacock", 
           "peacocks" -> "peaces", "peafowl" -> "peafowls", 
           "peafowl" -> "peacock", "peafowls" -> "peafowl", 
           "peafowls" -> "peacocks", "peahen" -> "peahens", 
           "peahen" -> "peace", "peahens" -> "peahen", "peahens" -> "peaces", 
           "peak" -> "pea", "peak" -> "peaks", "peaked" -> "pealed", 
           "peaked" -> "peace", "peakiness" -> "peaking", 
           "peakiness" -> "peatiest", "peaking" -> "pealing", 
           "peaking" -> "pearling", "peaks" -> "peak", "peaks" -> "peaky", 
           "peaky" -> "peak", "peaky" -> "peaks", "peal" -> "pea", 
           "peal" -> "peak", "pealed" -> "peaked", "pealed" -> "pearled", 
           "pealing" -> "peaking", "pealing" -> "pearling", 
           "peals" -> "peaks", "peals" -> "peal", "peanut" -> "peanuts", 
           "peanut" -> "peat", "peanuts" -> "peanut", "peanuts" -> "peaces", 
           "pear" -> "pea", "pear" -> "peak", "pearl" -> "peal", 
           "pearl" -> "pear", "pearled" -> "pealed", "pearled" -> "peaked", 
           "pearlier" -> "peachier", "pearlier" -> "pearled", 
           "pearliest" -> "peachiest", "pearliest" -> "pearlier", 
           "pearling" -> "pealing", "pearling" -> "peaking", 
           "pearls" -> "peals", "pearls" -> "pearl", "pearly" -> "pearl", 
           "pearly" -> "pearls", "pears" -> "peaks", "pears" -> "peals", 
           "peartrees" -> "peaces", "peartrees" -> "peaches", 
           "peas" -> "pea", "peas" -> "peak", "peasant" -> "peasants", 
           "peasant" -> "peasantry", "peasantry" -> "peasant", 
           "peasantry" -> "peasants", "peasants" -> "peasant", 
           "peasants" -> "peasantry", "peashooter" -> "peashooters", 
           "peashooter" -> "peachier", "peashooters" -> "peashooter", 
           "peashooters" -> "peacemakers", "peat" -> "pea", "peat" -> "peak", 
           "peatier" -> "peachier", "peatier" -> "pearlier", 
           "peatiest" -> "peachiest", "peatiest" -> "pearliest", 
           "peaty" -> "peaky", "peaty" -> "peat"}, ImageSize -> 500]]|>, 
     "7350994e-9424-4b9f-a7f0-dcc29c29ba2a" -> 
      <|"Public" -> Hold[ForceGraph3D[{1 -> 2, 2 -> 3, 3 -> 4, 4 -> 2, 
           3 -> 5}, "VertexLabels" -> {1 -> "one", 4 -> "four", 5 -> "five"}, 
          ImageSize -> 500]]|>|>, "Path" -> "/Users/kirill/Github/wolfram-js-\
frontend/Demos/09 - Mixing languages/Force Graph3D.wln", 
   "TOC" -> {Notebook`Editor`TOC`Private`heading[1, 
      "Connecting external Javascript library ", 
      CellObj[JerryI`Notebook`CellObj`$76]], 
     Notebook`Editor`TOC`Private`heading[2, 
      "How to make interactive 3D Force-Directed Graphs", 
      CellObj[JerryI`Notebook`CellObj`$76]], 
     Notebook`Editor`TOC`Private`heading[2, "Testing", 
      CellObj[JerryI`Notebook`CellObj`$95]]}|>, 
 "Cells" -> {<|"Data" -> ".md\n# Connecting external Javascript library \n## \
How to make interactive 3D Force-Directed Graphs\n\nThere is an amazing \
[Javascript library](https://github.com/vasturiano/3d-force-graph) for \
building 3D force graphs using THREE.js. \n\nWe can build it into a standlone \
module for our notebooks using ESM cells. But firstly, lets fetch this \
library using NPM", "Display" -> "codemirror", 
    "Hash" -> "3b2460b8-4e75-4edd-a088-d7746475debb", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "# Connecting external Javascript library \n## How to make \
interactive 3D Force-Directed Graphs\n\nThere is an amazing [Javascript \
library](https://github.com/vasturiano/3d-force-graph) for building 3D force \
graphs using THREE.js. \n\nWe can build it into a standlone module for our \
notebooks using ESM cells. But firstly, lets fetch this library using NPM", 
    "Display" -> "markdown", "Hash" -> 
     "5bc957c0-d09e-4296-a268-32fba923de31", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Output", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> ".sh\nnpm i 3d-force-graph", "Display" -> "codemirror", 
    "Hash" -> "3bab2e3b-b744-473b-969a-f462a14eae74", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "\nadded 33 packages, and audited 37 packages in 4s\n\nfound 0 \
vulnerabilities\n", "Display" -> "shell", 
    "Hash" -> "6efbe96f-ec01-455a-a217-0c3f24c94c1b", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Output", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> ".md\nNow define our function. WLJS Notebook has a system of \
shared Javascript libraries, which already provides some of the \
dependencies.", "Display" -> "codemirror", 
    "Hash" -> "205abfe6-c3e5-4300-b29d-5a7b30b1aba6", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "Now define our function. WLJS Notebook has a system of shared \
Javascript libraries, which already provides some of the dependencies.", 
    "Display" -> "markdown", "Hash" -> 
     "b542d445-48ef-40e7-81c1-6aa6b9624407", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Output", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> ".esm\nimport ForceGraph3D from \
'3d-force-graph';\n\ncore.ForceGraph3D = async (args, env) => { \n  //load \
shared library from WLJS Notebook store\n  await \
interpretate.shared.SpriteText.load();\n  //interprete input data\n  const \
data = await interpretate(args[0], env);\n\n  const SpriteText = \
interpretate.shared.SpriteText.SpriteText;\n  const opts = await \
core._getRules(args, env);\n\n  // Build labels mapping\n  const labels = \
(opts.VertexLabels || []).reduce((acc, { lhs, rhs }) => {\n    acc[lhs] = \
rhs;\n    return acc;\n  }, {});\n\n  // Collect node IDs and construct \
links\n  const nodeIds = new Set();\n  const links = data.map(({ lhs, rhs }) \
=> {\n    nodeIds.add(lhs);\n    nodeIds.add(rhs);\n    return { source: \
String(rhs), target: String(lhs) };\n  });\n\n  // Create nodes with labels\n \
 const nodes = Array.from(nodeIds).map(id => ({\n    id: String(id),\n    \
label: labels[id] || String(id),\n  }));\n\n  let imageSize = \
(opts.ImageSize) || 350;\n\n  if (!Array.isArray(imageSize)) {\n    imageSize \
= [imageSize, imageSize * 0.7];\n  }\n\n  // Initialize the 3D force graph\n  \
const Graph = ForceGraph3D({})(env.element)\n    .width(imageSize[0])\n    \
.height(imageSize[1])\n    .cooldownTicks(100)\n    .graphData({ nodes, links \
})\n    .nodeThreeObject(node => {\n      const sprite = new \
SpriteText(node.label);\n      sprite.material.depthWrite = true; // Make \
sprite background transparent\n      sprite.color = 'white';\n      \
sprite.textHeight = 12;\n      return sprite;\n    })\n    \
.nodeThreeObjectExtend(false);\n\n  // Apply optional charge strength\n  if \
('Charge' in opts) {\n    Graph.d3Force('charge').strength(opts.Charge);\n  \
}\n\n  Graph.onEngineStop(() => Graph.zoomToFit(400));\n\n  env.local.Graph = \
Graph;\n};\n\ncore.ForceGraph3D.destroy = () => {\n  console.warn('3D graph \
was removed');\n}\n\n//make each instance unique\ncore.ForceGraph3D.virtual = \
true  \n", "Display" -> "codemirror", 
    "Hash" -> "6298baa1-e049-4dda-8958-bad15ef7810d", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Fade" -> True|>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "var __create = Object.create;\nvar __defProp = \
Object.defineProperty;\nvar __getOwnPropDesc = \
Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = \
Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar \
__hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod2) \
=> function __require() {\n  return mod2 || (0, \
cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), \
mod2.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if \
(from && typeof from === \"object\" || typeof from === \"function\") {\n    \
for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, \
key) && key !== except)\n        __defProp(to, key, { get: () => from[key], \
enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  \
}\n  return to;\n};\nvar __toESM = (mod2, isNodeMode, target) => (target = \
mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n  // If the \
importer is in node compatibility mode or this is not an ESM\n  // file that \
has been converted to a CommonJS file using a Babel-\n  // compatible \
transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" \
to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || \
!mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, \
enumerable: true }) : target,\n  mod2\n));\n\n// \
../../node_modules/ngraph.events/index.js\nvar require_ngraph = \
__commonJS({\n  \"../../node_modules/ngraph.events/index.js\"(exports, \
module) {\n    module.exports = function eventify(subject) {\n      \
validateSubject(subject);\n      var eventsStorage = \
createEventsStorage(subject);\n      subject.on = eventsStorage.on;\n      \
subject.off = eventsStorage.off;\n      subject.fire = eventsStorage.fire;\n  \
    return subject;\n    };\n    function createEventsStorage(subject) {\n    \
  var registeredEvents = /* @__PURE__ */ Object.create(null);\n      return \
{\n        on: function(eventName, callback, ctx) {\n          if (typeof \
callback !== \"function\") {\n            throw new Error(\"callback is \
expected to be a function\");\n          }\n          var handlers = \
registeredEvents[eventName];\n          if (!handlers) {\n            \
handlers = registeredEvents[eventName] = [];\n          }\n          \
handlers.push({ callback, ctx });\n          return subject;\n        },\n    \
    off: function(eventName, callback) {\n          var wantToRemoveAll = \
typeof eventName === \"undefined\";\n          if (wantToRemoveAll) {\n       \
     registeredEvents = /* @__PURE__ */ Object.create(null);\n            \
return subject;\n          }\n          if (registeredEvents[eventName]) {\n  \
          var deleteAllCallbacksForEvent = typeof callback !== \
\"function\";\n            if (deleteAllCallbacksForEvent) {\n              \
delete registeredEvents[eventName];\n            } else {\n              var \
callbacks = registeredEvents[eventName];\n              for (var i = 0; i < \
callbacks.length; ++i) {\n                if (callbacks[i].callback === \
callback) {\n                  callbacks.splice(i, 1);\n                }\n   \
           }\n            }\n          }\n          return subject;\n        \
},\n        fire: function(eventName) {\n          var callbacks = \
registeredEvents[eventName];\n          if (!callbacks) {\n            return \
subject;\n          }\n          var fireArguments;\n          if \
(arguments.length > 1) {\n            fireArguments = \
Array.prototype.splice.call(arguments, 1);\n          }\n          for (var i \
= 0; i < callbacks.length; ++i) {\n            var callbackInfo = \
callbacks[i];\n            callbackInfo.callback.apply(callbackInfo.ctx, \
fireArguments);\n          }\n          return subject;\n        }\n      \
};\n    }\n    function validateSubject(subject) {\n      if (!subject) {\n   \
     throw new Error(\"Eventify cannot use falsy object as events \
subject\");\n      }\n      var reservedWords = [\"on\", \"fire\", \
\"off\"];\n      for (var i = 0; i < reservedWords.length; ++i) {\n        if \
(subject.hasOwnProperty(reservedWords[i])) {\n          throw new \
Error(\"Subject cannot be eventified, since it already has property '\" + \
reservedWords[i] + \"'\");\n        }\n      }\n    }\n  }\n});\n\n// \
../../node_modules/ngraph.graph/index.js\nvar require_ngraph2 = \
__commonJS({\n  \"../../node_modules/ngraph.graph/index.js\"(exports, module) \
{\n    module.exports = createGraph;\n    var eventify = require_ngraph();\n  \
  function createGraph(options) {\n      options = options || {};\n      if \
(\"uniqueLinkId\" in options) {\n        console.warn(\n          \
\"ngraph.graph: Starting from version 0.14 `uniqueLinkId` is \
deprecated.\\nUse `multigraph` option instead\\n\",\n          \"\\n\",\n     \
     \"Note: there is also change in default behavior: From now on each \
graph\\nis considered to be not a multigraph by default (each edge is \
unique).\"\n        );\n        options.multigraph = options.uniqueLinkId;\n  \
    }\n      if (options.multigraph === void 0) options.multigraph = false;\n \
     if (typeof Map !== \"function\") {\n        throw new \
Error(\"ngraph.graph requires `Map` to be defined. Please polyfill it before \
using ngraph\");\n      }\n      var nodes = /* @__PURE__ */ new Map();\n     \
 var links = /* @__PURE__ */ new Map();\n      var multiEdges = {};\n      \
var suspendEvents = 0;\n      var createLink = options.multigraph ? \
createUniqueLink : createSingleLink, changes = [], recordLinkChange = noop2, \
recordNodeChange = noop2, enterModification = noop2, exitModification = \
noop2;\n      var graphPart = {\n        /**\n         * Sometimes duck \
typing could be slow. Giving clients a hint about data structure\n         * \
via explicit version number here:\n         */\n        version: 20,\n        \
/**\n         * Adds node to the graph. If node with given id already exists \
in the graph\n         * its data is extended with whatever comes in 'data' \
argument.\n         *\n         * @param nodeId the node's identifier. A \
string or number is preferred.\n         * @param [data] additional data for \
the node being added. If node already\n         *   exists its data object is \
augmented with the new one.\n         *\n         * @return {node} The newly \
added node or node with given id if it already exists.\n         */\n        \
addNode,\n        /**\n         * Adds a link to the graph. The function \
always create a new\n         * link between two nodes. If one of the nodes \
does not exists\n         * a new node is created.\n         *\n         * \
@param fromId link start node id;\n         * @param toId link end node id;\n \
        * @param [data] additional data to be set on the new link;\n         \
*\n         * @return {link} The newly created link\n         */\n        \
addLink,\n        /**\n         * Removes link from the graph. If link does \
not exist does nothing.\n         *\n         * @param link - object returned \
by addLink() or getLinks() methods.\n         *\n         * @returns true if \
link was removed; false otherwise.\n         */\n        removeLink,\n        \
/**\n         * Removes node with given id from the graph. If node does not \
exist in the graph\n         * does nothing.\n         *\n         * @param \
nodeId node's identifier passed to addNode() function.\n         *\n         \
* @returns true if node was removed; false otherwise.\n         */\n        \
removeNode,\n        /**\n         * Gets node with given identifier. If node \
does not exist undefined value is returned.\n         *\n         * @param \
nodeId requested node identifier;\n         *\n         * @return {node} in \
with requested identifier or undefined if no such node exists.\n         */\n \
       getNode,\n        /**\n         * Gets number of nodes in this \
graph.\n         *\n         * @return number of nodes in the graph.\n        \
 */\n        getNodeCount,\n        /**\n         * Gets total number of \
links in the graph.\n         */\n        getLinkCount,\n        /**\n        \
 * Gets total number of links in the graph.\n         */\n        \
getEdgeCount: getLinkCount,\n        /**\n         * Synonym for \
`getLinkCount()`\n         */\n        getLinksCount: getLinkCount,\n        \
/**\n         * Synonym for `getNodeCount()`\n         */\n        \
getNodesCount: getNodeCount,\n        /**\n         * Gets all links (inbound \
and outbound) from the node with given id.\n         * If node with given id \
is not found null is returned.\n         *\n         * @param nodeId \
requested node identifier.\n         *\n         * @return Set of links from \
and to requested node if such node exists;\n         *   otherwise null is \
returned.\n         */\n        getLinks,\n        /**\n         * Invokes \
callback on each node of the graph.\n         *\n         * @param \
{Function(node)} callback Function to be invoked. The function\n         *   \
is passed one argument: visited node.\n         */\n        forEachNode,\n    \
    /**\n         * Invokes callback on every linked (adjacent) node to the \
given one.\n         *\n         * @param nodeId Identifier of the requested \
node.\n         * @param {Function(node, link)} callback Function to be \
called on all linked nodes.\n         *   The function is passed two \
parameters: adjacent node and link object itself.\n         * @param oriented \
if true graph treated as oriented.\n         */\n        forEachLinkedNode,\n \
       /**\n         * Enumerates all links in the graph\n         *\n        \
 * @param {Function(link)} callback Function to be called on all links in the \
graph.\n         *   The function is passed one parameter: graph's link \
object.\n         *\n         * Link object contains at least the following \
fields:\n         *  fromId - node id where link starts;\n         *  toId - \
node id where link ends,\n         *  data - additional data passed to \
graph.addLink() method.\n         */\n        forEachLink,\n        /**\n     \
    * Suspend all notifications about graph changes until\n         * \
endUpdate is called.\n         */\n        beginUpdate: enterModification,\n  \
      /**\n         * Resumes all notifications about graph changes and \
fires\n         * graph 'changed' event in case there are any pending \
changes.\n         */\n        endUpdate: exitModification,\n        /**\n    \
     * Removes all nodes and links from the graph.\n         */\n        \
clear,\n        /**\n         * Detects whether there is a link between two \
nodes.\n         * Operation complexity is O(n) where n - number of links of \
a node.\n         * NOTE: this function is synonym for getLink()\n         \
*\n         * @returns link if there is one. null otherwise.\n         */\n   \
     hasLink: getLink,\n        /**\n         * Detects whether there is a \
node with given id\n         * \n         * Operation complexity is O(1)\n    \
     * NOTE: this function is synonym for getNode()\n         *\n         * \
@returns node if there is one; Falsy value otherwise.\n         */\n        \
hasNode: getNode,\n        /**\n         * Gets an edge between two nodes.\n  \
       * Operation complexity is O(n) where n - number of links of a node.\n  \
       *\n         * @param {string} fromId link start identifier\n         * \
@param {string} toId link end identifier\n         *\n         * @returns \
link if there is one; undefined otherwise.\n         */\n        getLink\n    \
  };\n      eventify(graphPart);\n      monitorSubscribers();\n      return \
graphPart;\n      function monitorSubscribers() {\n        var realOn = \
graphPart.on;\n        graphPart.on = on;\n        function on() {\n          \
graphPart.beginUpdate = enterModification = enterModificationReal;\n          \
graphPart.endUpdate = exitModification = exitModificationReal;\n          \
recordLinkChange = recordLinkChangeReal;\n          recordNodeChange = \
recordNodeChangeReal;\n          graphPart.on = realOn;\n          return \
realOn.apply(graphPart, arguments);\n        }\n      }\n      function \
recordLinkChangeReal(link, changeType) {\n        changes.push({\n          \
link,\n          changeType\n        });\n      }\n      function \
recordNodeChangeReal(node, changeType) {\n        changes.push({\n          \
node,\n          changeType\n        });\n      }\n      function \
addNode(nodeId, data) {\n        if (nodeId === void 0) {\n          throw \
new Error(\"Invalid node identifier\");\n        }\n        \
enterModification();\n        var node = getNode(nodeId);\n        if (!node) \
{\n          node = new Node2(nodeId, data);\n          \
recordNodeChange(node, \"add\");\n        } else {\n          node.data = \
data;\n          recordNodeChange(node, \"update\");\n        }\n        \
nodes.set(nodeId, node);\n        exitModification();\n        return node;\n \
     }\n      function getNode(nodeId) {\n        return nodes.get(nodeId);\n \
     }\n      function removeNode(nodeId) {\n        var node = \
getNode(nodeId);\n        if (!node) {\n          return false;\n        }\n  \
      enterModification();\n        var prevLinks = node.links;\n        if \
(prevLinks) {\n          prevLinks.forEach(removeLinkInstance);\n          \
node.links = null;\n        }\n        nodes.delete(nodeId);\n        \
recordNodeChange(node, \"remove\");\n        exitModification();\n        \
return true;\n      }\n      function addLink(fromId, toId, data) {\n        \
enterModification();\n        var fromNode = getNode(fromId) || \
addNode(fromId);\n        var toNode = getNode(toId) || addNode(toId);\n      \
  var link = createLink(fromId, toId, data);\n        var isUpdate = \
links.has(link.id);\n        links.set(link.id, link);\n        \
addLinkToNode(fromNode, link);\n        if (fromId !== toId) {\n          \
addLinkToNode(toNode, link);\n        }\n        recordLinkChange(link, \
isUpdate ? \"update\" : \"add\");\n        exitModification();\n        \
return link;\n      }\n      function createSingleLink(fromId, toId, data) \
{\n        var linkId = makeLinkId(fromId, toId);\n        var prevLink = \
links.get(linkId);\n        if (prevLink) {\n          prevLink.data = \
data;\n          return prevLink;\n        }\n        return new Link(fromId, \
toId, data, linkId);\n      }\n      function createUniqueLink(fromId, toId, \
data) {\n        var linkId = makeLinkId(fromId, toId);\n        var \
isMultiEdge = multiEdges.hasOwnProperty(linkId);\n        if (isMultiEdge || \
getLink(fromId, toId)) {\n          if (!isMultiEdge) {\n            \
multiEdges[linkId] = 0;\n          }\n          var suffix = \"@\" + \
++multiEdges[linkId];\n          linkId = makeLinkId(fromId + suffix, toId + \
suffix);\n        }\n        return new Link(fromId, toId, data, linkId);\n   \
   }\n      function getNodeCount() {\n        return nodes.size;\n      }\n  \
    function getLinkCount() {\n        return links.size;\n      }\n      \
function getLinks(nodeId) {\n        var node = getNode(nodeId);\n        \
return node ? node.links : null;\n      }\n      function removeLink(link, \
otherId) {\n        if (otherId !== void 0) {\n          link = getLink(link, \
otherId);\n        }\n        return removeLinkInstance(link);\n      }\n     \
 function removeLinkInstance(link) {\n        if (!link) {\n          return \
false;\n        }\n        if (!links.get(link.id)) return false;\n        \
enterModification();\n        links.delete(link.id);\n        var fromNode = \
getNode(link.fromId);\n        var toNode = getNode(link.toId);\n        if \
(fromNode) {\n          fromNode.links.delete(link);\n        }\n        if \
(toNode) {\n          toNode.links.delete(link);\n        }\n        \
recordLinkChange(link, \"remove\");\n        exitModification();\n        \
return true;\n      }\n      function getLink(fromNodeId, toNodeId) {\n       \
 if (fromNodeId === void 0 || toNodeId === void 0) return void 0;\n        \
return links.get(makeLinkId(fromNodeId, toNodeId));\n      }\n      function \
clear() {\n        enterModification();\n        forEachNode(function(node) \
{\n          removeNode(node.id);\n        });\n        exitModification();\n \
     }\n      function forEachLink(callback) {\n        if (typeof callback \
=== \"function\") {\n          var valuesIterator = links.values();\n         \
 var nextValue = valuesIterator.next();\n          while (!nextValue.done) \
{\n            if (callback(nextValue.value)) {\n              return true;\n \
           }\n            nextValue = valuesIterator.next();\n          }\n   \
     }\n      }\n      function forEachLinkedNode(nodeId, callback, oriented) \
{\n        var node = getNode(nodeId);\n        if (node && node.links && \
typeof callback === \"function\") {\n          if (oriented) {\n            \
return forEachOrientedLink(node.links, nodeId, callback);\n          } else \
{\n            return forEachNonOrientedLink(node.links, nodeId, callback);\n \
         }\n        }\n      }\n      function forEachNonOrientedLink(links2, \
nodeId, callback) {\n        var quitFast;\n        var valuesIterator = \
links2.values();\n        var nextValue = valuesIterator.next();\n        \
while (!nextValue.done) {\n          var link = nextValue.value;\n          \
var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n        \
  quitFast = callback(nodes.get(linkedNodeId), link);\n          if \
(quitFast) {\n            return true;\n          }\n          nextValue = \
valuesIterator.next();\n        }\n      }\n      function \
forEachOrientedLink(links2, nodeId, callback) {\n        var quitFast;\n      \
  var valuesIterator = links2.values();\n        var nextValue = \
valuesIterator.next();\n        while (!nextValue.done) {\n          var link \
= nextValue.value;\n          if (link.fromId === nodeId) {\n            \
quitFast = callback(nodes.get(link.toId), link);\n            if (quitFast) \
{\n              return true;\n            }\n          }\n          \
nextValue = valuesIterator.next();\n        }\n      }\n      function \
noop2() {\n      }\n      function enterModificationReal() {\n        \
suspendEvents += 1;\n      }\n      function exitModificationReal() {\n       \
 suspendEvents -= 1;\n        if (suspendEvents === 0 && changes.length > 0) \
{\n          graphPart.fire(\"changed\", changes);\n          changes.length \
= 0;\n        }\n      }\n      function forEachNode(callback) {\n        if \
(typeof callback !== \"function\") {\n          throw new Error(\"Function is \
expected to iterate over graph nodes. You passed \" + callback);\n        }\n \
       var valuesIterator = nodes.values();\n        var nextValue = \
valuesIterator.next();\n        while (!nextValue.done) {\n          if \
(callback(nextValue.value)) {\n            return true;\n          }\n        \
  nextValue = valuesIterator.next();\n        }\n      }\n    }\n    function \
Node2(id2, data) {\n      this.id = id2;\n      this.links = null;\n      \
this.data = data;\n    }\n    function addLinkToNode(node, link) {\n      if \
(node.links) {\n        node.links.add(link);\n      } else {\n        \
node.links = /* @__PURE__ */ new Set([link]);\n      }\n    }\n    function \
Link(fromId, toId, data, id2) {\n      this.fromId = fromId;\n      this.toId \
= toId;\n      this.data = data;\n      this.id = id2;\n    }\n    function \
makeLinkId(fromId, toId) {\n      return fromId.toString() + \"\\u{1F449} \" \
+ toId.toString();\n    }\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js\n\
var require_getVariableName = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js\
\"(exports, module) {\n    module.exports = function getVariableName(index5) \
{\n      if (index5 === 0) return \"x\";\n      if (index5 === 1) return \
\"y\";\n      if (index5 === 2) return \"z\";\n      return \"c\" + (index5 + \
1);\n    };\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder\
.js\nvar require_createPatternBuilder = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuild\
er.js\"(exports, module) {\n    var getVariableName = \
require_getVariableName();\n    module.exports = function \
createPatternBuilder(dimension) {\n      return pattern;\n      function \
pattern(template, config) {\n        let indent = config && config.indent || \
0;\n        let join = config && config.join !== void 0 ? config.join : \
\"\\n\";\n        let indentString = Array(indent + 1).join(\" \");\n        \
let buffer2 = [];\n        for (let i = 0; i < dimension; ++i) {\n          \
let variableName = getVariableName(i);\n          let prefix = i === 0 ? \"\" \
: indentString;\n          buffer2.push(prefix + template.replace(/{var}/g, \
variableName));\n        }\n        return buffer2.join(join);\n      }\n    \
};\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody.j\
s\nvar require_generateCreateBody = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody\
.js\"(exports, module) {\n    var createPatternBuilder = \
require_createPatternBuilder();\n    module.exports = \
generateCreateBodyFunction;\n    \
module.exports.generateCreateBodyFunctionBody = \
generateCreateBodyFunctionBody;\n    module.exports.getVectorCode = \
getVectorCode;\n    module.exports.getBodyCode = getBodyCode;\n    function \
generateCreateBodyFunction(dimension, debugSetters) {\n      let code = \
generateCreateBodyFunctionBody(dimension, debugSetters);\n      let { Body } \
= new Function(code)();\n      return Body;\n    }\n    function \
generateCreateBodyFunctionBody(dimension, debugSetters) {\n      let code = \
`\n${getVectorCode(dimension, debugSetters)}\n${getBodyCode(dimension, \
debugSetters)}\nreturn {Body: Body, Vector: Vector};\n`;\n      return \
code;\n    }\n    function getBodyCode(dimension) {\n      let pattern = \
createPatternBuilder(dimension);\n      let variableList = pattern(\"{var}\", \
{ join: \", \" });\n      return `\nfunction Body(${variableList}) {\n  \
this.isPinned = false;\n  this.pos = new Vector(${variableList});\n  \
this.force = new Vector();\n  this.velocity = new Vector();\n  this.mass = \
1;\n\n  this.springCount = 0;\n  this.springLength = \
0;\n}\n\nBody.prototype.reset = function() {\n  this.force.reset();\n  \
this.springCount = 0;\n  this.springLength = \
0;\n}\n\nBody.prototype.setPosition = function (${variableList}) {\n  \
${pattern(\"this.pos.{var} = {var} || 0;\", { indent: 2 })}\n};`;\n    }\n    \
function getVectorCode(dimension, debugSetters) {\n      let pattern = \
createPatternBuilder(dimension);\n      let setters = \"\";\n      if \
(debugSetters) {\n        setters = `${pattern(\"\\n   var \
v{var};\\nObject.defineProperty(this, '{var}', {\\n  set: function(v) { \\n   \
 if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to \
{var}');\\n    v{var} = v; \\n  },\\n  get: function() { return v{var}; \
}\\n});\")}`;\n      }\n      let variableList = pattern(\"{var}\", { join: \
\", \" });\n      return `function Vector(${variableList}) {\n  ${setters}\n  \
  if (typeof arguments[0] === 'object') {\n      // could be another vector\n \
     let v = arguments[0];\n      ${pattern('if (!Number.isFinite(v.{var})) \
throw new Error(\"Expected value is not a finite number at Vector constructor \
({var})\");', { indent: 4 })}\n      ${pattern(\"this.{var} = v.{var};\", { \
indent: 4 })}\n    } else {\n      ${pattern('this.{var} = typeof {var} === \
\"number\" ? {var} : 0;', { indent: 4 })}\n    }\n  }\n  \n  \
Vector.prototype.reset = function () {\n    ${pattern(\"this.{var} = \", { \
join: \"\" })}0;\n  };`;\n    }\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.js\
\nvar require_generateQuadTree = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.j\
s\"(exports, module) {\n    var createPatternBuilder = \
require_createPatternBuilder();\n    var getVariableName = \
require_getVariableName();\n    module.exports = generateQuadTreeFunction;\n  \
  module.exports.generateQuadTreeFunctionBody = \
generateQuadTreeFunctionBody;\n    module.exports.getInsertStackCode = \
getInsertStackCode;\n    module.exports.getQuadNodeCode = getQuadNodeCode;\n  \
  module.exports.isSamePosition = isSamePosition;\n    \
module.exports.getChildBodyCode = getChildBodyCode;\n    \
module.exports.setChildBodyCode = setChildBodyCode;\n    function \
generateQuadTreeFunction(dimension) {\n      let code = \
generateQuadTreeFunctionBody(dimension);\n      return new \
Function(code)();\n    }\n    function \
generateQuadTreeFunctionBody(dimension) {\n      let pattern = \
createPatternBuilder(dimension);\n      let quadCount = Math.pow(2, \
dimension);\n      let code = \
`\n${getInsertStackCode()}\n${getQuadNodeCode(dimension)}\n${isSamePosition(d\
imension)}\n${getChildBodyCode(dimension)}\n${setChildBodyCode(dimension)}\n\
\nfunction createQuadTree(options, random) {\n  options = options || {};\n  \
options.gravity = typeof options.gravity === 'number' ? options.gravity : \
-1;\n  options.theta = typeof options.theta === 'number' ? options.theta : \
0.8;\n\n  var gravity = options.gravity;\n  var updateQueue = [];\n  var \
insertStack = new InsertStack();\n  var theta = options.theta;\n\n  var \
nodesCache = [];\n  var currentInCache = 0;\n  var root = newNode();\n\n  \
return {\n    insertBodies: insertBodies,\n\n    /**\n     * Gets root node \
if it is present\n     */\n    getRoot: function() {\n      return root;\n    \
},\n\n    updateBodyForce: update,\n\n    options: function(newOptions) {\n   \
   if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n \
         gravity = newOptions.gravity;\n        }\n        if (typeof \
newOptions.theta === 'number') {\n          theta = newOptions.theta;\n       \
 }\n\n        return this;\n      }\n\n      return {\n        gravity: \
gravity,\n        theta: theta\n      };\n    }\n  };\n\n  function newNode() \
{\n    // To avoid pressure on GC we reuse nodes.\n    var node = \
nodesCache[currentInCache];\n    if (node) {\n${assignQuads(\"      \
node.\")}\n      node.body = null;\n      node.mass = \
${pattern(\"node.mass_{var} = \", { join: \"\" })}0;\n      \
${pattern(\"node.min_{var} = node.max_{var} = \", { join: \"\" })}0;\n    } \
else {\n      node = new QuadNode();\n      nodesCache[currentInCache] = \
node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function \
update(sourceBody) {\n    var queue = updateQueue;\n    var v;\n    \
${pattern(\"var d{var};\", { indent: 4 })}\n    var r; \n    ${pattern(\"var \
f{var} = 0;\", { indent: 4 })}\n    var queueLength = 1;\n    var shiftIdx = \
0;\n    var pushIdx = 1;\n\n    queue[0] = root;\n\n    while (queueLength) \
{\n      var node = queue[shiftIdx];\n      var body = node.body;\n\n      \
queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = (body !== \
sourceBody);\n      if (body && differentBody) {\n        // If the current \
node is a leaf node (and it is not source body),\n        // calculate the \
force exerted by the current node on body, and add this\n        // amount to \
body's net force.\n        ${pattern(\"d{var} = body.pos.{var} - \
sourceBody.pos.{var};\", { indent: 8 })}\n        r = \
Math.sqrt(${pattern(\"d{var} * d{var}\", { join: \" + \" })});\n\n        if \
(r === 0) {\n          // Poor man's protection against zero distance.\n      \
    ${pattern(\"d{var} = (random.nextDouble() - 0.5) / 50;\", { indent: 10 \
})}\n          r = Math.sqrt(${pattern(\"d{var} * d{var}\", { join: \" + \" \
})});\n        }\n\n        // This is standard gravitation force calculation \
but we divide\n        // by r^3 to save two operations when normalizing \
force vector.\n        v = gravity * body.mass * sourceBody.mass / (r * r * \
r);\n        ${pattern(\"f{var} += v * d{var};\", { indent: 8 })}\n      } \
else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  \
where s is the width of the region\n        // represented by the internal \
node, and r is the distance between the body\n        // and the node's \
center-of-mass\n        ${pattern(\"d{var} = node.mass_{var} / node.mass - \
sourceBody.pos.{var};\", { indent: 8 })}\n        r = \
Math.sqrt(${pattern(\"d{var} * d{var}\", { join: \" + \" })});\n\n        if \
(r === 0) {\n          // Sorry about code duplication. I don't want to \
create many functions\n          // right away. Just want to see performance \
first.\n          ${pattern(\"d{var} = (random.nextDouble() - 0.5) / 50;\", { \
indent: 10 })}\n          r = Math.sqrt(${pattern(\"d{var} * d{var}\", { \
join: \" + \" })});\n        }\n        // If s / r < \\u03B8, treat this \
internal node as a single body, and calculate the\n        // force it exerts \
on sourceBody, and add this amount to sourceBody's net force.\n        if \
((node.max_${getVariableName(0)} - node.min_${getVariableName(0)}) / r < \
theta) {\n          // in the if statement above we consider node's width \
only\n          // because the region was made into square during tree \
creation.\n          // Thus there is no difference between using width or \
height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n \
         ${pattern(\"f{var} += v * d{var};\", { indent: 10 })}\n        } \
else {\n          // Otherwise, run the procedure recursively on each of the \
current node's children.\n\n          // I intentionally unfolded this loop, \
to save several CPU cycles.\n${runRecursiveOnChildren()}\n        }\n      \
}\n    }\n\n    ${pattern(\"sourceBody.force.{var} += f{var};\", { indent: 4 \
})}\n  }\n\n  function insertBodies(bodies) {\n    ${pattern(\"var {var}min = \
Number.MAX_VALUE;\", { indent: 4 })}\n    ${pattern(\"var {var}max = \
Number.MIN_VALUE;\", { indent: 4 })}\n    var i = bodies.length;\n\n    // To \
reduce quad tree depth we are looking for exact bounding box of all \
particles.\n    while (i--) {\n      var pos = bodies[i].pos;\n      \
${pattern(\"if (pos.{var} < {var}min) {var}min = pos.{var};\", { indent: 6 \
})}\n      ${pattern(\"if (pos.{var} > {var}max) {var}max = pos.{var};\", { \
indent: 6 })}\n    }\n\n    // Makes the bounds square.\n    var \
maxSideLength = -Infinity;\n    ${pattern(\"if ({var}max - {var}min > \
maxSideLength) maxSideLength = {var}max - {var}min ;\", { indent: 4 })}\n\n   \
 currentInCache = 0;\n    root = newNode();\n    ${pattern(\"root.min_{var} = \
{var}min;\", { indent: 4 })}\n    ${pattern(\"root.max_{var} = {var}min + \
maxSideLength;\", { indent: 4 })}\n\n    i = bodies.length - 1;\n    if (i >= \
0) {\n      root.body = bodies[i];\n    }\n    while (i--) {\n      \
insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    \
insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while \
(!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop();\n      \
var node = stackItem.node;\n      var body = stackItem.body;\n\n      if \
(!node.body) {\n        // This is internal node. Update the total mass of \
the node and center-of-mass.\n        ${pattern(\"var {var} = \
body.pos.{var};\", { indent: 8 })}\n        node.mass += body.mass;\n        \
${pattern(\"node.mass_{var} += body.mass * {var};\", { indent: 8 })}\n\n      \
  // Recursively insert the body in the appropriate quadrant.\n        // But \
first find the appropriate quadrant.\n        var quadIdx = 0; // Assume we \
are in the 0's quad.\n        ${pattern(\"var min_{var} = node.min_{var};\", \
{ indent: 8 })}\n        ${pattern(\"var max_{var} = (min_{var} + \
node.max_{var}) / 2;\", { indent: 8 })}\n\n${assignInsertionQuadIndex(8)}\n\n \
       var child = getChild(node, quadIdx);\n\n        if (!child) {\n        \
  // The node is internal but this quadrant is not taken. Add\n          // \
subnode to it.\n          child = newNode();\n          \
${pattern(\"child.min_{var} = min_{var};\", { indent: 10 })}\n          \
${pattern(\"child.max_{var} = max_{var};\", { indent: 10 })}\n          \
child.body = body;\n\n          setChild(node, quadIdx, child);\n        } \
else {\n          // continue searching in this quadrant.\n          \
insertStack.push(child, body);\n        }\n      } else {\n        // We are \
trying to add to the leaf node.\n        // We have to convert current leaf \
into internal node\n        // and continue adding two nodes.\n        var \
oldBody = node.body;\n        node.body = null; // internal nodes do not cary \
bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // \
Prevent infinite subdivision by bumping one node\n          // anywhere in \
this quadrant\n          var retriesCount = 3;\n          do {\n            \
var offset = random.nextDouble();\n            ${pattern(\"var d{var} = \
(node.max_{var} - node.min_{var}) * offset;\", { indent: 12 })}\n\n           \
 ${pattern(\"oldBody.pos.{var} = node.min_{var} + d{var};\", { indent: 12 \
})}\n            retriesCount -= 1;\n            // Make sure we don't bump \
it out of the box. If we do, next iteration should fix it\n          } while \
(retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if \
(retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            \
// This is very bad, we ran out of precision.\n            // if we do not \
return from the method we'll get into\n            // infinite loop here. So \
we sacrifice correctness of layout, and keep the app running\n            // \
Next layout iteration should get larger bounding box in the first step and \
fix this\n            return;\n          }\n        }\n        // Next \
iteration should subdivide node further.\n        insertStack.push(node, \
oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  \
}\n}\nreturn createQuadTree;\n\n`;\n      return code;\n      function \
assignInsertionQuadIndex(indentCount) {\n        let insertionCode = [];\n    \
    let indent = Array(indentCount + 1).join(\" \");\n        for (let i = 0; \
i < dimension; ++i) {\n          insertionCode.push(indent + `if \
(${getVariableName(i)} > max_${getVariableName(i)}) {`);\n          \
insertionCode.push(indent + `  quadIdx = quadIdx + ${Math.pow(2, i)};`);\n    \
      insertionCode.push(indent + `  min_${getVariableName(i)} = \
max_${getVariableName(i)};`);\n          insertionCode.push(indent + `  \
max_${getVariableName(i)} = node.max_${getVariableName(i)};`);\n          \
insertionCode.push(indent + `}`);\n        }\n        return \
insertionCode.join(\"\\n\");\n      }\n      function \
runRecursiveOnChildren() {\n        let indent = Array(11).join(\" \");\n     \
   let recursiveCode = [];\n        for (let i = 0; i < quadCount; ++i) {\n   \
       recursiveCode.push(indent + `if (node.quad${i}) {`);\n          \
recursiveCode.push(indent + `  queue[pushIdx] = node.quad${i};`);\n          \
recursiveCode.push(indent + `  queueLength += 1;`);\n          \
recursiveCode.push(indent + `  pushIdx += 1;`);\n          \
recursiveCode.push(indent + `}`);\n        }\n        return \
recursiveCode.join(\"\\n\");\n      }\n      function assignQuads(indent) {\n \
       let quads = [];\n        for (let i = 0; i < quadCount; ++i) {\n       \
   quads.push(`${indent}quad${i} = null;`);\n        }\n        return \
quads.join(\"\\n\");\n      }\n    }\n    function isSamePosition(dimension) \
{\n      let pattern = createPatternBuilder(dimension);\n      return `\n  \
function isSamePosition(point1, point2) {\n    ${pattern(\"var d{var} = \
Math.abs(point1.{var} - point2.{var});\", { indent: 2 })}\n  \n    return \
${pattern(\"d{var} < 1e-8\", { join: \" && \" })};\n  }  \n`;\n    }\n    \
function setChildBodyCode(dimension) {\n      var quadCount = Math.pow(2, \
dimension);\n      return `\nfunction setChild(node, idx, child) {\n  \
${setChildBody()}\n}`;\n      function setChildBody() {\n        let \
childBody = [];\n        for (let i = 0; i < quadCount; ++i) {\n          let \
prefix = i === 0 ? \"  \" : \"  else \";\n          \
childBody.push(`${prefix}if (idx === ${i}) node.quad${i} = child;`);\n        \
}\n        return childBody.join(\"\\n\");\n      }\n    }\n    function \
getChildBodyCode(dimension) {\n      return `function getChild(node, idx) \
{\n${getChildBody()}\n  return null;\n}`;\n      function getChildBody() {\n  \
      let childBody = [];\n        let quadCount = Math.pow(2, dimension);\n  \
      for (let i = 0; i < quadCount; ++i) {\n          childBody.push(`  if \
(idx === ${i}) return node.quad${i};`);\n        }\n        return \
childBody.join(\"\\n\");\n      }\n    }\n    function \
getQuadNodeCode(dimension) {\n      let pattern = \
createPatternBuilder(dimension);\n      let quadCount = Math.pow(2, \
dimension);\n      var quadNodeCode = `\nfunction QuadNode() {\n  // body \
stored inside this node. In quad tree only leaf nodes (by construction)\n  // \
contain bodies:\n  this.body = null;\n\n  // Child nodes are stored in quads. \
Each quad is presented by number:\n  // 0 | 1\n  // -----\n  // 2 | \
3\n${assignQuads(\"  this.\")}\n\n  // Total mass of current node\n  \
this.mass = 0;\n\n  // Center of mass coordinates\n  \
${pattern(\"this.mass_{var} = 0;\", { indent: 2 })}\n\n  // bounding box \
coordinates\n  ${pattern(\"this.min_{var} = 0;\", { indent: 2 })}\n  \
${pattern(\"this.max_{var} = 0;\", { indent: 2 })}\n}\n`;\n      return \
quadNodeCode;\n      function assignQuads(indent) {\n        let quads = \
[];\n        for (let i = 0; i < quadCount; ++i) {\n          \
quads.push(`${indent}quad${i} = null;`);\n        }\n        return \
quads.join(\"\\n\");\n      }\n    }\n    function getInsertStackCode() {\n   \
   return `\n/**\n * Our implementation of QuadTree is non-recursive to avoid \
GC hit\n * This data structure represent stack of elements\n * which we are \
trying to insert into quad tree.\n */\nfunction InsertStack () {\n    \
this.stack = [];\n    this.popIdx = 0;\n}\n\nInsertStack.prototype = {\n    \
isEmpty: function() {\n        return this.popIdx === 0;\n    },\n    push: \
function (node, body) {\n        var item = this.stack[this.popIdx];\n        \
if (!item) {\n            // we are trying to avoid memory pressure: create \
new element\n            // only when absolutely necessary\n            \
this.stack[this.popIdx] = new InsertStackElement(node, body);\n        } else \
{\n            item.node = node;\n            item.body = body;\n        }\n  \
      ++this.popIdx;\n    },\n    pop: function () {\n        if (this.popIdx \
> 0) {\n            return this.stack[--this.popIdx];\n        }\n    },\n    \
reset: function () {\n        this.popIdx = 0;\n    }\n};\n\nfunction \
InsertStackElement(node, body) {\n    this.node = node; // QuadTree node\n    \
this.body = body; // physical body which needs to be inserted to \
node\n}\n`;\n    }\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js\nv\
ar require_generateBounds = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js\
\"(exports, module) {\n    module.exports = generateBoundsFunction;\n    \
module.exports.generateFunctionBody = generateBoundsFunctionBody;\n    var \
createPatternBuilder = require_createPatternBuilder();\n    function \
generateBoundsFunction(dimension) {\n      let code = \
generateBoundsFunctionBody(dimension);\n      return new Function(\"bodies\", \
\"settings\", \"random\", code);\n    }\n    function \
generateBoundsFunctionBody(dimension) {\n      let pattern = \
createPatternBuilder(dimension);\n      let code = `\n  var boundingBox = {\n \
   ${pattern(\"min_{var}: 0, max_{var}: 0,\", { indent: 4 })}\n  };\n\n  \
return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    \
reset: resetBoundingBox,\n\n    getBestNewPosition: function (neighbors) {\n  \
    var ${pattern(\"base_{var} = 0\", { join: \", \" })};\n\n      if \
(neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n  \
        let neighborPos = neighbors[i].pos;\n          ${pattern(\"base_{var} \
+= neighborPos.{var};\", { indent: 10 })}\n        }\n\n        \
${pattern(\"base_{var} /= neighbors.length;\", { indent: 8 })}\n      } else \
{\n        ${pattern(\"base_{var} = (boundingBox.min_{var} + \
boundingBox.max_{var}) / 2;\", { indent: 8 })}\n      }\n\n      var \
springLength = settings.springLength;\n      return {\n        \
${pattern(\"{var}: base_{var} + (random.nextDouble() - 0.5) * \
springLength,\", { indent: 8 })}\n      };\n    }\n  };\n\n  function \
updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) return; \
// No bodies - no borders.\n\n    ${pattern(\"var max_{var} = -Infinity;\", { \
indent: 4 })}\n    ${pattern(\"var min_{var} = Infinity;\", { indent: 4 \
})}\n\n    while(i--) {\n      // this is O(n), it could be done faster with \
quadtree, if we check the root node bounds\n      var bodyPos = \
bodies[i].pos;\n      ${pattern(\"if (bodyPos.{var} < min_{var}) min_{var} = \
bodyPos.{var};\", { indent: 6 })}\n      ${pattern(\"if (bodyPos.{var} > \
max_{var}) max_{var} = bodyPos.{var};\", { indent: 6 })}\n    }\n\n    \
${pattern(\"boundingBox.min_{var} = min_{var};\", { indent: 4 })}\n    \
${pattern(\"boundingBox.max_{var} = max_{var};\", { indent: 4 })}\n  }\n\n  \
function resetBoundingBox() {\n    ${pattern(\"boundingBox.min_{var} = \
boundingBox.max_{var} = 0;\", { indent: 4 })}\n  }\n`;\n      return code;\n  \
  }\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDragFo\
rce.js\nvar require_generateCreateDragForce = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDrag\
Force.js\"(exports, module) {\n    var createPatternBuilder = \
require_createPatternBuilder();\n    module.exports = \
generateCreateDragForceFunction;\n    \
module.exports.generateCreateDragForceFunctionBody = \
generateCreateDragForceFunctionBody;\n    function \
generateCreateDragForceFunction(dimension) {\n      let code = \
generateCreateDragForceFunctionBody(dimension);\n      return new \
Function(\"options\", code);\n    }\n    function \
generateCreateDragForceFunctionBody(dimension) {\n      let pattern = \
createPatternBuilder(dimension);\n      let code = `\n  if \
(!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient \
is not a finite number');\n\n  return {\n    update: function(body) {\n      \
${pattern(\"body.force.{var} -= options.dragCoefficient * \
body.velocity.{var};\", { indent: 6 })}\n    }\n  };\n`;\n      return \
code;\n    }\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpring\
Force.js\nvar require_generateCreateSpringForce = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpri\
ngForce.js\"(exports, module) {\n    var createPatternBuilder = \
require_createPatternBuilder();\n    module.exports = \
generateCreateSpringForceFunction;\n    \
module.exports.generateCreateSpringForceFunctionBody = \
generateCreateSpringForceFunctionBody;\n    function \
generateCreateSpringForceFunction(dimension) {\n      let code = \
generateCreateSpringForceFunctionBody(dimension);\n      return new \
Function(\"options\", \"random\", code);\n    }\n    function \
generateCreateSpringForceFunctionBody(dimension) {\n      let pattern = \
createPatternBuilder(dimension);\n      let code = `\n  if \
(!Number.isFinite(options.springCoefficient)) throw new Error('Spring \
coefficient is not a number');\n  if (!Number.isFinite(options.springLength)) \
throw new Error('Spring length is not a number');\n\n  return {\n    /**\n    \
 * Updates forces acting on a spring\n     */\n    update: function (spring) \
{\n      var body1 = spring.from;\n      var body2 = spring.to;\n      var \
length = spring.length < 0 ? options.springLength : spring.length;\n      \
${pattern(\"var d{var} = body2.pos.{var} - body1.pos.{var};\", { indent: 6 \
})}\n      var r = Math.sqrt(${pattern(\"d{var} * d{var}\", { join: \" + \" \
})});\n\n      if (r === 0) {\n        ${pattern(\"d{var} = \
(random.nextDouble() - 0.5) / 50;\", { indent: 8 })}\n        r = \
Math.sqrt(${pattern(\"d{var} * d{var}\", { join: \" + \" })});\n      }\n\n   \
   var d = r - length;\n      var coefficient = ((spring.coefficient > 0) ? \
spring.coefficient : options.springCoefficient) * d / r;\n\n      \
${pattern(\"body1.force.{var} += coefficient * d{var}\", { indent: 6 })};\n   \
   body1.springCount += 1;\n      body1.springLength += r;\n\n      \
${pattern(\"body2.force.{var} -= coefficient * d{var}\", { indent: 6 })};\n   \
   body2.springCount += 1;\n      body2.springLength += r;\n    }\n  };\n`;\n \
     return code;\n    }\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.j\
s\nvar require_generateIntegrator = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator\
.js\"(exports, module) {\n    var createPatternBuilder = \
require_createPatternBuilder();\n    module.exports = \
generateIntegratorFunction;\n    \
module.exports.generateIntegratorFunctionBody = \
generateIntegratorFunctionBody;\n    function \
generateIntegratorFunction(dimension) {\n      let code = \
generateIntegratorFunctionBody(dimension);\n      return new \
Function(\"bodies\", \"timeStep\", \"adaptiveTimeStepWeight\", code);\n    \
}\n    function generateIntegratorFunctionBody(dimension) {\n      let \
pattern = createPatternBuilder(dimension);\n      let code = `\n  var length \
= bodies.length;\n  if (length === 0) return 0;\n\n  ${pattern(\"var d{var} = \
0, t{var} = 0;\", { indent: 2 })}\n\n  for (var i = 0; i < length; ++i) {\n   \
 var body = bodies[i];\n    if (body.isPinned) continue;\n\n    if \
(adaptiveTimeStepWeight && body.springCount) {\n      timeStep = \
(adaptiveTimeStepWeight * body.springLength/body.springCount);\n    }\n\n    \
var coeff = timeStep / body.mass;\n\n    ${pattern(\"body.velocity.{var} += \
coeff * body.force.{var};\", { indent: 4 })}\n    ${pattern(\"var v{var} = \
body.velocity.{var};\", { indent: 4 })}\n    var v = \
Math.sqrt(${pattern(\"v{var} * v{var}\", { join: \" + \" })});\n\n    if (v > \
1) {\n      // We normalize it so that we move within timeStep range. \n      \
// for the case when v <= 1 - we let velocity to fade out.\n      \
${pattern(\"body.velocity.{var} = v{var} / v;\", { indent: 6 })}\n    }\n\n   \
 ${pattern(\"d{var} = timeStep * body.velocity.{var};\", { indent: 4 })}\n\n  \
  ${pattern(\"body.pos.{var} += d{var};\", { indent: 4 })}\n\n    \
${pattern(\"t{var} += Math.abs(d{var});\", { indent: 4 })}\n  }\n\n  return \
(${pattern(\"t{var} * t{var}\", { join: \" + \" })})/length;\n`;\n      \
return code;\n    }\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/spring.js\nvar require_spring = \
__commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/spring.js\"(exports, module) {\n  \
  module.exports = Spring;\n    function Spring(fromBody, toBody, length2, \
springCoefficient) {\n      this.from = fromBody;\n      this.to = toBody;\n  \
    this.length = length2;\n      this.coefficient = springCoefficient;\n    \
}\n  }\n});\n\n// ../../node_modules/ngraph.merge/index.js\nvar \
require_ngraph3 = __commonJS({\n  \
\"../../node_modules/ngraph.merge/index.js\"(exports, module) {\n    \
module.exports = merge;\n    function merge(target, options) {\n      var \
key;\n      if (!target) {\n        target = {};\n      }\n      if (options) \
{\n        for (key in options) {\n          if (options.hasOwnProperty(key)) \
{\n            var targetHasIt = target.hasOwnProperty(key), optionsValueType \
= typeof options[key], shouldReplace = !targetHasIt || typeof target[key] !== \
optionsValueType;\n            if (shouldReplace) {\n              \
target[key] = options[key];\n            } else if (optionsValueType === \
\"object\") {\n              target[key] = merge(target[key], \
options[key]);\n            }\n          }\n        }\n      }\n      return \
target;\n    }\n  }\n});\n\n// ../../node_modules/ngraph.random/index.js\nvar \
require_ngraph4 = __commonJS({\n  \
\"../../node_modules/ngraph.random/index.js\"(exports, module) {\n    \
module.exports = random;\n    module.exports.random = random, \
module.exports.randomIterator = randomIterator;\n    function \
random(inputSeed) {\n      var seed = typeof inputSeed === \"number\" ? \
inputSeed : +/* @__PURE__ */ new Date();\n      return new Generator(seed);\n \
   }\n    function Generator(seed) {\n      this.seed = seed;\n    }\n    \
Generator.prototype.next = next;\n    Generator.prototype.nextDouble = \
nextDouble;\n    Generator.prototype.uniform = nextDouble;\n    \
Generator.prototype.gaussian = gaussian;\n    function gaussian() {\n      \
var r, x2, y2;\n      do {\n        x2 = this.nextDouble() * 2 - 1;\n        \
y2 = this.nextDouble() * 2 - 1;\n        r = x2 * x2 + y2 * y2;\n      } \
while (r >= 1 || r === 0);\n      return x2 * Math.sqrt(-2 * Math.log(r) / \
r);\n    }\n    Generator.prototype.levy = levy;\n    function levy() {\n     \
 var beta = 3 / 2;\n      var sigma = Math.pow(\n        gamma(1 + beta) * \
Math.sin(Math.PI * beta / 2) / (gamma((1 + beta) / 2) * beta * Math.pow(2, \
(beta - 1) / 2)),\n        1 / beta\n      );\n      return this.gaussian() * \
sigma / Math.pow(Math.abs(this.gaussian()), 1 / beta);\n    }\n    function \
gamma(z2) {\n      return Math.sqrt(2 * Math.PI / z2) * Math.pow(1 / Math.E * \
(z2 + 1 / (12 * z2 - 1 / (10 * z2))), z2);\n    }\n    function nextDouble() \
{\n      var seed = this.seed;\n      seed = seed + 2127912214 + (seed << 12) \
& 4294967295;\n      seed = (seed ^ 3345072700 ^ seed >>> 19) & 4294967295;\n \
     seed = seed + 374761393 + (seed << 5) & 4294967295;\n      seed = (seed \
+ 3550635116 ^ seed << 9) & 4294967295;\n      seed = seed + 4251993797 + \
(seed << 3) & 4294967295;\n      seed = (seed ^ 3042594569 ^ seed >>> 16) & \
4294967295;\n      this.seed = seed;\n      return (seed & 268435455) / \
268435456;\n    }\n    function next(maxValue) {\n      return \
Math.floor(this.nextDouble() * maxValue);\n    }\n    function \
randomIterator(array, customRandom) {\n      var localRandom = customRandom \
|| random();\n      if (typeof localRandom.next !== \"function\") {\n        \
throw new Error(\"customRandom does not match expected API: next() function \
is missing\");\n      }\n      return {\n        forEach,\n        /**\n      \
   * Shuffles array randomly, in place.\n         */\n        shuffle\n      \
};\n      function shuffle() {\n        var i, j, t;\n        for (i = \
array.length - 1; i > 0; --i) {\n          j = localRandom.next(i + 1);\n     \
     t = array[j];\n          array[j] = array[i];\n          array[i] = t;\n \
       }\n        return array;\n      }\n      function forEach(callback) \
{\n        var i, j, t;\n        for (i = array.length - 1; i > 0; --i) {\n   \
       j = localRandom.next(i + 1);\n          t = array[j];\n          \
array[j] = array[i];\n          array[i] = t;\n          callback(t);\n       \
 }\n        if (array.length) {\n          callback(array[0]);\n        }\n   \
   }\n    }\n  }\n});\n\n// \
../../node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js\nvar \
require_createPhysicsSimulator = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js\"(expor\
ts, module) {\n    module.exports = createPhysicsSimulator;\n    var \
generateCreateBodyFunction = require_generateCreateBody();\n    var \
generateQuadTreeFunction = require_generateQuadTree();\n    var \
generateBoundsFunction = require_generateBounds();\n    var \
generateCreateDragForceFunction = require_generateCreateDragForce();\n    var \
generateCreateSpringForceFunction = require_generateCreateSpringForce();\n    \
var generateIntegratorFunction = require_generateIntegrator();\n    var \
dimensionalCache = {};\n    function createPhysicsSimulator(settings) {\n     \
 var Spring = require_spring();\n      var merge = require_ngraph3();\n      \
var eventify = require_ngraph();\n      if (settings) {\n        if \
(settings.springCoeff !== void 0) throw new Error(\"springCoeff was renamed \
to springCoefficient\");\n        if (settings.dragCoeff !== void 0) throw \
new Error(\"dragCoeff was renamed to dragCoefficient\");\n      }\n      \
settings = merge(settings, {\n        /**\n         * Ideal length for links \
(springs in physical model).\n         */\n        springLength: 10,\n        \
/**\n         * Hook's law coefficient. 1 - solid spring.\n         */\n      \
  springCoefficient: 0.8,\n        /**\n         * Coulomb's law coefficient. \
It's used to repel nodes thus should be negative\n         * if you make it \
positive nodes start attract each other :).\n         */\n        gravity: \
-12,\n        /**\n         * Theta coefficient from Barnes Hut simulation. \
Ranged between (0, 1).\n         * The closer it's to 1 the more nodes \
algorithm will have to go through.\n         * Setting it to one makes Barnes \
Hut simulation no different from\n         * brute-force forces calculation \
(each node is considered).\n         */\n        theta: 0.8,\n        /**\n   \
      * Drag force coefficient. Used to slow down system, thus should be less \
than 1.\n         * The closer it is to 0 the less tight system will be.\n    \
     */\n        dragCoefficient: 0.9,\n        // TODO: Need to rename this \
to something better. E.g. `dragCoefficient`\n        /**\n         * Default \
time step (dt) for forces integration\n         */\n        timeStep: 0.5,\n  \
      /**\n         * Adaptive time step uses average spring length to \
compute actual time step:\n         * See: \
https://twitter.com/anvaka/status/1293067160755957760\n         */\n        \
adaptiveTimeStepWeight: 0,\n        /**\n         * This parameter defines \
number of dimensions of the space where simulation\n         * is performed. \
\n         */\n        dimensions: 2,\n        /**\n         * In debug mode \
more checks are performed, this will help you catch errors\n         * \
quickly, however for production build it is recommended to turn off this \
flag\n         * to speed up computation.\n         */\n        debug: \
false\n      });\n      var factory = \
dimensionalCache[settings.dimensions];\n      if (!factory) {\n        var \
dimensions = settings.dimensions;\n        factory = {\n          Body: \
generateCreateBodyFunction(dimensions, settings.debug),\n          \
createQuadTree: generateQuadTreeFunction(dimensions),\n          \
createBounds: generateBoundsFunction(dimensions),\n          createDragForce: \
generateCreateDragForceFunction(dimensions),\n          createSpringForce: \
generateCreateSpringForceFunction(dimensions),\n          integrate: \
generateIntegratorFunction(dimensions)\n        };\n        \
dimensionalCache[dimensions] = factory;\n      }\n      var Body = \
factory.Body;\n      var createQuadTree = factory.createQuadTree;\n      var \
createBounds = factory.createBounds;\n      var createDragForce = \
factory.createDragForce;\n      var createSpringForce = \
factory.createSpringForce;\n      var integrate = factory.integrate;\n      \
var createBody = (pos) => new Body(pos);\n      var random = \
require_ngraph4().random(42);\n      var bodies = [];\n      var springs = \
[];\n      var quadTree = createQuadTree(settings, random);\n      var bounds \
= createBounds(bodies, settings, random);\n      var springForce = \
createSpringForce(settings, random);\n      var dragForce = \
createDragForce(settings);\n      var totalMovement = 0;\n      var forces = \
[];\n      var forceMap = /* @__PURE__ */ new Map();\n      var \
iterationNumber = 0;\n      addForce(\"nbody\", nbodyForce);\n      \
addForce(\"spring\", updateSpringForce);\n      var publicApi = {\n        \
/**\n         * Array of bodies, registered with current simulator\n         \
*\n         * Note: To add new body, use addBody() method. This property is \
only\n         * exposed for testing/performance purposes.\n         */\n     \
   bodies,\n        quadTree,\n        /**\n         * Array of springs, \
registered with current simulator\n         *\n         * Note: To add new \
spring, use addSpring() method. This property is only\n         * exposed for \
testing/performance purposes.\n         */\n        springs,\n        /**\n   \
      * Returns settings with which current simulator was initialized\n       \
  */\n        settings,\n        /**\n         * Adds a new force to \
simulation\n         */\n        addForce,\n        /**\n         * Removes a \
force from the simulation.\n         */\n        removeForce,\n        /**\n  \
       * Returns a map of all registered forces.\n         */\n        \
getForces,\n        /**\n         * Performs one step of force simulation.\n  \
       *\n         * @returns {boolean} true if system is considered stable; \
False otherwise.\n         */\n        step: function() {\n          for (var \
i = 0; i < forces.length; ++i) {\n            forces[i](iterationNumber);\n   \
       }\n          var movement = integrate(bodies, settings.timeStep, \
settings.adaptiveTimeStepWeight);\n          iterationNumber += 1;\n          \
return movement;\n        },\n        /**\n         * Adds body to the \
system\n         *\n         * @param {ngraph.physics.primitives.Body} body \
physical body\n         *\n         * @returns \
{ngraph.physics.primitives.Body} added body\n         */\n        addBody: \
function(body) {\n          if (!body) {\n            throw new Error(\"Body \
is required\");\n          }\n          bodies.push(body);\n          return \
body;\n        },\n        /**\n         * Adds body to the system at given \
position\n         *\n         * @param {Object} pos position of a body\n     \
    *\n         * @returns {ngraph.physics.primitives.Body} added body\n      \
   */\n        addBodyAt: function(pos) {\n          if (!pos) {\n            \
throw new Error(\"Body position is required\");\n          }\n          var \
body = createBody(pos);\n          bodies.push(body);\n          return \
body;\n        },\n        /**\n         * Removes body from the system\n     \
    *\n         * @param {ngraph.physics.primitives.Body} body to remove\n    \
     *\n         * @returns {Boolean} true if body found and removed. falsy \
otherwise;\n         */\n        removeBody: function(body) {\n          if \
(!body) {\n            return;\n          }\n          var idx = \
bodies.indexOf(body);\n          if (idx < 0) {\n            return;\n        \
  }\n          bodies.splice(idx, 1);\n          if (bodies.length === 0) {\n \
           bounds.reset();\n          }\n          return true;\n        },\n \
       /**\n         * Adds a spring to this simulation.\n         *\n        \
 * @returns {Object} - a handle for a spring. If you want to later remove\n   \
      * spring pass it to removeSpring() method.\n         */\n        \
addSpring: function(body1, body2, springLength, springCoefficient) {\n        \
  if (!body1 || !body2) {\n            throw new Error(\"Cannot add null \
spring to force simulator\");\n          }\n          if (typeof springLength \
!== \"number\") {\n            springLength = -1;\n          }\n          var \
spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? \
springCoefficient : -1);\n          springs.push(spring);\n          return \
spring;\n        },\n        /**\n         * Returns amount of movement \
performed on last step() call\n         */\n        getTotalMovement: \
function() {\n          return totalMovement;\n        },\n        /**\n      \
   * Removes spring from the system\n         *\n         * @param {Object} \
spring to remove. Spring is an object returned by addSpring\n         *\n     \
    * @returns {Boolean} true if spring found and removed. falsy otherwise;\n \
        */\n        removeSpring: function(spring) {\n          if (!spring) \
{\n            return;\n          }\n          var idx = \
springs.indexOf(spring);\n          if (idx > -1) {\n            \
springs.splice(idx, 1);\n            return true;\n          }\n        },\n  \
      getBestNewBodyPosition: function(neighbors) {\n          return \
bounds.getBestNewPosition(neighbors);\n        },\n        /**\n         * \
Returns bounding box which covers all bodies\n         */\n        getBBox: \
getBoundingBox,\n        getBoundingBox,\n        invalidateBBox: function() \
{\n          console.warn(\"invalidateBBox() is deprecated, bounds always \
recomputed on `getBBox()` call\");\n        },\n        // TODO: Move the \
force specific stuff to force\n        gravity: function(value) {\n          \
if (value !== void 0) {\n            settings.gravity = value;\n            \
quadTree.options({ gravity: value });\n            return this;\n          } \
else {\n            return settings.gravity;\n          }\n        },\n       \
 theta: function(value) {\n          if (value !== void 0) {\n            \
settings.theta = value;\n            quadTree.options({ theta: value });\n    \
        return this;\n          } else {\n            return \
settings.theta;\n          }\n        },\n        /**\n         * Returns \
pseudo-random number generator instance.\n         */\n        random\n      \
};\n      expose(settings, publicApi);\n      eventify(publicApi);\n      \
return publicApi;\n      function getBoundingBox() {\n        \
bounds.update();\n        return bounds.box;\n      }\n      function \
addForce(forceName, forceFunction) {\n        if (forceMap.has(forceName)) \
throw new Error(\"Force \" + forceName + \" is already added\");\n        \
forceMap.set(forceName, forceFunction);\n        \
forces.push(forceFunction);\n      }\n      function removeForce(forceName) \
{\n        var forceIndex = forces.indexOf(forceMap.get(forceName));\n        \
if (forceIndex < 0) return;\n        forces.splice(forceIndex, 1);\n        \
forceMap.delete(forceName);\n      }\n      function getForces() {\n        \
return forceMap;\n      }\n      function nbodyForce() {\n        if \
(bodies.length === 0) return;\n        quadTree.insertBodies(bodies);\n       \
 var i = bodies.length;\n        while (i--) {\n          var body = \
bodies[i];\n          if (!body.isPinned) {\n            body.reset();\n      \
      quadTree.updateBodyForce(body);\n            dragForce.update(body);\n  \
        }\n        }\n      }\n      function updateSpringForce() {\n        \
var i = springs.length;\n        while (i--) {\n          \
springForce.update(springs[i]);\n        }\n      }\n    }\n    function \
expose(settings, target) {\n      for (var key in settings) {\n        \
augment(settings, target, key);\n      }\n    }\n    function augment(source, \
target, key) {\n      if (!source.hasOwnProperty(key)) return;\n      if \
(typeof target[key] === \"function\") {\n        return;\n      }\n      var \
sourceIsNumber = Number.isFinite(source[key]);\n      if (sourceIsNumber) {\n \
       target[key] = function(value) {\n          if (value !== void 0) {\n   \
         if (!Number.isFinite(value)) throw new Error(\"Value of \" + key + \
\" should be a valid number.\");\n            source[key] = value;\n          \
  return target;\n          }\n          return source[key];\n        };\n    \
  } else {\n        target[key] = function(value) {\n          if (value !== \
void 0) {\n            source[key] = value;\n            return target;\n     \
     }\n          return source[key];\n        };\n      }\n    }\n  \
}\n});\n\n// ../../node_modules/ngraph.forcelayout/index.js\nvar \
require_ngraph5 = __commonJS({\n  \
\"../../node_modules/ngraph.forcelayout/index.js\"(exports, module) {\n    \
module.exports = createLayout;\n    module.exports.simulator = \
require_createPhysicsSimulator();\n    var eventify = require_ngraph();\n    \
function createLayout(graph2, physicsSettings) {\n      if (!graph2) {\n      \
  throw new Error(\"Graph structure cannot be undefined\");\n      }\n      \
var createSimulator = physicsSettings && physicsSettings.createSimulator || \
require_createPhysicsSimulator();\n      var physicsSimulator = \
createSimulator(physicsSettings);\n      if (Array.isArray(physicsSettings)) \
throw new Error(\"Physics settings is expected to be an object\");\n      var \
nodeMass = graph2.version > 19 ? defaultSetNodeMass : defaultArrayNodeMass;\n \
     if (physicsSettings && typeof physicsSettings.nodeMass === \"function\") \
{\n        nodeMass = physicsSettings.nodeMass;\n      }\n      var \
nodeBodies = /* @__PURE__ */ new Map();\n      var springs = {};\n      var \
bodiesCount = 0;\n      var springTransform = \
physicsSimulator.settings.springTransform || noop2;\n      initPhysics();\n   \
   listenToEvents();\n      var wasStable = false;\n      var api = {\n       \
 /**\n         * Performs one step of iterative layout algorithm\n         \
*\n         * @returns {boolean} true if the system should be considered \
stable; False otherwise.\n         * The system is stable if no further call \
to `step()` can improve the layout.\n         */\n        step: function() \
{\n          if (bodiesCount === 0) {\n            \
updateStableStatus(true);\n            return true;\n          }\n          \
var lastMove = physicsSimulator.step();\n          api.lastMove = lastMove;\n \
         api.fire(\"step\");\n          var ratio = lastMove / bodiesCount;\n \
         var isStableNow = ratio <= 0.01;\n          \
updateStableStatus(isStableNow);\n          return isStableNow;\n        },\n \
       /**\n         * For a given `nodeId` returns position\n         */\n   \
     getNodePosition: function(nodeId) {\n          return \
getInitializedBody(nodeId).pos;\n        },\n        /**\n         * Sets \
position of a node to a given coordinates\n         * @param {string} nodeId \
node identifier\n         * @param {number} x position of a node\n         * \
@param {number} y position of a node\n         * @param {number=} z position \
of node (only if applicable to body)\n         */\n        setNodePosition: \
function(nodeId) {\n          var body = getInitializedBody(nodeId);\n        \
  body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n   \
     },\n        /**\n         * @returns {Object} Link position by link id\n \
        * @returns {Object.from} {x, y} coordinates of link start\n         * \
@returns {Object.to} {x, y} coordinates of link end\n         */\n        \
getLinkPosition: function(linkId) {\n          var spring = \
springs[linkId];\n          if (spring) {\n            return {\n             \
 from: spring.from.pos,\n              to: spring.to.pos\n            };\n    \
      }\n        },\n        /**\n         * @returns {Object} area required \
to fit in the graph. Object contains\n         * `x1`, `y1` - top left \
coordinates\n         * `x2`, `y2` - bottom right coordinates\n         */\n  \
      getGraphRect: function() {\n          return \
physicsSimulator.getBBox();\n        },\n        /**\n         * Iterates \
over each body in the layout simulator and performs a callback(body, \
nodeId)\n         */\n        forEachBody,\n        /*\n         * Requests \
layout algorithm to pin/unpin node to its current position\n         * Pinned \
nodes should not be affected by layout algorithm and always\n         * \
remain at their position\n         */\n        pinNode: function(node, \
isPinned) {\n          var body = getInitializedBody(node.id);\n          \
body.isPinned = !!isPinned;\n        },\n        /**\n         * Checks \
whether given graph's node is currently pinned\n         */\n        \
isNodePinned: function(node) {\n          return \
getInitializedBody(node.id).isPinned;\n        },\n        /**\n         * \
Request to release all resources\n         */\n        dispose: function() \
{\n          graph2.off(\"changed\", onGraphChanged);\n          \
api.fire(\"disposed\");\n        },\n        /**\n         * Gets physical \
body for a given node id. If node is not found undefined\n         * value is \
returned.\n         */\n        getBody,\n        /**\n         * Gets spring \
for a given edge.\n         *\n         * @param {string} linkId link \
identifer. If two arguments are passed then\n         * this argument is \
treated as formNodeId\n         * @param {string=} toId when defined this \
parameter denotes head of the link\n         * and first argument is treated \
as tail of the link (fromId)\n         */\n        getSpring,\n        /**\n  \
       * Returns length of cumulative force vector. The closer this to zero - \
the more stable the system is\n         */\n        getForceVectorLength,\n   \
     /**\n         * [Read only] Gets current physics simulator\n         \
*/\n        simulator: physicsSimulator,\n        /**\n         * Gets the \
graph that was used for layout\n         */\n        graph: graph2,\n        \
/**\n         * Gets amount of movement performed during last step \
operation\n         */\n        lastMove: 0\n      };\n      eventify(api);\n \
     return api;\n      function updateStableStatus(isStableNow) {\n        \
if (wasStable !== isStableNow) {\n          wasStable = isStableNow;\n        \
  onStableChanged(isStableNow);\n        }\n      }\n      function \
forEachBody(cb) {\n        nodeBodies.forEach(cb);\n      }\n      function \
getForceVectorLength() {\n        var fx = 0, fy = 0;\n        \
forEachBody(function(body) {\n          fx += Math.abs(body.force.x);\n       \
   fy += Math.abs(body.force.y);\n        });\n        return Math.sqrt(fx * \
fx + fy * fy);\n      }\n      function getSpring(fromId, toId) {\n        \
var linkId;\n        if (toId === void 0) {\n          if (typeof fromId !== \
\"object\") {\n            linkId = fromId;\n          } else {\n            \
linkId = fromId.id;\n          }\n        } else {\n          var link = \
graph2.hasLink(fromId, toId);\n          if (!link) return;\n          linkId \
= link.id;\n        }\n        return springs[linkId];\n      }\n      \
function getBody(nodeId) {\n        return nodeBodies.get(nodeId);\n      }\n \
     function listenToEvents() {\n        graph2.on(\"changed\", \
onGraphChanged);\n      }\n      function onStableChanged(isStable) {\n       \
 api.fire(\"stable\", isStable);\n      }\n      function \
onGraphChanged(changes) {\n        for (var i = 0; i < changes.length; ++i) \
{\n          var change = changes[i];\n          if (change.changeType === \
\"add\") {\n            if (change.node) {\n              \
initBody(change.node.id);\n            }\n            if (change.link) {\n    \
          initLink(change.link);\n            }\n          } else if \
(change.changeType === \"remove\") {\n            if (change.node) {\n        \
      releaseNode(change.node);\n            }\n            if (change.link) \
{\n              releaseLink(change.link);\n            }\n          }\n      \
  }\n        bodiesCount = graph2.getNodesCount();\n      }\n      function \
initPhysics() {\n        bodiesCount = 0;\n        \
graph2.forEachNode(function(node) {\n          initBody(node.id);\n          \
bodiesCount += 1;\n        });\n        graph2.forEachLink(initLink);\n      \
}\n      function initBody(nodeId) {\n        var body = \
nodeBodies.get(nodeId);\n        if (!body) {\n          var node = \
graph2.getNode(nodeId);\n          if (!node) {\n            throw new \
Error(\"initBody() was called with unknown node id\");\n          }\n         \
 var pos = node.position;\n          if (!pos) {\n            var neighbors = \
getNeighborBodies(node);\n            pos = \
physicsSimulator.getBestNewBodyPosition(neighbors);\n          }\n          \
body = physicsSimulator.addBodyAt(pos);\n          body.id = nodeId;\n        \
  nodeBodies.set(nodeId, body);\n          updateBodyMass(nodeId);\n          \
if (isNodeOriginallyPinned(node)) {\n            body.isPinned = true;\n      \
    }\n        }\n      }\n      function releaseNode(node) {\n        var \
nodeId = node.id;\n        var body = nodeBodies.get(nodeId);\n        if \
(body) {\n          nodeBodies.delete(nodeId);\n          \
physicsSimulator.removeBody(body);\n        }\n      }\n      function \
initLink(link) {\n        updateBodyMass(link.fromId);\n        \
updateBodyMass(link.toId);\n        var fromBody = \
nodeBodies.get(link.fromId), toBody = nodeBodies.get(link.toId), spring = \
physicsSimulator.addSpring(fromBody, toBody, link.length);\n        \
springTransform(link, spring);\n        springs[link.id] = spring;\n      }\n \
     function releaseLink(link) {\n        var spring = springs[link.id];\n   \
     if (spring) {\n          var from = graph2.getNode(link.fromId), to = \
graph2.getNode(link.toId);\n          if (from) updateBodyMass(from.id);\n    \
      if (to) updateBodyMass(to.id);\n          delete springs[link.id];\n    \
      physicsSimulator.removeSpring(spring);\n        }\n      }\n      \
function getNeighborBodies(node) {\n        var neighbors = [];\n        if \
(!node.links) {\n          return neighbors;\n        }\n        var \
maxNeighbors = Math.min(node.links.length, 2);\n        for (var i = 0; i < \
maxNeighbors; ++i) {\n          var link = node.links[i];\n          var \
otherBody = link.fromId !== node.id ? nodeBodies.get(link.fromId) : \
nodeBodies.get(link.toId);\n          if (otherBody && otherBody.pos) {\n     \
       neighbors.push(otherBody);\n          }\n        }\n        return \
neighbors;\n      }\n      function updateBodyMass(nodeId) {\n        var \
body = nodeBodies.get(nodeId);\n        body.mass = nodeMass(nodeId);\n       \
 if (Number.isNaN(body.mass)) {\n          throw new Error(\"Node mass should \
be a number\");\n        }\n      }\n      function \
isNodeOriginallyPinned(node) {\n        return node && (node.isPinned || \
node.data && node.data.isPinned);\n      }\n      function \
getInitializedBody(nodeId) {\n        var body = nodeBodies.get(nodeId);\n    \
    if (!body) {\n          initBody(nodeId);\n          body = \
nodeBodies.get(nodeId);\n        }\n        return body;\n      }\n      \
function defaultArrayNodeMass(nodeId) {\n        var links = \
graph2.getLinks(nodeId);\n        if (!links) return 1;\n        return 1 + \
links.length / 3;\n      }\n      function defaultSetNodeMass(nodeId) {\n     \
   var links = graph2.getLinks(nodeId);\n        if (!links) return 1;\n      \
  return 1 + links.size / 3;\n      }\n    }\n    function noop2() {\n    }\n \
 }\n});\n\n// ../../node_modules/three/build/three.module.js\nvar REVISION = \
\"170\";\nvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, \
PAN: 2 };\nvar TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 \
};\nvar CullFaceNone = 0;\nvar CullFaceBack = 1;\nvar CullFaceFront = 2;\nvar \
PCFShadowMap = 1;\nvar PCFSoftShadowMap = 2;\nvar VSMShadowMap = 3;\nvar \
FrontSide = 0;\nvar BackSide = 1;\nvar DoubleSide = 2;\nvar NoBlending = \
0;\nvar NormalBlending = 1;\nvar AdditiveBlending = 2;\nvar \
SubtractiveBlending = 3;\nvar MultiplyBlending = 4;\nvar CustomBlending = \
5;\nvar AddEquation = 100;\nvar SubtractEquation = 101;\nvar \
ReverseSubtractEquation = 102;\nvar MinEquation = 103;\nvar MaxEquation = \
104;\nvar ZeroFactor = 200;\nvar OneFactor = 201;\nvar SrcColorFactor = \
202;\nvar OneMinusSrcColorFactor = 203;\nvar SrcAlphaFactor = 204;\nvar \
OneMinusSrcAlphaFactor = 205;\nvar DstAlphaFactor = 206;\nvar \
OneMinusDstAlphaFactor = 207;\nvar DstColorFactor = 208;\nvar \
OneMinusDstColorFactor = 209;\nvar SrcAlphaSaturateFactor = 210;\nvar \
ConstantColorFactor = 211;\nvar OneMinusConstantColorFactor = 212;\nvar \
ConstantAlphaFactor = 213;\nvar OneMinusConstantAlphaFactor = 214;\nvar \
NeverDepth = 0;\nvar AlwaysDepth = 1;\nvar LessDepth = 2;\nvar LessEqualDepth \
= 3;\nvar EqualDepth = 4;\nvar GreaterEqualDepth = 5;\nvar GreaterDepth = \
6;\nvar NotEqualDepth = 7;\nvar MultiplyOperation = 0;\nvar MixOperation = \
1;\nvar AddOperation = 2;\nvar NoToneMapping = 0;\nvar LinearToneMapping = \
1;\nvar ReinhardToneMapping = 2;\nvar CineonToneMapping = 3;\nvar \
ACESFilmicToneMapping = 4;\nvar CustomToneMapping = 5;\nvar AgXToneMapping = \
6;\nvar NeutralToneMapping = 7;\nvar UVMapping = 300;\nvar \
CubeReflectionMapping = 301;\nvar CubeRefractionMapping = 302;\nvar \
EquirectangularReflectionMapping = 303;\nvar EquirectangularRefractionMapping \
= 304;\nvar CubeUVReflectionMapping = 306;\nvar RepeatWrapping = 1e3;\nvar \
ClampToEdgeWrapping = 1001;\nvar MirroredRepeatWrapping = 1002;\nvar \
NearestFilter = 1003;\nvar NearestMipmapNearestFilter = 1004;\nvar \
NearestMipmapLinearFilter = 1005;\nvar LinearFilter = 1006;\nvar \
LinearMipmapNearestFilter = 1007;\nvar LinearMipmapLinearFilter = 1008;\nvar \
UnsignedByteType = 1009;\nvar ByteType = 1010;\nvar ShortType = 1011;\nvar \
UnsignedShortType = 1012;\nvar IntType = 1013;\nvar UnsignedIntType = \
1014;\nvar FloatType = 1015;\nvar HalfFloatType = 1016;\nvar \
UnsignedShort4444Type = 1017;\nvar UnsignedShort5551Type = 1018;\nvar \
UnsignedInt248Type = 1020;\nvar UnsignedInt5999Type = 35902;\nvar AlphaFormat \
= 1021;\nvar RGBFormat = 1022;\nvar RGBAFormat = 1023;\nvar LuminanceFormat = \
1024;\nvar LuminanceAlphaFormat = 1025;\nvar DepthFormat = 1026;\nvar \
DepthStencilFormat = 1027;\nvar RedFormat = 1028;\nvar RedIntegerFormat = \
1029;\nvar RGFormat = 1030;\nvar RGIntegerFormat = 1031;\nvar \
RGBAIntegerFormat = 1033;\nvar RGB_S3TC_DXT1_Format = 33776;\nvar \
RGBA_S3TC_DXT1_Format = 33777;\nvar RGBA_S3TC_DXT3_Format = 33778;\nvar \
RGBA_S3TC_DXT5_Format = 33779;\nvar RGB_PVRTC_4BPPV1_Format = 35840;\nvar \
RGB_PVRTC_2BPPV1_Format = 35841;\nvar RGBA_PVRTC_4BPPV1_Format = 35842;\nvar \
RGBA_PVRTC_2BPPV1_Format = 35843;\nvar RGB_ETC1_Format = 36196;\nvar \
RGB_ETC2_Format = 37492;\nvar RGBA_ETC2_EAC_Format = 37496;\nvar \
RGBA_ASTC_4x4_Format = 37808;\nvar RGBA_ASTC_5x4_Format = 37809;\nvar \
RGBA_ASTC_5x5_Format = 37810;\nvar RGBA_ASTC_6x5_Format = 37811;\nvar \
RGBA_ASTC_6x6_Format = 37812;\nvar RGBA_ASTC_8x5_Format = 37813;\nvar \
RGBA_ASTC_8x6_Format = 37814;\nvar RGBA_ASTC_8x8_Format = 37815;\nvar \
RGBA_ASTC_10x5_Format = 37816;\nvar RGBA_ASTC_10x6_Format = 37817;\nvar \
RGBA_ASTC_10x8_Format = 37818;\nvar RGBA_ASTC_10x10_Format = 37819;\nvar \
RGBA_ASTC_12x10_Format = 37820;\nvar RGBA_ASTC_12x12_Format = 37821;\nvar \
RGBA_BPTC_Format = 36492;\nvar RGB_BPTC_SIGNED_Format = 36494;\nvar \
RGB_BPTC_UNSIGNED_Format = 36495;\nvar RED_RGTC1_Format = 36283;\nvar \
SIGNED_RED_RGTC1_Format = 36284;\nvar RED_GREEN_RGTC2_Format = 36285;\nvar \
SIGNED_RED_GREEN_RGTC2_Format = 36286;\nvar InterpolateDiscrete = 2300;\nvar \
InterpolateLinear = 2301;\nvar InterpolateSmooth = 2302;\nvar \
ZeroCurvatureEnding = 2400;\nvar ZeroSlopeEnding = 2401;\nvar \
WrapAroundEnding = 2402;\nvar BasicDepthPacking = 3200;\nvar RGBADepthPacking \
= 3201;\nvar TangentSpaceNormalMap = 0;\nvar ObjectSpaceNormalMap = 1;\nvar \
NoColorSpace = \"\";\nvar SRGBColorSpace = \"srgb\";\nvar \
LinearSRGBColorSpace = \"srgb-linear\";\nvar LinearTransfer = \
\"linear\";\nvar SRGBTransfer = \"srgb\";\nvar KeepStencilOp = 7680;\nvar \
AlwaysStencilFunc = 519;\nvar NeverCompare = 512;\nvar LessCompare = \
513;\nvar EqualCompare = 514;\nvar LessEqualCompare = 515;\nvar \
GreaterCompare = 516;\nvar NotEqualCompare = 517;\nvar GreaterEqualCompare = \
518;\nvar AlwaysCompare = 519;\nvar StaticDrawUsage = 35044;\nvar GLSL3 = \
\"300 es\";\nvar WebGLCoordinateSystem = 2e3;\nvar WebGPUCoordinateSystem = \
2001;\nvar EventDispatcher = class {\n  addEventListener(type, listener) {\n  \
  if (this._listeners === void 0) this._listeners = {};\n    const listeners \
= this._listeners;\n    if (listeners[type] === void 0) {\n      \
listeners[type] = [];\n    }\n    if (listeners[type].indexOf(listener) === \
-1) {\n      listeners[type].push(listener);\n    }\n  }\n  \
hasEventListener(type, listener) {\n    if (this._listeners === void 0) \
return false;\n    const listeners = this._listeners;\n    return \
listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n  \
}\n  removeEventListener(type, listener) {\n    if (this._listeners === void \
0) return;\n    const listeners = this._listeners;\n    const listenerArray = \
listeners[type];\n    if (listenerArray !== void 0) {\n      const index5 = \
listenerArray.indexOf(listener);\n      if (index5 !== -1) {\n        \
listenerArray.splice(index5, 1);\n      }\n    }\n  }\n  dispatchEvent(event) \
{\n    if (this._listeners === void 0) return;\n    const listeners = \
this._listeners;\n    const listenerArray = listeners[event.type];\n    if \
(listenerArray !== void 0) {\n      event.target = this;\n      const array = \
listenerArray.slice(0);\n      for (let i = 0, l = array.length; i < l; i++) \
{\n        array[i].call(this, event);\n      }\n      event.target = null;\n \
   }\n  }\n};\nvar _lut = [\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \
\"06\", \"07\", \"08\", \"09\", \"0a\", \"0b\", \"0c\", \"0d\", \"0e\", \
\"0f\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \
\"18\", \"19\", \"1a\", \"1b\", \"1c\", \"1d\", \"1e\", \"1f\", \"20\", \
\"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \
\"2a\", \"2b\", \"2c\", \"2d\", \"2e\", \"2f\", \"30\", \"31\", \"32\", \
\"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3a\", \"3b\", \
\"3c\", \"3d\", \"3e\", \"3f\", \"40\", \"41\", \"42\", \"43\", \"44\", \
\"45\", \"46\", \"47\", \"48\", \"49\", \"4a\", \"4b\", \"4c\", \"4d\", \
\"4e\", \"4f\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \
\"57\", \"58\", \"59\", \"5a\", \"5b\", \"5c\", \"5d\", \"5e\", \"5f\", \
\"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \
\"69\", \"6a\", \"6b\", \"6c\", \"6d\", \"6e\", \"6f\", \"70\", \"71\", \
\"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7a\", \
\"7b\", \"7c\", \"7d\", \"7e\", \"7f\", \"80\", \"81\", \"82\", \"83\", \
\"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8a\", \"8b\", \"8c\", \
\"8d\", \"8e\", \"8f\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \
\"96\", \"97\", \"98\", \"99\", \"9a\", \"9b\", \"9c\", \"9d\", \"9e\", \
\"9f\", \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"a7\", \
\"a8\", \"a9\", \"aa\", \"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"b0\", \
\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\", \"b9\", \
\"ba\", \"bb\", \"bc\", \"bd\", \"be\", \"bf\", \"c0\", \"c1\", \"c2\", \
\"c3\", \"c4\", \"c5\", \"c6\", \"c7\", \"c8\", \"c9\", \"ca\", \"cb\", \
\"cc\", \"cd\", \"ce\", \"cf\", \"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \
\"d5\", \"d6\", \"d7\", \"d8\", \"d9\", \"da\", \"db\", \"dc\", \"dd\", \
\"de\", \"df\", \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \
\"e7\", \"e8\", \"e9\", \"ea\", \"eb\", \"ec\", \"ed\", \"ee\", \"ef\", \
\"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \
\"f9\", \"fa\", \"fb\", \"fc\", \"fd\", \"fe\", \"ff\"];\nvar _seed = \
1234567;\nvar DEG2RAD = Math.PI / 180;\nvar RAD2DEG = 180 / \
Math.PI;\nfunction generateUUID() {\n  const d0 = Math.random() * 4294967295 \
| 0;\n  const d1 = Math.random() * 4294967295 | 0;\n  const d2 = \
Math.random() * 4294967295 | 0;\n  const d3 = Math.random() * 4294967295 | \
0;\n  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & \
255] + _lut[d0 >> 24 & 255] + \"-\" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + \
\"-\" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + \"-\" + _lut[d2 & \
63 | 128] + _lut[d2 >> 8 & 255] + \"-\" + _lut[d2 >> 16 & 255] + _lut[d2 >> \
24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + \
_lut[d3 >> 24 & 255];\n  return uuid.toLowerCase();\n}\nfunction clamp(value, \
min2, max2) {\n  return Math.max(min2, Math.min(max2, value));\n}\nfunction \
euclideanModulo(n, m2) {\n  return (n % m2 + m2) % m2;\n}\nfunction \
mapLinear(x2, a1, a2, b1, b2) {\n  return b1 + (x2 - a1) * (b2 - b1) / (a2 - \
a1);\n}\nfunction inverseLerp(x2, y2, value) {\n  if (x2 !== y2) {\n    \
return (value - x2) / (y2 - x2);\n  } else {\n    return 0;\n  }\n}\nfunction \
lerp(x2, y2, t) {\n  return (1 - t) * x2 + t * y2;\n}\nfunction damp(x2, y2, \
lambda, dt) {\n  return lerp(x2, y2, 1 - Math.exp(-lambda * \
dt));\n}\nfunction pingpong(x2, length2 = 1) {\n  return length2 - \
Math.abs(euclideanModulo(x2, length2 * 2) - length2);\n}\nfunction \
smoothstep(x2, min2, max2) {\n  if (x2 <= min2) return 0;\n  if (x2 >= max2) \
return 1;\n  x2 = (x2 - min2) / (max2 - min2);\n  return x2 * x2 * (3 - 2 * \
x2);\n}\nfunction smootherstep(x2, min2, max2) {\n  if (x2 <= min2) return \
0;\n  if (x2 >= max2) return 1;\n  x2 = (x2 - min2) / (max2 - min2);\n  \
return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);\n}\nfunction randInt(low, \
high) {\n  return low + Math.floor(Math.random() * (high - low + \
1));\n}\nfunction randFloat(low, high) {\n  return low + Math.random() * \
(high - low);\n}\nfunction randFloatSpread(range) {\n  return range * (0.5 - \
Math.random());\n}\nfunction seededRandom(s) {\n  if (s !== void 0) _seed = \
s;\n  let t = _seed += 1831565813;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  \
t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / \
4294967296;\n}\nfunction degToRad(degrees2) {\n  return degrees2 * \
DEG2RAD;\n}\nfunction radToDeg(radians2) {\n  return radians2 * \
RAD2DEG;\n}\nfunction isPowerOfTwo(value) {\n  return (value & value - 1) === \
0 && value !== 0;\n}\nfunction ceilPowerOfTwo(value) {\n  return Math.pow(2, \
Math.ceil(Math.log(value) / Math.LN2));\n}\nfunction floorPowerOfTwo(value) \
{\n  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\nfunction \
setQuaternionFromProperEuler(q, a2, b, c2, order) {\n  const cos2 = \
Math.cos;\n  const sin2 = Math.sin;\n  const c22 = cos2(b / 2);\n  const s2 = \
sin2(b / 2);\n  const c13 = cos2((a2 + c2) / 2);\n  const s13 = sin2((a2 + \
c2) / 2);\n  const c1_3 = cos2((a2 - c2) / 2);\n  const s1_3 = sin2((a2 - c2) \
/ 2);\n  const c3_1 = cos2((c2 - a2) / 2);\n  const s3_1 = sin2((c2 - a2) / \
2);\n  switch (order) {\n    case \"XYX\":\n      q.set(c22 * s13, s2 * c1_3, \
s2 * s1_3, c22 * c13);\n      break;\n    case \"YZY\":\n      q.set(s2 * \
s1_3, c22 * s13, s2 * c1_3, c22 * c13);\n      break;\n    case \"ZXZ\":\n    \
  q.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);\n      break;\n    case \
\"XZX\":\n      q.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);\n      \
break;\n    case \"YXY\":\n      q.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * \
c13);\n      break;\n    case \"ZYZ\":\n      q.set(s2 * s3_1, s2 * c3_1, c22 \
* s13, c22 * c13);\n      break;\n    default:\n      \
console.warn(\"THREE.MathUtils: .setQuaternionFromProperEuler() encountered \
an unknown order: \" + order);\n  }\n}\nfunction denormalize(value, array) \
{\n  switch (array.constructor) {\n    case Float32Array:\n      return \
value;\n    case Uint32Array:\n      return value / 4294967295;\n    case \
Uint16Array:\n      return value / 65535;\n    case Uint8Array:\n      return \
value / 255;\n    case Int32Array:\n      return Math.max(value / 2147483647, \
-1);\n    case Int16Array:\n      return Math.max(value / 32767, -1);\n    \
case Int8Array:\n      return Math.max(value / 127, -1);\n    default:\n      \
throw new Error(\"Invalid component type.\");\n  }\n}\nfunction \
normalize(value, array) {\n  switch (array.constructor) {\n    case \
Float32Array:\n      return value;\n    case Uint32Array:\n      return \
Math.round(value * 4294967295);\n    case Uint16Array:\n      return \
Math.round(value * 65535);\n    case Uint8Array:\n      return \
Math.round(value * 255);\n    case Int32Array:\n      return Math.round(value \
* 2147483647);\n    case Int16Array:\n      return Math.round(value * \
32767);\n    case Int8Array:\n      return Math.round(value * 127);\n    \
default:\n      throw new Error(\"Invalid component type.\");\n  }\n}\nvar \
MathUtils = {\n  DEG2RAD,\n  RAD2DEG,\n  generateUUID,\n  clamp,\n  \
euclideanModulo,\n  mapLinear,\n  inverseLerp,\n  lerp,\n  damp,\n  \
pingpong,\n  smoothstep,\n  smootherstep,\n  randInt,\n  randFloat,\n  \
randFloatSpread,\n  seededRandom,\n  degToRad,\n  radToDeg,\n  \
isPowerOfTwo,\n  ceilPowerOfTwo,\n  floorPowerOfTwo,\n  \
setQuaternionFromProperEuler,\n  normalize,\n  denormalize\n};\nvar Vector2 = \
class _Vector2 {\n  constructor(x2 = 0, y2 = 0) {\n    \
_Vector2.prototype.isVector2 = true;\n    this.x = x2;\n    this.y = y2;\n  \
}\n  get width() {\n    return this.x;\n  }\n  set width(value) {\n    this.x \
= value;\n  }\n  get height() {\n    return this.y;\n  }\n  set height(value) \
{\n    this.y = value;\n  }\n  set(x2, y2) {\n    this.x = x2;\n    this.y = \
y2;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    \
this.y = scalar;\n    return this;\n  }\n  setX(x2) {\n    this.x = x2;\n    \
return this;\n  }\n  setY(y2) {\n    this.y = y2;\n    return this;\n  }\n  \
setComponent(index5, value) {\n    switch (index5) {\n      case 0:\n        \
this.x = value;\n        break;\n      case 1:\n        this.y = value;\n     \
   break;\n      default:\n        throw new Error(\"index is out of range: \
\" + index5);\n    }\n    return this;\n  }\n  getComponent(index5) {\n    \
switch (index5) {\n      case 0:\n        return this.x;\n      case 1:\n     \
   return this.y;\n      default:\n        throw new Error(\"index is out of \
range: \" + index5);\n    }\n  }\n  clone() {\n    return new \
this.constructor(this.x, this.y);\n  }\n  copy(v) {\n    this.x = v.x;\n    \
this.y = v.y;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    \
this.y += v.y;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n   \
 this.y += s;\n    return this;\n  }\n  addVectors(a2, b) {\n    this.x = \
a2.x + b.x;\n    this.y = a2.y + b.y;\n    return this;\n  }\n  \
addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    \
return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    \
return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    \
return this;\n  }\n  subVectors(a2, b) {\n    this.x = a2.x - b.x;\n    \
this.y = a2.y - b.y;\n    return this;\n  }\n  multiply(v) {\n    this.x *= \
v.x;\n    this.y *= v.y;\n    return this;\n  }\n  multiplyScalar(scalar) {\n \
   this.x *= scalar;\n    this.y *= scalar;\n    return this;\n  }\n  \
divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    return this;\n  }\n  \
divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  \
applyMatrix3(m2) {\n    const x2 = this.x, y2 = this.y;\n    const e = \
m2.elements;\n    this.x = e[0] * x2 + e[3] * y2 + e[6];\n    this.y = e[1] * \
x2 + e[4] * y2 + e[7];\n    return this;\n  }\n  min(v) {\n    this.x = \
Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    return \
this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = \
Math.max(this.y, v.y);\n    return this;\n  }\n  clamp(min2, max2) {\n    \
this.x = Math.max(min2.x, Math.min(max2.x, this.x));\n    this.y = \
Math.max(min2.y, Math.min(max2.y, this.y));\n    return this;\n  }\n  \
clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, \
this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    \
return this;\n  }\n  clampLength(min2, max2) {\n    const length2 = \
this.length();\n    return this.divideScalar(length2 || \
1).multiplyScalar(Math.max(min2, Math.min(max2, length2)));\n  }\n  floor() \
{\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    \
return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = \
Math.ceil(this.y);\n    return this;\n  }\n  round() {\n    this.x = \
Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  \
}\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = \
Math.trunc(this.y);\n    return this;\n  }\n  negate() {\n    this.x = \
-this.x;\n    this.y = -this.y;\n    return this;\n  }\n  dot(v) {\n    \
return this.x * v.x + this.y * v.y;\n  }\n  cross(v) {\n    return this.x * \
v.y - this.y * v.x;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y \
* this.y;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * \
this.y);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + \
Math.abs(this.y);\n  }\n  normalize() {\n    return \
this.divideScalar(this.length() || 1);\n  }\n  angle() {\n    const angle = \
Math.atan2(-this.y, -this.x) + Math.PI;\n    return angle;\n  }\n  angleTo(v) \
{\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if \
(denominator === 0) return Math.PI / 2;\n    const theta = this.dot(v) / \
denominator;\n    return Math.acos(clamp(theta, -1, 1));\n  }\n  \
distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  \
distanceToSquared(v) {\n    const dx = this.x - v.x, dy = this.y - v.y;\n    \
return dx * dx + dy * dy;\n  }\n  manhattanDistanceTo(v) {\n    return \
Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n  }\n  setLength(length2) \
{\n    return this.normalize().multiplyScalar(length2);\n  }\n  lerp(v, \
alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) \
* alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = \
v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n   \
 return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === \
this.y;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n \
   this.y = array[offset + 1];\n    return this;\n  }\n  toArray(array = [], \
offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n \
   return array;\n  }\n  fromBufferAttribute(attribute2, index5) {\n    \
this.x = attribute2.getX(index5);\n    this.y = attribute2.getY(index5);\n    \
return this;\n  }\n  rotateAround(center, angle) {\n    const c2 = \
Math.cos(angle), s = Math.sin(angle);\n    const x2 = this.x - center.x;\n    \
const y2 = this.y - center.y;\n    this.x = x2 * c2 - y2 * s + center.x;\n    \
this.y = x2 * s + y2 * c2 + center.y;\n    return this;\n  }\n  random() {\n  \
  this.x = Math.random();\n    this.y = Math.random();\n    return this;\n  \
}\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n  \
}\n};\nvar Matrix3 = class _Matrix3 {\n  constructor(n11, n12, n13, n21, n22, \
n23, n31, n32, n33) {\n    _Matrix3.prototype.isMatrix3 = true;\n    \
this.elements = [\n      1,\n      0,\n      0,\n      0,\n      1,\n      \
0,\n      0,\n      0,\n      1\n    ];\n    if (n11 !== void 0) {\n      \
this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n    }\n  }\n  \
set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    const te = \
this.elements;\n    te[0] = n11;\n    te[1] = n21;\n    te[2] = n31;\n    \
te[3] = n12;\n    te[4] = n22;\n    te[5] = n32;\n    te[6] = n13;\n    te[7] \
= n23;\n    te[8] = n33;\n    return this;\n  }\n  identity() {\n    \
this.set(\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      \
0,\n      0,\n      1\n    );\n    return this;\n  }\n  copy(m2) {\n    const \
te = this.elements;\n    const me = m2.elements;\n    te[0] = me[0];\n    \
te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n  \
  te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = \
me[8];\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    \
xAxis.setFromMatrix3Column(this, 0);\n    yAxis.setFromMatrix3Column(this, \
1);\n    zAxis.setFromMatrix3Column(this, 2);\n    return this;\n  }\n  \
setFromMatrix4(m2) {\n    const me = m2.elements;\n    this.set(\n      \
me[0],\n      me[4],\n      me[8],\n      me[1],\n      me[5],\n      \
me[9],\n      me[2],\n      me[6],\n      me[10]\n    );\n    return this;\n  \
}\n  multiply(m2) {\n    return this.multiplyMatrices(this, m2);\n  }\n  \
premultiply(m2) {\n    return this.multiplyMatrices(m2, this);\n  }\n  \
multiplyMatrices(a2, b) {\n    const ae = a2.elements;\n    const be = \
b.elements;\n    const te = this.elements;\n    const a11 = ae[0], a12 = \
ae[3], a13 = ae[6];\n    const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n    \
const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n    const b11 = be[0], b12 = \
be[3], b13 = be[6];\n    const b21 = be[1], b22 = be[4], b23 = be[7];\n    \
const b31 = be[2], b32 = be[5], b33 = be[8];\n    te[0] = a11 * b11 + a12 * \
b21 + a13 * b31;\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n    te[6] = \
a11 * b13 + a12 * b23 + a13 * b33;\n    te[1] = a21 * b11 + a22 * b21 + a23 * \
b31;\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n    te[7] = a21 * b13 + \
a22 * b23 + a23 * b33;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n    \
te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n    te[8] = a31 * b13 + a32 * b23 \
+ a33 * b33;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = \
this.elements;\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] \
*= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n   \
 te[8] *= s;\n    return this;\n  }\n  determinant() {\n    const te = \
this.elements;\n    const a2 = te[0], b = te[1], c2 = te[2], d = te[3], e = \
te[4], f = te[5], g = te[6], h = te[7], i = te[8];\n    return a2 * e * i - \
a2 * f * h - b * d * i + b * f * g + c2 * d * h - c2 * e * g;\n  }\n  \
invert() {\n    const te = this.elements, n11 = te[0], n21 = te[1], n31 = \
te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = \
te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * \
n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n    if (det === 0) \
return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    \
te[0] = t11 * detInv;\n    te[1] = (n31 * n23 - n33 * n21) * detInv;\n    \
te[2] = (n32 * n21 - n31 * n22) * detInv;\n    te[3] = t12 * detInv;\n    \
te[4] = (n33 * n11 - n31 * n13) * detInv;\n    te[5] = (n31 * n12 - n32 * \
n11) * detInv;\n    te[6] = t13 * detInv;\n    te[7] = (n21 * n13 - n23 * \
n11) * detInv;\n    te[8] = (n22 * n11 - n21 * n12) * detInv;\n    return \
this;\n  }\n  transpose() {\n    let tmp2;\n    const m2 = this.elements;\n   \
 tmp2 = m2[1];\n    m2[1] = m2[3];\n    m2[3] = tmp2;\n    tmp2 = m2[2];\n    \
m2[2] = m2[6];\n    m2[6] = tmp2;\n    tmp2 = m2[5];\n    m2[5] = m2[7];\n    \
m2[7] = tmp2;\n    return this;\n  }\n  getNormalMatrix(matrix4) {\n    \
return this.setFromMatrix4(matrix4).invert().transpose();\n  }\n  \
transposeIntoArray(r) {\n    const m2 = this.elements;\n    r[0] = m2[0];\n   \
 r[1] = m2[3];\n    r[2] = m2[6];\n    r[3] = m2[1];\n    r[4] = m2[4];\n    \
r[5] = m2[7];\n    r[6] = m2[2];\n    r[7] = m2[5];\n    r[8] = m2[8];\n    \
return this;\n  }\n  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n    \
const c2 = Math.cos(rotation);\n    const s = Math.sin(rotation);\n    \
this.set(\n      sx * c2,\n      sx * s,\n      -sx * (c2 * cx + s * cy) + cx \
+ tx,\n      -sy * s,\n      sy * c2,\n      -sy * (-s * cx + c2 * cy) + cy + \
ty,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  //\n  \
scale(sx, sy) {\n    this.premultiply(_m3.makeScale(sx, sy));\n    return \
this;\n  }\n  rotate(theta) {\n    \
this.premultiply(_m3.makeRotation(-theta));\n    return this;\n  }\n  \
translate(tx, ty) {\n    this.premultiply(_m3.makeTranslation(tx, ty));\n    \
return this;\n  }\n  // for 2D Transforms\n  makeTranslation(x2, y2) {\n    \
if (x2.isVector2) {\n      this.set(\n        1,\n        0,\n        x2.x,\n \
       0,\n        1,\n        x2.y,\n        0,\n        0,\n        1\n     \
 );\n    } else {\n      this.set(\n        1,\n        0,\n        x2,\n     \
   0,\n        1,\n        y2,\n        0,\n        0,\n        1\n      );\n \
   }\n    return this;\n  }\n  makeRotation(theta) {\n    const c2 = \
Math.cos(theta);\n    const s = Math.sin(theta);\n    this.set(\n      c2,\n  \
    -s,\n      0,\n      s,\n      c2,\n      0,\n      0,\n      0,\n      \
1\n    );\n    return this;\n  }\n  makeScale(x2, y2) {\n    this.set(\n      \
x2,\n      0,\n      0,\n      0,\n      y2,\n      0,\n      0,\n      0,\n  \
    1\n    );\n    return this;\n  }\n  //\n  equals(matrix) {\n    const te \
= this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 9; \
i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return true;\n  \
}\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 9; i++) {\n      \
this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  \
toArray(array = [], offset = 0) {\n    const te = this.elements;\n    \
array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] \
= te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    \
array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset \
+ 7] = te[7];\n    array[offset + 8] = te[8];\n    return array;\n  }\n  \
clone() {\n    return new this.constructor().fromArray(this.elements);\n  \
}\n};\nvar _m3 = /* @__PURE__ */ new Matrix3();\nfunction \
arrayNeedsUint32(array) {\n  for (let i = array.length - 1; i >= 0; --i) {\n  \
  if (array[i] >= 65535) return true;\n  }\n  return false;\n}\nfunction \
createElementNS(name) {\n  return \
document.createElementNS(\"http://www.w3.org/1999/xhtml\", \
name);\n}\nfunction createCanvasElement() {\n  const canvas = \
createElementNS(\"canvas\");\n  canvas.style.display = \"block\";\n  return \
canvas;\n}\nvar _cache = {};\nfunction warnOnce(message) {\n  if (message in \
_cache) return;\n  _cache[message] = true;\n  \
console.warn(message);\n}\nfunction probeAsync(gl, sync, interval2) {\n  \
return new Promise(function(resolve, reject) {\n    function probe() {\n      \
switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {\n        \
case gl.WAIT_FAILED:\n          reject();\n          break;\n        case \
gl.TIMEOUT_EXPIRED:\n          setTimeout(probe, interval2);\n          \
break;\n        default:\n          resolve();\n      }\n    }\n    \
setTimeout(probe, interval2);\n  });\n}\nfunction \
toNormalizedProjectionMatrix(projectionMatrix) {\n  const m2 = \
projectionMatrix.elements;\n  m2[2] = 0.5 * m2[2] + 0.5 * m2[3];\n  m2[6] = \
0.5 * m2[6] + 0.5 * m2[7];\n  m2[10] = 0.5 * m2[10] + 0.5 * m2[11];\n  m2[14] \
= 0.5 * m2[14] + 0.5 * m2[15];\n}\nfunction \
toReversedProjectionMatrix(projectionMatrix) {\n  const m2 = \
projectionMatrix.elements;\n  const isPerspectiveMatrix = m2[11] === -1;\n  \
if (isPerspectiveMatrix) {\n    m2[10] = -m2[10] - 1;\n    m2[14] = \
-m2[14];\n  } else {\n    m2[10] = -m2[10];\n    m2[14] = -m2[14] + 1;\n  \
}\n}\nvar ColorManagement = {\n  enabled: true,\n  workingColorSpace: \
LinearSRGBColorSpace,\n  /**\n   * Implementations of supported color \
spaces.\n   *\n   * Required:\n   *\t- primaries: chromaticity coordinates [ \
rx ry gx gy bx by ]\n   *\t- whitePoint: reference white [ x y ]\n   *\t- \
transfer: transfer function (pre-defined)\n   *\t- toXYZ: Matrix3 RGB to XYZ \
transform\n   *\t- fromXYZ: Matrix3 XYZ to RGB transform\n   *\t- \
luminanceCoefficients: RGB luminance coefficients\n   *\n   * Optional:\n   * \
 - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n   *  - \
workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n   *\n   * \
Reference:\n   * - \
https://www.russellcottrell.com/photo/matrixCalculator.htm\n   */\n  spaces: \
{},\n  convert: function(color2, sourceColorSpace, targetColorSpace) {\n    \
if (this.enabled === false || sourceColorSpace === targetColorSpace || \
!sourceColorSpace || !targetColorSpace) {\n      return color2;\n    }\n    \
if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n      \
color2.r = SRGBToLinear(color2.r);\n      color2.g = \
SRGBToLinear(color2.g);\n      color2.b = SRGBToLinear(color2.b);\n    }\n    \
if (this.spaces[sourceColorSpace].primaries !== \
this.spaces[targetColorSpace].primaries) {\n      \
color2.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n      \
color2.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n    }\n    if \
(this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n      color2.r = \
LinearToSRGB(color2.r);\n      color2.g = LinearToSRGB(color2.g);\n      \
color2.b = LinearToSRGB(color2.b);\n    }\n    return color2;\n  },\n  \
fromWorkingColorSpace: function(color2, targetColorSpace) {\n    return \
this.convert(color2, this.workingColorSpace, targetColorSpace);\n  },\n  \
toWorkingColorSpace: function(color2, sourceColorSpace) {\n    return \
this.convert(color2, sourceColorSpace, this.workingColorSpace);\n  },\n  \
getPrimaries: function(colorSpace) {\n    return \
this.spaces[colorSpace].primaries;\n  },\n  getTransfer: function(colorSpace) \
{\n    if (colorSpace === NoColorSpace) return LinearTransfer;\n    return \
this.spaces[colorSpace].transfer;\n  },\n  getLuminanceCoefficients: \
function(target, colorSpace = this.workingColorSpace) {\n    return \
target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n  },\n  \
define: function(colorSpaces) {\n    Object.assign(this.spaces, \
colorSpaces);\n  },\n  // Internal APIs\n  _getMatrix: function(targetMatrix, \
sourceColorSpace, targetColorSpace) {\n    return \
targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[t\
argetColorSpace].fromXYZ);\n  },\n  _getDrawingBufferColorSpace: \
function(colorSpace) {\n    return \
this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n  \
},\n  _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n \
   return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n \
 }\n};\nfunction SRGBToLinear(c2) {\n  return c2 < 0.04045 ? c2 * \
0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);\n}\nfunction \
LinearToSRGB(c2) {\n  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * \
Math.pow(c2, 0.41666) - 0.055;\n}\nvar REC709_PRIMARIES = [0.64, 0.33, 0.3, \
0.6, 0.15, 0.06];\nvar REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, \
0.0722];\nvar D65 = [0.3127, 0.329];\nvar LINEAR_REC709_TO_XYZ = /* @__PURE__ \
*/ new Matrix3().set(\n  0.4123908,\n  0.3575843,\n  0.1804808,\n  \
0.212639,\n  0.7151687,\n  0.0721923,\n  0.0193308,\n  0.1191948,\n  \
0.9505322\n);\nvar XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new \
Matrix3().set(\n  3.2409699,\n  -1.5373832,\n  -0.4986108,\n  -0.9692436,\n  \
1.8759675,\n  0.0415551,\n  0.0556301,\n  -0.203977,\n  \
1.0569715\n);\nColorManagement.define({\n  [LinearSRGBColorSpace]: {\n    \
primaries: REC709_PRIMARIES,\n    whitePoint: D65,\n    transfer: \
LinearTransfer,\n    toXYZ: LINEAR_REC709_TO_XYZ,\n    fromXYZ: \
XYZ_TO_LINEAR_REC709,\n    luminanceCoefficients: \
REC709_LUMINANCE_COEFFICIENTS,\n    workingColorSpaceConfig: { \
unpackColorSpace: SRGBColorSpace },\n    outputColorSpaceConfig: { \
drawingBufferColorSpace: SRGBColorSpace }\n  },\n  [SRGBColorSpace]: {\n    \
primaries: REC709_PRIMARIES,\n    whitePoint: D65,\n    transfer: \
SRGBTransfer,\n    toXYZ: LINEAR_REC709_TO_XYZ,\n    fromXYZ: \
XYZ_TO_LINEAR_REC709,\n    luminanceCoefficients: \
REC709_LUMINANCE_COEFFICIENTS,\n    outputColorSpaceConfig: { \
drawingBufferColorSpace: SRGBColorSpace }\n  }\n});\nvar _canvas;\nvar \
ImageUtils = class {\n  static getDataURL(image) {\n    if \
(/^data:/i.test(image.src)) {\n      return image.src;\n    }\n    if (typeof \
HTMLCanvasElement === \"undefined\") {\n      return image.src;\n    }\n    \
let canvas;\n    if (image instanceof HTMLCanvasElement) {\n      canvas = \
image;\n    } else {\n      if (_canvas === void 0) _canvas = \
createElementNS(\"canvas\");\n      _canvas.width = image.width;\n      \
_canvas.height = image.height;\n      const context2 = \
_canvas.getContext(\"2d\");\n      if (image instanceof ImageData) {\n        \
context2.putImageData(image, 0, 0);\n      } else {\n        \
context2.drawImage(image, 0, 0, image.width, image.height);\n      }\n      \
canvas = _canvas;\n    }\n    if (canvas.width > 2048 || canvas.height > \
2048) {\n      console.warn(\"THREE.ImageUtils.getDataURL: Image converted to \
jpg for performance reasons\", image);\n      return \
canvas.toDataURL(\"image/jpeg\", 0.6);\n    } else {\n      return \
canvas.toDataURL(\"image/png\");\n    }\n  }\n  static sRGBToLinear(image) \
{\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof \
HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image \
instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image \
instanceof ImageBitmap) {\n      const canvas = \
createElementNS(\"canvas\");\n      canvas.width = image.width;\n      \
canvas.height = image.height;\n      const context2 = \
canvas.getContext(\"2d\");\n      context2.drawImage(image, 0, 0, \
image.width, image.height);\n      const imageData = context2.getImageData(0, \
0, image.width, image.height);\n      const data = imageData.data;\n      for \
(let i = 0; i < data.length; i++) {\n        data[i] = SRGBToLinear(data[i] / \
255) * 255;\n      }\n      context2.putImageData(imageData, 0, 0);\n      \
return canvas;\n    } else if (image.data) {\n      const data = \
image.data.slice(0);\n      for (let i = 0; i < data.length; i++) {\n        \
if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n      \
    data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);\n        } else \
{\n          data[i] = SRGBToLinear(data[i]);\n        }\n      }\n      \
return {\n        data,\n        width: image.width,\n        height: \
image.height\n      };\n    } else {\n      \
console.warn(\"THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No \
color space conversion applied.\");\n      return image;\n    }\n  }\n};\nvar \
_sourceId = 0;\nvar Source = class {\n  constructor(data = null) {\n    \
this.isSource = true;\n    Object.defineProperty(this, \"id\", { value: \
_sourceId++ });\n    this.uuid = generateUUID();\n    this.data = data;\n    \
this.dataReady = true;\n    this.version = 0;\n  }\n  set needsUpdate(value) \
{\n    if (value === true) this.version++;\n  }\n  toJSON(meta) {\n    const \
isRootObject = meta === void 0 || typeof meta === \"string\";\n    if \
(!isRootObject && meta.images[this.uuid] !== void 0) {\n      return \
meta.images[this.uuid];\n    }\n    const output2 = {\n      uuid: \
this.uuid,\n      url: \"\"\n    };\n    const data = this.data;\n    if \
(data !== null) {\n      let url;\n      if (Array.isArray(data)) {\n        \
url = [];\n        for (let i = 0, l = data.length; i < l; i++) {\n          \
if (data[i].isDataTexture) {\n            \
url.push(serializeImage(data[i].image));\n          } else {\n            \
url.push(serializeImage(data[i]));\n          }\n        }\n      } else {\n  \
      url = serializeImage(data);\n      }\n      output2.url = url;\n    }\n \
   if (!isRootObject) {\n      meta.images[this.uuid] = output2;\n    }\n    \
return output2;\n  }\n};\nfunction serializeImage(image) {\n  if (typeof \
HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || \
typeof HTMLCanvasElement !== \"undefined\" && image instanceof \
HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof \
ImageBitmap) {\n    return ImageUtils.getDataURL(image);\n  } else {\n    if \
(image.data) {\n      return {\n        data: Array.from(image.data),\n       \
 width: image.width,\n        height: image.height,\n        type: \
image.data.constructor.name\n      };\n    } else {\n      \
console.warn(\"THREE.Texture: Unable to serialize Texture.\");\n      return \
{};\n    }\n  }\n}\nvar _textureId = 0;\nvar Texture = class _Texture extends \
EventDispatcher {\n  constructor(image = _Texture.DEFAULT_IMAGE, mapping = \
_Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = \
ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = \
LinearMipmapLinearFilter, format2 = RGBAFormat, type = UnsignedByteType, \
anisotropy2 = _Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {\n    \
super();\n    this.isTexture = true;\n    Object.defineProperty(this, \"id\", \
{ value: _textureId++ });\n    this.uuid = generateUUID();\n    this.name = \
\"\";\n    this.source = new Source(image);\n    this.mipmaps = [];\n    \
this.mapping = mapping;\n    this.channel = 0;\n    this.wrapS = wrapS;\n    \
this.wrapT = wrapT;\n    this.magFilter = magFilter;\n    this.minFilter = \
minFilter;\n    this.anisotropy = anisotropy2;\n    this.format = format2;\n  \
  this.internalFormat = null;\n    this.type = type;\n    this.offset = new \
Vector2(0, 0);\n    this.repeat = new Vector2(1, 1);\n    this.center = new \
Vector2(0, 0);\n    this.rotation = 0;\n    this.matrixAutoUpdate = true;\n   \
 this.matrix = new Matrix3();\n    this.generateMipmaps = true;\n    \
this.premultiplyAlpha = false;\n    this.flipY = true;\n    \
this.unpackAlignment = 4;\n    this.colorSpace = colorSpace;\n    \
this.userData = {};\n    this.version = 0;\n    this.onUpdate = null;\n    \
this.isRenderTargetTexture = false;\n    this.pmremVersion = 0;\n  }\n  get \
image() {\n    return this.source.data;\n  }\n  set image(value = null) {\n   \
 this.source.data = value;\n  }\n  updateMatrix() {\n    \
this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, \
this.repeat.y, this.rotation, this.center.x, this.center.y);\n  }\n  clone() \
{\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    \
this.name = source.name;\n    this.source = source.source;\n    this.mipmaps \
= source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    \
this.channel = source.channel;\n    this.wrapS = source.wrapS;\n    \
this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    \
this.minFilter = source.minFilter;\n    this.anisotropy = \
source.anisotropy;\n    this.format = source.format;\n    this.internalFormat \
= source.internalFormat;\n    this.type = source.type;\n    \
this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    \
this.center.copy(source.center);\n    this.rotation = source.rotation;\n    \
this.matrixAutoUpdate = source.matrixAutoUpdate;\n    \
this.matrix.copy(source.matrix);\n    this.generateMipmaps = \
source.generateMipmaps;\n    this.premultiplyAlpha = \
source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    \
this.unpackAlignment = source.unpackAlignment;\n    this.colorSpace = \
source.colorSpace;\n    this.userData = \
JSON.parse(JSON.stringify(source.userData));\n    this.needsUpdate = true;\n  \
  return this;\n  }\n  toJSON(meta) {\n    const isRootObject = meta === void \
0 || typeof meta === \"string\";\n    if (!isRootObject && \
meta.textures[this.uuid] !== void 0) {\n      return \
meta.textures[this.uuid];\n    }\n    const output2 = {\n      metadata: {\n  \
      version: 4.6,\n        type: \"Texture\",\n        generator: \
\"Texture.toJSON\"\n      },\n      uuid: this.uuid,\n      name: \
this.name,\n      image: this.source.toJSON(meta).uuid,\n      mapping: \
this.mapping,\n      channel: this.channel,\n      repeat: [this.repeat.x, \
this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: \
[this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: \
[this.wrapS, this.wrapT],\n      format: this.format,\n      internalFormat: \
this.internalFormat,\n      type: this.type,\n      colorSpace: \
this.colorSpace,\n      minFilter: this.minFilter,\n      magFilter: \
this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: \
this.flipY,\n      generateMipmaps: this.generateMipmaps,\n      \
premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: \
this.unpackAlignment\n    };\n    if (Object.keys(this.userData).length > 0) \
output2.userData = this.userData;\n    if (!isRootObject) {\n      \
meta.textures[this.uuid] = output2;\n    }\n    return output2;\n  }\n  \
dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n  \
transformUv(uv2) {\n    if (this.mapping !== UVMapping) return uv2;\n    \
uv2.applyMatrix3(this.matrix);\n    if (uv2.x < 0 || uv2.x > 1) {\n      \
switch (this.wrapS) {\n        case RepeatWrapping:\n          uv2.x = uv2.x \
- Math.floor(uv2.x);\n          break;\n        case ClampToEdgeWrapping:\n   \
       uv2.x = uv2.x < 0 ? 0 : 1;\n          break;\n        case \
MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv2.x) % 2) === 1) \
{\n            uv2.x = Math.ceil(uv2.x) - uv2.x;\n          } else {\n        \
    uv2.x = uv2.x - Math.floor(uv2.x);\n          }\n          break;\n      \
}\n    }\n    if (uv2.y < 0 || uv2.y > 1) {\n      switch (this.wrapT) {\n    \
    case RepeatWrapping:\n          uv2.y = uv2.y - Math.floor(uv2.y);\n      \
    break;\n        case ClampToEdgeWrapping:\n          uv2.y = uv2.y < 0 ? \
0 : 1;\n          break;\n        case MirroredRepeatWrapping:\n          if \
(Math.abs(Math.floor(uv2.y) % 2) === 1) {\n            uv2.y = \
Math.ceil(uv2.y) - uv2.y;\n          } else {\n            uv2.y = uv2.y - \
Math.floor(uv2.y);\n          }\n          break;\n      }\n    }\n    if \
(this.flipY) {\n      uv2.y = 1 - uv2.y;\n    }\n    return uv2;\n  }\n  set \
needsUpdate(value) {\n    if (value === true) {\n      this.version++;\n      \
this.source.needsUpdate = true;\n    }\n  }\n  set needsPMREMUpdate(value) \
{\n    if (value === true) {\n      this.pmremVersion++;\n    }\n  \
}\n};\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = \
UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\nvar Vector4 = class _Vector4 {\n \
 constructor(x2 = 0, y2 = 0, z2 = 0, w = 1) {\n    \
_Vector4.prototype.isVector4 = true;\n    this.x = x2;\n    this.y = y2;\n    \
this.z = z2;\n    this.w = w;\n  }\n  get width() {\n    return this.z;\n  \
}\n  set width(value) {\n    this.z = value;\n  }\n  get height() {\n    \
return this.w;\n  }\n  set height(value) {\n    this.w = value;\n  }\n  \
set(x2, y2, z2, w) {\n    this.x = x2;\n    this.y = y2;\n    this.z = z2;\n  \
  this.w = w;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = \
scalar;\n    this.y = scalar;\n    this.z = scalar;\n    this.w = scalar;\n   \
 return this;\n  }\n  setX(x2) {\n    this.x = x2;\n    return this;\n  }\n  \
setY(y2) {\n    this.y = y2;\n    return this;\n  }\n  setZ(z2) {\n    this.z \
= z2;\n    return this;\n  }\n  setW(w) {\n    this.w = w;\n    return \
this;\n  }\n  setComponent(index5, value) {\n    switch (index5) {\n      \
case 0:\n        this.x = value;\n        break;\n      case 1:\n        \
this.y = value;\n        break;\n      case 2:\n        this.z = value;\n     \
   break;\n      case 3:\n        this.w = value;\n        break;\n      \
default:\n        throw new Error(\"index is out of range: \" + index5);\n    \
}\n    return this;\n  }\n  getComponent(index5) {\n    switch (index5) {\n   \
   case 0:\n        return this.x;\n      case 1:\n        return this.y;\n   \
   case 2:\n        return this.z;\n      case 3:\n        return this.w;\n   \
   default:\n        throw new Error(\"index is out of range: \" + index5);\n \
   }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, \
this.z, this.w);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    \
this.z = v.z;\n    this.w = v.w !== void 0 ? v.w : 1;\n    return this;\n  \
}\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n   \
 this.w += v.w;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n  \
  this.y += s;\n    this.z += s;\n    this.w += s;\n    return this;\n  }\n  \
addVectors(a2, b) {\n    this.x = a2.x + b.x;\n    this.y = a2.y + b.y;\n    \
this.z = a2.z + b.z;\n    this.w = a2.w + b.w;\n    return this;\n  }\n  \
addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    \
this.z += v.z * s;\n    this.w += v.w * s;\n    return this;\n  }\n  sub(v) \
{\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= \
v.w;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y \
-= s;\n    this.z -= s;\n    this.w -= s;\n    return this;\n  }\n  \
subVectors(a2, b) {\n    this.x = a2.x - b.x;\n    this.y = a2.y - b.y;\n    \
this.z = a2.z - b.z;\n    this.w = a2.w - b.w;\n    return this;\n  }\n  \
multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n   \
 this.w *= v.w;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    \
this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w \
*= scalar;\n    return this;\n  }\n  applyMatrix4(m2) {\n    const x2 = \
this.x, y2 = this.y, z2 = this.z, w = this.w;\n    const e = m2.elements;\n   \
 this.x = e[0] * x2 + e[4] * y2 + e[8] * z2 + e[12] * w;\n    this.y = e[1] * \
x2 + e[5] * y2 + e[9] * z2 + e[13] * w;\n    this.z = e[2] * x2 + e[6] * y2 + \
e[10] * z2 + e[14] * w;\n    this.w = e[3] * x2 + e[7] * y2 + e[11] * z2 + \
e[15] * w;\n    return this;\n  }\n  divide(v) {\n    this.x /= v.x;\n    \
this.y /= v.y;\n    this.z /= v.z;\n    this.w /= v.w;\n    return this;\n  \
}\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  \
}\n  setAxisAngleFromQuaternion(q) {\n    this.w = 2 * Math.acos(q.w);\n    \
const s = Math.sqrt(1 - q.w * q.w);\n    if (s < 1e-4) {\n      this.x = 1;\n \
     this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n  \
    this.y = q.y / s;\n      this.z = q.z / s;\n    }\n    return this;\n  \
}\n  setAxisAngleFromRotationMatrix(m2) {\n    let angle, x2, y2, z2;\n    \
const epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = \
te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = \
te[6], m33 = te[10];\n    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - \
m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n      if (Math.abs(m12 + \
m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < \
epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n        this.set(1, \
0, 0, 0);\n        return this;\n      }\n      angle = Math.PI;\n      const \
xx = (m11 + 1) / 2;\n      const yy = (m22 + 1) / 2;\n      const zz = (m33 + \
1) / 2;\n      const xy = (m12 + m21) / 4;\n      const xz = (m13 + m31) / \
4;\n      const yz = (m23 + m32) / 4;\n      if (xx > yy && xx > zz) {\n      \
  if (xx < epsilon) {\n          x2 = 0;\n          y2 = 0.707106781;\n       \
   z2 = 0.707106781;\n        } else {\n          x2 = Math.sqrt(xx);\n       \
   y2 = xy / x2;\n          z2 = xz / x2;\n        }\n      } else if (yy > \
zz) {\n        if (yy < epsilon) {\n          x2 = 0.707106781;\n          y2 \
= 0;\n          z2 = 0.707106781;\n        } else {\n          y2 = \
Math.sqrt(yy);\n          x2 = xy / y2;\n          z2 = yz / y2;\n        }\n \
     } else {\n        if (zz < epsilon) {\n          x2 = 0.707106781;\n     \
     y2 = 0.707106781;\n          z2 = 0;\n        } else {\n          z2 = \
Math.sqrt(zz);\n          x2 = xz / z2;\n          y2 = yz / z2;\n        }\n \
     }\n      this.set(x2, y2, z2, angle);\n      return this;\n    }\n    \
let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + \
(m21 - m12) * (m21 - m12));\n    if (Math.abs(s) < 1e-3) s = 1;\n    this.x = \
(m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / \
s;\n    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n    return this;\n  \
}\n  setFromMatrixPosition(m2) {\n    const e = m2.elements;\n    this.x = \
e[12];\n    this.y = e[13];\n    this.z = e[14];\n    this.w = e[15];\n    \
return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    \
this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    \
this.w = Math.min(this.w, v.w);\n    return this;\n  }\n  max(v) {\n    \
this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    \
this.z = Math.max(this.z, v.z);\n    this.w = Math.max(this.w, v.w);\n    \
return this;\n  }\n  clamp(min2, max2) {\n    this.x = Math.max(min2.x, \
Math.min(max2.x, this.x));\n    this.y = Math.max(min2.y, Math.min(max2.y, \
this.y));\n    this.z = Math.max(min2.z, Math.min(max2.z, this.z));\n    \
this.w = Math.max(min2.w, Math.min(max2.w, this.w));\n    return this;\n  }\n \
 clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, \
Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, \
this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    \
this.w = Math.max(minVal, Math.min(maxVal, this.w));\n    return this;\n  }\n \
 clampLength(min2, max2) {\n    const length2 = this.length();\n    return \
this.divideScalar(length2 || 1).multiplyScalar(Math.max(min2, Math.min(max2, \
length2)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = \
Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = \
Math.floor(this.w);\n    return this;\n  }\n  ceil() {\n    this.x = \
Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = \
Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n    return this;\n  }\n  \
round() {\n    this.x = Math.round(this.x);\n    this.y = \
Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = \
Math.round(this.w);\n    return this;\n  }\n  roundToZero() {\n    this.x = \
Math.trunc(this.x);\n    this.y = Math.trunc(this.y);\n    this.z = \
Math.trunc(this.z);\n    this.w = Math.trunc(this.w);\n    return this;\n  \
}\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = \
-this.z;\n    this.w = -this.w;\n    return this;\n  }\n  dot(v) {\n    \
return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  }\n  \
lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z \
+ this.w * this.w;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + \
this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n  \
manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + \
Math.abs(this.z) + Math.abs(this.w);\n  }\n  normalize() {\n    return \
this.divideScalar(this.length() || 1);\n  }\n  setLength(length2) {\n    \
return this.normalize().multiplyScalar(length2);\n  }\n  lerp(v, alpha) {\n   \
 this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n   \
 this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n   \
 return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x \
- v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = \
v1.z + (v2.z - v1.z) * alpha;\n    this.w = v1.w + (v2.w - v1.w) * alpha;\n   \
 return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === \
this.y && v.z === this.z && v.w === this.w;\n  }\n  fromArray(array, offset = \
0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    \
this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return \
this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = \
this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n   \
 array[offset + 3] = this.w;\n    return array;\n  }\n  \
fromBufferAttribute(attribute2, index5) {\n    this.x = \
attribute2.getX(index5);\n    this.y = attribute2.getY(index5);\n    this.z = \
attribute2.getZ(index5);\n    this.w = attribute2.getW(index5);\n    return \
this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = \
Math.random();\n    this.z = Math.random();\n    this.w = Math.random();\n    \
return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield \
this.y;\n    yield this.z;\n    yield this.w;\n  }\n};\nvar RenderTarget = \
class extends EventDispatcher {\n  constructor(width = 1, height = 1, options \
= {}) {\n    super();\n    this.isRenderTarget = true;\n    this.width = \
width;\n    this.height = height;\n    this.depth = 1;\n    this.scissor = \
new Vector4(0, 0, width, height);\n    this.scissorTest = false;\n    \
this.viewport = new Vector4(0, 0, width, height);\n    const image = { width, \
height, depth: 1 };\n    options = Object.assign({\n      generateMipmaps: \
false,\n      internalFormat: null,\n      minFilter: LinearFilter,\n      \
depthBuffer: true,\n      stencilBuffer: false,\n      resolveDepthBuffer: \
true,\n      resolveStencilBuffer: true,\n      depthTexture: null,\n      \
samples: 0,\n      count: 1\n    }, options);\n    const texture2 = new \
Texture(image, options.mapping, options.wrapS, options.wrapT, \
options.magFilter, options.minFilter, options.format, options.type, \
options.anisotropy, options.colorSpace);\n    texture2.flipY = false;\n    \
texture2.generateMipmaps = options.generateMipmaps;\n    \
texture2.internalFormat = options.internalFormat;\n    this.textures = [];\n  \
  const count = options.count;\n    for (let i = 0; i < count; i++) {\n      \
this.textures[i] = texture2.clone();\n      \
this.textures[i].isRenderTargetTexture = true;\n    }\n    this.depthBuffer = \
options.depthBuffer;\n    this.stencilBuffer = options.stencilBuffer;\n    \
this.resolveDepthBuffer = options.resolveDepthBuffer;\n    \
this.resolveStencilBuffer = options.resolveStencilBuffer;\n    \
this.depthTexture = options.depthTexture;\n    this.samples = \
options.samples;\n  }\n  get texture() {\n    return this.textures[0];\n  }\n \
 set texture(value) {\n    this.textures[0] = value;\n  }\n  setSize(width, \
height, depth2 = 1) {\n    if (this.width !== width || this.height !== height \
|| this.depth !== depth2) {\n      this.width = width;\n      this.height = \
height;\n      this.depth = depth2;\n      for (let i = 0, il = \
this.textures.length; i < il; i++) {\n        this.textures[i].image.width = \
width;\n        this.textures[i].image.height = height;\n        \
this.textures[i].image.depth = depth2;\n      }\n      this.dispose();\n    \
}\n    this.viewport.set(0, 0, width, height);\n    this.scissor.set(0, 0, \
width, height);\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n  copy(source) {\n    this.width = \
source.width;\n    this.height = source.height;\n    this.depth = \
source.depth;\n    this.scissor.copy(source.scissor);\n    this.scissorTest = \
source.scissorTest;\n    this.viewport.copy(source.viewport);\n    \
this.textures.length = 0;\n    for (let i = 0, il = source.textures.length; i \
< il; i++) {\n      this.textures[i] = source.textures[i].clone();\n      \
this.textures[i].isRenderTargetTexture = true;\n    }\n    const image = \
Object.assign({}, source.texture.image);\n    this.texture.source = new \
Source(image);\n    this.depthBuffer = source.depthBuffer;\n    \
this.stencilBuffer = source.stencilBuffer;\n    this.resolveDepthBuffer = \
source.resolveDepthBuffer;\n    this.resolveStencilBuffer = \
source.resolveStencilBuffer;\n    if (source.depthTexture !== null) \
this.depthTexture = source.depthTexture.clone();\n    this.samples = \
source.samples;\n    return this;\n  }\n  dispose() {\n    \
this.dispatchEvent({ type: \"dispose\" });\n  }\n};\nvar WebGLRenderTarget = \
class extends RenderTarget {\n  constructor(width = 1, height = 1, options = \
{}) {\n    super(width, height, options);\n    this.isWebGLRenderTarget = \
true;\n  }\n};\nvar DataArrayTexture = class extends Texture {\n  \
constructor(data = null, width = 1, height = 1, depth2 = 1) {\n    \
super(null);\n    this.isDataArrayTexture = true;\n    this.image = { data, \
width, height, depth: depth2 };\n    this.magFilter = NearestFilter;\n    \
this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    \
this.generateMipmaps = false;\n    this.flipY = false;\n    \
this.unpackAlignment = 1;\n    this.layerUpdates = /* @__PURE__ */ new \
Set();\n  }\n  addLayerUpdate(layerIndex) {\n    \
this.layerUpdates.add(layerIndex);\n  }\n  clearLayerUpdates() {\n    \
this.layerUpdates.clear();\n  }\n};\nvar Data3DTexture = class extends \
Texture {\n  constructor(data = null, width = 1, height = 1, depth2 = 1) {\n  \
  super(null);\n    this.isData3DTexture = true;\n    this.image = { data, \
width, height, depth: depth2 };\n    this.magFilter = NearestFilter;\n    \
this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    \
this.generateMipmaps = false;\n    this.flipY = false;\n    \
this.unpackAlignment = 1;\n  }\n};\nvar Quaternion = class {\n  \
constructor(x2 = 0, y2 = 0, z2 = 0, w = 1) {\n    this.isQuaternion = true;\n \
   this._x = x2;\n    this._y = y2;\n    this._z = z2;\n    this._w = w;\n  \
}\n  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) \
{\n    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = \
src0[srcOffset0 + 2], w02 = src0[srcOffset0 + 3];\n    const x1 = \
src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], \
w12 = src1[srcOffset1 + 3];\n    if (t === 0) {\n      dst[dstOffset + 0] = \
x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      \
dst[dstOffset + 3] = w02;\n      return;\n    }\n    if (t === 1) {\n      \
dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset \
+ 2] = z1;\n      dst[dstOffset + 3] = w12;\n      return;\n    }\n    if \
(w02 !== w12 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - \
t;\n      const cos2 = x0 * x1 + y0 * y1 + z0 * z1 + w02 * w12, dir = cos2 >= \
0 ? 1 : -1, sqrSin = 1 - cos2 * cos2;\n      if (sqrSin > Number.EPSILON) {\n \
       const sin2 = Math.sqrt(sqrSin), len = Math.atan2(sin2, cos2 * dir);\n  \
      s = Math.sin(s * len) / sin2;\n        t = Math.sin(t * len) / sin2;\n  \
    }\n      const tDir = t * dir;\n      x0 = x0 * s + x1 * tDir;\n      y0 \
= y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w02 = w02 * s + \
w12 * tDir;\n      if (s === 1 - t) {\n        const f = 1 / Math.sqrt(x0 * \
x0 + y0 * y0 + z0 * z0 + w02 * w02);\n        x0 *= f;\n        y0 *= f;\n    \
    z0 *= f;\n        w02 *= f;\n      }\n    }\n    dst[dstOffset] = x0;\n   \
 dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + \
3] = w02;\n  }\n  static multiplyQuaternionsFlat(dst, dstOffset, src0, \
srcOffset0, src1, srcOffset1) {\n    const x0 = src0[srcOffset0];\n    const \
y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const \
w02 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1];\n    const y1 = \
src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w12 = \
src1[srcOffset1 + 3];\n    dst[dstOffset] = x0 * w12 + w02 * x1 + y0 * z1 - \
z0 * y1;\n    dst[dstOffset + 1] = y0 * w12 + w02 * y1 + z0 * x1 - x0 * z1;\n \
   dst[dstOffset + 2] = z0 * w12 + w02 * z1 + x0 * y1 - y0 * x1;\n    \
dst[dstOffset + 3] = w02 * w12 - x0 * x1 - y0 * y1 - z0 * z1;\n    return \
dst;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    \
this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return \
this._y;\n  }\n  set y(value) {\n    this._y = value;\n    \
this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set \
z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get \
w() {\n    return this._w;\n  }\n  set w(value) {\n    this._w = value;\n    \
this._onChangeCallback();\n  }\n  set(x2, y2, z2, w) {\n    this._x = x2;\n   \
 this._y = y2;\n    this._z = z2;\n    this._w = w;\n    \
this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new \
this.constructor(this._x, this._y, this._z, this._w);\n  }\n  \
copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = \
quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n    \
this._onChangeCallback();\n    return this;\n  }\n  setFromEuler(euler, \
update4 = true) {\n    const x2 = euler._x, y2 = euler._y, z2 = euler._z, \
order = euler._order;\n    const cos2 = Math.cos;\n    const sin2 = \
Math.sin;\n    const c1 = cos2(x2 / 2);\n    const c2 = cos2(y2 / 2);\n    \
const c3 = cos2(z2 / 2);\n    const s1 = sin2(x2 / 2);\n    const s2 = \
sin2(y2 / 2);\n    const s3 = sin2(z2 / 2);\n    switch (order) {\n      case \
\"XYZ\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = \
c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * \
c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      \
case \"YXZ\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n    \
  case \"ZXY\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n    \
  case \"ZYX\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n    \
  case \"YZX\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n    \
  case \"XZY\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n    \
  default:\n        console.warn(\"THREE.Quaternion: .setFromEuler() \
encountered an unknown order: \" + order);\n    }\n    if (update4 === true) \
this._onChangeCallback();\n    return this;\n  }\n  setFromAxisAngle(axis, \
angle) {\n    const halfAngle = angle / 2, s = Math.sin(halfAngle);\n    \
this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n \
   this._w = Math.cos(halfAngle);\n    this._onChangeCallback();\n    return \
this;\n  }\n  setFromRotationMatrix(m2) {\n    const te = m2.elements, m11 = \
te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = \
te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n    if (trace > \
0) {\n      const s = 0.5 / Math.sqrt(trace + 1);\n      this._w = 0.25 / \
s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      \
this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      \
const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n      this._w = (m32 - m23) / \
s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      \
this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s = 2 * \
Math.sqrt(1 + m22 - m11 - m33);\n      this._w = (m13 - m31) / s;\n      \
this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + \
m32) / s;\n    } else {\n      const s = 2 * Math.sqrt(1 + m33 - m11 - \
m22);\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n   \
   this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n    \
this._onChangeCallback();\n    return this;\n  }\n  setFromUnitVectors(vFrom, \
vTo) {\n    let r = vFrom.dot(vTo) + 1;\n    if (r < Number.EPSILON) {\n      \
r = 0;\n      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n        this._x = \
-vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w \
= r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n     \
   this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      \
this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x \
- vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      \
this._w = r;\n    }\n    return this.normalize();\n  }\n  angleTo(q) {\n    \
return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n  }\n  \
rotateTowards(q, step2) {\n    const angle = this.angleTo(q);\n    if (angle \
=== 0) return this;\n    const t = Math.min(1, step2 / angle);\n    \
this.slerp(q, t);\n    return this;\n  }\n  identity() {\n    return \
this.set(0, 0, 0, 1);\n  }\n  invert() {\n    return this.conjugate();\n  }\n \
 conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n  \
  this._onChangeCallback();\n    return this;\n  }\n  dot(v) {\n    return \
this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n  \
lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * \
this._z + this._w * this._w;\n  }\n  length() {\n    return Math.sqrt(this._x \
* this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  \
}\n  normalize() {\n    let l = this.length();\n    if (l === 0) {\n      \
this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    \
} else {\n      l = 1 / l;\n      this._x = this._x * l;\n      this._y = \
this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    \
}\n    this._onChangeCallback();\n    return this;\n  }\n  multiply(q) {\n    \
return this.multiplyQuaternions(this, q);\n  }\n  premultiply(q) {\n    \
return this.multiplyQuaternions(q, this);\n  }\n  multiplyQuaternions(a2, b) \
{\n    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;\n    const \
qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n    this._x = qax * qbw + \
qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz \
* qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * \
qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n    \
this._onChangeCallback();\n    return this;\n  }\n  slerp(qb, t) {\n    if (t \
=== 0) return this;\n    if (t === 1) return this.copy(qb);\n    const x2 = \
this._x, y2 = this._y, z2 = this._z, w = this._w;\n    let cosHalfTheta = w * \
qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;\n    if (cosHalfTheta < 0) {\n  \
    this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n     \
 this._z = -qb._z;\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      \
this.copy(qb);\n    }\n    if (cosHalfTheta >= 1) {\n      this._w = w;\n     \
 this._x = x2;\n      this._y = y2;\n      this._z = z2;\n      return \
this;\n    }\n    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n  \
  if (sqrSinHalfTheta <= Number.EPSILON) {\n      const s = 1 - t;\n      \
this._w = s * w + t * this._w;\n      this._x = s * x2 + t * this._x;\n      \
this._y = s * y2 + t * this._y;\n      this._z = s * z2 + t * this._z;\n      \
this.normalize();\n      return this;\n    }\n    const sinHalfTheta = \
Math.sqrt(sqrSinHalfTheta);\n    const halfTheta = Math.atan2(sinHalfTheta, \
cosHalfTheta);\n    const ratioA = Math.sin((1 - t) * halfTheta) / \
sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n    this._w = \
w * ratioA + this._w * ratioB;\n    this._x = x2 * ratioA + this._x * \
ratioB;\n    this._y = y2 * ratioA + this._y * ratioB;\n    this._z = z2 * \
ratioA + this._z * ratioB;\n    this._onChangeCallback();\n    return this;\n \
 }\n  slerpQuaternions(qa, qb, t) {\n    return this.copy(qa).slerp(qb, t);\n \
 }\n  random() {\n    const theta1 = 2 * Math.PI * Math.random();\n    const \
theta2 = 2 * Math.PI * Math.random();\n    const x0 = Math.random();\n    \
const r1 = Math.sqrt(1 - x0);\n    const r2 = Math.sqrt(x0);\n    return \
this.set(\n      r1 * Math.sin(theta1),\n      r1 * Math.cos(theta1),\n      \
r2 * Math.sin(theta2),\n      r2 * Math.cos(theta2)\n    );\n  }\n  \
equals(quaternion) {\n    return quaternion._x === this._x && quaternion._y \
=== this._y && quaternion._z === this._z && quaternion._w === this._w;\n  }\n \
 fromArray(array, offset = 0) {\n    this._x = array[offset];\n    this._y = \
array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = \
array[offset + 3];\n    this._onChangeCallback();\n    return this;\n  }\n  \
toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    \
array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    \
array[offset + 3] = this._w;\n    return array;\n  }\n  \
fromBufferAttribute(attribute2, index5) {\n    this._x = \
attribute2.getX(index5);\n    this._y = attribute2.getY(index5);\n    this._z \
= attribute2.getZ(index5);\n    this._w = attribute2.getW(index5);\n    \
this._onChangeCallback();\n    return this;\n  }\n  toJSON() {\n    return \
this.toArray();\n  }\n  _onChange(callback) {\n    this._onChangeCallback = \
callback;\n    return this;\n  }\n  _onChangeCallback() {\n  }\n  \
*[Symbol.iterator]() {\n    yield this._x;\n    yield this._y;\n    yield \
this._z;\n    yield this._w;\n  }\n};\nvar Vector3 = class _Vector3 {\n  \
constructor(x2 = 0, y2 = 0, z2 = 0) {\n    _Vector3.prototype.isVector3 = \
true;\n    this.x = x2;\n    this.y = y2;\n    this.z = z2;\n  }\n  set(x2, \
y2, z2) {\n    if (z2 === void 0) z2 = this.z;\n    this.x = x2;\n    this.y \
= y2;\n    this.z = z2;\n    return this;\n  }\n  setScalar(scalar) {\n    \
this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    return \
this;\n  }\n  setX(x2) {\n    this.x = x2;\n    return this;\n  }\n  setY(y2) \
{\n    this.y = y2;\n    return this;\n  }\n  setZ(z2) {\n    this.z = z2;\n  \
  return this;\n  }\n  setComponent(index5, value) {\n    switch (index5) {\n \
     case 0:\n        this.x = value;\n        break;\n      case 1:\n        \
this.y = value;\n        break;\n      case 2:\n        this.z = value;\n     \
   break;\n      default:\n        throw new Error(\"index is out of range: \
\" + index5);\n    }\n    return this;\n  }\n  getComponent(index5) {\n    \
switch (index5) {\n      case 0:\n        return this.x;\n      case 1:\n     \
   return this.y;\n      case 2:\n        return this.z;\n      default:\n    \
    throw new Error(\"index is out of range: \" + index5);\n    }\n  }\n  \
clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  }\n  \
copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    \
return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    \
this.z += v.z;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n   \
 this.y += s;\n    this.z += s;\n    return this;\n  }\n  addVectors(a2, b) \
{\n    this.x = a2.x + b.x;\n    this.y = a2.y + b.y;\n    this.z = a2.z + \
b.z;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * \
s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  }\n  \
sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    \
return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    \
this.z -= s;\n    return this;\n  }\n  subVectors(a2, b) {\n    this.x = a2.x \
- b.x;\n    this.y = a2.y - b.y;\n    this.z = a2.z - b.z;\n    return \
this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    \
this.z *= v.z;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x \
*= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  \
}\n  multiplyVectors(a2, b) {\n    this.x = a2.x * b.x;\n    this.y = a2.y * \
b.y;\n    this.z = a2.z * b.z;\n    return this;\n  }\n  applyEuler(euler) \
{\n    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n  }\n \
 applyAxisAngle(axis, angle) {\n    return \
this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n  }\n  \
applyMatrix3(m2) {\n    const x2 = this.x, y2 = this.y, z2 = this.z;\n    \
const e = m2.elements;\n    this.x = e[0] * x2 + e[3] * y2 + e[6] * z2;\n    \
this.y = e[1] * x2 + e[4] * y2 + e[7] * z2;\n    this.z = e[2] * x2 + e[5] * \
y2 + e[8] * z2;\n    return this;\n  }\n  applyNormalMatrix(m2) {\n    return \
this.applyMatrix3(m2).normalize();\n  }\n  applyMatrix4(m2) {\n    const x2 = \
this.x, y2 = this.y, z2 = this.z;\n    const e = m2.elements;\n    const w = \
1 / (e[3] * x2 + e[7] * y2 + e[11] * z2 + e[15]);\n    this.x = (e[0] * x2 + \
e[4] * y2 + e[8] * z2 + e[12]) * w;\n    this.y = (e[1] * x2 + e[5] * y2 + \
e[9] * z2 + e[13]) * w;\n    this.z = (e[2] * x2 + e[6] * y2 + e[10] * z2 + \
e[14]) * w;\n    return this;\n  }\n  applyQuaternion(q) {\n    const vx = \
this.x, vy = this.y, vz = this.z;\n    const qx = q.x, qy = q.y, qz = q.z, qw \
= q.w;\n    const tx = 2 * (qy * vz - qz * vy);\n    const ty = 2 * (qz * vx \
- qx * vz);\n    const tz = 2 * (qx * vy - qy * vx);\n    this.x = vx + qw * \
tx + qy * tz - qz * ty;\n    this.y = vy + qw * ty + qz * tx - qx * tz;\n    \
this.z = vz + qw * tz + qx * ty - qy * tx;\n    return this;\n  }\n  \
project(camera3) {\n    return \
this.applyMatrix4(camera3.matrixWorldInverse).applyMatrix4(camera3.projection\
Matrix);\n  }\n  unproject(camera3) {\n    return \
this.applyMatrix4(camera3.projectionMatrixInverse).applyMatrix4(camera3.matri\
xWorld);\n  }\n  transformDirection(m2) {\n    const x2 = this.x, y2 = \
this.y, z2 = this.z;\n    const e = m2.elements;\n    this.x = e[0] * x2 + \
e[4] * y2 + e[8] * z2;\n    this.y = e[1] * x2 + e[5] * y2 + e[9] * z2;\n    \
this.z = e[2] * x2 + e[6] * y2 + e[10] * z2;\n    return this.normalize();\n  \
}\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= \
v.z;\n    return this;\n  }\n  divideScalar(scalar) {\n    return \
this.multiplyScalar(1 / scalar);\n  }\n  min(v) {\n    this.x = \
Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = \
Math.min(this.z, v.z);\n    return this;\n  }\n  max(v) {\n    this.x = \
Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = \
Math.max(this.z, v.z);\n    return this;\n  }\n  clamp(min2, max2) {\n    \
this.x = Math.max(min2.x, Math.min(max2.x, this.x));\n    this.y = \
Math.max(min2.y, Math.min(max2.y, this.y));\n    this.z = Math.max(min2.z, \
Math.min(max2.z, this.z));\n    return this;\n  }\n  clampScalar(minVal, \
maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    \
this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = \
Math.max(minVal, Math.min(maxVal, this.z));\n    return this;\n  }\n  \
clampLength(min2, max2) {\n    const length2 = this.length();\n    return \
this.divideScalar(length2 || 1).multiplyScalar(Math.max(min2, Math.min(max2, \
length2)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = \
Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  \
}\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = \
Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  }\n  \
round() {\n    this.x = Math.round(this.x);\n    this.y = \
Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  \
}\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = \
Math.trunc(this.y);\n    this.z = Math.trunc(this.z);\n    return this;\n  \
}\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = \
-this.z;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y \
* v.y + this.z * v.z;\n  }\n  // TODO lengthSquared?\n  lengthSq() {\n    \
return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n  length() \
{\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * \
this.z);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + \
Math.abs(this.y) + Math.abs(this.z);\n  }\n  normalize() {\n    return \
this.divideScalar(this.length() || 1);\n  }\n  setLength(length2) {\n    \
return this.normalize().multiplyScalar(length2);\n  }\n  lerp(v, alpha) {\n   \
 this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n   \
 this.z += (v.z - this.z) * alpha;\n    return this;\n  }\n  lerpVectors(v1, \
v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + \
(v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    \
return this;\n  }\n  cross(v) {\n    return this.crossVectors(this, v);\n  \
}\n  crossVectors(a2, b) {\n    const ax = a2.x, ay = a2.y, az = a2.z;\n    \
const bx = b.x, by = b.y, bz = b.z;\n    this.x = ay * bz - az * by;\n    \
this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return \
this;\n  }\n  projectOnVector(v) {\n    const denominator = v.lengthSq();\n   \
 if (denominator === 0) return this.set(0, 0, 0);\n    const scalar = \
v.dot(this) / denominator;\n    return this.copy(v).multiplyScalar(scalar);\n \
 }\n  projectOnPlane(planeNormal) {\n    \
_vector$c.copy(this).projectOnVector(planeNormal);\n    return \
this.sub(_vector$c);\n  }\n  reflect(normal2) {\n    return \
this.sub(_vector$c.copy(normal2).multiplyScalar(2 * this.dot(normal2)));\n  \
}\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * \
v.lengthSq());\n    if (denominator === 0) return Math.PI / 2;\n    const \
theta = this.dot(v) / denominator;\n    return Math.acos(clamp(theta, -1, \
1));\n  }\n  distanceTo(v) {\n    return \
Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    \
const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n    return dx \
* dx + dy * dy + dz * dz;\n  }\n  manhattanDistanceTo(v) {\n    return \
Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n  \
}\n  setFromSpherical(s) {\n    return this.setFromSphericalCoords(s.radius, \
s.phi, s.theta);\n  }\n  setFromSphericalCoords(radius, phi, theta) {\n    \
const sinPhiRadius = Math.sin(phi) * radius;\n    this.x = sinPhiRadius * \
Math.sin(theta);\n    this.y = Math.cos(phi) * radius;\n    this.z = \
sinPhiRadius * Math.cos(theta);\n    return this;\n  }\n  \
setFromCylindrical(c2) {\n    return this.setFromCylindricalCoords(c2.radius, \
c2.theta, c2.y);\n  }\n  setFromCylindricalCoords(radius, theta, y2) {\n    \
this.x = radius * Math.sin(theta);\n    this.y = y2;\n    this.z = radius * \
Math.cos(theta);\n    return this;\n  }\n  setFromMatrixPosition(m2) {\n    \
const e = m2.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z \
= e[14];\n    return this;\n  }\n  setFromMatrixScale(m2) {\n    const sx = \
this.setFromMatrixColumn(m2, 0).length();\n    const sy = \
this.setFromMatrixColumn(m2, 1).length();\n    const sz = \
this.setFromMatrixColumn(m2, 2).length();\n    this.x = sx;\n    this.y = \
sy;\n    this.z = sz;\n    return this;\n  }\n  setFromMatrixColumn(m2, \
index5) {\n    return this.fromArray(m2.elements, index5 * 4);\n  }\n  \
setFromMatrix3Column(m2, index5) {\n    return this.fromArray(m2.elements, \
index5 * 3);\n  }\n  setFromEuler(e) {\n    this.x = e._x;\n    this.y = \
e._y;\n    this.z = e._z;\n    return this;\n  }\n  setFromColor(c2) {\n    \
this.x = c2.r;\n    this.y = c2.g;\n    this.z = c2.b;\n    return this;\n  \
}\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === \
this.z;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n \
   this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return \
this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = \
this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n   \
 return array;\n  }\n  fromBufferAttribute(attribute2, index5) {\n    this.x \
= attribute2.getX(index5);\n    this.y = attribute2.getY(index5);\n    this.z \
= attribute2.getZ(index5);\n    return this;\n  }\n  random() {\n    this.x = \
Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    \
return this;\n  }\n  randomDirection() {\n    const theta = Math.random() * \
Math.PI * 2;\n    const u = Math.random() * 2 - 1;\n    const c2 = \
Math.sqrt(1 - u * u);\n    this.x = c2 * Math.cos(theta);\n    this.y = u;\n  \
  this.z = c2 * Math.sin(theta);\n    return this;\n  }\n  \
*[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield \
this.z;\n  }\n};\nvar _vector$c = /* @__PURE__ */ new Vector3();\nvar \
_quaternion$4 = /* @__PURE__ */ new Quaternion();\nvar Box3 = class {\n  \
constructor(min2 = new Vector3(Infinity, Infinity, Infinity), max2 = new \
Vector3(-Infinity, -Infinity, -Infinity)) {\n    this.isBox3 = true;\n    \
this.min = min2;\n    this.max = max2;\n  }\n  set(min2, max2) {\n    \
this.min.copy(min2);\n    this.max.copy(max2);\n    return this;\n  }\n  \
setFromArray(array) {\n    this.makeEmpty();\n    for (let i = 0, il = \
array.length; i < il; i += 3) {\n      \
this.expandByPoint(_vector$b.fromArray(array, i));\n    }\n    return this;\n \
 }\n  setFromBufferAttribute(attribute2) {\n    this.makeEmpty();\n    for \
(let i = 0, il = attribute2.count; i < il; i++) {\n      \
this.expandByPoint(_vector$b.fromBufferAttribute(attribute2, i));\n    }\n    \
return this;\n  }\n  setFromPoints(points) {\n    this.makeEmpty();\n    for \
(let i = 0, il = points.length; i < il; i++) {\n      \
this.expandByPoint(points[i]);\n    }\n    return this;\n  }\n  \
setFromCenterAndSize(center, size) {\n    const halfSize = \
_vector$b.copy(size).multiplyScalar(0.5);\n    \
this.min.copy(center).sub(halfSize);\n    \
this.max.copy(center).add(halfSize);\n    return this;\n  }\n  \
setFromObject(object, precise = false) {\n    this.makeEmpty();\n    return \
this.expandByObject(object, precise);\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n  copy(box) {\n    \
this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n \
 makeEmpty() {\n    this.min.x = this.min.y = this.min.z = Infinity;\n    \
this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  }\n  \
isEmpty() {\n    return this.max.x < this.min.x || this.max.y < this.min.y || \
this.max.z < this.min.z;\n  }\n  getCenter(target) {\n    return \
this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, \
this.max).multiplyScalar(0.5);\n  }\n  getSize(target) {\n    return \
this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, \
this.min);\n  }\n  expandByPoint(point) {\n    this.min.min(point);\n    \
this.max.max(point);\n    return this;\n  }\n  expandByVector(vector) {\n    \
this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n  \
expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    \
this.max.addScalar(scalar);\n    return this;\n  }\n  expandByObject(object, \
precise = false) {\n    object.updateWorldMatrix(false, false);\n    const \
geometry = object.geometry;\n    if (geometry !== void 0) {\n      const \
positionAttribute = geometry.getAttribute(\"position\");\n      if (precise \
=== true && positionAttribute !== void 0 && object.isInstancedMesh !== true) \
{\n        for (let i = 0, l = positionAttribute.count; i < l; i++) {\n       \
   if (object.isMesh === true) {\n            object.getVertexPosition(i, \
_vector$b);\n          } else {\n            \
_vector$b.fromBufferAttribute(positionAttribute, i);\n          }\n          \
_vector$b.applyMatrix4(object.matrixWorld);\n          \
this.expandByPoint(_vector$b);\n        }\n      } else {\n        if \
(object.boundingBox !== void 0) {\n          if (object.boundingBox === null) \
{\n            object.computeBoundingBox();\n          }\n          \
_box$4.copy(object.boundingBox);\n        } else {\n          if \
(geometry.boundingBox === null) {\n            \
geometry.computeBoundingBox();\n          }\n          \
_box$4.copy(geometry.boundingBox);\n        }\n        \
_box$4.applyMatrix4(object.matrixWorld);\n        this.union(_box$4);\n      \
}\n    }\n    const children = object.children;\n    for (let i = 0, l = \
children.length; i < l; i++) {\n      this.expandByObject(children[i], \
precise);\n    }\n    return this;\n  }\n  containsPoint(point) {\n    return \
point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && \
point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n  \
}\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= \
this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && \
this.min.z <= box.min.z && box.max.z <= this.max.z;\n  }\n  \
getParameter(point, target) {\n    return target.set(\n      (point.x - \
this.min.x) / (this.max.x - this.min.x),\n      (point.y - this.min.y) / \
(this.max.y - this.min.y),\n      (point.z - this.min.z) / (this.max.z - \
this.min.z)\n    );\n  }\n  intersectsBox(box) {\n    return box.max.x >= \
this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y \
<= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n  }\n  \
intersectsSphere(sphere) {\n    this.clampPoint(sphere.center, _vector$b);\n  \
  return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * \
sphere.radius;\n  }\n  intersectsPlane(plane) {\n    let min2, max2;\n    if \
(plane.normal.x > 0) {\n      min2 = plane.normal.x * this.min.x;\n      max2 \
= plane.normal.x * this.max.x;\n    } else {\n      min2 = plane.normal.x * \
this.max.x;\n      max2 = plane.normal.x * this.min.x;\n    }\n    if \
(plane.normal.y > 0) {\n      min2 += plane.normal.y * this.min.y;\n      \
max2 += plane.normal.y * this.max.y;\n    } else {\n      min2 += \
plane.normal.y * this.max.y;\n      max2 += plane.normal.y * this.min.y;\n    \
}\n    if (plane.normal.z > 0) {\n      min2 += plane.normal.z * \
this.min.z;\n      max2 += plane.normal.z * this.max.z;\n    } else {\n      \
min2 += plane.normal.z * this.max.z;\n      max2 += plane.normal.z * \
this.min.z;\n    }\n    return min2 <= -plane.constant && max2 >= \
-plane.constant;\n  }\n  intersectsTriangle(triangle) {\n    if \
(this.isEmpty()) {\n      return false;\n    }\n    \
this.getCenter(_center);\n    _extents.subVectors(this.max, _center);\n    \
_v0$3.subVectors(triangle.a, _center);\n    _v1$7.subVectors(triangle.b, \
_center);\n    _v2$4.subVectors(triangle.c, _center);\n    \
_f0.subVectors(_v1$7, _v0$3);\n    _f1.subVectors(_v2$4, _v1$7);\n    \
_f2.subVectors(_v0$3, _v2$4);\n    let axes = [\n      0,\n      -_f0.z,\n    \
  _f0.y,\n      0,\n      -_f1.z,\n      _f1.y,\n      0,\n      -_f2.z,\n    \
  _f2.y,\n      _f0.z,\n      0,\n      -_f0.x,\n      _f1.z,\n      0,\n     \
 -_f1.x,\n      _f2.z,\n      0,\n      -_f2.x,\n      -_f0.y,\n      \
_f0.x,\n      0,\n      -_f1.y,\n      _f1.x,\n      0,\n      -_f2.y,\n      \
_f2.x,\n      0\n    ];\n    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, \
_extents)) {\n      return false;\n    }\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, \
1];\n    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {\n      \
return false;\n    }\n    _triangleNormal.crossVectors(_f0, _f1);\n    axes = \
[_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n    return \
satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents);\n  }\n  clampPoint(point, \
target) {\n    return target.copy(point).clamp(this.min, this.max);\n  }\n  \
distanceToPoint(point) {\n    return this.clampPoint(point, \
_vector$b).distanceTo(point);\n  }\n  getBoundingSphere(target) {\n    if \
(this.isEmpty()) {\n      target.makeEmpty();\n    } else {\n      \
this.getCenter(target.center);\n      target.radius = \
this.getSize(_vector$b).length() * 0.5;\n    }\n    return target;\n  }\n  \
intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n    \
if (this.isEmpty()) this.makeEmpty();\n    return this;\n  }\n  union(box) \
{\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n \
 }\n  applyMatrix4(matrix) {\n    if (this.isEmpty()) return this;\n    \
_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n    \
_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n    \
_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n    \
_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n    \
_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n    \
_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n    \
_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n    \
_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n    \
this.setFromPoints(_points);\n    return this;\n  }\n  translate(offset) {\n  \
  this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  }\n  \
equals(box) {\n    return box.min.equals(this.min) && \
box.max.equals(this.max);\n  }\n};\nvar _points = [\n  /* @__PURE__ */ new \
Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new \
Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new \
Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new \
Vector3(),\n  /* @__PURE__ */ new Vector3()\n];\nvar _vector$b = /* @__PURE__ \
*/ new Vector3();\nvar _box$4 = /* @__PURE__ */ new Box3();\nvar _v0$3 = /* \
@__PURE__ */ new Vector3();\nvar _v1$7 = /* @__PURE__ */ new Vector3();\nvar \
_v2$4 = /* @__PURE__ */ new Vector3();\nvar _f0 = /* @__PURE__ */ new \
Vector3();\nvar _f1 = /* @__PURE__ */ new Vector3();\nvar _f2 = /* @__PURE__ \
*/ new Vector3();\nvar _center = /* @__PURE__ */ new Vector3();\nvar _extents \
= /* @__PURE__ */ new Vector3();\nvar _triangleNormal = /* @__PURE__ */ new \
Vector3();\nvar _testAxis = /* @__PURE__ */ new Vector3();\nfunction \
satForAxes(axes, v0, v1, v2, extents) {\n  for (let i = 0, j = axes.length - \
3; i <= j; i += 3) {\n    _testAxis.fromArray(axes, i);\n    const r = \
extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + \
extents.z * Math.abs(_testAxis.z);\n    const p0 = v0.dot(_testAxis);\n    \
const p1 = v1.dot(_testAxis);\n    const p2 = v2.dot(_testAxis);\n    if \
(Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      return \
false;\n    }\n  }\n  return true;\n}\nvar _box$3 = /* @__PURE__ */ new \
Box3();\nvar _v1$6 = /* @__PURE__ */ new Vector3();\nvar _v2$3 = /* @__PURE__ \
*/ new Vector3();\nvar Sphere = class {\n  constructor(center = new \
Vector3(), radius = -1) {\n    this.isSphere = true;\n    this.center = \
center;\n    this.radius = radius;\n  }\n  set(center, radius) {\n    \
this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n \
 setFromPoints(points, optionalCenter) {\n    const center = this.center;\n   \
 if (optionalCenter !== void 0) {\n      center.copy(optionalCenter);\n    } \
else {\n      _box$3.setFromPoints(points).getCenter(center);\n    }\n    let \
maxRadiusSq = 0;\n    for (let i = 0, il = points.length; i < il; i++) {\n    \
  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n \
   }\n    this.radius = Math.sqrt(maxRadiusSq);\n    return this;\n  }\n  \
copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = \
sphere.radius;\n    return this;\n  }\n  isEmpty() {\n    return this.radius \
< 0;\n  }\n  makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = \
-1;\n    return this;\n  }\n  containsPoint(point) {\n    return \
point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n  \
distanceToPoint(point) {\n    return point.distanceTo(this.center) - \
this.radius;\n  }\n  intersectsSphere(sphere) {\n    const radiusSum = \
this.radius + sphere.radius;\n    return \
sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n \
 intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n  \
intersectsPlane(plane) {\n    return \
Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n  \
clampPoint(point, target) {\n    const deltaLengthSq = \
this.center.distanceToSquared(point);\n    target.copy(point);\n    if \
(deltaLengthSq > this.radius * this.radius) {\n      \
target.sub(this.center).normalize();\n      \
target.multiplyScalar(this.radius).add(this.center);\n    }\n    return \
target;\n  }\n  getBoundingBox(target) {\n    if (this.isEmpty()) {\n      \
target.makeEmpty();\n      return target;\n    }\n    target.set(this.center, \
this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  \
}\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    \
this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  \
}\n  translate(offset) {\n    this.center.add(offset);\n    return this;\n  \
}\n  expandByPoint(point) {\n    if (this.isEmpty()) {\n      \
this.center.copy(point);\n      this.radius = 0;\n      return this;\n    }\n \
   _v1$6.subVectors(point, this.center);\n    const lengthSq2 = \
_v1$6.lengthSq();\n    if (lengthSq2 > this.radius * this.radius) {\n      \
const length2 = Math.sqrt(lengthSq2);\n      const delta = (length2 - \
this.radius) * 0.5;\n      this.center.addScaledVector(_v1$6, delta / \
length2);\n      this.radius += delta;\n    }\n    return this;\n  }\n  \
union(sphere) {\n    if (sphere.isEmpty()) {\n      return this;\n    }\n    \
if (this.isEmpty()) {\n      this.copy(sphere);\n      return this;\n    }\n  \
  if (this.center.equals(sphere.center) === true) {\n      this.radius = \
Math.max(this.radius, sphere.radius);\n    } else {\n      \
_v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);\n      \
this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));\n      \
this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));\n    }\n    return \
this;\n  }\n  equals(sphere) {\n    return sphere.center.equals(this.center) \
&& sphere.radius === this.radius;\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n};\nvar _vector$a = /* @__PURE__ */ new \
Vector3();\nvar _segCenter = /* @__PURE__ */ new Vector3();\nvar _segDir = /* \
@__PURE__ */ new Vector3();\nvar _diff = /* @__PURE__ */ new Vector3();\nvar \
_edge1 = /* @__PURE__ */ new Vector3();\nvar _edge2 = /* @__PURE__ */ new \
Vector3();\nvar _normal$1 = /* @__PURE__ */ new Vector3();\nvar Ray = class \
{\n  constructor(origin = new Vector3(), direction2 = new Vector3(0, 0, -1)) \
{\n    this.origin = origin;\n    this.direction = direction2;\n  }\n  \
set(origin, direction2) {\n    this.origin.copy(origin);\n    \
this.direction.copy(direction2);\n    return this;\n  }\n  copy(ray) {\n    \
this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n    \
return this;\n  }\n  at(t, target) {\n    return \
target.copy(this.origin).addScaledVector(this.direction, t);\n  }\n  \
lookAt(v) {\n    this.direction.copy(v).sub(this.origin).normalize();\n    \
return this;\n  }\n  recast(t) {\n    this.origin.copy(this.at(t, \
_vector$a));\n    return this;\n  }\n  closestPointToPoint(point, target) {\n \
   target.subVectors(point, this.origin);\n    const directionDistance = \
target.dot(this.direction);\n    if (directionDistance < 0) {\n      return \
target.copy(this.origin);\n    }\n    return \
target.copy(this.origin).addScaledVector(this.direction, \
directionDistance);\n  }\n  distanceToPoint(point) {\n    return \
Math.sqrt(this.distanceSqToPoint(point));\n  }\n  distanceSqToPoint(point) \
{\n    const directionDistance = _vector$a.subVectors(point, \
this.origin).dot(this.direction);\n    if (directionDistance < 0) {\n      \
return this.origin.distanceToSquared(point);\n    }\n    \
_vector$a.copy(this.origin).addScaledVector(this.direction, \
directionDistance);\n    return _vector$a.distanceToSquared(point);\n  }\n  \
distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n   \
 _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n    \
_segDir.copy(v1).sub(v0).normalize();\n    \
_diff.copy(this.origin).sub(_segCenter);\n    const segExtent = \
v0.distanceTo(v1) * 0.5;\n    const a01 = -this.direction.dot(_segDir);\n    \
const b0 = _diff.dot(this.direction);\n    const b1 = -_diff.dot(_segDir);\n  \
  const c2 = _diff.lengthSq();\n    const det = Math.abs(1 - a01 * a01);\n    \
let s0, s1, sqrDist, extDet;\n    if (det > 0) {\n      s0 = a01 * b1 - b0;\n \
     s1 = a01 * b0 - b1;\n      extDet = segExtent * det;\n      if (s0 >= 0) \
{\n        if (s1 >= -extDet) {\n          if (s1 <= extDet) {\n            \
const invDet = 1 / det;\n            s0 *= invDet;\n            s1 *= \
invDet;\n            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 \
+ s1 + 2 * b1) + c2;\n          } else {\n            s1 = segExtent;\n       \
     s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 \
* (s1 + 2 * b1) + c2;\n          }\n        } else {\n          s1 = \
-segExtent;\n          s0 = Math.max(0, -(a01 * s1 + b0));\n          sqrDist \
= -s0 * s0 + s1 * (s1 + 2 * b1) + c2;\n        }\n      } else {\n        if \
(s1 <= -extDet) {\n          s0 = Math.max(0, -(-a01 * segExtent + b0));\n    \
      s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), \
segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;\n        \
} else if (s1 <= extDet) {\n          s0 = 0;\n          s1 = \
Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = s1 * (s1 \
+ 2 * b1) + c2;\n        } else {\n          s0 = Math.max(0, -(a01 * \
segExtent + b0));\n          s1 = s0 > 0 ? segExtent : \
Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 \
+ s1 * (s1 + 2 * b1) + c2;\n        }\n      }\n    } else {\n      s1 = a01 \
> 0 ? -segExtent : segExtent;\n      s0 = Math.max(0, -(a01 * s1 + b0));\n    \
  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;\n    }\n    if \
(optionalPointOnRay) {\n      \
optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n   \
 }\n    if (optionalPointOnSegment) {\n      \
optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);\n    \
}\n    return sqrDist;\n  }\n  intersectSphere(sphere, target) {\n    \
_vector$a.subVectors(sphere.center, this.origin);\n    const tca = \
_vector$a.dot(this.direction);\n    const d2 = _vector$a.dot(_vector$a) - tca \
* tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > \
radius2) return null;\n    const thc = Math.sqrt(radius2 - d2);\n    const t0 \
= tca - thc;\n    const t1 = tca + thc;\n    if (t1 < 0) return null;\n    if \
(t0 < 0) return this.at(t1, target);\n    return this.at(t0, target);\n  }\n  \
intersectsSphere(sphere) {\n    return this.distanceSqToPoint(sphere.center) \
<= sphere.radius * sphere.radius;\n  }\n  distanceToPlane(plane) {\n    const \
denominator = plane.normal.dot(this.direction);\n    if (denominator === 0) \
{\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n \
     }\n      return null;\n    }\n    const t = \
-(this.origin.dot(plane.normal) + plane.constant) / denominator;\n    return \
t >= 0 ? t : null;\n  }\n  intersectPlane(plane, target) {\n    const t = \
this.distanceToPlane(plane);\n    if (t === null) {\n      return null;\n    \
}\n    return this.at(t, target);\n  }\n  intersectsPlane(plane) {\n    const \
distToPoint = plane.distanceToPoint(this.origin);\n    if (distToPoint === 0) \
{\n      return true;\n    }\n    const denominator = \
plane.normal.dot(this.direction);\n    if (denominator * distToPoint < 0) {\n \
     return true;\n    }\n    return false;\n  }\n  intersectBox(box, target) \
{\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / \
this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / \
this.direction.z;\n    const origin = this.origin;\n    if (invdirx >= 0) {\n \
     tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - \
origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * \
invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n    if \
(invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      \
tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = \
(box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * \
invdiry;\n    }\n    if (tmin > tymax || tymin > tmax) return null;\n    if \
(tymin > tmin || isNaN(tmin)) tmin = tymin;\n    if (tymax < tmax || \
isNaN(tmax)) tmax = tymax;\n    if (invdirz >= 0) {\n      tzmin = (box.min.z \
- origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    \
} else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = \
(box.min.z - origin.z) * invdirz;\n    }\n    if (tmin > tzmax || tzmin > \
tmax) return null;\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n    \
if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n    if (tmax < 0) return \
null;\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n  \
intersectsBox(box) {\n    return this.intersectBox(box, _vector$a) !== \
null;\n  }\n  intersectTriangle(a2, b, c2, backfaceCulling, target) {\n    \
_edge1.subVectors(b, a2);\n    _edge2.subVectors(c2, a2);\n    \
_normal$1.crossVectors(_edge1, _edge2);\n    let DdN = \
this.direction.dot(_normal$1);\n    let sign2;\n    if (DdN > 0) {\n      if \
(backfaceCulling) return null;\n      sign2 = 1;\n    } else if (DdN < 0) {\n \
     sign2 = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    \
}\n    _diff.subVectors(this.origin, a2);\n    const DdQxE2 = sign2 * \
this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n    if (DdQxE2 < 0) \
{\n      return null;\n    }\n    const DdE1xQ = sign2 * \
this.direction.dot(_edge1.cross(_diff));\n    if (DdE1xQ < 0) {\n      return \
null;\n    }\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n    }\n   \
 const QdN = -sign2 * _diff.dot(_normal$1);\n    if (QdN < 0) {\n      return \
null;\n    }\n    return this.at(QdN / DdN, target);\n  }\n  \
applyMatrix4(matrix4) {\n    this.origin.applyMatrix4(matrix4);\n    \
this.direction.transformDirection(matrix4);\n    return this;\n  }\n  \
equals(ray) {\n    return ray.origin.equals(this.origin) && \
ray.direction.equals(this.direction);\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n};\nvar Matrix4 = class _Matrix4 {\n  \
constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, \
n42, n43, n44) {\n    _Matrix4.prototype.isMatrix4 = true;\n    this.elements \
= [\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n   \
   0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n \
     1\n    ];\n    if (n11 !== void 0) {\n      this.set(n11, n12, n13, n14, \
n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n    }\n  }\n  \
set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, \
n43, n44) {\n    const te = this.elements;\n    te[0] = n11;\n    te[4] = \
n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = \
n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = \
n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = \
n42;\n    te[11] = n43;\n    te[15] = n44;\n    return this;\n  }\n  \
identity() {\n    this.set(\n      1,\n      0,\n      0,\n      0,\n      \
0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n    \
  0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  clone() \
{\n    return new _Matrix4().fromArray(this.elements);\n  }\n  copy(m2) {\n   \
 const te = this.elements;\n    const me = m2.elements;\n    te[0] = me[0];\n \
   te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = \
me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] \
= me[8];\n    te[9] = me[9];\n    te[10] = me[10];\n    te[11] = me[11];\n    \
te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    te[15] = \
me[15];\n    return this;\n  }\n  copyPosition(m2) {\n    const te = \
this.elements, me = m2.elements;\n    te[12] = me[12];\n    te[13] = \
me[13];\n    te[14] = me[14];\n    return this;\n  }\n  setFromMatrix3(m2) \
{\n    const me = m2.elements;\n    this.set(\n      me[0],\n      me[3],\n   \
   me[6],\n      0,\n      me[1],\n      me[4],\n      me[7],\n      0,\n     \
 me[2],\n      me[5],\n      me[8],\n      0,\n      0,\n      0,\n      0,\n \
     1\n    );\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) \
{\n    xAxis.setFromMatrixColumn(this, 0);\n    \
yAxis.setFromMatrixColumn(this, 1);\n    zAxis.setFromMatrixColumn(this, \
2);\n    return this;\n  }\n  makeBasis(xAxis, yAxis, zAxis) {\n    \
this.set(\n      xAxis.x,\n      yAxis.x,\n      zAxis.x,\n      0,\n      \
xAxis.y,\n      yAxis.y,\n      zAxis.y,\n      0,\n      xAxis.z,\n      \
yAxis.z,\n      zAxis.z,\n      0,\n      0,\n      0,\n      0,\n      1\n   \
 );\n    return this;\n  }\n  extractRotation(m2) {\n    const te = \
this.elements;\n    const me = m2.elements;\n    const scaleX = 1 / \
_v1$5.setFromMatrixColumn(m2, 0).length();\n    const scaleY = 1 / \
_v1$5.setFromMatrixColumn(m2, 1).length();\n    const scaleZ = 1 / \
_v1$5.setFromMatrixColumn(m2, 2).length();\n    te[0] = me[0] * scaleX;\n    \
te[1] = me[1] * scaleX;\n    te[2] = me[2] * scaleX;\n    te[3] = 0;\n    \
te[4] = me[4] * scaleY;\n    te[5] = me[5] * scaleY;\n    te[6] = me[6] * \
scaleY;\n    te[7] = 0;\n    te[8] = me[8] * scaleZ;\n    te[9] = me[9] * \
scaleZ;\n    te[10] = me[10] * scaleZ;\n    te[11] = 0;\n    te[12] = 0;\n    \
te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  \
makeRotationFromEuler(euler) {\n    const te = this.elements;\n    const x2 = \
euler.x, y2 = euler.y, z2 = euler.z;\n    const a2 = Math.cos(x2), b = \
Math.sin(x2);\n    const c2 = Math.cos(y2), d = Math.sin(y2);\n    const e = \
Math.cos(z2), f = Math.sin(z2);\n    if (euler.order === \"XYZ\") {\n      \
const ae = a2 * e, af = a2 * f, be = b * e, bf = b * f;\n      te[0] = c2 * \
e;\n      te[4] = -c2 * f;\n      te[8] = d;\n      te[1] = af + be * d;\n    \
  te[5] = ae - bf * d;\n      te[9] = -b * c2;\n      te[2] = bf - ae * d;\n  \
    te[6] = be + af * d;\n      te[10] = a2 * c2;\n    } else if (euler.order \
=== \"YXZ\") {\n      const ce = c2 * e, cf = c2 * f, de = d * e, df = d * \
f;\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a2 \
* d;\n      te[1] = a2 * f;\n      te[5] = a2 * e;\n      te[9] = -b;\n      \
te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a2 * c2;\n   \
 } else if (euler.order === \"ZXY\") {\n      const ce = c2 * e, cf = c2 * f, \
de = d * e, df = d * f;\n      te[0] = ce - df * b;\n      te[4] = -a2 * f;\n \
     te[8] = de + cf * b;\n      te[1] = cf + de * b;\n      te[5] = a2 * \
e;\n      te[9] = df - ce * b;\n      te[2] = -a2 * d;\n      te[6] = b;\n    \
  te[10] = a2 * c2;\n    } else if (euler.order === \"ZYX\") {\n      const \
ae = a2 * e, af = a2 * f, be = b * e, bf = b * f;\n      te[0] = c2 * e;\n    \
  te[4] = be * d - af;\n      te[8] = ae * d + bf;\n      te[1] = c2 * f;\n   \
   te[5] = bf * d + ae;\n      te[9] = af * d - be;\n      te[2] = -d;\n      \
te[6] = b * c2;\n      te[10] = a2 * c2;\n    } else if (euler.order === \
\"YZX\") {\n      const ac = a2 * c2, ad = a2 * d, bc = b * c2, bd = b * d;\n \
     te[0] = c2 * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + \
ad;\n      te[1] = f;\n      te[5] = a2 * e;\n      te[9] = -b * e;\n      \
te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    \
} else if (euler.order === \"XZY\") {\n      const ac = a2 * c2, ad = a2 * d, \
bc = b * c2, bd = b * d;\n      te[0] = c2 * e;\n      te[4] = -f;\n      \
te[8] = d * e;\n      te[1] = ac * f + bd;\n      te[5] = a2 * e;\n      \
te[9] = ad * f - bc;\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      \
te[10] = bd * f + ac;\n    }\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = \
0;\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    \
return this;\n  }\n  makeRotationFromQuaternion(q) {\n    return \
this.compose(_zero, q, _one);\n  }\n  lookAt(eye, target, up) {\n    const te \
= this.elements;\n    _z.subVectors(eye, target);\n    if (_z.lengthSq() === \
0) {\n      _z.z = 1;\n    }\n    _z.normalize();\n    _x.crossVectors(up, \
_z);\n    if (_x.lengthSq() === 0) {\n      if (Math.abs(up.z) === 1) {\n     \
   _z.x += 1e-4;\n      } else {\n        _z.z += 1e-4;\n      }\n      \
_z.normalize();\n      _x.crossVectors(up, _z);\n    }\n    _x.normalize();\n \
   _y.crossVectors(_z, _x);\n    te[0] = _x.x;\n    te[4] = _y.x;\n    te[8] \
= _z.x;\n    te[1] = _x.y;\n    te[5] = _y.y;\n    te[9] = _z.y;\n    te[2] = \
_x.z;\n    te[6] = _y.z;\n    te[10] = _z.z;\n    return this;\n  }\n  \
multiply(m2) {\n    return this.multiplyMatrices(this, m2);\n  }\n  \
premultiply(m2) {\n    return this.multiplyMatrices(m2, this);\n  }\n  \
multiplyMatrices(a2, b) {\n    const ae = a2.elements;\n    const be = \
b.elements;\n    const te = this.elements;\n    const a11 = ae[0], a12 = \
ae[4], a13 = ae[8], a14 = ae[12];\n    const a21 = ae[1], a22 = ae[5], a23 = \
ae[9], a24 = ae[13];\n    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = \
ae[14];\n    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n    \
const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n    const b21 = \
be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n    const b31 = be[2], b32 = \
be[6], b33 = be[10], b34 = be[14];\n    const b41 = be[3], b42 = be[7], b43 = \
be[11], b44 = be[15];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * \
b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = \
a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 \
* b24 + a13 * b34 + a14 * b44;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 \
+ a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    \
te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * \
b14 + a22 * b24 + a23 * b34 + a24 * b44;\n    te[2] = a31 * b11 + a32 * b21 + \
a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * \
b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] \
= a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n    te[3] = a41 * b11 + a42 \
* b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 \
+ a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n   \
 te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n    return this;\n  \
}\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    \
te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= \
s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    \
te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] \
*= s;\n    te[15] *= s;\n    return this;\n  }\n  determinant() {\n    const \
te = this.elements;\n    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = \
te[12];\n    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n    \
const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n    const n41 = \
te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n    return n41 * (+n14 * n23 \
* n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 \
- n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * \
n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * \
n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * \
n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * \
n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n  }\n  \
transpose() {\n    const te = this.elements;\n    let tmp2;\n    tmp2 = \
te[1];\n    te[1] = te[4];\n    te[4] = tmp2;\n    tmp2 = te[2];\n    te[2] = \
te[8];\n    te[8] = tmp2;\n    tmp2 = te[6];\n    te[6] = te[9];\n    te[9] = \
tmp2;\n    tmp2 = te[3];\n    te[3] = te[12];\n    te[12] = tmp2;\n    tmp2 = \
te[7];\n    te[7] = te[13];\n    te[13] = tmp2;\n    tmp2 = te[11];\n    \
te[11] = te[14];\n    te[14] = tmp2;\n    return this;\n  }\n  \
setPosition(x2, y2, z2) {\n    const te = this.elements;\n    if \
(x2.isVector3) {\n      te[12] = x2.x;\n      te[13] = x2.y;\n      te[14] = \
x2.z;\n    } else {\n      te[12] = x2;\n      te[13] = y2;\n      te[14] = \
z2;\n    }\n    return this;\n  }\n  invert() {\n    const te = \
this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = \
te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = \
te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], \
t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - \
n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - \
n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = \
n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * \
n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * \
n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n    const \
det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n    if (det === 0) \
return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const \
detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n24 * n33 * n41 - \
n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * \
n33 * n44) * detInv;\n    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * \
n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n  \
  te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * \
n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n    te[4] = t12 * \
detInv;\n    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - \
n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n    te[6] = \
(n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 \
* n31 * n44 - n11 * n32 * n44) * detInv;\n    te[7] = (n12 * n33 * n41 - n13 \
* n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 \
* n43) * detInv;\n    te[8] = t13 * detInv;\n    te[9] = (n14 * n23 * n41 - \
n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * \
n23 * n44) * detInv;\n    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * \
n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n  \
  te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * \
n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n    te[12] = t14 * \
detInv;\n    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - \
n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n    te[14] = \
(n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 \
* n21 * n34 - n11 * n22 * n34) * detInv;\n    te[15] = (n12 * n23 * n31 - n13 \
* n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 \
* n33) * detInv;\n    return this;\n  }\n  scale(v) {\n    const te = \
this.elements;\n    const x2 = v.x, y2 = v.y, z2 = v.z;\n    te[0] *= x2;\n   \
 te[4] *= y2;\n    te[8] *= z2;\n    te[1] *= x2;\n    te[5] *= y2;\n    \
te[9] *= z2;\n    te[2] *= x2;\n    te[6] *= y2;\n    te[10] *= z2;\n    \
te[3] *= x2;\n    te[7] *= y2;\n    te[11] *= z2;\n    return this;\n  }\n  \
getMaxScaleOnAxis() {\n    const te = this.elements;\n    const scaleXSq = \
te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq = te[4] * \
te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq = te[8] * te[8] + \
te[9] * te[9] + te[10] * te[10];\n    return Math.sqrt(Math.max(scaleXSq, \
scaleYSq, scaleZSq));\n  }\n  makeTranslation(x2, y2, z2) {\n    if \
(x2.isVector3) {\n      this.set(\n        1,\n        0,\n        0,\n       \
 x2.x,\n        0,\n        1,\n        0,\n        x2.y,\n        0,\n       \
 0,\n        1,\n        x2.z,\n        0,\n        0,\n        0,\n        \
1\n      );\n    } else {\n      this.set(\n        1,\n        0,\n        \
0,\n        x2,\n        0,\n        1,\n        0,\n        y2,\n        \
0,\n        0,\n        1,\n        z2,\n        0,\n        0,\n        0,\n \
       1\n      );\n    }\n    return this;\n  }\n  makeRotationX(theta) {\n  \
  const c2 = Math.cos(theta), s = Math.sin(theta);\n    this.set(\n      1,\n \
     0,\n      0,\n      0,\n      0,\n      c2,\n      -s,\n      0,\n      \
0,\n      s,\n      c2,\n      0,\n      0,\n      0,\n      0,\n      1\n    \
);\n    return this;\n  }\n  makeRotationY(theta) {\n    const c2 = \
Math.cos(theta), s = Math.sin(theta);\n    this.set(\n      c2,\n      0,\n   \
   s,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -s,\n      \
0,\n      c2,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    \
return this;\n  }\n  makeRotationZ(theta) {\n    const c2 = Math.cos(theta), \
s = Math.sin(theta);\n    this.set(\n      c2,\n      -s,\n      0,\n      \
0,\n      s,\n      c2,\n      0,\n      0,\n      0,\n      0,\n      1,\n   \
   0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n \
 makeRotationAxis(axis, angle) {\n    const c2 = Math.cos(angle);\n    const \
s = Math.sin(angle);\n    const t = 1 - c2;\n    const x2 = axis.x, y2 = \
axis.y, z2 = axis.z;\n    const tx = t * x2, ty = t * y2;\n    this.set(\n    \
  tx * x2 + c2,\n      tx * y2 - s * z2,\n      tx * z2 + s * y2,\n      0,\n \
     tx * y2 + s * z2,\n      ty * y2 + c2,\n      ty * z2 - s * x2,\n      \
0,\n      tx * z2 - s * y2,\n      ty * z2 + s * x2,\n      t * z2 * z2 + \
c2,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return \
this;\n  }\n  makeScale(x2, y2, z2) {\n    this.set(\n      x2,\n      0,\n   \
   0,\n      0,\n      0,\n      y2,\n      0,\n      0,\n      0,\n      \
0,\n      z2,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    \
return this;\n  }\n  makeShear(xy, xz, yx, yz, zx, zy) {\n    this.set(\n     \
 1,\n      yx,\n      zx,\n      0,\n      xy,\n      1,\n      zy,\n      \
0,\n      xz,\n      yz,\n      1,\n      0,\n      0,\n      0,\n      0,\n  \
    1\n    );\n    return this;\n  }\n  compose(position, quaternion, scale) \
{\n    const te = this.elements;\n    const x2 = quaternion._x, y2 = \
quaternion._y, z2 = quaternion._z, w = quaternion._w;\n    const x22 = x2 + \
x2, y22 = y2 + y2, z22 = z2 + z2;\n    const xx = x2 * x22, xy = x2 * y22, xz \
= x2 * z22;\n    const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;\n    \
const wx = w * x22, wy = w * y22, wz = w * z22;\n    const sx = scale.x, sy = \
scale.y, sz = scale.z;\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + \
wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) \
* sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    \
te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    \
te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = position.x;\n   \
 te[13] = position.y;\n    te[14] = position.z;\n    te[15] = 1;\n    return \
this;\n  }\n  decompose(position, quaternion, scale) {\n    const te = \
this.elements;\n    let sx = _v1$5.set(te[0], te[1], te[2]).length();\n    \
const sy = _v1$5.set(te[4], te[5], te[6]).length();\n    const sz = \
_v1$5.set(te[8], te[9], te[10]).length();\n    const det = \
this.determinant();\n    if (det < 0) sx = -sx;\n    position.x = te[12];\n   \
 position.y = te[13];\n    position.z = te[14];\n    _m1$4.copy(this);\n    \
const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n \
   _m1$4.elements[0] *= invSX;\n    _m1$4.elements[1] *= invSX;\n    \
_m1$4.elements[2] *= invSX;\n    _m1$4.elements[4] *= invSY;\n    \
_m1$4.elements[5] *= invSY;\n    _m1$4.elements[6] *= invSY;\n    \
_m1$4.elements[8] *= invSZ;\n    _m1$4.elements[9] *= invSZ;\n    \
_m1$4.elements[10] *= invSZ;\n    quaternion.setFromRotationMatrix(_m1$4);\n  \
  scale.x = sx;\n    scale.y = sy;\n    scale.z = sz;\n    return this;\n  \
}\n  makePerspective(left, right, top, bottom, near, far, coordinateSystem = \
WebGLCoordinateSystem) {\n    const te = this.elements;\n    const x2 = 2 * \
near / (right - left);\n    const y2 = 2 * near / (top - bottom);\n    const \
a2 = (right + left) / (right - left);\n    const b = (top + bottom) / (top - \
bottom);\n    let c2, d;\n    if (coordinateSystem === WebGLCoordinateSystem) \
{\n      c2 = -(far + near) / (far - near);\n      d = -2 * far * near / (far \
- near);\n    } else if (coordinateSystem === WebGPUCoordinateSystem) {\n     \
 c2 = -far / (far - near);\n      d = -far * near / (far - near);\n    } else \
{\n      throw new Error(\"THREE.Matrix4.makePerspective(): Invalid \
coordinate system: \" + coordinateSystem);\n    }\n    te[0] = x2;\n    te[4] \
= 0;\n    te[8] = a2;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y2;\n    \
te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = \
c2;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    \
te[15] = 0;\n    return this;\n  }\n  makeOrthographic(left, right, top, \
bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n    const te \
= this.elements;\n    const w = 1 / (right - left);\n    const h = 1 / (top - \
bottom);\n    const p = 1 / (far - near);\n    const x2 = (right + left) * \
w;\n    const y2 = (top + bottom) * h;\n    let z2, zInv;\n    if \
(coordinateSystem === WebGLCoordinateSystem) {\n      z2 = (far + near) * \
p;\n      zInv = -2 * p;\n    } else if (coordinateSystem === \
WebGPUCoordinateSystem) {\n      z2 = near * p;\n      zInv = -1 * p;\n    } \
else {\n      throw new Error(\"THREE.Matrix4.makeOrthographic(): Invalid \
coordinate system: \" + coordinateSystem);\n    }\n    te[0] = 2 * w;\n    \
te[4] = 0;\n    te[8] = 0;\n    te[12] = -x2;\n    te[1] = 0;\n    te[5] = 2 \
* h;\n    te[9] = 0;\n    te[13] = -y2;\n    te[2] = 0;\n    te[6] = 0;\n    \
te[10] = zInv;\n    te[14] = -z2;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] \
= 0;\n    te[15] = 1;\n    return this;\n  }\n  equals(matrix) {\n    const \
te = this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < \
16; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return \
true;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 16; \
i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return \
this;\n  }\n  toArray(array = [], offset = 0) {\n    const te = \
this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n  \
  array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    \
array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset \
+ 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = \
te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    \
array[offset + 11] = te[11];\n    array[offset + 12] = te[12];\n    \
array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    \
array[offset + 15] = te[15];\n    return array;\n  }\n};\nvar _v1$5 = /* \
@__PURE__ */ new Vector3();\nvar _m1$4 = /* @__PURE__ */ new Matrix4();\nvar \
_zero = /* @__PURE__ */ new Vector3(0, 0, 0);\nvar _one = /* @__PURE__ */ new \
Vector3(1, 1, 1);\nvar _x = /* @__PURE__ */ new Vector3();\nvar _y = /* \
@__PURE__ */ new Vector3();\nvar _z = /* @__PURE__ */ new Vector3();\nvar \
_matrix$2 = /* @__PURE__ */ new Matrix4();\nvar _quaternion$3 = /* @__PURE__ \
*/ new Quaternion();\nvar Euler = class _Euler {\n  constructor(x2 = 0, y2 = \
0, z2 = 0, order = _Euler.DEFAULT_ORDER) {\n    this.isEuler = true;\n    \
this._x = x2;\n    this._y = y2;\n    this._z = z2;\n    this._order = \
order;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    \
this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return \
this._y;\n  }\n  set y(value) {\n    this._y = value;\n    \
this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set \
z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get \
order() {\n    return this._order;\n  }\n  set order(value) {\n    \
this._order = value;\n    this._onChangeCallback();\n  }\n  set(x2, y2, z2, \
order = this._order) {\n    this._x = x2;\n    this._y = y2;\n    this._z = \
z2;\n    this._order = order;\n    this._onChangeCallback();\n    return \
this;\n  }\n  clone() {\n    return new this.constructor(this._x, this._y, \
this._z, this._order);\n  }\n  copy(euler) {\n    this._x = euler._x;\n    \
this._y = euler._y;\n    this._z = euler._z;\n    this._order = \
euler._order;\n    this._onChangeCallback();\n    return this;\n  }\n  \
setFromRotationMatrix(m2, order = this._order, update4 = true) {\n    const \
te = m2.elements;\n    const m11 = te[0], m12 = te[4], m13 = te[8];\n    \
const m21 = te[1], m22 = te[5], m23 = te[9];\n    const m31 = te[2], m32 = \
te[6], m33 = te[10];\n    switch (order) {\n      case \"XYZ\":\n        \
this._y = Math.asin(clamp(m13, -1, 1));\n        if (Math.abs(m13) < \
0.9999999) {\n          this._x = Math.atan2(-m23, m33);\n          this._z = \
Math.atan2(-m12, m11);\n        } else {\n          this._x = Math.atan2(m32, \
m22);\n          this._z = 0;\n        }\n        break;\n      case \
\"YXZ\":\n        this._x = Math.asin(-clamp(m23, -1, 1));\n        if \
(Math.abs(m23) < 0.9999999) {\n          this._y = Math.atan2(m13, m33);\n    \
      this._z = Math.atan2(m21, m22);\n        } else {\n          this._y = \
Math.atan2(-m31, m11);\n          this._z = 0;\n        }\n        break;\n   \
   case \"ZXY\":\n        this._x = Math.asin(clamp(m32, -1, 1));\n        if \
(Math.abs(m32) < 0.9999999) {\n          this._y = Math.atan2(-m31, m33);\n   \
       this._z = Math.atan2(-m12, m22);\n        } else {\n          this._y \
= 0;\n          this._z = Math.atan2(m21, m11);\n        }\n        break;\n  \
    case \"ZYX\":\n        this._y = Math.asin(-clamp(m31, -1, 1));\n        \
if (Math.abs(m31) < 0.9999999) {\n          this._x = Math.atan2(m32, m33);\n \
         this._z = Math.atan2(m21, m11);\n        } else {\n          this._x \
= 0;\n          this._z = Math.atan2(-m12, m22);\n        }\n        break;\n \
     case \"YZX\":\n        this._z = Math.asin(clamp(m21, -1, 1));\n        \
if (Math.abs(m21) < 0.9999999) {\n          this._x = Math.atan2(-m23, \
m22);\n          this._y = Math.atan2(-m31, m11);\n        } else {\n         \
 this._x = 0;\n          this._y = Math.atan2(m13, m33);\n        }\n        \
break;\n      case \"XZY\":\n        this._z = Math.asin(-clamp(m12, -1, \
1));\n        if (Math.abs(m12) < 0.9999999) {\n          this._x = \
Math.atan2(m32, m22);\n          this._y = Math.atan2(m13, m11);\n        } \
else {\n          this._x = Math.atan2(-m23, m33);\n          this._y = 0;\n  \
      }\n        break;\n      default:\n        console.warn(\"THREE.Euler: \
.setFromRotationMatrix() encountered an unknown order: \" + order);\n    }\n  \
  this._order = order;\n    if (update4 === true) this._onChangeCallback();\n \
   return this;\n  }\n  setFromQuaternion(q, order, update4) {\n    \
_matrix$2.makeRotationFromQuaternion(q);\n    return \
this.setFromRotationMatrix(_matrix$2, order, update4);\n  }\n  \
setFromVector3(v, order = this._order) {\n    return this.set(v.x, v.y, v.z, \
order);\n  }\n  reorder(newOrder) {\n    _quaternion$3.setFromEuler(this);\n  \
  return this.setFromQuaternion(_quaternion$3, newOrder);\n  }\n  \
equals(euler) {\n    return euler._x === this._x && euler._y === this._y && \
euler._z === this._z && euler._order === this._order;\n  }\n  \
fromArray(array) {\n    this._x = array[0];\n    this._y = array[1];\n    \
this._z = array[2];\n    if (array[3] !== void 0) this._order = array[3];\n   \
 this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], \
offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = \
this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = \
this._order;\n    return array;\n  }\n  _onChange(callback) {\n    \
this._onChangeCallback = callback;\n    return this;\n  }\n  \
_onChangeCallback() {\n  }\n  *[Symbol.iterator]() {\n    yield this._x;\n    \
yield this._y;\n    yield this._z;\n    yield this._order;\n  \
}\n};\nEuler.DEFAULT_ORDER = \"XYZ\";\nvar Layers = class {\n  constructor() \
{\n    this.mask = 1 | 0;\n  }\n  set(channel) {\n    this.mask = (1 << \
channel | 0) >>> 0;\n  }\n  enable(channel) {\n    this.mask |= 1 << channel \
| 0;\n  }\n  enableAll() {\n    this.mask = 4294967295 | 0;\n  }\n  \
toggle(channel) {\n    this.mask ^= 1 << channel | 0;\n  }\n  \
disable(channel) {\n    this.mask &= ~(1 << channel | 0);\n  }\n  \
disableAll() {\n    this.mask = 0;\n  }\n  test(layers) {\n    return \
(this.mask & layers.mask) !== 0;\n  }\n  isEnabled(channel) {\n    return \
(this.mask & (1 << channel | 0)) !== 0;\n  }\n};\nvar _object3DId = 0;\nvar \
_v1$4 = /* @__PURE__ */ new Vector3();\nvar _q1 = /* @__PURE__ */ new \
Quaternion();\nvar _m1$3 = /* @__PURE__ */ new Matrix4();\nvar _target = /* \
@__PURE__ */ new Vector3();\nvar _position$3 = /* @__PURE__ */ new \
Vector3();\nvar _scale$2 = /* @__PURE__ */ new Vector3();\nvar _quaternion$2 \
= /* @__PURE__ */ new Quaternion();\nvar _xAxis = /* @__PURE__ */ new \
Vector3(1, 0, 0);\nvar _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);\nvar \
_zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);\nvar _addedEvent = { type: \
\"added\" };\nvar _removedEvent = { type: \"removed\" };\nvar \
_childaddedEvent = { type: \"childadded\", child: null };\nvar \
_childremovedEvent = { type: \"childremoved\", child: null };\nvar Object3D = \
class _Object3D extends EventDispatcher {\n  constructor() {\n    super();\n  \
  this.isObject3D = true;\n    Object.defineProperty(this, \"id\", { value: \
_object3DId++ });\n    this.uuid = generateUUID();\n    this.name = \"\";\n   \
 this.type = \"Object3D\";\n    this.parent = null;\n    this.children = \
[];\n    this.up = _Object3D.DEFAULT_UP.clone();\n    const position = new \
Vector3();\n    const rotation = new Euler();\n    const quaternion = new \
Quaternion();\n    const scale = new Vector3(1, 1, 1);\n    function \
onRotationChange() {\n      quaternion.setFromEuler(rotation, false);\n    \
}\n    function onQuaternionChange() {\n      \
rotation.setFromQuaternion(quaternion, void 0, false);\n    }\n    \
rotation._onChange(onRotationChange);\n    \
quaternion._onChange(onQuaternionChange);\n    Object.defineProperties(this, \
{\n      position: {\n        configurable: true,\n        enumerable: \
true,\n        value: position\n      },\n      rotation: {\n        \
configurable: true,\n        enumerable: true,\n        value: rotation\n     \
 },\n      quaternion: {\n        configurable: true,\n        enumerable: \
true,\n        value: quaternion\n      },\n      scale: {\n        \
configurable: true,\n        enumerable: true,\n        value: scale\n      \
},\n      modelViewMatrix: {\n        value: new Matrix4()\n      },\n      \
normalMatrix: {\n        value: new Matrix3()\n      }\n    });\n    \
this.matrix = new Matrix4();\n    this.matrixWorld = new Matrix4();\n    \
this.matrixAutoUpdate = _Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n    \
this.matrixWorldAutoUpdate = _Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;\n    \
this.matrixWorldNeedsUpdate = false;\n    this.layers = new Layers();\n    \
this.visible = true;\n    this.castShadow = false;\n    this.receiveShadow = \
false;\n    this.frustumCulled = true;\n    this.renderOrder = 0;\n    \
this.animations = [];\n    this.userData = {};\n  }\n  onBeforeShadow() {\n  \
}\n  onAfterShadow() {\n  }\n  onBeforeRender() {\n  }\n  onAfterRender() {\n \
 }\n  applyMatrix4(matrix) {\n    if (this.matrixAutoUpdate) \
this.updateMatrix();\n    this.matrix.premultiply(matrix);\n    \
this.matrix.decompose(this.position, this.quaternion, this.scale);\n  }\n  \
applyQuaternion(q) {\n    this.quaternion.premultiply(q);\n    return this;\n \
 }\n  setRotationFromAxisAngle(axis, angle) {\n    \
this.quaternion.setFromAxisAngle(axis, angle);\n  }\n  \
setRotationFromEuler(euler) {\n    this.quaternion.setFromEuler(euler, \
true);\n  }\n  setRotationFromMatrix(m2) {\n    \
this.quaternion.setFromRotationMatrix(m2);\n  }\n  \
setRotationFromQuaternion(q) {\n    this.quaternion.copy(q);\n  }\n  \
rotateOnAxis(axis, angle) {\n    _q1.setFromAxisAngle(axis, angle);\n    \
this.quaternion.multiply(_q1);\n    return this;\n  }\n  \
rotateOnWorldAxis(axis, angle) {\n    _q1.setFromAxisAngle(axis, angle);\n    \
this.quaternion.premultiply(_q1);\n    return this;\n  }\n  rotateX(angle) \
{\n    return this.rotateOnAxis(_xAxis, angle);\n  }\n  rotateY(angle) {\n    \
return this.rotateOnAxis(_yAxis, angle);\n  }\n  rotateZ(angle) {\n    return \
this.rotateOnAxis(_zAxis, angle);\n  }\n  translateOnAxis(axis, distance2) \
{\n    _v1$4.copy(axis).applyQuaternion(this.quaternion);\n    \
this.position.add(_v1$4.multiplyScalar(distance2));\n    return this;\n  }\n  \
translateX(distance2) {\n    return this.translateOnAxis(_xAxis, \
distance2);\n  }\n  translateY(distance2) {\n    return \
this.translateOnAxis(_yAxis, distance2);\n  }\n  translateZ(distance2) {\n    \
return this.translateOnAxis(_zAxis, distance2);\n  }\n  localToWorld(vector) \
{\n    this.updateWorldMatrix(true, false);\n    return \
vector.applyMatrix4(this.matrixWorld);\n  }\n  worldToLocal(vector) {\n    \
this.updateWorldMatrix(true, false);\n    return \
vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());\n  }\n  \
lookAt(x2, y2, z2) {\n    if (x2.isVector3) {\n      _target.copy(x2);\n    } \
else {\n      _target.set(x2, y2, z2);\n    }\n    const parent = \
this.parent;\n    this.updateWorldMatrix(true, false);\n    \
_position$3.setFromMatrixPosition(this.matrixWorld);\n    if (this.isCamera \
|| this.isLight) {\n      _m1$3.lookAt(_position$3, _target, this.up);\n    } \
else {\n      _m1$3.lookAt(_target, _position$3, this.up);\n    }\n    \
this.quaternion.setFromRotationMatrix(_m1$3);\n    if (parent) {\n      \
_m1$3.extractRotation(parent.matrixWorld);\n      \
_q1.setFromRotationMatrix(_m1$3);\n      \
this.quaternion.premultiply(_q1.invert());\n    }\n  }\n  add(object) {\n    \
if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) \
{\n        this.add(arguments[i]);\n      }\n      return this;\n    }\n    \
if (object === this) {\n      console.error(\"THREE.Object3D.add: object \
can't be added as a child of itself.\", object);\n      return this;\n    }\n \
   if (object && object.isObject3D) {\n      object.removeFromParent();\n     \
 object.parent = this;\n      this.children.push(object);\n      \
object.dispatchEvent(_addedEvent);\n      _childaddedEvent.child = object;\n  \
    this.dispatchEvent(_childaddedEvent);\n      _childaddedEvent.child = \
null;\n    } else {\n      console.error(\"THREE.Object3D.add: object not an \
instance of THREE.Object3D.\", object);\n    }\n    return this;\n  }\n  \
remove(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < \
arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n      \
return this;\n    }\n    const index5 = this.children.indexOf(object);\n    \
if (index5 !== -1) {\n      object.parent = null;\n      \
this.children.splice(index5, 1);\n      \
object.dispatchEvent(_removedEvent);\n      _childremovedEvent.child = \
object;\n      this.dispatchEvent(_childremovedEvent);\n      \
_childremovedEvent.child = null;\n    }\n    return this;\n  }\n  \
removeFromParent() {\n    const parent = this.parent;\n    if (parent !== \
null) {\n      parent.remove(this);\n    }\n    return this;\n  }\n  clear() \
{\n    return this.remove(...this.children);\n  }\n  attach(object) {\n    \
this.updateWorldMatrix(true, false);\n    \
_m1$3.copy(this.matrixWorld).invert();\n    if (object.parent !== null) {\n   \
   object.parent.updateWorldMatrix(true, false);\n      \
_m1$3.multiply(object.parent.matrixWorld);\n    }\n    \
object.applyMatrix4(_m1$3);\n    object.removeFromParent();\n    \
object.parent = this;\n    this.children.push(object);\n    \
object.updateWorldMatrix(false, true);\n    \
object.dispatchEvent(_addedEvent);\n    _childaddedEvent.child = object;\n    \
this.dispatchEvent(_childaddedEvent);\n    _childaddedEvent.child = null;\n   \
 return this;\n  }\n  getObjectById(id2) {\n    return \
this.getObjectByProperty(\"id\", id2);\n  }\n  getObjectByName(name) {\n    \
return this.getObjectByProperty(\"name\", name);\n  }\n  \
getObjectByProperty(name, value) {\n    if (this[name] === value) return \
this;\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      \
const child = this.children[i];\n      const object = \
child.getObjectByProperty(name, value);\n      if (object !== void 0) {\n     \
   return object;\n      }\n    }\n    return void 0;\n  }\n  \
getObjectsByProperty(name, value, result = []) {\n    if (this[name] === \
value) result.push(this);\n    const children = this.children;\n    for (let \
i = 0, l = children.length; i < l; i++) {\n      \
children[i].getObjectsByProperty(name, value, result);\n    }\n    return \
result;\n  }\n  getWorldPosition(target) {\n    this.updateWorldMatrix(true, \
false);\n    return target.setFromMatrixPosition(this.matrixWorld);\n  }\n  \
getWorldQuaternion(target) {\n    this.updateWorldMatrix(true, false);\n    \
this.matrixWorld.decompose(_position$3, target, _scale$2);\n    return \
target;\n  }\n  getWorldScale(target) {\n    this.updateWorldMatrix(true, \
false);\n    this.matrixWorld.decompose(_position$3, _quaternion$2, \
target);\n    return target;\n  }\n  getWorldDirection(target) {\n    \
this.updateWorldMatrix(true, false);\n    const e = \
this.matrixWorld.elements;\n    return target.set(e[8], e[9], \
e[10]).normalize();\n  }\n  raycast() {\n  }\n  traverse(callback) {\n    \
callback(this);\n    const children = this.children;\n    for (let i = 0, l = \
children.length; i < l; i++) {\n      children[i].traverse(callback);\n    \
}\n  }\n  traverseVisible(callback) {\n    if (this.visible === false) \
return;\n    callback(this);\n    const children = this.children;\n    for \
(let i = 0, l = children.length; i < l; i++) {\n      \
children[i].traverseVisible(callback);\n    }\n  }\n  \
traverseAncestors(callback) {\n    const parent = this.parent;\n    if \
(parent !== null) {\n      callback(parent);\n      \
parent.traverseAncestors(callback);\n    }\n  }\n  updateMatrix() {\n    \
this.matrix.compose(this.position, this.quaternion, this.scale);\n    \
this.matrixWorldNeedsUpdate = true;\n  }\n  updateMatrixWorld(force) {\n    \
if (this.matrixAutoUpdate) this.updateMatrix();\n    if \
(this.matrixWorldNeedsUpdate || force) {\n      if \
(this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) \
{\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          \
this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    \
    }\n      }\n      this.matrixWorldNeedsUpdate = false;\n      force = \
true;\n    }\n    const children = this.children;\n    for (let i = 0, l = \
children.length; i < l; i++) {\n      const child = children[i];\n      \
child.updateMatrixWorld(force);\n    }\n  }\n  \
updateWorldMatrix(updateParents, updateChildren) {\n    const parent = \
this.parent;\n    if (updateParents === true && parent !== null) {\n      \
parent.updateWorldMatrix(true, false);\n    }\n    if (this.matrixAutoUpdate) \
this.updateMatrix();\n    if (this.matrixWorldAutoUpdate === true) {\n      \
if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n    \
  } else {\n        \
this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    \
  }\n    }\n    if (updateChildren === true) {\n      const children = \
this.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n    \
    const child = children[i];\n        child.updateWorldMatrix(false, \
true);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRootObject = meta \
=== void 0 || typeof meta === \"string\";\n    const output2 = {};\n    if \
(isRootObject) {\n      meta = {\n        geometries: {},\n        materials: \
{},\n        textures: {},\n        images: {},\n        shapes: {},\n        \
skeletons: {},\n        animations: {},\n        nodes: {}\n      };\n      \
output2.metadata = {\n        version: 4.6,\n        type: \"Object\",\n      \
  generator: \"Object3D.toJSON\"\n      };\n    }\n    const object = {};\n   \
 object.uuid = this.uuid;\n    object.type = this.type;\n    if (this.name \
!== \"\") object.name = this.name;\n    if (this.castShadow === true) \
object.castShadow = true;\n    if (this.receiveShadow === true) \
object.receiveShadow = true;\n    if (this.visible === false) object.visible \
= false;\n    if (this.frustumCulled === false) object.frustumCulled = \
false;\n    if (this.renderOrder !== 0) object.renderOrder = \
this.renderOrder;\n    if (Object.keys(this.userData).length > 0) \
object.userData = this.userData;\n    object.layers = this.layers.mask;\n    \
object.matrix = this.matrix.toArray();\n    object.up = this.up.toArray();\n  \
  if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n    \
if (this.isInstancedMesh) {\n      object.type = \"InstancedMesh\";\n      \
object.count = this.count;\n      object.instanceMatrix = \
this.instanceMatrix.toJSON();\n      if (this.instanceColor !== null) \
object.instanceColor = this.instanceColor.toJSON();\n    }\n    if \
(this.isBatchedMesh) {\n      object.type = \"BatchedMesh\";\n      \
object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n      \
object.sortObjects = this.sortObjects;\n      object.drawRanges = \
this._drawRanges;\n      object.reservedRanges = this._reservedRanges;\n      \
object.visibility = this._visibility;\n      object.active = this._active;\n  \
    object.bounds = this._bounds.map((bound) => ({\n        boxInitialized: \
bound.boxInitialized,\n        boxMin: bound.box.min.toArray(),\n        \
boxMax: bound.box.max.toArray(),\n        sphereInitialized: \
bound.sphereInitialized,\n        sphereRadius: bound.sphere.radius,\n        \
sphereCenter: bound.sphere.center.toArray()\n      }));\n      \
object.maxInstanceCount = this._maxInstanceCount;\n      \
object.maxVertexCount = this._maxVertexCount;\n      object.maxIndexCount = \
this._maxIndexCount;\n      object.geometryInitialized = \
this._geometryInitialized;\n      object.geometryCount = \
this._geometryCount;\n      object.matricesTexture = \
this._matricesTexture.toJSON(meta);\n      if (this._colorsTexture !== null) \
object.colorsTexture = this._colorsTexture.toJSON(meta);\n      if \
(this.boundingSphere !== null) {\n        object.boundingSphere = {\n         \
 center: object.boundingSphere.center.toArray(),\n          radius: \
object.boundingSphere.radius\n        };\n      }\n      if (this.boundingBox \
!== null) {\n        object.boundingBox = {\n          min: \
object.boundingBox.min.toArray(),\n          max: \
object.boundingBox.max.toArray()\n        };\n      }\n    }\n    function \
serialize(library, element2) {\n      if (library[element2.uuid] === void 0) \
{\n        library[element2.uuid] = element2.toJSON(meta);\n      }\n      \
return element2.uuid;\n    }\n    if (this.isScene) {\n      if \
(this.background) {\n        if (this.background.isColor) {\n          \
object.background = this.background.toJSON();\n        } else if \
(this.background.isTexture) {\n          object.background = \
this.background.toJSON(meta).uuid;\n        }\n      }\n      if \
(this.environment && this.environment.isTexture && \
this.environment.isRenderTargetTexture !== true) {\n        \
object.environment = this.environment.toJSON(meta).uuid;\n      }\n    } else \
if (this.isMesh || this.isLine || this.isPoints) {\n      object.geometry = \
serialize(meta.geometries, this.geometry);\n      const parameters = \
this.geometry.parameters;\n      if (parameters !== void 0 && \
parameters.shapes !== void 0) {\n        const shapes = parameters.shapes;\n  \
      if (Array.isArray(shapes)) {\n          for (let i = 0, l = \
shapes.length; i < l; i++) {\n            const shape = shapes[i];\n          \
  serialize(meta.shapes, shape);\n          }\n        } else {\n          \
serialize(meta.shapes, shapes);\n        }\n      }\n    }\n    if \
(this.isSkinnedMesh) {\n      object.bindMode = this.bindMode;\n      \
object.bindMatrix = this.bindMatrix.toArray();\n      if (this.skeleton !== \
void 0) {\n        serialize(meta.skeletons, this.skeleton);\n        \
object.skeleton = this.skeleton.uuid;\n      }\n    }\n    if (this.material \
!== void 0) {\n      if (Array.isArray(this.material)) {\n        const uuids \
= [];\n        for (let i = 0, l = this.material.length; i < l; i++) {\n      \
    uuids.push(serialize(meta.materials, this.material[i]));\n        }\n     \
   object.material = uuids;\n      } else {\n        object.material = \
serialize(meta.materials, this.material);\n      }\n    }\n    if \
(this.children.length > 0) {\n      object.children = [];\n      for (let i = \
0; i < this.children.length; i++) {\n        \
object.children.push(this.children[i].toJSON(meta).object);\n      }\n    }\n \
   if (this.animations.length > 0) {\n      object.animations = [];\n      \
for (let i = 0; i < this.animations.length; i++) {\n        const animation = \
this.animations[i];\n        \
object.animations.push(serialize(meta.animations, animation));\n      }\n    \
}\n    if (isRootObject) {\n      const geometries = \
extractFromCache(meta.geometries);\n      const materials = \
extractFromCache(meta.materials);\n      const textures = \
extractFromCache(meta.textures);\n      const images = \
extractFromCache(meta.images);\n      const shapes = \
extractFromCache(meta.shapes);\n      const skeletons = \
extractFromCache(meta.skeletons);\n      const animations = \
extractFromCache(meta.animations);\n      const nodes = \
extractFromCache(meta.nodes);\n      if (geometries.length > 0) \
output2.geometries = geometries;\n      if (materials.length > 0) \
output2.materials = materials;\n      if (textures.length > 0) \
output2.textures = textures;\n      if (images.length > 0) output2.images = \
images;\n      if (shapes.length > 0) output2.shapes = shapes;\n      if \
(skeletons.length > 0) output2.skeletons = skeletons;\n      if \
(animations.length > 0) output2.animations = animations;\n      if \
(nodes.length > 0) output2.nodes = nodes;\n    }\n    output2.object = \
object;\n    return output2;\n    function extractFromCache(cache2) {\n      \
const values = [];\n      for (const key in cache2) {\n        const data = \
cache2[key];\n        delete data.metadata;\n        values.push(data);\n     \
 }\n      return values;\n    }\n  }\n  clone(recursive) {\n    return new \
this.constructor().copy(this, recursive);\n  }\n  copy(source, recursive = \
true) {\n    this.name = source.name;\n    this.up.copy(source.up);\n    \
this.position.copy(source.position);\n    this.rotation.order = \
source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    \
this.scale.copy(source.scale);\n    this.matrix.copy(source.matrix);\n    \
this.matrixWorld.copy(source.matrixWorld);\n    this.matrixAutoUpdate = \
source.matrixAutoUpdate;\n    this.matrixWorldAutoUpdate = \
source.matrixWorldAutoUpdate;\n    this.matrixWorldNeedsUpdate = \
source.matrixWorldNeedsUpdate;\n    this.layers.mask = source.layers.mask;\n  \
  this.visible = source.visible;\n    this.castShadow = source.castShadow;\n  \
  this.receiveShadow = source.receiveShadow;\n    this.frustumCulled = \
source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n    \
this.animations = source.animations.slice();\n    this.userData = \
JSON.parse(JSON.stringify(source.userData));\n    if (recursive === true) {\n \
     for (let i = 0; i < source.children.length; i++) {\n        const child \
= source.children[i];\n        this.add(child.clone());\n      }\n    }\n    \
return this;\n  }\n};\nObject3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, \
1, 0);\nObject3D.DEFAULT_MATRIX_AUTO_UPDATE = \
true;\nObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\nvar _v0$2 = /* \
@__PURE__ */ new Vector3();\nvar _v1$3 = /* @__PURE__ */ new Vector3();\nvar \
_v2$2 = /* @__PURE__ */ new Vector3();\nvar _v3$2 = /* @__PURE__ */ new \
Vector3();\nvar _vab = /* @__PURE__ */ new Vector3();\nvar _vac = /* \
@__PURE__ */ new Vector3();\nvar _vbc = /* @__PURE__ */ new Vector3();\nvar \
_vap = /* @__PURE__ */ new Vector3();\nvar _vbp = /* @__PURE__ */ new \
Vector3();\nvar _vcp = /* @__PURE__ */ new Vector3();\nvar _v40 = /* \
@__PURE__ */ new Vector4();\nvar _v41 = /* @__PURE__ */ new Vector4();\nvar \
_v42 = /* @__PURE__ */ new Vector4();\nvar Triangle = class _Triangle {\n  \
constructor(a2 = new Vector3(), b = new Vector3(), c2 = new Vector3()) {\n    \
this.a = a2;\n    this.b = b;\n    this.c = c2;\n  }\n  static getNormal(a2, \
b, c2, target) {\n    target.subVectors(c2, b);\n    _v0$2.subVectors(a2, \
b);\n    target.cross(_v0$2);\n    const targetLengthSq = \
target.lengthSq();\n    if (targetLengthSq > 0) {\n      return \
target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n    }\n    return \
target.set(0, 0, 0);\n  }\n  // static/instance method to calculate \
barycentric coordinates\n  // based on: \
http://www.blackpawn.com/texts/pointinpoly/default.html\n  static \
getBarycoord(point, a2, b, c2, target) {\n    _v0$2.subVectors(c2, a2);\n    \
_v1$3.subVectors(b, a2);\n    _v2$2.subVectors(point, a2);\n    const dot00 = \
_v0$2.dot(_v0$2);\n    const dot01 = _v0$2.dot(_v1$3);\n    const dot02 = \
_v0$2.dot(_v2$2);\n    const dot11 = _v1$3.dot(_v1$3);\n    const dot12 = \
_v1$3.dot(_v2$2);\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if \
(denom === 0) {\n      target.set(0, 0, 0);\n      return null;\n    }\n    \
const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * \
invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    \
return target.set(1 - u - v, v, u);\n  }\n  static containsPoint(point, a2, \
b, c2) {\n    if (this.getBarycoord(point, a2, b, c2, _v3$2) === null) {\n    \
  return false;\n    }\n    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + \
_v3$2.y <= 1;\n  }\n  static getInterpolation(point, p1, p2, p3, v1, v2, v3, \
target) {\n    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {\n  \
    target.x = 0;\n      target.y = 0;\n      if (\"z\" in target) target.z = \
0;\n      if (\"w\" in target) target.w = 0;\n      return null;\n    }\n    \
target.setScalar(0);\n    target.addScaledVector(v1, _v3$2.x);\n    \
target.addScaledVector(v2, _v3$2.y);\n    target.addScaledVector(v3, \
_v3$2.z);\n    return target;\n  }\n  static getInterpolatedAttribute(attr, \
i1, i2, i3, barycoord, target) {\n    _v40.setScalar(0);\n    \
_v41.setScalar(0);\n    _v42.setScalar(0);\n    \
_v40.fromBufferAttribute(attr, i1);\n    _v41.fromBufferAttribute(attr, \
i2);\n    _v42.fromBufferAttribute(attr, i3);\n    target.setScalar(0);\n    \
target.addScaledVector(_v40, barycoord.x);\n    target.addScaledVector(_v41, \
barycoord.y);\n    target.addScaledVector(_v42, barycoord.z);\n    return \
target;\n  }\n  static isFrontFacing(a2, b, c2, direction2) {\n    \
_v0$2.subVectors(c2, b);\n    _v1$3.subVectors(a2, b);\n    return \
_v0$2.cross(_v1$3).dot(direction2) < 0 ? true : false;\n  }\n  set(a2, b, c2) \
{\n    this.a.copy(a2);\n    this.b.copy(b);\n    this.c.copy(c2);\n    \
return this;\n  }\n  setFromPointsAndIndices(points, i0, i1, i2) {\n    \
this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    \
this.c.copy(points[i2]);\n    return this;\n  }\n  \
setFromAttributeAndIndices(attribute2, i0, i1, i2) {\n    \
this.a.fromBufferAttribute(attribute2, i0);\n    \
this.b.fromBufferAttribute(attribute2, i1);\n    \
this.c.fromBufferAttribute(attribute2, i2);\n    return this;\n  }\n  clone() \
{\n    return new this.constructor().copy(this);\n  }\n  copy(triangle) {\n   \
 this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    \
this.c.copy(triangle.c);\n    return this;\n  }\n  getArea() {\n    \
_v0$2.subVectors(this.c, this.b);\n    _v1$3.subVectors(this.a, this.b);\n    \
return _v0$2.cross(_v1$3).length() * 0.5;\n  }\n  getMidpoint(target) {\n    \
return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n \
 }\n  getNormal(target) {\n    return _Triangle.getNormal(this.a, this.b, \
this.c, target);\n  }\n  getPlane(target) {\n    return \
target.setFromCoplanarPoints(this.a, this.b, this.c);\n  }\n  \
getBarycoord(point, target) {\n    return _Triangle.getBarycoord(point, \
this.a, this.b, this.c, target);\n  }\n  getInterpolation(point, v1, v2, v3, \
target) {\n    return _Triangle.getInterpolation(point, this.a, this.b, \
this.c, v1, v2, v3, target);\n  }\n  containsPoint(point) {\n    return \
_Triangle.containsPoint(point, this.a, this.b, this.c);\n  }\n  \
isFrontFacing(direction2) {\n    return _Triangle.isFrontFacing(this.a, \
this.b, this.c, direction2);\n  }\n  intersectsBox(box) {\n    return \
box.intersectsTriangle(this);\n  }\n  closestPointToPoint(p, target) {\n    \
const a2 = this.a, b = this.b, c2 = this.c;\n    let v, w;\n    \
_vab.subVectors(b, a2);\n    _vac.subVectors(c2, a2);\n    _vap.subVectors(p, \
a2);\n    const d1 = _vab.dot(_vap);\n    const d2 = _vac.dot(_vap);\n    if \
(d1 <= 0 && d2 <= 0) {\n      return target.copy(a2);\n    }\n    \
_vbp.subVectors(p, b);\n    const d3 = _vab.dot(_vbp);\n    const d4 = \
_vac.dot(_vbp);\n    if (d3 >= 0 && d4 <= d3) {\n      return \
target.copy(b);\n    }\n    const vc = d1 * d4 - d3 * d2;\n    if (vc <= 0 && \
d1 >= 0 && d3 <= 0) {\n      v = d1 / (d1 - d3);\n      return \
target.copy(a2).addScaledVector(_vab, v);\n    }\n    _vcp.subVectors(p, \
c2);\n    const d5 = _vab.dot(_vcp);\n    const d6 = _vac.dot(_vcp);\n    if \
(d6 >= 0 && d5 <= d6) {\n      return target.copy(c2);\n    }\n    const vb = \
d5 * d2 - d1 * d6;\n    if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n      w = d2 / \
(d2 - d6);\n      return target.copy(a2).addScaledVector(_vac, w);\n    }\n   \
 const va = d3 * d6 - d5 * d4;\n    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= \
0) {\n      _vbc.subVectors(c2, b);\n      w = (d4 - d3) / (d4 - d3 + (d5 - \
d6));\n      return target.copy(b).addScaledVector(_vbc, w);\n    }\n    \
const denom = 1 / (va + vb + vc);\n    v = vb * denom;\n    w = vc * denom;\n \
   return target.copy(a2).addScaledVector(_vab, v).addScaledVector(_vac, \
w);\n  }\n  equals(triangle) {\n    return triangle.a.equals(this.a) && \
triangle.b.equals(this.b) && triangle.c.equals(this.c);\n  }\n};\nvar \
_colorKeywords = {\n  \"aliceblue\": 15792383,\n  \"antiquewhite\": \
16444375,\n  \"aqua\": 65535,\n  \"aquamarine\": 8388564,\n  \"azure\": \
15794175,\n  \"beige\": 16119260,\n  \"bisque\": 16770244,\n  \"black\": 0,\n \
 \"blanchedalmond\": 16772045,\n  \"blue\": 255,\n  \"blueviolet\": \
9055202,\n  \"brown\": 10824234,\n  \"burlywood\": 14596231,\n  \
\"cadetblue\": 6266528,\n  \"chartreuse\": 8388352,\n  \"chocolate\": \
13789470,\n  \"coral\": 16744272,\n  \"cornflowerblue\": 6591981,\n  \
\"cornsilk\": 16775388,\n  \"crimson\": 14423100,\n  \"cyan\": 65535,\n  \
\"darkblue\": 139,\n  \"darkcyan\": 35723,\n  \"darkgoldenrod\": 12092939,\n  \
\"darkgray\": 11119017,\n  \"darkgreen\": 25600,\n  \"darkgrey\": 11119017,\n \
 \"darkkhaki\": 12433259,\n  \"darkmagenta\": 9109643,\n  \"darkolivegreen\": \
5597999,\n  \"darkorange\": 16747520,\n  \"darkorchid\": 10040012,\n  \
\"darkred\": 9109504,\n  \"darksalmon\": 15308410,\n  \"darkseagreen\": \
9419919,\n  \"darkslateblue\": 4734347,\n  \"darkslategray\": 3100495,\n  \
\"darkslategrey\": 3100495,\n  \"darkturquoise\": 52945,\n  \"darkviolet\": \
9699539,\n  \"deeppink\": 16716947,\n  \"deepskyblue\": 49151,\n  \
\"dimgray\": 6908265,\n  \"dimgrey\": 6908265,\n  \"dodgerblue\": 2003199,\n  \
\"firebrick\": 11674146,\n  \"floralwhite\": 16775920,\n  \"forestgreen\": \
2263842,\n  \"fuchsia\": 16711935,\n  \"gainsboro\": 14474460,\n  \
\"ghostwhite\": 16316671,\n  \"gold\": 16766720,\n  \"goldenrod\": \
14329120,\n  \"gray\": 8421504,\n  \"green\": 32768,\n  \"greenyellow\": \
11403055,\n  \"grey\": 8421504,\n  \"honeydew\": 15794160,\n  \"hotpink\": \
16738740,\n  \"indianred\": 13458524,\n  \"indigo\": 4915330,\n  \"ivory\": \
16777200,\n  \"khaki\": 15787660,\n  \"lavender\": 15132410,\n  \
\"lavenderblush\": 16773365,\n  \"lawngreen\": 8190976,\n  \"lemonchiffon\": \
16775885,\n  \"lightblue\": 11393254,\n  \"lightcoral\": 15761536,\n  \
\"lightcyan\": 14745599,\n  \"lightgoldenrodyellow\": 16448210,\n  \
\"lightgray\": 13882323,\n  \"lightgreen\": 9498256,\n  \"lightgrey\": \
13882323,\n  \"lightpink\": 16758465,\n  \"lightsalmon\": 16752762,\n  \
\"lightseagreen\": 2142890,\n  \"lightskyblue\": 8900346,\n  \
\"lightslategray\": 7833753,\n  \"lightslategrey\": 7833753,\n  \
\"lightsteelblue\": 11584734,\n  \"lightyellow\": 16777184,\n  \"lime\": \
65280,\n  \"limegreen\": 3329330,\n  \"linen\": 16445670,\n  \"magenta\": \
16711935,\n  \"maroon\": 8388608,\n  \"mediumaquamarine\": 6737322,\n  \
\"mediumblue\": 205,\n  \"mediumorchid\": 12211667,\n  \"mediumpurple\": \
9662683,\n  \"mediumseagreen\": 3978097,\n  \"mediumslateblue\": 8087790,\n  \
\"mediumspringgreen\": 64154,\n  \"mediumturquoise\": 4772300,\n  \
\"mediumvioletred\": 13047173,\n  \"midnightblue\": 1644912,\n  \
\"mintcream\": 16121850,\n  \"mistyrose\": 16770273,\n  \"moccasin\": \
16770229,\n  \"navajowhite\": 16768685,\n  \"navy\": 128,\n  \"oldlace\": \
16643558,\n  \"olive\": 8421376,\n  \"olivedrab\": 7048739,\n  \"orange\": \
16753920,\n  \"orangered\": 16729344,\n  \"orchid\": 14315734,\n  \
\"palegoldenrod\": 15657130,\n  \"palegreen\": 10025880,\n  \
\"paleturquoise\": 11529966,\n  \"palevioletred\": 14381203,\n  \
\"papayawhip\": 16773077,\n  \"peachpuff\": 16767673,\n  \"peru\": \
13468991,\n  \"pink\": 16761035,\n  \"plum\": 14524637,\n  \"powderblue\": \
11591910,\n  \"purple\": 8388736,\n  \"rebeccapurple\": 6697881,\n  \"red\": \
16711680,\n  \"rosybrown\": 12357519,\n  \"royalblue\": 4286945,\n  \
\"saddlebrown\": 9127187,\n  \"salmon\": 16416882,\n  \"sandybrown\": \
16032864,\n  \"seagreen\": 3050327,\n  \"seashell\": 16774638,\n  \"sienna\": \
10506797,\n  \"silver\": 12632256,\n  \"skyblue\": 8900331,\n  \"slateblue\": \
6970061,\n  \"slategray\": 7372944,\n  \"slategrey\": 7372944,\n  \"snow\": \
16775930,\n  \"springgreen\": 65407,\n  \"steelblue\": 4620980,\n  \"tan\": \
13808780,\n  \"teal\": 32896,\n  \"thistle\": 14204888,\n  \"tomato\": \
16737095,\n  \"turquoise\": 4251856,\n  \"violet\": 15631086,\n  \"wheat\": \
16113331,\n  \"white\": 16777215,\n  \"whitesmoke\": 16119285,\n  \"yellow\": \
16776960,\n  \"yellowgreen\": 10145074\n};\nvar _hslA = { h: 0, s: 0, l: 0 \
};\nvar _hslB = { h: 0, s: 0, l: 0 };\nfunction hue2rgb(p, q, t) {\n  if (t < \
0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * \
t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * 6 * (2 \
/ 3 - t);\n  return p;\n}\nvar Color = class {\n  constructor(r, g, b) {\n    \
this.isColor = true;\n    this.r = 1;\n    this.g = 1;\n    this.b = 1;\n    \
return this.set(r, g, b);\n  }\n  set(r, g, b) {\n    if (g === void 0 && b \
=== void 0) {\n      const value = r;\n      if (value && value.isColor) {\n  \
      this.copy(value);\n      } else if (typeof value === \"number\") {\n    \
    this.setHex(value);\n      } else if (typeof value === \"string\") {\n    \
    this.setStyle(value);\n      }\n    } else {\n      this.setRGB(r, g, \
b);\n    }\n    return this;\n  }\n  setScalar(scalar) {\n    this.r = \
scalar;\n    this.g = scalar;\n    this.b = scalar;\n    return this;\n  }\n  \
setHex(hex, colorSpace = SRGBColorSpace) {\n    hex = Math.floor(hex);\n    \
this.r = (hex >> 16 & 255) / 255;\n    this.g = (hex >> 8 & 255) / 255;\n    \
this.b = (hex & 255) / 255;\n    ColorManagement.toWorkingColorSpace(this, \
colorSpace);\n    return this;\n  }\n  setRGB(r, g, b, colorSpace = \
ColorManagement.workingColorSpace) {\n    this.r = r;\n    this.g = g;\n    \
this.b = b;\n    ColorManagement.toWorkingColorSpace(this, colorSpace);\n    \
return this;\n  }\n  setHSL(h, s, l, colorSpace = \
ColorManagement.workingColorSpace) {\n    h = euclideanModulo(h, 1);\n    s = \
clamp(s, 0, 1);\n    l = clamp(l, 0, 1);\n    if (s === 0) {\n      this.r = \
this.g = this.b = l;\n    } else {\n      const p = l <= 0.5 ? l * (1 + s) : \
l + s - l * s;\n      const q = 2 * l - p;\n      this.r = hue2rgb(q, p, h + \
1 / 3);\n      this.g = hue2rgb(q, p, h);\n      this.b = hue2rgb(q, p, h - 1 \
/ 3);\n    }\n    ColorManagement.toWorkingColorSpace(this, colorSpace);\n    \
return this;\n  }\n  setStyle(style, colorSpace = SRGBColorSpace) {\n    \
function handleAlpha(string) {\n      if (string === void 0) return;\n      \
if (parseFloat(string) < 1) {\n        console.warn(\"THREE.Color: Alpha \
component of \" + style + \" will be ignored.\");\n      }\n    }\n    let \
m2;\n    if (m2 = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n      let \
color2;\n      const name = m2[1];\n      const components = m2[2];\n      \
switch (name) {\n        case \"rgb\":\n        case \"rgba\":\n          if \
(color2 = \
/^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.\
exec(components)) {\n            handleAlpha(color2[4]);\n            return \
this.setRGB(\n              Math.min(255, parseInt(color2[1], 10)) / 255,\n   \
           Math.min(255, parseInt(color2[2], 10)) / 255,\n              \
Math.min(255, parseInt(color2[3], 10)) / 255,\n              colorSpace\n     \
       );\n          }\n          if (color2 = \
/^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\
\\s*)?$/.exec(components)) {\n            handleAlpha(color2[4]);\n           \
 return this.setRGB(\n              Math.min(100, parseInt(color2[1], 10)) / \
100,\n              Math.min(100, parseInt(color2[2], 10)) / 100,\n           \
   Math.min(100, parseInt(color2[3], 10)) / 100,\n              colorSpace\n  \
          );\n          }\n          break;\n        case \"hsl\":\n        \
case \"hsla\":\n          if (color2 = \
/^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(\
?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            \
handleAlpha(color2[4]);\n            return this.setHSL(\n              \
parseFloat(color2[1]) / 360,\n              parseFloat(color2[2]) / 100,\n    \
          parseFloat(color2[3]) / 100,\n              colorSpace\n            \
);\n          }\n          break;\n        default:\n          \
console.warn(\"THREE.Color: Unknown color model \" + style);\n      }\n    } \
else if (m2 = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n      const hex = \
m2[1];\n      const size = hex.length;\n      if (size === 3) {\n        \
return this.setRGB(\n          parseInt(hex.charAt(0), 16) / 15,\n          \
parseInt(hex.charAt(1), 16) / 15,\n          parseInt(hex.charAt(2), 16) / \
15,\n          colorSpace\n        );\n      } else if (size === 6) {\n       \
 return this.setHex(parseInt(hex, 16), colorSpace);\n      } else {\n        \
console.warn(\"THREE.Color: Invalid hex color \" + style);\n      }\n    } \
else if (style && style.length > 0) {\n      return this.setColorName(style, \
colorSpace);\n    }\n    return this;\n  }\n  setColorName(style, colorSpace \
= SRGBColorSpace) {\n    const hex = _colorKeywords[style.toLowerCase()];\n   \
 if (hex !== void 0) {\n      this.setHex(hex, colorSpace);\n    } else {\n   \
   console.warn(\"THREE.Color: Unknown color \" + style);\n    }\n    return \
this;\n  }\n  clone() {\n    return new this.constructor(this.r, this.g, \
this.b);\n  }\n  copy(color2) {\n    this.r = color2.r;\n    this.g = \
color2.g;\n    this.b = color2.b;\n    return this;\n  }\n  \
copySRGBToLinear(color2) {\n    this.r = SRGBToLinear(color2.r);\n    this.g \
= SRGBToLinear(color2.g);\n    this.b = SRGBToLinear(color2.b);\n    return \
this;\n  }\n  copyLinearToSRGB(color2) {\n    this.r = \
LinearToSRGB(color2.r);\n    this.g = LinearToSRGB(color2.g);\n    this.b = \
LinearToSRGB(color2.b);\n    return this;\n  }\n  convertSRGBToLinear() {\n   \
 this.copySRGBToLinear(this);\n    return this;\n  }\n  convertLinearToSRGB() \
{\n    this.copyLinearToSRGB(this);\n    return this;\n  }\n  \
getHex(colorSpace = SRGBColorSpace) {\n    \
ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n    \
return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + \
Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * \
255, 0, 255));\n  }\n  getHexString(colorSpace = SRGBColorSpace) {\n    \
return (\"000000\" + this.getHex(colorSpace).toString(16)).slice(-6);\n  }\n  \
getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n    \
ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n    \
const r = _color.r, g = _color.g, b = _color.b;\n    const max2 = Math.max(r, \
g, b);\n    const min2 = Math.min(r, g, b);\n    let hue, saturation;\n    \
const lightness = (min2 + max2) / 2;\n    if (min2 === max2) {\n      hue = \
0;\n      saturation = 0;\n    } else {\n      const delta = max2 - min2;\n   \
   saturation = lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 \
- min2);\n      switch (max2) {\n        case r:\n          hue = (g - b) / \
delta + (g < b ? 6 : 0);\n          break;\n        case g:\n          hue = \
(b - r) / delta + 2;\n          break;\n        case b:\n          hue = (r - \
g) / delta + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    \
target.h = hue;\n    target.s = saturation;\n    target.l = lightness;\n    \
return target;\n  }\n  getRGB(target, colorSpace = \
ColorManagement.workingColorSpace) {\n    \
ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n    \
target.r = _color.r;\n    target.g = _color.g;\n    target.b = _color.b;\n    \
return target;\n  }\n  getStyle(colorSpace = SRGBColorSpace) {\n    \
ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n    \
const r = _color.r, g = _color.g, b = _color.b;\n    if (colorSpace !== \
SRGBColorSpace) {\n      return `color(${colorSpace} ${r.toFixed(3)} \
${g.toFixed(3)} ${b.toFixed(3)})`;\n    }\n    return `rgb(${Math.round(r * \
255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n  }\n  offsetHSL(h, \
s, l) {\n    this.getHSL(_hslA);\n    return this.setHSL(_hslA.h + h, _hslA.s \
+ s, _hslA.l + l);\n  }\n  add(color2) {\n    this.r += color2.r;\n    this.g \
+= color2.g;\n    this.b += color2.b;\n    return this;\n  }\n  \
addColors(color1, color2) {\n    this.r = color1.r + color2.r;\n    this.g = \
color1.g + color2.g;\n    this.b = color1.b + color2.b;\n    return this;\n  \
}\n  addScalar(s) {\n    this.r += s;\n    this.g += s;\n    this.b += s;\n   \
 return this;\n  }\n  sub(color2) {\n    this.r = Math.max(0, this.r - \
color2.r);\n    this.g = Math.max(0, this.g - color2.g);\n    this.b = \
Math.max(0, this.b - color2.b);\n    return this;\n  }\n  multiply(color2) \
{\n    this.r *= color2.r;\n    this.g *= color2.g;\n    this.b *= \
color2.b;\n    return this;\n  }\n  multiplyScalar(s) {\n    this.r *= s;\n   \
 this.g *= s;\n    this.b *= s;\n    return this;\n  }\n  lerp(color2, alpha) \
{\n    this.r += (color2.r - this.r) * alpha;\n    this.g += (color2.g - \
this.g) * alpha;\n    this.b += (color2.b - this.b) * alpha;\n    return \
this;\n  }\n  lerpColors(color1, color2, alpha) {\n    this.r = color1.r + \
(color2.r - color1.r) * alpha;\n    this.g = color1.g + (color2.g - color1.g) \
* alpha;\n    this.b = color1.b + (color2.b - color1.b) * alpha;\n    return \
this;\n  }\n  lerpHSL(color2, alpha) {\n    this.getHSL(_hslA);\n    \
color2.getHSL(_hslB);\n    const h = lerp(_hslA.h, _hslB.h, alpha);\n    \
const s = lerp(_hslA.s, _hslB.s, alpha);\n    const l = lerp(_hslA.l, \
_hslB.l, alpha);\n    this.setHSL(h, s, l);\n    return this;\n  }\n  \
setFromVector3(v) {\n    this.r = v.x;\n    this.g = v.y;\n    this.b = \
v.z;\n    return this;\n  }\n  applyMatrix3(m2) {\n    const r = this.r, g = \
this.g, b = this.b;\n    const e = m2.elements;\n    this.r = e[0] * r + e[3] \
* g + e[6] * b;\n    this.g = e[1] * r + e[4] * g + e[7] * b;\n    this.b = \
e[2] * r + e[5] * g + e[8] * b;\n    return this;\n  }\n  equals(c2) {\n    \
return c2.r === this.r && c2.g === this.g && c2.b === this.b;\n  }\n  \
fromArray(array, offset = 0) {\n    this.r = array[offset];\n    this.g = \
array[offset + 1];\n    this.b = array[offset + 2];\n    return this;\n  }\n  \
toArray(array = [], offset = 0) {\n    array[offset] = this.r;\n    \
array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n    return \
array;\n  }\n  fromBufferAttribute(attribute2, index5) {\n    this.r = \
attribute2.getX(index5);\n    this.g = attribute2.getY(index5);\n    this.b = \
attribute2.getZ(index5);\n    return this;\n  }\n  toJSON() {\n    return \
this.getHex();\n  }\n  *[Symbol.iterator]() {\n    yield this.r;\n    yield \
this.g;\n    yield this.b;\n  }\n};\nvar _color = /* @__PURE__ */ new \
Color();\nColor.NAMES = _colorKeywords;\nvar _materialId = 0;\nvar Material = \
class extends EventDispatcher {\n  static get type() {\n    return \
\"Material\";\n  }\n  get type() {\n    return this.constructor.type;\n  }\n  \
set type(_value) {\n  }\n  constructor() {\n    super();\n    this.isMaterial \
= true;\n    Object.defineProperty(this, \"id\", { value: _materialId++ });\n \
   this.uuid = generateUUID();\n    this.name = \"\";\n    this.blending = \
NormalBlending;\n    this.side = FrontSide;\n    this.vertexColors = false;\n \
   this.opacity = 1;\n    this.transparent = false;\n    this.alphaHash = \
false;\n    this.blendSrc = SrcAlphaFactor;\n    this.blendDst = \
OneMinusSrcAlphaFactor;\n    this.blendEquation = AddEquation;\n    \
this.blendSrcAlpha = null;\n    this.blendDstAlpha = null;\n    \
this.blendEquationAlpha = null;\n    this.blendColor = new Color(0, 0, 0);\n  \
  this.blendAlpha = 0;\n    this.depthFunc = LessEqualDepth;\n    \
this.depthTest = true;\n    this.depthWrite = true;\n    \
this.stencilWriteMask = 255;\n    this.stencilFunc = AlwaysStencilFunc;\n    \
this.stencilRef = 0;\n    this.stencilFuncMask = 255;\n    this.stencilFail = \
KeepStencilOp;\n    this.stencilZFail = KeepStencilOp;\n    this.stencilZPass \
= KeepStencilOp;\n    this.stencilWrite = false;\n    this.clippingPlanes = \
null;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n    \
this.shadowSide = null;\n    this.colorWrite = true;\n    this.precision = \
null;\n    this.polygonOffset = false;\n    this.polygonOffsetFactor = 0;\n   \
 this.polygonOffsetUnits = 0;\n    this.dithering = false;\n    \
this.alphaToCoverage = false;\n    this.premultipliedAlpha = false;\n    \
this.forceSinglePass = false;\n    this.visible = true;\n    this.toneMapped \
= true;\n    this.userData = {};\n    this.version = 0;\n    this._alphaTest \
= 0;\n  }\n  get alphaTest() {\n    return this._alphaTest;\n  }\n  set \
alphaTest(value) {\n    if (this._alphaTest > 0 !== value > 0) {\n      \
this.version++;\n    }\n    this._alphaTest = value;\n  }\n  // \
onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n  \
onBeforeRender() {\n  }\n  onBeforeCompile() {\n  }\n  \
customProgramCacheKey() {\n    return this.onBeforeCompile.toString();\n  }\n \
 setValues(values) {\n    if (values === void 0) return;\n    for (const key \
in values) {\n      const newValue = values[key];\n      if (newValue === \
void 0) {\n        console.warn(`THREE.Material: parameter '${key}' has value \
of undefined.`);\n        continue;\n      }\n      const currentValue = \
this[key];\n      if (currentValue === void 0) {\n        \
console.warn(`THREE.Material: '${key}' is not a property of \
THREE.${this.type}.`);\n        continue;\n      }\n      if (currentValue && \
currentValue.isColor) {\n        currentValue.set(newValue);\n      } else if \
(currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) \
{\n        currentValue.copy(newValue);\n      } else {\n        this[key] = \
newValue;\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRootObject = \
meta === void 0 || typeof meta === \"string\";\n    if (isRootObject) {\n     \
 meta = {\n        textures: {},\n        images: {}\n      };\n    }\n    \
const data = {\n      metadata: {\n        version: 4.6,\n        type: \
\"Material\",\n        generator: \"Material.toJSON\"\n      }\n    };\n    \
data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \
\"\") data.name = this.name;\n    if (this.color && this.color.isColor) \
data.color = this.color.getHex();\n    if (this.roughness !== void 0) \
data.roughness = this.roughness;\n    if (this.metalness !== void 0) \
data.metalness = this.metalness;\n    if (this.sheen !== void 0) data.sheen = \
this.sheen;\n    if (this.sheenColor && this.sheenColor.isColor) \
data.sheenColor = this.sheenColor.getHex();\n    if (this.sheenRoughness !== \
void 0) data.sheenRoughness = this.sheenRoughness;\n    if (this.emissive && \
this.emissive.isColor) data.emissive = this.emissive.getHex();\n    if \
(this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) \
data.emissiveIntensity = this.emissiveIntensity;\n    if (this.specular && \
this.specular.isColor) data.specular = this.specular.getHex();\n    if \
(this.specularIntensity !== void 0) data.specularIntensity = \
this.specularIntensity;\n    if (this.specularColor && \
this.specularColor.isColor) data.specularColor = \
this.specularColor.getHex();\n    if (this.shininess !== void 0) \
data.shininess = this.shininess;\n    if (this.clearcoat !== void 0) \
data.clearcoat = this.clearcoat;\n    if (this.clearcoatRoughness !== void 0) \
data.clearcoatRoughness = this.clearcoatRoughness;\n    if (this.clearcoatMap \
&& this.clearcoatMap.isTexture) {\n      data.clearcoatMap = \
this.clearcoatMap.toJSON(meta).uuid;\n    }\n    if \
(this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n      \
data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n  \
  }\n    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) \
{\n      data.clearcoatNormalMap = \
this.clearcoatNormalMap.toJSON(meta).uuid;\n      data.clearcoatNormalScale = \
this.clearcoatNormalScale.toArray();\n    }\n    if (this.dispersion !== void \
0) data.dispersion = this.dispersion;\n    if (this.iridescence !== void 0) \
data.iridescence = this.iridescence;\n    if (this.iridescenceIOR !== void 0) \
data.iridescenceIOR = this.iridescenceIOR;\n    if \
(this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = \
this.iridescenceThicknessRange;\n    if (this.iridescenceMap && \
this.iridescenceMap.isTexture) {\n      data.iridescenceMap = \
this.iridescenceMap.toJSON(meta).uuid;\n    }\n    if \
(this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n  \
    data.iridescenceThicknessMap = \
this.iridescenceThicknessMap.toJSON(meta).uuid;\n    }\n    if \
(this.anisotropy !== void 0) data.anisotropy = this.anisotropy;\n    if \
(this.anisotropyRotation !== void 0) data.anisotropyRotation = \
this.anisotropyRotation;\n    if (this.anisotropyMap && \
this.anisotropyMap.isTexture) {\n      data.anisotropyMap = \
this.anisotropyMap.toJSON(meta).uuid;\n    }\n    if (this.map && \
this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n    if \
(this.matcap && this.matcap.isTexture) data.matcap = \
this.matcap.toJSON(meta).uuid;\n    if (this.alphaMap && \
this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n   \
 if (this.lightMap && this.lightMap.isTexture) {\n      data.lightMap = \
this.lightMap.toJSON(meta).uuid;\n      data.lightMapIntensity = \
this.lightMapIntensity;\n    }\n    if (this.aoMap && this.aoMap.isTexture) \
{\n      data.aoMap = this.aoMap.toJSON(meta).uuid;\n      \
data.aoMapIntensity = this.aoMapIntensity;\n    }\n    if (this.bumpMap && \
this.bumpMap.isTexture) {\n      data.bumpMap = \
this.bumpMap.toJSON(meta).uuid;\n      data.bumpScale = this.bumpScale;\n    \
}\n    if (this.normalMap && this.normalMap.isTexture) {\n      \
data.normalMap = this.normalMap.toJSON(meta).uuid;\n      data.normalMapType \
= this.normalMapType;\n      data.normalScale = this.normalScale.toArray();\n \
   }\n    if (this.displacementMap && this.displacementMap.isTexture) {\n     \
 data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n      \
data.displacementScale = this.displacementScale;\n      data.displacementBias \
= this.displacementBias;\n    }\n    if (this.roughnessMap && \
this.roughnessMap.isTexture) data.roughnessMap = \
this.roughnessMap.toJSON(meta).uuid;\n    if (this.metalnessMap && \
this.metalnessMap.isTexture) data.metalnessMap = \
this.metalnessMap.toJSON(meta).uuid;\n    if (this.emissiveMap && \
this.emissiveMap.isTexture) data.emissiveMap = \
this.emissiveMap.toJSON(meta).uuid;\n    if (this.specularMap && \
this.specularMap.isTexture) data.specularMap = \
this.specularMap.toJSON(meta).uuid;\n    if (this.specularIntensityMap && \
this.specularIntensityMap.isTexture) data.specularIntensityMap = \
this.specularIntensityMap.toJSON(meta).uuid;\n    if (this.specularColorMap \
&& this.specularColorMap.isTexture) data.specularColorMap = \
this.specularColorMap.toJSON(meta).uuid;\n    if (this.envMap && \
this.envMap.isTexture) {\n      data.envMap = \
this.envMap.toJSON(meta).uuid;\n      if (this.combine !== void 0) \
data.combine = this.combine;\n    }\n    if (this.envMapRotation !== void 0) \
data.envMapRotation = this.envMapRotation.toArray();\n    if \
(this.envMapIntensity !== void 0) data.envMapIntensity = \
this.envMapIntensity;\n    if (this.reflectivity !== void 0) \
data.reflectivity = this.reflectivity;\n    if (this.refractionRatio !== void \
0) data.refractionRatio = this.refractionRatio;\n    if (this.gradientMap && \
this.gradientMap.isTexture) {\n      data.gradientMap = \
this.gradientMap.toJSON(meta).uuid;\n    }\n    if (this.transmission !== \
void 0) data.transmission = this.transmission;\n    if (this.transmissionMap \
&& this.transmissionMap.isTexture) data.transmissionMap = \
this.transmissionMap.toJSON(meta).uuid;\n    if (this.thickness !== void 0) \
data.thickness = this.thickness;\n    if (this.thicknessMap && \
this.thicknessMap.isTexture) data.thicknessMap = \
this.thicknessMap.toJSON(meta).uuid;\n    if (this.attenuationDistance !== \
void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = \
this.attenuationDistance;\n    if (this.attenuationColor !== void 0) \
data.attenuationColor = this.attenuationColor.getHex();\n    if (this.size \
!== void 0) data.size = this.size;\n    if (this.shadowSide !== null) \
data.shadowSide = this.shadowSide;\n    if (this.sizeAttenuation !== void 0) \
data.sizeAttenuation = this.sizeAttenuation;\n    if (this.blending !== \
NormalBlending) data.blending = this.blending;\n    if (this.side !== \
FrontSide) data.side = this.side;\n    if (this.vertexColors === true) \
data.vertexColors = true;\n    if (this.opacity < 1) data.opacity = \
this.opacity;\n    if (this.transparent === true) data.transparent = true;\n  \
  if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;\n    \
if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = \
this.blendDst;\n    if (this.blendEquation !== AddEquation) \
data.blendEquation = this.blendEquation;\n    if (this.blendSrcAlpha !== \
null) data.blendSrcAlpha = this.blendSrcAlpha;\n    if (this.blendDstAlpha \
!== null) data.blendDstAlpha = this.blendDstAlpha;\n    if \
(this.blendEquationAlpha !== null) data.blendEquationAlpha = \
this.blendEquationAlpha;\n    if (this.blendColor && this.blendColor.isColor) \
data.blendColor = this.blendColor.getHex();\n    if (this.blendAlpha !== 0) \
data.blendAlpha = this.blendAlpha;\n    if (this.depthFunc !== \
LessEqualDepth) data.depthFunc = this.depthFunc;\n    if (this.depthTest === \
false) data.depthTest = this.depthTest;\n    if (this.depthWrite === false) \
data.depthWrite = this.depthWrite;\n    if (this.colorWrite === false) \
data.colorWrite = this.colorWrite;\n    if (this.stencilWriteMask !== 255) \
data.stencilWriteMask = this.stencilWriteMask;\n    if (this.stencilFunc !== \
AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;\n    if \
(this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n    if \
(this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;\n \
   if (this.stencilFail !== KeepStencilOp) data.stencilFail = \
this.stencilFail;\n    if (this.stencilZFail !== KeepStencilOp) \
data.stencilZFail = this.stencilZFail;\n    if (this.stencilZPass !== \
KeepStencilOp) data.stencilZPass = this.stencilZPass;\n    if \
(this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n    if \
(this.rotation !== void 0 && this.rotation !== 0) data.rotation = \
this.rotation;\n    if (this.polygonOffset === true) data.polygonOffset = \
true;\n    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = \
this.polygonOffsetFactor;\n    if (this.polygonOffsetUnits !== 0) \
data.polygonOffsetUnits = this.polygonOffsetUnits;\n    if (this.linewidth \
!== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;\n    if \
(this.dashSize !== void 0) data.dashSize = this.dashSize;\n    if \
(this.gapSize !== void 0) data.gapSize = this.gapSize;\n    if (this.scale \
!== void 0) data.scale = this.scale;\n    if (this.dithering === true) \
data.dithering = true;\n    if (this.alphaTest > 0) data.alphaTest = \
this.alphaTest;\n    if (this.alphaHash === true) data.alphaHash = true;\n    \
if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n    if \
(this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n    if \
(this.forceSinglePass === true) data.forceSinglePass = true;\n    if \
(this.wireframe === true) data.wireframe = true;\n    if \
(this.wireframeLinewidth > 1) data.wireframeLinewidth = \
this.wireframeLinewidth;\n    if (this.wireframeLinecap !== \"round\") \
data.wireframeLinecap = this.wireframeLinecap;\n    if \
(this.wireframeLinejoin !== \"round\") data.wireframeLinejoin = \
this.wireframeLinejoin;\n    if (this.flatShading === true) data.flatShading \
= true;\n    if (this.visible === false) data.visible = false;\n    if \
(this.toneMapped === false) data.toneMapped = false;\n    if (this.fog === \
false) data.fog = false;\n    if (Object.keys(this.userData).length > 0) \
data.userData = this.userData;\n    function extractFromCache(cache2) {\n     \
 const values = [];\n      for (const key in cache2) {\n        const data2 = \
cache2[key];\n        delete data2.metadata;\n        values.push(data2);\n   \
   }\n      return values;\n    }\n    if (isRootObject) {\n      const \
textures = extractFromCache(meta.textures);\n      const images = \
extractFromCache(meta.images);\n      if (textures.length > 0) data.textures \
= textures;\n      if (images.length > 0) data.images = images;\n    }\n    \
return data;\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n  copy(source) {\n    this.name = \
source.name;\n    this.blending = source.blending;\n    this.side = \
source.side;\n    this.vertexColors = source.vertexColors;\n    this.opacity \
= source.opacity;\n    this.transparent = source.transparent;\n    \
this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    \
this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = \
source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    \
this.blendEquationAlpha = source.blendEquationAlpha;\n    \
this.blendColor.copy(source.blendColor);\n    this.blendAlpha = \
source.blendAlpha;\n    this.depthFunc = source.depthFunc;\n    \
this.depthTest = source.depthTest;\n    this.depthWrite = \
source.depthWrite;\n    this.stencilWriteMask = source.stencilWriteMask;\n    \
this.stencilFunc = source.stencilFunc;\n    this.stencilRef = \
source.stencilRef;\n    this.stencilFuncMask = source.stencilFuncMask;\n    \
this.stencilFail = source.stencilFail;\n    this.stencilZFail = \
source.stencilZFail;\n    this.stencilZPass = source.stencilZPass;\n    \
this.stencilWrite = source.stencilWrite;\n    const srcPlanes = \
source.clippingPlanes;\n    let dstPlanes = null;\n    if (srcPlanes !== \
null) {\n      const n = srcPlanes.length;\n      dstPlanes = new Array(n);\n \
     for (let i = 0; i !== n; ++i) {\n        dstPlanes[i] = \
srcPlanes[i].clone();\n      }\n    }\n    this.clippingPlanes = dstPlanes;\n \
   this.clipIntersection = source.clipIntersection;\n    this.clipShadows = \
source.clipShadows;\n    this.shadowSide = source.shadowSide;\n    \
this.colorWrite = source.colorWrite;\n    this.precision = \
source.precision;\n    this.polygonOffset = source.polygonOffset;\n    \
this.polygonOffsetFactor = source.polygonOffsetFactor;\n    \
this.polygonOffsetUnits = source.polygonOffsetUnits;\n    this.dithering = \
source.dithering;\n    this.alphaTest = source.alphaTest;\n    this.alphaHash \
= source.alphaHash;\n    this.alphaToCoverage = source.alphaToCoverage;\n    \
this.premultipliedAlpha = source.premultipliedAlpha;\n    \
this.forceSinglePass = source.forceSinglePass;\n    this.visible = \
source.visible;\n    this.toneMapped = source.toneMapped;\n    this.userData \
= JSON.parse(JSON.stringify(source.userData));\n    return this;\n  }\n  \
dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n  set \
needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  \
onBuild() {\n    console.warn(\"Material: onBuild() has been removed.\");\n  \
}\n};\nvar MeshBasicMaterial = class extends Material {\n  static get type() \
{\n    return \"MeshBasicMaterial\";\n  }\n  constructor(parameters) {\n    \
super();\n    this.isMeshBasicMaterial = true;\n    this.color = new \
Color(16777215);\n    this.map = null;\n    this.lightMap = null;\n    \
this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity \
= 1;\n    this.specularMap = null;\n    this.alphaMap = null;\n    \
this.envMap = null;\n    this.envMapRotation = new Euler();\n    this.combine \
= MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = \
0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    \
this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n \
   this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n \
   super.copy(source);\n    this.color.copy(source.color);\n    this.map = \
source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity \
= source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    \
this.aoMapIntensity = source.aoMapIntensity;\n    this.specularMap = \
source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = \
source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    \
this.combine = source.combine;\n    this.reflectivity = \
source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    \
this.wireframe = source.wireframe;\n    this.wireframeLinewidth = \
source.wireframeLinewidth;\n    this.wireframeLinecap = \
source.wireframeLinecap;\n    this.wireframeLinejoin = \
source.wireframeLinejoin;\n    this.fog = source.fog;\n    return this;\n  \
}\n};\nvar _vector$9 = /* @__PURE__ */ new Vector3();\nvar _vector2$1 = /* \
@__PURE__ */ new Vector2();\nvar BufferAttribute = class {\n  \
constructor(array, itemSize, normalized = false) {\n    if \
(Array.isArray(array)) {\n      throw new TypeError(\"THREE.BufferAttribute: \
array should be a Typed Array.\");\n    }\n    this.isBufferAttribute = \
true;\n    this.name = \"\";\n    this.array = array;\n    this.itemSize = \
itemSize;\n    this.count = array !== void 0 ? array.length / itemSize : 0;\n \
   this.normalized = normalized;\n    this.usage = StaticDrawUsage;\n    \
this.updateRanges = [];\n    this.gpuType = FloatType;\n    this.version = \
0;\n  }\n  onUploadCallback() {\n  }\n  set needsUpdate(value) {\n    if \
(value === true) this.version++;\n  }\n  setUsage(value) {\n    this.usage = \
value;\n    return this;\n  }\n  addUpdateRange(start, count) {\n    \
this.updateRanges.push({ start, count });\n  }\n  clearUpdateRanges() {\n    \
this.updateRanges.length = 0;\n  }\n  copy(source) {\n    this.name = \
source.name;\n    this.array = new source.array.constructor(source.array);\n  \
  this.itemSize = source.itemSize;\n    this.count = source.count;\n    \
this.normalized = source.normalized;\n    this.usage = source.usage;\n    \
this.gpuType = source.gpuType;\n    return this;\n  }\n  copyAt(index1, \
attribute2, index22) {\n    index1 *= this.itemSize;\n    index22 *= \
attribute2.itemSize;\n    for (let i = 0, l = this.itemSize; i < l; i++) {\n  \
    this.array[index1 + i] = attribute2.array[index22 + i];\n    }\n    \
return this;\n  }\n  copyArray(array) {\n    this.array.set(array);\n    \
return this;\n  }\n  applyMatrix3(m2) {\n    if (this.itemSize === 2) {\n     \
 for (let i = 0, l = this.count; i < l; i++) {\n        \
_vector2$1.fromBufferAttribute(this, i);\n        \
_vector2$1.applyMatrix3(m2);\n        this.setXY(i, _vector2$1.x, \
_vector2$1.y);\n      }\n    } else if (this.itemSize === 3) {\n      for \
(let i = 0, l = this.count; i < l; i++) {\n        \
_vector$9.fromBufferAttribute(this, i);\n        \
_vector$9.applyMatrix3(m2);\n        this.setXYZ(i, _vector$9.x, _vector$9.y, \
_vector$9.z);\n      }\n    }\n    return this;\n  }\n  applyMatrix4(m2) {\n  \
  for (let i = 0, l = this.count; i < l; i++) {\n      \
_vector$9.fromBufferAttribute(this, i);\n      _vector$9.applyMatrix4(m2);\n  \
    this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return \
this;\n  }\n  applyNormalMatrix(m2) {\n    for (let i = 0, l = this.count; i \
< l; i++) {\n      _vector$9.fromBufferAttribute(this, i);\n      \
_vector$9.applyNormalMatrix(m2);\n      this.setXYZ(i, _vector$9.x, \
_vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  \
transformDirection(m2) {\n    for (let i = 0, l = this.count; i < l; i++) {\n \
     _vector$9.fromBufferAttribute(this, i);\n      \
_vector$9.transformDirection(m2);\n      this.setXYZ(i, _vector$9.x, \
_vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  set(value, offset \
= 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n  \
getComponent(index5, component) {\n    let value = this.array[index5 * \
this.itemSize + component];\n    if (this.normalized) value = \
denormalize(value, this.array);\n    return value;\n  }\n  \
setComponent(index5, component, value) {\n    if (this.normalized) value = \
normalize(value, this.array);\n    this.array[index5 * this.itemSize + \
component] = value;\n    return this;\n  }\n  getX(index5) {\n    let x2 = \
this.array[index5 * this.itemSize];\n    if (this.normalized) x2 = \
denormalize(x2, this.array);\n    return x2;\n  }\n  setX(index5, x2) {\n    \
if (this.normalized) x2 = normalize(x2, this.array);\n    this.array[index5 * \
this.itemSize] = x2;\n    return this;\n  }\n  getY(index5) {\n    let y2 = \
this.array[index5 * this.itemSize + 1];\n    if (this.normalized) y2 = \
denormalize(y2, this.array);\n    return y2;\n  }\n  setY(index5, y2) {\n    \
if (this.normalized) y2 = normalize(y2, this.array);\n    this.array[index5 * \
this.itemSize + 1] = y2;\n    return this;\n  }\n  getZ(index5) {\n    let z2 \
= this.array[index5 * this.itemSize + 2];\n    if (this.normalized) z2 = \
denormalize(z2, this.array);\n    return z2;\n  }\n  setZ(index5, z2) {\n    \
if (this.normalized) z2 = normalize(z2, this.array);\n    this.array[index5 * \
this.itemSize + 2] = z2;\n    return this;\n  }\n  getW(index5) {\n    let w \
= this.array[index5 * this.itemSize + 3];\n    if (this.normalized) w = \
denormalize(w, this.array);\n    return w;\n  }\n  setW(index5, w) {\n    if \
(this.normalized) w = normalize(w, this.array);\n    this.array[index5 * \
this.itemSize + 3] = w;\n    return this;\n  }\n  setXY(index5, x2, y2) {\n   \
 index5 *= this.itemSize;\n    if (this.normalized) {\n      x2 = \
normalize(x2, this.array);\n      y2 = normalize(y2, this.array);\n    }\n    \
this.array[index5 + 0] = x2;\n    this.array[index5 + 1] = y2;\n    return \
this;\n  }\n  setXYZ(index5, x2, y2, z2) {\n    index5 *= this.itemSize;\n    \
if (this.normalized) {\n      x2 = normalize(x2, this.array);\n      y2 = \
normalize(y2, this.array);\n      z2 = normalize(z2, this.array);\n    }\n    \
this.array[index5 + 0] = x2;\n    this.array[index5 + 1] = y2;\n    \
this.array[index5 + 2] = z2;\n    return this;\n  }\n  setXYZW(index5, x2, \
y2, z2, w) {\n    index5 *= this.itemSize;\n    if (this.normalized) {\n      \
x2 = normalize(x2, this.array);\n      y2 = normalize(y2, this.array);\n      \
z2 = normalize(z2, this.array);\n      w = normalize(w, this.array);\n    }\n \
   this.array[index5 + 0] = x2;\n    this.array[index5 + 1] = y2;\n    \
this.array[index5 + 2] = z2;\n    this.array[index5 + 3] = w;\n    return \
this;\n  }\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n   \
 return this;\n  }\n  clone() {\n    return new this.constructor(this.array, \
this.itemSize).copy(this);\n  }\n  toJSON() {\n    const data = {\n      \
itemSize: this.itemSize,\n      type: this.array.constructor.name,\n      \
array: Array.from(this.array),\n      normalized: this.normalized\n    };\n   \
 if (this.name !== \"\") data.name = this.name;\n    if (this.usage !== \
StaticDrawUsage) data.usage = this.usage;\n    return data;\n  }\n};\nvar \
Uint16BufferAttribute = class extends BufferAttribute {\n  constructor(array, \
itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, \
normalized);\n  }\n};\nvar Uint32BufferAttribute = class extends \
BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    \
super(new Uint32Array(array), itemSize, normalized);\n  }\n};\nvar \
Float32BufferAttribute = class extends BufferAttribute {\n  \
constructor(array, itemSize, normalized) {\n    super(new \
Float32Array(array), itemSize, normalized);\n  }\n};\nvar _id$2 = 0;\nvar \
_m1$2 = /* @__PURE__ */ new Matrix4();\nvar _obj = /* @__PURE__ */ new \
Object3D();\nvar _offset = /* @__PURE__ */ new Vector3();\nvar _box$2 = /* \
@__PURE__ */ new Box3();\nvar _boxMorphTargets = /* @__PURE__ */ new \
Box3();\nvar _vector$8 = /* @__PURE__ */ new Vector3();\nvar BufferGeometry = \
class _BufferGeometry extends EventDispatcher {\n  constructor() {\n    \
super();\n    this.isBufferGeometry = true;\n    Object.defineProperty(this, \
\"id\", { value: _id$2++ });\n    this.uuid = generateUUID();\n    this.name \
= \"\";\n    this.type = \"BufferGeometry\";\n    this.index = null;\n    \
this.indirect = null;\n    this.attributes = {};\n    this.morphAttributes = \
{};\n    this.morphTargetsRelative = false;\n    this.groups = [];\n    \
this.boundingBox = null;\n    this.boundingSphere = null;\n    this.drawRange \
= { start: 0, count: Infinity };\n    this.userData = {};\n  }\n  getIndex() \
{\n    return this.index;\n  }\n  setIndex(index5) {\n    if \
(Array.isArray(index5)) {\n      this.index = new (arrayNeedsUint32(index5) ? \
Uint32BufferAttribute : Uint16BufferAttribute)(index5, 1);\n    } else {\n    \
  this.index = index5;\n    }\n    return this;\n  }\n  setIndirect(indirect) \
{\n    this.indirect = indirect;\n    return this;\n  }\n  getIndirect() {\n  \
  return this.indirect;\n  }\n  getAttribute(name) {\n    return \
this.attributes[name];\n  }\n  setAttribute(name, attribute2) {\n    \
this.attributes[name] = attribute2;\n    return this;\n  }\n  \
deleteAttribute(name) {\n    delete this.attributes[name];\n    return \
this;\n  }\n  hasAttribute(name) {\n    return this.attributes[name] !== void \
0;\n  }\n  addGroup(start, count, materialIndex = 0) {\n    \
this.groups.push({\n      start,\n      count,\n      materialIndex\n    \
});\n  }\n  clearGroups() {\n    this.groups = [];\n  }\n  \
setDrawRange(start, count) {\n    this.drawRange.start = start;\n    \
this.drawRange.count = count;\n  }\n  applyMatrix4(matrix) {\n    const \
position = this.attributes.position;\n    if (position !== void 0) {\n      \
position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n   \
 const normal2 = this.attributes.normal;\n    if (normal2 !== void 0) {\n     \
 const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      \
normal2.applyNormalMatrix(normalMatrix);\n      normal2.needsUpdate = true;\n \
   }\n    const tangent = this.attributes.tangent;\n    if (tangent !== void \
0) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = \
true;\n    }\n    if (this.boundingBox !== null) {\n      \
this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n  \
    this.computeBoundingSphere();\n    }\n    return this;\n  }\n  \
applyQuaternion(q) {\n    _m1$2.makeRotationFromQuaternion(q);\n    \
this.applyMatrix4(_m1$2);\n    return this;\n  }\n  rotateX(angle) {\n    \
_m1$2.makeRotationX(angle);\n    this.applyMatrix4(_m1$2);\n    return \
this;\n  }\n  rotateY(angle) {\n    _m1$2.makeRotationY(angle);\n    \
this.applyMatrix4(_m1$2);\n    return this;\n  }\n  rotateZ(angle) {\n    \
_m1$2.makeRotationZ(angle);\n    this.applyMatrix4(_m1$2);\n    return \
this;\n  }\n  translate(x2, y2, z2) {\n    _m1$2.makeTranslation(x2, y2, \
z2);\n    this.applyMatrix4(_m1$2);\n    return this;\n  }\n  scale(x2, y2, \
z2) {\n    _m1$2.makeScale(x2, y2, z2);\n    this.applyMatrix4(_m1$2);\n    \
return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    \
_obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n \
 }\n  center() {\n    this.computeBoundingBox();\n    \
this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, \
_offset.y, _offset.z);\n    return this;\n  }\n  setFromPoints(points) {\n    \
const positionAttribute = this.getAttribute(\"position\");\n    if \
(positionAttribute === void 0) {\n      const position = [];\n      for (let \
i = 0, l = points.length; i < l; i++) {\n        const point = points[i];\n   \
     position.push(point.x, point.y, point.z || 0);\n      }\n      \
this.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n   \
 } else {\n      for (let i = 0, l = positionAttribute.count; i < l; i++) {\n \
       const point = points[i];\n        positionAttribute.setXYZ(i, point.x, \
point.y, point.z || 0);\n      }\n      if (points.length > \
positionAttribute.count) {\n        console.warn(\"THREE.BufferGeometry: \
Buffer size too small for points data. Use .dispose() and create a new \
geometry.\");\n      }\n      positionAttribute.needsUpdate = true;\n    }\n  \
  return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === \
null) {\n      this.boundingBox = new Box3();\n    }\n    const position = \
this.attributes.position;\n    const morphAttributesPosition = \
this.morphAttributes.position;\n    if (position && \
position.isGLBufferAttribute) {\n      \
console.error(\"THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute \
requires a manual bounding box.\", this);\n      this.boundingBox.set(\n      \
  new Vector3(-Infinity, -Infinity, -Infinity),\n        new \
Vector3(Infinity, Infinity, Infinity)\n      );\n      return;\n    }\n    if \
(position !== void 0) {\n      \
this.boundingBox.setFromBufferAttribute(position);\n      if \
(morphAttributesPosition) {\n        for (let i = 0, il = \
morphAttributesPosition.length; i < il; i++) {\n          const \
morphAttribute = morphAttributesPosition[i];\n          \
_box$2.setFromBufferAttribute(morphAttribute);\n          if \
(this.morphTargetsRelative) {\n            \
_vector$8.addVectors(this.boundingBox.min, _box$2.min);\n            \
this.boundingBox.expandByPoint(_vector$8);\n            \
_vector$8.addVectors(this.boundingBox.max, _box$2.max);\n            \
this.boundingBox.expandByPoint(_vector$8);\n          } else {\n            \
this.boundingBox.expandByPoint(_box$2.min);\n            \
this.boundingBox.expandByPoint(_box$2.max);\n          }\n        }\n      \
}\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n    if \
(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || \
isNaN(this.boundingBox.min.z)) {\n      \
console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max \
have NaN values. The \"position\" attribute is likely to have NaN values.', \
this);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere \
=== null) {\n      this.boundingSphere = new Sphere();\n    }\n    const \
position = this.attributes.position;\n    const morphAttributesPosition = \
this.morphAttributes.position;\n    if (position && \
position.isGLBufferAttribute) {\n      \
console.error(\"THREE.BufferGeometry.computeBoundingSphere(): \
GLBufferAttribute requires a manual bounding sphere.\", this);\n      \
this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n    \
if (position) {\n      const center = this.boundingSphere.center;\n      \
_box$2.setFromBufferAttribute(position);\n      if (morphAttributesPosition) \
{\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) \
{\n          const morphAttribute = morphAttributesPosition[i];\n          \
_boxMorphTargets.setFromBufferAttribute(morphAttribute);\n          if \
(this.morphTargetsRelative) {\n            _vector$8.addVectors(_box$2.min, \
_boxMorphTargets.min);\n            _box$2.expandByPoint(_vector$8);\n        \
    _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);\n            \
_box$2.expandByPoint(_vector$8);\n          } else {\n            \
_box$2.expandByPoint(_boxMorphTargets.min);\n            \
_box$2.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      \
}\n      _box$2.getCenter(center);\n      let maxRadiusSq = 0;\n      for \
(let i = 0, il = position.count; i < il; i++) {\n        \
_vector$8.fromBufferAttribute(position, i);\n        maxRadiusSq = \
Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n      }\n      \
if (morphAttributesPosition) {\n        for (let i = 0, il = \
morphAttributesPosition.length; i < il; i++) {\n          const \
morphAttribute = morphAttributesPosition[i];\n          const \
morphTargetsRelative = this.morphTargetsRelative;\n          for (let j = 0, \
jl = morphAttribute.count; j < jl; j++) {\n            \
_vector$8.fromBufferAttribute(morphAttribute, j);\n            if \
(morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, \
j);\n              _vector$8.add(_offset);\n            }\n            \
maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n   \
       }\n        }\n      }\n      this.boundingSphere.radius = \
Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n     \
   console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed \
radius is NaN. The \"position\" attribute is likely to have NaN values.', \
this);\n      }\n    }\n  }\n  computeTangents() {\n    const index5 = \
this.index;\n    const attributes = this.attributes;\n    if (index5 === null \
|| attributes.position === void 0 || attributes.normal === void 0 || \
attributes.uv === void 0) {\n      console.error(\"THREE.BufferGeometry: \
.computeTangents() failed. Missing required attributes (index, position, \
normal or uv)\");\n      return;\n    }\n    const positionAttribute = \
attributes.position;\n    const normalAttribute = attributes.normal;\n    \
const uvAttribute = attributes.uv;\n    if (this.hasAttribute(\"tangent\") \
=== false) {\n      this.setAttribute(\"tangent\", new BufferAttribute(new \
Float32Array(4 * positionAttribute.count), 4));\n    }\n    const \
tangentAttribute = this.getAttribute(\"tangent\");\n    const tan1 = [], tan2 \
= [];\n    for (let i = 0; i < positionAttribute.count; i++) {\n      tan1[i] \
= new Vector3();\n      tan2[i] = new Vector3();\n    }\n    const vA = new \
Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = \
new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new \
Vector3();\n    function handleTriangle(a2, b, c2) {\n      \
vA.fromBufferAttribute(positionAttribute, a2);\n      \
vB.fromBufferAttribute(positionAttribute, b);\n      \
vC.fromBufferAttribute(positionAttribute, c2);\n      \
uvA.fromBufferAttribute(uvAttribute, a2);\n      \
uvB.fromBufferAttribute(uvAttribute, b);\n      \
uvC.fromBufferAttribute(uvAttribute, c2);\n      vB.sub(vA);\n      \
vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1 / \
(uvB.x * uvC.y - uvC.x * uvB.y);\n      if (!isFinite(r)) return;\n      \
sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, \
-uvB.y).multiplyScalar(r);\n      \
tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, \
-uvC.x).multiplyScalar(r);\n      tan1[a2].add(sdir);\n      \
tan1[b].add(sdir);\n      tan1[c2].add(sdir);\n      tan2[a2].add(tdir);\n    \
  tan2[b].add(tdir);\n      tan2[c2].add(tdir);\n    }\n    let groups = \
this.groups;\n    if (groups.length === 0) {\n      groups = [{\n        \
start: 0,\n        count: index5.count\n      }];\n    }\n    for (let i = 0, \
il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      \
const start = group.start;\n      const count = group.count;\n      for (let \
j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(\n   \
       index5.getX(j + 0),\n          index5.getX(j + 1),\n          \
index5.getX(j + 2)\n        );\n      }\n    }\n    const tmp2 = new \
Vector3(), tmp22 = new Vector3();\n    const n = new Vector3(), n2 = new \
Vector3();\n    function handleVertex(v) {\n      \
n.fromBufferAttribute(normalAttribute, v);\n      n2.copy(n);\n      const t \
= tan1[v];\n      tmp2.copy(t);\n      \
tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();\n      \
tmp22.crossVectors(n2, t);\n      const test = tmp22.dot(tan2[v]);\n      \
const w = test < 0 ? -1 : 1;\n      tangentAttribute.setXYZW(v, tmp2.x, \
tmp2.y, tmp2.z, w);\n    }\n    for (let i = 0, il = groups.length; i < il; \
++i) {\n      const group = groups[i];\n      const start = group.start;\n    \
  const count = group.count;\n      for (let j = start, jl = start + count; j \
< jl; j += 3) {\n        handleVertex(index5.getX(j + 0));\n        \
handleVertex(index5.getX(j + 1));\n        handleVertex(index5.getX(j + \
2));\n      }\n    }\n  }\n  computeVertexNormals() {\n    const index5 = \
this.index;\n    const positionAttribute = this.getAttribute(\"position\");\n \
   if (positionAttribute !== void 0) {\n      let normalAttribute = \
this.getAttribute(\"normal\");\n      if (normalAttribute === void 0) {\n     \
   normalAttribute = new BufferAttribute(new \
Float32Array(positionAttribute.count * 3), 3);\n        \
this.setAttribute(\"normal\", normalAttribute);\n      } else {\n        for \
(let i = 0, il = normalAttribute.count; i < il; i++) {\n          \
normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n      const pA = new \
Vector3(), pB = new Vector3(), pC = new Vector3();\n      const nA = new \
Vector3(), nB = new Vector3(), nC = new Vector3();\n      const cb = new \
Vector3(), ab = new Vector3();\n      if (index5) {\n        for (let i = 0, \
il = index5.count; i < il; i += 3) {\n          const vA = index5.getX(i + \
0);\n          const vB = index5.getX(i + 1);\n          const vC = \
index5.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, \
vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          \
pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, \
pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          \
nA.fromBufferAttribute(normalAttribute, vA);\n          \
nB.fromBufferAttribute(normalAttribute, vB);\n          \
nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n         \
 nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, \
nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n \
         normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } \
else {\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) \
{\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          \
pB.fromBufferAttribute(positionAttribute, i + 1);\n          \
pC.fromBufferAttribute(positionAttribute, i + 2);\n          \
cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          \
cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n   \
       normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          \
normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n      \
this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  \
}\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n    \
for (let i = 0, il = normals.count; i < il; i++) {\n      \
_vector$8.fromBufferAttribute(normals, i);\n      _vector$8.normalize();\n    \
  normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);\n    }\n  }\n  \
toNonIndexed() {\n    function convertBufferAttribute(attribute2, indices2) \
{\n      const array = attribute2.array;\n      const itemSize = \
attribute2.itemSize;\n      const normalized = attribute2.normalized;\n      \
const array2 = new array.constructor(indices2.length * itemSize);\n      let \
index5 = 0, index22 = 0;\n      for (let i = 0, l = indices2.length; i < l; \
i++) {\n        if (attribute2.isInterleavedBufferAttribute) {\n          \
index5 = indices2[i] * attribute2.data.stride + attribute2.offset;\n        } \
else {\n          index5 = indices2[i] * itemSize;\n        }\n        for \
(let j = 0; j < itemSize; j++) {\n          array2[index22++] = \
array[index5++];\n        }\n      }\n      return new \
BufferAttribute(array2, itemSize, normalized);\n    }\n    if (this.index === \
null) {\n      console.warn(\"THREE.BufferGeometry.toNonIndexed(): \
BufferGeometry is already non-indexed.\");\n      return this;\n    }\n    \
const geometry2 = new _BufferGeometry();\n    const indices = \
this.index.array;\n    const attributes = this.attributes;\n    for (const \
name in attributes) {\n      const attribute2 = attributes[name];\n      \
const newAttribute = convertBufferAttribute(attribute2, indices);\n      \
geometry2.setAttribute(name, newAttribute);\n    }\n    const morphAttributes \
= this.morphAttributes;\n    for (const name in morphAttributes) {\n      \
const morphArray = [];\n      const morphAttribute = morphAttributes[name];\n \
     for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        \
const attribute2 = morphAttribute[i];\n        const newAttribute = \
convertBufferAttribute(attribute2, indices);\n        \
morphArray.push(newAttribute);\n      }\n      \
geometry2.morphAttributes[name] = morphArray;\n    }\n    \
geometry2.morphTargetsRelative = this.morphTargetsRelative;\n    const groups \
= this.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      \
const group = groups[i];\n      geometry2.addGroup(group.start, group.count, \
group.materialIndex);\n    }\n    return geometry2;\n  }\n  toJSON() {\n    \
const data = {\n      metadata: {\n        version: 4.6,\n        type: \
\"BufferGeometry\",\n        generator: \"BufferGeometry.toJSON\"\n      }\n  \
  };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if \
(this.name !== \"\") data.name = this.name;\n    if \
(Object.keys(this.userData).length > 0) data.userData = this.userData;\n    \
if (this.parameters !== void 0) {\n      const parameters = \
this.parameters;\n      for (const key in parameters) {\n        if \
(parameters[key] !== void 0) data[key] = parameters[key];\n      }\n      \
return data;\n    }\n    data.data = { attributes: {} };\n    const index5 = \
this.index;\n    if (index5 !== null) {\n      data.data.index = {\n        \
type: index5.array.constructor.name,\n        array: \
Array.prototype.slice.call(index5.array)\n      };\n    }\n    const \
attributes = this.attributes;\n    for (const key in attributes) {\n      \
const attribute2 = attributes[key];\n      data.data.attributes[key] = \
attribute2.toJSON(data.data);\n    }\n    const morphAttributes = {};\n    \
let hasMorphAttributes = false;\n    for (const key in this.morphAttributes) \
{\n      const attributeArray = this.morphAttributes[key];\n      const array \
= [];\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n     \
   const attribute2 = attributeArray[i];\n        \
array.push(attribute2.toJSON(data.data));\n      }\n      if (array.length > \
0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = \
true;\n      }\n    }\n    if (hasMorphAttributes) {\n      \
data.data.morphAttributes = morphAttributes;\n      \
data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n    const \
groups = this.groups;\n    if (groups.length > 0) {\n      data.data.groups = \
JSON.parse(JSON.stringify(groups));\n    }\n    const boundingSphere = \
this.boundingSphere;\n    if (boundingSphere !== null) {\n      \
data.data.boundingSphere = {\n        center: \
boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n     \
 };\n    }\n    return data;\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n  copy(source) {\n    this.index = \
null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    \
this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = \
null;\n    const data = {};\n    this.name = source.name;\n    const index5 = \
source.index;\n    if (index5 !== null) {\n      \
this.setIndex(index5.clone(data));\n    }\n    const attributes = \
source.attributes;\n    for (const name in attributes) {\n      const \
attribute2 = attributes[name];\n      this.setAttribute(name, \
attribute2.clone(data));\n    }\n    const morphAttributes = \
source.morphAttributes;\n    for (const name in morphAttributes) {\n      \
const array = [];\n      const morphAttribute = morphAttributes[name];\n      \
for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        \
array.push(morphAttribute[i].clone(data));\n      }\n      \
this.morphAttributes[name] = array;\n    }\n    this.morphTargetsRelative = \
source.morphTargetsRelative;\n    const groups = source.groups;\n    for (let \
i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n     \
 this.addGroup(group.start, group.count, group.materialIndex);\n    }\n    \
const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n    \
  this.boundingBox = boundingBox.clone();\n    }\n    const boundingSphere = \
source.boundingSphere;\n    if (boundingSphere !== null) {\n      \
this.boundingSphere = boundingSphere.clone();\n    }\n    \
this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = \
source.drawRange.count;\n    this.userData = source.userData;\n    return \
this;\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  \
}\n};\nvar _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();\nvar _ray$3 = /* \
@__PURE__ */ new Ray();\nvar _sphere$6 = /* @__PURE__ */ new Sphere();\nvar \
_sphereHitAt = /* @__PURE__ */ new Vector3();\nvar _vA$1 = /* @__PURE__ */ \
new Vector3();\nvar _vB$1 = /* @__PURE__ */ new Vector3();\nvar _vC$1 = /* \
@__PURE__ */ new Vector3();\nvar _tempA = /* @__PURE__ */ new Vector3();\nvar \
_morphA = /* @__PURE__ */ new Vector3();\nvar _intersectionPoint = /* \
@__PURE__ */ new Vector3();\nvar _intersectionPointWorld = /* @__PURE__ */ \
new Vector3();\nvar Mesh = class extends Object3D {\n  constructor(geometry = \
new BufferGeometry(), material = new MeshBasicMaterial()) {\n    super();\n   \
 this.isMesh = true;\n    this.type = \"Mesh\";\n    this.geometry = \
geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  \
}\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if \
(source.morphTargetInfluences !== void 0) {\n      this.morphTargetInfluences \
= source.morphTargetInfluences.slice();\n    }\n    if \
(source.morphTargetDictionary !== void 0) {\n      this.morphTargetDictionary \
= Object.assign({}, source.morphTargetDictionary);\n    }\n    this.material \
= Array.isArray(source.material) ? source.material.slice() : \
source.material;\n    this.geometry = source.geometry;\n    return this;\n  \
}\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const \
morphAttributes = geometry.morphAttributes;\n    const keys = \
Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const \
morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== void \
0) {\n        this.morphTargetInfluences = [];\n        \
this.morphTargetDictionary = {};\n        for (let m2 = 0, ml = \
morphAttribute.length; m2 < ml; m2++) {\n          const name = \
morphAttribute[m2].name || String(m2);\n          \
this.morphTargetInfluences.push(0);\n          \
this.morphTargetDictionary[name] = m2;\n        }\n      }\n    }\n  }\n  \
getVertexPosition(index5, target) {\n    const geometry = this.geometry;\n    \
const position = geometry.attributes.position;\n    const morphPosition = \
geometry.morphAttributes.position;\n    const morphTargetsRelative = \
geometry.morphTargetsRelative;\n    target.fromBufferAttribute(position, \
index5);\n    const morphInfluences = this.morphTargetInfluences;\n    if \
(morphPosition && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      for \
(let i = 0, il = morphPosition.length; i < il; i++) {\n        const \
influence = morphInfluences[i];\n        const morphAttribute = \
morphPosition[i];\n        if (influence === 0) continue;\n        \
_tempA.fromBufferAttribute(morphAttribute, index5);\n        if \
(morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, \
influence);\n        } else {\n          \
_morphA.addScaledVector(_tempA.sub(target), influence);\n        }\n      }\n \
     target.add(_morphA);\n    }\n    return target;\n  }\n  \
raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    \
const material = this.material;\n    const matrixWorld = this.matrixWorld;\n  \
  if (material === void 0) return;\n    if (geometry.boundingSphere === null) \
geometry.computeBoundingSphere();\n    \
_sphere$6.copy(geometry.boundingSphere);\n    \
_sphere$6.applyMatrix4(matrixWorld);\n    \
_ray$3.copy(raycaster.ray).recast(raycaster.near);\n    if \
(_sphere$6.containsPoint(_ray$3.origin) === false) {\n      if \
(_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;\n      if \
(_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - \
raycaster.near) ** 2) return;\n    }\n    \
_inverseMatrix$3.copy(matrixWorld).invert();\n    \
_ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);\n    if \
(geometry.boundingBox !== null) {\n      if \
(_ray$3.intersectsBox(geometry.boundingBox) === false) return;\n    }\n    \
this._computeIntersections(raycaster, intersects, _ray$3);\n  }\n  \
_computeIntersections(raycaster, intersects, rayLocalSpace) {\n    let \
intersection;\n    const geometry = this.geometry;\n    const material = \
this.material;\n    const index5 = geometry.index;\n    const position = \
geometry.attributes.position;\n    const uv2 = geometry.attributes.uv;\n    \
const uv1 = geometry.attributes.uv1;\n    const normal2 = \
geometry.attributes.normal;\n    const groups = geometry.groups;\n    const \
drawRange = geometry.drawRange;\n    if (index5 !== null) {\n      if \
(Array.isArray(material)) {\n        for (let i = 0, il = groups.length; i < \
il; i++) {\n          const group = groups[i];\n          const groupMaterial \
= material[group.materialIndex];\n          const start = \
Math.max(group.start, drawRange.start);\n          const end = \
Math.min(index5.count, Math.min(group.start + group.count, drawRange.start + \
drawRange.count));\n          for (let j = start, jl = end; j < jl; j += 3) \
{\n            const a2 = index5.getX(j);\n            const b = \
index5.getX(j + 1);\n            const c2 = index5.getX(j + 2);\n            \
intersection = checkGeometryIntersection(this, groupMaterial, raycaster, \
rayLocalSpace, uv2, uv1, normal2, a2, b, c2);\n            if (intersection) \
{\n              intersection.faceIndex = Math.floor(j / 3);\n              \
intersection.face.materialIndex = group.materialIndex;\n              \
intersects.push(intersection);\n            }\n          }\n        }\n      \
} else {\n        const start = Math.max(0, drawRange.start);\n        const \
end = Math.min(index5.count, drawRange.start + drawRange.count);\n        for \
(let i = start, il = end; i < il; i += 3) {\n          const a2 = \
index5.getX(i);\n          const b = index5.getX(i + 1);\n          const c2 \
= index5.getX(i + 2);\n          intersection = \
checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv2, uv1, \
normal2, a2, b, c2);\n          if (intersection) {\n            \
intersection.faceIndex = Math.floor(i / 3);\n            \
intersects.push(intersection);\n          }\n        }\n      }\n    } else \
if (position !== void 0) {\n      if (Array.isArray(material)) {\n        for \
(let i = 0, il = groups.length; i < il; i++) {\n          const group = \
groups[i];\n          const groupMaterial = material[group.materialIndex];\n  \
        const start = Math.max(group.start, drawRange.start);\n          \
const end = Math.min(position.count, Math.min(group.start + group.count, \
drawRange.start + drawRange.count));\n          for (let j = start, jl = end; \
j < jl; j += 3) {\n            const a2 = j;\n            const b = j + 1;\n  \
          const c2 = j + 2;\n            intersection = \
checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv2, \
uv1, normal2, a2, b, c2);\n            if (intersection) {\n              \
intersection.faceIndex = Math.floor(j / 3);\n              \
intersection.face.materialIndex = group.materialIndex;\n              \
intersects.push(intersection);\n            }\n          }\n        }\n      \
} else {\n        const start = Math.max(0, drawRange.start);\n        const \
end = Math.min(position.count, drawRange.start + drawRange.count);\n        \
for (let i = start, il = end; i < il; i += 3) {\n          const a2 = i;\n    \
      const b = i + 1;\n          const c2 = i + 2;\n          intersection = \
checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv2, uv1, \
normal2, a2, b, c2);\n          if (intersection) {\n            \
intersection.faceIndex = Math.floor(i / 3);\n            \
intersects.push(intersection);\n          }\n        }\n      }\n    }\n  \
}\n};\nfunction checkIntersection$1(object, material, raycaster, ray, pA, pB, \
pC, point) {\n  let intersect2;\n  if (material.side === BackSide) {\n    \
intersect2 = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    \
intersect2 = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, \
point);\n  }\n  if (intersect2 === null) return null;\n  \
_intersectionPointWorld.copy(point);\n  \
_intersectionPointWorld.applyMatrix4(object.matrixWorld);\n  const distance2 \
= raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance2 \
< raycaster.near || distance2 > raycaster.far) return null;\n  return {\n    \
distance: distance2,\n    point: _intersectionPointWorld.clone(),\n    \
object\n  };\n}\nfunction checkGeometryIntersection(object, material, \
raycaster, ray, uv2, uv1, normal2, a2, b, c2) {\n  \
object.getVertexPosition(a2, _vA$1);\n  object.getVertexPosition(b, _vB$1);\n \
 object.getVertexPosition(c2, _vC$1);\n  const intersection = \
checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, \
_intersectionPoint);\n  if (intersection) {\n    const barycoord = new \
Vector3();\n    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, \
_vC$1, barycoord);\n    if (uv2) {\n      intersection.uv = \
Triangle.getInterpolatedAttribute(uv2, a2, b, c2, barycoord, new \
Vector2());\n    }\n    if (uv1) {\n      intersection.uv1 = \
Triangle.getInterpolatedAttribute(uv1, a2, b, c2, barycoord, new \
Vector2());\n    }\n    if (normal2) {\n      intersection.normal = \
Triangle.getInterpolatedAttribute(normal2, a2, b, c2, barycoord, new \
Vector3());\n      if (intersection.normal.dot(ray.direction) > 0) {\n        \
intersection.normal.multiplyScalar(-1);\n      }\n    }\n    const face = {\n \
     a: a2,\n      b,\n      c: c2,\n      normal: new Vector3(),\n      \
materialIndex: 0\n    };\n    Triangle.getNormal(_vA$1, _vB$1, _vC$1, \
face.normal);\n    intersection.face = face;\n    intersection.barycoord = \
barycoord;\n  }\n  return intersection;\n}\nvar BoxGeometry = class \
_BoxGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, \
depth2 = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n    \
super();\n    this.type = \"BoxGeometry\";\n    this.parameters = {\n      \
width,\n      height,\n      depth: depth2,\n      widthSegments,\n      \
heightSegments,\n      depthSegments\n    };\n    const scope = this;\n    \
widthSegments = Math.floor(widthSegments);\n    heightSegments = \
Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments);\n \
   const indices = [];\n    const vertices = [];\n    const normals = [];\n   \
 const uvs = [];\n    let numberOfVertices = 0;\n    let groupStart = 0;\n    \
buildPlane(\"z\", \"y\", \"x\", -1, -1, depth2, height, width, depthSegments, \
heightSegments, 0);\n    buildPlane(\"z\", \"y\", \"x\", 1, -1, depth2, \
height, -width, depthSegments, heightSegments, 1);\n    buildPlane(\"x\", \
\"z\", \"y\", 1, 1, width, depth2, height, widthSegments, depthSegments, \
2);\n    buildPlane(\"x\", \"z\", \"y\", 1, -1, width, depth2, -height, \
widthSegments, depthSegments, 3);\n    buildPlane(\"x\", \"y\", \"z\", 1, -1, \
width, height, depth2, widthSegments, heightSegments, 4);\n    \
buildPlane(\"x\", \"y\", \"z\", -1, -1, width, height, -depth2, \
widthSegments, heightSegments, 5);\n    this.setIndex(indices);\n    \
this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n   \
 this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    \
this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function \
buildPlane(u, v, w, udir, vdir, width2, height2, depth3, gridX, gridY, \
materialIndex) {\n      const segmentWidth = width2 / gridX;\n      const \
segmentHeight = height2 / gridY;\n      const widthHalf = width2 / 2;\n      \
const heightHalf = height2 / 2;\n      const depthHalf = depth3 / 2;\n      \
const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      let \
vertexCounter = 0;\n      let groupCount = 0;\n      const vector = new \
Vector3();\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y2 = \
iy * segmentHeight - heightHalf;\n        for (let ix = 0; ix < gridX1; ix++) \
{\n          const x2 = ix * segmentWidth - widthHalf;\n          vector[u] = \
x2 * udir;\n          vector[v] = y2 * vdir;\n          vector[w] = \
depthHalf;\n          vertices.push(vector.x, vector.y, vector.z);\n          \
vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth3 > 0 ? \
1 : -1;\n          normals.push(vector.x, vector.y, vector.z);\n          \
uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n          \
vertexCounter += 1;\n        }\n      }\n      for (let iy = 0; iy < gridY; \
iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a2 = \
numberOfVertices + ix + gridX1 * iy;\n          const b = numberOfVertices + \
ix + gridX1 * (iy + 1);\n          const c2 = numberOfVertices + (ix + 1) + \
gridX1 * (iy + 1);\n          const d = numberOfVertices + (ix + 1) + gridX1 \
* iy;\n          indices.push(a2, b, d);\n          indices.push(b, c2, d);\n \
         groupCount += 6;\n        }\n      }\n      \
scope.addGroup(groupStart, groupCount, materialIndex);\n      groupStart += \
groupCount;\n      numberOfVertices += vertexCounter;\n    }\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.parameters = \
Object.assign({}, source.parameters);\n    return this;\n  }\n  static \
fromJSON(data) {\n    return new _BoxGeometry(data.width, data.height, \
data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n  \
}\n};\nfunction cloneUniforms(src) {\n  const dst = {};\n  for (const u in \
src) {\n    dst[u] = {};\n    for (const p in src[u]) {\n      const \
property2 = src[u][p];\n      if (property2 && (property2.isColor || \
property2.isMatrix3 || property2.isMatrix4 || property2.isVector2 || \
property2.isVector3 || property2.isVector4 || property2.isTexture || \
property2.isQuaternion)) {\n        if (property2.isRenderTargetTexture) {\n  \
        console.warn(\"UniformsUtils: Textures of render targets cannot be \
cloned via cloneUniforms() or mergeUniforms().\");\n          dst[u][p] = \
null;\n        } else {\n          dst[u][p] = property2.clone();\n        \
}\n      } else if (Array.isArray(property2)) {\n        dst[u][p] = \
property2.slice();\n      } else {\n        dst[u][p] = property2;\n      }\n \
   }\n  }\n  return dst;\n}\nfunction mergeUniforms(uniforms) {\n  const \
merged = {};\n  for (let u = 0; u < uniforms.length; u++) {\n    const tmp2 = \
cloneUniforms(uniforms[u]);\n    for (const p in tmp2) {\n      merged[p] = \
tmp2[p];\n    }\n  }\n  return merged;\n}\nfunction cloneUniformsGroups(src) \
{\n  const dst = [];\n  for (let u = 0; u < src.length; u++) {\n    \
dst.push(src[u].clone());\n  }\n  return dst;\n}\nfunction \
getUnlitUniformColorSpace(renderer3) {\n  const currentRenderTarget = \
renderer3.getRenderTarget();\n  if (currentRenderTarget === null) {\n    \
return renderer3.outputColorSpace;\n  }\n  if \
(currentRenderTarget.isXRRenderTarget === true) {\n    return \
currentRenderTarget.texture.colorSpace;\n  }\n  return \
ColorManagement.workingColorSpace;\n}\nvar UniformsUtils = { clone: \
cloneUniforms, merge: mergeUniforms };\nvar default_vertex = \"void main() \
{\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 \
);\\n}\";\nvar default_fragment = \"void main() {\\n\tgl_FragColor = vec4( \
1.0, 0.0, 0.0, 1.0 );\\n}\";\nvar ShaderMaterial = class extends Material {\n \
 static get type() {\n    return \"ShaderMaterial\";\n  }\n  \
constructor(parameters) {\n    super();\n    this.isShaderMaterial = true;\n  \
  this.defines = {};\n    this.uniforms = {};\n    this.uniformsGroups = \
[];\n    this.vertexShader = default_vertex;\n    this.fragmentShader = \
default_fragment;\n    this.linewidth = 1;\n    this.wireframe = false;\n    \
this.wireframeLinewidth = 1;\n    this.fog = false;\n    this.lights = \
false;\n    this.clipping = false;\n    this.forceSinglePass = true;\n    \
this.extensions = {\n      clipCullDistance: false,\n      // set to use \
vertex shader clipping\n      multiDraw: false\n      // set to use vertex \
shader multi_draw / enable gl_DrawID\n    };\n    this.defaultAttributeValues \
= {\n      \"color\": [1, 1, 1],\n      \"uv\": [0, 0],\n      \"uv1\": [0, \
0]\n    };\n    this.index0AttributeName = void 0;\n    \
this.uniformsNeedUpdate = false;\n    this.glslVersion = null;\n    if \
(parameters !== void 0) {\n      this.setValues(parameters);\n    }\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.fragmentShader = \
source.fragmentShader;\n    this.vertexShader = source.vertexShader;\n    \
this.uniforms = cloneUniforms(source.uniforms);\n    this.uniformsGroups = \
cloneUniformsGroups(source.uniformsGroups);\n    this.defines = \
Object.assign({}, source.defines);\n    this.wireframe = source.wireframe;\n  \
  this.wireframeLinewidth = source.wireframeLinewidth;\n    this.fog = \
source.fog;\n    this.lights = source.lights;\n    this.clipping = \
source.clipping;\n    this.extensions = Object.assign({}, \
source.extensions);\n    this.glslVersion = source.glslVersion;\n    return \
this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    \
data.glslVersion = this.glslVersion;\n    data.uniforms = {};\n    for (const \
name in this.uniforms) {\n      const uniform2 = this.uniforms[name];\n      \
const value = uniform2.value;\n      if (value && value.isTexture) {\n        \
data.uniforms[name] = {\n          type: \"t\",\n          value: \
value.toJSON(meta).uuid\n        };\n      } else if (value && value.isColor) \
{\n        data.uniforms[name] = {\n          type: \"c\",\n          value: \
value.getHex()\n        };\n      } else if (value && value.isVector2) {\n    \
    data.uniforms[name] = {\n          type: \"v2\",\n          value: \
value.toArray()\n        };\n      } else if (value && value.isVector3) {\n   \
     data.uniforms[name] = {\n          type: \"v3\",\n          value: \
value.toArray()\n        };\n      } else if (value && value.isVector4) {\n   \
     data.uniforms[name] = {\n          type: \"v4\",\n          value: \
value.toArray()\n        };\n      } else if (value && value.isMatrix3) {\n   \
     data.uniforms[name] = {\n          type: \"m3\",\n          value: \
value.toArray()\n        };\n      } else if (value && value.isMatrix4) {\n   \
     data.uniforms[name] = {\n          type: \"m4\",\n          value: \
value.toArray()\n        };\n      } else {\n        data.uniforms[name] = \
{\n          value\n        };\n      }\n    }\n    if \
(Object.keys(this.defines).length > 0) data.defines = this.defines;\n    \
data.vertexShader = this.vertexShader;\n    data.fragmentShader = \
this.fragmentShader;\n    data.lights = this.lights;\n    data.clipping = \
this.clipping;\n    const extensions = {};\n    for (const key in \
this.extensions) {\n      if (this.extensions[key] === true) extensions[key] \
= true;\n    }\n    if (Object.keys(extensions).length > 0) data.extensions = \
extensions;\n    return data;\n  }\n};\nvar Camera = class extends Object3D \
{\n  constructor() {\n    super();\n    this.isCamera = true;\n    this.type \
= \"Camera\";\n    this.matrixWorldInverse = new Matrix4();\n    \
this.projectionMatrix = new Matrix4();\n    this.projectionMatrixInverse = \
new Matrix4();\n    this.coordinateSystem = WebGLCoordinateSystem;\n  }\n  \
copy(source, recursive) {\n    super.copy(source, recursive);\n    \
this.matrixWorldInverse.copy(source.matrixWorldInverse);\n    \
this.projectionMatrix.copy(source.projectionMatrix);\n    \
this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n    \
this.coordinateSystem = source.coordinateSystem;\n    return this;\n  }\n  \
getWorldDirection(target) {\n    return \
super.getWorldDirection(target).negate();\n  }\n  updateMatrixWorld(force) \
{\n    super.updateMatrixWorld(force);\n    \
this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  \
updateWorldMatrix(updateParents, updateChildren) {\n    \
super.updateWorldMatrix(updateParents, updateChildren);\n    \
this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  clone() {\n  \
  return new this.constructor().copy(this);\n  }\n};\nvar _v3$1 = /* \
@__PURE__ */ new Vector3();\nvar _minTarget = /* @__PURE__ */ new \
Vector2();\nvar _maxTarget = /* @__PURE__ */ new Vector2();\nvar \
PerspectiveCamera = class extends Camera {\n  constructor(fov3 = 50, aspect3 \
= 1, near = 0.1, far = 2e3) {\n    super();\n    this.isPerspectiveCamera = \
true;\n    this.type = \"PerspectiveCamera\";\n    this.fov = fov3;\n    \
this.zoom = 1;\n    this.near = near;\n    this.far = far;\n    this.focus = \
10;\n    this.aspect = aspect3;\n    this.view = null;\n    this.filmGauge = \
35;\n    this.filmOffset = 0;\n    this.updateProjectionMatrix();\n  }\n  \
copy(source, recursive) {\n    super.copy(source, recursive);\n    this.fov = \
source.fov;\n    this.zoom = source.zoom;\n    this.near = source.near;\n    \
this.far = source.far;\n    this.focus = source.focus;\n    this.aspect = \
source.aspect;\n    this.view = source.view === null ? null : \
Object.assign({}, source.view);\n    this.filmGauge = source.filmGauge;\n    \
this.filmOffset = source.filmOffset;\n    return this;\n  }\n  /**\n   * Sets \
the FOV by focal length in respect to the current .filmGauge.\n   *\n   * The \
default film gauge is 35, so that the focal length can be specified for\n   * \
a 35mm (full frame) camera.\n   *\n   * Values for focal length and film \
gauge must have the same unit.\n   */\n  setFocalLength(focalLength) {\n    \
const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov \
= RAD2DEG * 2 * Math.atan(vExtentSlope);\n    \
this.updateProjectionMatrix();\n  }\n  /**\n   * Calculates the focal length \
from the current .fov and .filmGauge.\n   */\n  getFocalLength() {\n    const \
vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n    return 0.5 * \
this.getFilmHeight() / vExtentSlope;\n  }\n  getEffectiveFOV() {\n    return \
RAD2DEG * 2 * Math.atan(\n      Math.tan(DEG2RAD * 0.5 * this.fov) / \
this.zoom\n    );\n  }\n  getFilmWidth() {\n    return this.filmGauge * \
Math.min(this.aspect, 1);\n  }\n  getFilmHeight() {\n    return \
this.filmGauge / Math.max(this.aspect, 1);\n  }\n  /**\n   * Computes the 2D \
bounds of the camera's viewable rectangle at a given distance along the \
viewing direction.\n   * Sets minTarget and maxTarget to the coordinates of \
the lower-left and upper-right corners of the view rectangle.\n   */\n  \
getViewBounds(distance2, minTarget, maxTarget) {\n    _v3$1.set(-1, -1, \
0.5).applyMatrix4(this.projectionMatrixInverse);\n    minTarget.set(_v3$1.x, \
_v3$1.y).multiplyScalar(-distance2 / _v3$1.z);\n    _v3$1.set(1, 1, \
0.5).applyMatrix4(this.projectionMatrixInverse);\n    maxTarget.set(_v3$1.x, \
_v3$1.y).multiplyScalar(-distance2 / _v3$1.z);\n  }\n  /**\n   * Computes the \
width and height of the camera's viewable rectangle at a given distance along \
the viewing direction.\n   * Copies the result into the target Vector2, where \
x is width and y is height.\n   */\n  getViewSize(distance2, target) {\n    \
this.getViewBounds(distance2, _minTarget, _maxTarget);\n    return \
target.subVectors(_maxTarget, _minTarget);\n  }\n  /**\n   * Sets an offset \
in a larger frustum. This is useful for multi-window or\n   * \
multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 \
monitors and each monitor is 1920x1080 and\n   * the monitors are in grid \
like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   \
+---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then \
for each monitor you would call it like this\n   *\n   *   const w = 1920;\n  \
 *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const \
fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( \
fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   \
camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   \
--C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h \
);\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, \
h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, \
fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( \
fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no \
reason monitors have to be the same size or in a grid.\n   */\n  \
setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {\n    \
this.aspect = fullWidth / fullHeight;\n    if (this.view === null) {\n      \
this.view = {\n        enabled: true,\n        fullWidth: 1,\n        \
fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n \
       height: 1\n      };\n    }\n    this.view.enabled = true;\n    \
this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    \
this.view.offsetX = x2;\n    this.view.offsetY = y2;\n    this.view.width = \
width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  \
}\n  clearViewOffset() {\n    if (this.view !== null) {\n      \
this.view.enabled = false;\n    }\n    this.updateProjectionMatrix();\n  }\n  \
updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * \
Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n  \
  let width = this.aspect * height;\n    let left = -0.5 * width;\n    const \
view = this.view;\n    if (this.view !== null && this.view.enabled) {\n      \
const fullWidth = view.fullWidth, fullHeight = view.fullHeight;\n      left \
+= view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / \
fullHeight;\n      width *= view.width / fullWidth;\n      height *= \
view.height / fullHeight;\n    }\n    const skew = this.filmOffset;\n    if \
(skew !== 0) left += near * skew / this.getFilmWidth();\n    \
this.projectionMatrix.makePerspective(left, left + width, top, top - height, \
near, this.far, this.coordinateSystem);\n    \
this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  \
toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.fov = \
this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = \
this.near;\n    data.object.far = this.far;\n    data.object.focus = \
this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== \
null) data.object.view = Object.assign({}, this.view);\n    \
data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = \
this.filmOffset;\n    return data;\n  }\n};\nvar fov = -90;\nvar aspect = \
1;\nvar CubeCamera = class extends Object3D {\n  constructor(near, far, \
renderTarget) {\n    super();\n    this.type = \"CubeCamera\";\n    \
this.renderTarget = renderTarget;\n    this.coordinateSystem = null;\n    \
this.activeMipmapLevel = 0;\n    const cameraPX = new PerspectiveCamera(fov, \
aspect, near, far);\n    cameraPX.layers = this.layers;\n    \
this.add(cameraPX);\n    const cameraNX = new PerspectiveCamera(fov, aspect, \
near, far);\n    cameraNX.layers = this.layers;\n    this.add(cameraNX);\n    \
const cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n    \
cameraPY.layers = this.layers;\n    this.add(cameraPY);\n    const cameraNY = \
new PerspectiveCamera(fov, aspect, near, far);\n    cameraNY.layers = \
this.layers;\n    this.add(cameraNY);\n    const cameraPZ = new \
PerspectiveCamera(fov, aspect, near, far);\n    cameraPZ.layers = \
this.layers;\n    this.add(cameraPZ);\n    const cameraNZ = new \
PerspectiveCamera(fov, aspect, near, far);\n    cameraNZ.layers = \
this.layers;\n    this.add(cameraNZ);\n  }\n  updateCoordinateSystem() {\n    \
const coordinateSystem = this.coordinateSystem;\n    const cameras = \
this.children.concat();\n    const [cameraPX, cameraNX, cameraPY, cameraNY, \
cameraPZ, cameraNZ] = cameras;\n    for (const camera3 of cameras) \
this.remove(camera3);\n    if (coordinateSystem === WebGLCoordinateSystem) \
{\n      cameraPX.up.set(0, 1, 0);\n      cameraPX.lookAt(1, 0, 0);\n      \
cameraNX.up.set(0, 1, 0);\n      cameraNX.lookAt(-1, 0, 0);\n      \
cameraPY.up.set(0, 0, -1);\n      cameraPY.lookAt(0, 1, 0);\n      \
cameraNY.up.set(0, 0, 1);\n      cameraNY.lookAt(0, -1, 0);\n      \
cameraPZ.up.set(0, 1, 0);\n      cameraPZ.lookAt(0, 0, 1);\n      \
cameraNZ.up.set(0, 1, 0);\n      cameraNZ.lookAt(0, 0, -1);\n    } else if \
(coordinateSystem === WebGPUCoordinateSystem) {\n      cameraPX.up.set(0, -1, \
0);\n      cameraPX.lookAt(-1, 0, 0);\n      cameraNX.up.set(0, -1, 0);\n     \
 cameraNX.lookAt(1, 0, 0);\n      cameraPY.up.set(0, 0, 1);\n      \
cameraPY.lookAt(0, 1, 0);\n      cameraNY.up.set(0, 0, -1);\n      \
cameraNY.lookAt(0, -1, 0);\n      cameraPZ.up.set(0, -1, 0);\n      \
cameraPZ.lookAt(0, 0, 1);\n      cameraNZ.up.set(0, -1, 0);\n      \
cameraNZ.lookAt(0, 0, -1);\n    } else {\n      throw new \
Error(\"THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: \
\" + coordinateSystem);\n    }\n    for (const camera3 of cameras) {\n      \
this.add(camera3);\n      camera3.updateMatrixWorld();\n    }\n  }\n  \
update(renderer3, scene3) {\n    if (this.parent === null) \
this.updateMatrixWorld();\n    const { renderTarget, activeMipmapLevel } = \
this;\n    if (this.coordinateSystem !== renderer3.coordinateSystem) {\n      \
this.coordinateSystem = renderer3.coordinateSystem;\n      \
this.updateCoordinateSystem();\n    }\n    const [cameraPX, cameraNX, \
cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;\n    const \
currentRenderTarget = renderer3.getRenderTarget();\n    const \
currentActiveCubeFace = renderer3.getActiveCubeFace();\n    const \
currentActiveMipmapLevel = renderer3.getActiveMipmapLevel();\n    const \
currentXrEnabled = renderer3.xr.enabled;\n    renderer3.xr.enabled = false;\n \
   const generateMipmaps = renderTarget.texture.generateMipmaps;\n    \
renderTarget.texture.generateMipmaps = false;\n    \
renderer3.setRenderTarget(renderTarget, 0, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraPX);\n    \
renderer3.setRenderTarget(renderTarget, 1, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraNX);\n    \
renderer3.setRenderTarget(renderTarget, 2, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraPY);\n    \
renderer3.setRenderTarget(renderTarget, 3, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraNY);\n    \
renderer3.setRenderTarget(renderTarget, 4, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraPZ);\n    renderTarget.texture.generateMipmaps \
= generateMipmaps;\n    renderer3.setRenderTarget(renderTarget, 5, \
activeMipmapLevel);\n    renderer3.render(scene3, cameraNZ);\n    \
renderer3.setRenderTarget(currentRenderTarget, currentActiveCubeFace, \
currentActiveMipmapLevel);\n    renderer3.xr.enabled = currentXrEnabled;\n    \
renderTarget.texture.needsPMREMUpdate = true;\n  }\n};\nvar CubeTexture = \
class extends Texture {\n  constructor(images, mapping, wrapS, wrapT, \
magFilter, minFilter, format2, type, anisotropy2, colorSpace) {\n    images = \
images !== void 0 ? images : [];\n    mapping = mapping !== void 0 ? mapping \
: CubeReflectionMapping;\n    super(images, mapping, wrapS, wrapT, magFilter, \
minFilter, format2, type, anisotropy2, colorSpace);\n    this.isCubeTexture = \
true;\n    this.flipY = false;\n  }\n  get images() {\n    return \
this.image;\n  }\n  set images(value) {\n    this.image = value;\n  \
}\n};\nvar WebGLCubeRenderTarget = class extends WebGLRenderTarget {\n  \
constructor(size = 1, options = {}) {\n    super(size, size, options);\n    \
this.isWebGLCubeRenderTarget = true;\n    const image = { width: size, \
height: size, depth: 1 };\n    const images = [image, image, image, image, \
image, image];\n    this.texture = new CubeTexture(images, options.mapping, \
options.wrapS, options.wrapT, options.magFilter, options.minFilter, \
options.format, options.type, options.anisotropy, options.colorSpace);\n    \
this.texture.isRenderTargetTexture = true;\n    this.texture.generateMipmaps \
= options.generateMipmaps !== void 0 ? options.generateMipmaps : false;\n    \
this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : \
LinearFilter;\n  }\n  fromEquirectangularTexture(renderer3, texture2) {\n    \
this.texture.type = texture2.type;\n    this.texture.colorSpace = \
texture2.colorSpace;\n    this.texture.generateMipmaps = \
texture2.generateMipmaps;\n    this.texture.minFilter = texture2.minFilter;\n \
   this.texture.magFilter = texture2.magFilter;\n    const shader = {\n      \
uniforms: {\n        tEquirect: { value: null }\n      },\n      \
vertexShader: (\n        /* glsl */\n        `\n\n\t\t\t\tvarying vec3 \
vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 \
matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz \
);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = \
transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include \
<begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`\n   \
   ),\n      fragmentShader: (\n        /* glsl */\n        \
`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 \
vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() \
{\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection \
);\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction \
);\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV \
);\n\n\t\t\t\t}\n\t\t\t`\n      )\n    };\n    const geometry = new \
BoxGeometry(5, 5, 5);\n    const material = new ShaderMaterial({\n      name: \
\"CubemapFromEquirect\",\n      uniforms: cloneUniforms(shader.uniforms),\n   \
   vertexShader: shader.vertexShader,\n      fragmentShader: \
shader.fragmentShader,\n      side: BackSide,\n      blending: NoBlending\n   \
 });\n    material.uniforms.tEquirect.value = texture2;\n    const mesh = new \
Mesh(geometry, material);\n    const currentMinFilter = texture2.minFilter;\n \
   if (texture2.minFilter === LinearMipmapLinearFilter) texture2.minFilter = \
LinearFilter;\n    const camera3 = new CubeCamera(1, 10, this);\n    \
camera3.update(renderer3, mesh);\n    texture2.minFilter = \
currentMinFilter;\n    mesh.geometry.dispose();\n    \
mesh.material.dispose();\n    return this;\n  }\n  clear(renderer3, color2, \
depth2, stencil) {\n    const currentRenderTarget = \
renderer3.getRenderTarget();\n    for (let i = 0; i < 6; i++) {\n      \
renderer3.setRenderTarget(this, i);\n      renderer3.clear(color2, depth2, \
stencil);\n    }\n    renderer3.setRenderTarget(currentRenderTarget);\n  \
}\n};\nvar _vector1 = /* @__PURE__ */ new Vector3();\nvar _vector2 = /* \
@__PURE__ */ new Vector3();\nvar _normalMatrix = /* @__PURE__ */ new \
Matrix3();\nvar Plane = class {\n  constructor(normal2 = new Vector3(1, 0, \
0), constant = 0) {\n    this.isPlane = true;\n    this.normal = normal2;\n   \
 this.constant = constant;\n  }\n  set(normal2, constant) {\n    \
this.normal.copy(normal2);\n    this.constant = constant;\n    return this;\n \
 }\n  setComponents(x2, y2, z2, w) {\n    this.normal.set(x2, y2, z2);\n    \
this.constant = w;\n    return this;\n  }\n  \
setFromNormalAndCoplanarPoint(normal2, point) {\n    \
this.normal.copy(normal2);\n    this.constant = -point.dot(this.normal);\n    \
return this;\n  }\n  setFromCoplanarPoints(a2, b, c2) {\n    const normal2 = \
_vector1.subVectors(c2, b).cross(_vector2.subVectors(a2, b)).normalize();\n   \
 this.setFromNormalAndCoplanarPoint(normal2, a2);\n    return this;\n  }\n  \
copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = \
plane.constant;\n    return this;\n  }\n  normalize() {\n    const \
inverseNormalLength = 1 / this.normal.length();\n    \
this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= \
inverseNormalLength;\n    return this;\n  }\n  negate() {\n    this.constant \
*= -1;\n    this.normal.negate();\n    return this;\n  }\n  \
distanceToPoint(point) {\n    return this.normal.dot(point) + \
this.constant;\n  }\n  distanceToSphere(sphere) {\n    return \
this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n  \
projectPoint(point, target) {\n    return \
target.copy(point).addScaledVector(this.normal, \
-this.distanceToPoint(point));\n  }\n  intersectLine(line, target) {\n    \
const direction2 = line.delta(_vector1);\n    const denominator = \
this.normal.dot(direction2);\n    if (denominator === 0) {\n      if \
(this.distanceToPoint(line.start) === 0) {\n        return \
target.copy(line.start);\n      }\n      return null;\n    }\n    const t = \
-(line.start.dot(this.normal) + this.constant) / denominator;\n    if (t < 0 \
|| t > 1) {\n      return null;\n    }\n    return \
target.copy(line.start).addScaledVector(direction2, t);\n  }\n  \
intersectsLine(line) {\n    const startSign = \
this.distanceToPoint(line.start);\n    const endSign = \
this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || \
endSign < 0 && startSign > 0;\n  }\n  intersectsBox(box) {\n    return \
box.intersectsPlane(this);\n  }\n  intersectsSphere(sphere) {\n    return \
sphere.intersectsPlane(this);\n  }\n  coplanarPoint(target) {\n    return \
target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n  \
applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = \
optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n    const \
referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    \
const normal2 = this.normal.applyMatrix3(normalMatrix).normalize();\n    \
this.constant = -referencePoint.dot(normal2);\n    return this;\n  }\n  \
translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    \
return this;\n  }\n  equals(plane) {\n    return \
plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n  \
clone() {\n    return new this.constructor().copy(this);\n  }\n};\nvar \
_sphere$5 = /* @__PURE__ */ new Sphere();\nvar _vector$7 = /* @__PURE__ */ \
new Vector3();\nvar Frustum = class {\n  constructor(p0 = new Plane(), p1 = \
new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new \
Plane()) {\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n  set(p0, p1, \
p2, p3, p4, p5) {\n    const planes = this.planes;\n    planes[0].copy(p0);\n \
   planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    \
planes[4].copy(p4);\n    planes[5].copy(p5);\n    return this;\n  }\n  \
copy(frustum) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; \
i++) {\n      planes[i].copy(frustum.planes[i]);\n    }\n    return this;\n  \
}\n  setFromProjectionMatrix(m2, coordinateSystem = WebGLCoordinateSystem) \
{\n    const planes = this.planes;\n    const me = m2.elements;\n    const \
me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n    const me4 = me[4], \
me5 = me[5], me6 = me[6], me7 = me[7];\n    const me8 = me[8], me9 = me[9], \
me10 = me[10], me11 = me[11];\n    const me12 = me[12], me13 = me[13], me14 = \
me[14], me15 = me[15];\n    planes[0].setComponents(me3 - me0, me7 - me4, \
me11 - me8, me15 - me12).normalize();\n    planes[1].setComponents(me3 + me0, \
me7 + me4, me11 + me8, me15 + me12).normalize();\n    \
planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + \
me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - \
me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - me2, me7 - \
me6, me11 - me10, me15 - me14).normalize();\n    if (coordinateSystem === \
WebGLCoordinateSystem) {\n      planes[5].setComponents(me3 + me2, me7 + me6, \
me11 + me10, me15 + me14).normalize();\n    } else if (coordinateSystem === \
WebGPUCoordinateSystem) {\n      planes[5].setComponents(me2, me6, me10, \
me14).normalize();\n    } else {\n      throw new \
Error(\"THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: \
\" + coordinateSystem);\n    }\n    return this;\n  }\n  \
intersectsObject(object) {\n    if (object.boundingSphere !== void 0) {\n     \
 if (object.boundingSphere === null) object.computeBoundingSphere();\n      \
_sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);\n    \
} else {\n      const geometry = object.geometry;\n      if \
(geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      \
_sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n   \
 }\n    return this.intersectsSphere(_sphere$5);\n  }\n  \
intersectsSprite(sprite) {\n    _sphere$5.center.set(0, 0, 0);\n    \
_sphere$5.radius = 0.7071067811865476;\n    \
_sphere$5.applyMatrix4(sprite.matrixWorld);\n    return \
this.intersectsSphere(_sphere$5);\n  }\n  intersectsSphere(sphere) {\n    \
const planes = this.planes;\n    const center = sphere.center;\n    const \
negRadius = -sphere.radius;\n    for (let i = 0; i < 6; i++) {\n      const \
distance2 = planes[i].distanceToPoint(center);\n      if (distance2 < \
negRadius) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \
intersectsBox(box) {\n    const planes = this.planes;\n    for (let i = 0; i \
< 6; i++) {\n      const plane = planes[i];\n      _vector$7.x = \
plane.normal.x > 0 ? box.max.x : box.min.x;\n      _vector$7.y = \
plane.normal.y > 0 ? box.max.y : box.min.y;\n      _vector$7.z = \
plane.normal.z > 0 ? box.max.z : box.min.z;\n      if \
(plane.distanceToPoint(_vector$7) < 0) {\n        return false;\n      }\n    \
}\n    return true;\n  }\n  containsPoint(point) {\n    const planes = \
this.planes;\n    for (let i = 0; i < 6; i++) {\n      if \
(planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    \
}\n    return true;\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n};\nfunction WebGLAnimation() {\n  let \
context2 = null;\n  let isAnimating = false;\n  let animationLoop = null;\n  \
let requestId = null;\n  function onAnimationFrame(time, frame2) {\n    \
animationLoop(time, frame2);\n    requestId = \
context2.requestAnimationFrame(onAnimationFrame);\n  }\n  return {\n    \
start: function() {\n      if (isAnimating === true) return;\n      if \
(animationLoop === null) return;\n      requestId = \
context2.requestAnimationFrame(onAnimationFrame);\n      isAnimating = \
true;\n    },\n    stop: function() {\n      \
context2.cancelAnimationFrame(requestId);\n      isAnimating = false;\n    \
},\n    setAnimationLoop: function(callback) {\n      animationLoop = \
callback;\n    },\n    setContext: function(value) {\n      context2 = \
value;\n    }\n  };\n}\nfunction WebGLAttributes(gl) {\n  const buffers = /* \
@__PURE__ */ new WeakMap();\n  function createBuffer(attribute2, bufferType) \
{\n    const array = attribute2.array;\n    const usage = attribute2.usage;\n \
   const size = array.byteLength;\n    const buffer2 = gl.createBuffer();\n   \
 gl.bindBuffer(bufferType, buffer2);\n    gl.bufferData(bufferType, array, \
usage);\n    attribute2.onUploadCallback();\n    let type;\n    if (array \
instanceof Float32Array) {\n      type = gl.FLOAT;\n    } else if (array \
instanceof Uint16Array) {\n      if (attribute2.isFloat16BufferAttribute) {\n \
       type = gl.HALF_FLOAT;\n      } else {\n        type = \
gl.UNSIGNED_SHORT;\n      }\n    } else if (array instanceof Int16Array) {\n  \
    type = gl.SHORT;\n    } else if (array instanceof Uint32Array) {\n      \
type = gl.UNSIGNED_INT;\n    } else if (array instanceof Int32Array) {\n      \
type = gl.INT;\n    } else if (array instanceof Int8Array) {\n      type = \
gl.BYTE;\n    } else if (array instanceof Uint8Array) {\n      type = \
gl.UNSIGNED_BYTE;\n    } else if (array instanceof Uint8ClampedArray) {\n     \
 type = gl.UNSIGNED_BYTE;\n    } else {\n      throw new \
Error(\"THREE.WebGLAttributes: Unsupported buffer data format: \" + array);\n \
   }\n    return {\n      buffer: buffer2,\n      type,\n      \
bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: \
attribute2.version,\n      size\n    };\n  }\n  function \
updateBuffer(buffer2, attribute2, bufferType) {\n    const array = \
attribute2.array;\n    const updateRanges = attribute2.updateRanges;\n    \
gl.bindBuffer(bufferType, buffer2);\n    if (updateRanges.length === 0) {\n   \
   gl.bufferSubData(bufferType, 0, array);\n    } else {\n      \
updateRanges.sort((a2, b) => a2.start - b.start);\n      let mergeIndex = \
0;\n      for (let i = 1; i < updateRanges.length; i++) {\n        const \
previousRange = updateRanges[mergeIndex];\n        const range = \
updateRanges[i];\n        if (range.start <= previousRange.start + \
previousRange.count + 1) {\n          previousRange.count = Math.max(\n       \
     previousRange.count,\n            range.start + range.count - \
previousRange.start\n          );\n        } else {\n          \
++mergeIndex;\n          updateRanges[mergeIndex] = range;\n        }\n      \
}\n      updateRanges.length = mergeIndex + 1;\n      for (let i = 0, l = \
updateRanges.length; i < l; i++) {\n        const range = updateRanges[i];\n  \
      gl.bufferSubData(\n          bufferType,\n          range.start * \
array.BYTES_PER_ELEMENT,\n          array,\n          range.start,\n          \
range.count\n        );\n      }\n      attribute2.clearUpdateRanges();\n    \
}\n    attribute2.onUploadCallback();\n  }\n  function get2(attribute2) {\n   \
 if (attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;\n \
   return buffers.get(attribute2);\n  }\n  function remove2(attribute2) {\n   \
 if (attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;\n \
   const data = buffers.get(attribute2);\n    if (data) {\n      \
gl.deleteBuffer(data.buffer);\n      buffers.delete(attribute2);\n    }\n  \
}\n  function update4(attribute2, bufferType) {\n    if \
(attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;\n    \
if (attribute2.isGLBufferAttribute) {\n      const cached = \
buffers.get(attribute2);\n      if (!cached || cached.version < \
attribute2.version) {\n        buffers.set(attribute2, {\n          buffer: \
attribute2.buffer,\n          type: attribute2.type,\n          \
bytesPerElement: attribute2.elementSize,\n          version: \
attribute2.version\n        });\n      }\n      return;\n    }\n    const \
data = buffers.get(attribute2);\n    if (data === void 0) {\n      \
buffers.set(attribute2, createBuffer(attribute2, bufferType));\n    } else if \
(data.version < attribute2.version) {\n      if (data.size !== \
attribute2.array.byteLength) {\n        throw new \
Error(\"THREE.WebGLAttributes: The size of the buffer attribute's array \
buffer does not match the original size. Resizing buffer attributes is not \
supported.\");\n      }\n      updateBuffer(data.buffer, attribute2, \
bufferType);\n      data.version = attribute2.version;\n    }\n  }\n  return \
{\n    get: get2,\n    remove: remove2,\n    update: update4\n  };\n}\nvar \
PlaneGeometry = class _PlaneGeometry extends BufferGeometry {\n  \
constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n \
   super();\n    this.type = \"PlaneGeometry\";\n    this.parameters = {\n    \
  width,\n      height,\n      widthSegments,\n      heightSegments\n    };\n \
   const width_half = width / 2;\n    const height_half = height / 2;\n    \
const gridX = Math.floor(widthSegments);\n    const gridY = \
Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 \
= gridY + 1;\n    const segment_width = width / gridX;\n    const \
segment_height = height / gridY;\n    const indices = [];\n    const vertices \
= [];\n    const normals = [];\n    const uvs = [];\n    for (let iy = 0; iy \
< gridY1; iy++) {\n      const y2 = iy * segment_height - height_half;\n      \
for (let ix = 0; ix < gridX1; ix++) {\n        const x2 = ix * segment_width \
- width_half;\n        vertices.push(x2, -y2, 0);\n        normals.push(0, 0, \
1);\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n      \
}\n    }\n    for (let iy = 0; iy < gridY; iy++) {\n      for (let ix = 0; ix \
< gridX; ix++) {\n        const a2 = ix + gridX1 * iy;\n        const b = ix \
+ gridX1 * (iy + 1);\n        const c2 = ix + 1 + gridX1 * (iy + 1);\n        \
const d = ix + 1 + gridX1 * iy;\n        indices.push(a2, b, d);\n        \
indices.push(b, c2, d);\n      }\n    }\n    this.setIndex(indices);\n    \
this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n   \
 this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    \
this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.parameters = \
Object.assign({}, source.parameters);\n    return this;\n  }\n  static \
fromJSON(data) {\n    return new _PlaneGeometry(data.width, data.height, \
data.widthSegments, data.heightSegments);\n  }\n};\nvar alphahash_fragment = \
\"#ifdef USE_ALPHAHASH\\n\tif ( diffuseColor.a < getAlphaHashThreshold( \
vPosition ) ) discard;\\n#endif\";\nvar alphahash_pars_fragment = \"#ifdef \
USE_ALPHAHASH\\n\tconst float ALPHA_HASH_SCALE = 0.05;\\n\tfloat hash2D( vec2 \
value ) {\\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * \
( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\\n\t}\\n\tfloat hash3D( \
vec3 value ) {\\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) \
);\\n\t}\\n\tfloat getAlphaHashThreshold( vec3 position ) {\\n\t\tfloat \
maxDeriv = max(\\n\t\t\tlength( dFdx( position.xyz ) ),\\n\t\t\tlength( dFdy( \
position.xyz ) )\\n\t\t);\\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * \
maxDeriv );\\n\t\tvec2 pixScales = vec2(\\n\t\t\texp2( floor( log2( pixScale \
) ) ),\\n\t\t\texp2( ceil( log2( pixScale ) ) )\\n\t\t);\\n\t\tvec2 alpha = \
vec2(\\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\\n\t\t\thash3D( \
floor( pixScales.y * position.xyz ) )\\n\t\t);\\n\t\tfloat lerpFactor = \
fract( log2( pixScale ) );\\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + \
lerpFactor * alpha.y;\\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor \
);\\n\t\tvec3 cases = vec3(\\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) \
),\\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 \
- x ) / ( 2.0 * a * ( 1.0 - a ) ) )\\n\t\t);\\n\t\tfloat threshold = ( x < ( \
1.0 - a ) )\\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\\n\t\t\t: \
cases.z;\\n\t\treturn clamp( threshold , 1.0e-6, 1.0 \
);\\n\t}\\n#endif\";\nvar alphamap_fragment = \"#ifdef \
USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv \
).g;\\n#endif\";\nvar alphamap_pars_fragment = \"#ifdef \
USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\";\nvar \
alphatest_fragment = \"#ifdef USE_ALPHATEST\\n\t#ifdef \
ALPHA_TO_COVERAGE\\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + \
fwidth( diffuseColor.a ), diffuseColor.a );\\n\tif ( diffuseColor.a == 0.0 ) \
discard;\\n\t#else\\n\tif ( diffuseColor.a < alphaTest ) \
discard;\\n\t#endif\\n#endif\";\nvar alphatest_pars_fragment = \"#ifdef \
USE_ALPHATEST\\n\tuniform float alphaTest;\\n#endif\";\nvar aomap_fragment = \
\"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv \
).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= \
ambientOcclusion;\\n\t#if defined( USE_CLEARCOAT ) \
\\n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\\n\t#endif\\n\t#if \
defined( USE_SHEEN ) \\n\t\tsheenSpecularIndirect *= \
ambientOcclusion;\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( \
STANDARD )\\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir \
) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( \
dotNV, ambientOcclusion, material.roughness );\\n\t#endif\\n#endif\";\nvar \
aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\tuniform sampler2D \
aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\nvar \
batching_pars_vertex = \"#ifdef USE_BATCHING\\n\t#if ! defined( \
GL_ANGLE_multi_draw )\\n\t#define gl_DrawID _gl_DrawID\\n\tuniform int \
_gl_DrawID;\\n\t#endif\\n\tuniform highp sampler2D \
batchingTexture;\\n\tuniform highp usampler2D batchingIdTexture;\\n\tmat4 \
getBatchingMatrix( const in float i ) {\\n\t\tint size = textureSize( \
batchingTexture, 0 ).x;\\n\t\tint j = int( i ) * 4;\\n\t\tint x = j % \
size;\\n\t\tint y = j / size;\\n\t\tvec4 v1 = texelFetch( batchingTexture, \
ivec2( x, y ), 0 );\\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + \
1, y ), 0 );\\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), \
0 );\\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 \
);\\n\t\treturn mat4( v1, v2, v3, v4 );\\n\t}\\n\tfloat getIndirectIndex( \
const in int i ) {\\n\t\tint size = textureSize( batchingIdTexture, 0 \
).x;\\n\t\tint x = i % size;\\n\t\tint y = i / size;\\n\t\treturn float( \
texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r \
);\\n\t}\\n#endif\\n#ifdef USE_BATCHING_COLOR\\n\tuniform sampler2D \
batchingColorTexture;\\n\tvec3 getBatchingColor( const in float i ) \
{\\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\\n\t\tint j = \
int( i );\\n\t\tint x = j % size;\\n\t\tint y = j / size;\\n\t\treturn \
texelFetch( batchingColorTexture, ivec2( x, y ), 0 \
).rgb;\\n\t}\\n#endif\";\nvar batching_vertex = \"#ifdef \
USE_BATCHING\\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( \
gl_DrawID ) );\\n#endif\";\nvar begin_vertex = \"vec3 transformed = vec3( \
position );\\n#ifdef USE_ALPHAHASH\\n\tvPosition = vec3( position \
);\\n#endif\";\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal \
);\\n#ifdef USE_TANGENT\\n\tvec3 objectTangent = vec3( tangent.xyz \
);\\n#endif\";\nvar bsdfs = \"float G_BlinnPhong_Implicit( ) {\\n\treturn \
0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float \
dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, \
shininess );\\n}\\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in \
vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in \
float shininess ) {\\n\tvec3 halfDir = normalize( lightDir + viewDir \
);\\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\tfloat dotVH = \
saturate( dot( viewDir, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, \
1.0, dotVH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = \
D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n} // \
validated\";\nvar iridescence_fragment = \"#ifdef USE_IRIDESCENCE\\n\tconst \
mat3 XYZ_TO_REC709 = mat3(\\n\t\t 3.2404542, -0.9692660,  \
0.0556434,\\n\t\t-1.5371385,  1.8760108, -0.2040259,\\n\t\t-0.4985314,  \
0.0415560,  1.0572252\\n\t);\\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) \
{\\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) \
/ ( vec3( 1.0 ) - sqrtF0 );\\n\t}\\n\tvec3 IorToFresnel0( vec3 \
transmittedIor, float incidentIor ) {\\n\t\treturn pow2( ( transmittedIor - \
vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) \
);\\n\t}\\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) \
{\\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + \
incidentIor ));\\n\t}\\n\tvec3 evalSensitivity( float OPD, vec3 shift ) \
{\\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\\n\t\tvec3 val = vec3( \
5.4856e-13, 4.4201e-13, 5.2481e-13 );\\n\t\tvec3 pos = vec3( 1.6810e+06, \
1.7953e+06, 2.2084e+06 );\\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, \
6.6121e+09 );\\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * \
phase + shift ) * exp( - pow2( phase ) * var );\\n\t\txyz.x += 9.7470e-14 * \
sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( \
- 4.5282e+09 * pow2( phase ) );\\n\t\txyz /= 1.0685e-7;\\n\t\tvec3 rgb = \
XYZ_TO_REC709 * xyz;\\n\t\treturn rgb;\\n\t}\\n\tvec3 evalIridescence( float \
outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 \
) {\\n\t\tvec3 I;\\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, \
smoothstep( 0.0, 0.03, thinFilmThickness ) );\\n\t\tfloat sinTheta2Sq = pow2( \
outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\\n\t\tfloat \
cosTheta2Sq = 1.0 - sinTheta2Sq;\\n\t\tif ( cosTheta2Sq < 0.0 ) \
{\\n\t\t\treturn vec3( 1.0 );\\n\t\t}\\n\t\tfloat cosTheta2 = sqrt( \
cosTheta2Sq );\\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR \
);\\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\\n\t\tfloat T121 = 1.0 \
- R12;\\n\t\tfloat phi12 = 0.0;\\n\t\tif ( iridescenceIOR < outsideIOR ) \
phi12 = PI;\\n\t\tfloat phi21 = PI - phi12;\\n\t\tvec3 baseIOR = \
Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( \
baseIOR, iridescenceIOR );\\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 \
);\\n\t\tvec3 phi23 = vec3( 0.0 );\\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) \
phi23[ 0 ] = PI;\\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = \
PI;\\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\\n\t\tfloat \
OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\\n\t\tvec3 phi = \
vec3( phi21 ) + phi23;\\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 \
);\\n\t\tvec3 r123 = sqrt( R123 );\\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( \
vec3( 1.0 ) - R123 );\\n\t\tvec3 C0 = R12 + Rs;\\n\t\tI = C0;\\n\t\tvec3 Cm = \
Rs - T121;\\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\\n\t\t\tCm *= \
r123;\\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * \
phi );\\n\t\t\tI += Cm * Sm;\\n\t\t}\\n\t\treturn max( I, vec3( 0.0 ) \
);\\n\t}\\n#endif\";\nvar bumpmap_pars_fragment = \"#ifdef \
USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float \
bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vBumpMapUv \
);\\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\\n\t\tfloat Hll = bumpScale * \
texture2D( bumpMap, vBumpMapUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( \
bumpMap, vBumpMapUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * \
texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy \
);\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 \
dHdxy, float faceDirection ) {\\n\t\tvec3 vSigmaX = normalize( dFdx( \
surf_pos.xyz ) );\\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) \
);\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN \
);\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 \
) * faceDirection;\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y \
* R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad \
);\\n\t}\\n#endif\";\nvar clipping_planes_fragment = \"#if \
NUM_CLIPPING_PLANES > 0\\n\tvec4 plane;\\n\t#ifdef \
ALPHA_TO_COVERAGE\\n\t\tfloat distanceToPlane, distanceGradient;\\n\t\tfloat \
clipOpacity = 1.0;\\n\t\t#pragma unroll_loop_start\\n\t\tfor ( int i = 0; i < \
UNION_CLIPPING_PLANES; i ++ ) {\\n\t\t\tplane = clippingPlanes[ i \
];\\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + \
plane.w;\\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / \
2.0;\\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, \
distanceToPlane );\\n\t\t\tif ( clipOpacity == 0.0 ) \
discard;\\n\t\t}\\n\t\t#pragma unroll_loop_end\\n\t\t#if \
UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\t\t\tfloat unionClipOpacity = \
1.0;\\n\t\t\t#pragma unroll_loop_start\\n\t\t\tfor ( int i = \
UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\t\t\t\tplane = \
clippingPlanes[ i ];\\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, \
plane.xyz ) + plane.w;\\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) \
/ 2.0;\\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, \
distanceGradient, distanceToPlane );\\n\t\t\t}\\n\t\t\t#pragma \
unroll_loop_end\\n\t\t\tclipOpacity *= 1.0 - \
unionClipOpacity;\\n\t\t#endif\\n\t\tdiffuseColor.a *= clipOpacity;\\n\t\tif \
( diffuseColor.a == 0.0 ) discard;\\n\t#else\\n\t\t#pragma \
unroll_loop_start\\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) \
{\\n\t\t\tplane = clippingPlanes[ i ];\\n\t\t\tif ( dot( vClipPosition, \
plane.xyz ) > plane.w ) discard;\\n\t\t}\\n\t\t#pragma \
unroll_loop_end\\n\t\t#if UNION_CLIPPING_PLANES < \
NUM_CLIPPING_PLANES\\n\t\t\tbool clipped = true;\\n\t\t\t#pragma \
unroll_loop_start\\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < \
NUM_CLIPPING_PLANES; i ++ ) {\\n\t\t\t\tplane = clippingPlanes[ i \
];\\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && \
clipped;\\n\t\t\t}\\n\t\t\t#pragma unroll_loop_end\\n\t\t\tif ( clipped ) \
discard;\\n\t\t#endif\\n\t#endif\\n#endif\";\nvar \
clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\tvarying \
vec3 vClipPosition;\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES \
];\\n#endif\";\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > \
0\\n\tvarying vec3 vClipPosition;\\n#endif\";\nvar clipping_planes_vertex = \
\"#if NUM_CLIPPING_PLANES > 0\\n\tvClipPosition = - \
mvPosition.xyz;\\n#endif\";\nvar color_fragment = \"#if defined( \
USE_COLOR_ALPHA )\\n\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR \
)\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\nvar color_pars_fragment = \
\"#if defined( USE_COLOR_ALPHA )\\n\tvarying vec4 vColor;\\n#elif defined( \
USE_COLOR )\\n\tvarying vec3 vColor;\\n#endif\";\nvar color_pars_vertex = \
\"#if defined( USE_COLOR_ALPHA )\\n\tvarying vec4 vColor;\\n#elif defined( \
USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR \
)\\n\tvarying vec3 vColor;\\n#endif\";\nvar color_vertex = \"#if defined( \
USE_COLOR_ALPHA )\\n\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || \
defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\\n\tvColor = \
vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\tvColor *= \
color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\tvColor.xyz *= \
instanceColor.xyz;\\n#endif\\n#ifdef USE_BATCHING_COLOR\\n\tvec3 \
batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) \
);\\n\tvColor.xyz *= batchingColor.xyz;\\n#endif\";\nvar common = \"#define \
PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF \
1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define \
RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef \
saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\n#define \
whiteComplement( a ) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) \
{ return x*x; }\\nvec3 pow2( const in vec3 x ) { return x*x; }\\nfloat pow3( \
const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float \
x2 = x*x; return x2*x2; }\\nfloat max3( const in vec3 v ) { return max( max( \
v.x, v.y ), v.z ); }\\nfloat average( const in vec3 v ) { return dot( v, \
vec3( 0.3333333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst \
highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = \
dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract( sin( sn ) * \
c );\\n}\\n#ifdef HIGH_PRECISION\\n\tfloat precisionSafeLength( vec3 v ) { \
return length( v ); }\\n#else\\n\tfloat precisionSafeLength( vec3 v ) \
{\\n\t\tfloat maxComponent = max3( abs( v ) );\\n\t\treturn length( v / \
maxComponent ) * maxComponent;\\n\t}\\n#endif\\nstruct IncidentLight \
{\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct \
ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 \
indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\n#ifdef \
USE_ALPHAHASH\\n\tvarying vec3 vPosition;\\n#endif\\nvec3 transformDirection( \
in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, \
0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 \
matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz \
);\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\tmat3 tmp;\\n\ttmp[ 0 ] = \
vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 \
].y, m[ 2 ].y );\\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z \
);\\n\treturn tmp;\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\treturn m[ 2 \
][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\tfloat u = atan( \
dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\tfloat v = asin( clamp( dir.y, - \
1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\treturn vec2( u, v );\\n}\\nvec3 \
BRDF_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * \
diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in float f90, \
const in float dotVH ) {\\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - \
6.98316 ) * dotVH );\\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel \
);\\n}\\nfloat F_Schlick( const in float f0, const in float f90, const in \
float dotVH ) {\\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * \
dotVH );\\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n} // \
validated\";\nvar cube_uv_reflection_fragment = \"#ifdef \
ENVMAP_TYPE_CUBE_UV\\n\t#define cubeUV_minMipLevel 4.0\\n\t#define \
cubeUV_minTileSize 16.0\\n\tfloat getFace( vec3 direction ) {\\n\t\tvec3 \
absDirection = abs( direction );\\n\t\tfloat face = - 1.0;\\n\t\tif ( \
absDirection.x > absDirection.z ) {\\n\t\t\tif ( absDirection.x > \
absDirection.y )\\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : \
3.0;\\n\t\t\telse\\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\t\t} \
else {\\n\t\t\tif ( absDirection.z > absDirection.y )\\n\t\t\t\tface = \
direction.z > 0.0 ? 2.0 : 5.0;\\n\t\t\telse\\n\t\t\t\tface = direction.y > \
0.0 ? 1.0 : 4.0;\\n\t\t}\\n\t\treturn face;\\n\t}\\n\tvec2 getUV( vec3 \
direction, float face ) {\\n\t\tvec2 uv;\\n\t\tif ( face == 0.0 ) \
{\\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\t\t} \
else if ( face == 1.0 ) {\\n\t\t\tuv = vec2( - direction.x, - direction.z ) / \
abs( direction.y );\\n\t\t} else if ( face == 2.0 ) {\\n\t\t\tuv = vec2( - \
direction.x, direction.y ) / abs( direction.z );\\n\t\t} else if ( face == \
3.0 ) {\\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x \
);\\n\t\t} else if ( face == 4.0 ) {\\n\t\t\tuv = vec2( - direction.x, \
direction.z ) / abs( direction.y );\\n\t\t} else {\\n\t\t\tuv = vec2( \
direction.x, direction.y ) / abs( direction.z );\\n\t\t}\\n\t\treturn 0.5 * ( \
uv + 1.0 );\\n\t}\\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, \
float mipInt ) {\\n\t\tfloat face = getFace( direction );\\n\t\tfloat \
filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\t\tmipInt = max( \
mipInt, cubeUV_minMipLevel );\\n\t\tfloat faceSize = exp2( mipInt \
);\\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + \
1.0;\\n\t\tif ( face > 2.0 ) {\\n\t\t\tuv.y += faceSize;\\n\t\t\tface -= \
3.0;\\n\t\t}\\n\t\tuv.x += face * faceSize;\\n\t\tuv.x += filterInt * 3.0 * \
cubeUV_minTileSize;\\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize \
);\\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\\n\t\tuv.y *= \
CUBEUV_TEXEL_HEIGHT;\\n\t\t#ifdef texture2DGradEXT\\n\t\t\treturn \
texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) \
).rgb;\\n\t\t#else\\n\t\t\treturn texture2D( envMap, uv \
).rgb;\\n\t\t#endif\\n\t}\\n\t#define cubeUV_r0 1.0\\n\t#define cubeUV_m0 - \
2.0\\n\t#define cubeUV_r1 0.8\\n\t#define cubeUV_m1 - 1.0\\n\t#define \
cubeUV_r4 0.4\\n\t#define cubeUV_m4 2.0\\n\t#define cubeUV_r5 \
0.305\\n\t#define cubeUV_m5 3.0\\n\t#define cubeUV_r6 0.21\\n\t#define \
cubeUV_m6 4.0\\n\tfloat roughnessToMip( float roughness ) {\\n\t\tfloat mip = \
0.0;\\n\t\tif ( roughness >= cubeUV_r1 ) {\\n\t\t\tmip = ( cubeUV_r0 - \
roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + \
cubeUV_m0;\\n\t\t} else if ( roughness >= cubeUV_r4 ) {\\n\t\t\tmip = ( \
cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 \
) + cubeUV_m1;\\n\t\t} else if ( roughness >= cubeUV_r5 ) {\\n\t\t\tmip = ( \
cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 \
) + cubeUV_m4;\\n\t\t} else if ( roughness >= cubeUV_r6 ) {\\n\t\t\tmip = ( \
cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 \
) + cubeUV_m5;\\n\t\t} else {\\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness \
);\t\t}\\n\t\treturn mip;\\n\t}\\n\tvec4 textureCubeUV( sampler2D envMap, \
vec3 sampleDir, float roughness ) {\\n\t\tfloat mip = clamp( roughnessToMip( \
roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\\n\t\tfloat mipF = fract( mip \
);\\n\t\tfloat mipInt = floor( mip );\\n\t\tvec3 color0 = bilinearCubeUV( \
envMap, sampleDir, mipInt );\\n\t\tif ( mipF == 0.0 ) {\\n\t\t\treturn vec4( \
color0, 1.0 );\\n\t\t} else {\\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, \
sampleDir, mipInt + 1.0 );\\n\t\t\treturn vec4( mix( color0, color1, mipF ), \
1.0 );\\n\t\t}\\n\t}\\n#endif\";\nvar defaultnormal_vertex = \"vec3 \
transformedNormal = objectNormal;\\n#ifdef USE_TANGENT\\n\tvec3 \
transformedTangent = objectTangent;\\n#endif\\n#ifdef USE_BATCHING\\n\tmat3 \
bm = mat3( batchingMatrix );\\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ \
0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) \
);\\n\ttransformedNormal = bm * transformedNormal;\\n\t#ifdef \
USE_TANGENT\\n\t\ttransformedTangent = bm * \
transformedTangent;\\n\t#endif\\n#endif\\n#ifdef USE_INSTANCING\\n\tmat3 im = \
mat3( instanceMatrix );\\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] \
), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\\n\ttransformedNormal \
= im * transformedNormal;\\n\t#ifdef USE_TANGENT\\n\t\ttransformedTangent = \
im * transformedTangent;\\n\t#endif\\n#endif\\ntransformedNormal = \
normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\ttransformedNormal = \
- transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\ttransformedTangent = ( \
modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\\n\t#ifdef \
FLIP_SIDED\\n\t\ttransformedTangent = - \
transformedTangent;\\n\t#endif\\n#endif\";\nvar displacementmap_pars_vertex = \
\"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D \
displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float \
displacementBias;\\n#endif\";\nvar displacementmap_vertex = \"#ifdef \
USE_DISPLACEMENTMAP\\n\ttransformed += normalize( objectNormal ) * ( \
texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + \
displacementBias );\\n#endif\";\nvar emissivemap_fragment = \"#ifdef \
USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, \
vEmissiveMapUv );\\n\t#ifdef \
DECODE_VIDEO_TEXTURE_EMISSIVE\\n\t\temissiveColor = sRGBTransferEOTF( \
emissiveColor );\\n\t#endif\\n\ttotalEmissiveRadiance *= \
emissiveColor.rgb;\\n#endif\";\nvar emissivemap_pars_fragment = \"#ifdef \
USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\";\nvar \
colorspace_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor \
);\";\nvar colorspace_pars_fragment = \"vec4 LinearTransferOETF( in vec4 \
value ) {\\n\treturn value;\\n}\\nvec4 sRGBTransferEOTF( in vec4 value ) \
{\\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), \
vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, \
vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 sRGBTransferOETF( in vec4 value \
) {\\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( \
0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) \
) ) ), value.a );\\n}\";\nvar envmap_fragment = \"#ifdef \
USE_ENVMAP\\n\t#ifdef ENV_WORLDPOS\\n\t\tvec3 cameraToFrag;\\n\t\tif ( \
isOrthographic ) {\\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ \
2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\t\t} else \
{\\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition \
);\\n\t\t}\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, \
viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = \
reflect( cameraToFrag, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = \
refract( cameraToFrag, worldNormal, refractionRatio \
);\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = \
vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = \
textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, \
reflectVec.yz ) );\\n\t#else\\n\t\tvec4 envColor = vec4( 0.0 \
);\\n\t#endif\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( \
outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity \
);\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( \
outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif \
defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * \
specularStrength * reflectivity;\\n\t#endif\\n#endif\";\nvar \
envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\tuniform float \
envMapIntensity;\\n\tuniform float flipEnvMap;\\n\tuniform mat3 \
envMapRotation;\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube \
envMap;\\n\t#else\\n\t\tuniform sampler2D \
envMap;\\n\t#endif\\n\t\\n#endif\";\nvar envmap_pars_fragment = \"#ifdef \
USE_ENVMAP\\n\tuniform float reflectivity;\\n\t#if defined( USE_BUMPMAP ) || \
defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT \
)\\n\t\t#define ENV_WORLDPOS\\n\t#endif\\n\t#ifdef ENV_WORLDPOS\\n\t\tvarying \
vec3 vWorldPosition;\\n\t\tuniform float \
refractionRatio;\\n\t#else\\n\t\tvarying vec3 \
vReflect;\\n\t#endif\\n#endif\";\nvar envmap_pars_vertex = \"#ifdef \
USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || \
defined( PHONG ) || defined( LAMBERT )\\n\t\t#define \
ENV_WORLDPOS\\n\t#endif\\n\t#ifdef ENV_WORLDPOS\\n\t\t\\n\t\tvarying vec3 \
vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float \
refractionRatio;\\n\t#endif\\n#endif\";\nvar envmap_vertex = \"#ifdef \
USE_ENVMAP\\n\t#ifdef ENV_WORLDPOS\\n\t\tvWorldPosition = \
worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex;\\n\t\tif ( \
isOrthographic ) {\\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 \
][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\t\t} else \
{\\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition \
);\\n\t\t}\\n\t\tvec3 worldNormal = inverseTransformDirection( \
transformedNormal, viewMatrix );\\n\t\t#ifdef \
ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, \
worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, \
worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\";\nvar \
fog_vertex = \"#ifdef USE_FOG\\n\tvFogDepth = - \
mvPosition.z;\\n#endif\";\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\tvarying \
float vFogDepth;\\n#endif\";\nvar fog_fragment = \"#ifdef USE_FOG\\n\t#ifdef \
FOG_EXP2\\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * \
vFogDepth * vFogDepth );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( \
fogNear, fogFar, vFogDepth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( \
gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\nvar fog_pars_fragment = \
\"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\tvarying float \
vFogDepth;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float \
fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float \
fogFar;\\n\t#endif\\n#endif\";\nvar gradientmap_pars_fragment = \"#ifdef \
USE_GRADIENTMAP\\n\tuniform sampler2D gradientMap;\\n#endif\\nvec3 \
getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\tfloat dotNL = \
dot( normal, lightDirection );\\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 \
);\\n\t#ifdef USE_GRADIENTMAP\\n\t\treturn vec3( texture2D( gradientMap, \
coord ).r );\\n\t#else\\n\t\tvec2 fw = fwidth( coord ) * 0.5;\\n\t\treturn \
mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) \
);\\n\t#endif\\n}\";\nvar lightmap_pars_fragment = \"#ifdef \
USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float \
lightMapIntensity;\\n#endif\";\nvar lights_lambert_fragment = \
\"LambertMaterial material;\\nmaterial.diffuseColor = \
diffuseColor.rgb;\\nmaterial.specularStrength = specularStrength;\";\nvar \
lights_lambert_pars_fragment = \"varying vec3 vViewPosition;\\nstruct \
LambertMaterial {\\n\tvec3 diffuseColor;\\n\tfloat \
specularStrength;\\n};\\nvoid RE_Direct_Lambert( const in IncidentLight \
directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, \
const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const \
in LambertMaterial material, inout ReflectedLight reflectedLight ) \
{\\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) \
);\\n\tvec3 irradiance = dotNL * \
directLight.color;\\n\treflectedLight.directDiffuse += irradiance * \
BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Lambert( \
const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 \
geometryNormal, const in vec3 geometryViewDir, const in vec3 \
geometryClearcoatNormal, const in LambertMaterial material, inout \
ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += \
irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define \
RE_Direct\t\t\t\tRE_Direct_Lambert\\n#define \
RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\";\nvar lights_pars_begin = \
\"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\n#if \
defined( USE_LIGHT_PROBES )\\n\tuniform vec3 lightProbe[ 9 ];\\n#endif\\nvec3 \
shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\tfloat \
x = normal.x, y = normal.y, z = normal.z;\\n\tvec3 result = shCoefficients[ 0 \
] * 0.886227;\\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * \
y;\\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\tresult += \
shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\tresult += shCoefficients[ 4 ] * \
2.0 * 0.429043 * x * y;\\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * \
y * z;\\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 \
);\\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\tresult += \
shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\treturn \
result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], \
const in vec3 normal ) {\\n\tvec3 worldNormal = inverseTransformDirection( \
normal, viewMatrix );\\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, \
lightProbe );\\n\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( \
const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = \
ambientLightColor;\\n\treturn irradiance;\\n}\\nfloat getDistanceAttenuation( \
const in float lightDistance, const in float cutoffDistance, const in float \
decayExponent ) {\\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, \
decayExponent ), 0.01 );\\n\tif ( cutoffDistance > 0.0 ) \
{\\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / \
cutoffDistance ) ) );\\n\t}\\n\treturn distanceFalloff;\\n}\\nfloat \
getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, \
const in float angleCosine ) {\\n\treturn smoothstep( coneCosine, \
penumbraCosine, angleCosine );\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct \
DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t};\\n\tuniform \
DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid \
getDirectionalLightInfo( const in DirectionalLight directionalLight, out \
IncidentLight light ) {\\n\t\tlight.color = \
directionalLight.color;\\n\t\tlight.direction = \
directionalLight.direction;\\n\t\tlight.visible = true;\\n\t}\\n#endif\\n#if \
NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 \
color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t};\\n\tuniform PointLight \
pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointLightInfo( const in \
PointLight pointLight, const in vec3 geometryPosition, out IncidentLight \
light ) {\\n\t\tvec3 lVector = pointLight.position - \
geometryPosition;\\n\t\tlight.direction = normalize( lVector );\\n\t\tfloat \
lightDistance = length( lVector );\\n\t\tlight.color = \
pointLight.color;\\n\t\tlight.color *= getDistanceAttenuation( lightDistance, \
pointLight.distance, pointLight.decay );\\n\t\tlight.visible = ( light.color \
!= vec3( 0.0 ) );\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct \
SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 \
color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat \
coneCos;\\n\t\tfloat penumbraCos;\\n\t};\\n\tuniform SpotLight spotLights[ \
NUM_SPOT_LIGHTS ];\\n\tvoid getSpotLightInfo( const in SpotLight spotLight, \
const in vec3 geometryPosition, out IncidentLight light ) {\\n\t\tvec3 \
lVector = spotLight.position - geometryPosition;\\n\t\tlight.direction = \
normalize( lVector );\\n\t\tfloat angleCos = dot( light.direction, \
spotLight.direction );\\n\t\tfloat spotAttenuation = getSpotAttenuation( \
spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\tif ( \
spotAttenuation > 0.0 ) {\\n\t\t\tfloat lightDistance = length( lVector \
);\\n\t\t\tlight.color = spotLight.color * \
spotAttenuation;\\n\t\t\tlight.color *= getDistanceAttenuation( \
lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tlight.visible = \
( light.color != vec3( 0.0 ) );\\n\t\t} else {\\n\t\t\tlight.color = vec3( \
0.0 );\\n\t\t\tlight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if \
NUM_RECT_AREA_LIGHTS > 0\\n\tstruct RectAreaLight {\\n\t\tvec3 \
color;\\n\t\tvec3 position;\\n\t\tvec3 halfWidth;\\n\t\tvec3 \
halfHeight;\\n\t};\\n\tuniform sampler2D ltc_1;\tuniform sampler2D \
ltc_2;\\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS \
];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 \
direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform \
HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 \
getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in \
vec3 normal ) {\\n\t\tfloat dotNL = dot( normal, hemiLight.direction \
);\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = \
mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight \
);\\n\t\treturn irradiance;\\n\t}\\n#endif\";\nvar \
envmap_physical_pars_fragment = \"#ifdef USE_ENVMAP\\n\tvec3 \
getIBLIrradiance( const in vec3 normal ) {\\n\t\t#ifdef \
ENVMAP_TYPE_CUBE_UV\\n\t\t\tvec3 worldNormal = inverseTransformDirection( \
normal, viewMatrix );\\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, \
envMapRotation * worldNormal, 1.0 );\\n\t\t\treturn PI * envMapColor.rgb * \
envMapIntensity;\\n\t\t#else\\n\t\t\treturn vec3( 0.0 \
);\\n\t\t#endif\\n\t}\\n\tvec3 getIBLRadiance( const in vec3 viewDir, const \
in vec3 normal, const in float roughness ) {\\n\t\t#ifdef \
ENVMAP_TYPE_CUBE_UV\\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal \
);\\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * \
roughness) );\\n\t\t\treflectVec = inverseTransformDirection( reflectVec, \
viewMatrix );\\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, \
envMapRotation * reflectVec, roughness );\\n\t\t\treturn envMapColor.rgb * \
envMapIntensity;\\n\t\t#else\\n\t\t\treturn vec3( 0.0 \
);\\n\t\t#endif\\n\t}\\n\t#ifdef USE_ANISOTROPY\\n\t\tvec3 \
getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const \
in float roughness, const in vec3 bitangent, const in float anisotropy ) \
{\\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\t\t\t\tvec3 bentNormal = cross( \
bitangent, viewDir );\\n\t\t\t\tbentNormal = normalize( cross( bentNormal, \
bitangent ) );\\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, \
pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\\n\t\t\t\treturn \
getIBLRadiance( viewDir, bentNormal, roughness \
);\\n\t\t\t#else\\n\t\t\t\treturn vec3( 0.0 \
);\\n\t\t\t#endif\\n\t\t}\\n\t#endif\\n#endif\";\nvar lights_toon_fragment = \
\"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\nvar \
lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\nstruct \
ToonMaterial {\\n\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in \
IncidentLight directLight, const in vec3 geometryPosition, const in vec3 \
geometryNormal, const in vec3 geometryViewDir, const in vec3 \
geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight \
reflectedLight ) {\\n\tvec3 irradiance = getGradientIrradiance( \
geometryNormal, directLight.direction ) * \
directLight.color;\\n\treflectedLight.directDiffuse += irradiance * \
BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( \
const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 \
geometryNormal, const in vec3 geometryViewDir, const in vec3 \
geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight \
reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * \
BRDF_Lambert( material.diffuseColor );\\n}\\n#define \
RE_Direct\t\t\t\tRE_Direct_Toon\\n#define \
RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\";\nvar lights_phong_fragment = \
\"BlinnPhongMaterial material;\\nmaterial.diffuseColor = \
diffuseColor.rgb;\\nmaterial.specularColor = \
specular;\\nmaterial.specularShininess = \
shininess;\\nmaterial.specularStrength = specularStrength;\";\nvar \
lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\nstruct \
BlinnPhongMaterial {\\n\tvec3 diffuseColor;\\n\tvec3 specularColor;\\n\tfloat \
specularShininess;\\n\tfloat specularStrength;\\n};\\nvoid \
RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 \
geometryPosition, const in vec3 geometryNormal, const in vec3 \
geometryViewDir, const in vec3 geometryClearcoatNormal, const in \
BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) \
{\\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) \
);\\n\tvec3 irradiance = dotNL * \
directLight.color;\\n\treflectedLight.directDiffuse += irradiance * \
BRDF_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += \
irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, \
geometryNormal, material.specularColor, material.specularShininess ) * \
material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in \
vec3 irradiance, const in vec3 geometryPosition, const in vec3 \
geometryNormal, const in vec3 geometryViewDir, const in vec3 \
geometryClearcoatNormal, const in BlinnPhongMaterial material, inout \
ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += \
irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define \
RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define \
RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\";\nvar \
lights_physical_fragment = \"PhysicalMaterial \
material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - \
metalnessFactor );\\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( \
dFdy( nonPerturbedNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, \
dxy.y ), dxy.z );\\nmaterial.roughness = max( roughnessFactor, 0.0525 \
);material.roughness += geometryRoughness;\\nmaterial.roughness = min( \
material.roughness, 1.0 );\\n#ifdef IOR\\n\tmaterial.ior = ior;\\n\t#ifdef \
USE_SPECULAR\\n\t\tfloat specularIntensityFactor = \
specularIntensity;\\n\t\tvec3 specularColorFactor = \
specularColor;\\n\t\t#ifdef USE_SPECULAR_COLORMAP\\n\t\t\tspecularColorFactor \
*= texture2D( specularColorMap, vSpecularColorMapUv \
).rgb;\\n\t\t#endif\\n\t\t#ifdef \
USE_SPECULAR_INTENSITYMAP\\n\t\t\tspecularIntensityFactor *= texture2D( \
specularIntensityMap, vSpecularIntensityMapUv \
).a;\\n\t\t#endif\\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, \
1.0, metalnessFactor );\\n\t#else\\n\t\tfloat specularIntensityFactor = \
1.0;\\n\t\tvec3 specularColorFactor = vec3( 1.0 );\\n\t\tmaterial.specularF90 \
= 1.0;\\n\t#endif\\n\tmaterial.specularColor = mix( min( pow2( ( material.ior \
- 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * \
specularIntensityFactor, diffuseColor.rgb, metalnessFactor \
);\\n#else\\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, \
metalnessFactor );\\n\tmaterial.specularF90 = 1.0;\\n#endif\\n#ifdef \
USE_CLEARCOAT\\n\tmaterial.clearcoat = \
clearcoat;\\n\tmaterial.clearcoatRoughness = \
clearcoatRoughness;\\n\tmaterial.clearcoatF0 = vec3( 0.04 \
);\\n\tmaterial.clearcoatF90 = 1.0;\\n\t#ifdef \
USE_CLEARCOATMAP\\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, \
vClearcoatMapUv ).x;\\n\t#endif\\n\t#ifdef \
USE_CLEARCOAT_ROUGHNESSMAP\\n\t\tmaterial.clearcoatRoughness *= texture2D( \
clearcoatRoughnessMap, vClearcoatRoughnessMapUv \
).y;\\n\t#endif\\n\tmaterial.clearcoat = saturate( material.clearcoat \
);\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 \
);\\n\tmaterial.clearcoatRoughness += \
geometryRoughness;\\n\tmaterial.clearcoatRoughness = min( \
material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef \
USE_DISPERSION\\n\tmaterial.dispersion = dispersion;\\n#endif\\n#ifdef \
USE_IRIDESCENCE\\n\tmaterial.iridescence = \
iridescence;\\n\tmaterial.iridescenceIOR = iridescenceIOR;\\n\t#ifdef \
USE_IRIDESCENCEMAP\\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, \
vIridescenceMapUv ).r;\\n\t#endif\\n\t#ifdef \
USE_IRIDESCENCE_THICKNESSMAP\\n\t\tmaterial.iridescenceThickness = \
(iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( \
iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + \
iridescenceThicknessMinimum;\\n\t#else\\n\t\tmaterial.iridescenceThickness = \
iridescenceThicknessMaximum;\\n\t#endif\\n#endif\\n#ifdef \
USE_SHEEN\\n\tmaterial.sheenColor = sheenColor;\\n\t#ifdef \
USE_SHEEN_COLORMAP\\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, \
vSheenColorMapUv ).rgb;\\n\t#endif\\n\tmaterial.sheenRoughness = clamp( \
sheenRoughness, 0.07, 1.0 );\\n\t#ifdef \
USE_SHEEN_ROUGHNESSMAP\\n\t\tmaterial.sheenRoughness *= texture2D( \
sheenRoughnessMap, vSheenRoughnessMapUv ).a;\\n\t#endif\\n#endif\\n#ifdef \
USE_ANISOTROPY\\n\t#ifdef USE_ANISOTROPYMAP\\n\t\tmat2 anisotropyMat = mat2( \
anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, \
anisotropyVector.x );\\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, \
vAnisotropyMapUv ).rgb;\\n\t\tvec2 anisotropyV = anisotropyMat * normalize( \
2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * \
anisotropyPolar.b;\\n\t#else\\n\t\tvec2 anisotropyV = \
anisotropyVector;\\n\t#endif\\n\tmaterial.anisotropy = length( anisotropyV \
);\\n\tif( material.anisotropy == 0.0 ) {\\n\t\tanisotropyV = vec2( 1.0, 0.0 \
);\\n\t} else {\\n\t\tanisotropyV /= \
material.anisotropy;\\n\t\tmaterial.anisotropy = saturate( \
material.anisotropy );\\n\t}\\n\tmaterial.alphaT = mix( pow2( \
material.roughness ), 1.0, pow2( material.anisotropy ) \
);\\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * \
anisotropyV.y;\\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] \
* anisotropyV.y;\\n#endif\";\nvar lights_physical_pars_fragment = \"struct \
PhysicalMaterial {\\n\tvec3 diffuseColor;\\n\tfloat roughness;\\n\tvec3 \
specularColor;\\n\tfloat specularF90;\\n\tfloat dispersion;\\n\t#ifdef \
USE_CLEARCOAT\\n\t\tfloat clearcoat;\\n\t\tfloat \
clearcoatRoughness;\\n\t\tvec3 clearcoatF0;\\n\t\tfloat \
clearcoatF90;\\n\t#endif\\n\t#ifdef USE_IRIDESCENCE\\n\t\tfloat \
iridescence;\\n\t\tfloat iridescenceIOR;\\n\t\tfloat \
iridescenceThickness;\\n\t\tvec3 iridescenceFresnel;\\n\t\tvec3 \
iridescenceF0;\\n\t#endif\\n\t#ifdef USE_SHEEN\\n\t\tvec3 \
sheenColor;\\n\t\tfloat sheenRoughness;\\n\t#endif\\n\t#ifdef IOR\\n\t\tfloat \
ior;\\n\t#endif\\n\t#ifdef USE_TRANSMISSION\\n\t\tfloat \
transmission;\\n\t\tfloat transmissionAlpha;\\n\t\tfloat \
thickness;\\n\t\tfloat attenuationDistance;\\n\t\tvec3 \
attenuationColor;\\n\t#endif\\n\t#ifdef USE_ANISOTROPY\\n\t\tfloat \
anisotropy;\\n\t\tfloat alphaT;\\n\t\tvec3 anisotropyT;\\n\t\tvec3 \
anisotropyB;\\n\t#endif\\n};\\nvec3 clearcoatSpecularDirect = vec3( 0.0 \
);\\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\\nvec3 sheenSpecularDirect \
= vec3( 0.0 );\\nvec3 sheenSpecularIndirect = vec3(0.0 );\\nvec3 \
Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) \
{\\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\\n    float x2 = x * x;\\n  \
  float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\\n    return ( f - vec3( f90 \
) * x5 ) / ( 1.0 - x5 );\\n}\\nfloat V_GGX_SmithCorrelated( const in float \
alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( \
alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) \
);\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) \
);\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in \
float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat \
denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / \
pow2( denom );\\n}\\n#ifdef USE_ANISOTROPY\\n\tfloat \
V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float \
alphaB, const in float dotTV, const in float dotBV, const in float dotTL, \
const in float dotBL, const in float dotNV, const in float dotNL ) \
{\\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, \
dotNV ) );\\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * \
dotBL, dotNL ) );\\n\t\tfloat v = 0.5 / ( gv + gl );\\n\t\treturn \
saturate(v);\\n\t}\\n\tfloat D_GGX_Anisotropic( const in float alphaT, const \
in float alphaB, const in float dotNH, const in float dotTH, const in float \
dotBH ) {\\n\t\tfloat a2 = alphaT * alphaB;\\n\t\thighp vec3 v = vec3( alphaB \
* dotTH, alphaT * dotBH, a2 * dotNH );\\n\t\thighp float v2 = dot( v, v \
);\\n\t\tfloat w2 = a2 / v2;\\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 \
);\\n\t}\\n#endif\\n#ifdef USE_CLEARCOAT\\n\tvec3 BRDF_GGX_Clearcoat( const \
in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in \
PhysicalMaterial material) {\\n\t\tvec3 f0 = \
material.clearcoatF0;\\n\t\tfloat f90 = material.clearcoatF90;\\n\t\tfloat \
roughness = material.clearcoatRoughness;\\n\t\tfloat alpha = pow2( roughness \
);\\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\\n\t\tfloat dotNL = \
saturate( dot( normal, lightDir ) );\\n\t\tfloat dotNV = saturate( dot( \
normal, viewDir ) );\\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) \
);\\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\t\tvec3 F = \
F_Schlick( f0, f90, dotVH );\\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, \
dotNL, dotNV );\\n\t\tfloat D = D_GGX( alpha, dotNH );\\n\t\treturn F * ( V * \
D );\\n\t}\\n#endif\\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 \
viewDir, const in vec3 normal, const in PhysicalMaterial material ) \
{\\n\tvec3 f0 = material.specularColor;\\n\tfloat f90 = \
material.specularF90;\\n\tfloat roughness = material.roughness;\\n\tfloat \
alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( lightDir + viewDir \
);\\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\tfloat dotNV = \
saturate( dot( normal, viewDir ) );\\n\tfloat dotNH = saturate( dot( normal, \
halfDir ) );\\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\tvec3 \
F = F_Schlick( f0, f90, dotVH );\\n\t#ifdef USE_IRIDESCENCE\\n\t\tF = mix( F, \
material.iridescenceFresnel, material.iridescence );\\n\t#endif\\n\t#ifdef \
USE_ANISOTROPY\\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir \
);\\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\\n\t\tfloat \
dotTH = dot( material.anisotropyT, halfDir );\\n\t\tfloat dotBL = dot( \
material.anisotropyB, lightDir );\\n\t\tfloat dotBV = dot( \
material.anisotropyB, viewDir );\\n\t\tfloat dotBH = dot( \
material.anisotropyB, halfDir );\\n\t\tfloat V = \
V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, \
dotTL, dotBL, dotNV, dotNL );\\n\t\tfloat D = D_GGX_Anisotropic( \
material.alphaT, alpha, dotNH, dotTH, dotBH );\\n\t#else\\n\t\tfloat V = \
V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\t\tfloat D = D_GGX( alpha, \
dotNH );\\n\t#endif\\n\treturn F * ( V * D );\\n}\\nvec2 LTC_Uv( const in \
vec3 N, const in vec3 V, const in float roughness ) {\\n\tconst float \
LUT_SIZE = 64.0;\\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / \
LUT_SIZE;\\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\tfloat dotNV = \
saturate( dot( N, V ) );\\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) \
);\\n\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\treturn uv;\\n}\\nfloat \
LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\tfloat l = length( f \
);\\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 \
LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\tfloat x \
= dot( v1, v2 );\\n\tfloat y = abs( x );\\n\tfloat a = 0.8543985 + ( \
0.4965155 + 0.0145206 * y ) * y;\\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) \
* y;\\n\tfloat v = a / b;\\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * \
inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\treturn cross( v1, v2 ) * \
theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, \
const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) \
{\\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\tvec3 v2 = rectCoords[ \
3 ] - rectCoords[ 0 ];\\n\tvec3 lightNormal = cross( v1, v2 );\\n\tif( dot( \
lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\tvec3 T1, \
T2;\\n\tT1 = normalize( V - N * dot( V, N ) );\\n\tT2 = - cross( N, T1 \
);\\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\tvec3 coords[ \
4 ];\\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\tcoords[ 1 ] = mat * \
( rectCoords[ 1 ] - P );\\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P \
);\\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\tcoords[ 0 ] = \
normalize( coords[ 0 ] );\\n\tcoords[ 1 ] = normalize( coords[ 1 ] \
);\\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\tcoords[ 3 ] = normalize( \
coords[ 3 ] );\\n\tvec3 vectorFormFactor = vec3( 0.0 );\\n\tvectorFormFactor \
+= LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\tvectorFormFactor \
+= LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\tvectorFormFactor \
+= LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\tvectorFormFactor \
+= LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\tfloat result = \
LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\treturn vec3( result \
);\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie( float roughness, float \
dotNH ) {\\n\tfloat alpha = pow2( roughness );\\n\tfloat invAlpha = 1.0 / \
alpha;\\n\tfloat cos2h = dotNH * dotNH;\\n\tfloat sin2h = max( 1.0 - cos2h, \
0.0078125 );\\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( \
2.0 * PI );\\n}\\nfloat V_Neubelt( float dotNV, float dotNL ) {\\n\treturn \
saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\\n}\\nvec3 \
BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 \
normal, vec3 sheenColor, const in float sheenRoughness ) {\\n\tvec3 halfDir = \
normalize( lightDir + viewDir );\\n\tfloat dotNL = saturate( dot( normal, \
lightDir ) );\\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\tfloat \
dotNH = saturate( dot( normal, halfDir ) );\\n\tfloat D = D_Charlie( \
sheenRoughness, dotNH );\\n\tfloat V = V_Neubelt( dotNV, dotNL );\\n\treturn \
sheenColor * ( D * V );\\n}\\n#endif\\nfloat IBLSheenBRDF( const in vec3 \
normal, const in vec3 viewDir, const in float roughness ) {\\n\tfloat dotNV = \
saturate( dot( normal, viewDir ) );\\n\tfloat r2 = roughness * \
roughness;\\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - \
25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\\n\tfloat b = roughness < 0.25 ? \
44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + \
0.72;\\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * \
( roughness - 0.25 ) );\\n\treturn saturate( DG * RECIPROCAL_PI );\\n}\\nvec2 \
DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float \
roughness ) {\\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\tconst \
vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, \
0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = \
min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 fab = vec2( - \
1.04, 1.04 ) * a004 + r.zw;\\n\treturn fab;\\n}\\nvec3 EnvironmentBRDF( const \
in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in \
float specularF90, const in float roughness ) {\\n\tvec2 fab = DFGApprox( \
normal, viewDir, roughness );\\n\treturn specularColor * fab.x + specularF90 \
* fab.y;\\n}\\n#ifdef USE_IRIDESCENCE\\nvoid \
computeMultiscatteringIridescence( const in vec3 normal, const in vec3 \
viewDir, const in vec3 specularColor, const in float specularF90, const in \
float iridescence, const in vec3 iridescenceF0, const in float roughness, \
inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#else\\nvoid \
computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in \
vec3 specularColor, const in float specularF90, const in float roughness, \
inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#endif\\n\tvec2 fab = \
DFGApprox( normal, viewDir, roughness );\\n\t#ifdef \
USE_IRIDESCENCE\\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, \
iridescence );\\n\t#else\\n\t\tvec3 Fr = specularColor;\\n\t#endif\\n\tvec3 \
FssEss = Fr * fab.x + specularF90 * fab.y;\\n\tfloat Ess = fab.x + \
fab.y;\\n\tfloat Ems = 1.0 - Ess;\\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * \
0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\tsingleScatter \
+= FssEss;\\n\tmultiScatter += Fms * Ems;\\n}\\n#if NUM_RECT_AREA_LIGHTS > \
0\\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, \
const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 \
geometryViewDir, const in vec3 geometryClearcoatNormal, const in \
PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\t\tvec3 \
normal = geometryNormal;\\n\t\tvec3 viewDir = geometryViewDir;\\n\t\tvec3 \
position = geometryPosition;\\n\t\tvec3 lightPos = \
rectAreaLight.position;\\n\t\tvec3 halfWidth = \
rectAreaLight.halfWidth;\\n\t\tvec3 halfHeight = \
rectAreaLight.halfHeight;\\n\t\tvec3 lightColor = \
rectAreaLight.color;\\n\t\tfloat roughness = material.roughness;\\n\t\tvec3 \
rectCoords[ 4 ];\\n\t\trectCoords[ 0 ] = lightPos + halfWidth - \
halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - \
halfHeight;\\n\t\trectCoords[ 2 ] = lightPos - halfWidth + \
halfHeight;\\n\t\trectCoords[ 3 ] = lightPos + halfWidth + \
halfHeight;\\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\t\tvec4 \
t1 = texture2D( ltc_1, uv );\\n\t\tvec4 t2 = texture2D( ltc_2, uv \
);\\n\t\tmat3 mInv = mat3(\\n\t\t\tvec3( t1.x, 0, t1.y ),\\n\t\t\tvec3(    0, \
1,    0 ),\\n\t\t\tvec3( t1.z, 0, t1.w )\\n\t\t);\\n\t\tvec3 fresnel = ( \
material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * \
t2.y );\\n\t\treflectedLight.directSpecular += lightColor * fresnel * \
LTC_Evaluate( normal, viewDir, position, mInv, rectCoords \
);\\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * \
LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords \
);\\n\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight \
directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, \
const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const \
in PhysicalMaterial material, inout ReflectedLight reflectedLight ) \
{\\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) \
);\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifdef \
USE_CLEARCOAT\\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, \
directLight.direction ) );\\n\t\tvec3 ccIrradiance = dotNLcc * \
directLight.color;\\n\t\tclearcoatSpecularDirect += ccIrradiance * \
BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, \
geometryClearcoatNormal, material );\\n\t#endif\\n\t#ifdef \
USE_SHEEN\\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( \
directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, \
material.sheenRoughness );\\n\t#endif\\n\treflectedLight.directSpecular += \
irradiance * BRDF_GGX( directLight.direction, geometryViewDir, \
geometryNormal, material );\\n\treflectedLight.directDiffuse += irradiance * \
BRDF_Lambert( material.diffuseColor );\\n}\\nvoid \
RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 \
geometryPosition, const in vec3 geometryNormal, const in vec3 \
geometryViewDir, const in vec3 geometryClearcoatNormal, const in \
PhysicalMaterial material, inout ReflectedLight reflectedLight ) \
{\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( \
material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in \
vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, \
const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 \
geometryViewDir, const in vec3 geometryClearcoatNormal, const in \
PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\t#ifdef \
USE_CLEARCOAT\\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * \
EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, \
material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness \
);\\n\t#endif\\n\t#ifdef USE_SHEEN\\n\t\tsheenSpecularIndirect += irradiance \
* material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, \
material.sheenRoughness );\\n\t#endif\\n\tvec3 singleScattering = vec3( 0.0 \
);\\n\tvec3 multiScattering = vec3( 0.0 );\\n\tvec3 cosineWeightedIrradiance \
= irradiance * RECIPROCAL_PI;\\n\t#ifdef \
USE_IRIDESCENCE\\n\t\tcomputeMultiscatteringIridescence( geometryNormal, \
geometryViewDir, material.specularColor, material.specularF90, \
material.iridescence, material.iridescenceFresnel, material.roughness, \
singleScattering, multiScattering );\\n\t#else\\n\t\tcomputeMultiscattering( \
geometryNormal, geometryViewDir, material.specularColor, \
material.specularF90, material.roughness, singleScattering, multiScattering \
);\\n\t#endif\\n\tvec3 totalScattering = singleScattering + \
multiScattering;\\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( \
totalScattering.r, totalScattering.g ), totalScattering.b ) \
);\\n\treflectedLight.indirectSpecular += radiance * \
singleScattering;\\n\treflectedLight.indirectSpecular += multiScattering * \
cosineWeightedIrradiance;\\n\treflectedLight.indirectDiffuse += diffuse * \
cosineWeightedIrradiance;\\n}\\n#define \
RE_Direct\t\t\t\tRE_Direct_Physical\\n#define \
RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\\n#define \
RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define \
RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\nfloat \
computeSpecularOcclusion( const in float dotNV, const in float \
ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( \
dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + \
ambientOcclusion );\\n}\";\nvar lights_fragment_begin = \"\\nvec3 \
geometryPosition = - vViewPosition;\\nvec3 geometryNormal = normal;\\nvec3 \
geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( \
vViewPosition );\\nvec3 geometryClearcoatNormal = vec3( 0.0 );\\n#ifdef \
USE_CLEARCOAT\\n\tgeometryClearcoatNormal = \
clearcoatNormal;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\tfloat dotNVi = \
saturate( dot( normal, geometryViewDir ) );\\n\tif ( \
material.iridescenceThickness == 0.0 ) {\\n\t\tmaterial.iridescence = \
0.0;\\n\t} else {\\n\t\tmaterial.iridescence = saturate( material.iridescence \
);\\n\t}\\n\tif ( material.iridescence > 0.0 ) \
{\\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, \
material.iridescenceIOR, dotNVi, material.iridescenceThickness, \
material.specularColor );\\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( \
material.iridescenceFresnel, 1.0, dotNVi );\\n\t}\\n#endif\\nIncidentLight \
directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct \
)\\n\tPointLight pointLight;\\n\t#if defined( USE_SHADOWMAP ) && \
NUM_POINT_LIGHT_SHADOWS > 0\\n\tPointLightShadow \
pointLightShadow;\\n\t#endif\\n\t#pragma unroll_loop_start\\n\tfor ( int i = \
0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i \
];\\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight \
);\\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < \
NUM_POINT_LIGHT_SHADOWS )\\n\t\tpointLightShadow = pointLightShadows[ i \
];\\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? \
getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, \
pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, \
pointLightShadow.shadowRadius, vPointShadowCoord[ i ], \
pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : \
1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometryPosition, \
geometryNormal, geometryViewDir, geometryClearcoatNormal, material, \
reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if ( \
NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight \
spotLight;\\n\tvec4 spotColor;\\n\tvec3 spotLightCoord;\\n\tbool \
inSpotLightMap;\\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > \
0\\n\tSpotLightShadow spotLightShadow;\\n\t#endif\\n\t#pragma \
unroll_loop_start\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) \
{\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotLightInfo( spotLight, \
geometryPosition, directLight );\\n\t\t#if ( UNROLLED_LOOP_INDEX < \
NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\t\t#define SPOT_LIGHT_MAP_INDEX \
UNROLLED_LOOP_INDEX\\n\t\t#elif ( UNROLLED_LOOP_INDEX < \
NUM_SPOT_LIGHT_SHADOWS )\\n\t\t#define SPOT_LIGHT_MAP_INDEX \
NUM_SPOT_LIGHT_MAPS\\n\t\t#else\\n\t\t#define SPOT_LIGHT_MAP_INDEX ( \
UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + \
NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\t\t#endif\\n\t\t#if ( \
SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\\n\t\t\tspotLightCoord = \
vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\\n\t\t\tinSpotLightMap = \
all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) \
);\\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], \
spotLightCoord.xy );\\n\t\t\tdirectLight.color = inSpotLightMap ? \
directLight.color * spotColor.rgb : \
directLight.color;\\n\t\t#endif\\n\t\t#undef SPOT_LIGHT_MAP_INDEX\\n\t\t#if \
defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS \
)\\n\t\tspotLightShadow = spotLightShadows[ i ];\\n\t\tdirectLight.color *= ( \
directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], \
spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, \
spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i \
] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometryPosition, \
geometryNormal, geometryViewDir, geometryClearcoatNormal, material, \
reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if ( \
NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight \
directionalLight;\\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > \
0\\n\tDirectionalLightShadow directionalLightShadow;\\n\t#endif\\n\t#pragma \
unroll_loop_start\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) \
{\\n\t\tdirectionalLight = directionalLights[ i \
];\\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\\n\t\t#if \
defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS \
)\\n\t\tdirectionalLightShadow = directionalLightShadows[ i \
];\\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? \
getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, \
directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, \
directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : \
1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometryPosition, \
geometryNormal, geometryViewDir, geometryClearcoatNormal, material, \
reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if ( \
NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\tRectAreaLight \
rectAreaLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < \
NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\t\trectAreaLight = rectAreaLights[ i \
];\\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, \
geometryViewDir, geometryClearcoatNormal, material, reflectedLight \
);\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if defined( \
RE_IndirectDiffuse )\\n\tvec3 iblIrradiance = vec3( 0.0 );\\n\tvec3 \
irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#if defined( \
USE_LIGHT_PROBES )\\n\t\tirradiance += getLightProbeIrradiance( lightProbe, \
geometryNormal );\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\t#pragma \
unroll_loop_start\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) \
{\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], \
geometryNormal );\\n\t\t}\\n\t\t#pragma \
unroll_loop_end\\n\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular \
)\\n\tvec3 radiance = vec3( 0.0 );\\n\tvec3 clearcoatRadiance = vec3( 0.0 \
);\\n#endif\";\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse \
)\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec4 lightMapTexel = texture2D( lightMap, \
vLightMapUv );\\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * \
lightMapIntensity;\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if \
defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV \
)\\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal \
);\\n\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( \
RE_IndirectSpecular )\\n\t#ifdef USE_ANISOTROPY\\n\t\tradiance += \
getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, \
material.roughness, material.anisotropyB, material.anisotropy \
);\\n\t#else\\n\t\tradiance += getIBLRadiance( geometryViewDir, \
geometryNormal, material.roughness );\\n\t#endif\\n\t#ifdef \
USE_CLEARCOAT\\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, \
geometryClearcoatNormal, material.clearcoatRoughness \
);\\n\t#endif\\n#endif\";\nvar lights_fragment_end = \"#if defined( \
RE_IndirectDiffuse )\\n\tRE_IndirectDiffuse( irradiance, geometryPosition, \
geometryNormal, geometryViewDir, geometryClearcoatNormal, material, \
reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular \
)\\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, \
geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, \
material, reflectedLight );\\n#endif\";\nvar logdepthbuf_fragment = \"#if \
defined( USE_LOGDEPTHBUF )\\n\tgl_FragDepth = vIsPerspective == 0.0 ? \
gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\nvar \
logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF )\\n\tuniform \
float logDepthBufFC;\\n\tvarying float vFragDepth;\\n\tvarying float \
vIsPerspective;\\n#endif\";\nvar logdepthbuf_pars_vertex = \"#ifdef \
USE_LOGDEPTHBUF\\n\tvarying float vFragDepth;\\n\tvarying float \
vIsPerspective;\\n#endif\";\nvar logdepthbuf_vertex = \"#ifdef \
USE_LOGDEPTHBUF\\n\tvFragDepth = 1.0 + gl_Position.w;\\n\tvIsPerspective = \
float( isPerspectiveMatrix( projectionMatrix ) );\\n#endif\";\nvar \
map_fragment = \"#ifdef USE_MAP\\n\tvec4 sampledDiffuseColor = texture2D( \
map, vMapUv );\\n\t#ifdef DECODE_VIDEO_TEXTURE\\n\t\tsampledDiffuseColor = \
sRGBTransferEOTF( sampledDiffuseColor );\\n\t#endif\\n\tdiffuseColor *= \
sampledDiffuseColor;\\n#endif\";\nvar map_pars_fragment = \"#ifdef \
USE_MAP\\n\tuniform sampler2D map;\\n#endif\";\nvar map_particle_fragment = \
\"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\t#if defined( \
USE_POINTS_UV )\\n\t\tvec2 uv = vUv;\\n\t#else\\n\t\tvec2 uv = ( uvTransform \
* vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) \
).xy;\\n\t#endif\\n#endif\\n#ifdef USE_MAP\\n\tdiffuseColor *= texture2D( \
map, uv );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( \
alphaMap, uv ).g;\\n#endif\";\nvar map_particle_pars_fragment = \"#if \
defined( USE_POINTS_UV )\\n\tvarying vec2 vUv;\\n#else\\n\t#if defined( \
USE_MAP ) || defined( USE_ALPHAMAP )\\n\t\tuniform mat3 \
uvTransform;\\n\t#endif\\n#endif\\n#ifdef USE_MAP\\n\tuniform sampler2D \
map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tuniform sampler2D \
alphaMap;\\n#endif\";\nvar metalnessmap_fragment = \"float metalnessFactor = \
metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( \
metalnessMap, vMetalnessMapUv );\\n\tmetalnessFactor *= \
texelMetalness.b;\\n#endif\";\nvar metalnessmap_pars_fragment = \"#ifdef \
USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\nvar \
morphinstance_vertex = \"#ifdef USE_INSTANCING_MORPH\\n\tfloat \
morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\tfloat \
morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID \
), 0 ).r;\\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) \
{\\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, \
gl_InstanceID ), 0 ).r;\\n\t}\\n#endif\";\nvar morphcolor_vertex = \"#if \
defined( USE_MORPHCOLORS )\\n\tvColor *= morphTargetBaseInfluence;\\n\tfor ( \
int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\t\t#if defined( \
USE_COLOR_ALPHA )\\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += \
getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\\n\t\t#elif \
defined( USE_COLOR )\\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor \
+= getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i \
];\\n\t\t#endif\\n\t}\\n#endif\";\nvar morphnormal_vertex = \"#ifdef \
USE_MORPHNORMALS\\n\tobjectNormal *= morphTargetBaseInfluence;\\n\tfor ( int \
i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\t\tif ( morphTargetInfluences[ i ] \
!= 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * \
morphTargetInfluences[ i ];\\n\t}\\n#endif\";\nvar morphtarget_pars_vertex = \
\"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_INSTANCING_MORPH\\n\t\tuniform \
float morphTargetBaseInfluence;\\n\t\tuniform float morphTargetInfluences[ \
MORPHTARGETS_COUNT ];\\n\t#endif\\n\tuniform sampler2DArray \
morphTargetsTexture;\\n\tuniform ivec2 morphTargetsTextureSize;\\n\tvec4 \
getMorph( const in int vertexIndex, const in int morphTargetIndex, const in \
int offset ) {\\n\t\tint texelIndex = vertexIndex * \
MORPHTARGETS_TEXTURE_STRIDE + offset;\\n\t\tint y = texelIndex / \
morphTargetsTextureSize.x;\\n\t\tint x = texelIndex - y * \
morphTargetsTextureSize.x;\\n\t\tivec3 morphUV = ivec3( x, y, \
morphTargetIndex );\\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 \
);\\n\t}\\n#endif\";\nvar morphtarget_vertex = \"#ifdef \
USE_MORPHTARGETS\\n\ttransformed *= morphTargetBaseInfluence;\\n\tfor ( int i \
= 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\t\tif ( morphTargetInfluences[ i ] \
!= 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * \
morphTargetInfluences[ i ];\\n\t}\\n#endif\";\nvar normal_fragment_begin = \
\"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef \
FLAT_SHADED\\n\tvec3 fdx = dFdx( vViewPosition );\\n\tvec3 fdy = dFdy( \
vViewPosition );\\n\tvec3 normal = normalize( cross( fdx, fdy ) \
);\\n#else\\n\tvec3 normal = normalize( vNormal );\\n\t#ifdef \
DOUBLE_SIDED\\n\t\tnormal *= faceDirection;\\n\t#endif\\n#endif\\n#if \
defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) \
|| defined( USE_ANISOTROPY )\\n\t#ifdef USE_TANGENT\\n\t\tmat3 tbn = mat3( \
normalize( vTangent ), normalize( vBitangent ), normal \
);\\n\t#else\\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, \
normal,\\n\t\t#if defined( USE_NORMALMAP )\\n\t\t\tvNormalMapUv\\n\t\t#elif \
defined( USE_CLEARCOAT_NORMALMAP \
)\\n\t\t\tvClearcoatNormalMapUv\\n\t\t#else\\n\t\t\tvUv\\n\t\t#endif\\n\t\t);\
\\n\t#endif\\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED \
)\\n\t\ttbn[0] *= faceDirection;\\n\t\ttbn[1] *= \
faceDirection;\\n\t#endif\\n#endif\\n#ifdef \
USE_CLEARCOAT_NORMALMAP\\n\t#ifdef USE_TANGENT\\n\t\tmat3 tbn2 = mat3( \
normalize( vTangent ), normalize( vBitangent ), normal \
);\\n\t#else\\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, \
vClearcoatNormalMapUv );\\n\t#endif\\n\t#if defined( DOUBLE_SIDED ) && ! \
defined( FLAT_SHADED )\\n\t\ttbn2[0] *= faceDirection;\\n\t\ttbn2[1] *= \
faceDirection;\\n\t#endif\\n#endif\\nvec3 nonPerturbedNormal = \
normal;\";\nvar normal_fragment_maps = \"#ifdef \
USE_NORMALMAP_OBJECTSPACE\\n\tnormal = texture2D( normalMap, vNormalMapUv \
).xyz * 2.0 - 1.0;\\n\t#ifdef FLIP_SIDED\\n\t\tnormal = - \
normal;\\n\t#endif\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * \
faceDirection;\\n\t#endif\\n\tnormal = normalize( normalMatrix * normal \
);\\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\\n\tvec3 mapN = texture2D( \
normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\tmapN.xy *= \
normalScale;\\n\tnormal = normalize( tbn * mapN );\\n#elif defined( \
USE_BUMPMAP )\\n\tnormal = perturbNormalArb( - vViewPosition, normal, \
dHdxy_fwd(), faceDirection );\\n#endif\";\nvar normal_pars_fragment = \
\"#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n\t#ifdef \
USE_TANGENT\\n\t\tvarying vec3 vTangent;\\n\t\tvarying vec3 \
vBitangent;\\n\t#endif\\n#endif\";\nvar normal_pars_vertex = \"#ifndef \
FLAT_SHADED\\n\tvarying vec3 vNormal;\\n\t#ifdef USE_TANGENT\\n\t\tvarying \
vec3 vTangent;\\n\t\tvarying vec3 vBitangent;\\n\t#endif\\n#endif\";\nvar \
normal_vertex = \"#ifndef FLAT_SHADED\\n\tvNormal = normalize( \
transformedNormal );\\n\t#ifdef USE_TANGENT\\n\t\tvTangent = normalize( \
transformedTangent );\\n\t\tvBitangent = normalize( cross( vNormal, vTangent \
) * tangent.w );\\n\t#endif\\n#endif\";\nvar normalmap_pars_fragment = \
\"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 \
normalScale;\\n#endif\\n#ifdef USE_NORMALMAP_OBJECTSPACE\\n\tuniform mat3 \
normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( \
USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || \
defined( USE_ANISOTROPY ) )\\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 \
surf_norm, vec2 uv ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = \
dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( uv.st );\\n\t\tvec2 st1 = dFdy( \
uv.st );\\n\t\tvec3 N = surf_norm;\\n\t\tvec3 q1perp = cross( q1, N \
);\\n\t\tvec3 q0perp = cross( N, q0 );\\n\t\tvec3 T = q1perp * st0.x + q0perp \
* st1.x;\\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\t\tfloat det = \
max( dot( T, T ), dot( B, B ) );\\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : \
inversesqrt( det );\\n\t\treturn mat3( T * scale, B * scale, N \
);\\n\t}\\n#endif\";\nvar clearcoat_normal_fragment_begin = \"#ifdef \
USE_CLEARCOAT\\n\tvec3 clearcoatNormal = nonPerturbedNormal;\\n#endif\";\nvar \
clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\tvec3 \
clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * \
2.0 - 1.0;\\n\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\tclearcoatNormal \
= normalize( tbn2 * clearcoatMapN );\\n#endif\";\nvar clearcoat_pars_fragment \
= \"#ifdef USE_CLEARCOATMAP\\n\tuniform sampler2D \
clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\tuniform sampler2D \
clearcoatNormalMap;\\n\tuniform vec2 clearcoatNormalScale;\\n#endif\\n#ifdef \
USE_CLEARCOAT_ROUGHNESSMAP\\n\tuniform sampler2D \
clearcoatRoughnessMap;\\n#endif\";\nvar iridescence_pars_fragment = \"#ifdef \
USE_IRIDESCENCEMAP\\n\tuniform sampler2D iridescenceMap;\\n#endif\\n#ifdef \
USE_IRIDESCENCE_THICKNESSMAP\\n\tuniform sampler2D \
iridescenceThicknessMap;\\n#endif\";\nvar opaque_fragment = \"#ifdef \
OPAQUE\\ndiffuseColor.a = 1.0;\\n#endif\\n#ifdef \
USE_TRANSMISSION\\ndiffuseColor.a *= \
material.transmissionAlpha;\\n#endif\\ngl_FragColor = vec4( outgoingLight, \
diffuseColor.a );\";\nvar packing = \"vec3 packNormalToRGB( const in vec3 \
normal ) {\\n\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 \
unpackRGBToNormal( const in vec3 rgb ) {\\n\treturn 2.0 * rgb.xyz - \
1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale \
= 255. / 256.;const float ShiftRight8 = 1. / 256.;\\nconst float Inv255 = 1. \
/ 255.;\\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * \
256.0 * 256.0 );\\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / \
PackFactors.g );\\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / \
PackFactors.rg, 1.0 / PackFactors.b );\\nconst vec4 UnpackFactors4 = vec4( \
UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\\nvec4 \
packDepthToRGBA( const in float v ) {\\n\tif( v <= 0.0 )\\n\t\treturn vec4( \
0., 0., 0., 0. );\\n\tif( v >= 1.0 )\\n\t\treturn vec4( 1., 1., 1., 1. \
);\\n\tfloat vuf;\\n\tfloat af = modf( v * PackFactors.a, vuf );\\n\tfloat bf \
= modf( vuf * ShiftRight8, vuf );\\n\tfloat gf = modf( vuf * ShiftRight8, vuf \
);\\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af \
);\\n}\\nvec3 packDepthToRGB( const in float v ) {\\n\tif( v <= 0.0 \
)\\n\t\treturn vec3( 0., 0., 0. );\\n\tif( v >= 1.0 )\\n\t\treturn vec3( 1., \
1., 1. );\\n\tfloat vuf;\\n\tfloat bf = modf( v * PackFactors.b, vuf \
);\\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\\n\treturn vec3( vuf * \
Inv255, gf * PackUpscale, bf );\\n}\\nvec2 packDepthToRG( const in float v ) \
{\\n\tif( v <= 0.0 )\\n\t\treturn vec2( 0., 0. );\\n\tif( v >= 1.0 \
)\\n\t\treturn vec2( 1., 1. );\\n\tfloat vuf;\\n\tfloat gf = modf( v * 256., \
vuf );\\n\treturn vec2( vuf * Inv255, gf );\\n}\\nfloat unpackRGBAToDepth( \
const in vec4 v ) {\\n\treturn dot( v, UnpackFactors4 );\\n}\\nfloat \
unpackRGBToDepth( const in vec3 v ) {\\n\treturn dot( v, UnpackFactors3 \
);\\n}\\nfloat unpackRGToDepth( const in vec2 v ) {\\n\treturn v.r * \
UnpackFactors2.r + v.g * UnpackFactors2.g;\\n}\\nvec4 pack2HalfToRGBA( const \
in vec2 v ) {\\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * \
255.0 ) );\\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w \
);\\n}\\nvec2 unpackRGBATo2Half( const in vec4 v ) {\\n\treturn vec2( v.x + ( \
v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( \
const in float viewZ, const in float near, const in float far ) {\\n\treturn \
( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( \
const in float depth, const in float near, const in float far ) {\\n\treturn \
depth * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in \
float viewZ, const in float near, const in float far ) {\\n\treturn ( ( near \
+ viewZ ) * far ) / ( ( far - near ) * viewZ );\\n}\\nfloat \
perspectiveDepthToViewZ( const in float depth, const in float near, const in \
float far ) {\\n\treturn ( near * far ) / ( ( far - near ) * depth - far \
);\\n}\";\nvar premultiplied_alpha_fragment = \"#ifdef \
PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\nvar \
project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef \
USE_BATCHING\\n\tmvPosition = batchingMatrix * mvPosition;\\n#endif\\n#ifdef \
USE_INSTANCING\\n\tmvPosition = instanceMatrix * \
mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * \
mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\nvar \
dithering_fragment = \"#ifdef DITHERING\\n\tgl_FragColor.rgb = dithering( \
gl_FragColor.rgb );\\n#endif\";\nvar dithering_pars_fragment = \"#ifdef \
DITHERING\\n\tvec3 dithering( vec3 color ) {\\n\t\tfloat grid_position = \
rand( gl_FragCoord.xy );\\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, \
-0.25 / 255.0, 0.25 / 255.0 );\\n\t\tdither_shift_RGB = mix( 2.0 * \
dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\t\treturn \
color + dither_shift_RGB;\\n\t}\\n#endif\";\nvar roughnessmap_fragment = \
\"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 \
texelRoughness = texture2D( roughnessMap, vRoughnessMapUv \
);\\n\troughnessFactor *= texelRoughness.g;\\n#endif\";\nvar \
roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D \
roughnessMap;\\n#endif\";\nvar shadowmap_pars_fragment = \"#if \
NUM_SPOT_LIGHT_COORDS > 0\\n\tvarying vec4 vSpotLightCoord[ \
NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#if NUM_SPOT_LIGHT_MAPS > 0\\n\tuniform \
sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\\n#endif\\n#ifdef \
USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\t\tuniform sampler2D \
directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tvarying vec4 \
vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tstruct \
DirectionalLightShadow {\\n\t\t\tfloat shadowIntensity;\\n\t\t\tfloat \
shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat \
shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t};\\n\t\tuniform \
DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS \
];\\n\t#endif\\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\t\tuniform sampler2D \
spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t\tstruct SpotLightShadow \
{\\n\t\t\tfloat shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat \
shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 \
shadowMapSize;\\n\t\t};\\n\t\tuniform SpotLightShadow spotLightShadows[ \
NUM_SPOT_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > \
0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS \
];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS \
];\\n\t\tstruct PointLightShadow {\\n\t\t\tfloat \
shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat \
shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 \
shadowMapSize;\\n\t\t\tfloat shadowCameraNear;\\n\t\t\tfloat \
shadowCameraFar;\\n\t\t};\\n\t\tuniform PointLightShadow pointLightShadows[ \
NUM_POINT_LIGHT_SHADOWS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D \
depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, \
unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tvec2 \
texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\t\treturn \
unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\t}\\n\tfloat VSMShadow \
(sampler2D shadow, vec2 uv, float compare ){\\n\t\tfloat occlusion = \
1.0;\\n\t\tvec2 distribution = texture2DDistribution( shadow, uv \
);\\n\t\tfloat hard_shadow = step( compare , distribution.x );\\n\t\tif \
(hard_shadow != 1.0 ) {\\n\t\t\tfloat distance = compare - distribution.x \
;\\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y \
);\\n\t\t\tfloat softness_probability = variance / (variance + distance * \
distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) \
/ ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, \
softness_probability ), 0.0, 1.0 );\\n\t\t}\\n\t\treturn \
occlusion;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 \
shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, \
vec4 shadowCoord ) {\\n\t\tfloat shadow = 1.0;\\n\t\tshadowCoord.xyz /= \
shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbool inFrustum = \
shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && \
shadowCoord.y <= 1.0;\\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= \
1.0;\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF \
)\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - \
texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * \
shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat \
dy1 = + texelSize.y * shadowRadius;\\n\t\t\tfloat dx2 = dx0 / \
2.0;\\n\t\t\tfloat dy2 = dy0 / 2.0;\\n\t\t\tfloat dx3 = dx1 / \
2.0;\\n\t\t\tfloat dy3 = dy1 / 2.0;\\n\t\t\tshadow = \
(\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), \
shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + \
vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, \
shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) \
+\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), \
shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + \
vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, \
shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) \
+\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), \
shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + \
vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, \
shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, \
shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) \
+\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), \
shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + \
vec2( dx2, dy3 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, \
shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) \
+\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), \
shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + \
vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, \
shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) \
+\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), \
shadowCoord.z )\\n\t\t\t) * ( 1.0 / 17.0 );\\n\t\t#elif defined( \
SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / \
shadowMapSize;\\n\t\t\tfloat dx = texelSize.x;\\n\t\t\tfloat dy = \
texelSize.y;\\n\t\t\tvec2 uv = shadowCoord.xy;\\n\t\t\tvec2 f = fract( uv * \
shadowMapSize + 0.5 );\\n\t\t\tuv -= f * texelSize;\\n\t\t\tshadow = \
(\\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) \
+\\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z \
) +\\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), \
shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, \
shadowCoord.z ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, \
0.0 ), shadowCoord.z ),\\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( \
2.0 * dx, 0.0 ), shadowCoord.z ),\\n\t\t\t\t\t f.x ) +\\n\t\t\t\tmix( \
texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z \
),\\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), \
shadowCoord.z ),\\n\t\t\t\t\t f.x ) +\\n\t\t\t\tmix( texture2DCompare( \
shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\\n\t\t\t\t\t \
texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z \
),\\n\t\t\t\t\t f.y ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + \
vec2( dx, -dy ), shadowCoord.z ),\\n\t\t\t\t\t texture2DCompare( shadowMap, \
uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\t\t\t\t\t f.y ) \
+\\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), \
shadowCoord.z ),\\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 \
* dx, -dy ), shadowCoord.z ),\\n\t\t\t\t\t\t  f.x ),\\n\t\t\t\t\t mix( \
texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z \
),\\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy \
), shadowCoord.z ),\\n\t\t\t\t\t\t  f.x ),\\n\t\t\t\t\t f.y )\\n\t\t\t) * ( \
1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\t\t\tshadow = \
VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z \
);\\n\t\t#else\\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, \
shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn mix( 1.0, shadow, \
shadowIntensity );\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) \
{\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, \
max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * \
( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat \
almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - \
almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 \
)\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) \
{\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * \
signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( \
v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * \
signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, \
0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 \
shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, \
vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) \
{\\n\t\tfloat shadow = 1.0;\\n\t\tvec3 lightToPosition = \
shadowCoord.xyz;\\n\t\t\\n\t\tfloat lightToPositionLength = length( \
lightToPosition );\\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 \
&& lightToPositionLength - shadowCameraNear >= 0.0 ) {\\n\t\t\tfloat dp = ( \
lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - \
shadowCameraNear );\t\t\tdp += shadowBias;\\n\t\t\tvec3 bd3D = normalize( \
lightToPosition );\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * \
vec2( 4.0, 2.0 ) );\\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( \
SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\t\t\t\tvec2 \
offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\t\tshadow = \
(\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, \
texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D \
+ offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, \
cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) \
+\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, \
texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( \
bd3D, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, \
cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) \
+\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, \
texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D \
+ offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, \
cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t\t) * ( 1.0 / 9.0 \
);\\n\t\t\t#else\\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( \
bd3D, texelSize.y ), dp );\\n\t\t\t#endif\\n\t\t}\\n\t\treturn mix( 1.0, \
shadow, shadowIntensity );\\n\t}\\n#endif\";\nvar shadowmap_pars_vertex = \
\"#if NUM_SPOT_LIGHT_COORDS > 0\\n\tuniform mat4 spotLightMatrix[ \
NUM_SPOT_LIGHT_COORDS ];\\n\tvarying vec4 vSpotLightCoord[ \
NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\t#if \
NUM_DIR_LIGHT_SHADOWS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ \
NUM_DIR_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ \
NUM_DIR_LIGHT_SHADOWS ];\\n\t\tstruct DirectionalLightShadow {\\n\t\t\tfloat \
shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat \
shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 \
shadowMapSize;\\n\t\t};\\n\t\tuniform DirectionalLightShadow \
directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if \
NUM_SPOT_LIGHT_SHADOWS > 0\\n\t\tstruct SpotLightShadow {\\n\t\t\tfloat \
shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat \
shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 \
shadowMapSize;\\n\t\t};\\n\t\tuniform SpotLightShadow spotLightShadows[ \
NUM_SPOT_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > \
0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS \
];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS \
];\\n\t\tstruct PointLightShadow {\\n\t\t\tfloat \
shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat \
shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 \
shadowMapSize;\\n\t\t\tfloat shadowCameraNear;\\n\t\t\tfloat \
shadowCameraFar;\\n\t\t};\\n\t\tuniform PointLightShadow pointLightShadows[ \
NUM_POINT_LIGHT_SHADOWS ];\\n\t#endif\\n#endif\";\nvar shadowmap_vertex = \
\"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || \
NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\\n\tvec3 \
shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix \
);\\n\tvec4 shadowWorldPosition;\\n#endif\\n#if defined( USE_SHADOWMAP \
)\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\t\t#pragma unroll_loop_start\\n\t\tfor \
( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\t\t\tshadowWorldPosition \
= worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i \
].shadowNormalBias, 0 );\\n\t\t\tvDirectionalShadowCoord[ i ] = \
directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\t\t}\\n\t\t#pragma \
unroll_loop_end\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\t\t#pragma \
unroll_loop_start\\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) \
{\\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * \
pointLightShadows[ i ].shadowNormalBias, 0 );\\n\t\t\tvPointShadowCoord[ i ] \
= pointShadowMatrix[ i ] * shadowWorldPosition;\\n\t\t}\\n\t\t#pragma \
unroll_loop_end\\n\t#endif\\n#endif\\n#if NUM_SPOT_LIGHT_COORDS > \
0\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < \
NUM_SPOT_LIGHT_COORDS; i ++ ) {\\n\t\tshadowWorldPosition = \
worldPosition;\\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < \
NUM_SPOT_LIGHT_SHADOWS )\\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal \
* spotLightShadows[ i ].shadowNormalBias;\\n\t\t#endif\\n\t\tvSpotLightCoord[ \
i ] = spotLightMatrix[ i ] * shadowWorldPosition;\\n\t}\\n\t#pragma \
unroll_loop_end\\n#endif\";\nvar shadowmask_pars_fragment = \"float \
getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if \
NUM_DIR_LIGHT_SHADOWS > 0\\n\tDirectionalLightShadow \
directionalLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < \
NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\t\tdirectionalLight = \
directionalLightShadows[ i ];\\n\t\tshadow *= receiveShadow ? getShadow( \
directionalShadowMap[ i ], directionalLight.shadowMapSize, \
directionalLight.shadowIntensity, directionalLight.shadowBias, \
directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : \
1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#if \
NUM_SPOT_LIGHT_SHADOWS > 0\\n\tSpotLightShadow spotLight;\\n\t#pragma \
unroll_loop_start\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) \
{\\n\t\tspotLight = spotLightShadows[ i ];\\n\t\tshadow *= receiveShadow ? \
getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, \
spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, \
vSpotLightCoord[ i ] ) : 1.0;\\n\t}\\n\t#pragma \
unroll_loop_end\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > \
0\\n\tPointLightShadow pointLight;\\n\t#pragma unroll_loop_start\\n\tfor ( \
int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\t\tpointLight = \
pointLightShadows[ i ];\\n\t\tshadow *= receiveShadow ? getPointShadow( \
pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, \
pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], \
pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : \
1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#endif\\n\treturn \
shadow;\\n}\";\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX \
= getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( \
skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 \
boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\nvar \
skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\tuniform mat4 \
bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\tuniform highp sampler2D \
boneTexture;\\n\tmat4 getBoneMatrix( const in float i ) {\\n\t\tint size = \
textureSize( boneTexture, 0 ).x;\\n\t\tint j = int( i ) * 4;\\n\t\tint x = j \
% size;\\n\t\tint y = j / size;\\n\t\tvec4 v1 = texelFetch( boneTexture, \
ivec2( x, y ), 0 );\\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y \
), 0 );\\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 \
);\\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 \
);\\n\t\treturn mat4( v1, v2, v3, v4 );\\n\t}\\n#endif\";\nvar \
skinning_vertex = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * \
vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += \
boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * \
skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * \
skinWeight.z;\\n\tskinned += boneMatW * skinVertex * \
skinWeight.w;\\n\ttransformed = ( bindMatrixInverse * skinned \
).xyz;\\n#endif\";\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\tmat4 \
skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * \
boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += \
skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * \
boneMatW;\\n\tskinMatrix = bindMatrixInverse * skinMatrix * \
bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) \
).xyz;\\n\t#ifdef USE_TANGENT\\n\t\tobjectTangent = vec4( skinMatrix * vec4( \
objectTangent, 0.0 ) ).xyz;\\n\t#endif\\n#endif\";\nvar specularmap_fragment \
= \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = \
texture2D( specularMap, vSpecularMapUv );\\n\tspecularStrength = \
texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\nvar \
specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D \
specularMap;\\n#endif\";\nvar tonemapping_fragment = \"#if defined( \
TONE_MAPPING )\\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb \
);\\n#endif\";\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define \
saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float \
toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\treturn \
saturate( toneMappingExposure * color );\\n}\\nvec3 ReinhardToneMapping( vec3 \
color ) {\\n\tcolor *= toneMappingExposure;\\n\treturn saturate( color / ( \
vec3( 1.0 ) + color ) );\\n}\\nvec3 CineonToneMapping( vec3 color ) \
{\\n\tcolor *= toneMappingExposure;\\n\tcolor = max( vec3( 0.0 ), color - \
0.004 );\\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 \
* color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) \
{\\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\tvec3 b = v * ( \
0.983729 * v + 0.4329510 ) + 0.238081;\\n\treturn a / b;\\n}\\nvec3 \
ACESFilmicToneMapping( vec3 color ) {\\n\tconst mat3 ACESInputMat = \
mat3(\\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, \
0.13383 ),\\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\\n\t);\\n\tconst mat3 \
ACESOutputMat = mat3(\\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( \
-0.53108,  1.10813, -0.07276 ),\\n\t\tvec3( -0.07367, -0.00605,  1.07602 \
)\\n\t);\\n\tcolor *= toneMappingExposure / 0.6;\\n\tcolor = ACESInputMat * \
color;\\n\tcolor = RRTAndODTFit( color );\\n\tcolor = ACESOutputMat * \
color;\\n\treturn saturate( color );\\n}\\nconst mat3 \
LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\\n\tvec3( 1.6605, - 0.1246, - 0.0182 \
),\\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\\n\tvec3( - 0.0728, - 0.0083, \
1.1187 )\\n);\\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\\n\tvec3( \
0.6274, 0.0691, 0.0164 ),\\n\tvec3( 0.3293, 0.9195, 0.0880 ),\\n\tvec3( \
0.0433, 0.0113, 0.8956 )\\n);\\nvec3 agxDefaultContrastApprox( vec3 x ) \
{\\n\tvec3 x2 = x * x;\\n\tvec3 x4 = x2 * x2;\\n\treturn + 15.5 * x4 * \
x2\\n\t\t- 40.14 * x4 * x\\n\t\t+ 31.96 * x4\\n\t\t- 6.868 * x2 * x\\n\t\t+ \
0.4298 * x2\\n\t\t+ 0.1191 * x\\n\t\t- 0.00232;\\n}\\nvec3 AgXToneMapping( \
vec3 color ) {\\n\tconst mat3 AgXInsetMatrix = mat3(\\n\t\tvec3( \
0.856627153315983, 0.137318972929847, 0.11189821299995 ),\\n\t\tvec3( \
0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\\n\t\tvec3( \
0.0482516061458583, 0.101439036467562, 0.811302368396859 )\\n\t);\\n\tconst \
mat3 AgXOutsetMatrix = mat3(\\n\t\tvec3( 1.1271005818144368, - \
0.1413297634984383, - 0.14132976349843826 ),\\n\t\tvec3( - \
0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\\n\t\tvec3( \
- 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 \
)\\n\t);\\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = \
4.026069;\\n\tcolor *= toneMappingExposure;\\n\tcolor = \
LINEAR_SRGB_TO_LINEAR_REC2020 * color;\\n\tcolor = AgXInsetMatrix * \
color;\\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\\n\tcolor = ( \
color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\\n\tcolor = clamp( color, 0.0, \
1.0 );\\n\tcolor = agxDefaultContrastApprox( color );\\n\tcolor = \
AgXOutsetMatrix * color;\\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( \
2.2 ) );\\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\\n\tcolor = \
clamp( color, 0.0, 1.0 );\\n\treturn color;\\n}\\nvec3 NeutralToneMapping( \
vec3 color ) {\\n\tconst float StartCompression = 0.8 - 0.04;\\n\tconst float \
Desaturation = 0.15;\\n\tcolor *= toneMappingExposure;\\n\tfloat x = min( \
color.r, min( color.g, color.b ) );\\n\tfloat offset = x < 0.08 ? x - 6.25 * \
x * x : 0.04;\\n\tcolor -= offset;\\n\tfloat peak = max( color.r, max( \
color.g, color.b ) );\\n\tif ( peak < StartCompression ) return \
color;\\n\tfloat d = 1. - StartCompression;\\n\tfloat newPeak = 1. - d * d / \
( peak + d - StartCompression );\\n\tcolor *= newPeak / peak;\\n\tfloat g = \
1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\\n\treturn mix( color, \
vec3( newPeak ), g );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return \
color; }\";\nvar transmission_fragment = \"#ifdef \
USE_TRANSMISSION\\n\tmaterial.transmission = \
transmission;\\n\tmaterial.transmissionAlpha = 1.0;\\n\tmaterial.thickness = \
thickness;\\n\tmaterial.attenuationDistance = \
attenuationDistance;\\n\tmaterial.attenuationColor = \
attenuationColor;\\n\t#ifdef USE_TRANSMISSIONMAP\\n\t\tmaterial.transmission \
*= texture2D( transmissionMap, vTransmissionMapUv ).r;\\n\t#endif\\n\t#ifdef \
USE_THICKNESSMAP\\n\t\tmaterial.thickness *= texture2D( thicknessMap, \
vThicknessMapUv ).g;\\n\t#endif\\n\tvec3 pos = vWorldPosition;\\n\tvec3 v = \
normalize( cameraPosition - pos );\\n\tvec3 n = inverseTransformDirection( \
normal, viewMatrix );\\n\tvec4 transmitted = getIBLVolumeRefraction(\\n\t\tn, \
v, material.roughness, material.diffuseColor, material.specularColor, \
material.specularF90,\\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, \
material.dispersion, material.ior, \
material.thickness,\\n\t\tmaterial.attenuationColor, \
material.attenuationDistance );\\n\tmaterial.transmissionAlpha = mix( \
material.transmissionAlpha, transmitted.a, material.transmission \
);\\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, \
material.transmission );\\n#endif\";\nvar transmission_pars_fragment = \
\"#ifdef USE_TRANSMISSION\\n\tuniform float transmission;\\n\tuniform float \
thickness;\\n\tuniform float attenuationDistance;\\n\tuniform vec3 \
attenuationColor;\\n\t#ifdef USE_TRANSMISSIONMAP\\n\t\tuniform sampler2D \
transmissionMap;\\n\t#endif\\n\t#ifdef USE_THICKNESSMAP\\n\t\tuniform \
sampler2D thicknessMap;\\n\t#endif\\n\tuniform vec2 \
transmissionSamplerSize;\\n\tuniform sampler2D \
transmissionSamplerMap;\\n\tuniform mat4 modelMatrix;\\n\tuniform mat4 \
projectionMatrix;\\n\tvarying vec3 vWorldPosition;\\n\tfloat w0( float a ) \
{\\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 \
);\\n\t}\\n\tfloat w1( float a ) {\\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( \
3.0 * a - 6.0 ) + 4.0 );\\n\t}\\n\tfloat w2( float a ){\\n\t\treturn ( 1.0 / \
6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\\n\t}\\n\tfloat w3( \
float a ) {\\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\\n\t}\\n\tfloat g0( \
float a ) {\\n\t\treturn w0( a ) + w1( a );\\n\t}\\n\tfloat g1( float a ) \
{\\n\t\treturn w2( a ) + w3( a );\\n\t}\\n\tfloat h0( float a ) \
{\\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\\n\t}\\n\tfloat h1( \
float a ) {\\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) \
);\\n\t}\\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod \
) {\\n\t\tuv = uv * texelSize.zw + 0.5;\\n\t\tvec2 iuv = floor( uv \
);\\n\t\tvec2 fuv = fract( uv );\\n\t\tfloat g0x = g0( fuv.x );\\n\t\tfloat \
g1x = g1( fuv.x );\\n\t\tfloat h0x = h0( fuv.x );\\n\t\tfloat h1x = h1( fuv.x \
);\\n\t\tfloat h0y = h0( fuv.y );\\n\t\tfloat h1y = h1( fuv.y );\\n\t\tvec2 \
p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\t\tvec2 p1 \
= ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\t\tvec2 p2 = \
( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\t\tvec2 p3 = ( \
vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\t\treturn g0( \
fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod \
) ) +\\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * \
textureLod( tex, p3, lod ) );\\n\t}\\n\tvec4 textureBicubic( sampler2D \
sampler, vec2 uv, float lod ) {\\n\t\tvec2 fLodSize = vec2( textureSize( \
sampler, int( lod ) ) );\\n\t\tvec2 cLodSize = vec2( textureSize( sampler, \
int( lod + 1.0 ) ) );\\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\\n\t\tvec2 \
cLodSizeInv = 1.0 / cLodSize;\\n\t\tvec4 fSample = bicubic( sampler, uv, \
vec4( fLodSizeInv, fLodSize ), floor( lod ) );\\n\t\tvec4 cSample = bicubic( \
sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\\n\t\treturn mix( \
fSample, cSample, fract( lod ) );\\n\t}\\n\tvec3 getVolumeTransmissionRay( \
const in vec3 n, const in vec3 v, const in float thickness, const in float \
ior, const in mat4 modelMatrix ) {\\n\t\tvec3 refractionVector = refract( - \
v, normalize( n ), 1.0 / ior );\\n\t\tvec3 modelScale;\\n\t\tmodelScale.x = \
length( vec3( modelMatrix[ 0 ].xyz ) );\\n\t\tmodelScale.y = length( vec3( \
modelMatrix[ 1 ].xyz ) );\\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 \
].xyz ) );\\n\t\treturn normalize( refractionVector ) * thickness * \
modelScale;\\n\t}\\n\tfloat applyIorToRoughness( const in float roughness, \
const in float ior ) {\\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, \
1.0 );\\n\t}\\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const \
in float roughness, const in float ior ) {\\n\t\tfloat lod = log2( \
transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior \
);\\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod \
);\\n\t}\\n\tvec3 volumeAttenuation( const in float transmissionDistance, \
const in vec3 attenuationColor, const in float attenuationDistance ) \
{\\n\t\tif ( isinf( attenuationDistance ) ) {\\n\t\t\treturn vec3( 1.0 \
);\\n\t\t} else {\\n\t\t\tvec3 attenuationCoefficient = -log( \
attenuationColor ) / attenuationDistance;\\n\t\t\tvec3 transmittance = exp( - \
attenuationCoefficient * transmissionDistance );\t\t\treturn \
transmittance;\\n\t\t}\\n\t}\\n\tvec4 getIBLVolumeRefraction( const in vec3 \
n, const in vec3 v, const in float roughness, const in vec3 \
diffuseColor,\\n\t\tconst in vec3 specularColor, const in float specularF90, \
const in vec3 position, const in mat4 modelMatrix,\\n\t\tconst in mat4 \
viewMatrix, const in mat4 projMatrix, const in float dispersion, const in \
float ior, const in float thickness,\\n\t\tconst in vec3 attenuationColor, \
const in float attenuationDistance ) {\\n\t\tvec4 \
transmittedLight;\\n\t\tvec3 transmittance;\\n\t\t#ifdef \
USE_DISPERSION\\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * \
dispersion;\\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread \
);\\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\\n\t\t\t\tvec3 transmissionRay = \
getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix \
);\\n\t\t\t\tvec3 refractedRayExit = position + \
transmissionRay;\\n\t\t\\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * \
vec4( refractedRayExit, 1.0 );\\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / \
ndcPos.w;\\n\t\t\t\trefractionCoords += 1.0;\\n\t\t\t\trefractionCoords /= \
2.0;\\n\t\t\\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( \
refractionCoords, roughness, iors[ i ] );\\n\t\t\t\ttransmittedLight[ i ] = \
transmissionSample[ i ];\\n\t\t\t\ttransmittedLight.a += \
transmissionSample.a;\\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * \
volumeAttenuation( length( transmissionRay ), attenuationColor, \
attenuationDistance )[ i ];\\n\t\t\t}\\n\t\t\ttransmittedLight.a /= \
3.0;\\n\t\t\\n\t\t#else\\n\t\t\\n\t\t\tvec3 transmissionRay = \
getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n\t\t\tvec3 \
refractedRayExit = position + transmissionRay;\\n\t\t\tvec4 ndcPos = \
projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\t\t\tvec2 \
refractionCoords = ndcPos.xy / ndcPos.w;\\n\t\t\trefractionCoords += \
1.0;\\n\t\t\trefractionCoords /= 2.0;\\n\t\t\ttransmittedLight = \
getTransmissionSample( refractionCoords, roughness, ior \
);\\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( \
transmissionRay ), attenuationColor, attenuationDistance \
);\\n\t\t\\n\t\t#endif\\n\t\tvec3 attenuatedColor = transmittance * \
transmittedLight.rgb;\\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, \
specularF90, roughness );\\n\t\tfloat transmittanceFactor = ( transmittance.r \
+ transmittance.g + transmittance.b ) / 3.0;\\n\t\treturn vec4( ( 1.0 - F ) * \
attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor \
);\\n\t}\\n#endif\";\nvar uv_pars_fragment = \"#if defined( USE_UV ) || \
defined( USE_ANISOTROPY )\\n\tvarying vec2 vUv;\\n#endif\\n#ifdef \
USE_MAP\\n\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tvarying \
vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\tvarying vec2 \
vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\tvarying vec2 \
vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\tvarying vec2 \
vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tvarying vec2 \
vNormalMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\tvarying vec2 \
vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\tvarying vec2 \
vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\tvarying vec2 \
vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\tvarying vec2 \
vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\tvarying vec2 \
vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\tvarying vec2 \
vClearcoatNormalMapUv;\\n#endif\\n#ifdef \
USE_CLEARCOAT_ROUGHNESSMAP\\n\tvarying vec2 \
vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\tvarying \
vec2 vIridescenceMapUv;\\n#endif\\n#ifdef \
USE_IRIDESCENCE_THICKNESSMAP\\n\tvarying vec2 \
vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\tvarying \
vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\tvarying \
vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\tvarying vec2 \
vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\tvarying vec2 \
vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\tvarying \
vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef \
USE_TRANSMISSIONMAP\\n\tuniform mat3 transmissionMapTransform;\\n\tvarying \
vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\tuniform mat3 \
thicknessMapTransform;\\n\tvarying vec2 vThicknessMapUv;\\n#endif\";\nvar \
uv_pars_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY \
)\\n\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\tuniform mat3 \
mapTransform;\\n\tvarying vec2 vMapUv;\\n#endif\\n#ifdef \
USE_ALPHAMAP\\n\tuniform mat3 alphaMapTransform;\\n\tvarying vec2 \
vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\tuniform mat3 \
lightMapTransform;\\n\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef \
USE_AOMAP\\n\tuniform mat3 aoMapTransform;\\n\tvarying vec2 \
vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\tuniform mat3 \
bumpMapTransform;\\n\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef \
USE_NORMALMAP\\n\tuniform mat3 normalMapTransform;\\n\tvarying vec2 \
vNormalMapUv;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\tuniform mat3 \
displacementMapTransform;\\n\tvarying vec2 \
vDisplacementMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\tuniform mat3 \
emissiveMapTransform;\\n\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef \
USE_METALNESSMAP\\n\tuniform mat3 metalnessMapTransform;\\n\tvarying vec2 \
vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\tuniform mat3 \
roughnessMapTransform;\\n\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef \
USE_ANISOTROPYMAP\\n\tuniform mat3 anisotropyMapTransform;\\n\tvarying vec2 \
vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\tuniform mat3 \
clearcoatMapTransform;\\n\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef \
USE_CLEARCOAT_NORMALMAP\\n\tuniform mat3 \
clearcoatNormalMapTransform;\\n\tvarying vec2 \
vClearcoatNormalMapUv;\\n#endif\\n#ifdef \
USE_CLEARCOAT_ROUGHNESSMAP\\n\tuniform mat3 \
clearcoatRoughnessMapTransform;\\n\tvarying vec2 \
vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\tuniform \
mat3 sheenColorMapTransform;\\n\tvarying vec2 \
vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\tuniform mat3 \
sheenRoughnessMapTransform;\\n\tvarying vec2 \
vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\tuniform mat3 \
iridescenceMapTransform;\\n\tvarying vec2 \
vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\tuniform \
mat3 iridescenceThicknessMapTransform;\\n\tvarying vec2 \
vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\tuniform \
mat3 specularMapTransform;\\n\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef \
USE_SPECULAR_COLORMAP\\n\tuniform mat3 specularColorMapTransform;\\n\tvarying \
vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef \
USE_SPECULAR_INTENSITYMAP\\n\tuniform mat3 \
specularIntensityMapTransform;\\n\tvarying vec2 \
vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\tuniform \
mat3 transmissionMapTransform;\\n\tvarying vec2 \
vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\tuniform mat3 \
thicknessMapTransform;\\n\tvarying vec2 vThicknessMapUv;\\n#endif\";\nvar \
uv_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\tvUv = \
vec3( uv, 1 ).xy;\\n#endif\\n#ifdef USE_MAP\\n\tvMapUv = ( mapTransform * \
vec3( MAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tvAlphaMapUv = ( \
alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_LIGHTMAP\\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) \
).xy;\\n#endif\\n#ifdef USE_AOMAP\\n\tvAoMapUv = ( aoMapTransform * vec3( \
AOMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_BUMPMAP\\n\tvBumpMapUv = ( \
bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_NORMALMAP\\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 \
) ).xy;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\tvDisplacementMapUv = ( \
displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) \
).xy;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\tvEmissiveMapUv = ( \
emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_METALNESSMAP\\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( \
METALNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_ROUGHNESSMAP\\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( \
ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_ANISOTROPYMAP\\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( \
ANISOTROPYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_CLEARCOATMAP\\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( \
CLEARCOATMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_CLEARCOAT_NORMALMAP\\n\tvClearcoatNormalMapUv = ( \
clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) \
).xy;\\n#endif\\n#ifdef \
USE_CLEARCOAT_ROUGHNESSMAP\\n\tvClearcoatRoughnessMapUv = ( \
clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) \
).xy;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\tvIridescenceMapUv = ( \
iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) \
).xy;\\n#endif\\n#ifdef \
USE_IRIDESCENCE_THICKNESSMAP\\n\tvIridescenceThicknessMapUv = ( \
iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) \
).xy;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\tvSheenColorMapUv = ( \
sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_SHEEN_ROUGHNESSMAP\\n\tvSheenRoughnessMapUv = ( \
sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) \
).xy;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\tvSpecularMapUv = ( \
specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_SPECULAR_COLORMAP\\n\tvSpecularColorMapUv = ( specularColorMapTransform * \
vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef \
USE_SPECULAR_INTENSITYMAP\\n\tvSpecularIntensityMapUv = ( \
specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) \
).xy;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\tvTransmissionMapUv = ( \
transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) \
).xy;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\tvThicknessMapUv = ( \
thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\";\nvar \
worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || \
defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || \
NUM_SPOT_LIGHT_COORDS > 0\\n\tvec4 worldPosition = vec4( transformed, 1.0 \
);\\n\t#ifdef USE_BATCHING\\n\t\tworldPosition = batchingMatrix * \
worldPosition;\\n\t#endif\\n\t#ifdef USE_INSTANCING\\n\t\tworldPosition = \
instanceMatrix * worldPosition;\\n\t#endif\\n\tworldPosition = modelMatrix * \
worldPosition;\\n#endif\";\nvar vertex$h = \"varying vec2 vUv;\\nuniform mat3 \
uvTransform;\\nvoid main() {\\n\tvUv = ( uvTransform * vec3( uv, 1 ) \
).xy;\\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\nvar fragment$h \
= \"uniform sampler2D t2D;\\nuniform float backgroundIntensity;\\nvarying \
vec2 vUv;\\nvoid main() {\\n\tvec4 texColor = texture2D( t2D, vUv \
);\\n\t#ifdef DECODE_VIDEO_TEXTURE\\n\t\ttexColor = vec4( mix( pow( \
texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), \
texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 \
) ) ) ), texColor.w );\\n\t#endif\\n\ttexColor.rgb *= \
backgroundIntensity;\\n\tgl_FragColor = texColor;\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n}\";\nvar \
vertex$g = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() \
{\\n\tvWorldDirection = transformDirection( position, modelMatrix \
);\\n\t#include <begin_vertex>\\n\t#include \
<project_vertex>\\n\tgl_Position.z = gl_Position.w;\\n}\";\nvar fragment$g = \
\"#ifdef ENVMAP_TYPE_CUBE\\n\tuniform samplerCube envMap;\\n#elif defined( \
ENVMAP_TYPE_CUBE_UV )\\n\tuniform sampler2D envMap;\\n#endif\\nuniform float \
flipEnvMap;\\nuniform float backgroundBlurriness;\\nuniform float \
backgroundIntensity;\\nuniform mat3 backgroundRotation;\\nvarying vec3 \
vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() \
{\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 texColor = textureCube( envMap, \
backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz \
) );\\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\tvec4 texColor = \
textureCubeUV( envMap, backgroundRotation * vWorldDirection, \
backgroundBlurriness );\\n\t#else\\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, \
1.0 );\\n\t#endif\\n\ttexColor.rgb *= backgroundIntensity;\\n\tgl_FragColor = \
texColor;\\n\t#include <tonemapping_fragment>\\n\t#include \
<colorspace_fragment>\\n}\";\nvar vertex$f = \"varying vec3 \
vWorldDirection;\\n#include <common>\\nvoid main() {\\n\tvWorldDirection = \
transformDirection( position, modelMatrix );\\n\t#include \
<begin_vertex>\\n\t#include <project_vertex>\\n\tgl_Position.z = \
gl_Position.w;\\n}\";\nvar fragment$f = \"uniform samplerCube \
tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 \
vWorldDirection;\\nvoid main() {\\n\tvec4 texColor = textureCube( tCube, \
vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\tgl_FragColor = \
texColor;\\n\tgl_FragColor.a *= opacity;\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n}\";\nvar \
vertex$e = \"#include <common>\\n#include <batching_pars_vertex>\\n#include \
<uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include \
<morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include \
<logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying \
vec2 vHighPrecisionZW;\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include \
<batching_vertex>\\n\t#include <skinbase_vertex>\\n\t#include \
<morphinstance_vertex>\\n\t#ifdef USE_DISPLACEMENTMAP\\n\t\t#include \
<beginnormal_vertex>\\n\t\t#include <morphnormal_vertex>\\n\t\t#include \
<skinnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include \
<logdepthbuf_vertex>\\n\t#include \
<clipping_planes_vertex>\\n\tvHighPrecisionZW = gl_Position.zw;\\n}\";\nvar \
fragment$e = \"#if DEPTH_PACKING == 3200\\n\tuniform float \
opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include \
<uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include \
<alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include \
<alphahash_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include \
<clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid \
main() {\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#include \
<clipping_planes_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a \
= opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include \
<alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include \
<alphahash_fragment>\\n\t#include <logdepthbuf_fragment>\\n\tfloat fragCoordZ \
= 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\t#if \
DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), \
opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = \
packDepthToRGBA( fragCoordZ );\\n\t#elif DEPTH_PACKING == \
3202\\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 \
);\\n\t#elif DEPTH_PACKING == 3203\\n\t\tgl_FragColor = vec4( packDepthToRG( \
fragCoordZ ), 0.0, 1.0 );\\n\t#endif\\n}\";\nvar vertex$d = \"#define \
DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include \
<batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include \
<displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include \
<skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() \
{\\n\t#include <uv_vertex>\\n\t#include <batching_vertex>\\n\t#include \
<skinbase_vertex>\\n\t#include <morphinstance_vertex>\\n\t#ifdef \
USE_DISPLACEMENTMAP\\n\t\t#include <beginnormal_vertex>\\n\t\t#include \
<morphnormal_vertex>\\n\t\t#include \
<skinnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include \
<worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = \
worldPosition.xyz;\\n}\";\nvar fragment$d = \"#define DISTANCE\\nuniform vec3 \
referencePosition;\\nuniform float nearDistance;\\nuniform float \
farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include \
<packing>\\n#include <uv_pars_fragment>\\n#include \
<map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include \
<alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include \
<clipping_planes_pars_fragment>\\nvoid main () {\\n\tvec4 diffuseColor = \
vec4( 1.0 );\\n\t#include <clipping_planes_fragment>\\n\t#include \
<map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include \
<alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\tfloat dist = \
length( vWorldPosition - referencePosition );\\n\tdist = ( dist - \
nearDistance ) / ( farDistance - nearDistance );\\n\tdist = saturate( dist \
);\\n\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\nvar vertex$c = \
\"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() \
{\\n\tvWorldDirection = transformDirection( position, modelMatrix \
);\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n}\";\nvar \
fragment$c = \"uniform sampler2D tEquirect;\\nvarying vec3 \
vWorldDirection;\\n#include <common>\\nvoid main() {\\n\tvec3 direction = \
normalize( vWorldDirection );\\n\tvec2 sampleUV = equirectUv( direction \
);\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n}\";\nvar \
vertex$b = \"uniform float scale;\\nattribute float lineDistance;\\nvarying \
float vLineDistance;\\n#include <common>\\n#include \
<uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include \
<fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include \
<logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid \
main() {\\n\tvLineDistance = scale * lineDistance;\\n\t#include \
<uv_vertex>\\n\t#include <color_vertex>\\n\t#include \
<morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include \
<begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include \
<project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include \
<clipping_planes_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar fragment$b = \
\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float \
dashSize;\\nuniform float totalSize;\\nvarying float \
vLineDistance;\\n#include <common>\\n#include \
<color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include \
<map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include \
<logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid \
main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include \
<clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > \
dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 \
);\\n\t#include <logdepthbuf_fragment>\\n\t#include \
<map_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = \
diffuseColor.rgb;\\n\t#include <opaque_fragment>\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include \
<fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n}\";\nvar \
vertex$a = \"#include <common>\\n#include <batching_pars_vertex>\\n#include \
<uv_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include \
<color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include \
<morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include \
<logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid \
main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include \
<morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include \
<batching_vertex>\\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING \
)\\n\t\t#include <beginnormal_vertex>\\n\t\t#include \
<morphnormal_vertex>\\n\t\t#include <skinbase_vertex>\\n\t\t#include \
<skinnormal_vertex>\\n\t\t#include \
<defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include \
<clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include \
<envmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar fragment$a = \"uniform \
vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 \
vNormal;\\n#endif\\n#include <common>\\n#include \
<dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include \
<uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include \
<alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include \
<alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include \
<lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include \
<envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include \
<specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include \
<clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( \
diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\t#include \
<logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include \
<color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include \
<alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include \
<specularmap_fragment>\\n\tReflectedLight reflectedLight = ReflectedLight( \
vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\t#ifdef \
USE_LIGHTMAP\\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv \
);\\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * \
lightMapIntensity * \
RECIPROCAL_PI;\\n\t#else\\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 \
);\\n\t#endif\\n\t#include \
<aomap_fragment>\\n\treflectedLight.indirectDiffuse *= \
diffuseColor.rgb;\\n\tvec3 outgoingLight = \
reflectedLight.indirectDiffuse;\\n\t#include <envmap_fragment>\\n\t#include \
<opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include \
<colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include \
<premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nvar \
vertex$9 = \"#define LAMBERT\\nvarying vec3 vViewPosition;\\n#include \
<common>\\n#include <batching_pars_vertex>\\n#include \
<uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include \
<envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include \
<fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include \
<morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include \
<shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include \
<clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include \
<uv_vertex>\\n\t#include <color_vertex>\\n\t#include \
<morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include \
<batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include \
<morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include \
<skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include \
<normal_vertex>\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include \
<logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition \
= - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include \
<envmap_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include \
<fog_vertex>\\n}\";\nvar fragment$9 = \"#define LAMBERT\\nuniform vec3 \
diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include \
<common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include \
<color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include \
<map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include \
<alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include \
<aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include \
<emissivemap_pars_fragment>\\n#include \
<envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include \
<fog_pars_fragment>\\n#include <bsdfs>\\n#include \
<lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include \
<lights_lambert_pars_fragment>\\n#include \
<shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include \
<normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include \
<logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid \
main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include \
<clipping_planes_fragment>\\n\tReflectedLight reflectedLight = \
ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) \
);\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include \
<logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include \
<color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include \
<alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include \
<specularmap_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include \
<normal_fragment_maps>\\n\t#include <emissivemap_fragment>\\n\t#include \
<lights_lambert_fragment>\\n\t#include <lights_fragment_begin>\\n\t#include \
<lights_fragment_maps>\\n\t#include <lights_fragment_end>\\n\t#include \
<aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + \
reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include \
<envmap_fragment>\\n\t#include <opaque_fragment>\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include \
<fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include \
<dithering_fragment>\\n}\";\nvar vertex$8 = \"#define MATCAP\\nvarying vec3 \
vViewPosition;\\n#include <common>\\n#include \
<batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include \
<color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include \
<fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include \
<morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include \
<logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid \
main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include \
<morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include \
<batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include \
<morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include \
<skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include \
<normal_vertex>\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include \
<logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include \
<fog_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n}\";\nvar fragment$8 = \
\"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform \
sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#include \
<common>\\n#include <dithering_pars_fragment>\\n#include \
<color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include \
<map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include \
<alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include \
<fog_pars_fragment>\\n#include <normal_pars_fragment>\\n#include \
<bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include \
<logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid \
main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include \
<clipping_planes_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#include \
<map_fragment>\\n\t#include <color_fragment>\\n\t#include \
<alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include \
<alphahash_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include \
<normal_fragment_maps>\\n\tvec3 viewDir = normalize( vViewPosition \
);\\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\tvec3 y \
= cross( viewDir, x );\\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) \
) * 0.495 + 0.5;\\n\t#ifdef USE_MATCAP\\n\t\tvec4 matcapColor = texture2D( \
matcap, uv );\\n\t#else\\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, \
uv.y ) ), 1.0 );\\n\t#endif\\n\tvec3 outgoingLight = diffuseColor.rgb * \
matcapColor.rgb;\\n\t#include <opaque_fragment>\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include \
<fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include \
<dithering_fragment>\\n}\";\nvar vertex$7 = \"#define NORMAL\\n#if defined( \
FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( \
USE_NORMALMAP_TANGENTSPACE )\\n\tvarying vec3 \
vViewPosition;\\n#endif\\n#include <common>\\n#include \
<batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include \
<displacementmap_pars_vertex>\\n#include <normal_pars_vertex>\\n#include \
<morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include \
<logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid \
main() {\\n\t#include <uv_vertex>\\n\t#include <batching_vertex>\\n\t#include \
<beginnormal_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include \
<morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include \
<skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include \
<normal_vertex>\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include \
<logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n#if defined( \
FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( \
USE_NORMALMAP_TANGENTSPACE )\\n\tvViewPosition = - \
mvPosition.xyz;\\n#endif\\n}\";\nvar fragment$7 = \"#define NORMAL\\nuniform \
float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || \
defined( USE_NORMALMAP_TANGENTSPACE )\\n\tvarying vec3 \
vViewPosition;\\n#endif\\n#include <packing>\\n#include \
<uv_pars_fragment>\\n#include <normal_pars_fragment>\\n#include \
<bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include \
<logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid \
main() {\\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\\n\t#include \
<clipping_planes_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#include \
<normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\tgl_FragColor \
= vec4( packNormalToRGB( normal ), diffuseColor.a );\\n\t#ifdef \
OPAQUE\\n\t\tgl_FragColor.a = 1.0;\\n\t#endif\\n}\";\nvar vertex$6 = \
\"#define PHONG\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include \
<batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include \
<displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include \
<color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include \
<normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include \
<skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include \
<logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid \
main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include \
<morphcolor_vertex>\\n\t#include <batching_vertex>\\n\t#include \
<beginnormal_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include \
<morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include \
<skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include \
<normal_vertex>\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include \
<logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition \
= - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include \
<envmap_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include \
<fog_vertex>\\n}\";\nvar fragment$6 = \"#define PHONG\\nuniform vec3 \
diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float \
shininess;\\nuniform float opacity;\\n#include <common>\\n#include \
<packing>\\n#include <dithering_pars_fragment>\\n#include \
<color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include \
<map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include \
<alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include \
<aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include \
<emissivemap_pars_fragment>\\n#include \
<envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include \
<fog_pars_fragment>\\n#include <bsdfs>\\n#include \
<lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include \
<lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include \
<bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include \
<specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include \
<clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( \
diffuse, opacity );\\n\t#include \
<clipping_planes_fragment>\\n\tReflectedLight reflectedLight = \
ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) \
);\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include \
<logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include \
<color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include \
<alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include \
<specularmap_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include \
<normal_fragment_maps>\\n\t#include <emissivemap_fragment>\\n\t#include \
<lights_phong_fragment>\\n\t#include <lights_fragment_begin>\\n\t#include \
<lights_fragment_maps>\\n\t#include <lights_fragment_end>\\n\t#include \
<aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + \
reflectedLight.indirectDiffuse + reflectedLight.directSpecular + \
reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include \
<envmap_fragment>\\n\t#include <opaque_fragment>\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include \
<fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include \
<dithering_fragment>\\n}\";\nvar vertex$5 = \"#define STANDARD\\nvarying vec3 \
vViewPosition;\\n#ifdef USE_TRANSMISSION\\n\tvarying vec3 \
vWorldPosition;\\n#endif\\n#include <common>\\n#include \
<batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include \
<displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include \
<fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include \
<morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include \
<shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include \
<clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include \
<uv_vertex>\\n\t#include <color_vertex>\\n\t#include \
<morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include \
<batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include \
<morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include \
<skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include \
<normal_vertex>\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include \
<logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition \
= - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include \
<shadowmap_vertex>\\n\t#include <fog_vertex>\\n#ifdef \
USE_TRANSMISSION\\n\tvWorldPosition = worldPosition.xyz;\\n#endif\\n}\";\nvar \
fragment$5 = \"#define STANDARD\\n#ifdef PHYSICAL\\n\t#define IOR\\n\t#define \
USE_SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 \
emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform \
float opacity;\\n#ifdef IOR\\n\tuniform float ior;\\n#endif\\n#ifdef \
USE_SPECULAR\\n\tuniform float specularIntensity;\\n\tuniform vec3 \
specularColor;\\n\t#ifdef USE_SPECULAR_COLORMAP\\n\t\tuniform sampler2D \
specularColorMap;\\n\t#endif\\n\t#ifdef \
USE_SPECULAR_INTENSITYMAP\\n\t\tuniform sampler2D \
specularIntensityMap;\\n\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT\\n\tuniform \
float clearcoat;\\n\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef \
USE_DISPERSION\\n\tuniform float dispersion;\\n#endif\\n#ifdef \
USE_IRIDESCENCE\\n\tuniform float iridescence;\\n\tuniform float \
iridescenceIOR;\\n\tuniform float iridescenceThicknessMinimum;\\n\tuniform \
float iridescenceThicknessMaximum;\\n#endif\\n#ifdef USE_SHEEN\\n\tuniform \
vec3 sheenColor;\\n\tuniform float sheenRoughness;\\n\t#ifdef \
USE_SHEEN_COLORMAP\\n\t\tuniform sampler2D \
sheenColorMap;\\n\t#endif\\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\t\tuniform \
sampler2D sheenRoughnessMap;\\n\t#endif\\n#endif\\n#ifdef \
USE_ANISOTROPY\\n\tuniform vec2 anisotropyVector;\\n\t#ifdef \
USE_ANISOTROPYMAP\\n\t\tuniform sampler2D \
anisotropyMap;\\n\t#endif\\n#endif\\nvarying vec3 vViewPosition;\\n#include \
<common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include \
<color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include \
<map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include \
<alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include \
<aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include \
<emissivemap_pars_fragment>\\n#include <iridescence_fragment>\\n#include \
<cube_uv_reflection_fragment>\\n#include \
<envmap_common_pars_fragment>\\n#include \
<envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include \
<lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include \
<lights_physical_pars_fragment>\\n#include \
<transmission_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include \
<bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include \
<clearcoat_pars_fragment>\\n#include <iridescence_pars_fragment>\\n#include \
<roughnessmap_pars_fragment>\\n#include \
<metalnessmap_pars_fragment>\\n#include \
<logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid \
main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include \
<clipping_planes_fragment>\\n\tReflectedLight reflectedLight = \
ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) \
);\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include \
<logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include \
<color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include \
<alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include \
<roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include \
<normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\t#include \
<clearcoat_normal_fragment_begin>\\n\t#include \
<clearcoat_normal_fragment_maps>\\n\t#include \
<emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include \
<lights_fragment_begin>\\n\t#include <lights_fragment_maps>\\n\t#include \
<lights_fragment_end>\\n\t#include <aomap_fragment>\\n\tvec3 totalDiffuse = \
reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\tvec3 \
totalSpecular = reflectedLight.directSpecular + \
reflectedLight.indirectSpecular;\\n\t#include \
<transmission_fragment>\\n\tvec3 outgoingLight = totalDiffuse + totalSpecular \
+ totalEmissiveRadiance;\\n\t#ifdef USE_SHEEN\\n\t\tfloat sheenEnergyComp = \
1.0 - 0.157 * max3( material.sheenColor );\\n\t\toutgoingLight = \
outgoingLight * sheenEnergyComp + sheenSpecularDirect + \
sheenSpecularIndirect;\\n\t#endif\\n\t#ifdef USE_CLEARCOAT\\n\t\tfloat \
dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) \
);\\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, \
dotNVcc );\\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * \
Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * \
material.clearcoat;\\n\t#endif\\n\t#include <opaque_fragment>\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include \
<fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include \
<dithering_fragment>\\n}\";\nvar vertex$4 = \"#define TOON\\nvarying vec3 \
vViewPosition;\\n#include <common>\\n#include \
<batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include \
<displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include \
<fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include \
<morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include \
<shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include \
<clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include \
<uv_vertex>\\n\t#include <color_vertex>\\n\t#include \
<morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include \
<batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include \
<morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include \
<skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include \
<normal_vertex>\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include \
<logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition \
= - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include \
<shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar fragment$4 = \
\"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform \
float opacity;\\n#include <common>\\n#include <packing>\\n#include \
<dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include \
<uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include \
<alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include \
<alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include \
<lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include \
<gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include \
<bsdfs>\\n#include <lights_pars_begin>\\n#include \
<normal_pars_fragment>\\n#include <lights_toon_pars_fragment>\\n#include \
<shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include \
<normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include \
<clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( \
diffuse, opacity );\\n\t#include \
<clipping_planes_fragment>\\n\tReflectedLight reflectedLight = \
ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) \
);\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include \
<logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include \
<color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include \
<alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include \
<normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\t#include \
<emissivemap_fragment>\\n\t#include <lights_toon_fragment>\\n\t#include \
<lights_fragment_begin>\\n\t#include <lights_fragment_maps>\\n\t#include \
<lights_fragment_end>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = \
reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + \
totalEmissiveRadiance;\\n\t#include <opaque_fragment>\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include \
<fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include \
<dithering_fragment>\\n}\";\nvar vertex$3 = \"uniform float size;\\nuniform \
float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include \
<fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include \
<logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n#ifdef \
USE_POINTS_UV\\n\tvarying vec2 vUv;\\n\tuniform mat3 \
uvTransform;\\n#endif\\nvoid main() {\\n\t#ifdef USE_POINTS_UV\\n\t\tvUv = ( \
uvTransform * vec3( uv, 1 ) ).xy;\\n\t#endif\\n\t#include \
<color_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include \
<morphcolor_vertex>\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <project_vertex>\\n\tgl_PointSize = \
size;\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tbool isPerspective = \
isPerspectiveMatrix( projectionMatrix );\\n\t\tif ( isPerspective ) \
gl_PointSize *= ( scale / - mvPosition.z );\\n\t#endif\\n\t#include \
<logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include \
<worldpos_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar fragment$3 = \
\"uniform vec3 diffuse;\\nuniform float opacity;\\n#include \
<common>\\n#include <color_pars_fragment>\\n#include \
<map_particle_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include \
<alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include \
<logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid \
main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include \
<clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\t#include \
<logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include \
<color_fragment>\\n\t#include <alphatest_fragment>\\n\t#include \
<alphahash_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\t#include \
<opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include \
<colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include \
<premultiplied_alpha_fragment>\\n}\";\nvar vertex$2 = \"#include \
<common>\\n#include <batching_pars_vertex>\\n#include \
<fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include \
<skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include \
<shadowmap_pars_vertex>\\nvoid main() {\\n\t#include \
<batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include \
<morphinstance_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include \
<skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include \
<defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include \
<morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include \
<project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include \
<worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include \
<fog_vertex>\\n}\";\nvar fragment$2 = \"uniform vec3 color;\\nuniform float \
opacity;\\n#include <common>\\n#include <packing>\\n#include \
<fog_pars_fragment>\\n#include <bsdfs>\\n#include \
<lights_pars_begin>\\n#include <logdepthbuf_pars_fragment>\\n#include \
<shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() \
{\\n\t#include <logdepthbuf_fragment>\\n\tgl_FragColor = vec4( color, opacity \
* ( 1.0 - getShadowMask() ) );\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include \
<fog_fragment>\\n}\";\nvar vertex$1 = \"uniform float rotation;\\nuniform \
vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include \
<fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include \
<clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include \
<uv_vertex>\\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\\n\tvec2 scale = \
vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) \
);\\n\t#ifndef USE_SIZEATTENUATION\\n\t\tbool isPerspective = \
isPerspectiveMatrix( projectionMatrix );\\n\t\tif ( isPerspective ) scale *= \
- mvPosition.z;\\n\t#endif\\n\tvec2 alignedPosition = ( position.xy - ( \
center - vec2( 0.5 ) ) ) * scale;\\n\tvec2 \
rotatedPosition;\\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x \
- sin( rotation ) * alignedPosition.y;\\n\trotatedPosition.y = sin( rotation \
) * alignedPosition.x + cos( rotation ) * \
alignedPosition.y;\\n\tmvPosition.xy += rotatedPosition;\\n\tgl_Position = \
projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include \
<clipping_planes_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar fragment$1 = \
\"uniform vec3 diffuse;\\nuniform float opacity;\\n#include \
<common>\\n#include <uv_pars_fragment>\\n#include \
<map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include \
<alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include \
<fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include \
<clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( \
diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\tvec3 \
outgoingLight = vec3( 0.0 );\\n\t#include <logdepthbuf_fragment>\\n\t#include \
<map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include \
<alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\toutgoingLight = \
diffuseColor.rgb;\\n\t#include <opaque_fragment>\\n\t#include \
<tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include \
<fog_fragment>\\n}\";\nvar ShaderChunk = {\n  alphahash_fragment,\n  \
alphahash_pars_fragment,\n  alphamap_fragment,\n  alphamap_pars_fragment,\n  \
alphatest_fragment,\n  alphatest_pars_fragment,\n  aomap_fragment,\n  \
aomap_pars_fragment,\n  batching_pars_vertex,\n  batching_vertex,\n  \
begin_vertex,\n  beginnormal_vertex,\n  bsdfs,\n  iridescence_fragment,\n  \
bumpmap_pars_fragment,\n  clipping_planes_fragment,\n  \
clipping_planes_pars_fragment,\n  clipping_planes_pars_vertex,\n  \
clipping_planes_vertex,\n  color_fragment,\n  color_pars_fragment,\n  \
color_pars_vertex,\n  color_vertex,\n  common,\n  \
cube_uv_reflection_fragment,\n  defaultnormal_vertex,\n  \
displacementmap_pars_vertex,\n  displacementmap_vertex,\n  \
emissivemap_fragment,\n  emissivemap_pars_fragment,\n  colorspace_fragment,\n \
 colorspace_pars_fragment,\n  envmap_fragment,\n  \
envmap_common_pars_fragment,\n  envmap_pars_fragment,\n  \
envmap_pars_vertex,\n  envmap_physical_pars_fragment,\n  envmap_vertex,\n  \
fog_vertex,\n  fog_pars_vertex,\n  fog_fragment,\n  fog_pars_fragment,\n  \
gradientmap_pars_fragment,\n  lightmap_pars_fragment,\n  \
lights_lambert_fragment,\n  lights_lambert_pars_fragment,\n  \
lights_pars_begin,\n  lights_toon_fragment,\n  lights_toon_pars_fragment,\n  \
lights_phong_fragment,\n  lights_phong_pars_fragment,\n  \
lights_physical_fragment,\n  lights_physical_pars_fragment,\n  \
lights_fragment_begin,\n  lights_fragment_maps,\n  lights_fragment_end,\n  \
logdepthbuf_fragment,\n  logdepthbuf_pars_fragment,\n  \
logdepthbuf_pars_vertex,\n  logdepthbuf_vertex,\n  map_fragment,\n  \
map_pars_fragment,\n  map_particle_fragment,\n  map_particle_pars_fragment,\n \
 metalnessmap_fragment,\n  metalnessmap_pars_fragment,\n  \
morphinstance_vertex,\n  morphcolor_vertex,\n  morphnormal_vertex,\n  \
morphtarget_pars_vertex,\n  morphtarget_vertex,\n  normal_fragment_begin,\n  \
normal_fragment_maps,\n  normal_pars_fragment,\n  normal_pars_vertex,\n  \
normal_vertex,\n  normalmap_pars_fragment,\n  \
clearcoat_normal_fragment_begin,\n  clearcoat_normal_fragment_maps,\n  \
clearcoat_pars_fragment,\n  iridescence_pars_fragment,\n  opaque_fragment,\n  \
packing,\n  premultiplied_alpha_fragment,\n  project_vertex,\n  \
dithering_fragment,\n  dithering_pars_fragment,\n  roughnessmap_fragment,\n  \
roughnessmap_pars_fragment,\n  shadowmap_pars_fragment,\n  \
shadowmap_pars_vertex,\n  shadowmap_vertex,\n  shadowmask_pars_fragment,\n  \
skinbase_vertex,\n  skinning_pars_vertex,\n  skinning_vertex,\n  \
skinnormal_vertex,\n  specularmap_fragment,\n  specularmap_pars_fragment,\n  \
tonemapping_fragment,\n  tonemapping_pars_fragment,\n  \
transmission_fragment,\n  transmission_pars_fragment,\n  uv_pars_fragment,\n  \
uv_pars_vertex,\n  uv_vertex,\n  worldpos_vertex,\n  background_vert: \
vertex$h,\n  background_frag: fragment$h,\n  backgroundCube_vert: vertex$g,\n \
 backgroundCube_frag: fragment$g,\n  cube_vert: vertex$f,\n  cube_frag: \
fragment$f,\n  depth_vert: vertex$e,\n  depth_frag: fragment$e,\n  \
distanceRGBA_vert: vertex$d,\n  distanceRGBA_frag: fragment$d,\n  \
equirect_vert: vertex$c,\n  equirect_frag: fragment$c,\n  linedashed_vert: \
vertex$b,\n  linedashed_frag: fragment$b,\n  meshbasic_vert: vertex$a,\n  \
meshbasic_frag: fragment$a,\n  meshlambert_vert: vertex$9,\n  \
meshlambert_frag: fragment$9,\n  meshmatcap_vert: vertex$8,\n  \
meshmatcap_frag: fragment$8,\n  meshnormal_vert: vertex$7,\n  \
meshnormal_frag: fragment$7,\n  meshphong_vert: vertex$6,\n  meshphong_frag: \
fragment$6,\n  meshphysical_vert: vertex$5,\n  meshphysical_frag: \
fragment$5,\n  meshtoon_vert: vertex$4,\n  meshtoon_frag: fragment$4,\n  \
points_vert: vertex$3,\n  points_frag: fragment$3,\n  shadow_vert: \
vertex$2,\n  shadow_frag: fragment$2,\n  sprite_vert: vertex$1,\n  \
sprite_frag: fragment$1\n};\nvar UniformsLib = {\n  common: {\n    diffuse: { \
value: /* @__PURE__ */ new Color(16777215) },\n    opacity: { value: 1 },\n   \
 map: { value: null },\n    mapTransform: { value: /* @__PURE__ */ new \
Matrix3() },\n    alphaMap: { value: null },\n    alphaMapTransform: { value: \
/* @__PURE__ */ new Matrix3() },\n    alphaTest: { value: 0 }\n  },\n  \
specularmap: {\n    specularMap: { value: null },\n    specularMapTransform: \
{ value: /* @__PURE__ */ new Matrix3() }\n  },\n  envmap: {\n    envMap: { \
value: null },\n    envMapRotation: { value: /* @__PURE__ */ new Matrix3() \
},\n    flipEnvMap: { value: -1 },\n    reflectivity: { value: 1 },\n    // \
basic, lambert, phong\n    ior: { value: 1.5 },\n    // physical\n    \
refractionRatio: { value: 0.98 }\n    // basic, lambert, phong\n  },\n  \
aomap: {\n    aoMap: { value: null },\n    aoMapIntensity: { value: 1 },\n    \
aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }\n  },\n  lightmap: \
{\n    lightMap: { value: null },\n    lightMapIntensity: { value: 1 },\n    \
lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }\n  },\n  bumpmap: \
{\n    bumpMap: { value: null },\n    bumpMapTransform: { value: /* @__PURE__ \
*/ new Matrix3() },\n    bumpScale: { value: 1 }\n  },\n  normalmap: {\n    \
normalMap: { value: null },\n    normalMapTransform: { value: /* @__PURE__ */ \
new Matrix3() },\n    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) \
}\n  },\n  displacementmap: {\n    displacementMap: { value: null },\n    \
displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    \
displacementScale: { value: 1 },\n    displacementBias: { value: 0 }\n  },\n  \
emissivemap: {\n    emissiveMap: { value: null },\n    emissiveMapTransform: \
{ value: /* @__PURE__ */ new Matrix3() }\n  },\n  metalnessmap: {\n    \
metalnessMap: { value: null },\n    metalnessMapTransform: { value: /* \
@__PURE__ */ new Matrix3() }\n  },\n  roughnessmap: {\n    roughnessMap: { \
value: null },\n    roughnessMapTransform: { value: /* @__PURE__ */ new \
Matrix3() }\n  },\n  gradientmap: {\n    gradientMap: { value: null }\n  },\n \
 fog: {\n    fogDensity: { value: 25e-5 },\n    fogNear: { value: 1 },\n    \
fogFar: { value: 2e3 },\n    fogColor: { value: /* @__PURE__ */ new \
Color(16777215) }\n  },\n  lights: {\n    ambientLightColor: { value: [] },\n \
   lightProbe: { value: [] },\n    directionalLights: { value: [], \
properties: {\n      direction: {},\n      color: {}\n    } },\n    \
directionalLightShadows: { value: [], properties: {\n      shadowIntensity: \
1,\n      shadowBias: {},\n      shadowNormalBias: {},\n      shadowRadius: \
{},\n      shadowMapSize: {}\n    } },\n    directionalShadowMap: { value: [] \
},\n    directionalShadowMatrix: { value: [] },\n    spotLights: { value: [], \
properties: {\n      color: {},\n      position: {},\n      direction: {},\n  \
    distance: {},\n      coneCos: {},\n      penumbraCos: {},\n      decay: \
{}\n    } },\n    spotLightShadows: { value: [], properties: {\n      \
shadowIntensity: 1,\n      shadowBias: {},\n      shadowNormalBias: {},\n     \
 shadowRadius: {},\n      shadowMapSize: {}\n    } },\n    spotLightMap: { \
value: [] },\n    spotShadowMap: { value: [] },\n    spotLightMatrix: { \
value: [] },\n    pointLights: { value: [], properties: {\n      color: {},\n \
     position: {},\n      decay: {},\n      distance: {}\n    } },\n    \
pointLightShadows: { value: [], properties: {\n      shadowIntensity: 1,\n    \
  shadowBias: {},\n      shadowNormalBias: {},\n      shadowRadius: {},\n     \
 shadowMapSize: {},\n      shadowCameraNear: {},\n      shadowCameraFar: {}\n \
   } },\n    pointShadowMap: { value: [] },\n    pointShadowMatrix: { value: \
[] },\n    hemisphereLights: { value: [], properties: {\n      direction: \
{},\n      skyColor: {},\n      groundColor: {}\n    } },\n    // TODO \
(abelnation): RectAreaLight BRDF data needs to be moved from example to main \
src\n    rectAreaLights: { value: [], properties: {\n      color: {},\n      \
position: {},\n      width: {},\n      height: {}\n    } },\n    ltc_1: { \
value: null },\n    ltc_2: { value: null }\n  },\n  points: {\n    diffuse: { \
value: /* @__PURE__ */ new Color(16777215) },\n    opacity: { value: 1 },\n   \
 size: { value: 1 },\n    scale: { value: 1 },\n    map: { value: null },\n   \
 alphaMap: { value: null },\n    alphaMapTransform: { value: /* @__PURE__ */ \
new Matrix3() },\n    alphaTest: { value: 0 },\n    uvTransform: { value: /* \
@__PURE__ */ new Matrix3() }\n  },\n  sprite: {\n    diffuse: { value: /* \
@__PURE__ */ new Color(16777215) },\n    opacity: { value: 1 },\n    center: \
{ value: /* @__PURE__ */ new Vector2(0.5, 0.5) },\n    rotation: { value: 0 \
},\n    map: { value: null },\n    mapTransform: { value: /* @__PURE__ */ new \
Matrix3() },\n    alphaMap: { value: null },\n    alphaMapTransform: { value: \
/* @__PURE__ */ new Matrix3() },\n    alphaTest: { value: 0 }\n  }\n};\nvar \
ShaderLib = {\n  basic: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n    \
  UniformsLib.common,\n      UniformsLib.specularmap,\n      \
UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n  \
    UniformsLib.fog\n    ]),\n    vertexShader: ShaderChunk.meshbasic_vert,\n \
   fragmentShader: ShaderChunk.meshbasic_frag\n  },\n  lambert: {\n    \
uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      \
UniformsLib.specularmap,\n      UniformsLib.envmap,\n      \
UniformsLib.aomap,\n      UniformsLib.lightmap,\n      \
UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      \
UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      \
UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { \
value: /* @__PURE__ */ new Color(0) }\n      }\n    ]),\n    vertexShader: \
ShaderChunk.meshlambert_vert,\n    fragmentShader: \
ShaderChunk.meshlambert_frag\n  },\n  phong: {\n    uniforms: /* @__PURE__ */ \
mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n  \
    UniformsLib.envmap,\n      UniformsLib.aomap,\n      \
UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      \
UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      \
UniformsLib.displacementmap,\n      UniformsLib.fog,\n      \
UniformsLib.lights,\n      {\n        emissive: { value: /* @__PURE__ */ new \
Color(0) },\n        specular: { value: /* @__PURE__ */ new Color(1118481) \
},\n        shininess: { value: 30 }\n      }\n    ]),\n    vertexShader: \
ShaderChunk.meshphong_vert,\n    fragmentShader: ShaderChunk.meshphong_frag\n \
 },\n  standard: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      \
UniformsLib.common,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n    \
  UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      \
UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      \
UniformsLib.displacementmap,\n      UniformsLib.roughnessmap,\n      \
UniformsLib.metalnessmap,\n      UniformsLib.fog,\n      \
UniformsLib.lights,\n      {\n        emissive: { value: /* @__PURE__ */ new \
Color(0) },\n        roughness: { value: 1 },\n        metalness: { value: 0 \
},\n        envMapIntensity: { value: 1 }\n      }\n    ]),\n    \
vertexShader: ShaderChunk.meshphysical_vert,\n    fragmentShader: \
ShaderChunk.meshphysical_frag\n  },\n  toon: {\n    uniforms: /* @__PURE__ */ \
mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.aomap,\n      \
UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      \
UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      \
UniformsLib.displacementmap,\n      UniformsLib.gradientmap,\n      \
UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { \
value: /* @__PURE__ */ new Color(0) }\n      }\n    ]),\n    vertexShader: \
ShaderChunk.meshtoon_vert,\n    fragmentShader: ShaderChunk.meshtoon_frag\n  \
},\n  matcap: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      \
UniformsLib.common,\n      UniformsLib.bumpmap,\n      \
UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      \
UniformsLib.fog,\n      {\n        matcap: { value: null }\n      }\n    \
]),\n    vertexShader: ShaderChunk.meshmatcap_vert,\n    fragmentShader: \
ShaderChunk.meshmatcap_frag\n  },\n  points: {\n    uniforms: /* @__PURE__ */ \
mergeUniforms([\n      UniformsLib.points,\n      UniformsLib.fog\n    ]),\n  \
  vertexShader: ShaderChunk.points_vert,\n    fragmentShader: \
ShaderChunk.points_frag\n  },\n  dashed: {\n    uniforms: /* @__PURE__ */ \
mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.fog,\n      {\n \
       scale: { value: 1 },\n        dashSize: { value: 1 },\n        \
totalSize: { value: 2 }\n      }\n    ]),\n    vertexShader: \
ShaderChunk.linedashed_vert,\n    fragmentShader: \
ShaderChunk.linedashed_frag\n  },\n  depth: {\n    uniforms: /* @__PURE__ */ \
mergeUniforms([\n      UniformsLib.common,\n      \
UniformsLib.displacementmap\n    ]),\n    vertexShader: \
ShaderChunk.depth_vert,\n    fragmentShader: ShaderChunk.depth_frag\n  },\n  \
normal: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      \
UniformsLib.common,\n      UniformsLib.bumpmap,\n      \
UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      {\n        \
opacity: { value: 1 }\n      }\n    ]),\n    vertexShader: \
ShaderChunk.meshnormal_vert,\n    fragmentShader: \
ShaderChunk.meshnormal_frag\n  },\n  sprite: {\n    uniforms: /* @__PURE__ */ \
mergeUniforms([\n      UniformsLib.sprite,\n      UniformsLib.fog\n    ]),\n  \
  vertexShader: ShaderChunk.sprite_vert,\n    fragmentShader: \
ShaderChunk.sprite_frag\n  },\n  background: {\n    uniforms: {\n      \
uvTransform: { value: /* @__PURE__ */ new Matrix3() },\n      t2D: { value: \
null },\n      backgroundIntensity: { value: 1 }\n    },\n    vertexShader: \
ShaderChunk.background_vert,\n    fragmentShader: \
ShaderChunk.background_frag\n  },\n  backgroundCube: {\n    uniforms: {\n     \
 envMap: { value: null },\n      flipEnvMap: { value: -1 },\n      \
backgroundBlurriness: { value: 0 },\n      backgroundIntensity: { value: 1 \
},\n      backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }\n    \
},\n    vertexShader: ShaderChunk.backgroundCube_vert,\n    fragmentShader: \
ShaderChunk.backgroundCube_frag\n  },\n  cube: {\n    uniforms: {\n      \
tCube: { value: null },\n      tFlip: { value: -1 },\n      opacity: { value: \
1 }\n    },\n    vertexShader: ShaderChunk.cube_vert,\n    fragmentShader: \
ShaderChunk.cube_frag\n  },\n  equirect: {\n    uniforms: {\n      tEquirect: \
{ value: null }\n    },\n    vertexShader: ShaderChunk.equirect_vert,\n    \
fragmentShader: ShaderChunk.equirect_frag\n  },\n  distanceRGBA: {\n    \
uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      \
UniformsLib.displacementmap,\n      {\n        referencePosition: { value: /* \
@__PURE__ */ new Vector3() },\n        nearDistance: { value: 1 },\n        \
farDistance: { value: 1e3 }\n      }\n    ]),\n    vertexShader: \
ShaderChunk.distanceRGBA_vert,\n    fragmentShader: \
ShaderChunk.distanceRGBA_frag\n  },\n  shadow: {\n    uniforms: /* @__PURE__ \
*/ mergeUniforms([\n      UniformsLib.lights,\n      UniformsLib.fog,\n      \
{\n        color: { value: /* @__PURE__ */ new Color(0) },\n        opacity: \
{ value: 1 }\n      }\n    ]),\n    vertexShader: ShaderChunk.shadow_vert,\n  \
  fragmentShader: ShaderChunk.shadow_frag\n  }\n};\nShaderLib.physical = {\n  \
uniforms: /* @__PURE__ */ mergeUniforms([\n    ShaderLib.standard.uniforms,\n \
   {\n      clearcoat: { value: 0 },\n      clearcoatMap: { value: null },\n  \
    clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      \
clearcoatNormalMap: { value: null },\n      clearcoatNormalMapTransform: { \
value: /* @__PURE__ */ new Matrix3() },\n      clearcoatNormalScale: { value: \
/* @__PURE__ */ new Vector2(1, 1) },\n      clearcoatRoughness: { value: 0 \
},\n      clearcoatRoughnessMap: { value: null },\n      \
clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n   \
   dispersion: { value: 0 },\n      iridescence: { value: 0 },\n      \
iridescenceMap: { value: null },\n      iridescenceMapTransform: { value: /* \
@__PURE__ */ new Matrix3() },\n      iridescenceIOR: { value: 1.3 },\n      \
iridescenceThicknessMinimum: { value: 100 },\n      \
iridescenceThicknessMaximum: { value: 400 },\n      iridescenceThicknessMap: \
{ value: null },\n      iridescenceThicknessMapTransform: { value: /* \
@__PURE__ */ new Matrix3() },\n      sheen: { value: 0 },\n      sheenColor: \
{ value: /* @__PURE__ */ new Color(0) },\n      sheenColorMap: { value: null \
},\n      sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n \
     sheenRoughness: { value: 1 },\n      sheenRoughnessMap: { value: null \
},\n      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() \
},\n      transmission: { value: 0 },\n      transmissionMap: { value: null \
},\n      transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() \
},\n      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() \
},\n      transmissionSamplerMap: { value: null },\n      thickness: { value: \
0 },\n      thicknessMap: { value: null },\n      thicknessMapTransform: { \
value: /* @__PURE__ */ new Matrix3() },\n      attenuationDistance: { value: \
0 },\n      attenuationColor: { value: /* @__PURE__ */ new Color(0) },\n      \
specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },\n      \
specularColorMap: { value: null },\n      specularColorMapTransform: { value: \
/* @__PURE__ */ new Matrix3() },\n      specularIntensity: { value: 1 },\n    \
  specularIntensityMap: { value: null },\n      \
specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    \
  anisotropyVector: { value: /* @__PURE__ */ new Vector2() },\n      \
anisotropyMap: { value: null },\n      anisotropyMapTransform: { value: /* \
@__PURE__ */ new Matrix3() }\n    }\n  ]),\n  vertexShader: \
ShaderChunk.meshphysical_vert,\n  fragmentShader: \
ShaderChunk.meshphysical_frag\n};\nvar _rgb = { r: 0, b: 0, g: 0 };\nvar \
_e1$1 = /* @__PURE__ */ new Euler();\nvar _m1$1 = /* @__PURE__ */ new \
Matrix4();\nfunction WebGLBackground(renderer3, cubemaps, cubeuvmaps, state, \
objects, alpha, premultipliedAlpha) {\n  const clearColor = new Color(0);\n  \
let clearAlpha = alpha === true ? 0 : 1;\n  let planeMesh;\n  let boxMesh;\n  \
let currentBackground = null;\n  let currentBackgroundVersion = 0;\n  let \
currentTonemapping = null;\n  function getBackground(scene3) {\n    let \
background = scene3.isScene === true ? scene3.background : null;\n    if \
(background && background.isTexture) {\n      const usePMREM = \
scene3.backgroundBlurriness > 0;\n      background = (usePMREM ? cubeuvmaps : \
cubemaps).get(background);\n    }\n    return background;\n  }\n  function \
render(scene3) {\n    let forceClear = false;\n    const background = \
getBackground(scene3);\n    if (background === null) {\n      \
setClear(clearColor, clearAlpha);\n    } else if (background && \
background.isColor) {\n      setClear(background, 1);\n      forceClear = \
true;\n    }\n    const environmentBlendMode = \
renderer3.xr.getEnvironmentBlendMode();\n    if (environmentBlendMode === \
\"additive\") {\n      state.buffers.color.setClear(0, 0, 0, 1, \
premultipliedAlpha);\n    } else if (environmentBlendMode === \
\"alpha-blend\") {\n      state.buffers.color.setClear(0, 0, 0, 0, \
premultipliedAlpha);\n    }\n    if (renderer3.autoClear || forceClear) {\n   \
   state.buffers.depth.setTest(true);\n      \
state.buffers.depth.setMask(true);\n      \
state.buffers.color.setMask(true);\n      \
renderer3.clear(renderer3.autoClearColor, renderer3.autoClearDepth, \
renderer3.autoClearStencil);\n    }\n  }\n  function \
addToRenderList(renderList, scene3) {\n    const background = \
getBackground(scene3);\n    if (background && (background.isCubeTexture || \
background.mapping === CubeUVReflectionMapping)) {\n      if (boxMesh === \
void 0) {\n        boxMesh = new Mesh(\n          new BoxGeometry(1, 1, 1),\n \
         new ShaderMaterial({\n            name: \
\"BackgroundCubeMaterial\",\n            uniforms: \
cloneUniforms(ShaderLib.backgroundCube.uniforms),\n            vertexShader: \
ShaderLib.backgroundCube.vertexShader,\n            fragmentShader: \
ShaderLib.backgroundCube.fragmentShader,\n            side: BackSide,\n       \
     depthTest: false,\n            depthWrite: false,\n            fog: \
false\n          })\n        );\n        \
boxMesh.geometry.deleteAttribute(\"normal\");\n        \
boxMesh.geometry.deleteAttribute(\"uv\");\n        boxMesh.onBeforeRender = \
function(renderer4, scene4, camera3) {\n          \
this.matrixWorld.copyPosition(camera3.matrixWorld);\n        };\n        \
Object.defineProperty(boxMesh.material, \"envMap\", {\n          get: \
function() {\n            return this.uniforms.envMap.value;\n          }\n   \
     });\n        objects.update(boxMesh);\n      }\n      \
_e1$1.copy(scene3.backgroundRotation);\n      _e1$1.x *= -1;\n      _e1$1.y \
*= -1;\n      _e1$1.z *= -1;\n      if (background.isCubeTexture && \
background.isRenderTargetTexture === false) {\n        _e1$1.y *= -1;\n       \
 _e1$1.z *= -1;\n      }\n      boxMesh.material.uniforms.envMap.value = \
background;\n      boxMesh.material.uniforms.flipEnvMap.value = \
background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : \
1;\n      boxMesh.material.uniforms.backgroundBlurriness.value = \
scene3.backgroundBlurriness;\n      \
boxMesh.material.uniforms.backgroundIntensity.value = \
scene3.backgroundIntensity;\n      \
boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeR\
otationFromEuler(_e1$1));\n      boxMesh.material.toneMapped = \
ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;\n      \
if (currentBackground !== background || currentBackgroundVersion !== \
background.version || currentTonemapping !== renderer3.toneMapping) {\n       \
 boxMesh.material.needsUpdate = true;\n        currentBackground = \
background;\n        currentBackgroundVersion = background.version;\n        \
currentTonemapping = renderer3.toneMapping;\n      }\n      \
boxMesh.layers.enableAll();\n      renderList.unshift(boxMesh, \
boxMesh.geometry, boxMesh.material, 0, 0, null);\n    } else if (background \
&& background.isTexture) {\n      if (planeMesh === void 0) {\n        \
planeMesh = new Mesh(\n          new PlaneGeometry(2, 2),\n          new \
ShaderMaterial({\n            name: \"BackgroundMaterial\",\n            \
uniforms: cloneUniforms(ShaderLib.background.uniforms),\n            \
vertexShader: ShaderLib.background.vertexShader,\n            fragmentShader: \
ShaderLib.background.fragmentShader,\n            side: FrontSide,\n          \
  depthTest: false,\n            depthWrite: false,\n            fog: false\n \
         })\n        );\n        \
planeMesh.geometry.deleteAttribute(\"normal\");\n        \
Object.defineProperty(planeMesh.material, \"map\", {\n          get: \
function() {\n            return this.uniforms.t2D.value;\n          }\n      \
  });\n        objects.update(planeMesh);\n      }\n      \
planeMesh.material.uniforms.t2D.value = background;\n      \
planeMesh.material.uniforms.backgroundIntensity.value = \
scene3.backgroundIntensity;\n      planeMesh.material.toneMapped = \
ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;\n      \
if (background.matrixAutoUpdate === true) {\n        \
background.updateMatrix();\n      }\n      \
planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n      \
if (currentBackground !== background || currentBackgroundVersion !== \
background.version || currentTonemapping !== renderer3.toneMapping) {\n       \
 planeMesh.material.needsUpdate = true;\n        currentBackground = \
background;\n        currentBackgroundVersion = background.version;\n        \
currentTonemapping = renderer3.toneMapping;\n      }\n      \
planeMesh.layers.enableAll();\n      renderList.unshift(planeMesh, \
planeMesh.geometry, planeMesh.material, 0, 0, null);\n    }\n  }\n  function \
setClear(color2, alpha2) {\n    color2.getRGB(_rgb, \
getUnlitUniformColorSpace(renderer3));\n    \
state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, \
premultipliedAlpha);\n  }\n  return {\n    getClearColor: function() {\n      \
return clearColor;\n    },\n    setClearColor: function(color2, alpha2 = 1) \
{\n      clearColor.set(color2);\n      clearAlpha = alpha2;\n      \
setClear(clearColor, clearAlpha);\n    },\n    getClearAlpha: function() {\n  \
    return clearAlpha;\n    },\n    setClearAlpha: function(alpha2) {\n      \
clearAlpha = alpha2;\n      setClear(clearColor, clearAlpha);\n    },\n    \
render,\n    addToRenderList\n  };\n}\nfunction WebGLBindingStates(gl, \
attributes) {\n  const maxVertexAttributes = \
gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  const bindingStates = {};\n  const \
defaultState = createBindingState(null);\n  let currentState = \
defaultState;\n  let forceUpdate = false;\n  function setup(object, material, \
program, geometry, index5) {\n    let updateBuffers = false;\n    const state \
= getBindingState(geometry, program, material);\n    if (currentState !== \
state) {\n      currentState = state;\n      \
bindVertexArrayObject(currentState.object);\n    }\n    updateBuffers = \
needsUpdate(object, geometry, program, index5);\n    if (updateBuffers) \
saveCache(object, geometry, program, index5);\n    if (index5 !== null) {\n   \
   attributes.update(index5, gl.ELEMENT_ARRAY_BUFFER);\n    }\n    if \
(updateBuffers || forceUpdate) {\n      forceUpdate = false;\n      \
setupVertexAttributes(object, material, program, geometry);\n      if (index5 \
!== null) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, \
attributes.get(index5).buffer);\n      }\n    }\n  }\n  function \
createVertexArrayObject() {\n    return gl.createVertexArray();\n  }\n  \
function bindVertexArrayObject(vao) {\n    return gl.bindVertexArray(vao);\n  \
}\n  function deleteVertexArrayObject(vao) {\n    return \
gl.deleteVertexArray(vao);\n  }\n  function getBindingState(geometry, \
program, material) {\n    const wireframe = material.wireframe === true;\n    \
let programMap = bindingStates[geometry.id];\n    if (programMap === void 0) \
{\n      programMap = {};\n      bindingStates[geometry.id] = programMap;\n   \
 }\n    let stateMap = programMap[program.id];\n    if (stateMap === void 0) \
{\n      stateMap = {};\n      programMap[program.id] = stateMap;\n    }\n    \
let state = stateMap[wireframe];\n    if (state === void 0) {\n      state = \
createBindingState(createVertexArrayObject());\n      stateMap[wireframe] = \
state;\n    }\n    return state;\n  }\n  function createBindingState(vao) {\n \
   const newAttributes = [];\n    const enabledAttributes = [];\n    const \
attributeDivisors = [];\n    for (let i = 0; i < maxVertexAttributes; i++) \
{\n      newAttributes[i] = 0;\n      enabledAttributes[i] = 0;\n      \
attributeDivisors[i] = 0;\n    }\n    return {\n      // for backward \
compatibility on non-VAO support browser\n      geometry: null,\n      \
program: null,\n      wireframe: false,\n      newAttributes,\n      \
enabledAttributes,\n      attributeDivisors,\n      object: vao,\n      \
attributes: {},\n      index: null\n    };\n  }\n  function \
needsUpdate(object, geometry, program, index5) {\n    const cachedAttributes \
= currentState.attributes;\n    const geometryAttributes = \
geometry.attributes;\n    let attributesNum = 0;\n    const programAttributes \
= program.getAttributes();\n    for (const name in programAttributes) {\n     \
 const programAttribute = programAttributes[name];\n      if \
(programAttribute.location >= 0) {\n        const cachedAttribute = \
cachedAttributes[name];\n        let geometryAttribute = \
geometryAttributes[name];\n        if (geometryAttribute === void 0) {\n      \
    if (name === \"instanceMatrix\" && object.instanceMatrix) \
geometryAttribute = object.instanceMatrix;\n          if (name === \
\"instanceColor\" && object.instanceColor) geometryAttribute = \
object.instanceColor;\n        }\n        if (cachedAttribute === void 0) \
return true;\n        if (cachedAttribute.attribute !== geometryAttribute) \
return true;\n        if (geometryAttribute && cachedAttribute.data !== \
geometryAttribute.data) return true;\n        attributesNum++;\n      }\n    \
}\n    if (currentState.attributesNum !== attributesNum) return true;\n    if \
(currentState.index !== index5) return true;\n    return false;\n  }\n  \
function saveCache(object, geometry, program, index5) {\n    const cache2 = \
{};\n    const attributes2 = geometry.attributes;\n    let attributesNum = \
0;\n    const programAttributes = program.getAttributes();\n    for (const \
name in programAttributes) {\n      const programAttribute = \
programAttributes[name];\n      if (programAttribute.location >= 0) {\n       \
 let attribute2 = attributes2[name];\n        if (attribute2 === void 0) {\n  \
        if (name === \"instanceMatrix\" && object.instanceMatrix) attribute2 \
= object.instanceMatrix;\n          if (name === \"instanceColor\" && \
object.instanceColor) attribute2 = object.instanceColor;\n        }\n        \
const data = {};\n        data.attribute = attribute2;\n        if \
(attribute2 && attribute2.data) {\n          data.data = attribute2.data;\n   \
     }\n        cache2[name] = data;\n        attributesNum++;\n      }\n    \
}\n    currentState.attributes = cache2;\n    currentState.attributesNum = \
attributesNum;\n    currentState.index = index5;\n  }\n  function \
initAttributes() {\n    const newAttributes = currentState.newAttributes;\n   \
 for (let i = 0, il = newAttributes.length; i < il; i++) {\n      \
newAttributes[i] = 0;\n    }\n  }\n  function enableAttribute(attribute2) {\n \
   enableAttributeAndDivisor(attribute2, 0);\n  }\n  function \
enableAttributeAndDivisor(attribute2, meshPerAttribute) {\n    const \
newAttributes = currentState.newAttributes;\n    const enabledAttributes = \
currentState.enabledAttributes;\n    const attributeDivisors = \
currentState.attributeDivisors;\n    newAttributes[attribute2] = 1;\n    if \
(enabledAttributes[attribute2] === 0) {\n      \
gl.enableVertexAttribArray(attribute2);\n      enabledAttributes[attribute2] \
= 1;\n    }\n    if (attributeDivisors[attribute2] !== meshPerAttribute) {\n  \
    gl.vertexAttribDivisor(attribute2, meshPerAttribute);\n      \
attributeDivisors[attribute2] = meshPerAttribute;\n    }\n  }\n  function \
disableUnusedAttributes() {\n    const newAttributes = \
currentState.newAttributes;\n    const enabledAttributes = \
currentState.enabledAttributes;\n    for (let i = 0, il = \
enabledAttributes.length; i < il; i++) {\n      if (enabledAttributes[i] !== \
newAttributes[i]) {\n        gl.disableVertexAttribArray(i);\n        \
enabledAttributes[i] = 0;\n      }\n    }\n  }\n  function \
vertexAttribPointer(index5, size, type, normalized, stride, offset, integer) \
{\n    if (integer === true) {\n      gl.vertexAttribIPointer(index5, size, \
type, stride, offset);\n    } else {\n      gl.vertexAttribPointer(index5, \
size, type, normalized, stride, offset);\n    }\n  }\n  function \
setupVertexAttributes(object, material, program, geometry) {\n    \
initAttributes();\n    const geometryAttributes = geometry.attributes;\n    \
const programAttributes = program.getAttributes();\n    const \
materialDefaultAttributeValues = material.defaultAttributeValues;\n    for \
(const name in programAttributes) {\n      const programAttribute = \
programAttributes[name];\n      if (programAttribute.location >= 0) {\n       \
 let geometryAttribute = geometryAttributes[name];\n        if \
(geometryAttribute === void 0) {\n          if (name === \"instanceMatrix\" \
&& object.instanceMatrix) geometryAttribute = object.instanceMatrix;\n        \
  if (name === \"instanceColor\" && object.instanceColor) geometryAttribute = \
object.instanceColor;\n        }\n        if (geometryAttribute !== void 0) \
{\n          const normalized = geometryAttribute.normalized;\n          \
const size = geometryAttribute.itemSize;\n          const attribute2 = \
attributes.get(geometryAttribute);\n          if (attribute2 === void 0) \
continue;\n          const buffer2 = attribute2.buffer;\n          const type \
= attribute2.type;\n          const bytesPerElement = \
attribute2.bytesPerElement;\n          const integer = type === gl.INT || \
type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;\n          \
if (geometryAttribute.isInterleavedBufferAttribute) {\n            const data \
= geometryAttribute.data;\n            const stride = data.stride;\n          \
  const offset = geometryAttribute.offset;\n            if \
(data.isInstancedInterleavedBuffer) {\n              for (let i = 0; i < \
programAttribute.locationSize; i++) {\n                \
enableAttributeAndDivisor(programAttribute.location + i, \
data.meshPerAttribute);\n              }\n              if \
(object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) \
{\n                geometry._maxInstanceCount = data.meshPerAttribute * \
data.count;\n              }\n            } else {\n              for (let i \
= 0; i < programAttribute.locationSize; i++) {\n                \
enableAttribute(programAttribute.location + i);\n              }\n            \
}\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);\n            for (let \
i = 0; i < programAttribute.locationSize; i++) {\n              \
vertexAttribPointer(\n                programAttribute.location + i,\n        \
        size / programAttribute.locationSize,\n                type,\n        \
        normalized,\n                stride * bytesPerElement,\n              \
  (offset + size / programAttribute.locationSize * i) * bytesPerElement,\n    \
            integer\n              );\n            }\n          } else {\n    \
        if (geometryAttribute.isInstancedBufferAttribute) {\n              \
for (let i = 0; i < programAttribute.locationSize; i++) {\n                \
enableAttributeAndDivisor(programAttribute.location + i, \
geometryAttribute.meshPerAttribute);\n              }\n              if \
(object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) \
{\n                geometry._maxInstanceCount = \
geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              \
}\n            } else {\n              for (let i = 0; i < \
programAttribute.locationSize; i++) {\n                \
enableAttribute(programAttribute.location + i);\n              }\n            \
}\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);\n            for (let \
i = 0; i < programAttribute.locationSize; i++) {\n              \
vertexAttribPointer(\n                programAttribute.location + i,\n        \
        size / programAttribute.locationSize,\n                type,\n        \
        normalized,\n                size * bytesPerElement,\n                \
size / programAttribute.locationSize * i * bytesPerElement,\n                \
integer\n              );\n            }\n          }\n        } else if \
(materialDefaultAttributeValues !== void 0) {\n          const value = \
materialDefaultAttributeValues[name];\n          if (value !== void 0) {\n    \
        switch (value.length) {\n              case 2:\n                \
gl.vertexAttrib2fv(programAttribute.location, value);\n                \
break;\n              case 3:\n                \
gl.vertexAttrib3fv(programAttribute.location, value);\n                \
break;\n              case 4:\n                \
gl.vertexAttrib4fv(programAttribute.location, value);\n                \
break;\n              default:\n                \
gl.vertexAttrib1fv(programAttribute.location, value);\n            }\n        \
  }\n        }\n      }\n    }\n    disableUnusedAttributes();\n  }\n  \
function dispose() {\n    reset();\n    for (const geometryId in \
bindingStates) {\n      const programMap = bindingStates[geometryId];\n      \
for (const programId in programMap) {\n        const stateMap = \
programMap[programId];\n        for (const wireframe in stateMap) {\n         \
 deleteVertexArrayObject(stateMap[wireframe].object);\n          delete \
stateMap[wireframe];\n        }\n        delete programMap[programId];\n      \
}\n      delete bindingStates[geometryId];\n    }\n  }\n  function \
releaseStatesOfGeometry(geometry) {\n    if (bindingStates[geometry.id] === \
void 0) return;\n    const programMap = bindingStates[geometry.id];\n    for \
(const programId in programMap) {\n      const stateMap = \
programMap[programId];\n      for (const wireframe in stateMap) {\n        \
deleteVertexArrayObject(stateMap[wireframe].object);\n        delete \
stateMap[wireframe];\n      }\n      delete programMap[programId];\n    }\n   \
 delete bindingStates[geometry.id];\n  }\n  function \
releaseStatesOfProgram(program) {\n    for (const geometryId in \
bindingStates) {\n      const programMap = bindingStates[geometryId];\n      \
if (programMap[program.id] === void 0) continue;\n      const stateMap = \
programMap[program.id];\n      for (const wireframe in stateMap) {\n        \
deleteVertexArrayObject(stateMap[wireframe].object);\n        delete \
stateMap[wireframe];\n      }\n      delete programMap[program.id];\n    }\n  \
}\n  function reset() {\n    resetDefaultState();\n    forceUpdate = true;\n  \
  if (currentState === defaultState) return;\n    currentState = \
defaultState;\n    bindVertexArrayObject(currentState.object);\n  }\n  \
function resetDefaultState() {\n    defaultState.geometry = null;\n    \
defaultState.program = null;\n    defaultState.wireframe = false;\n  }\n  \
return {\n    setup,\n    reset,\n    resetDefaultState,\n    dispose,\n    \
releaseStatesOfGeometry,\n    releaseStatesOfProgram,\n    initAttributes,\n  \
  enableAttribute,\n    disableUnusedAttributes\n  };\n}\nfunction \
WebGLBufferRenderer(gl, extensions, info) {\n  let mode;\n  function \
setMode(value) {\n    mode = value;\n  }\n  function render(start, count) {\n \
   gl.drawArrays(mode, start, count);\n    info.update(count, mode, 1);\n  \
}\n  function renderInstances(start, count, primcount) {\n    if (primcount \
=== 0) return;\n    gl.drawArraysInstanced(mode, start, count, primcount);\n  \
  info.update(count, mode, primcount);\n  }\n  function \
renderMultiDraw(starts, counts, drawCount) {\n    if (drawCount === 0) \
return;\n    const extension = extensions.get(\"WEBGL_multi_draw\");\n    \
extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);\n    \
let elementCount = 0;\n    for (let i = 0; i < drawCount; i++) {\n      \
elementCount += counts[i];\n    }\n    info.update(elementCount, mode, 1);\n  \
}\n  function renderMultiDrawInstances(starts, counts, drawCount, primcount) \
{\n    if (drawCount === 0) return;\n    const extension = \
extensions.get(\"WEBGL_multi_draw\");\n    if (extension === null) {\n      \
for (let i = 0; i < starts.length; i++) {\n        renderInstances(starts[i], \
counts[i], primcount[i]);\n      }\n    } else {\n      \
extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, \
primcount, 0, drawCount);\n      let elementCount = 0;\n      for (let i = 0; \
i < drawCount; i++) {\n        elementCount += counts[i] * primcount[i];\n    \
  }\n      info.update(elementCount, mode, 1);\n    }\n  }\n  this.setMode = \
setMode;\n  this.render = render;\n  this.renderInstances = \
renderInstances;\n  this.renderMultiDraw = renderMultiDraw;\n  \
this.renderMultiDrawInstances = renderMultiDrawInstances;\n}\nfunction \
WebGLCapabilities(gl, extensions, parameters, utils) {\n  let \
maxAnisotropy;\n  function getMaxAnisotropy() {\n    if (maxAnisotropy !== \
void 0) return maxAnisotropy;\n    if \
(extensions.has(\"EXT_texture_filter_anisotropic\") === true) {\n      const \
extension = extensions.get(\"EXT_texture_filter_anisotropic\");\n      \
maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n  \
  } else {\n      maxAnisotropy = 0;\n    }\n    return maxAnisotropy;\n  }\n \
 function textureFormatReadable(textureFormat) {\n    if (textureFormat !== \
RGBAFormat && utils.convert(textureFormat) !== \
gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {\n      return \
false;\n    }\n    return true;\n  }\n  function \
textureTypeReadable(textureType) {\n    const halfFloatSupportedByExt = \
textureType === HalfFloatType && \
(extensions.has(\"EXT_color_buffer_half_float\") || \
extensions.has(\"EXT_color_buffer_float\"));\n    if (textureType !== \
UnsignedByteType && utils.convert(textureType) !== \
gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac \
< 52 (#9513)\n    textureType !== FloatType && !halfFloatSupportedByExt) {\n  \
    return false;\n    }\n    return true;\n  }\n  function \
getMaxPrecision(precision2) {\n    if (precision2 === \"highp\") {\n      if \
(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 \
&& gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > \
0) {\n        return \"highp\";\n      }\n      precision2 = \"mediump\";\n   \
 }\n    if (precision2 === \"mediump\") {\n      if \
(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 \
&& gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision \
> 0) {\n        return \"mediump\";\n      }\n    }\n    return \"lowp\";\n  \
}\n  let precision = parameters.precision !== void 0 ? parameters.precision : \
\"highp\";\n  const maxPrecision = getMaxPrecision(precision);\n  if \
(maxPrecision !== precision) {\n    console.warn(\"THREE.WebGLRenderer:\", \
precision, \"not supported, using\", maxPrecision, \"instead.\");\n    \
precision = maxPrecision;\n  }\n  const logarithmicDepthBuffer = \
parameters.logarithmicDepthBuffer === true;\n  const reverseDepthBuffer = \
parameters.reverseDepthBuffer === true && \
extensions.has(\"EXT_clip_control\");\n  const maxTextures = \
gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  const maxVertexTextures = \
gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n  const maxTextureSize = \
gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  const maxCubemapSize = \
gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n  const maxAttributes = \
gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  const maxVertexUniforms = \
gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n  const maxVaryings = \
gl.getParameter(gl.MAX_VARYING_VECTORS);\n  const maxFragmentUniforms = \
gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n  const vertexTextures = \
maxVertexTextures > 0;\n  const maxSamples = \
gl.getParameter(gl.MAX_SAMPLES);\n  return {\n    isWebGL2: true,\n    // \
keeping this for backwards compatibility\n    getMaxAnisotropy,\n    \
getMaxPrecision,\n    textureFormatReadable,\n    textureTypeReadable,\n    \
precision,\n    logarithmicDepthBuffer,\n    reverseDepthBuffer,\n    \
maxTextures,\n    maxVertexTextures,\n    maxTextureSize,\n    \
maxCubemapSize,\n    maxAttributes,\n    maxVertexUniforms,\n    \
maxVaryings,\n    maxFragmentUniforms,\n    vertexTextures,\n    maxSamples\n \
 };\n}\nfunction WebGLClipping(properties) {\n  const scope = this;\n  let \
globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, \
renderingShadows = false;\n  const plane = new Plane(), viewNormalMatrix = \
new Matrix3(), uniform2 = { value: null, needsUpdate: false };\n  \
this.uniform = uniform2;\n  this.numPlanes = 0;\n  this.numIntersection = \
0;\n  this.init = function(planes, enableLocalClipping) {\n    const enabled \
= planes.length !== 0 || enableLocalClipping || // enable state of previous \
frame - the clipping code has to\n    // run another frame in order to reset \
the state:\n    numGlobalPlanes !== 0 || localClippingEnabled;\n    \
localClippingEnabled = enableLocalClipping;\n    numGlobalPlanes = \
planes.length;\n    return enabled;\n  };\n  this.beginShadows = function() \
{\n    renderingShadows = true;\n    projectPlanes(null);\n  };\n  \
this.endShadows = function() {\n    renderingShadows = false;\n  };\n  \
this.setGlobalState = function(planes, camera3) {\n    globalState = \
projectPlanes(planes, camera3, 0);\n  };\n  this.setState = \
function(material, camera3, useCache) {\n    const planes = \
material.clippingPlanes, clipIntersection = material.clipIntersection, \
clipShadows = material.clipShadows;\n    const materialProperties = \
properties.get(material);\n    if (!localClippingEnabled || planes === null \
|| planes.length === 0 || renderingShadows && !clipShadows) {\n      if \
(renderingShadows) {\n        projectPlanes(null);\n      } else {\n        \
resetGlobalState();\n      }\n    } else {\n      const nGlobal = \
renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;\n      let \
dstArray = materialProperties.clippingState || null;\n      uniform2.value = \
dstArray;\n      dstArray = projectPlanes(planes, camera3, lGlobal, \
useCache);\n      for (let i = 0; i !== lGlobal; ++i) {\n        dstArray[i] \
= globalState[i];\n      }\n      materialProperties.clippingState = \
dstArray;\n      this.numIntersection = clipIntersection ? this.numPlanes : \
0;\n      this.numPlanes += nGlobal;\n    }\n  };\n  function \
resetGlobalState() {\n    if (uniform2.value !== globalState) {\n      \
uniform2.value = globalState;\n      uniform2.needsUpdate = numGlobalPlanes > \
0;\n    }\n    scope.numPlanes = numGlobalPlanes;\n    scope.numIntersection \
= 0;\n  }\n  function projectPlanes(planes, camera3, dstOffset, \
skipTransform) {\n    const nPlanes = planes !== null ? planes.length : 0;\n  \
  let dstArray = null;\n    if (nPlanes !== 0) {\n      dstArray = \
uniform2.value;\n      if (skipTransform !== true || dstArray === null) {\n   \
     const flatSize = dstOffset + nPlanes * 4, viewMatrix = \
camera3.matrixWorldInverse;\n        \
viewNormalMatrix.getNormalMatrix(viewMatrix);\n        if (dstArray === null \
|| dstArray.length < flatSize) {\n          dstArray = new \
Float32Array(flatSize);\n        }\n        for (let i = 0, i4 = dstOffset; i \
!== nPlanes; ++i, i4 += 4) {\n          \
plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n          \
plane.normal.toArray(dstArray, i4);\n          dstArray[i4 + 3] = \
plane.constant;\n        }\n      }\n      uniform2.value = dstArray;\n      \
uniform2.needsUpdate = true;\n    }\n    scope.numPlanes = nPlanes;\n    \
scope.numIntersection = 0;\n    return dstArray;\n  }\n}\nfunction \
WebGLCubeMaps(renderer3) {\n  let cubemaps = /* @__PURE__ */ new WeakMap();\n \
 function mapTextureMapping2(texture2, mapping) {\n    if (mapping === \
EquirectangularReflectionMapping) {\n      texture2.mapping = \
CubeReflectionMapping;\n    } else if (mapping === \
EquirectangularRefractionMapping) {\n      texture2.mapping = \
CubeRefractionMapping;\n    }\n    return texture2;\n  }\n  function \
get2(texture2) {\n    if (texture2 && texture2.isTexture) {\n      const \
mapping = texture2.mapping;\n      if (mapping === \
EquirectangularReflectionMapping || mapping === \
EquirectangularRefractionMapping) {\n        if (cubemaps.has(texture2)) {\n  \
        const cubemap = cubemaps.get(texture2).texture;\n          return \
mapTextureMapping2(cubemap, texture2.mapping);\n        } else {\n          \
const image = texture2.image;\n          if (image && image.height > 0) {\n   \
         const renderTarget = new WebGLCubeRenderTarget(image.height);\n      \
      renderTarget.fromEquirectangularTexture(renderer3, texture2);\n         \
   cubemaps.set(texture2, renderTarget);\n            \
texture2.addEventListener(\"dispose\", onTextureDispose2);\n            \
return mapTextureMapping2(renderTarget.texture, texture2.mapping);\n          \
} else {\n            return null;\n          }\n        }\n      }\n    }\n  \
  return texture2;\n  }\n  function onTextureDispose2(event) {\n    const \
texture2 = event.target;\n    texture2.removeEventListener(\"dispose\", \
onTextureDispose2);\n    const cubemap = cubemaps.get(texture2);\n    if \
(cubemap !== void 0) {\n      cubemaps.delete(texture2);\n      \
cubemap.dispose();\n    }\n  }\n  function dispose() {\n    cubemaps = /* \
@__PURE__ */ new WeakMap();\n  }\n  return {\n    get: get2,\n    dispose\n  \
};\n}\nvar OrthographicCamera = class extends Camera {\n  constructor(left = \
-1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {\n    super();\n \
   this.isOrthographicCamera = true;\n    this.type = \
\"OrthographicCamera\";\n    this.zoom = 1;\n    this.view = null;\n    \
this.left = left;\n    this.right = right;\n    this.top = top;\n    \
this.bottom = bottom;\n    this.near = near;\n    this.far = far;\n    \
this.updateProjectionMatrix();\n  }\n  copy(source, recursive) {\n    \
super.copy(source, recursive);\n    this.left = source.left;\n    this.right \
= source.right;\n    this.top = source.top;\n    this.bottom = \
source.bottom;\n    this.near = source.near;\n    this.far = source.far;\n    \
this.zoom = source.zoom;\n    this.view = source.view === null ? null : \
Object.assign({}, source.view);\n    return this;\n  }\n  \
setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {\n    if \
(this.view === null) {\n      this.view = {\n        enabled: true,\n        \
fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: \
0,\n        width: 1,\n        height: 1\n      };\n    }\n    \
this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    \
this.view.fullHeight = fullHeight;\n    this.view.offsetX = x2;\n    \
this.view.offsetY = y2;\n    this.view.width = width;\n    this.view.height = \
height;\n    this.updateProjectionMatrix();\n  }\n  clearViewOffset() {\n    \
if (this.view !== null) {\n      this.view.enabled = false;\n    }\n    \
this.updateProjectionMatrix();\n  }\n  updateProjectionMatrix() {\n    const \
dx = (this.right - this.left) / (2 * this.zoom);\n    const dy = (this.top - \
this.bottom) / (2 * this.zoom);\n    const cx = (this.right + this.left) / \
2;\n    const cy = (this.top + this.bottom) / 2;\n    let left = cx - dx;\n   \
 let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n    \
if (this.view !== null && this.view.enabled) {\n      const scaleW = \
(this.right - this.left) / this.view.fullWidth / this.zoom;\n      const \
scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n      \
left += scaleW * this.view.offsetX;\n      right = left + scaleW * \
this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = \
top - scaleH * this.view.height;\n    }\n    \
this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, \
this.far, this.coordinateSystem);\n    \
this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  \
toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.zoom = \
this.zoom;\n    data.object.left = this.left;\n    data.object.right = \
this.right;\n    data.object.top = this.top;\n    data.object.bottom = \
this.bottom;\n    data.object.near = this.near;\n    data.object.far = \
this.far;\n    if (this.view !== null) data.object.view = Object.assign({}, \
this.view);\n    return data;\n  }\n};\nvar LOD_MIN = 4;\nvar EXTRA_LOD_SIGMA \
= [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nvar MAX_SAMPLES = 20;\nvar \
_flatCamera = /* @__PURE__ */ new OrthographicCamera();\nvar _clearColor = /* \
@__PURE__ */ new Color();\nvar _oldTarget = null;\nvar _oldActiveCubeFace = \
0;\nvar _oldActiveMipmapLevel = 0;\nvar _oldXrEnabled = false;\nvar PHI = (1 \
+ Math.sqrt(5)) / 2;\nvar INV_PHI = 1 / PHI;\nvar _axisDirections = [\n  /* \
@__PURE__ */ new Vector3(-PHI, INV_PHI, 0),\n  /* @__PURE__ */ new \
Vector3(PHI, INV_PHI, 0),\n  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),\n \
 /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),\n  /* @__PURE__ */ new \
Vector3(0, PHI, -INV_PHI),\n  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),\n \
 /* @__PURE__ */ new Vector3(-1, 1, -1),\n  /* @__PURE__ */ new Vector3(1, 1, \
-1),\n  /* @__PURE__ */ new Vector3(-1, 1, 1),\n  /* @__PURE__ */ new \
Vector3(1, 1, 1)\n];\nvar PMREMGenerator = class {\n  constructor(renderer3) \
{\n    this._renderer = renderer3;\n    this._pingPongRenderTarget = null;\n  \
  this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    \
this._sizeLods = [];\n    this._sigmas = [];\n    this._blurMaterial = \
null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = \
null;\n    this._compileMaterial(this._blurMaterial);\n  }\n  /**\n   * \
Generates a PMREM from a supplied Scene, which can be faster than using an\n  \
 * image if networking bandwidth is low. Optional sigma specifies a blur \
radius\n   * in radians to be applied to the scene before PMREM generation. \
Optional near\n   * and far planes ensure the scene is rendered in its \
entirety (the cubeCamera\n   * is placed at the origin).\n   */\n  \
fromScene(scene3, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = \
this._renderer.getRenderTarget();\n    _oldActiveCubeFace = \
this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = \
this._renderer.getActiveMipmapLevel();\n    _oldXrEnabled = \
this._renderer.xr.enabled;\n    this._renderer.xr.enabled = false;\n    \
this._setSize(256);\n    const cubeUVRenderTarget = \
this._allocateTargets();\n    cubeUVRenderTarget.depthBuffer = true;\n    \
this._sceneToCubeUV(scene3, near, far, cubeUVRenderTarget);\n    if (sigma > \
0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n    \
this._applyPMREM(cubeUVRenderTarget);\n    \
this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  \
/**\n   * Generates a PMREM from an equirectangular texture, which can be \
either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * \
as this matches best with the 256 x 256 cubemap output.\n   * The smallest \
supported equirectangular image size is 64 x 32.\n   */\n  \
fromEquirectangular(equirectangular, renderTarget = null) {\n    return \
this._fromTexture(equirectangular, renderTarget);\n  }\n  /**\n   * Generates \
a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The \
ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x \
256 cubemap output.\n   * The smallest supported cube size is 16 x 16.\n   \
*/\n  fromCubemap(cubemap, renderTarget = null) {\n    return \
this._fromTexture(cubemap, renderTarget);\n  }\n  /**\n   * Pre-compiles the \
cubemap shader. You can get faster start-up by invoking this method during\n  \
 * your texture's network fetch for increased concurrency.\n   */\n  \
compileCubemapShader() {\n    if (this._cubemapMaterial === null) {\n      \
this._cubemapMaterial = _getCubemapMaterial();\n      \
this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n  /**\n   * \
Pre-compiles the equirectangular shader. You can get faster start-up by \
invoking this method during\n   * your texture's network fetch for increased \
concurrency.\n   */\n  compileEquirectangularShader() {\n    if \
(this._equirectMaterial === null) {\n      this._equirectMaterial = \
_getEquirectMaterial();\n      \
this._compileMaterial(this._equirectMaterial);\n    }\n  }\n  /**\n   * \
Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is \
a static class,\n   * so you should not need more than one PMREMGenerator \
object. If you do, calling dispose() on\n   * one of them will cause any \
others to also become unusable.\n   */\n  dispose() {\n    this._dispose();\n \
   if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    \
if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n  }\n \
 // private interface\n  _setSize(cubeSize) {\n    this._lodMax = \
Math.floor(Math.log2(cubeSize));\n    this._cubeSize = Math.pow(2, \
this._lodMax);\n  }\n  _dispose() {\n    if (this._blurMaterial !== null) \
this._blurMaterial.dispose();\n    if (this._pingPongRenderTarget !== null) \
this._pingPongRenderTarget.dispose();\n    for (let i = 0; i < \
this._lodPlanes.length; i++) {\n      this._lodPlanes[i].dispose();\n    }\n  \
}\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget, \
_oldActiveCubeFace, _oldActiveMipmapLevel);\n    this._renderer.xr.enabled = \
_oldXrEnabled;\n    outputTarget.scissorTest = false;\n    \
_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  \
}\n  _fromTexture(texture2, renderTarget) {\n    if (texture2.mapping === \
CubeReflectionMapping || texture2.mapping === CubeRefractionMapping) {\n      \
this._setSize(texture2.image.length === 0 ? 16 : texture2.image[0].width || \
texture2.image[0].image.width);\n    } else {\n      \
this._setSize(texture2.image.width / 4);\n    }\n    _oldTarget = \
this._renderer.getRenderTarget();\n    _oldActiveCubeFace = \
this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = \
this._renderer.getActiveMipmapLevel();\n    _oldXrEnabled = \
this._renderer.xr.enabled;\n    this._renderer.xr.enabled = false;\n    const \
cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    \
this._textureToCubeUV(texture2, cubeUVRenderTarget);\n    \
this._applyPMREM(cubeUVRenderTarget);\n    \
this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  \
_allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * \
7);\n    const height = 4 * this._cubeSize;\n    const params = {\n      \
magFilter: LinearFilter,\n      minFilter: LinearFilter,\n      \
generateMipmaps: false,\n      type: HalfFloatType,\n      format: \
RGBAFormat,\n      colorSpace: LinearSRGBColorSpace,\n      depthBuffer: \
false\n    };\n    const cubeUVRenderTarget = _createRenderTarget(width, \
height, params);\n    if (this._pingPongRenderTarget === null || \
this._pingPongRenderTarget.width !== width || \
this._pingPongRenderTarget.height !== height) {\n      if \
(this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n  \
    this._pingPongRenderTarget = _createRenderTarget(width, height, \
params);\n      const { _lodMax } = this;\n      ({ sizeLods: this._sizeLods, \
lodPlanes: this._lodPlanes, sigmas: this._sigmas } = \
_createPlanes(_lodMax));\n      this._blurMaterial = _getBlurShader(_lodMax, \
width, height);\n    }\n    return cubeUVRenderTarget;\n  }\n  \
_compileMaterial(material) {\n    const tmpMesh = new \
Mesh(this._lodPlanes[0], material);\n    this._renderer.compile(tmpMesh, \
_flatCamera);\n  }\n  _sceneToCubeUV(scene3, near, far, cubeUVRenderTarget) \
{\n    const fov3 = 90;\n    const aspect3 = 1;\n    const cubeCamera = new \
PerspectiveCamera(fov3, aspect3, near, far);\n    const upSign = [1, -1, 1, \
1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const \
renderer3 = this._renderer;\n    const originalAutoClear = \
renderer3.autoClear;\n    const toneMapping2 = renderer3.toneMapping;\n    \
renderer3.getClearColor(_clearColor);\n    renderer3.toneMapping = \
NoToneMapping;\n    renderer3.autoClear = false;\n    const \
backgroundMaterial = new MeshBasicMaterial({\n      name: \
\"PMREM.Background\",\n      side: BackSide,\n      depthWrite: false,\n      \
depthTest: false\n    });\n    const backgroundBox = new Mesh(new \
BoxGeometry(), backgroundMaterial);\n    let useSolidColor = false;\n    \
const background = scene3.background;\n    if (background) {\n      if \
(background.isColor) {\n        backgroundMaterial.color.copy(background);\n  \
      scene3.background = null;\n        useSolidColor = true;\n      }\n    \
} else {\n      backgroundMaterial.color.copy(_clearColor);\n      \
useSolidColor = true;\n    }\n    for (let i = 0; i < 6; i++) {\n      const \
col = i % 3;\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], \
0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col \
=== 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        \
cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        \
cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, \
forwardSign[i]);\n      }\n      const size = this._cubeSize;\n      \
_setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);\n \
     renderer3.setRenderTarget(cubeUVRenderTarget);\n      if (useSolidColor) \
{\n        renderer3.render(backgroundBox, cubeCamera);\n      }\n      \
renderer3.render(scene3, cubeCamera);\n    }\n    \
backgroundBox.geometry.dispose();\n    backgroundBox.material.dispose();\n    \
renderer3.toneMapping = toneMapping2;\n    renderer3.autoClear = \
originalAutoClear;\n    scene3.background = background;\n  }\n  \
_textureToCubeUV(texture2, cubeUVRenderTarget) {\n    const renderer3 = \
this._renderer;\n    const isCubeTexture = texture2.mapping === \
CubeReflectionMapping || texture2.mapping === CubeRefractionMapping;\n    if \
(isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        \
this._cubemapMaterial = _getCubemapMaterial();\n      }\n      \
this._cubemapMaterial.uniforms.flipEnvMap.value = \
texture2.isRenderTargetTexture === false ? -1 : 1;\n    } else {\n      if \
(this._equirectMaterial === null) {\n        this._equirectMaterial = \
_getEquirectMaterial();\n      }\n    }\n    const material = isCubeTexture ? \
this._cubemapMaterial : this._equirectMaterial;\n    const mesh = new \
Mesh(this._lodPlanes[0], material);\n    const uniforms = \
material.uniforms;\n    uniforms[\"envMap\"].value = texture2;\n    const \
size = this._cubeSize;\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, \
2 * size);\n    renderer3.setRenderTarget(cubeUVRenderTarget);\n    \
renderer3.render(mesh, _flatCamera);\n  }\n  _applyPMREM(cubeUVRenderTarget) \
{\n    const renderer3 = this._renderer;\n    const autoClear = \
renderer3.autoClear;\n    renderer3.autoClear = false;\n    const n = \
this._lodPlanes.length;\n    for (let i = 1; i < n; i++) {\n      const sigma \
= Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * \
this._sigmas[i - 1]);\n      const poleAxis = _axisDirections[(n - i - 1) % \
_axisDirections.length];\n      this._blur(cubeUVRenderTarget, i - 1, i, \
sigma, poleAxis);\n    }\n    renderer3.autoClear = autoClear;\n  }\n  /**\n  \
 * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   \
* vertically and horizontally, but this breaks down on a cube. Here we \
apply\n   * the blur latitudinally (around the poles), and then \
longitudinally (towards\n   * the poles) to approximate the \
orthogonally-separable blur. It is least\n   * accurate at the poles, but \
still does a decent job.\n   */\n  _blur(cubeUVRenderTarget, lodIn, lodOut, \
sigma, poleAxis) {\n    const pingPongRenderTarget = \
this._pingPongRenderTarget;\n    this._halfBlur(\n      cubeUVRenderTarget,\n \
     pingPongRenderTarget,\n      lodIn,\n      lodOut,\n      sigma,\n      \
\"latitudinal\",\n      poleAxis\n    );\n    this._halfBlur(\n      \
pingPongRenderTarget,\n      cubeUVRenderTarget,\n      lodOut,\n      \
lodOut,\n      sigma,\n      \"longitudinal\",\n      poleAxis\n    );\n  }\n \
 _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction2, \
poleAxis) {\n    const renderer3 = this._renderer;\n    const blurMaterial = \
this._blurMaterial;\n    if (direction2 !== \"latitudinal\" && direction2 !== \
\"longitudinal\") {\n      console.error(\n        \"blur direction must be \
either latitudinal or longitudinal!\"\n      );\n    }\n    const \
STANDARD_DEVIATIONS = 3;\n    const blurMesh = new \
Mesh(this._lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = \
blurMaterial.uniforms;\n    const pixels = this._sizeLods[lodIn] - 1;\n    \
const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * \
Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / \
radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + \
Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples \
> MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too \
large and will clip, as it requested ${samples} samples when the maximum is \
set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n  \
  for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x3 = i / \
sigmaPixels;\n      const weight = Math.exp(-x3 * x3 / 2);\n      \
weights.push(weight);\n      if (i === 0) {\n        sum += weight;\n      } \
else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for \
(let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / \
sum;\n    }\n    blurUniforms[\"envMap\"].value = targetIn.texture;\n    \
blurUniforms[\"samples\"].value = samples;\n    \
blurUniforms[\"weights\"].value = weights;\n    \
blurUniforms[\"latitudinal\"].value = direction2 === \"latitudinal\";\n    if \
(poleAxis) {\n      blurUniforms[\"poleAxis\"].value = poleAxis;\n    }\n    \
const { _lodMax } = this;\n    blurUniforms[\"dTheta\"].value = \
radiansPerPixel;\n    blurUniforms[\"mipInt\"].value = _lodMax - lodIn;\n    \
const outputSize = this._sizeLods[lodOut];\n    const x2 = 3 * outputSize * \
(lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n    const y2 \
= 4 * (this._cubeSize - outputSize);\n    _setViewport(targetOut, x2, y2, 3 * \
outputSize, 2 * outputSize);\n    renderer3.setRenderTarget(targetOut);\n    \
renderer3.render(blurMesh, _flatCamera);\n  }\n};\nfunction \
_createPlanes(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  \
const sigmas = [];\n  let lod = lodMax;\n  const totalLods = lodMax - LOD_MIN \
+ 1 + EXTRA_LOD_SIGMA.length;\n  for (let i = 0; i < totalLods; i++) {\n    \
const sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    let sigma \
= 1 / sizeLod;\n    if (i > lodMax - LOD_MIN) {\n      sigma = \
EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];\n    } else if (i === 0) {\n      \
sigma = 0;\n    }\n    sigmas.push(sigma);\n    const texelSize = 1 / \
(sizeLod - 2);\n    const min2 = -texelSize;\n    const max2 = 1 + \
texelSize;\n    const uv1 = [min2, min2, max2, min2, max2, max2, min2, min2, \
max2, max2, min2, max2];\n    const cubeFaces = 6;\n    const vertices = 6;\n \
   const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = \
1;\n    const position = new Float32Array(positionSize * vertices * \
cubeFaces);\n    const uv2 = new Float32Array(uvSize * vertices * \
cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices \
* cubeFaces);\n    for (let face = 0; face < cubeFaces; face++) {\n      \
const x2 = face % 3 * 2 / 3 - 1;\n      const y2 = face > 2 ? 0 : -1;\n      \
const coordinates = [\n        x2,\n        y2,\n        0,\n        x2 + 2 / \
3,\n        y2,\n        0,\n        x2 + 2 / 3,\n        y2 + 1,\n        \
0,\n        x2,\n        y2,\n        0,\n        x2 + 2 / 3,\n        y2 + \
1,\n        0,\n        x2,\n        y2 + 1,\n        0\n      ];\n      \
position.set(coordinates, positionSize * vertices * face);\n      \
uv2.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, \
face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices \
* face);\n    }\n    const planes = new BufferGeometry();\n    \
planes.setAttribute(\"position\", new BufferAttribute(position, \
positionSize));\n    planes.setAttribute(\"uv\", new BufferAttribute(uv2, \
uvSize));\n    planes.setAttribute(\"faceIndex\", new \
BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n    \
if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n  return { lodPlanes, \
sizeLods, sigmas };\n}\nfunction _createRenderTarget(width, height, params) \
{\n  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, \
params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  \
cubeUVRenderTarget.texture.name = \"PMREM.cubeUv\";\n  \
cubeUVRenderTarget.scissorTest = true;\n  return \
cubeUVRenderTarget;\n}\nfunction _setViewport(target, x2, y2, width, height) \
{\n  target.viewport.set(x2, y2, width, height);\n  target.scissor.set(x2, \
y2, width, height);\n}\nfunction _getBlurShader(lodMax, width, height) {\n  \
const weights = new Float32Array(MAX_SAMPLES);\n  const poleAxis = new \
Vector3(0, 1, 0);\n  const shaderMaterial = new ShaderMaterial({\n    name: \
\"SphericalGaussianBlur\",\n    defines: {\n      \"n\": MAX_SAMPLES,\n      \
\"CUBEUV_TEXEL_WIDTH\": 1 / width,\n      \"CUBEUV_TEXEL_HEIGHT\": 1 / \
height,\n      \"CUBEUV_MAX_MIP\": `${lodMax}.0`\n    },\n    uniforms: {\n   \
   \"envMap\": { value: null },\n      \"samples\": { value: 1 },\n      \
\"weights\": { value: weights },\n      \"latitudinal\": { value: false },\n  \
    \"dTheta\": { value: 0 },\n      \"mipInt\": { value: 0 },\n      \
\"poleAxis\": { value: poleAxis }\n    },\n    vertexShader: \
_getCommonVertexShader(),\n    fragmentShader: (\n      /* glsl */\n      \
`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump \
int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D \
envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n \
];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float \
dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 \
poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include \
<cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis \
) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' \
axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * \
cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta \
)\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta \
);\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt \
);\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? \
poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( \
axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, \
- vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis \
);\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 \
);\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis \
);\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples \
) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * \
float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * \
theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( \
theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`\n    ),\n    blending: \
NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return \
shaderMaterial;\n}\nfunction _getEquirectMaterial() {\n  return new \
ShaderMaterial({\n    name: \"EquirectangularToCubeUV\",\n    uniforms: {\n   \
   \"envMap\": { value: null }\n    },\n    vertexShader: \
_getCommonVertexShader(),\n    fragmentShader: (\n      /* glsl */\n      \
`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump \
int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D \
envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 \
outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = \
equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( \
envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`\n    ),\n    blending: \
NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\nfunction \
_getCubemapMaterial() {\n  return new ShaderMaterial({\n    name: \
\"CubemapToCubeUV\",\n    uniforms: {\n      \"envMap\": { value: null },\n   \
   \"flipEnvMap\": { value: -1 }\n    },\n    vertexShader: \
_getCommonVertexShader(),\n    fragmentShader: (\n      /* glsl */\n      \
`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump \
int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 \
vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() \
{\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * \
vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`\n    ),\n    \
blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  \
});\n}\nfunction _getCommonVertexShader() {\n  return (\n    /* glsl */\n    \
`\n\n\t\tprecision mediump float;\n\t\tprecision mediump \
int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 \
vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing \
convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 \
* uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == \
0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} \
else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = \
direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos \
y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( \
-u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = \
direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg \
x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = \
direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg \
y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( \
u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid \
main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex \
);\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n  \
);\n}\nfunction WebGLCubeUVMaps(renderer3) {\n  let cubeUVmaps = /* @__PURE__ \
*/ new WeakMap();\n  let pmremGenerator = null;\n  function get2(texture2) \
{\n    if (texture2 && texture2.isTexture) {\n      const mapping = \
texture2.mapping;\n      const isEquirectMap = mapping === \
EquirectangularReflectionMapping || mapping === \
EquirectangularRefractionMapping;\n      const isCubeMap = mapping === \
CubeReflectionMapping || mapping === CubeRefractionMapping;\n      if \
(isEquirectMap || isCubeMap) {\n        let renderTarget = \
cubeUVmaps.get(texture2);\n        const currentPMREMVersion = renderTarget \
!== void 0 ? renderTarget.texture.pmremVersion : 0;\n        if \
(texture2.isRenderTargetTexture && texture2.pmremVersion !== \
currentPMREMVersion) {\n          if (pmremGenerator === null) pmremGenerator \
= new PMREMGenerator(renderer3);\n          renderTarget = isEquirectMap ? \
pmremGenerator.fromEquirectangular(texture2, renderTarget) : \
pmremGenerator.fromCubemap(texture2, renderTarget);\n          \
renderTarget.texture.pmremVersion = texture2.pmremVersion;\n          \
cubeUVmaps.set(texture2, renderTarget);\n          return \
renderTarget.texture;\n        } else {\n          if (renderTarget !== void \
0) {\n            return renderTarget.texture;\n          } else {\n          \
  const image = texture2.image;\n            if (isEquirectMap && image && \
image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {\n   \
           if (pmremGenerator === null) pmremGenerator = new \
PMREMGenerator(renderer3);\n              renderTarget = isEquirectMap ? \
pmremGenerator.fromEquirectangular(texture2) : \
pmremGenerator.fromCubemap(texture2);\n              \
renderTarget.texture.pmremVersion = texture2.pmremVersion;\n              \
cubeUVmaps.set(texture2, renderTarget);\n              \
texture2.addEventListener(\"dispose\", onTextureDispose2);\n              \
return renderTarget.texture;\n            } else {\n              return \
null;\n            }\n          }\n        }\n      }\n    }\n    return \
texture2;\n  }\n  function isCubeTextureComplete(image) {\n    let count = \
0;\n    const length2 = 6;\n    for (let i = 0; i < length2; i++) {\n      if \
(image[i] !== void 0) count++;\n    }\n    return count === length2;\n  }\n  \
function onTextureDispose2(event) {\n    const texture2 = event.target;\n    \
texture2.removeEventListener(\"dispose\", onTextureDispose2);\n    const \
cubemapUV = cubeUVmaps.get(texture2);\n    if (cubemapUV !== void 0) {\n      \
cubeUVmaps.delete(texture2);\n      cubemapUV.dispose();\n    }\n  }\n  \
function dispose() {\n    cubeUVmaps = /* @__PURE__ */ new WeakMap();\n    if \
(pmremGenerator !== null) {\n      pmremGenerator.dispose();\n      \
pmremGenerator = null;\n    }\n  }\n  return {\n    get: get2,\n    dispose\n \
 };\n}\nfunction WebGLExtensions(gl) {\n  const extensions = {};\n  function \
getExtension(name) {\n    if (extensions[name] !== void 0) {\n      return \
extensions[name];\n    }\n    let extension;\n    switch (name) {\n      case \
\"WEBGL_depth_texture\":\n        extension = \
gl.getExtension(\"WEBGL_depth_texture\") || \
gl.getExtension(\"MOZ_WEBGL_depth_texture\") || \
gl.getExtension(\"WEBKIT_WEBGL_depth_texture\");\n        break;\n      case \
\"EXT_texture_filter_anisotropic\":\n        extension = \
gl.getExtension(\"EXT_texture_filter_anisotropic\") || \
gl.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || \
gl.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");\n        break;\n \
     case \"WEBGL_compressed_texture_s3tc\":\n        extension = \
gl.getExtension(\"WEBGL_compressed_texture_s3tc\") || \
gl.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") || \
gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");\n        break;\n  \
    case \"WEBGL_compressed_texture_pvrtc\":\n        extension = \
gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || \
gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\");\n        break;\n \
     default:\n        extension = gl.getExtension(name);\n    }\n    \
extensions[name] = extension;\n    return extension;\n  }\n  return {\n    \
has: function(name) {\n      return getExtension(name) !== null;\n    },\n    \
init: function() {\n      getExtension(\"EXT_color_buffer_float\");\n      \
getExtension(\"WEBGL_clip_cull_distance\");\n      \
getExtension(\"OES_texture_float_linear\");\n      \
getExtension(\"EXT_color_buffer_half_float\");\n      \
getExtension(\"WEBGL_multisampled_render_to_texture\");\n      \
getExtension(\"WEBGL_render_shared_exponent\");\n    },\n    get: \
function(name) {\n      const extension = getExtension(name);\n      if \
(extension === null) {\n        warnOnce(\"THREE.WebGLRenderer: \" + name + \
\" extension not supported.\");\n      }\n      return extension;\n    }\n  \
};\n}\nfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n  \
const geometries = {};\n  const wireframeAttributes = /* @__PURE__ */ new \
WeakMap();\n  function onGeometryDispose(event) {\n    const geometry = \
event.target;\n    if (geometry.index !== null) {\n      \
attributes.remove(geometry.index);\n    }\n    for (const name in \
geometry.attributes) {\n      attributes.remove(geometry.attributes[name]);\n \
   }\n    for (const name in geometry.morphAttributes) {\n      const array = \
geometry.morphAttributes[name];\n      for (let i = 0, l = array.length; i < \
l; i++) {\n        attributes.remove(array[i]);\n      }\n    }\n    \
geometry.removeEventListener(\"dispose\", onGeometryDispose);\n    delete \
geometries[geometry.id];\n    const attribute2 = \
wireframeAttributes.get(geometry);\n    if (attribute2) {\n      \
attributes.remove(attribute2);\n      wireframeAttributes.delete(geometry);\n \
   }\n    bindingStates.releaseStatesOfGeometry(geometry);\n    if \
(geometry.isInstancedBufferGeometry === true) {\n      delete \
geometry._maxInstanceCount;\n    }\n    info.memory.geometries--;\n  }\n  \
function get2(object, geometry) {\n    if (geometries[geometry.id] === true) \
return geometry;\n    geometry.addEventListener(\"dispose\", \
onGeometryDispose);\n    geometries[geometry.id] = true;\n    \
info.memory.geometries++;\n    return geometry;\n  }\n  function \
update4(geometry) {\n    const geometryAttributes = geometry.attributes;\n    \
for (const name in geometryAttributes) {\n      \
attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);\n    }\n    \
const morphAttributes = geometry.morphAttributes;\n    for (const name in \
morphAttributes) {\n      const array = morphAttributes[name];\n      for \
(let i = 0, l = array.length; i < l; i++) {\n        \
attributes.update(array[i], gl.ARRAY_BUFFER);\n      }\n    }\n  }\n  \
function updateWireframeAttribute(geometry) {\n    const indices = [];\n    \
const geometryIndex = geometry.index;\n    const geometryPosition = \
geometry.attributes.position;\n    let version = 0;\n    if (geometryIndex \
!== null) {\n      const array = geometryIndex.array;\n      version = \
geometryIndex.version;\n      for (let i = 0, l = array.length; i < l; i += \
3) {\n        const a2 = array[i + 0];\n        const b = array[i + 1];\n     \
   const c2 = array[i + 2];\n        indices.push(a2, b, b, c2, c2, a2);\n    \
  }\n    } else if (geometryPosition !== void 0) {\n      const array = \
geometryPosition.array;\n      version = geometryPosition.version;\n      for \
(let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n        const a2 = i \
+ 0;\n        const b = i + 1;\n        const c2 = i + 2;\n        \
indices.push(a2, b, b, c2, c2, a2);\n      }\n    } else {\n      return;\n   \
 }\n    const attribute2 = new (arrayNeedsUint32(indices) ? \
Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n    \
attribute2.version = version;\n    const previousAttribute = \
wireframeAttributes.get(geometry);\n    if (previousAttribute) \
attributes.remove(previousAttribute);\n    wireframeAttributes.set(geometry, \
attribute2);\n  }\n  function getWireframeAttribute(geometry) {\n    const \
currentAttribute = wireframeAttributes.get(geometry);\n    if \
(currentAttribute) {\n      const geometryIndex = geometry.index;\n      if \
(geometryIndex !== null) {\n        if (currentAttribute.version < \
geometryIndex.version) {\n          updateWireframeAttribute(geometry);\n     \
   }\n      }\n    } else {\n      updateWireframeAttribute(geometry);\n    \
}\n    return wireframeAttributes.get(geometry);\n  }\n  return {\n    get: \
get2,\n    update: update4,\n    getWireframeAttribute\n  };\n}\nfunction \
WebGLIndexedBufferRenderer(gl, extensions, info) {\n  let mode;\n  function \
setMode(value) {\n    mode = value;\n  }\n  let type, bytesPerElement;\n  \
function setIndex(value) {\n    type = value.type;\n    bytesPerElement = \
value.bytesPerElement;\n  }\n  function render(start, count) {\n    \
gl.drawElements(mode, count, type, start * bytesPerElement);\n    \
info.update(count, mode, 1);\n  }\n  function renderInstances(start, count, \
primcount) {\n    if (primcount === 0) return;\n    \
gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, \
primcount);\n    info.update(count, mode, primcount);\n  }\n  function \
renderMultiDraw(starts, counts, drawCount) {\n    if (drawCount === 0) \
return;\n    const extension = extensions.get(\"WEBGL_multi_draw\");\n    \
extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, \
drawCount);\n    let elementCount = 0;\n    for (let i = 0; i < drawCount; \
i++) {\n      elementCount += counts[i];\n    }\n    \
info.update(elementCount, mode, 1);\n  }\n  function \
renderMultiDrawInstances(starts, counts, drawCount, primcount) {\n    if \
(drawCount === 0) return;\n    const extension = \
extensions.get(\"WEBGL_multi_draw\");\n    if (extension === null) {\n      \
for (let i = 0; i < starts.length; i++) {\n        renderInstances(starts[i] \
/ bytesPerElement, counts[i], primcount[i]);\n      }\n    } else {\n      \
extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, \
primcount, 0, drawCount);\n      let elementCount = 0;\n      for (let i = 0; \
i < drawCount; i++) {\n        elementCount += counts[i] * primcount[i];\n    \
  }\n      info.update(elementCount, mode, 1);\n    }\n  }\n  this.setMode = \
setMode;\n  this.setIndex = setIndex;\n  this.render = render;\n  \
this.renderInstances = renderInstances;\n  this.renderMultiDraw = \
renderMultiDraw;\n  this.renderMultiDrawInstances = \
renderMultiDrawInstances;\n}\nfunction WebGLInfo(gl) {\n  const memory = {\n  \
  geometries: 0,\n    textures: 0\n  };\n  const render = {\n    frame: 0,\n  \
  calls: 0,\n    triangles: 0,\n    points: 0,\n    lines: 0\n  };\n  \
function update4(count, mode, instanceCount) {\n    render.calls++;\n    \
switch (mode) {\n      case gl.TRIANGLES:\n        render.triangles += \
instanceCount * (count / 3);\n        break;\n      case gl.LINES:\n        \
render.lines += instanceCount * (count / 2);\n        break;\n      case \
gl.LINE_STRIP:\n        render.lines += instanceCount * (count - 1);\n        \
break;\n      case gl.LINE_LOOP:\n        render.lines += instanceCount * \
count;\n        break;\n      case gl.POINTS:\n        render.points += \
instanceCount * count;\n        break;\n      default:\n        \
console.error(\"THREE.WebGLInfo: Unknown draw mode:\", mode);\n        \
break;\n    }\n  }\n  function reset() {\n    render.calls = 0;\n    \
render.triangles = 0;\n    render.points = 0;\n    render.lines = 0;\n  }\n  \
return {\n    memory,\n    render,\n    programs: null,\n    autoReset: \
true,\n    reset,\n    update: update4\n  };\n}\nfunction \
WebGLMorphtargets(gl, capabilities, textures) {\n  const morphTextures = /* \
@__PURE__ */ new WeakMap();\n  const morph = new Vector4();\n  function \
update4(object, geometry, program) {\n    const objectInfluences = \
object.morphTargetInfluences;\n    const morphAttribute = \
geometry.morphAttributes.position || geometry.morphAttributes.normal || \
geometry.morphAttributes.color;\n    const morphTargetsCount = morphAttribute \
!== void 0 ? morphAttribute.length : 0;\n    let entry = \
morphTextures.get(geometry);\n    if (entry === void 0 || entry.count !== \
morphTargetsCount) {\n      let disposeTexture = function() {\n        \
texture2.dispose();\n        morphTextures.delete(geometry);\n        \
geometry.removeEventListener(\"dispose\", disposeTexture);\n      };\n      \
if (entry !== void 0) entry.texture.dispose();\n      const hasMorphPosition \
= geometry.morphAttributes.position !== void 0;\n      const hasMorphNormals \
= geometry.morphAttributes.normal !== void 0;\n      const hasMorphColors = \
geometry.morphAttributes.color !== void 0;\n      const morphTargets = \
geometry.morphAttributes.position || [];\n      const morphNormals = \
geometry.morphAttributes.normal || [];\n      const morphColors = \
geometry.morphAttributes.color || [];\n      let vertexDataCount = 0;\n      \
if (hasMorphPosition === true) vertexDataCount = 1;\n      if \
(hasMorphNormals === true) vertexDataCount = 2;\n      if (hasMorphColors === \
true) vertexDataCount = 3;\n      let width = \
geometry.attributes.position.count * vertexDataCount;\n      let height = \
1;\n      if (width > capabilities.maxTextureSize) {\n        height = \
Math.ceil(width / capabilities.maxTextureSize);\n        width = \
capabilities.maxTextureSize;\n      }\n      const buffer2 = new \
Float32Array(width * height * 4 * morphTargetsCount);\n      const texture2 = \
new DataArrayTexture(buffer2, width, height, morphTargetsCount);\n      \
texture2.type = FloatType;\n      texture2.needsUpdate = true;\n      const \
vertexDataStride = vertexDataCount * 4;\n      for (let i = 0; i < \
morphTargetsCount; i++) {\n        const morphTarget = morphTargets[i];\n     \
   const morphNormal = morphNormals[i];\n        const morphColor = \
morphColors[i];\n        const offset = width * height * 4 * i;\n        for \
(let j = 0; j < morphTarget.count; j++) {\n          const stride = j * \
vertexDataStride;\n          if (hasMorphPosition === true) {\n            \
morph.fromBufferAttribute(morphTarget, j);\n            buffer2[offset + \
stride + 0] = morph.x;\n            buffer2[offset + stride + 1] = morph.y;\n \
           buffer2[offset + stride + 2] = morph.z;\n            \
buffer2[offset + stride + 3] = 0;\n          }\n          if (hasMorphNormals \
=== true) {\n            morph.fromBufferAttribute(morphNormal, j);\n         \
   buffer2[offset + stride + 4] = morph.x;\n            buffer2[offset + \
stride + 5] = morph.y;\n            buffer2[offset + stride + 6] = morph.z;\n \
           buffer2[offset + stride + 7] = 0;\n          }\n          if \
(hasMorphColors === true) {\n            \
morph.fromBufferAttribute(morphColor, j);\n            buffer2[offset + \
stride + 8] = morph.x;\n            buffer2[offset + stride + 9] = morph.y;\n \
           buffer2[offset + stride + 10] = morph.z;\n            \
buffer2[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;\n    \
      }\n        }\n      }\n      entry = {\n        count: \
morphTargetsCount,\n        texture: texture2,\n        size: new \
Vector2(width, height)\n      };\n      morphTextures.set(geometry, entry);\n \
     geometry.addEventListener(\"dispose\", disposeTexture);\n    }\n    if \
(object.isInstancedMesh === true && object.morphTexture !== null) {\n      \
program.getUniforms().setValue(gl, \"morphTexture\", object.morphTexture, \
textures);\n    } else {\n      let morphInfluencesSum = 0;\n      for (let i \
= 0; i < objectInfluences.length; i++) {\n        morphInfluencesSum += \
objectInfluences[i];\n      }\n      const morphBaseInfluence = \
geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      \
program.getUniforms().setValue(gl, \"morphTargetBaseInfluence\", \
morphBaseInfluence);\n      program.getUniforms().setValue(gl, \
\"morphTargetInfluences\", objectInfluences);\n    }\n    \
program.getUniforms().setValue(gl, \"morphTargetsTexture\", entry.texture, \
textures);\n    program.getUniforms().setValue(gl, \
\"morphTargetsTextureSize\", entry.size);\n  }\n  return {\n    update: \
update4\n  };\n}\nfunction WebGLObjects(gl, geometries, attributes, info) {\n \
 let updateMap = /* @__PURE__ */ new WeakMap();\n  function update4(object) \
{\n    const frame2 = info.render.frame;\n    const geometry = \
object.geometry;\n    const buffergeometry = geometries.get(object, \
geometry);\n    if (updateMap.get(buffergeometry) !== frame2) {\n      \
geometries.update(buffergeometry);\n      updateMap.set(buffergeometry, \
frame2);\n    }\n    if (object.isInstancedMesh) {\n      if \
(object.hasEventListener(\"dispose\", onInstancedMeshDispose) === false) {\n  \
      object.addEventListener(\"dispose\", onInstancedMeshDispose);\n      \
}\n      if (updateMap.get(object) !== frame2) {\n        \
attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);\n        if \
(object.instanceColor !== null) {\n          \
attributes.update(object.instanceColor, gl.ARRAY_BUFFER);\n        }\n        \
updateMap.set(object, frame2);\n      }\n    }\n    if (object.isSkinnedMesh) \
{\n      const skeleton = object.skeleton;\n      if (updateMap.get(skeleton) \
!== frame2) {\n        skeleton.update();\n        updateMap.set(skeleton, \
frame2);\n      }\n    }\n    return buffergeometry;\n  }\n  function \
dispose() {\n    updateMap = /* @__PURE__ */ new WeakMap();\n  }\n  function \
onInstancedMeshDispose(event) {\n    const instancedMesh = event.target;\n    \
instancedMesh.removeEventListener(\"dispose\", onInstancedMeshDispose);\n    \
attributes.remove(instancedMesh.instanceMatrix);\n    if \
(instancedMesh.instanceColor !== null) \
attributes.remove(instancedMesh.instanceColor);\n  }\n  return {\n    update: \
update4,\n    dispose\n  };\n}\nvar DepthTexture = class extends Texture {\n  \
constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, \
anisotropy2, format2 = DepthFormat) {\n    if (format2 !== DepthFormat && \
format2 !== DepthStencilFormat) {\n      throw new Error(\"DepthTexture \
format must be either THREE.DepthFormat or THREE.DepthStencilFormat\");\n    \
}\n    if (type === void 0 && format2 === DepthFormat) type = \
UnsignedIntType;\n    if (type === void 0 && format2 === DepthStencilFormat) \
type = UnsignedInt248Type;\n    super(null, mapping, wrapS, wrapT, magFilter, \
minFilter, format2, type, anisotropy2);\n    this.isDepthTexture = true;\n    \
this.image = { width, height };\n    this.magFilter = magFilter !== void 0 ? \
magFilter : NearestFilter;\n    this.minFilter = minFilter !== void 0 ? \
minFilter : NearestFilter;\n    this.flipY = false;\n    this.generateMipmaps \
= false;\n    this.compareFunction = null;\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.compareFunction = source.compareFunction;\n    \
return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n   \
 if (this.compareFunction !== null) data.compareFunction = \
this.compareFunction;\n    return data;\n  }\n};\nvar emptyTexture = /* \
@__PURE__ */ new Texture();\nvar emptyShadowTexture = /* @__PURE__ */ new \
DepthTexture(1, 1);\nvar emptyArrayTexture = /* @__PURE__ */ new \
DataArrayTexture();\nvar empty3dTexture = /* @__PURE__ */ new \
Data3DTexture();\nvar emptyCubeTexture = /* @__PURE__ */ new \
CubeTexture();\nvar arrayCacheF32 = [];\nvar arrayCacheI32 = [];\nvar \
mat4array = new Float32Array(16);\nvar mat3array = new Float32Array(9);\nvar \
mat2array = new Float32Array(4);\nfunction flatten(array, nBlocks, blockSize) \
{\n  const firstElem = array[0];\n  if (firstElem <= 0 || firstElem > 0) \
return array;\n  const n = nBlocks * blockSize;\n  let r = \
arrayCacheF32[n];\n  if (r === void 0) {\n    r = new Float32Array(n);\n    \
arrayCacheF32[n] = r;\n  }\n  if (nBlocks !== 0) {\n    firstElem.toArray(r, \
0);\n    for (let i = 1, offset = 0; i !== nBlocks; ++i) {\n      offset += \
blockSize;\n      array[i].toArray(r, offset);\n    }\n  }\n  return \
r;\n}\nfunction arraysEqual(a2, b) {\n  if (a2.length !== b.length) return \
false;\n  for (let i = 0, l = a2.length; i < l; i++) {\n    if (a2[i] !== \
b[i]) return false;\n  }\n  return true;\n}\nfunction copyArray(a2, b) {\n  \
for (let i = 0, l = b.length; i < l; i++) {\n    a2[i] = b[i];\n  \
}\n}\nfunction allocTexUnits(textures, n) {\n  let r = arrayCacheI32[n];\n  \
if (r === void 0) {\n    r = new Int32Array(n);\n    arrayCacheI32[n] = r;\n  \
}\n  for (let i = 0; i !== n; ++i) {\n    r[i] = \
textures.allocateTextureUnit();\n  }\n  return r;\n}\nfunction \
setValueV1f(gl, v) {\n  const cache2 = this.cache;\n  if (cache2[0] === v) \
return;\n  gl.uniform1f(this.addr, v);\n  cache2[0] = v;\n}\nfunction \
setValueV2f(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n \
   if (cache2[0] !== v.x || cache2[1] !== v.y) {\n      \
gl.uniform2f(this.addr, v.x, v.y);\n      cache2[0] = v.x;\n      cache2[1] = \
v.y;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    \
gl.uniform2fv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction \
setValueV3f(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n \
   if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z) {\n      \
gl.uniform3f(this.addr, v.x, v.y, v.z);\n      cache2[0] = v.x;\n      \
cache2[1] = v.y;\n      cache2[2] = v.z;\n    }\n  } else if (v.r !== void 0) \
{\n    if (cache2[0] !== v.r || cache2[1] !== v.g || cache2[2] !== v.b) {\n   \
   gl.uniform3f(this.addr, v.r, v.g, v.b);\n      cache2[0] = v.r;\n      \
cache2[1] = v.g;\n      cache2[2] = v.b;\n    }\n  } else {\n    if \
(arraysEqual(cache2, v)) return;\n    gl.uniform3fv(this.addr, v);\n    \
copyArray(cache2, v);\n  }\n}\nfunction setValueV4f(gl, v) {\n  const cache2 \
= this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || \
cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {\n      \
gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n      cache2[0] = v.x;\n      \
cache2[1] = v.y;\n      cache2[2] = v.z;\n      cache2[3] = v.w;\n    }\n  } \
else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform4fv(this.addr, \
v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueM2(gl, v) {\n  const \
cache2 = this.cache;\n  const elements = v.elements;\n  if (elements === void \
0) {\n    if (arraysEqual(cache2, v)) return;\n    \
gl.uniformMatrix2fv(this.addr, false, v);\n    copyArray(cache2, v);\n  } \
else {\n    if (arraysEqual(cache2, elements)) return;\n    \
mat2array.set(elements);\n    gl.uniformMatrix2fv(this.addr, false, \
mat2array);\n    copyArray(cache2, elements);\n  }\n}\nfunction \
setValueM3(gl, v) {\n  const cache2 = this.cache;\n  const elements = \
v.elements;\n  if (elements === void 0) {\n    if (arraysEqual(cache2, v)) \
return;\n    gl.uniformMatrix3fv(this.addr, false, v);\n    copyArray(cache2, \
v);\n  } else {\n    if (arraysEqual(cache2, elements)) return;\n    \
mat3array.set(elements);\n    gl.uniformMatrix3fv(this.addr, false, \
mat3array);\n    copyArray(cache2, elements);\n  }\n}\nfunction \
setValueM4(gl, v) {\n  const cache2 = this.cache;\n  const elements = \
v.elements;\n  if (elements === void 0) {\n    if (arraysEqual(cache2, v)) \
return;\n    gl.uniformMatrix4fv(this.addr, false, v);\n    copyArray(cache2, \
v);\n  } else {\n    if (arraysEqual(cache2, elements)) return;\n    \
mat4array.set(elements);\n    gl.uniformMatrix4fv(this.addr, false, \
mat4array);\n    copyArray(cache2, elements);\n  }\n}\nfunction \
setValueV1i(gl, v) {\n  const cache2 = this.cache;\n  if (cache2[0] === v) \
return;\n  gl.uniform1i(this.addr, v);\n  cache2[0] = v;\n}\nfunction \
setValueV2i(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n \
   if (cache2[0] !== v.x || cache2[1] !== v.y) {\n      \
gl.uniform2i(this.addr, v.x, v.y);\n      cache2[0] = v.x;\n      cache2[1] = \
v.y;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    \
gl.uniform2iv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction \
setValueV3i(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n \
   if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z) {\n      \
gl.uniform3i(this.addr, v.x, v.y, v.z);\n      cache2[0] = v.x;\n      \
cache2[1] = v.y;\n      cache2[2] = v.z;\n    }\n  } else {\n    if \
(arraysEqual(cache2, v)) return;\n    gl.uniform3iv(this.addr, v);\n    \
copyArray(cache2, v);\n  }\n}\nfunction setValueV4i(gl, v) {\n  const cache2 \
= this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || \
cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {\n      \
gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);\n      cache2[0] = v.x;\n      \
cache2[1] = v.y;\n      cache2[2] = v.z;\n      cache2[3] = v.w;\n    }\n  } \
else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform4iv(this.addr, \
v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueV1ui(gl, v) {\n  \
const cache2 = this.cache;\n  if (cache2[0] === v) return;\n  \
gl.uniform1ui(this.addr, v);\n  cache2[0] = v;\n}\nfunction setValueV2ui(gl, \
v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if \
(cache2[0] !== v.x || cache2[1] !== v.y) {\n      gl.uniform2ui(this.addr, \
v.x, v.y);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n    }\n  } else \
{\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform2uiv(this.addr, \
v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueV3ui(gl, v) {\n  \
const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== \
v.x || cache2[1] !== v.y || cache2[2] !== v.z) {\n      \
gl.uniform3ui(this.addr, v.x, v.y, v.z);\n      cache2[0] = v.x;\n      \
cache2[1] = v.y;\n      cache2[2] = v.z;\n    }\n  } else {\n    if \
(arraysEqual(cache2, v)) return;\n    gl.uniform3uiv(this.addr, v);\n    \
copyArray(cache2, v);\n  }\n}\nfunction setValueV4ui(gl, v) {\n  const cache2 \
= this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || \
cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {\n      \
gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);\n      cache2[0] = v.x;\n      \
cache2[1] = v.y;\n      cache2[2] = v.z;\n      cache2[3] = v.w;\n    }\n  } \
else {\n    if (arraysEqual(cache2, v)) return;\n    \
gl.uniform4uiv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction \
setValueT1(gl, v, textures) {\n  const cache2 = this.cache;\n  const unit = \
textures.allocateTextureUnit();\n  if (cache2[0] !== unit) {\n    \
gl.uniform1i(this.addr, unit);\n    cache2[0] = unit;\n  }\n  let \
emptyTexture2D;\n  if (this.type === gl.SAMPLER_2D_SHADOW) {\n    \
emptyShadowTexture.compareFunction = LessEqualCompare;\n    emptyTexture2D = \
emptyShadowTexture;\n  } else {\n    emptyTexture2D = emptyTexture;\n  }\n  \
textures.setTexture2D(v || emptyTexture2D, unit);\n}\nfunction \
setValueT3D1(gl, v, textures) {\n  const cache2 = this.cache;\n  const unit = \
textures.allocateTextureUnit();\n  if (cache2[0] !== unit) {\n    \
gl.uniform1i(this.addr, unit);\n    cache2[0] = unit;\n  }\n  \
textures.setTexture3D(v || empty3dTexture, unit);\n}\nfunction setValueT6(gl, \
v, textures) {\n  const cache2 = this.cache;\n  const unit = \
textures.allocateTextureUnit();\n  if (cache2[0] !== unit) {\n    \
gl.uniform1i(this.addr, unit);\n    cache2[0] = unit;\n  }\n  \
textures.setTextureCube(v || emptyCubeTexture, unit);\n}\nfunction \
setValueT2DArray1(gl, v, textures) {\n  const cache2 = this.cache;\n  const \
unit = textures.allocateTextureUnit();\n  if (cache2[0] !== unit) {\n    \
gl.uniform1i(this.addr, unit);\n    cache2[0] = unit;\n  }\n  \
textures.setTexture2DArray(v || emptyArrayTexture, unit);\n}\nfunction \
getSingularSetter(type) {\n  switch (type) {\n    case 5126:\n      return \
setValueV1f;\n    // FLOAT\n    case 35664:\n      return setValueV2f;\n    \
// _VEC2\n    case 35665:\n      return setValueV3f;\n    // _VEC3\n    case \
35666:\n      return setValueV4f;\n    // _VEC4\n    case 35674:\n      \
return setValueM2;\n    // _MAT2\n    case 35675:\n      return setValueM3;\n \
   // _MAT3\n    case 35676:\n      return setValueM4;\n    // _MAT4\n    \
case 5124:\n    case 35670:\n      return setValueV1i;\n    // INT, BOOL\n    \
case 35667:\n    case 35671:\n      return setValueV2i;\n    // _VEC2\n    \
case 35668:\n    case 35672:\n      return setValueV3i;\n    // _VEC3\n    \
case 35669:\n    case 35673:\n      return setValueV4i;\n    // _VEC4\n    \
case 5125:\n      return setValueV1ui;\n    // UINT\n    case 36294:\n      \
return setValueV2ui;\n    // _VEC2\n    case 36295:\n      return \
setValueV3ui;\n    // _VEC3\n    case 36296:\n      return setValueV4ui;\n    \
// _VEC4\n    case 35678:\n    // SAMPLER_2D\n    case 36198:\n    // \
SAMPLER_EXTERNAL_OES\n    case 36298:\n    // INT_SAMPLER_2D\n    case \
36306:\n    // UNSIGNED_INT_SAMPLER_2D\n    case 35682:\n      return \
setValueT1;\n    case 35679:\n    // SAMPLER_3D\n    case 36299:\n    // \
INT_SAMPLER_3D\n    case 36307:\n      return setValueT3D1;\n    case \
35680:\n    // SAMPLER_CUBE\n    case 36300:\n    // INT_SAMPLER_CUBE\n    \
case 36308:\n    // UNSIGNED_INT_SAMPLER_CUBE\n    case 36293:\n      return \
setValueT6;\n    case 36289:\n    // SAMPLER_2D_ARRAY\n    case 36303:\n    \
// INT_SAMPLER_2D_ARRAY\n    case 36311:\n    // \
UNSIGNED_INT_SAMPLER_2D_ARRAY\n    case 36292:\n      return \
setValueT2DArray1;\n  }\n}\nfunction setValueV1fArray(gl, v) {\n  \
gl.uniform1fv(this.addr, v);\n}\nfunction setValueV2fArray(gl, v) {\n  const \
data = flatten(v, this.size, 2);\n  gl.uniform2fv(this.addr, \
data);\n}\nfunction setValueV3fArray(gl, v) {\n  const data = flatten(v, \
this.size, 3);\n  gl.uniform3fv(this.addr, data);\n}\nfunction \
setValueV4fArray(gl, v) {\n  const data = flatten(v, this.size, 4);\n  \
gl.uniform4fv(this.addr, data);\n}\nfunction setValueM2Array(gl, v) {\n  \
const data = flatten(v, this.size, 4);\n  gl.uniformMatrix2fv(this.addr, \
false, data);\n}\nfunction setValueM3Array(gl, v) {\n  const data = \
flatten(v, this.size, 9);\n  gl.uniformMatrix3fv(this.addr, false, \
data);\n}\nfunction setValueM4Array(gl, v) {\n  const data = flatten(v, \
this.size, 16);\n  gl.uniformMatrix4fv(this.addr, false, data);\n}\nfunction \
setValueV1iArray(gl, v) {\n  gl.uniform1iv(this.addr, v);\n}\nfunction \
setValueV2iArray(gl, v) {\n  gl.uniform2iv(this.addr, v);\n}\nfunction \
setValueV3iArray(gl, v) {\n  gl.uniform3iv(this.addr, v);\n}\nfunction \
setValueV4iArray(gl, v) {\n  gl.uniform4iv(this.addr, v);\n}\nfunction \
setValueV1uiArray(gl, v) {\n  gl.uniform1uiv(this.addr, v);\n}\nfunction \
setValueV2uiArray(gl, v) {\n  gl.uniform2uiv(this.addr, v);\n}\nfunction \
setValueV3uiArray(gl, v) {\n  gl.uniform3uiv(this.addr, v);\n}\nfunction \
setValueV4uiArray(gl, v) {\n  gl.uniform4uiv(this.addr, v);\n}\nfunction \
setValueT1Array(gl, v, textures) {\n  const cache2 = this.cache;\n  const n = \
v.length;\n  const units = allocTexUnits(textures, n);\n  if \
(!arraysEqual(cache2, units)) {\n    gl.uniform1iv(this.addr, units);\n    \
copyArray(cache2, units);\n  }\n  for (let i = 0; i !== n; ++i) {\n    \
textures.setTexture2D(v[i] || emptyTexture, units[i]);\n  }\n}\nfunction \
setValueT3DArray(gl, v, textures) {\n  const cache2 = this.cache;\n  const n \
= v.length;\n  const units = allocTexUnits(textures, n);\n  if \
(!arraysEqual(cache2, units)) {\n    gl.uniform1iv(this.addr, units);\n    \
copyArray(cache2, units);\n  }\n  for (let i = 0; i !== n; ++i) {\n    \
textures.setTexture3D(v[i] || empty3dTexture, units[i]);\n  }\n}\nfunction \
setValueT6Array(gl, v, textures) {\n  const cache2 = this.cache;\n  const n = \
v.length;\n  const units = allocTexUnits(textures, n);\n  if \
(!arraysEqual(cache2, units)) {\n    gl.uniform1iv(this.addr, units);\n    \
copyArray(cache2, units);\n  }\n  for (let i = 0; i !== n; ++i) {\n    \
textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);\n  \
}\n}\nfunction setValueT2DArrayArray(gl, v, textures) {\n  const cache2 = \
this.cache;\n  const n = v.length;\n  const units = allocTexUnits(textures, \
n);\n  if (!arraysEqual(cache2, units)) {\n    gl.uniform1iv(this.addr, \
units);\n    copyArray(cache2, units);\n  }\n  for (let i = 0; i !== n; ++i) \
{\n    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);\n  \
}\n}\nfunction getPureArraySetter(type) {\n  switch (type) {\n    case \
5126:\n      return setValueV1fArray;\n    // FLOAT\n    case 35664:\n      \
return setValueV2fArray;\n    // _VEC2\n    case 35665:\n      return \
setValueV3fArray;\n    // _VEC3\n    case 35666:\n      return \
setValueV4fArray;\n    // _VEC4\n    case 35674:\n      return \
setValueM2Array;\n    // _MAT2\n    case 35675:\n      return \
setValueM3Array;\n    // _MAT3\n    case 35676:\n      return \
setValueM4Array;\n    // _MAT4\n    case 5124:\n    case 35670:\n      return \
setValueV1iArray;\n    // INT, BOOL\n    case 35667:\n    case 35671:\n      \
return setValueV2iArray;\n    // _VEC2\n    case 35668:\n    case 35672:\n    \
  return setValueV3iArray;\n    // _VEC3\n    case 35669:\n    case 35673:\n  \
    return setValueV4iArray;\n    // _VEC4\n    case 5125:\n      return \
setValueV1uiArray;\n    // UINT\n    case 36294:\n      return \
setValueV2uiArray;\n    // _VEC2\n    case 36295:\n      return \
setValueV3uiArray;\n    // _VEC3\n    case 36296:\n      return \
setValueV4uiArray;\n    // _VEC4\n    case 35678:\n    // SAMPLER_2D\n    \
case 36198:\n    // SAMPLER_EXTERNAL_OES\n    case 36298:\n    // \
INT_SAMPLER_2D\n    case 36306:\n    // UNSIGNED_INT_SAMPLER_2D\n    case \
35682:\n      return setValueT1Array;\n    case 35679:\n    // SAMPLER_3D\n   \
 case 36299:\n    // INT_SAMPLER_3D\n    case 36307:\n      return \
setValueT3DArray;\n    case 35680:\n    // SAMPLER_CUBE\n    case 36300:\n    \
// INT_SAMPLER_CUBE\n    case 36308:\n    // UNSIGNED_INT_SAMPLER_CUBE\n    \
case 36293:\n      return setValueT6Array;\n    case 36289:\n    // \
SAMPLER_2D_ARRAY\n    case 36303:\n    // INT_SAMPLER_2D_ARRAY\n    case \
36311:\n    // UNSIGNED_INT_SAMPLER_2D_ARRAY\n    case 36292:\n      return \
setValueT2DArrayArray;\n  }\n}\nvar SingleUniform = class {\n  \
constructor(id2, activeInfo, addr) {\n    this.id = id2;\n    this.addr = \
addr;\n    this.cache = [];\n    this.type = activeInfo.type;\n    \
this.setValue = getSingularSetter(activeInfo.type);\n  }\n};\nvar \
PureArrayUniform = class {\n  constructor(id2, activeInfo, addr) {\n    \
this.id = id2;\n    this.addr = addr;\n    this.cache = [];\n    this.type = \
activeInfo.type;\n    this.size = activeInfo.size;\n    this.setValue = \
getPureArraySetter(activeInfo.type);\n  }\n};\nvar StructuredUniform = class \
{\n  constructor(id2) {\n    this.id = id2;\n    this.seq = [];\n    this.map \
= {};\n  }\n  setValue(gl, value, textures) {\n    const seq = this.seq;\n    \
for (let i = 0, n = seq.length; i !== n; ++i) {\n      const u = seq[i];\n    \
  u.setValue(gl, value[u.id], textures);\n    }\n  }\n};\nvar RePathPart = \
/(\\w+)(\\])?(\\[|\\.)?/g;\nfunction addUniform(container, uniformObject) {\n \
 container.seq.push(uniformObject);\n  container.map[uniformObject.id] = \
uniformObject;\n}\nfunction parseUniform(activeInfo, addr, container) {\n  \
const path = activeInfo.name, pathLength = path.length;\n  \
RePathPart.lastIndex = 0;\n  while (true) {\n    const match = \
RePathPart.exec(path), matchEnd = RePathPart.lastIndex;\n    let id2 = \
match[1];\n    const idIsIndex = match[2] === \"]\", subscript = match[3];\n  \
  if (idIsIndex) id2 = id2 | 0;\n    if (subscript === void 0 || subscript \
=== \"[\" && matchEnd + 2 === pathLength) {\n      addUniform(container, \
subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new \
PureArrayUniform(id2, activeInfo, addr));\n      break;\n    } else {\n      \
const map = container.map;\n      let next = map[id2];\n      if (next === \
void 0) {\n        next = new StructuredUniform(id2);\n        \
addUniform(container, next);\n      }\n      container = next;\n    }\n  \
}\n}\nvar WebGLUniforms = class {\n  constructor(gl, program) {\n    this.seq \
= [];\n    this.map = {};\n    const n = gl.getProgramParameter(program, \
gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < n; ++i) {\n      const info = \
gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, \
info.name);\n      parseUniform(info, addr, this);\n    }\n  }\n  \
setValue(gl, name, value, textures) {\n    const u = this.map[name];\n    if \
(u !== void 0) u.setValue(gl, value, textures);\n  }\n  setOptional(gl, \
object, name) {\n    const v = object[name];\n    if (v !== void 0) \
this.setValue(gl, name, v);\n  }\n  static upload(gl, seq, values, textures) \
{\n    for (let i = 0, n = seq.length; i !== n; ++i) {\n      const u = \
seq[i], v = values[u.id];\n      if (v.needsUpdate !== false) {\n        \
u.setValue(gl, v.value, textures);\n      }\n    }\n  }\n  static \
seqWithValue(seq, values) {\n    const r = [];\n    for (let i = 0, n = \
seq.length; i !== n; ++i) {\n      const u = seq[i];\n      if (u.id in \
values) r.push(u);\n    }\n    return r;\n  }\n};\nfunction WebGLShader(gl, \
type, string) {\n  const shader = gl.createShader(type);\n  \
gl.shaderSource(shader, string);\n  gl.compileShader(shader);\n  return \
shader;\n}\nvar COMPLETION_STATUS_KHR = 37297;\nvar programIdCount = \
0;\nfunction handleSource(string, errorLine) {\n  const lines = \
string.split(\"\\n\");\n  const lines2 = [];\n  const from = \
Math.max(errorLine - 6, 0);\n  const to = Math.min(errorLine + 6, \
lines.length);\n  for (let i = from; i < to; i++) {\n    const line = i + \
1;\n    lines2.push(`${line === errorLine ? \">\" : \" \"} ${line}: \
${lines[i]}`);\n  }\n  return lines2.join(\"\\n\");\n}\nvar _m0 = /* \
@__PURE__ */ new Matrix3();\nfunction getEncodingComponents(colorSpace) {\n  \
ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, \
colorSpace);\n  const encodingMatrix = `mat3( ${_m0.elements.map((v) => \
v.toFixed(4))} )`;\n  switch (ColorManagement.getTransfer(colorSpace)) {\n    \
case LinearTransfer:\n      return [encodingMatrix, \
\"LinearTransferOETF\"];\n    case SRGBTransfer:\n      return \
[encodingMatrix, \"sRGBTransferOETF\"];\n    default:\n      \
console.warn(\"THREE.WebGLProgram: Unsupported color space: \", \
colorSpace);\n      return [encodingMatrix, \"LinearTransferOETF\"];\n  \
}\n}\nfunction getShaderErrors(gl, shader, type) {\n  const status = \
gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  const errors = \
gl.getShaderInfoLog(shader).trim();\n  if (status && errors === \"\") return \
\"\";\n  const errorMatches = /ERROR: 0:(\\d+)/.exec(errors);\n  if \
(errorMatches) {\n    const errorLine = parseInt(errorMatches[1]);\n    \
return type.toUpperCase() + \"\\n\\n\" + errors + \"\\n\\n\" + \
handleSource(gl.getShaderSource(shader), errorLine);\n  } else {\n    return \
errors;\n  }\n}\nfunction getTexelEncodingFunction(functionName, colorSpace) \
{\n  const components = getEncodingComponents(colorSpace);\n  return [\n    \
`vec4 ${functionName}( vec4 value ) {`,\n    `\treturn ${components[1]}( \
vec4( value.rgb * ${components[0]}, value.a ) );`,\n    \"}\"\n  \
].join(\"\\n\");\n}\nfunction getToneMappingFunction(functionName, \
toneMapping2) {\n  let toneMappingName;\n  switch (toneMapping2) {\n    case \
LinearToneMapping:\n      toneMappingName = \"Linear\";\n      break;\n    \
case ReinhardToneMapping:\n      toneMappingName = \"Reinhard\";\n      \
break;\n    case CineonToneMapping:\n      toneMappingName = \"Cineon\";\n    \
  break;\n    case ACESFilmicToneMapping:\n      toneMappingName = \
\"ACESFilmic\";\n      break;\n    case AgXToneMapping:\n      \
toneMappingName = \"AgX\";\n      break;\n    case NeutralToneMapping:\n      \
toneMappingName = \"Neutral\";\n      break;\n    case CustomToneMapping:\n   \
   toneMappingName = \"Custom\";\n      break;\n    default:\n      \
console.warn(\"THREE.WebGLProgram: Unsupported toneMapping:\", \
toneMapping2);\n      toneMappingName = \"Linear\";\n  }\n  return \"vec3 \" \
+ functionName + \"( vec3 color ) { return \" + toneMappingName + \
\"ToneMapping( color ); }\";\n}\nvar _v0$1 = /* @__PURE__ */ new \
Vector3();\nfunction getLuminanceFunction() {\n  \
ColorManagement.getLuminanceCoefficients(_v0$1);\n  const r = \
_v0$1.x.toFixed(4);\n  const g = _v0$1.y.toFixed(4);\n  const b = \
_v0$1.z.toFixed(4);\n  return [\n    \"float luminance( const in vec3 rgb ) \
{\",\n    `\tconst vec3 weights = vec3( ${r}, ${g}, ${b} );`,\n    \"\treturn \
dot( weights, rgb );\",\n    \"}\"\n  ].join(\"\\n\");\n}\nfunction \
generateVertexExtensions(parameters) {\n  const chunks = [\n    \
parameters.extensionClipCullDistance ? \"#extension \
GL_ANGLE_clip_cull_distance : require\" : \"\",\n    \
parameters.extensionMultiDraw ? \"#extension GL_ANGLE_multi_draw : require\" \
: \"\"\n  ];\n  return \
chunks.filter(filterEmptyLine).join(\"\\n\");\n}\nfunction \
generateDefines(defines) {\n  const chunks = [];\n  for (const name in \
defines) {\n    const value = defines[name];\n    if (value === false) \
continue;\n    chunks.push(\"#define \" + name + \" \" + value);\n  }\n  \
return chunks.join(\"\\n\");\n}\nfunction fetchAttributeLocations(gl, \
program) {\n  const attributes = {};\n  const n = \
gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let i = 0; i < \
n; i++) {\n    const info = gl.getActiveAttrib(program, i);\n    const name = \
info.name;\n    let locationSize = 1;\n    if (info.type === gl.FLOAT_MAT2) \
locationSize = 2;\n    if (info.type === gl.FLOAT_MAT3) locationSize = 3;\n   \
 if (info.type === gl.FLOAT_MAT4) locationSize = 4;\n    attributes[name] = \
{\n      type: info.type,\n      location: gl.getAttribLocation(program, \
name),\n      locationSize\n    };\n  }\n  return attributes;\n}\nfunction \
filterEmptyLine(string) {\n  return string !== \"\";\n}\nfunction \
replaceLightNums(string, parameters) {\n  const numSpotLightCoords = \
parameters.numSpotLightShadows + parameters.numSpotLightMaps - \
parameters.numSpotLightShadowsWithMaps;\n  return \
string.replace(/NUM_DIR_LIGHTS/g, \
parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, \
parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, \
parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, \
numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, \
parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, \
parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, \
parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, \
parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, \
parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, \
parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, \
parameters.numPointLightShadows);\n}\nfunction \
replaceClippingPlaneNums(string, parameters) {\n  return \
string.replace(/NUM_CLIPPING_PLANES/g, \
parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, \
parameters.numClippingPlanes - parameters.numClipIntersection);\n}\nvar \
includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\nfunction \
resolveIncludes(string) {\n  return string.replace(includePattern, \
includeReplacer);\n}\nvar shaderChunkMap = /* @__PURE__ */ new \
Map();\nfunction includeReplacer(match, include) {\n  let string = \
ShaderChunk[include];\n  if (string === void 0) {\n    const newInclude = \
shaderChunkMap.get(include);\n    if (newInclude !== void 0) {\n      string \
= ShaderChunk[newInclude];\n      console.warn('THREE.WebGLRenderer: Shader \
chunk \"%s\" has been deprecated. Use \"%s\" instead.', include, \
newInclude);\n    } else {\n      throw new Error(\"Can not resolve #include \
<\" + include + \">\");\n    }\n  }\n  return \
resolveIncludes(string);\n}\nvar unrollLoopPattern = /#pragma \
unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*\
(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma \
unroll_loop_end/g;\nfunction unrollLoops(string) {\n  return \
string.replace(unrollLoopPattern, loopReplacer);\n}\nfunction \
loopReplacer(match, start, end, snippet) {\n  let string = \"\";\n  for (let \
i = parseInt(start); i < parseInt(end); i++) {\n    string += \
snippet.replace(/\\[\\s*i\\s*\\]/g, \"[ \" + i + \" \
]\").replace(/UNROLLED_LOOP_INDEX/g, i);\n  }\n  return string;\n}\nfunction \
generatePrecision(parameters) {\n  let precisionstring = `precision \
${parameters.precision} float;\n\tprecision ${parameters.precision} \
int;\n\tprecision ${parameters.precision} sampler2D;\n\tprecision \
${parameters.precision} samplerCube;\n\tprecision ${parameters.precision} \
sampler3D;\n\tprecision ${parameters.precision} sampler2DArray;\n\tprecision \
${parameters.precision} sampler2DShadow;\n\tprecision ${parameters.precision} \
samplerCubeShadow;\n\tprecision ${parameters.precision} \
sampler2DArrayShadow;\n\tprecision ${parameters.precision} \
isampler2D;\n\tprecision ${parameters.precision} isampler3D;\n\tprecision \
${parameters.precision} isamplerCube;\n\tprecision ${parameters.precision} \
isampler2DArray;\n\tprecision ${parameters.precision} \
usampler2D;\n\tprecision ${parameters.precision} usampler3D;\n\tprecision \
${parameters.precision} usamplerCube;\n\tprecision ${parameters.precision} \
usampler2DArray;\n\t`;\n  if (parameters.precision === \"highp\") {\n    \
precisionstring += \"\\n#define HIGH_PRECISION\";\n  } else if \
(parameters.precision === \"mediump\") {\n    precisionstring += \"\\n#define \
MEDIUM_PRECISION\";\n  } else if (parameters.precision === \"lowp\") {\n    \
precisionstring += \"\\n#define LOW_PRECISION\";\n  }\n  return \
precisionstring;\n}\nfunction generateShadowMapTypeDefine(parameters) {\n  \
let shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\n  if \
(parameters.shadowMapType === PCFShadowMap) {\n    shadowMapTypeDefine = \
\"SHADOWMAP_TYPE_PCF\";\n  } else if (parameters.shadowMapType === \
PCFSoftShadowMap) {\n    shadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\n \
 } else if (parameters.shadowMapType === VSMShadowMap) {\n    \
shadowMapTypeDefine = \"SHADOWMAP_TYPE_VSM\";\n  }\n  return \
shadowMapTypeDefine;\n}\nfunction generateEnvMapTypeDefine(parameters) {\n  \
let envMapTypeDefine = \"ENVMAP_TYPE_CUBE\";\n  if (parameters.envMap) {\n    \
switch (parameters.envMapMode) {\n      case CubeReflectionMapping:\n      \
case CubeRefractionMapping:\n        envMapTypeDefine = \
\"ENVMAP_TYPE_CUBE\";\n        break;\n      case CubeUVReflectionMapping:\n  \
      envMapTypeDefine = \"ENVMAP_TYPE_CUBE_UV\";\n        break;\n    }\n  \
}\n  return envMapTypeDefine;\n}\nfunction \
generateEnvMapModeDefine(parameters) {\n  let envMapModeDefine = \
\"ENVMAP_MODE_REFLECTION\";\n  if (parameters.envMap) {\n    switch \
(parameters.envMapMode) {\n      case CubeRefractionMapping:\n        \
envMapModeDefine = \"ENVMAP_MODE_REFRACTION\";\n        break;\n    }\n  }\n  \
return envMapModeDefine;\n}\nfunction \
generateEnvMapBlendingDefine(parameters) {\n  let envMapBlendingDefine = \
\"ENVMAP_BLENDING_NONE\";\n  if (parameters.envMap) {\n    switch \
(parameters.combine) {\n      case MultiplyOperation:\n        \
envMapBlendingDefine = \"ENVMAP_BLENDING_MULTIPLY\";\n        break;\n      \
case MixOperation:\n        envMapBlendingDefine = \"ENVMAP_BLENDING_MIX\";\n \
       break;\n      case AddOperation:\n        envMapBlendingDefine = \
\"ENVMAP_BLENDING_ADD\";\n        break;\n    }\n  }\n  return \
envMapBlendingDefine;\n}\nfunction generateCubeUVSize(parameters) {\n  const \
imageHeight = parameters.envMapCubeUVHeight;\n  if (imageHeight === null) \
return null;\n  const maxMip = Math.log2(imageHeight) - 2;\n  const \
texelHeight = 1 / imageHeight;\n  const texelWidth = 1 / (3 * \
Math.max(Math.pow(2, maxMip), 7 * 16));\n  return { texelWidth, texelHeight, \
maxMip };\n}\nfunction WebGLProgram(renderer3, cacheKey, parameters, \
bindingStates) {\n  const gl = renderer3.getContext();\n  const defines = \
parameters.defines;\n  let vertexShader = parameters.vertexShader;\n  let \
fragmentShader = parameters.fragmentShader;\n  const shadowMapTypeDefine = \
generateShadowMapTypeDefine(parameters);\n  const envMapTypeDefine = \
generateEnvMapTypeDefine(parameters);\n  const envMapModeDefine = \
generateEnvMapModeDefine(parameters);\n  const envMapBlendingDefine = \
generateEnvMapBlendingDefine(parameters);\n  const envMapCubeUVSize = \
generateCubeUVSize(parameters);\n  const customVertexExtensions = \
generateVertexExtensions(parameters);\n  const customDefines = \
generateDefines(defines);\n  const program = gl.createProgram();\n  let \
prefixVertex, prefixFragment;\n  let versionString = parameters.glslVersion ? \
\"#version \" + parameters.glslVersion + \"\\n\" : \"\";\n  if \
(parameters.isRawShaderMaterial) {\n    prefixVertex = [\n      \"#define \
SHADER_TYPE \" + parameters.shaderType,\n      \"#define SHADER_NAME \" + \
parameters.shaderName,\n      customDefines\n    \
].filter(filterEmptyLine).join(\"\\n\");\n    if (prefixVertex.length > 0) \
{\n      prefixVertex += \"\\n\";\n    }\n    prefixFragment = [\n      \
\"#define SHADER_TYPE \" + parameters.shaderType,\n      \"#define \
SHADER_NAME \" + parameters.shaderName,\n      customDefines\n    \
].filter(filterEmptyLine).join(\"\\n\");\n    if (prefixFragment.length > 0) \
{\n      prefixFragment += \"\\n\";\n    }\n  } else {\n    prefixVertex = \
[\n      generatePrecision(parameters),\n      \"#define SHADER_TYPE \" + \
parameters.shaderType,\n      \"#define SHADER_NAME \" + \
parameters.shaderName,\n      customDefines,\n      \
parameters.extensionClipCullDistance ? \"#define USE_CLIP_DISTANCE\" : \
\"\",\n      parameters.batching ? \"#define USE_BATCHING\" : \"\",\n      \
parameters.batchingColor ? \"#define USE_BATCHING_COLOR\" : \"\",\n      \
parameters.instancing ? \"#define USE_INSTANCING\" : \"\",\n      \
parameters.instancingColor ? \"#define USE_INSTANCING_COLOR\" : \"\",\n      \
parameters.instancingMorph ? \"#define USE_INSTANCING_MORPH\" : \"\",\n      \
parameters.useFog && parameters.fog ? \"#define USE_FOG\" : \"\",\n      \
parameters.useFog && parameters.fogExp2 ? \"#define FOG_EXP2\" : \"\",\n      \
parameters.map ? \"#define USE_MAP\" : \"\",\n      parameters.envMap ? \
\"#define USE_ENVMAP\" : \"\",\n      parameters.envMap ? \"#define \" + \
envMapModeDefine : \"\",\n      parameters.lightMap ? \"#define \
USE_LIGHTMAP\" : \"\",\n      parameters.aoMap ? \"#define USE_AOMAP\" : \
\"\",\n      parameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n      \
parameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n      \
parameters.normalMapObjectSpace ? \"#define USE_NORMALMAP_OBJECTSPACE\" : \
\"\",\n      parameters.normalMapTangentSpace ? \"#define \
USE_NORMALMAP_TANGENTSPACE\" : \"\",\n      parameters.displacementMap ? \
\"#define USE_DISPLACEMENTMAP\" : \"\",\n      parameters.emissiveMap ? \
\"#define USE_EMISSIVEMAP\" : \"\",\n      parameters.anisotropy ? \"#define \
USE_ANISOTROPY\" : \"\",\n      parameters.anisotropyMap ? \"#define \
USE_ANISOTROPYMAP\" : \"\",\n      parameters.clearcoatMap ? \"#define \
USE_CLEARCOATMAP\" : \"\",\n      parameters.clearcoatRoughnessMap ? \
\"#define USE_CLEARCOAT_ROUGHNESSMAP\" : \"\",\n      \
parameters.clearcoatNormalMap ? \"#define USE_CLEARCOAT_NORMALMAP\" : \"\",\n \
     parameters.iridescenceMap ? \"#define USE_IRIDESCENCEMAP\" : \"\",\n     \
 parameters.iridescenceThicknessMap ? \"#define \
USE_IRIDESCENCE_THICKNESSMAP\" : \"\",\n      parameters.specularMap ? \
\"#define USE_SPECULARMAP\" : \"\",\n      parameters.specularColorMap ? \
\"#define USE_SPECULAR_COLORMAP\" : \"\",\n      \
parameters.specularIntensityMap ? \"#define USE_SPECULAR_INTENSITYMAP\" : \
\"\",\n      parameters.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\",\n \
     parameters.metalnessMap ? \"#define USE_METALNESSMAP\" : \"\",\n      \
parameters.alphaMap ? \"#define USE_ALPHAMAP\" : \"\",\n      \
parameters.alphaHash ? \"#define USE_ALPHAHASH\" : \"\",\n      \
parameters.transmission ? \"#define USE_TRANSMISSION\" : \"\",\n      \
parameters.transmissionMap ? \"#define USE_TRANSMISSIONMAP\" : \"\",\n      \
parameters.thicknessMap ? \"#define USE_THICKNESSMAP\" : \"\",\n      \
parameters.sheenColorMap ? \"#define USE_SHEEN_COLORMAP\" : \"\",\n      \
parameters.sheenRoughnessMap ? \"#define USE_SHEEN_ROUGHNESSMAP\" : \"\",\n   \
   //\n      parameters.mapUv ? \"#define MAP_UV \" + parameters.mapUv : \
\"\",\n      parameters.alphaMapUv ? \"#define ALPHAMAP_UV \" + \
parameters.alphaMapUv : \"\",\n      parameters.lightMapUv ? \"#define \
LIGHTMAP_UV \" + parameters.lightMapUv : \"\",\n      parameters.aoMapUv ? \
\"#define AOMAP_UV \" + parameters.aoMapUv : \"\",\n      \
parameters.emissiveMapUv ? \"#define EMISSIVEMAP_UV \" + \
parameters.emissiveMapUv : \"\",\n      parameters.bumpMapUv ? \"#define \
BUMPMAP_UV \" + parameters.bumpMapUv : \"\",\n      parameters.normalMapUv ? \
\"#define NORMALMAP_UV \" + parameters.normalMapUv : \"\",\n      \
parameters.displacementMapUv ? \"#define DISPLACEMENTMAP_UV \" + \
parameters.displacementMapUv : \"\",\n      parameters.metalnessMapUv ? \
\"#define METALNESSMAP_UV \" + parameters.metalnessMapUv : \"\",\n      \
parameters.roughnessMapUv ? \"#define ROUGHNESSMAP_UV \" + \
parameters.roughnessMapUv : \"\",\n      parameters.anisotropyMapUv ? \
\"#define ANISOTROPYMAP_UV \" + parameters.anisotropyMapUv : \"\",\n      \
parameters.clearcoatMapUv ? \"#define CLEARCOATMAP_UV \" + \
parameters.clearcoatMapUv : \"\",\n      parameters.clearcoatNormalMapUv ? \
\"#define CLEARCOAT_NORMALMAP_UV \" + parameters.clearcoatNormalMapUv : \
\"\",\n      parameters.clearcoatRoughnessMapUv ? \"#define \
CLEARCOAT_ROUGHNESSMAP_UV \" + parameters.clearcoatRoughnessMapUv : \"\",\n   \
   parameters.iridescenceMapUv ? \"#define IRIDESCENCEMAP_UV \" + \
parameters.iridescenceMapUv : \"\",\n      \
parameters.iridescenceThicknessMapUv ? \"#define IRIDESCENCE_THICKNESSMAP_UV \
\" + parameters.iridescenceThicknessMapUv : \"\",\n      \
parameters.sheenColorMapUv ? \"#define SHEEN_COLORMAP_UV \" + \
parameters.sheenColorMapUv : \"\",\n      parameters.sheenRoughnessMapUv ? \
\"#define SHEEN_ROUGHNESSMAP_UV \" + parameters.sheenRoughnessMapUv : \"\",\n \
     parameters.specularMapUv ? \"#define SPECULARMAP_UV \" + \
parameters.specularMapUv : \"\",\n      parameters.specularColorMapUv ? \
\"#define SPECULAR_COLORMAP_UV \" + parameters.specularColorMapUv : \"\",\n   \
   parameters.specularIntensityMapUv ? \"#define SPECULAR_INTENSITYMAP_UV \" \
+ parameters.specularIntensityMapUv : \"\",\n      \
parameters.transmissionMapUv ? \"#define TRANSMISSIONMAP_UV \" + \
parameters.transmissionMapUv : \"\",\n      parameters.thicknessMapUv ? \
\"#define THICKNESSMAP_UV \" + parameters.thicknessMapUv : \"\",\n      //\n  \
    parameters.vertexTangents && parameters.flatShading === false ? \"#define \
USE_TANGENT\" : \"\",\n      parameters.vertexColors ? \"#define USE_COLOR\" \
: \"\",\n      parameters.vertexAlphas ? \"#define USE_COLOR_ALPHA\" : \
\"\",\n      parameters.vertexUv1s ? \"#define USE_UV1\" : \"\",\n      \
parameters.vertexUv2s ? \"#define USE_UV2\" : \"\",\n      \
parameters.vertexUv3s ? \"#define USE_UV3\" : \"\",\n      \
parameters.pointsUvs ? \"#define USE_POINTS_UV\" : \"\",\n      \
parameters.flatShading ? \"#define FLAT_SHADED\" : \"\",\n      \
parameters.skinning ? \"#define USE_SKINNING\" : \"\",\n      \
parameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n      \
parameters.morphNormals && parameters.flatShading === false ? \"#define \
USE_MORPHNORMALS\" : \"\",\n      parameters.morphColors ? \"#define \
USE_MORPHCOLORS\" : \"\",\n      parameters.morphTargetsCount > 0 ? \"#define \
MORPHTARGETS_TEXTURE_STRIDE \" + parameters.morphTextureStride : \"\",\n      \
parameters.morphTargetsCount > 0 ? \"#define MORPHTARGETS_COUNT \" + \
parameters.morphTargetsCount : \"\",\n      parameters.doubleSided ? \
\"#define DOUBLE_SIDED\" : \"\",\n      parameters.flipSided ? \"#define \
FLIP_SIDED\" : \"\",\n      parameters.shadowMapEnabled ? \"#define \
USE_SHADOWMAP\" : \"\",\n      parameters.shadowMapEnabled ? \"#define \" + \
shadowMapTypeDefine : \"\",\n      parameters.sizeAttenuation ? \"#define \
USE_SIZEATTENUATION\" : \"\",\n      parameters.numLightProbes > 0 ? \
\"#define USE_LIGHT_PROBES\" : \"\",\n      parameters.logarithmicDepthBuffer \
? \"#define USE_LOGDEPTHBUF\" : \"\",\n      parameters.reverseDepthBuffer ? \
\"#define USE_REVERSEDEPTHBUF\" : \"\",\n      \"uniform mat4 \
modelMatrix;\",\n      \"uniform mat4 modelViewMatrix;\",\n      \"uniform \
mat4 projectionMatrix;\",\n      \"uniform mat4 viewMatrix;\",\n      \
\"uniform mat3 normalMatrix;\",\n      \"uniform vec3 cameraPosition;\",\n    \
  \"uniform bool isOrthographic;\",\n      \"#ifdef USE_INSTANCING\",\n      \
\"\tattribute mat4 instanceMatrix;\",\n      \"#endif\",\n      \"#ifdef \
USE_INSTANCING_COLOR\",\n      \"\tattribute vec3 instanceColor;\",\n      \
\"#endif\",\n      \"#ifdef USE_INSTANCING_MORPH\",\n      \"\tuniform \
sampler2D morphTexture;\",\n      \"#endif\",\n      \"attribute vec3 \
position;\",\n      \"attribute vec3 normal;\",\n      \"attribute vec2 \
uv;\",\n      \"#ifdef USE_UV1\",\n      \"\tattribute vec2 uv1;\",\n      \
\"#endif\",\n      \"#ifdef USE_UV2\",\n      \"\tattribute vec2 uv2;\",\n    \
  \"#endif\",\n      \"#ifdef USE_UV3\",\n      \"\tattribute vec2 uv3;\",\n  \
    \"#endif\",\n      \"#ifdef USE_TANGENT\",\n      \"\tattribute vec4 \
tangent;\",\n      \"#endif\",\n      \"#if defined( USE_COLOR_ALPHA )\",\n   \
   \"\tattribute vec4 color;\",\n      \"#elif defined( USE_COLOR )\",\n      \
\"\tattribute vec3 color;\",\n      \"#endif\",\n      \"#ifdef \
USE_SKINNING\",\n      \"\tattribute vec4 skinIndex;\",\n      \"\tattribute \
vec4 skinWeight;\",\n      \"#endif\",\n      \"\\n\"\n    \
].filter(filterEmptyLine).join(\"\\n\");\n    prefixFragment = [\n      \
generatePrecision(parameters),\n      \"#define SHADER_TYPE \" + \
parameters.shaderType,\n      \"#define SHADER_NAME \" + \
parameters.shaderName,\n      customDefines,\n      parameters.useFog && \
parameters.fog ? \"#define USE_FOG\" : \"\",\n      parameters.useFog && \
parameters.fogExp2 ? \"#define FOG_EXP2\" : \"\",\n      \
parameters.alphaToCoverage ? \"#define ALPHA_TO_COVERAGE\" : \"\",\n      \
parameters.map ? \"#define USE_MAP\" : \"\",\n      parameters.matcap ? \
\"#define USE_MATCAP\" : \"\",\n      parameters.envMap ? \"#define \
USE_ENVMAP\" : \"\",\n      parameters.envMap ? \"#define \" + \
envMapTypeDefine : \"\",\n      parameters.envMap ? \"#define \" + \
envMapModeDefine : \"\",\n      parameters.envMap ? \"#define \" + \
envMapBlendingDefine : \"\",\n      envMapCubeUVSize ? \"#define \
CUBEUV_TEXEL_WIDTH \" + envMapCubeUVSize.texelWidth : \"\",\n      \
envMapCubeUVSize ? \"#define CUBEUV_TEXEL_HEIGHT \" + \
envMapCubeUVSize.texelHeight : \"\",\n      envMapCubeUVSize ? \"#define \
CUBEUV_MAX_MIP \" + envMapCubeUVSize.maxMip + \".0\" : \"\",\n      \
parameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n      \
parameters.aoMap ? \"#define USE_AOMAP\" : \"\",\n      parameters.bumpMap ? \
\"#define USE_BUMPMAP\" : \"\",\n      parameters.normalMap ? \"#define \
USE_NORMALMAP\" : \"\",\n      parameters.normalMapObjectSpace ? \"#define \
USE_NORMALMAP_OBJECTSPACE\" : \"\",\n      parameters.normalMapTangentSpace ? \
\"#define USE_NORMALMAP_TANGENTSPACE\" : \"\",\n      parameters.emissiveMap \
? \"#define USE_EMISSIVEMAP\" : \"\",\n      parameters.anisotropy ? \
\"#define USE_ANISOTROPY\" : \"\",\n      parameters.anisotropyMap ? \
\"#define USE_ANISOTROPYMAP\" : \"\",\n      parameters.clearcoat ? \"#define \
USE_CLEARCOAT\" : \"\",\n      parameters.clearcoatMap ? \"#define \
USE_CLEARCOATMAP\" : \"\",\n      parameters.clearcoatRoughnessMap ? \
\"#define USE_CLEARCOAT_ROUGHNESSMAP\" : \"\",\n      \
parameters.clearcoatNormalMap ? \"#define USE_CLEARCOAT_NORMALMAP\" : \"\",\n \
     parameters.dispersion ? \"#define USE_DISPERSION\" : \"\",\n      \
parameters.iridescence ? \"#define USE_IRIDESCENCE\" : \"\",\n      \
parameters.iridescenceMap ? \"#define USE_IRIDESCENCEMAP\" : \"\",\n      \
parameters.iridescenceThicknessMap ? \"#define USE_IRIDESCENCE_THICKNESSMAP\" \
: \"\",\n      parameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n \
     parameters.specularColorMap ? \"#define USE_SPECULAR_COLORMAP\" : \
\"\",\n      parameters.specularIntensityMap ? \"#define \
USE_SPECULAR_INTENSITYMAP\" : \"\",\n      parameters.roughnessMap ? \
\"#define USE_ROUGHNESSMAP\" : \"\",\n      parameters.metalnessMap ? \
\"#define USE_METALNESSMAP\" : \"\",\n      parameters.alphaMap ? \"#define \
USE_ALPHAMAP\" : \"\",\n      parameters.alphaTest ? \"#define \
USE_ALPHATEST\" : \"\",\n      parameters.alphaHash ? \"#define \
USE_ALPHAHASH\" : \"\",\n      parameters.sheen ? \"#define USE_SHEEN\" : \
\"\",\n      parameters.sheenColorMap ? \"#define USE_SHEEN_COLORMAP\" : \
\"\",\n      parameters.sheenRoughnessMap ? \"#define \
USE_SHEEN_ROUGHNESSMAP\" : \"\",\n      parameters.transmission ? \"#define \
USE_TRANSMISSION\" : \"\",\n      parameters.transmissionMap ? \"#define \
USE_TRANSMISSIONMAP\" : \"\",\n      parameters.thicknessMap ? \"#define \
USE_THICKNESSMAP\" : \"\",\n      parameters.vertexTangents && \
parameters.flatShading === false ? \"#define USE_TANGENT\" : \"\",\n      \
parameters.vertexColors || parameters.instancingColor || \
parameters.batchingColor ? \"#define USE_COLOR\" : \"\",\n      \
parameters.vertexAlphas ? \"#define USE_COLOR_ALPHA\" : \"\",\n      \
parameters.vertexUv1s ? \"#define USE_UV1\" : \"\",\n      \
parameters.vertexUv2s ? \"#define USE_UV2\" : \"\",\n      \
parameters.vertexUv3s ? \"#define USE_UV3\" : \"\",\n      \
parameters.pointsUvs ? \"#define USE_POINTS_UV\" : \"\",\n      \
parameters.gradientMap ? \"#define USE_GRADIENTMAP\" : \"\",\n      \
parameters.flatShading ? \"#define FLAT_SHADED\" : \"\",\n      \
parameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n      \
parameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n      \
parameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n      \
parameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n    \
  parameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : \"\",\n   \
   parameters.numLightProbes > 0 ? \"#define USE_LIGHT_PROBES\" : \"\",\n     \
 parameters.decodeVideoTexture ? \"#define DECODE_VIDEO_TEXTURE\" : \"\",\n   \
   parameters.decodeVideoTextureEmissive ? \"#define \
DECODE_VIDEO_TEXTURE_EMISSIVE\" : \"\",\n      \
parameters.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\",\n     \
 parameters.reverseDepthBuffer ? \"#define USE_REVERSEDEPTHBUF\" : \"\",\n    \
  \"uniform mat4 viewMatrix;\",\n      \"uniform vec3 cameraPosition;\",\n    \
  \"uniform bool isOrthographic;\",\n      parameters.toneMapping !== \
NoToneMapping ? \"#define TONE_MAPPING\" : \"\",\n      \
parameters.toneMapping !== NoToneMapping ? \
ShaderChunk[\"tonemapping_pars_fragment\"] : \"\",\n      // this code is \
required here because it is used by the toneMapping() function defined \
below\n      parameters.toneMapping !== NoToneMapping ? \
getToneMappingFunction(\"toneMapping\", parameters.toneMapping) : \"\",\n     \
 parameters.dithering ? \"#define DITHERING\" : \"\",\n      \
parameters.opaque ? \"#define OPAQUE\" : \"\",\n      \
ShaderChunk[\"colorspace_pars_fragment\"],\n      // this code is required \
here because it is used by the various encoding/decoding function defined \
below\n      getTexelEncodingFunction(\"linearToOutputTexel\", \
parameters.outputColorSpace),\n      getLuminanceFunction(),\n      \
parameters.useDepthPacking ? \"#define DEPTH_PACKING \" + \
parameters.depthPacking : \"\",\n      \"\\n\"\n    \
].filter(filterEmptyLine).join(\"\\n\");\n  }\n  vertexShader = \
resolveIncludes(vertexShader);\n  vertexShader = \
replaceLightNums(vertexShader, parameters);\n  vertexShader = \
replaceClippingPlaneNums(vertexShader, parameters);\n  fragmentShader = \
resolveIncludes(fragmentShader);\n  fragmentShader = \
replaceLightNums(fragmentShader, parameters);\n  fragmentShader = \
replaceClippingPlaneNums(fragmentShader, parameters);\n  vertexShader = \
unrollLoops(vertexShader);\n  fragmentShader = unrollLoops(fragmentShader);\n \
 if (parameters.isRawShaderMaterial !== true) {\n    versionString = \
\"#version 300 es\\n\";\n    prefixVertex = [\n      \
customVertexExtensions,\n      \"#define attribute in\",\n      \"#define \
varying out\",\n      \"#define texture2D texture\"\n    ].join(\"\\n\") + \
\"\\n\" + prefixVertex;\n    prefixFragment = [\n      \"#define varying \
in\",\n      parameters.glslVersion === GLSL3 ? \"\" : \"layout(location = 0) \
out highp vec4 pc_fragColor;\",\n      parameters.glslVersion === GLSL3 ? \
\"\" : \"#define gl_FragColor pc_fragColor\",\n      \"#define \
gl_FragDepthEXT gl_FragDepth\",\n      \"#define texture2D texture\",\n      \
\"#define textureCube texture\",\n      \"#define texture2DProj \
textureProj\",\n      \"#define texture2DLodEXT textureLod\",\n      \
\"#define texture2DProjLodEXT textureProjLod\",\n      \"#define \
textureCubeLodEXT textureLod\",\n      \"#define texture2DGradEXT \
textureGrad\",\n      \"#define texture2DProjGradEXT textureProjGrad\",\n     \
 \"#define textureCubeGradEXT textureGrad\"\n    ].join(\"\\n\") + \"\\n\" + \
prefixFragment;\n  }\n  const vertexGlsl = versionString + prefixVertex + \
vertexShader;\n  const fragmentGlsl = versionString + prefixFragment + \
fragmentShader;\n  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, \
vertexGlsl);\n  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, \
fragmentGlsl);\n  gl.attachShader(program, glVertexShader);\n  \
gl.attachShader(program, glFragmentShader);\n  if \
(parameters.index0AttributeName !== void 0) {\n    \
gl.bindAttribLocation(program, 0, parameters.index0AttributeName);\n  } else \
if (parameters.morphTargets === true) {\n    gl.bindAttribLocation(program, \
0, \"position\");\n  }\n  gl.linkProgram(program);\n  function \
onFirstUse(self2) {\n    if (renderer3.debug.checkShaderErrors) {\n      \
const programLog = gl.getProgramInfoLog(program).trim();\n      const \
vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\n      const \
fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\n      let \
runnable = true;\n      let haveDiagnostics = true;\n      if \
(gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        \
runnable = false;\n        if (typeof renderer3.debug.onShaderError === \
\"function\") {\n          renderer3.debug.onShaderError(gl, program, \
glVertexShader, glFragmentShader);\n        } else {\n          const \
vertexErrors = getShaderErrors(gl, glVertexShader, \"vertex\");\n          \
const fragmentErrors = getShaderErrors(gl, glFragmentShader, \"fragment\");\n \
         console.error(\n            \"THREE.WebGLProgram: Shader Error \" + \
gl.getError() + \" - VALIDATE_STATUS \" + gl.getProgramParameter(program, \
gl.VALIDATE_STATUS) + \"\\n\\nMaterial Name: \" + self2.name + \"\\nMaterial \
Type: \" + self2.type + \"\\n\\nProgram Info Log: \" + programLog + \"\\n\" + \
vertexErrors + \"\\n\" + fragmentErrors\n          );\n        }\n      } \
else if (programLog !== \"\") {\n        console.warn(\"THREE.WebGLProgram: \
Program Info Log:\", programLog);\n      } else if (vertexLog === \"\" || \
fragmentLog === \"\") {\n        haveDiagnostics = false;\n      }\n      if \
(haveDiagnostics) {\n        self2.diagnostics = {\n          runnable,\n     \
     programLog,\n          vertexShader: {\n            log: vertexLog,\n    \
        prefix: prefixVertex\n          },\n          fragmentShader: {\n     \
       log: fragmentLog,\n            prefix: prefixFragment\n          }\n   \
     };\n      }\n    }\n    gl.deleteShader(glVertexShader);\n    \
gl.deleteShader(glFragmentShader);\n    cachedUniforms = new \
WebGLUniforms(gl, program);\n    cachedAttributes = \
fetchAttributeLocations(gl, program);\n  }\n  let cachedUniforms;\n  \
this.getUniforms = function() {\n    if (cachedUniforms === void 0) {\n      \
onFirstUse(this);\n    }\n    return cachedUniforms;\n  };\n  let \
cachedAttributes;\n  this.getAttributes = function() {\n    if \
(cachedAttributes === void 0) {\n      onFirstUse(this);\n    }\n    return \
cachedAttributes;\n  };\n  let programReady = \
parameters.rendererExtensionParallelShaderCompile === false;\n  this.isReady \
= function() {\n    if (programReady === false) {\n      programReady = \
gl.getProgramParameter(program, COMPLETION_STATUS_KHR);\n    }\n    return \
programReady;\n  };\n  this.destroy = function() {\n    \
bindingStates.releaseStatesOfProgram(this);\n    gl.deleteProgram(program);\n \
   this.program = void 0;\n  };\n  this.type = parameters.shaderType;\n  \
this.name = parameters.shaderName;\n  this.id = programIdCount++;\n  \
this.cacheKey = cacheKey;\n  this.usedTimes = 1;\n  this.program = program;\n \
 this.vertexShader = glVertexShader;\n  this.fragmentShader = \
glFragmentShader;\n  return this;\n}\nvar _id$1 = 0;\nvar WebGLShaderCache = \
class {\n  constructor() {\n    this.shaderCache = /* @__PURE__ */ new \
Map();\n    this.materialCache = /* @__PURE__ */ new Map();\n  }\n  \
update(material) {\n    const vertexShader = material.vertexShader;\n    \
const fragmentShader = material.fragmentShader;\n    const vertexShaderStage \
= this._getShaderStage(vertexShader);\n    const fragmentShaderStage = \
this._getShaderStage(fragmentShader);\n    const materialShaders = \
this._getShaderCacheForMaterial(material);\n    if \
(materialShaders.has(vertexShaderStage) === false) {\n      \
materialShaders.add(vertexShaderStage);\n      \
vertexShaderStage.usedTimes++;\n    }\n    if \
(materialShaders.has(fragmentShaderStage) === false) {\n      \
materialShaders.add(fragmentShaderStage);\n      \
fragmentShaderStage.usedTimes++;\n    }\n    return this;\n  }\n  \
remove(material) {\n    const materialShaders = \
this.materialCache.get(material);\n    for (const shaderStage of \
materialShaders) {\n      shaderStage.usedTimes--;\n      if \
(shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);\n    \
}\n    this.materialCache.delete(material);\n    return this;\n  }\n  \
getVertexShaderID(material) {\n    return \
this._getShaderStage(material.vertexShader).id;\n  }\n  \
getFragmentShaderID(material) {\n    return \
this._getShaderStage(material.fragmentShader).id;\n  }\n  dispose() {\n    \
this.shaderCache.clear();\n    this.materialCache.clear();\n  }\n  \
_getShaderCacheForMaterial(material) {\n    const cache2 = \
this.materialCache;\n    let set2 = cache2.get(material);\n    if (set2 === \
void 0) {\n      set2 = /* @__PURE__ */ new Set();\n      \
cache2.set(material, set2);\n    }\n    return set2;\n  }\n  \
_getShaderStage(code) {\n    const cache2 = this.shaderCache;\n    let stage \
= cache2.get(code);\n    if (stage === void 0) {\n      stage = new \
WebGLShaderStage(code);\n      cache2.set(code, stage);\n    }\n    return \
stage;\n  }\n};\nvar WebGLShaderStage = class {\n  constructor(code) {\n    \
this.id = _id$1++;\n    this.code = code;\n    this.usedTimes = 0;\n  \
}\n};\nfunction WebGLPrograms(renderer3, cubemaps, cubeuvmaps, extensions, \
capabilities, bindingStates, clipping2) {\n  const _programLayers = new \
Layers();\n  const _customShaders = new WebGLShaderCache();\n  const \
_activeChannels = /* @__PURE__ */ new Set();\n  const programs = [];\n  const \
logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n  const \
SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;\n  let precision = \
capabilities.precision;\n  const shaderIDs = {\n    MeshDepthMaterial: \
\"depth\",\n    MeshDistanceMaterial: \"distanceRGBA\",\n    \
MeshNormalMaterial: \"normal\",\n    MeshBasicMaterial: \"basic\",\n    \
MeshLambertMaterial: \"lambert\",\n    MeshPhongMaterial: \"phong\",\n    \
MeshToonMaterial: \"toon\",\n    MeshStandardMaterial: \"physical\",\n    \
MeshPhysicalMaterial: \"physical\",\n    MeshMatcapMaterial: \"matcap\",\n    \
LineBasicMaterial: \"basic\",\n    LineDashedMaterial: \"dashed\",\n    \
PointsMaterial: \"points\",\n    ShadowMaterial: \"shadow\",\n    \
SpriteMaterial: \"sprite\"\n  };\n  function getChannel(value) {\n    \
_activeChannels.add(value);\n    if (value === 0) return \"uv\";\n    return \
`uv${value}`;\n  }\n  function getParameters(material, lights, shadows, \
scene3, object) {\n    const fog = scene3.fog;\n    const geometry = \
object.geometry;\n    const environment = material.isMeshStandardMaterial ? \
scene3.environment : null;\n    const envMap = \
(material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap \
|| environment);\n    const envMapCubeUVHeight = !!envMap && envMap.mapping \
=== CubeUVReflectionMapping ? envMap.image.height : null;\n    const shaderID \
= shaderIDs[material.type];\n    if (material.precision !== null) {\n      \
precision = capabilities.getMaxPrecision(material.precision);\n      if \
(precision !== material.precision) {\n        \
console.warn(\"THREE.WebGLProgram.getParameters:\", material.precision, \"not \
supported, using\", precision, \"instead.\");\n      }\n    }\n    const \
morphAttribute = geometry.morphAttributes.position || \
geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const \
morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;\n  \
  let morphTextureStride = 0;\n    if (geometry.morphAttributes.position !== \
void 0) morphTextureStride = 1;\n    if (geometry.morphAttributes.normal !== \
void 0) morphTextureStride = 2;\n    if (geometry.morphAttributes.color !== \
void 0) morphTextureStride = 3;\n    let vertexShader, fragmentShader;\n    \
let customVertexShaderID, customFragmentShaderID;\n    if (shaderID) {\n      \
const shader = ShaderLib[shaderID];\n      vertexShader = \
shader.vertexShader;\n      fragmentShader = shader.fragmentShader;\n    } \
else {\n      vertexShader = material.vertexShader;\n      fragmentShader = \
material.fragmentShader;\n      _customShaders.update(material);\n      \
customVertexShaderID = _customShaders.getVertexShaderID(material);\n      \
customFragmentShaderID = _customShaders.getFragmentShaderID(material);\n    \
}\n    const currentRenderTarget = renderer3.getRenderTarget();\n    const \
reverseDepthBuffer = renderer3.state.buffers.depth.getReversed();\n    const \
IS_INSTANCEDMESH = object.isInstancedMesh === true;\n    const IS_BATCHEDMESH \
= object.isBatchedMesh === true;\n    const HAS_MAP = !!material.map;\n    \
const HAS_MATCAP = !!material.matcap;\n    const HAS_ENVMAP = !!envMap;\n    \
const HAS_AOMAP = !!material.aoMap;\n    const HAS_LIGHTMAP = \
!!material.lightMap;\n    const HAS_BUMPMAP = !!material.bumpMap;\n    const \
HAS_NORMALMAP = !!material.normalMap;\n    const HAS_DISPLACEMENTMAP = \
!!material.displacementMap;\n    const HAS_EMISSIVEMAP = \
!!material.emissiveMap;\n    const HAS_METALNESSMAP = \
!!material.metalnessMap;\n    const HAS_ROUGHNESSMAP = \
!!material.roughnessMap;\n    const HAS_ANISOTROPY = material.anisotropy > \
0;\n    const HAS_CLEARCOAT = material.clearcoat > 0;\n    const \
HAS_DISPERSION = material.dispersion > 0;\n    const HAS_IRIDESCENCE = \
material.iridescence > 0;\n    const HAS_SHEEN = material.sheen > 0;\n    \
const HAS_TRANSMISSION = material.transmission > 0;\n    const \
HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;\n    const \
HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;\n    const \
HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;\n   \
 const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && \
!!material.clearcoatRoughnessMap;\n    const HAS_IRIDESCENCEMAP = \
HAS_IRIDESCENCE && !!material.iridescenceMap;\n    const \
HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && \
!!material.iridescenceThicknessMap;\n    const HAS_SHEEN_COLORMAP = HAS_SHEEN \
&& !!material.sheenColorMap;\n    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && \
!!material.sheenRoughnessMap;\n    const HAS_SPECULARMAP = \
!!material.specularMap;\n    const HAS_SPECULAR_COLORMAP = \
!!material.specularColorMap;\n    const HAS_SPECULAR_INTENSITYMAP = \
!!material.specularIntensityMap;\n    const HAS_TRANSMISSIONMAP = \
HAS_TRANSMISSION && !!material.transmissionMap;\n    const HAS_THICKNESSMAP = \
HAS_TRANSMISSION && !!material.thicknessMap;\n    const HAS_GRADIENTMAP = \
!!material.gradientMap;\n    const HAS_ALPHAMAP = !!material.alphaMap;\n    \
const HAS_ALPHATEST = material.alphaTest > 0;\n    const HAS_ALPHAHASH = \
!!material.alphaHash;\n    const HAS_EXTENSIONS = !!material.extensions;\n    \
let toneMapping2 = NoToneMapping;\n    if (material.toneMapped) {\n      if \
(currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === \
true) {\n        toneMapping2 = renderer3.toneMapping;\n      }\n    }\n    \
const parameters = {\n      shaderID,\n      shaderType: material.type,\n     \
 shaderName: material.name,\n      vertexShader,\n      fragmentShader,\n     \
 defines: material.defines,\n      customVertexShaderID,\n      \
customFragmentShaderID,\n      isRawShaderMaterial: \
material.isRawShaderMaterial === true,\n      glslVersion: \
material.glslVersion,\n      precision,\n      batching: IS_BATCHEDMESH,\n    \
  batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,\n      \
instancing: IS_INSTANCEDMESH,\n      instancingColor: IS_INSTANCEDMESH && \
object.instanceColor !== null,\n      instancingMorph: IS_INSTANCEDMESH && \
object.morphTexture !== null,\n      supportsVertexTextures: \
SUPPORTS_VERTEX_TEXTURES,\n      outputColorSpace: currentRenderTarget === \
null ? renderer3.outputColorSpace : currentRenderTarget.isXRRenderTarget === \
true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,\n      \
alphaToCoverage: !!material.alphaToCoverage,\n      map: HAS_MAP,\n      \
matcap: HAS_MATCAP,\n      envMap: HAS_ENVMAP,\n      envMapMode: HAS_ENVMAP \
&& envMap.mapping,\n      envMapCubeUVHeight,\n      aoMap: HAS_AOMAP,\n      \
lightMap: HAS_LIGHTMAP,\n      bumpMap: HAS_BUMPMAP,\n      normalMap: \
HAS_NORMALMAP,\n      displacementMap: SUPPORTS_VERTEX_TEXTURES && \
HAS_DISPLACEMENTMAP,\n      emissiveMap: HAS_EMISSIVEMAP,\n      \
normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === \
ObjectSpaceNormalMap,\n      normalMapTangentSpace: HAS_NORMALMAP && \
material.normalMapType === TangentSpaceNormalMap,\n      metalnessMap: \
HAS_METALNESSMAP,\n      roughnessMap: HAS_ROUGHNESSMAP,\n      anisotropy: \
HAS_ANISOTROPY,\n      anisotropyMap: HAS_ANISOTROPYMAP,\n      clearcoat: \
HAS_CLEARCOAT,\n      clearcoatMap: HAS_CLEARCOATMAP,\n      \
clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,\n      clearcoatRoughnessMap: \
HAS_CLEARCOAT_ROUGHNESSMAP,\n      dispersion: HAS_DISPERSION,\n      \
iridescence: HAS_IRIDESCENCE,\n      iridescenceMap: HAS_IRIDESCENCEMAP,\n    \
  iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,\n      sheen: \
HAS_SHEEN,\n      sheenColorMap: HAS_SHEEN_COLORMAP,\n      \
sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,\n      specularMap: \
HAS_SPECULARMAP,\n      specularColorMap: HAS_SPECULAR_COLORMAP,\n      \
specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,\n      transmission: \
HAS_TRANSMISSION,\n      transmissionMap: HAS_TRANSMISSIONMAP,\n      \
thicknessMap: HAS_THICKNESSMAP,\n      gradientMap: HAS_GRADIENTMAP,\n      \
opaque: material.transparent === false && material.blending === \
NormalBlending && material.alphaToCoverage === false,\n      alphaMap: \
HAS_ALPHAMAP,\n      alphaTest: HAS_ALPHATEST,\n      alphaHash: \
HAS_ALPHAHASH,\n      combine: material.combine,\n      //\n      mapUv: \
HAS_MAP && getChannel(material.map.channel),\n      aoMapUv: HAS_AOMAP && \
getChannel(material.aoMap.channel),\n      lightMapUv: HAS_LIGHTMAP && \
getChannel(material.lightMap.channel),\n      bumpMapUv: HAS_BUMPMAP && \
getChannel(material.bumpMap.channel),\n      normalMapUv: HAS_NORMALMAP && \
getChannel(material.normalMap.channel),\n      displacementMapUv: \
HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),\n      \
emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),\n \
     metalnessMapUv: HAS_METALNESSMAP && \
getChannel(material.metalnessMap.channel),\n      roughnessMapUv: \
HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),\n      \
anisotropyMapUv: HAS_ANISOTROPYMAP && \
getChannel(material.anisotropyMap.channel),\n      clearcoatMapUv: \
HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),\n      \
clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && \
getChannel(material.clearcoatNormalMap.channel),\n      \
clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && \
getChannel(material.clearcoatRoughnessMap.channel),\n      iridescenceMapUv: \
HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),\n      \
iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && \
getChannel(material.iridescenceThicknessMap.channel),\n      sheenColorMapUv: \
HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),\n      \
sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && \
getChannel(material.sheenRoughnessMap.channel),\n      specularMapUv: \
HAS_SPECULARMAP && getChannel(material.specularMap.channel),\n      \
specularColorMapUv: HAS_SPECULAR_COLORMAP && \
getChannel(material.specularColorMap.channel),\n      specularIntensityMapUv: \
HAS_SPECULAR_INTENSITYMAP && \
getChannel(material.specularIntensityMap.channel),\n      transmissionMapUv: \
HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),\n      \
thicknessMapUv: HAS_THICKNESSMAP && \
getChannel(material.thicknessMap.channel),\n      alphaMapUv: HAS_ALPHAMAP && \
getChannel(material.alphaMap.channel),\n      //\n      vertexTangents: \
!!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),\n      \
vertexColors: material.vertexColors,\n      vertexAlphas: \
material.vertexColors === true && !!geometry.attributes.color && \
geometry.attributes.color.itemSize === 4,\n      pointsUvs: object.isPoints \
=== true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),\n      \
fog: !!fog,\n      useFog: material.fog === true,\n      fogExp2: !!fog && \
fog.isFogExp2,\n      flatShading: material.flatShading === true,\n      \
sizeAttenuation: material.sizeAttenuation === true,\n      \
logarithmicDepthBuffer,\n      reverseDepthBuffer,\n      skinning: \
object.isSkinnedMesh === true,\n      morphTargets: \
geometry.morphAttributes.position !== void 0,\n      morphNormals: \
geometry.morphAttributes.normal !== void 0,\n      morphColors: \
geometry.morphAttributes.color !== void 0,\n      morphTargetsCount,\n      \
morphTextureStride,\n      numDirLights: lights.directional.length,\n      \
numPointLights: lights.point.length,\n      numSpotLights: \
lights.spot.length,\n      numSpotLightMaps: lights.spotLightMap.length,\n    \
  numRectAreaLights: lights.rectArea.length,\n      numHemiLights: \
lights.hemi.length,\n      numDirLightShadows: \
lights.directionalShadowMap.length,\n      numPointLightShadows: \
lights.pointShadowMap.length,\n      numSpotLightShadows: \
lights.spotShadowMap.length,\n      numSpotLightShadowsWithMaps: \
lights.numSpotLightShadowsWithMaps,\n      numLightProbes: \
lights.numLightProbes,\n      numClippingPlanes: clipping2.numPlanes,\n      \
numClipIntersection: clipping2.numIntersection,\n      dithering: \
material.dithering,\n      shadowMapEnabled: renderer3.shadowMap.enabled && \
shadows.length > 0,\n      shadowMapType: renderer3.shadowMap.type,\n      \
toneMapping: toneMapping2,\n      decodeVideoTexture: HAS_MAP && \
material.map.isVideoTexture === true && \
ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,\n      \
decodeVideoTextureEmissive: HAS_EMISSIVEMAP && \
material.emissiveMap.isVideoTexture === true && \
ColorManagement.getTransfer(material.emissiveMap.colorSpace) === \
SRGBTransfer,\n      premultipliedAlpha: material.premultipliedAlpha,\n      \
doubleSided: material.side === DoubleSide,\n      flipSided: material.side \
=== BackSide,\n      useDepthPacking: material.depthPacking >= 0,\n      \
depthPacking: material.depthPacking || 0,\n      index0AttributeName: \
material.index0AttributeName,\n      extensionClipCullDistance: \
HAS_EXTENSIONS && material.extensions.clipCullDistance === true && \
extensions.has(\"WEBGL_clip_cull_distance\"),\n      extensionMultiDraw: \
(HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) \
&& extensions.has(\"WEBGL_multi_draw\"),\n      \
rendererExtensionParallelShaderCompile: \
extensions.has(\"KHR_parallel_shader_compile\"),\n      \
customProgramCacheKey: material.customProgramCacheKey()\n    };\n    \
parameters.vertexUv1s = _activeChannels.has(1);\n    parameters.vertexUv2s = \
_activeChannels.has(2);\n    parameters.vertexUv3s = \
_activeChannels.has(3);\n    _activeChannels.clear();\n    return \
parameters;\n  }\n  function getProgramCacheKey(parameters) {\n    const \
array = [];\n    if (parameters.shaderID) {\n      \
array.push(parameters.shaderID);\n    } else {\n      \
array.push(parameters.customVertexShaderID);\n      \
array.push(parameters.customFragmentShaderID);\n    }\n    if \
(parameters.defines !== void 0) {\n      for (const name in \
parameters.defines) {\n        array.push(name);\n        \
array.push(parameters.defines[name]);\n      }\n    }\n    if \
(parameters.isRawShaderMaterial === false) {\n      \
getProgramCacheKeyParameters(array, parameters);\n      \
getProgramCacheKeyBooleans(array, parameters);\n      \
array.push(renderer3.outputColorSpace);\n    }\n    \
array.push(parameters.customProgramCacheKey);\n    return array.join();\n  \
}\n  function getProgramCacheKeyParameters(array, parameters) {\n    \
array.push(parameters.precision);\n    \
array.push(parameters.outputColorSpace);\n    \
array.push(parameters.envMapMode);\n    \
array.push(parameters.envMapCubeUVHeight);\n    \
array.push(parameters.mapUv);\n    array.push(parameters.alphaMapUv);\n    \
array.push(parameters.lightMapUv);\n    array.push(parameters.aoMapUv);\n    \
array.push(parameters.bumpMapUv);\n    array.push(parameters.normalMapUv);\n  \
  array.push(parameters.displacementMapUv);\n    \
array.push(parameters.emissiveMapUv);\n    \
array.push(parameters.metalnessMapUv);\n    \
array.push(parameters.roughnessMapUv);\n    \
array.push(parameters.anisotropyMapUv);\n    \
array.push(parameters.clearcoatMapUv);\n    \
array.push(parameters.clearcoatNormalMapUv);\n    \
array.push(parameters.clearcoatRoughnessMapUv);\n    \
array.push(parameters.iridescenceMapUv);\n    \
array.push(parameters.iridescenceThicknessMapUv);\n    \
array.push(parameters.sheenColorMapUv);\n    \
array.push(parameters.sheenRoughnessMapUv);\n    \
array.push(parameters.specularMapUv);\n    \
array.push(parameters.specularColorMapUv);\n    \
array.push(parameters.specularIntensityMapUv);\n    \
array.push(parameters.transmissionMapUv);\n    \
array.push(parameters.thicknessMapUv);\n    array.push(parameters.combine);\n \
   array.push(parameters.fogExp2);\n    \
array.push(parameters.sizeAttenuation);\n    \
array.push(parameters.morphTargetsCount);\n    \
array.push(parameters.morphAttributeCount);\n    \
array.push(parameters.numDirLights);\n    \
array.push(parameters.numPointLights);\n    \
array.push(parameters.numSpotLights);\n    \
array.push(parameters.numSpotLightMaps);\n    \
array.push(parameters.numHemiLights);\n    \
array.push(parameters.numRectAreaLights);\n    \
array.push(parameters.numDirLightShadows);\n    \
array.push(parameters.numPointLightShadows);\n    \
array.push(parameters.numSpotLightShadows);\n    \
array.push(parameters.numSpotLightShadowsWithMaps);\n    \
array.push(parameters.numLightProbes);\n    \
array.push(parameters.shadowMapType);\n    \
array.push(parameters.toneMapping);\n    \
array.push(parameters.numClippingPlanes);\n    \
array.push(parameters.numClipIntersection);\n    \
array.push(parameters.depthPacking);\n  }\n  function \
getProgramCacheKeyBooleans(array, parameters) {\n    \
_programLayers.disableAll();\n    if (parameters.supportsVertexTextures)\n    \
  _programLayers.enable(0);\n    if (parameters.instancing)\n      \
_programLayers.enable(1);\n    if (parameters.instancingColor)\n      \
_programLayers.enable(2);\n    if (parameters.instancingMorph)\n      \
_programLayers.enable(3);\n    if (parameters.matcap)\n      \
_programLayers.enable(4);\n    if (parameters.envMap)\n      \
_programLayers.enable(5);\n    if (parameters.normalMapObjectSpace)\n      \
_programLayers.enable(6);\n    if (parameters.normalMapTangentSpace)\n      \
_programLayers.enable(7);\n    if (parameters.clearcoat)\n      \
_programLayers.enable(8);\n    if (parameters.iridescence)\n      \
_programLayers.enable(9);\n    if (parameters.alphaTest)\n      \
_programLayers.enable(10);\n    if (parameters.vertexColors)\n      \
_programLayers.enable(11);\n    if (parameters.vertexAlphas)\n      \
_programLayers.enable(12);\n    if (parameters.vertexUv1s)\n      \
_programLayers.enable(13);\n    if (parameters.vertexUv2s)\n      \
_programLayers.enable(14);\n    if (parameters.vertexUv3s)\n      \
_programLayers.enable(15);\n    if (parameters.vertexTangents)\n      \
_programLayers.enable(16);\n    if (parameters.anisotropy)\n      \
_programLayers.enable(17);\n    if (parameters.alphaHash)\n      \
_programLayers.enable(18);\n    if (parameters.batching)\n      \
_programLayers.enable(19);\n    if (parameters.dispersion)\n      \
_programLayers.enable(20);\n    if (parameters.batchingColor)\n      \
_programLayers.enable(21);\n    array.push(_programLayers.mask);\n    \
_programLayers.disableAll();\n    if (parameters.fog)\n      \
_programLayers.enable(0);\n    if (parameters.useFog)\n      \
_programLayers.enable(1);\n    if (parameters.flatShading)\n      \
_programLayers.enable(2);\n    if (parameters.logarithmicDepthBuffer)\n      \
_programLayers.enable(3);\n    if (parameters.reverseDepthBuffer)\n      \
_programLayers.enable(4);\n    if (parameters.skinning)\n      \
_programLayers.enable(5);\n    if (parameters.morphTargets)\n      \
_programLayers.enable(6);\n    if (parameters.morphNormals)\n      \
_programLayers.enable(7);\n    if (parameters.morphColors)\n      \
_programLayers.enable(8);\n    if (parameters.premultipliedAlpha)\n      \
_programLayers.enable(9);\n    if (parameters.shadowMapEnabled)\n      \
_programLayers.enable(10);\n    if (parameters.doubleSided)\n      \
_programLayers.enable(11);\n    if (parameters.flipSided)\n      \
_programLayers.enable(12);\n    if (parameters.useDepthPacking)\n      \
_programLayers.enable(13);\n    if (parameters.dithering)\n      \
_programLayers.enable(14);\n    if (parameters.transmission)\n      \
_programLayers.enable(15);\n    if (parameters.sheen)\n      \
_programLayers.enable(16);\n    if (parameters.opaque)\n      \
_programLayers.enable(17);\n    if (parameters.pointsUvs)\n      \
_programLayers.enable(18);\n    if (parameters.decodeVideoTexture)\n      \
_programLayers.enable(19);\n    if (parameters.decodeVideoTextureEmissive)\n  \
    _programLayers.enable(20);\n    if (parameters.alphaToCoverage)\n      \
_programLayers.enable(21);\n    array.push(_programLayers.mask);\n  }\n  \
function getUniforms(material) {\n    const shaderID = \
shaderIDs[material.type];\n    let uniforms;\n    if (shaderID) {\n      \
const shader = ShaderLib[shaderID];\n      uniforms = \
UniformsUtils.clone(shader.uniforms);\n    } else {\n      uniforms = \
material.uniforms;\n    }\n    return uniforms;\n  }\n  function \
acquireProgram(parameters, cacheKey) {\n    let program;\n    for (let p = 0, \
pl = programs.length; p < pl; p++) {\n      const preexistingProgram = \
programs[p];\n      if (preexistingProgram.cacheKey === cacheKey) {\n        \
program = preexistingProgram;\n        ++program.usedTimes;\n        break;\n \
     }\n    }\n    if (program === void 0) {\n      program = new \
WebGLProgram(renderer3, cacheKey, parameters, bindingStates);\n      \
programs.push(program);\n    }\n    return program;\n  }\n  function \
releaseProgram(program) {\n    if (--program.usedTimes === 0) {\n      const \
i = programs.indexOf(program);\n      programs[i] = programs[programs.length \
- 1];\n      programs.pop();\n      program.destroy();\n    }\n  }\n  \
function releaseShaderCache(material) {\n    \
_customShaders.remove(material);\n  }\n  function dispose() {\n    \
_customShaders.dispose();\n  }\n  return {\n    getParameters,\n    \
getProgramCacheKey,\n    getUniforms,\n    acquireProgram,\n    \
releaseProgram,\n    releaseShaderCache,\n    // Exposed for resource \
monitoring & error feedback via renderer.info:\n    programs,\n    dispose\n  \
};\n}\nfunction WebGLProperties() {\n  let properties = /* @__PURE__ */ new \
WeakMap();\n  function has(object) {\n    return properties.has(object);\n  \
}\n  function get2(object) {\n    let map = properties.get(object);\n    if \
(map === void 0) {\n      map = {};\n      properties.set(object, map);\n    \
}\n    return map;\n  }\n  function remove2(object) {\n    \
properties.delete(object);\n  }\n  function update4(object, key, value) {\n   \
 properties.get(object)[key] = value;\n  }\n  function dispose() {\n    \
properties = /* @__PURE__ */ new WeakMap();\n  }\n  return {\n    has,\n    \
get: get2,\n    remove: remove2,\n    update: update4,\n    dispose\n  \
};\n}\nfunction painterSortStable(a2, b) {\n  if (a2.groupOrder !== \
b.groupOrder) {\n    return a2.groupOrder - b.groupOrder;\n  } else if \
(a2.renderOrder !== b.renderOrder) {\n    return a2.renderOrder - \
b.renderOrder;\n  } else if (a2.material.id !== b.material.id) {\n    return \
a2.material.id - b.material.id;\n  } else if (a2.z !== b.z) {\n    return \
a2.z - b.z;\n  } else {\n    return a2.id - b.id;\n  }\n}\nfunction \
reversePainterSortStable(a2, b) {\n  if (a2.groupOrder !== b.groupOrder) {\n  \
  return a2.groupOrder - b.groupOrder;\n  } else if (a2.renderOrder !== \
b.renderOrder) {\n    return a2.renderOrder - b.renderOrder;\n  } else if \
(a2.z !== b.z) {\n    return b.z - a2.z;\n  } else {\n    return a2.id - \
b.id;\n  }\n}\nfunction WebGLRenderList() {\n  const renderItems = [];\n  let \
renderItemsIndex = 0;\n  const opaque = [];\n  const transmissive = [];\n  \
const transparent = [];\n  function init4() {\n    renderItemsIndex = 0;\n    \
opaque.length = 0;\n    transmissive.length = 0;\n    transparent.length = \
0;\n  }\n  function getNextRenderItem(object, geometry, material, groupOrder, \
z2, group) {\n    let renderItem = renderItems[renderItemsIndex];\n    if \
(renderItem === void 0) {\n      renderItem = {\n        id: object.id,\n     \
   object,\n        geometry,\n        material,\n        groupOrder,\n       \
 renderOrder: object.renderOrder,\n        z: z2,\n        group\n      };\n  \
    renderItems[renderItemsIndex] = renderItem;\n    } else {\n      \
renderItem.id = object.id;\n      renderItem.object = object;\n      \
renderItem.geometry = geometry;\n      renderItem.material = material;\n      \
renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = \
object.renderOrder;\n      renderItem.z = z2;\n      renderItem.group = \
group;\n    }\n    renderItemsIndex++;\n    return renderItem;\n  }\n  \
function push(object, geometry, material, groupOrder, z2, group) {\n    const \
renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, \
group);\n    if (material.transmission > 0) {\n      \
transmissive.push(renderItem);\n    } else if (material.transparent === true) \
{\n      transparent.push(renderItem);\n    } else {\n      \
opaque.push(renderItem);\n    }\n  }\n  function unshift(object, geometry, \
material, groupOrder, z2, group) {\n    const renderItem = \
getNextRenderItem(object, geometry, material, groupOrder, z2, group);\n    if \
(material.transmission > 0) {\n      transmissive.unshift(renderItem);\n    } \
else if (material.transparent === true) {\n      \
transparent.unshift(renderItem);\n    } else {\n      \
opaque.unshift(renderItem);\n    }\n  }\n  function sort(customOpaqueSort, \
customTransparentSort) {\n    if (opaque.length > 1) \
opaque.sort(customOpaqueSort || painterSortStable);\n    if \
(transmissive.length > 1) transmissive.sort(customTransparentSort || \
reversePainterSortStable);\n    if (transparent.length > 1) \
transparent.sort(customTransparentSort || reversePainterSortStable);\n  }\n  \
function finish() {\n    for (let i = renderItemsIndex, il = \
renderItems.length; i < il; i++) {\n      const renderItem = \
renderItems[i];\n      if (renderItem.id === null) break;\n      \
renderItem.id = null;\n      renderItem.object = null;\n      \
renderItem.geometry = null;\n      renderItem.material = null;\n      \
renderItem.group = null;\n    }\n  }\n  return {\n    opaque,\n    \
transmissive,\n    transparent,\n    init: init4,\n    push,\n    unshift,\n  \
  finish,\n    sort\n  };\n}\nfunction WebGLRenderLists() {\n  let lists = /* \
@__PURE__ */ new WeakMap();\n  function get2(scene3, renderCallDepth) {\n    \
const listArray = lists.get(scene3);\n    let list;\n    if (listArray === \
void 0) {\n      list = new WebGLRenderList();\n      lists.set(scene3, \
[list]);\n    } else {\n      if (renderCallDepth >= listArray.length) {\n    \
    list = new WebGLRenderList();\n        listArray.push(list);\n      } \
else {\n        list = listArray[renderCallDepth];\n      }\n    }\n    \
return list;\n  }\n  function dispose() {\n    lists = /* @__PURE__ */ new \
WeakMap();\n  }\n  return {\n    get: get2,\n    dispose\n  };\n}\nfunction \
UniformsCache() {\n  const lights = {};\n  return {\n    get: function(light) \
{\n      if (lights[light.id] !== void 0) {\n        return \
lights[light.id];\n      }\n      let uniforms;\n      switch (light.type) \
{\n        case \"DirectionalLight\":\n          uniforms = {\n            \
direction: new Vector3(),\n            color: new Color()\n          };\n     \
     break;\n        case \"SpotLight\":\n          uniforms = {\n            \
position: new Vector3(),\n            direction: new Vector3(),\n            \
color: new Color(),\n            distance: 0,\n            coneCos: 0,\n      \
      penumbraCos: 0,\n            decay: 0\n          };\n          break;\n \
       case \"PointLight\":\n          uniforms = {\n            position: \
new Vector3(),\n            color: new Color(),\n            distance: 0,\n   \
         decay: 0\n          };\n          break;\n        case \
\"HemisphereLight\":\n          uniforms = {\n            direction: new \
Vector3(),\n            skyColor: new Color(),\n            groundColor: new \
Color()\n          };\n          break;\n        case \"RectAreaLight\":\n    \
      uniforms = {\n            color: new Color(),\n            position: \
new Vector3(),\n            halfWidth: new Vector3(),\n            \
halfHeight: new Vector3()\n          };\n          break;\n      }\n      \
lights[light.id] = uniforms;\n      return uniforms;\n    }\n  \
};\n}\nfunction ShadowUniformsCache() {\n  const lights = {};\n  return {\n   \
 get: function(light) {\n      if (lights[light.id] !== void 0) {\n        \
return lights[light.id];\n      }\n      let uniforms;\n      switch \
(light.type) {\n        case \"DirectionalLight\":\n          uniforms = {\n  \
          shadowIntensity: 1,\n            shadowBias: 0,\n            \
shadowNormalBias: 0,\n            shadowRadius: 1,\n            \
shadowMapSize: new Vector2()\n          };\n          break;\n        case \
\"SpotLight\":\n          uniforms = {\n            shadowIntensity: 1,\n     \
       shadowBias: 0,\n            shadowNormalBias: 0,\n            \
shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n    \
      break;\n        case \"PointLight\":\n          uniforms = {\n          \
  shadowIntensity: 1,\n            shadowBias: 0,\n            \
shadowNormalBias: 0,\n            shadowRadius: 1,\n            \
shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            \
shadowCameraFar: 1e3\n          };\n          break;\n      }\n      \
lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\nvar \
nextVersion = 0;\nfunction shadowCastingAndTexturingLightsFirst(lightA, \
lightB) {\n  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) \
+ (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);\n}\nfunction \
WebGLLights(extensions) {\n  const cache2 = new UniformsCache();\n  const \
shadowCache = ShadowUniformsCache();\n  const state = {\n    version: 0,\n    \
hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      \
spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n      \
numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: \
-1,\n      numSpotMaps: -1,\n      numLightProbes: -1\n    },\n    ambient: \
[0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadow: \
[],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    \
spot: [],\n    spotLightMap: [],\n    spotShadow: [],\n    spotShadowMap: \
[],\n    spotLightMatrix: [],\n    rectArea: [],\n    rectAreaLTC1: null,\n   \
 rectAreaLTC2: null,\n    point: [],\n    pointShadow: [],\n    \
pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: [],\n    \
numSpotLightShadowsWithMaps: 0,\n    numLightProbes: 0\n  };\n  for (let i = \
0; i < 9; i++) state.probe.push(new Vector3());\n  const vector3 = new \
Vector3();\n  const matrix4 = new Matrix4();\n  const matrix42 = new \
Matrix4();\n  function setup(lights) {\n    let r = 0, g = 0, b = 0;\n    for \
(let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n    let \
directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n   \
 let rectAreaLength = 0;\n    let hemiLength = 0;\n    let \
numDirectionalShadows = 0;\n    let numPointShadows = 0;\n    let \
numSpotShadows = 0;\n    let numSpotMaps = 0;\n    let numSpotShadowsWithMaps \
= 0;\n    let numLightProbes = 0;\n    \
lights.sort(shadowCastingAndTexturingLightsFirst);\n    for (let i = 0, l = \
lights.length; i < l; i++) {\n      const light = lights[i];\n      const \
color2 = light.color;\n      const intensity = light.intensity;\n      const \
distance2 = light.distance;\n      const shadowMap = light.shadow && \
light.shadow.map ? light.shadow.map.texture : null;\n      if \
(light.isAmbientLight) {\n        r += color2.r * intensity;\n        g += \
color2.g * intensity;\n        b += color2.b * intensity;\n      } else if \
(light.isLightProbe) {\n        for (let j = 0; j < 9; j++) {\n          \
state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        \
}\n        numLightProbes++;\n      } else if (light.isDirectionalLight) {\n  \
      const uniforms = cache2.get(light);\n        \
uniforms.color.copy(light.color).multiplyScalar(light.intensity);\n        if \
(light.castShadow) {\n          const shadow2 = light.shadow;\n          \
const shadowUniforms = shadowCache.get(light);\n          \
shadowUniforms.shadowIntensity = shadow2.intensity;\n          \
shadowUniforms.shadowBias = shadow2.bias;\n          \
shadowUniforms.shadowNormalBias = shadow2.normalBias;\n          \
shadowUniforms.shadowRadius = shadow2.radius;\n          \
shadowUniforms.shadowMapSize = shadow2.mapSize;\n          \
state.directionalShadow[directionalLength] = shadowUniforms;\n          \
state.directionalShadowMap[directionalLength] = shadowMap;\n          \
state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n     \
     numDirectionalShadows++;\n        }\n        \
state.directional[directionalLength] = uniforms;\n        \
directionalLength++;\n      } else if (light.isSpotLight) {\n        const \
uniforms = cache2.get(light);\n        \
uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        \
uniforms.color.copy(color2).multiplyScalar(intensity);\n        \
uniforms.distance = distance2;\n        uniforms.coneCos = \
Math.cos(light.angle);\n        uniforms.penumbraCos = Math.cos(light.angle * \
(1 - light.penumbra));\n        uniforms.decay = light.decay;\n        \
state.spot[spotLength] = uniforms;\n        const shadow2 = light.shadow;\n   \
     if (light.map) {\n          state.spotLightMap[numSpotMaps] = \
light.map;\n          numSpotMaps++;\n          \
shadow2.updateMatrices(light);\n          if (light.castShadow) \
numSpotShadowsWithMaps++;\n        }\n        \
state.spotLightMatrix[spotLength] = shadow2.matrix;\n        if \
(light.castShadow) {\n          const shadowUniforms = \
shadowCache.get(light);\n          shadowUniforms.shadowIntensity = \
shadow2.intensity;\n          shadowUniforms.shadowBias = shadow2.bias;\n     \
     shadowUniforms.shadowNormalBias = shadow2.normalBias;\n          \
shadowUniforms.shadowRadius = shadow2.radius;\n          \
shadowUniforms.shadowMapSize = shadow2.mapSize;\n          \
state.spotShadow[spotLength] = shadowUniforms;\n          \
state.spotShadowMap[spotLength] = shadowMap;\n          numSpotShadows++;\n   \
     }\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n    \
    const uniforms = cache2.get(light);\n        \
uniforms.color.copy(color2).multiplyScalar(intensity);\n        \
uniforms.halfWidth.set(light.width * 0.5, 0, 0);\n        \
uniforms.halfHeight.set(0, light.height * 0.5, 0);\n        \
state.rectArea[rectAreaLength] = uniforms;\n        rectAreaLength++;\n      \
} else if (light.isPointLight) {\n        const uniforms = \
cache2.get(light);\n        \
uniforms.color.copy(light.color).multiplyScalar(light.intensity);\n        \
uniforms.distance = light.distance;\n        uniforms.decay = light.decay;\n  \
      if (light.castShadow) {\n          const shadow2 = light.shadow;\n      \
    const shadowUniforms = shadowCache.get(light);\n          \
shadowUniforms.shadowIntensity = shadow2.intensity;\n          \
shadowUniforms.shadowBias = shadow2.bias;\n          \
shadowUniforms.shadowNormalBias = shadow2.normalBias;\n          \
shadowUniforms.shadowRadius = shadow2.radius;\n          \
shadowUniforms.shadowMapSize = shadow2.mapSize;\n          \
shadowUniforms.shadowCameraNear = shadow2.camera.near;\n          \
shadowUniforms.shadowCameraFar = shadow2.camera.far;\n          \
state.pointShadow[pointLength] = shadowUniforms;\n          \
state.pointShadowMap[pointLength] = shadowMap;\n          \
state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n          \
numPointShadows++;\n        }\n        state.point[pointLength] = uniforms;\n \
       pointLength++;\n      } else if (light.isHemisphereLight) {\n        \
const uniforms = cache2.get(light);\n        \
uniforms.skyColor.copy(light.color).multiplyScalar(intensity);\n        \
uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);\n     \
   state.hemi[hemiLength] = uniforms;\n        hemiLength++;\n      }\n    \
}\n    if (rectAreaLength > 0) {\n      if \
(extensions.has(\"OES_texture_float_linear\") === true) {\n        \
state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n        state.rectAreaLTC2 = \
UniformsLib.LTC_FLOAT_2;\n      } else {\n        state.rectAreaLTC1 = \
UniformsLib.LTC_HALF_1;\n        state.rectAreaLTC2 = \
UniformsLib.LTC_HALF_2;\n      }\n    }\n    state.ambient[0] = r;\n    \
state.ambient[1] = g;\n    state.ambient[2] = b;\n    const hash = \
state.hash;\n    if (hash.directionalLength !== directionalLength || \
hash.pointLength !== pointLength || hash.spotLength !== spotLength || \
hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || \
hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows \
!== numPointShadows || hash.numSpotShadows !== numSpotShadows || \
hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) \
{\n      state.directional.length = directionalLength;\n      \
state.spot.length = spotLength;\n      state.rectArea.length = \
rectAreaLength;\n      state.point.length = pointLength;\n      \
state.hemi.length = hemiLength;\n      state.directionalShadow.length = \
numDirectionalShadows;\n      state.directionalShadowMap.length = \
numDirectionalShadows;\n      state.pointShadow.length = numPointShadows;\n   \
   state.pointShadowMap.length = numPointShadows;\n      \
state.spotShadow.length = numSpotShadows;\n      state.spotShadowMap.length = \
numSpotShadows;\n      state.directionalShadowMatrix.length = \
numDirectionalShadows;\n      state.pointShadowMatrix.length = \
numPointShadows;\n      state.spotLightMatrix.length = numSpotShadows + \
numSpotMaps - numSpotShadowsWithMaps;\n      state.spotLightMap.length = \
numSpotMaps;\n      state.numSpotLightShadowsWithMaps = \
numSpotShadowsWithMaps;\n      state.numLightProbes = numLightProbes;\n      \
hash.directionalLength = directionalLength;\n      hash.pointLength = \
pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength \
= rectAreaLength;\n      hash.hemiLength = hemiLength;\n      \
hash.numDirectionalShadows = numDirectionalShadows;\n      \
hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = \
numSpotShadows;\n      hash.numSpotMaps = numSpotMaps;\n      \
hash.numLightProbes = numLightProbes;\n      state.version = nextVersion++;\n \
   }\n  }\n  function setupView(lights, camera3) {\n    let directionalLength \
= 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let \
rectAreaLength = 0;\n    let hemiLength = 0;\n    const viewMatrix = \
camera3.matrixWorldInverse;\n    for (let i = 0, l = lights.length; i < l; \
i++) {\n      const light = lights[i];\n      if (light.isDirectionalLight) \
{\n        const uniforms = state.directional[directionalLength];\n        \
uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        \
vector3.setFromMatrixPosition(light.target.matrixWorld);\n        \
uniforms.direction.sub(vector3);\n        \
uniforms.direction.transformDirection(viewMatrix);\n        \
directionalLength++;\n      } else if (light.isSpotLight) {\n        const \
uniforms = state.spot[spotLength];\n        \
uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        \
uniforms.position.applyMatrix4(viewMatrix);\n        \
uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        \
vector3.setFromMatrixPosition(light.target.matrixWorld);\n        \
uniforms.direction.sub(vector3);\n        \
uniforms.direction.transformDirection(viewMatrix);\n        spotLength++;\n   \
   } else if (light.isRectAreaLight) {\n        const uniforms = \
state.rectArea[rectAreaLength];\n        \
uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        \
uniforms.position.applyMatrix4(viewMatrix);\n        matrix42.identity();\n   \
     matrix4.copy(light.matrixWorld);\n        \
matrix4.premultiply(viewMatrix);\n        \
matrix42.extractRotation(matrix4);\n        \
uniforms.halfWidth.set(light.width * 0.5, 0, 0);\n        \
uniforms.halfHeight.set(0, light.height * 0.5, 0);\n        \
uniforms.halfWidth.applyMatrix4(matrix42);\n        \
uniforms.halfHeight.applyMatrix4(matrix42);\n        rectAreaLength++;\n      \
} else if (light.isPointLight) {\n        const uniforms = \
state.point[pointLength];\n        \
uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        \
uniforms.position.applyMatrix4(viewMatrix);\n        pointLength++;\n      } \
else if (light.isHemisphereLight) {\n        const uniforms = \
state.hemi[hemiLength];\n        \
uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        \
uniforms.direction.transformDirection(viewMatrix);\n        hemiLength++;\n   \
   }\n    }\n  }\n  return {\n    setup,\n    setupView,\n    state\n  \
};\n}\nfunction WebGLRenderState(extensions) {\n  const lights = new \
WebGLLights(extensions);\n  const lightsArray = [];\n  const shadowsArray = \
[];\n  function init4(camera3) {\n    state.camera = camera3;\n    \
lightsArray.length = 0;\n    shadowsArray.length = 0;\n  }\n  function \
pushLight(light) {\n    lightsArray.push(light);\n  }\n  function \
pushShadow(shadowLight) {\n    shadowsArray.push(shadowLight);\n  }\n  \
function setupLights() {\n    lights.setup(lightsArray);\n  }\n  function \
setupLightsView(camera3) {\n    lights.setupView(lightsArray, camera3);\n  \
}\n  const state = {\n    lightsArray,\n    shadowsArray,\n    camera: \
null,\n    lights,\n    transmissionRenderTarget: {}\n  };\n  return {\n    \
init: init4,\n    state,\n    setupLights,\n    setupLightsView,\n    \
pushLight,\n    pushShadow\n  };\n}\nfunction WebGLRenderStates(extensions) \
{\n  let renderStates = /* @__PURE__ */ new WeakMap();\n  function \
get2(scene3, renderCallDepth = 0) {\n    const renderStateArray = \
renderStates.get(scene3);\n    let renderState;\n    if (renderStateArray === \
void 0) {\n      renderState = new WebGLRenderState(extensions);\n      \
renderStates.set(scene3, [renderState]);\n    } else {\n      if \
(renderCallDepth >= renderStateArray.length) {\n        renderState = new \
WebGLRenderState(extensions);\n        renderStateArray.push(renderState);\n  \
    } else {\n        renderState = renderStateArray[renderCallDepth];\n      \
}\n    }\n    return renderState;\n  }\n  function dispose() {\n    \
renderStates = /* @__PURE__ */ new WeakMap();\n  }\n  return {\n    get: \
get2,\n    dispose\n  };\n}\nvar MeshDepthMaterial = class extends Material \
{\n  static get type() {\n    return \"MeshDepthMaterial\";\n  }\n  \
constructor(parameters) {\n    super();\n    this.isMeshDepthMaterial = \
true;\n    this.depthPacking = BasicDepthPacking;\n    this.map = null;\n    \
this.alphaMap = null;\n    this.displacementMap = null;\n    \
this.displacementScale = 1;\n    this.displacementBias = 0;\n    \
this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    \
this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n \
   this.depthPacking = source.depthPacking;\n    this.map = source.map;\n    \
this.alphaMap = source.alphaMap;\n    this.displacementMap = \
source.displacementMap;\n    this.displacementScale = \
source.displacementScale;\n    this.displacementBias = \
source.displacementBias;\n    this.wireframe = source.wireframe;\n    \
this.wireframeLinewidth = source.wireframeLinewidth;\n    return this;\n  \
}\n};\nvar MeshDistanceMaterial = class extends Material {\n  static get \
type() {\n    return \"MeshDistanceMaterial\";\n  }\n  \
constructor(parameters) {\n    super();\n    this.isMeshDistanceMaterial = \
true;\n    this.map = null;\n    this.alphaMap = null;\n    \
this.displacementMap = null;\n    this.displacementScale = 1;\n    \
this.displacementBias = 0;\n    this.setValues(parameters);\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.map = source.map;\n    \
this.alphaMap = source.alphaMap;\n    this.displacementMap = \
source.displacementMap;\n    this.displacementScale = \
source.displacementScale;\n    this.displacementBias = \
source.displacementBias;\n    return this;\n  }\n};\nvar vertex = \"void \
main() {\\n\tgl_Position = vec4( position, 1.0 );\\n}\";\nvar fragment = \
\"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float \
radius;\\n#include <packing>\\nvoid main() {\\n\tconst float samples = float( \
VSM_SAMPLES );\\n\tfloat mean = 0.0;\\n\tfloat squared_mean = 0.0;\\n\tfloat \
uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\\n\tfloat uvStart \
= samples <= 1.0 ? 0.0 : - 1.0;\\n\tfor ( float i = 0.0; i < samples; i ++ ) \
{\\n\t\tfloat uvOffset = uvStart + i * uvStride;\\n\t\t#ifdef \
HORIZONTAL_PASS\\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( \
shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / \
resolution ) );\\n\t\t\tmean += distribution.x;\\n\t\t\tsquared_mean += \
distribution.y * distribution.y + distribution.x * \
distribution.x;\\n\t\t#else\\n\t\t\tfloat depth = unpackRGBAToDepth( \
texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) \
/ resolution ) );\\n\t\t\tmean += depth;\\n\t\t\tsquared_mean += depth * \
depth;\\n\t\t#endif\\n\t}\\n\tmean = mean / samples;\\n\tsquared_mean = \
squared_mean / samples;\\n\tfloat std_dev = sqrt( squared_mean - mean * mean \
);\\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) \
);\\n}\";\nfunction WebGLShadowMap(renderer3, objects, capabilities) {\n  let \
_frustum2 = new Frustum();\n  const _shadowMapSize = new Vector2(), \
_viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = \
new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial \
= new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = \
capabilities.maxTextureSize;\n  const shadowSide = { [FrontSide]: BackSide, \
[BackSide]: FrontSide, [DoubleSide]: DoubleSide };\n  const \
shadowMaterialVertical = new ShaderMaterial({\n    defines: {\n      \
VSM_SAMPLES: 8\n    },\n    uniforms: {\n      shadow_pass: { value: null \
},\n      resolution: { value: new Vector2() },\n      radius: { value: 4 }\n \
   },\n    vertexShader: vertex,\n    fragmentShader: fragment\n  });\n  \
const shadowMaterialHorizontal = shadowMaterialVertical.clone();\n  \
shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n  const fullScreenTri \
= new BufferGeometry();\n  fullScreenTri.setAttribute(\n    \"position\",\n   \
 new BufferAttribute(\n      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, \
3, 0.5]),\n      3\n    )\n  );\n  const fullScreenMesh = new \
Mesh(fullScreenTri, shadowMaterialVertical);\n  const scope = this;\n  \
this.enabled = false;\n  this.autoUpdate = true;\n  this.needsUpdate = \
false;\n  this.type = PCFShadowMap;\n  let _previousType = this.type;\n  \
this.render = function(lights, scene3, camera3) {\n    if (scope.enabled === \
false) return;\n    if (scope.autoUpdate === false && scope.needsUpdate === \
false) return;\n    if (lights.length === 0) return;\n    const \
currentRenderTarget = renderer3.getRenderTarget();\n    const activeCubeFace \
= renderer3.getActiveCubeFace();\n    const activeMipmapLevel = \
renderer3.getActiveMipmapLevel();\n    const _state = renderer3.state;\n    \
_state.setBlending(NoBlending);\n    _state.buffers.color.setClear(1, 1, 1, \
1);\n    _state.buffers.depth.setTest(true);\n    \
_state.setScissorTest(false);\n    const toVSM = _previousType !== \
VSMShadowMap && this.type === VSMShadowMap;\n    const fromVSM = \
_previousType === VSMShadowMap && this.type !== VSMShadowMap;\n    for (let i \
= 0, il = lights.length; i < il; i++) {\n      const light = lights[i];\n     \
 const shadow2 = light.shadow;\n      if (shadow2 === void 0) {\n        \
console.warn(\"THREE.WebGLShadowMap:\", light, \"has no shadow.\");\n        \
continue;\n      }\n      if (shadow2.autoUpdate === false && \
shadow2.needsUpdate === false) continue;\n      \
_shadowMapSize.copy(shadow2.mapSize);\n      const shadowFrameExtents = \
shadow2.getFrameExtents();\n      \
_shadowMapSize.multiply(shadowFrameExtents);\n      \
_viewportSize.copy(shadow2.mapSize);\n      if (_shadowMapSize.x > \
_maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n        if \
(_shadowMapSize.x > _maxTextureSize) {\n          _viewportSize.x = \
Math.floor(_maxTextureSize / shadowFrameExtents.x);\n          \
_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n          \
shadow2.mapSize.x = _viewportSize.x;\n        }\n        if (_shadowMapSize.y \
> _maxTextureSize) {\n          _viewportSize.y = Math.floor(_maxTextureSize \
/ shadowFrameExtents.y);\n          _shadowMapSize.y = _viewportSize.y * \
shadowFrameExtents.y;\n          shadow2.mapSize.y = _viewportSize.y;\n       \
 }\n      }\n      if (shadow2.map === null || toVSM === true || fromVSM === \
true) {\n        const pars = this.type !== VSMShadowMap ? { minFilter: \
NearestFilter, magFilter: NearestFilter } : {};\n        if (shadow2.map !== \
null) {\n          shadow2.map.dispose();\n        }\n        shadow2.map = \
new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        \
shadow2.map.texture.name = light.name + \".shadowMap\";\n        \
shadow2.camera.updateProjectionMatrix();\n      }\n      \
renderer3.setRenderTarget(shadow2.map);\n      renderer3.clear();\n      \
const viewportCount = shadow2.getViewportCount();\n      for (let vp = 0; vp \
< viewportCount; vp++) {\n        const viewport2 = \
shadow2.getViewport(vp);\n        _viewport.set(\n          _viewportSize.x * \
viewport2.x,\n          _viewportSize.y * viewport2.y,\n          \
_viewportSize.x * viewport2.z,\n          _viewportSize.y * viewport2.w\n     \
   );\n        _state.viewport(_viewport);\n        \
shadow2.updateMatrices(light, vp);\n        _frustum2 = \
shadow2.getFrustum();\n        renderObject(scene3, camera3, shadow2.camera, \
light, this.type);\n      }\n      if (shadow2.isPointLightShadow !== true && \
this.type === VSMShadowMap) {\n        VSMPass(shadow2, camera3);\n      }\n  \
    shadow2.needsUpdate = false;\n    }\n    _previousType = this.type;\n    \
scope.needsUpdate = false;\n    \
renderer3.setRenderTarget(currentRenderTarget, activeCubeFace, \
activeMipmapLevel);\n  };\n  function VSMPass(shadow2, camera3) {\n    const \
geometry = objects.update(fullScreenMesh);\n    if \
(shadowMaterialVertical.defines.VSM_SAMPLES !== shadow2.blurSamples) {\n      \
shadowMaterialVertical.defines.VSM_SAMPLES = shadow2.blurSamples;\n      \
shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow2.blurSamples;\n      \
shadowMaterialVertical.needsUpdate = true;\n      \
shadowMaterialHorizontal.needsUpdate = true;\n    }\n    if (shadow2.mapPass \
=== null) {\n      shadow2.mapPass = new WebGLRenderTarget(_shadowMapSize.x, \
_shadowMapSize.y);\n    }\n    \
shadowMaterialVertical.uniforms.shadow_pass.value = shadow2.map.texture;\n    \
shadowMaterialVertical.uniforms.resolution.value = shadow2.mapSize;\n    \
shadowMaterialVertical.uniforms.radius.value = shadow2.radius;\n    \
renderer3.setRenderTarget(shadow2.mapPass);\n    renderer3.clear();\n    \
renderer3.renderBufferDirect(camera3, null, geometry, shadowMaterialVertical, \
fullScreenMesh, null);\n    \
shadowMaterialHorizontal.uniforms.shadow_pass.value = \
shadow2.mapPass.texture;\n    \
shadowMaterialHorizontal.uniforms.resolution.value = shadow2.mapSize;\n    \
shadowMaterialHorizontal.uniforms.radius.value = shadow2.radius;\n    \
renderer3.setRenderTarget(shadow2.map);\n    renderer3.clear();\n    \
renderer3.renderBufferDirect(camera3, null, geometry, \
shadowMaterialHorizontal, fullScreenMesh, null);\n  }\n  function \
getDepthMaterial(object, material, light, type) {\n    let result = null;\n   \
 const customMaterial = light.isPointLight === true ? \
object.customDistanceMaterial : object.customDepthMaterial;\n    if \
(customMaterial !== void 0) {\n      result = customMaterial;\n    } else {\n \
     result = light.isPointLight === true ? _distanceMaterial : \
_depthMaterial;\n      if (renderer3.localClippingEnabled && \
material.clipShadows === true && Array.isArray(material.clippingPlanes) && \
material.clippingPlanes.length !== 0 || material.displacementMap && \
material.displacementScale !== 0 || material.alphaMap && material.alphaTest > \
0 || material.map && material.alphaTest > 0) {\n        const keyA = \
result.uuid, keyB = material.uuid;\n        let materialsForVariant = \
_materialCache[keyA];\n        if (materialsForVariant === void 0) {\n        \
  materialsForVariant = {};\n          _materialCache[keyA] = \
materialsForVariant;\n        }\n        let cachedMaterial = \
materialsForVariant[keyB];\n        if (cachedMaterial === void 0) {\n        \
  cachedMaterial = result.clone();\n          materialsForVariant[keyB] = \
cachedMaterial;\n          material.addEventListener(\"dispose\", \
onMaterialDispose);\n        }\n        result = cachedMaterial;\n      }\n   \
 }\n    result.visible = material.visible;\n    result.wireframe = \
material.wireframe;\n    if (type === VSMShadowMap) {\n      result.side = \
material.shadowSide !== null ? material.shadowSide : material.side;\n    } \
else {\n      result.side = material.shadowSide !== null ? \
material.shadowSide : shadowSide[material.side];\n    }\n    result.alphaMap \
= material.alphaMap;\n    result.alphaTest = material.alphaTest;\n    \
result.map = material.map;\n    result.clipShadows = material.clipShadows;\n  \
  result.clippingPlanes = material.clippingPlanes;\n    \
result.clipIntersection = material.clipIntersection;\n    \
result.displacementMap = material.displacementMap;\n    \
result.displacementScale = material.displacementScale;\n    \
result.displacementBias = material.displacementBias;\n    \
result.wireframeLinewidth = material.wireframeLinewidth;\n    \
result.linewidth = material.linewidth;\n    if (light.isPointLight === true \
&& result.isMeshDistanceMaterial === true) {\n      const materialProperties \
= renderer3.properties.get(result);\n      materialProperties.light = \
light;\n    }\n    return result;\n  }\n  function renderObject(object, \
camera3, shadowCamera, light, type) {\n    if (object.visible === false) \
return;\n    const visible = object.layers.test(camera3.layers);\n    if \
(visible && (object.isMesh || object.isLine || object.isPoints)) {\n      if \
((object.castShadow || object.receiveShadow && type === VSMShadowMap) && \
(!object.frustumCulled || _frustum2.intersectsObject(object))) {\n        \
object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, \
object.matrixWorld);\n        const geometry = objects.update(object);\n      \
  const material = object.material;\n        if (Array.isArray(material)) {\n \
         const groups = geometry.groups;\n          for (let k = 0, kl = \
groups.length; k < kl; k++) {\n            const group = groups[k];\n         \
   const groupMaterial = material[group.materialIndex];\n            if \
(groupMaterial && groupMaterial.visible) {\n              const depthMaterial \
= getDepthMaterial(object, groupMaterial, light, type);\n              \
object.onBeforeShadow(renderer3, object, camera3, shadowCamera, geometry, \
depthMaterial, group);\n              \
renderer3.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, \
object, group);\n              object.onAfterShadow(renderer3, object, \
camera3, shadowCamera, geometry, depthMaterial, group);\n            }\n      \
    }\n        } else if (material.visible) {\n          const depthMaterial \
= getDepthMaterial(object, material, light, type);\n          \
object.onBeforeShadow(renderer3, object, camera3, shadowCamera, geometry, \
depthMaterial, null);\n          renderer3.renderBufferDirect(shadowCamera, \
null, geometry, depthMaterial, object, null);\n          \
object.onAfterShadow(renderer3, object, camera3, shadowCamera, geometry, \
depthMaterial, null);\n        }\n      }\n    }\n    const children = \
object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n    \
  renderObject(children[i], camera3, shadowCamera, light, type);\n    }\n  \
}\n  function onMaterialDispose(event) {\n    const material = \
event.target;\n    material.removeEventListener(\"dispose\", \
onMaterialDispose);\n    for (const id2 in _materialCache) {\n      const \
cache2 = _materialCache[id2];\n      const uuid = event.target.uuid;\n      \
if (uuid in cache2) {\n        const shadowMaterial = cache2[uuid];\n        \
shadowMaterial.dispose();\n        delete cache2[uuid];\n      }\n    }\n  \
}\n}\nvar reversedFuncs = {\n  [NeverDepth]: AlwaysDepth,\n  [LessDepth]: \
GreaterDepth,\n  [EqualDepth]: NotEqualDepth,\n  [LessEqualDepth]: \
GreaterEqualDepth,\n  [AlwaysDepth]: NeverDepth,\n  [GreaterDepth]: \
LessDepth,\n  [NotEqualDepth]: EqualDepth,\n  [GreaterEqualDepth]: \
LessEqualDepth\n};\nfunction WebGLState(gl, extensions) {\n  function \
ColorBuffer() {\n    let locked = false;\n    const color2 = new Vector4();\n \
   let currentColorMask = null;\n    const currentColorClear = new Vector4(0, \
0, 0, 0);\n    return {\n      setMask: function(colorMask) {\n        if \
(currentColorMask !== colorMask && !locked) {\n          \
gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n          \
currentColorMask = colorMask;\n        }\n      },\n      setLocked: \
function(lock) {\n        locked = lock;\n      },\n      setClear: \
function(r, g, b, a2, premultipliedAlpha) {\n        if (premultipliedAlpha \
=== true) {\n          r *= a2;\n          g *= a2;\n          b *= a2;\n     \
   }\n        color2.set(r, g, b, a2);\n        if \
(currentColorClear.equals(color2) === false) {\n          gl.clearColor(r, g, \
b, a2);\n          currentColorClear.copy(color2);\n        }\n      },\n     \
 reset: function() {\n        locked = false;\n        currentColorMask = \
null;\n        currentColorClear.set(-1, 0, 0, 0);\n      }\n    };\n  }\n  \
function DepthBuffer() {\n    let locked = false;\n    let reversed = \
false;\n    let currentDepthMask = null;\n    let currentDepthFunc = null;\n  \
  let currentDepthClear = null;\n    return {\n      setReversed: \
function(value) {\n        if (reversed !== value) {\n          const ext = \
extensions.get(\"EXT_clip_control\");\n          if (reversed) {\n            \
ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT);\n          } \
else {\n            ext.clipControlEXT(ext.LOWER_LEFT_EXT, \
ext.NEGATIVE_ONE_TO_ONE_EXT);\n          }\n          const oldDepth = \
currentDepthClear;\n          currentDepthClear = null;\n          \
this.setClear(oldDepth);\n        }\n        reversed = value;\n      },\n    \
  getReversed: function() {\n        return reversed;\n      },\n      \
setTest: function(depthTest) {\n        if (depthTest) {\n          \
enable(gl.DEPTH_TEST);\n        } else {\n          disable(gl.DEPTH_TEST);\n \
       }\n      },\n      setMask: function(depthMask) {\n        if \
(currentDepthMask !== depthMask && !locked) {\n          \
gl.depthMask(depthMask);\n          currentDepthMask = depthMask;\n        \
}\n      },\n      setFunc: function(depthFunc) {\n        if (reversed) \
depthFunc = reversedFuncs[depthFunc];\n        if (currentDepthFunc !== \
depthFunc) {\n          switch (depthFunc) {\n            case NeverDepth:\n  \
            gl.depthFunc(gl.NEVER);\n              break;\n            case \
AlwaysDepth:\n              gl.depthFunc(gl.ALWAYS);\n              break;\n  \
          case LessDepth:\n              gl.depthFunc(gl.LESS);\n             \
 break;\n            case LessEqualDepth:\n              \
gl.depthFunc(gl.LEQUAL);\n              break;\n            case \
EqualDepth:\n              gl.depthFunc(gl.EQUAL);\n              break;\n    \
        case GreaterEqualDepth:\n              gl.depthFunc(gl.GEQUAL);\n     \
         break;\n            case GreaterDepth:\n              \
gl.depthFunc(gl.GREATER);\n              break;\n            case \
NotEqualDepth:\n              gl.depthFunc(gl.NOTEQUAL);\n              \
break;\n            default:\n              gl.depthFunc(gl.LEQUAL);\n        \
  }\n          currentDepthFunc = depthFunc;\n        }\n      },\n      \
setLocked: function(lock) {\n        locked = lock;\n      },\n      \
setClear: function(depth2) {\n        if (currentDepthClear !== depth2) {\n   \
       if (reversed) {\n            depth2 = 1 - depth2;\n          }\n       \
   gl.clearDepth(depth2);\n          currentDepthClear = depth2;\n        }\n \
     },\n      reset: function() {\n        locked = false;\n        \
currentDepthMask = null;\n        currentDepthFunc = null;\n        \
currentDepthClear = null;\n        reversed = false;\n      }\n    };\n  }\n  \
function StencilBuffer() {\n    let locked = false;\n    let \
currentStencilMask = null;\n    let currentStencilFunc = null;\n    let \
currentStencilRef = null;\n    let currentStencilFuncMask = null;\n    let \
currentStencilFail = null;\n    let currentStencilZFail = null;\n    let \
currentStencilZPass = null;\n    let currentStencilClear = null;\n    return \
{\n      setTest: function(stencilTest) {\n        if (!locked) {\n          \
if (stencilTest) {\n            enable(gl.STENCIL_TEST);\n          } else \
{\n            disable(gl.STENCIL_TEST);\n          }\n        }\n      },\n  \
    setMask: function(stencilMask) {\n        if (currentStencilMask !== \
stencilMask && !locked) {\n          gl.stencilMask(stencilMask);\n          \
currentStencilMask = stencilMask;\n        }\n      },\n      setFunc: \
function(stencilFunc, stencilRef, stencilMask) {\n        if \
(currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || \
currentStencilFuncMask !== stencilMask) {\n          \
gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n          \
currentStencilFunc = stencilFunc;\n          currentStencilRef = \
stencilRef;\n          currentStencilFuncMask = stencilMask;\n        }\n     \
 },\n      setOp: function(stencilFail, stencilZFail, stencilZPass) {\n       \
 if (currentStencilFail !== stencilFail || currentStencilZFail !== \
stencilZFail || currentStencilZPass !== stencilZPass) {\n          \
gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n          \
currentStencilFail = stencilFail;\n          currentStencilZFail = \
stencilZFail;\n          currentStencilZPass = stencilZPass;\n        }\n     \
 },\n      setLocked: function(lock) {\n        locked = lock;\n      },\n    \
  setClear: function(stencil) {\n        if (currentStencilClear !== stencil) \
{\n          gl.clearStencil(stencil);\n          currentStencilClear = \
stencil;\n        }\n      },\n      reset: function() {\n        locked = \
false;\n        currentStencilMask = null;\n        currentStencilFunc = \
null;\n        currentStencilRef = null;\n        currentStencilFuncMask = \
null;\n        currentStencilFail = null;\n        currentStencilZFail = \
null;\n        currentStencilZPass = null;\n        currentStencilClear = \
null;\n      }\n    };\n  }\n  const colorBuffer = new ColorBuffer();\n  \
const depthBuffer = new DepthBuffer();\n  const stencilBuffer = new \
StencilBuffer();\n  const uboBindings = /* @__PURE__ */ new WeakMap();\n  \
const uboProgramMap = /* @__PURE__ */ new WeakMap();\n  let \
enabledCapabilities = {};\n  let currentBoundFramebuffers = {};\n  let \
currentDrawbuffers = /* @__PURE__ */ new WeakMap();\n  let defaultDrawbuffers \
= [];\n  let currentProgram = null;\n  let currentBlendingEnabled = false;\n  \
let currentBlending = null;\n  let currentBlendEquation = null;\n  let \
currentBlendSrc = null;\n  let currentBlendDst = null;\n  let \
currentBlendEquationAlpha = null;\n  let currentBlendSrcAlpha = null;\n  let \
currentBlendDstAlpha = null;\n  let currentBlendColor = new Color(0, 0, 0);\n \
 let currentBlendAlpha = 0;\n  let currentPremultipledAlpha = false;\n  let \
currentFlipSided = null;\n  let currentCullFace = null;\n  let \
currentLineWidth = null;\n  let currentPolygonOffsetFactor = null;\n  let \
currentPolygonOffsetUnits = null;\n  const maxTextures = \
gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n  let \
lineWidthAvailable = false;\n  let version = 0;\n  const glVersion = \
gl.getParameter(gl.VERSION);\n  if (glVersion.indexOf(\"WebGL\") !== -1) {\n  \
  version = parseFloat(/^WebGL (\\d)/.exec(glVersion)[1]);\n    \
lineWidthAvailable = version >= 1;\n  } else if (glVersion.indexOf(\"OpenGL \
ES\") !== -1) {\n    version = parseFloat(/^OpenGL ES \
(\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 2;\n  }\n  \
let currentTextureSlot = null;\n  let currentBoundTextures = {};\n  const \
scissorParam = gl.getParameter(gl.SCISSOR_BOX);\n  const viewportParam = \
gl.getParameter(gl.VIEWPORT);\n  const currentScissor = new \
Vector4().fromArray(scissorParam);\n  const currentViewport = new \
Vector4().fromArray(viewportParam);\n  function createTexture(type, target, \
count, dimensions) {\n    const data = new Uint8Array(4);\n    const texture2 \
= gl.createTexture();\n    gl.bindTexture(type, texture2);\n    \
gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    \
gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    for (let i = \
0; i < count; i++) {\n      if (type === gl.TEXTURE_3D || type === \
gl.TEXTURE_2D_ARRAY) {\n        gl.texImage3D(target, 0, gl.RGBA, 1, 1, \
dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      } else {\n        \
gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, \
data);\n      }\n    }\n    return texture2;\n  }\n  const emptyTextures = \
{};\n  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, \
gl.TEXTURE_2D, 1);\n  emptyTextures[gl.TEXTURE_CUBE_MAP] = \
createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);\n  \
emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, \
gl.TEXTURE_2D_ARRAY, 1, 1);\n  emptyTextures[gl.TEXTURE_3D] = \
createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);\n  colorBuffer.setClear(0, \
0, 0, 1);\n  depthBuffer.setClear(1);\n  stencilBuffer.setClear(0);\n  \
enable(gl.DEPTH_TEST);\n  depthBuffer.setFunc(LessEqualDepth);\n  \
setFlipSided(false);\n  setCullFace(CullFaceBack);\n  enable(gl.CULL_FACE);\n \
 setBlending(NoBlending);\n  function enable(id2) {\n    if \
(enabledCapabilities[id2] !== true) {\n      gl.enable(id2);\n      \
enabledCapabilities[id2] = true;\n    }\n  }\n  function disable(id2) {\n    \
if (enabledCapabilities[id2] !== false) {\n      gl.disable(id2);\n      \
enabledCapabilities[id2] = false;\n    }\n  }\n  function \
bindFramebuffer(target, framebuffer) {\n    if \
(currentBoundFramebuffers[target] !== framebuffer) {\n      \
gl.bindFramebuffer(target, framebuffer);\n      \
currentBoundFramebuffers[target] = framebuffer;\n      if (target === \
gl.DRAW_FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.FRAMEBUFFER] = \
framebuffer;\n      }\n      if (target === gl.FRAMEBUFFER) {\n        \
currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;\n      }\n      \
return true;\n    }\n    return false;\n  }\n  function \
drawBuffers(renderTarget, framebuffer) {\n    let drawBuffers2 = \
defaultDrawbuffers;\n    let needsUpdate = false;\n    if (renderTarget) {\n  \
    drawBuffers2 = currentDrawbuffers.get(framebuffer);\n      if \
(drawBuffers2 === void 0) {\n        drawBuffers2 = [];\n        \
currentDrawbuffers.set(framebuffer, drawBuffers2);\n      }\n      const \
textures = renderTarget.textures;\n      if (drawBuffers2.length !== \
textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {\n        for \
(let i = 0, il = textures.length; i < il; i++) {\n          drawBuffers2[i] = \
gl.COLOR_ATTACHMENT0 + i;\n        }\n        drawBuffers2.length = \
textures.length;\n        needsUpdate = true;\n      }\n    } else {\n      \
if (drawBuffers2[0] !== gl.BACK) {\n        drawBuffers2[0] = gl.BACK;\n      \
  needsUpdate = true;\n      }\n    }\n    if (needsUpdate) {\n      \
gl.drawBuffers(drawBuffers2);\n    }\n  }\n  function useProgram(program) {\n \
   if (currentProgram !== program) {\n      gl.useProgram(program);\n      \
currentProgram = program;\n      return true;\n    }\n    return false;\n  \
}\n  const equationToGL2 = {\n    [AddEquation]: gl.FUNC_ADD,\n    \
[SubtractEquation]: gl.FUNC_SUBTRACT,\n    [ReverseSubtractEquation]: \
gl.FUNC_REVERSE_SUBTRACT\n  };\n  equationToGL2[MinEquation] = gl.MIN;\n  \
equationToGL2[MaxEquation] = gl.MAX;\n  const factorToGL2 = {\n    \
[ZeroFactor]: gl.ZERO,\n    [OneFactor]: gl.ONE,\n    [SrcColorFactor]: \
gl.SRC_COLOR,\n    [SrcAlphaFactor]: gl.SRC_ALPHA,\n    \
[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,\n    [DstColorFactor]: \
gl.DST_COLOR,\n    [DstAlphaFactor]: gl.DST_ALPHA,\n    \
[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,\n    \
[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,\n    \
[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,\n    \
[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,\n    [ConstantColorFactor]: \
gl.CONSTANT_COLOR,\n    [OneMinusConstantColorFactor]: \
gl.ONE_MINUS_CONSTANT_COLOR,\n    [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,\n \
   [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA\n  };\n  \
function setBlending(blending, blendEquation, blendSrc, blendDst, \
blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, \
premultipliedAlpha) {\n    if (blending === NoBlending) {\n      if \
(currentBlendingEnabled === true) {\n        disable(gl.BLEND);\n        \
currentBlendingEnabled = false;\n      }\n      return;\n    }\n    if \
(currentBlendingEnabled === false) {\n      enable(gl.BLEND);\n      \
currentBlendingEnabled = true;\n    }\n    if (blending !== CustomBlending) \
{\n      if (blending !== currentBlending || premultipliedAlpha !== \
currentPremultipledAlpha) {\n        if (currentBlendEquation !== AddEquation \
|| currentBlendEquationAlpha !== AddEquation) {\n          \
gl.blendEquation(gl.FUNC_ADD);\n          currentBlendEquation = \
AddEquation;\n          currentBlendEquationAlpha = AddEquation;\n        }\n \
       if (premultipliedAlpha) {\n          switch (blending) {\n            \
case NormalBlending:\n              gl.blendFuncSeparate(gl.ONE, \
gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              \
break;\n            case AdditiveBlending:\n              \
gl.blendFunc(gl.ONE, gl.ONE);\n              break;\n            case \
SubtractiveBlending:\n              gl.blendFuncSeparate(gl.ZERO, \
gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            \
case MultiplyBlending:\n              gl.blendFuncSeparate(gl.ZERO, \
gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n              break;\n            \
default:\n              console.error(\"THREE.WebGLState: Invalid blending: \
\", blending);\n              break;\n          }\n        } else {\n         \
 switch (blending) {\n            case NormalBlending:\n              \
gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, \
gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case \
AdditiveBlending:\n              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n        \
      break;\n            case SubtractiveBlending:\n              \
gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n     \
         break;\n            case MultiplyBlending:\n              \
gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n              break;\n            \
default:\n              console.error(\"THREE.WebGLState: Invalid blending: \
\", blending);\n              break;\n          }\n        }\n        \
currentBlendSrc = null;\n        currentBlendDst = null;\n        \
currentBlendSrcAlpha = null;\n        currentBlendDstAlpha = null;\n        \
currentBlendColor.set(0, 0, 0);\n        currentBlendAlpha = 0;\n        \
currentBlending = blending;\n        currentPremultipledAlpha = \
premultipliedAlpha;\n      }\n      return;\n    }\n    blendEquationAlpha = \
blendEquationAlpha || blendEquation;\n    blendSrcAlpha = blendSrcAlpha || \
blendSrc;\n    blendDstAlpha = blendDstAlpha || blendDst;\n    if \
(blendEquation !== currentBlendEquation || blendEquationAlpha !== \
currentBlendEquationAlpha) {\n      \
gl.blendEquationSeparate(equationToGL2[blendEquation], \
equationToGL2[blendEquationAlpha]);\n      currentBlendEquation = \
blendEquation;\n      currentBlendEquationAlpha = blendEquationAlpha;\n    \
}\n    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || \
blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== \
currentBlendDstAlpha) {\n      gl.blendFuncSeparate(factorToGL2[blendSrc], \
factorToGL2[blendDst], factorToGL2[blendSrcAlpha], \
factorToGL2[blendDstAlpha]);\n      currentBlendSrc = blendSrc;\n      \
currentBlendDst = blendDst;\n      currentBlendSrcAlpha = blendSrcAlpha;\n    \
  currentBlendDstAlpha = blendDstAlpha;\n    }\n    if \
(blendColor.equals(currentBlendColor) === false || blendAlpha !== \
currentBlendAlpha) {\n      gl.blendColor(blendColor.r, blendColor.g, \
blendColor.b, blendAlpha);\n      currentBlendColor.copy(blendColor);\n      \
currentBlendAlpha = blendAlpha;\n    }\n    currentBlending = blending;\n    \
currentPremultipledAlpha = false;\n  }\n  function setMaterial(material, \
frontFaceCW) {\n    material.side === DoubleSide ? disable(gl.CULL_FACE) : \
enable(gl.CULL_FACE);\n    let flipSided = material.side === BackSide;\n    \
if (frontFaceCW) flipSided = !flipSided;\n    setFlipSided(flipSided);\n    \
material.blending === NormalBlending && material.transparent === false ? \
setBlending(NoBlending) : setBlending(material.blending, \
material.blendEquation, material.blendSrc, material.blendDst, \
material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, \
material.blendColor, material.blendAlpha, material.premultipliedAlpha);\n    \
depthBuffer.setFunc(material.depthFunc);\n    \
depthBuffer.setTest(material.depthTest);\n    \
depthBuffer.setMask(material.depthWrite);\n    \
colorBuffer.setMask(material.colorWrite);\n    const stencilWrite = \
material.stencilWrite;\n    stencilBuffer.setTest(stencilWrite);\n    if \
(stencilWrite) {\n      stencilBuffer.setMask(material.stencilWriteMask);\n   \
   stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, \
material.stencilFuncMask);\n      stencilBuffer.setOp(material.stencilFail, \
material.stencilZFail, material.stencilZPass);\n    }\n    \
setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, \
material.polygonOffsetUnits);\n    material.alphaToCoverage === true ? \
enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n \
 }\n  function setFlipSided(flipSided) {\n    if (currentFlipSided !== \
flipSided) {\n      if (flipSided) {\n        gl.frontFace(gl.CW);\n      } \
else {\n        gl.frontFace(gl.CCW);\n      }\n      currentFlipSided = \
flipSided;\n    }\n  }\n  function setCullFace(cullFace) {\n    if (cullFace \
!== CullFaceNone) {\n      enable(gl.CULL_FACE);\n      if (cullFace !== \
currentCullFace) {\n        if (cullFace === CullFaceBack) {\n          \
gl.cullFace(gl.BACK);\n        } else if (cullFace === CullFaceFront) {\n     \
     gl.cullFace(gl.FRONT);\n        } else {\n          \
gl.cullFace(gl.FRONT_AND_BACK);\n        }\n      }\n    } else {\n      \
disable(gl.CULL_FACE);\n    }\n    currentCullFace = cullFace;\n  }\n  \
function setLineWidth(width) {\n    if (width !== currentLineWidth) {\n      \
if (lineWidthAvailable) gl.lineWidth(width);\n      currentLineWidth = \
width;\n    }\n  }\n  function setPolygonOffset(polygonOffset, factor, units) \
{\n    if (polygonOffset) {\n      enable(gl.POLYGON_OFFSET_FILL);\n      if \
(currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== \
units) {\n        gl.polygonOffset(factor, units);\n        \
currentPolygonOffsetFactor = factor;\n        currentPolygonOffsetUnits = \
units;\n      }\n    } else {\n      disable(gl.POLYGON_OFFSET_FILL);\n    \
}\n  }\n  function setScissorTest(scissorTest) {\n    if (scissorTest) {\n    \
  enable(gl.SCISSOR_TEST);\n    } else {\n      disable(gl.SCISSOR_TEST);\n   \
 }\n  }\n  function activeTexture(webglSlot) {\n    if (webglSlot === void 0) \
webglSlot = gl.TEXTURE0 + maxTextures - 1;\n    if (currentTextureSlot !== \
webglSlot) {\n      gl.activeTexture(webglSlot);\n      currentTextureSlot = \
webglSlot;\n    }\n  }\n  function bindTexture(webglType, webglTexture, \
webglSlot) {\n    if (webglSlot === void 0) {\n      if (currentTextureSlot \
=== null) {\n        webglSlot = gl.TEXTURE0 + maxTextures - 1;\n      } else \
{\n        webglSlot = currentTextureSlot;\n      }\n    }\n    let \
boundTexture = currentBoundTextures[webglSlot];\n    if (boundTexture === \
void 0) {\n      boundTexture = { type: void 0, texture: void 0 };\n      \
currentBoundTextures[webglSlot] = boundTexture;\n    }\n    if \
(boundTexture.type !== webglType || boundTexture.texture !== webglTexture) \
{\n      if (currentTextureSlot !== webglSlot) {\n        \
gl.activeTexture(webglSlot);\n        currentTextureSlot = webglSlot;\n      \
}\n      gl.bindTexture(webglType, webglTexture || \
emptyTextures[webglType]);\n      boundTexture.type = webglType;\n      \
boundTexture.texture = webglTexture;\n    }\n  }\n  function unbindTexture() \
{\n    const boundTexture = currentBoundTextures[currentTextureSlot];\n    if \
(boundTexture !== void 0 && boundTexture.type !== void 0) {\n      \
gl.bindTexture(boundTexture.type, null);\n      boundTexture.type = void 0;\n \
     boundTexture.texture = void 0;\n    }\n  }\n  function \
compressedTexImage2D() {\n    try {\n      gl.compressedTexImage2D.apply(gl, \
arguments);\n    } catch (error) {\n      \
console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function \
compressedTexImage3D() {\n    try {\n      gl.compressedTexImage3D.apply(gl, \
arguments);\n    } catch (error) {\n      \
console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function \
texSubImage2D() {\n    try {\n      gl.texSubImage2D.apply(gl, arguments);\n  \
  } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    \
}\n  }\n  function texSubImage3D() {\n    try {\n      \
gl.texSubImage3D.apply(gl, arguments);\n    } catch (error) {\n      \
console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function \
compressedTexSubImage2D() {\n    try {\n      \
gl.compressedTexSubImage2D.apply(gl, arguments);\n    } catch (error) {\n     \
 console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function \
compressedTexSubImage3D() {\n    try {\n      \
gl.compressedTexSubImage3D.apply(gl, arguments);\n    } catch (error) {\n     \
 console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function \
texStorage2D() {\n    try {\n      gl.texStorage2D.apply(gl, arguments);\n    \
} catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    \
}\n  }\n  function texStorage3D() {\n    try {\n      \
gl.texStorage3D.apply(gl, arguments);\n    } catch (error) {\n      \
console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function \
texImage2D() {\n    try {\n      gl.texImage2D.apply(gl, arguments);\n    } \
catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  \
}\n  function texImage3D() {\n    try {\n      gl.texImage3D.apply(gl, \
arguments);\n    } catch (error) {\n      \
console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function \
scissor(scissor2) {\n    if (currentScissor.equals(scissor2) === false) {\n   \
   gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);\n      \
currentScissor.copy(scissor2);\n    }\n  }\n  function viewport2(viewport3) \
{\n    if (currentViewport.equals(viewport3) === false) {\n      \
gl.viewport(viewport3.x, viewport3.y, viewport3.z, viewport3.w);\n      \
currentViewport.copy(viewport3);\n    }\n  }\n  function \
updateUBOMapping(uniformsGroup, program) {\n    let mapping = \
uboProgramMap.get(program);\n    if (mapping === void 0) {\n      mapping = \
/* @__PURE__ */ new WeakMap();\n      uboProgramMap.set(program, mapping);\n  \
  }\n    let blockIndex = mapping.get(uniformsGroup);\n    if (blockIndex === \
void 0) {\n      blockIndex = gl.getUniformBlockIndex(program, \
uniformsGroup.name);\n      mapping.set(uniformsGroup, blockIndex);\n    }\n  \
}\n  function uniformBlockBinding(uniformsGroup, program) {\n    const \
mapping = uboProgramMap.get(program);\n    const blockIndex = \
mapping.get(uniformsGroup);\n    if (uboBindings.get(program) !== blockIndex) \
{\n      gl.uniformBlockBinding(program, blockIndex, \
uniformsGroup.__bindingPointIndex);\n      uboBindings.set(program, \
blockIndex);\n    }\n  }\n  function reset() {\n    gl.disable(gl.BLEND);\n   \
 gl.disable(gl.CULL_FACE);\n    gl.disable(gl.DEPTH_TEST);\n    \
gl.disable(gl.POLYGON_OFFSET_FILL);\n    gl.disable(gl.SCISSOR_TEST);\n    \
gl.disable(gl.STENCIL_TEST);\n    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n  \
  gl.blendEquation(gl.FUNC_ADD);\n    gl.blendFunc(gl.ONE, gl.ZERO);\n    \
gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);\n    gl.blendColor(0, \
0, 0, 0);\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0, 0, \
0, 0);\n    gl.depthMask(true);\n    gl.depthFunc(gl.LESS);\n    \
depthBuffer.setReversed(false);\n    gl.clearDepth(1);\n    \
gl.stencilMask(4294967295);\n    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);\n  \
  gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n    gl.clearStencil(0);\n    \
gl.cullFace(gl.BACK);\n    gl.frontFace(gl.CCW);\n    gl.polygonOffset(0, \
0);\n    gl.activeTexture(gl.TEXTURE0);\n    \
gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    \
gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n    \
gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    gl.useProgram(null);\n    \
gl.lineWidth(1);\n    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n  \
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    \
enabledCapabilities = {};\n    currentTextureSlot = null;\n    \
currentBoundTextures = {};\n    currentBoundFramebuffers = {};\n    \
currentDrawbuffers = /* @__PURE__ */ new WeakMap();\n    defaultDrawbuffers = \
[];\n    currentProgram = null;\n    currentBlendingEnabled = false;\n    \
currentBlending = null;\n    currentBlendEquation = null;\n    \
currentBlendSrc = null;\n    currentBlendDst = null;\n    \
currentBlendEquationAlpha = null;\n    currentBlendSrcAlpha = null;\n    \
currentBlendDstAlpha = null;\n    currentBlendColor = new Color(0, 0, 0);\n   \
 currentBlendAlpha = 0;\n    currentPremultipledAlpha = false;\n    \
currentFlipSided = null;\n    currentCullFace = null;\n    currentLineWidth = \
null;\n    currentPolygonOffsetFactor = null;\n    currentPolygonOffsetUnits \
= null;\n    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);\n   \
 currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);\n    \
colorBuffer.reset();\n    depthBuffer.reset();\n    stencilBuffer.reset();\n  \
}\n  return {\n    buffers: {\n      color: colorBuffer,\n      depth: \
depthBuffer,\n      stencil: stencilBuffer\n    },\n    enable,\n    \
disable,\n    bindFramebuffer,\n    drawBuffers,\n    useProgram,\n    \
setBlending,\n    setMaterial,\n    setFlipSided,\n    setCullFace,\n    \
setLineWidth,\n    setPolygonOffset,\n    setScissorTest,\n    \
activeTexture,\n    bindTexture,\n    unbindTexture,\n    \
compressedTexImage2D,\n    compressedTexImage3D,\n    texImage2D,\n    \
texImage3D,\n    updateUBOMapping,\n    uniformBlockBinding,\n    \
texStorage2D,\n    texStorage3D,\n    texSubImage2D,\n    texSubImage3D,\n    \
compressedTexSubImage2D,\n    compressedTexSubImage3D,\n    scissor,\n    \
viewport: viewport2,\n    reset\n  };\n}\nfunction getByteLength(width, \
height, format2, type) {\n  const typeByteLength = \
getTextureTypeByteLength(type);\n  switch (format2) {\n    // \
https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml\n  \
  case AlphaFormat:\n      return width * height;\n    case \
LuminanceFormat:\n      return width * height;\n    case \
LuminanceAlphaFormat:\n      return width * height * 2;\n    case \
RedFormat:\n      return width * height / typeByteLength.components * \
typeByteLength.byteLength;\n    case RedIntegerFormat:\n      return width * \
height / typeByteLength.components * typeByteLength.byteLength;\n    case \
RGFormat:\n      return width * height * 2 / typeByteLength.components * \
typeByteLength.byteLength;\n    case RGIntegerFormat:\n      return width * \
height * 2 / typeByteLength.components * typeByteLength.byteLength;\n    case \
RGBFormat:\n      return width * height * 3 / typeByteLength.components * \
typeByteLength.byteLength;\n    case RGBAFormat:\n      return width * height \
* 4 / typeByteLength.components * typeByteLength.byteLength;\n    case \
RGBAIntegerFormat:\n      return width * height * 4 / \
typeByteLength.components * typeByteLength.byteLength;\n    // \
https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_s\
rgb/\n    case RGB_S3TC_DXT1_Format:\n    case RGBA_S3TC_DXT1_Format:\n      \
return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n    \
case RGBA_S3TC_DXT3_Format:\n    case RGBA_S3TC_DXT5_Format:\n      return \
Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n    // \
https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/\
\n    case RGB_PVRTC_2BPPV1_Format:\n    case RGBA_PVRTC_2BPPV1_Format:\n     \
 return Math.max(width, 16) * Math.max(height, 8) / 4;\n    case \
RGB_PVRTC_4BPPV1_Format:\n    case RGBA_PVRTC_4BPPV1_Format:\n      return \
Math.max(width, 8) * Math.max(height, 8) / 2;\n    // \
https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/\n \
   case RGB_ETC1_Format:\n    case RGB_ETC2_Format:\n      return \
Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n    case \
RGBA_ETC2_EAC_Format:\n      return Math.floor((width + 3) / 4) * \
Math.floor((height + 3) / 4) * 16;\n    // \
https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/\
\n    case RGBA_ASTC_4x4_Format:\n      return Math.floor((width + 3) / 4) * \
Math.floor((height + 3) / 4) * 16;\n    case RGBA_ASTC_5x4_Format:\n      \
return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;\n    \
case RGBA_ASTC_5x5_Format:\n      return Math.floor((width + 4) / 5) * \
Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_6x5_Format:\n      \
return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;\n    \
case RGBA_ASTC_6x6_Format:\n      return Math.floor((width + 5) / 6) * \
Math.floor((height + 5) / 6) * 16;\n    case RGBA_ASTC_8x5_Format:\n      \
return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;\n    \
case RGBA_ASTC_8x6_Format:\n      return Math.floor((width + 7) / 8) * \
Math.floor((height + 5) / 6) * 16;\n    case RGBA_ASTC_8x8_Format:\n      \
return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;\n    \
case RGBA_ASTC_10x5_Format:\n      return Math.floor((width + 9) / 10) * \
Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_10x6_Format:\n      \
return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;\n    \
case RGBA_ASTC_10x8_Format:\n      return Math.floor((width + 9) / 10) * \
Math.floor((height + 7) / 8) * 16;\n    case RGBA_ASTC_10x10_Format:\n      \
return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;\n   \
 case RGBA_ASTC_12x10_Format:\n      return Math.floor((width + 11) / 12) * \
Math.floor((height + 9) / 10) * 16;\n    case RGBA_ASTC_12x12_Format:\n      \
return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;\n \
   // \
https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/\n \
   case RGBA_BPTC_Format:\n    case RGB_BPTC_SIGNED_Format:\n    case \
RGB_BPTC_UNSIGNED_Format:\n      return Math.ceil(width / 4) * \
Math.ceil(height / 4) * 16;\n    // \
https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/\n \
   case RED_RGTC1_Format:\n    case SIGNED_RED_RGTC1_Format:\n      return \
Math.ceil(width / 4) * Math.ceil(height / 4) * 8;\n    case \
RED_GREEN_RGTC2_Format:\n    case SIGNED_RED_GREEN_RGTC2_Format:\n      \
return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;\n  }\n  throw new \
Error(\n    `Unable to determine texture byte length for ${format2} \
format.`\n  );\n}\nfunction getTextureTypeByteLength(type) {\n  switch (type) \
{\n    case UnsignedByteType:\n    case ByteType:\n      return { byteLength: \
1, components: 1 };\n    case UnsignedShortType:\n    case ShortType:\n    \
case HalfFloatType:\n      return { byteLength: 2, components: 1 };\n    case \
UnsignedShort4444Type:\n    case UnsignedShort5551Type:\n      return { \
byteLength: 2, components: 4 };\n    case UnsignedIntType:\n    case \
IntType:\n    case FloatType:\n      return { byteLength: 4, components: 1 \
};\n    case UnsignedInt5999Type:\n      return { byteLength: 4, components: \
3 };\n  }\n  throw new Error(`Unknown texture type ${type}.`);\n}\nfunction \
WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) \
{\n  const multisampledRTTExt = \
extensions.has(\"WEBGL_multisampled_render_to_texture\") ? \
extensions.get(\"WEBGL_multisampled_render_to_texture\") : null;\n  const \
supportsInvalidateFramebuffer = typeof navigator === \"undefined\" ? false : \
/OculusBrowser/g.test(navigator.userAgent);\n  const _imageDimensions = new \
Vector2();\n  const _videoTextures = /* @__PURE__ */ new WeakMap();\n  let \
_canvas3;\n  const _sources = /* @__PURE__ */ new WeakMap();\n  let \
useOffscreenCanvas = false;\n  try {\n    useOffscreenCanvas = typeof \
OffscreenCanvas !== \"undefined\" && new OffscreenCanvas(1, \
1).getContext(\"2d\") !== null;\n  } catch (err) {\n  }\n  function \
createCanvas(width, height) {\n    return useOffscreenCanvas ? (\n      // \
eslint-disable-next-line compat/compat\n      new OffscreenCanvas(width, \
height)\n    ) : createElementNS(\"canvas\");\n  }\n  function \
resizeImage(image, needsNewCanvas, maxSize) {\n    let scale = 1;\n    const \
dimensions = getDimensions(image);\n    if (dimensions.width > maxSize || \
dimensions.height > maxSize) {\n      scale = maxSize / \
Math.max(dimensions.width, dimensions.height);\n    }\n    if (scale < 1) {\n \
     if (typeof HTMLImageElement !== \"undefined\" && image instanceof \
HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image \
instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image \
instanceof ImageBitmap || typeof VideoFrame !== \"undefined\" && image \
instanceof VideoFrame) {\n        const width = Math.floor(scale * \
dimensions.width);\n        const height = Math.floor(scale * \
dimensions.height);\n        if (_canvas3 === void 0) _canvas3 = \
createCanvas(width, height);\n        const canvas = needsNewCanvas ? \
createCanvas(width, height) : _canvas3;\n        canvas.width = width;\n      \
  canvas.height = height;\n        const context2 = \
canvas.getContext(\"2d\");\n        context2.drawImage(image, 0, 0, width, \
height);\n        console.warn(\"THREE.WebGLRenderer: Texture has been \
resized from (\" + dimensions.width + \"x\" + dimensions.height + \") to (\" \
+ width + \"x\" + height + \").\");\n        return canvas;\n      } else {\n \
       if (\"data\" in image) {\n          \
console.warn(\"THREE.WebGLRenderer: Image in DataTexture is too big (\" + \
dimensions.width + \"x\" + dimensions.height + \").\");\n        }\n        \
return image;\n      }\n    }\n    return image;\n  }\n  function \
textureNeedsGenerateMipmaps(texture2) {\n    return \
texture2.generateMipmaps;\n  }\n  function generateMipmap(target) {\n    \
_gl.generateMipmap(target);\n  }\n  function getTargetType(texture2) {\n    \
if (texture2.isWebGLCubeRenderTarget) return _gl.TEXTURE_CUBE_MAP;\n    if \
(texture2.isWebGL3DRenderTarget) return _gl.TEXTURE_3D;\n    if \
(texture2.isWebGLArrayRenderTarget || texture2.isCompressedArrayTexture) \
return _gl.TEXTURE_2D_ARRAY;\n    return _gl.TEXTURE_2D;\n  }\n  function \
getInternalFormat(internalFormatName, glFormat, glType, colorSpace, \
forceLinearTransfer = false) {\n    if (internalFormatName !== null) {\n      \
if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];\n     \
 console.warn(\"THREE.WebGLRenderer: Attempt to use non-existing WebGL \
internal format '\" + internalFormatName + \"'\");\n    }\n    let \
internalFormat = glFormat;\n    if (glFormat === _gl.RED) {\n      if (glType \
=== _gl.FLOAT) internalFormat = _gl.R32F;\n      if (glType === \
_gl.HALF_FLOAT) internalFormat = _gl.R16F;\n      if (glType === \
_gl.UNSIGNED_BYTE) internalFormat = _gl.R8;\n    }\n    if (glFormat === \
_gl.RED_INTEGER) {\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = \
_gl.R8UI;\n      if (glType === _gl.UNSIGNED_SHORT) internalFormat = \
_gl.R16UI;\n      if (glType === _gl.UNSIGNED_INT) internalFormat = \
_gl.R32UI;\n      if (glType === _gl.BYTE) internalFormat = _gl.R8I;\n      \
if (glType === _gl.SHORT) internalFormat = _gl.R16I;\n      if (glType === \
_gl.INT) internalFormat = _gl.R32I;\n    }\n    if (glFormat === _gl.RG) {\n  \
    if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;\n      if (glType \
=== _gl.HALF_FLOAT) internalFormat = _gl.RG16F;\n      if (glType === \
_gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;\n    }\n    if (glFormat === \
_gl.RG_INTEGER) {\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = \
_gl.RG8UI;\n      if (glType === _gl.UNSIGNED_SHORT) internalFormat = \
_gl.RG16UI;\n      if (glType === _gl.UNSIGNED_INT) internalFormat = \
_gl.RG32UI;\n      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;\n      \
if (glType === _gl.SHORT) internalFormat = _gl.RG16I;\n      if (glType === \
_gl.INT) internalFormat = _gl.RG32I;\n    }\n    if (glFormat === \
_gl.RGB_INTEGER) {\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = \
_gl.RGB8UI;\n      if (glType === _gl.UNSIGNED_SHORT) internalFormat = \
_gl.RGB16UI;\n      if (glType === _gl.UNSIGNED_INT) internalFormat = \
_gl.RGB32UI;\n      if (glType === _gl.BYTE) internalFormat = _gl.RGB8I;\n    \
  if (glType === _gl.SHORT) internalFormat = _gl.RGB16I;\n      if (glType \
=== _gl.INT) internalFormat = _gl.RGB32I;\n    }\n    if (glFormat === \
_gl.RGBA_INTEGER) {\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = \
_gl.RGBA8UI;\n      if (glType === _gl.UNSIGNED_SHORT) internalFormat = \
_gl.RGBA16UI;\n      if (glType === _gl.UNSIGNED_INT) internalFormat = \
_gl.RGBA32UI;\n      if (glType === _gl.BYTE) internalFormat = _gl.RGBA8I;\n  \
    if (glType === _gl.SHORT) internalFormat = _gl.RGBA16I;\n      if (glType \
=== _gl.INT) internalFormat = _gl.RGBA32I;\n    }\n    if (glFormat === \
_gl.RGB) {\n      if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat \
= _gl.RGB9_E5;\n    }\n    if (glFormat === _gl.RGBA) {\n      const transfer \
= forceLinearTransfer ? LinearTransfer : \
ColorManagement.getTransfer(colorSpace);\n      if (glType === _gl.FLOAT) \
internalFormat = _gl.RGBA32F;\n      if (glType === _gl.HALF_FLOAT) \
internalFormat = _gl.RGBA16F;\n      if (glType === _gl.UNSIGNED_BYTE) \
internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;\n  \
    if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;\n  \
    if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = \
_gl.RGB5_A1;\n    }\n    if (internalFormat === _gl.R16F || internalFormat \
=== _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F \
|| internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {\n      \
extensions.get(\"EXT_color_buffer_float\");\n    }\n    return \
internalFormat;\n  }\n  function getInternalDepthFormat(useStencil, \
depthType) {\n    let glInternalFormat;\n    if (useStencil) {\n      if \
(depthType === null || depthType === UnsignedIntType || depthType === \
UnsignedInt248Type) {\n        glInternalFormat = _gl.DEPTH24_STENCIL8;\n     \
 } else if (depthType === FloatType) {\n        glInternalFormat = \
_gl.DEPTH32F_STENCIL8;\n      } else if (depthType === UnsignedShortType) {\n \
       glInternalFormat = _gl.DEPTH24_STENCIL8;\n        \
console.warn(\"DepthTexture: 16 bit depth attachment is not supported with \
stencil. Using 24-bit attachment.\");\n      }\n    } else {\n      if \
(depthType === null || depthType === UnsignedIntType || depthType === \
UnsignedInt248Type) {\n        glInternalFormat = _gl.DEPTH_COMPONENT24;\n    \
  } else if (depthType === FloatType) {\n        glInternalFormat = \
_gl.DEPTH_COMPONENT32F;\n      } else if (depthType === UnsignedShortType) \
{\n        glInternalFormat = _gl.DEPTH_COMPONENT16;\n      }\n    }\n    \
return glInternalFormat;\n  }\n  function getMipLevels(texture2, image) {\n   \
 if (textureNeedsGenerateMipmaps(texture2) === true || \
texture2.isFramebufferTexture && texture2.minFilter !== NearestFilter && \
texture2.minFilter !== LinearFilter) {\n      return \
Math.log2(Math.max(image.width, image.height)) + 1;\n    } else if \
(texture2.mipmaps !== void 0 && texture2.mipmaps.length > 0) {\n      return \
texture2.mipmaps.length;\n    } else if (texture2.isCompressedTexture && \
Array.isArray(texture2.image)) {\n      return image.mipmaps.length;\n    } \
else {\n      return 1;\n    }\n  }\n  function onTextureDispose2(event) {\n  \
  const texture2 = event.target;\n    \
texture2.removeEventListener(\"dispose\", onTextureDispose2);\n    \
deallocateTexture(texture2);\n    if (texture2.isVideoTexture) {\n      \
_videoTextures.delete(texture2);\n    }\n  }\n  function \
onRenderTargetDispose(event) {\n    const renderTarget = event.target;\n    \
renderTarget.removeEventListener(\"dispose\", onRenderTargetDispose);\n    \
deallocateRenderTarget(renderTarget);\n  }\n  function \
deallocateTexture(texture2) {\n    const textureProperties = \
properties.get(texture2);\n    if (textureProperties.__webglInit === void 0) \
return;\n    const source = texture2.source;\n    const webglTextures = \
_sources.get(source);\n    if (webglTextures) {\n      const webglTexture = \
webglTextures[textureProperties.__cacheKey];\n      \
webglTexture.usedTimes--;\n      if (webglTexture.usedTimes === 0) {\n        \
deleteTexture(texture2);\n      }\n      if \
(Object.keys(webglTextures).length === 0) {\n        \
_sources.delete(source);\n      }\n    }\n    properties.remove(texture2);\n  \
}\n  function deleteTexture(texture2) {\n    const textureProperties = \
properties.get(texture2);\n    \
_gl.deleteTexture(textureProperties.__webglTexture);\n    const source = \
texture2.source;\n    const webglTextures = _sources.get(source);\n    delete \
webglTextures[textureProperties.__cacheKey];\n    info.memory.textures--;\n  \
}\n  function deallocateRenderTarget(renderTarget) {\n    const \
renderTargetProperties = properties.get(renderTarget);\n    if \
(renderTarget.depthTexture) {\n      renderTarget.depthTexture.dispose();\n   \
   properties.remove(renderTarget.depthTexture);\n    }\n    if \
(renderTarget.isWebGLCubeRenderTarget) {\n      for (let i = 0; i < 6; i++) \
{\n        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) \
{\n          for (let level = 0; level < \
renderTargetProperties.__webglFramebuffer[i].length; level++) \
_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);\n \
       } else {\n          \
_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n        \
}\n        if (renderTargetProperties.__webglDepthbuffer) \
_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n      \
}\n    } else {\n      if \
(Array.isArray(renderTargetProperties.__webglFramebuffer)) {\n        for \
(let level = 0; level < renderTargetProperties.__webglFramebuffer.length; \
level++) \
_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);\n    \
  } else {\n        \
_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n      }\n  \
    if (renderTargetProperties.__webglDepthbuffer) \
_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n      if \
(renderTargetProperties.__webglMultisampledFramebuffer) \
_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);\
\n      if (renderTargetProperties.__webglColorRenderbuffer) {\n        for \
(let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) \
{\n          if (renderTargetProperties.__webglColorRenderbuffer[i]) \
_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);\n \
       }\n      }\n      if (renderTargetProperties.__webglDepthRenderbuffer) \
_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n    \
}\n    const textures = renderTarget.textures;\n    for (let i = 0, il = \
textures.length; i < il; i++) {\n      const attachmentProperties = \
properties.get(textures[i]);\n      if (attachmentProperties.__webglTexture) \
{\n        _gl.deleteTexture(attachmentProperties.__webglTexture);\n        \
info.memory.textures--;\n      }\n      properties.remove(textures[i]);\n    \
}\n    properties.remove(renderTarget);\n  }\n  let textureUnits = 0;\n  \
function resetTextureUnits() {\n    textureUnits = 0;\n  }\n  function \
allocateTextureUnit() {\n    const textureUnit = textureUnits;\n    if \
(textureUnit >= capabilities.maxTextures) {\n      \
console.warn(\"THREE.WebGLTextures: Trying to use \" + textureUnit + \" \
texture units while this GPU supports only \" + capabilities.maxTextures);\n  \
  }\n    textureUnits += 1;\n    return textureUnit;\n  }\n  function \
getTextureCacheKey(texture2) {\n    const array = [];\n    \
array.push(texture2.wrapS);\n    array.push(texture2.wrapT);\n    \
array.push(texture2.wrapR || 0);\n    array.push(texture2.magFilter);\n    \
array.push(texture2.minFilter);\n    array.push(texture2.anisotropy);\n    \
array.push(texture2.internalFormat);\n    array.push(texture2.format);\n    \
array.push(texture2.type);\n    array.push(texture2.generateMipmaps);\n    \
array.push(texture2.premultiplyAlpha);\n    array.push(texture2.flipY);\n    \
array.push(texture2.unpackAlignment);\n    array.push(texture2.colorSpace);\n \
   return array.join();\n  }\n  function setTexture2D(texture2, slot) {\n    \
const textureProperties = properties.get(texture2);\n    if \
(texture2.isVideoTexture) updateVideoTexture(texture2);\n    if \
(texture2.isRenderTargetTexture === false && texture2.version > 0 && \
textureProperties.__version !== texture2.version) {\n      const image = \
texture2.image;\n      if (image === null) {\n        \
console.warn(\"THREE.WebGLRenderer: Texture marked for update but no image \
data found.\");\n      } else if (image.complete === false) {\n        \
console.warn(\"THREE.WebGLRenderer: Texture marked for update but image is \
incomplete\");\n      } else {\n        uploadTexture(textureProperties, \
texture2, slot);\n        return;\n      }\n    }\n    \
state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, \
_gl.TEXTURE0 + slot);\n  }\n  function setTexture2DArray(texture2, slot) {\n  \
  const textureProperties = properties.get(texture2);\n    if \
(texture2.version > 0 && textureProperties.__version !== texture2.version) \
{\n      uploadTexture(textureProperties, texture2, slot);\n      return;\n   \
 }\n    state.bindTexture(_gl.TEXTURE_2D_ARRAY, \
textureProperties.__webglTexture, _gl.TEXTURE0 + slot);\n  }\n  function \
setTexture3D(texture2, slot) {\n    const textureProperties = \
properties.get(texture2);\n    if (texture2.version > 0 && \
textureProperties.__version !== texture2.version) {\n      \
uploadTexture(textureProperties, texture2, slot);\n      return;\n    }\n    \
state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, \
_gl.TEXTURE0 + slot);\n  }\n  function setTextureCube(texture2, slot) {\n    \
const textureProperties = properties.get(texture2);\n    if (texture2.version \
> 0 && textureProperties.__version !== texture2.version) {\n      \
uploadCubeTexture(textureProperties, texture2, slot);\n      return;\n    }\n \
   state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, \
_gl.TEXTURE0 + slot);\n  }\n  const wrappingToGL2 = {\n    [RepeatWrapping]: \
_gl.REPEAT,\n    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,\n    \
[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT\n  };\n  const filterToGL2 = \
{\n    [NearestFilter]: _gl.NEAREST,\n    [NearestMipmapNearestFilter]: \
_gl.NEAREST_MIPMAP_NEAREST,\n    [NearestMipmapLinearFilter]: \
_gl.NEAREST_MIPMAP_LINEAR,\n    [LinearFilter]: _gl.LINEAR,\n    \
[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,\n    \
[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR\n  };\n  const \
compareToGL2 = {\n    [NeverCompare]: _gl.NEVER,\n    [AlwaysCompare]: \
_gl.ALWAYS,\n    [LessCompare]: _gl.LESS,\n    [LessEqualCompare]: \
_gl.LEQUAL,\n    [EqualCompare]: _gl.EQUAL,\n    [GreaterEqualCompare]: \
_gl.GEQUAL,\n    [GreaterCompare]: _gl.GREATER,\n    [NotEqualCompare]: \
_gl.NOTEQUAL\n  };\n  function setTextureParameters(textureType, texture2) \
{\n    if (texture2.type === FloatType && \
extensions.has(\"OES_texture_float_linear\") === false && (texture2.magFilter \
=== LinearFilter || texture2.magFilter === LinearMipmapNearestFilter || \
texture2.magFilter === NearestMipmapLinearFilter || texture2.magFilter === \
LinearMipmapLinearFilter || texture2.minFilter === LinearFilter || \
texture2.minFilter === LinearMipmapNearestFilter || texture2.minFilter === \
NearestMipmapLinearFilter || texture2.minFilter === \
LinearMipmapLinearFilter)) {\n      console.warn(\"THREE.WebGLRenderer: \
Unable to use linear filtering with floating point textures. \
OES_texture_float_linear not supported on this device.\");\n    }\n    \
_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, \
wrappingToGL2[texture2.wrapS]);\n    _gl.texParameteri(textureType, \
_gl.TEXTURE_WRAP_T, wrappingToGL2[texture2.wrapT]);\n    if (textureType === \
_gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n      \
_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, \
wrappingToGL2[texture2.wrapR]);\n    }\n    _gl.texParameteri(textureType, \
_gl.TEXTURE_MAG_FILTER, filterToGL2[texture2.magFilter]);\n    \
_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, \
filterToGL2[texture2.minFilter]);\n    if (texture2.compareFunction) {\n      \
_gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, \
_gl.COMPARE_REF_TO_TEXTURE);\n      _gl.texParameteri(textureType, \
_gl.TEXTURE_COMPARE_FUNC, compareToGL2[texture2.compareFunction]);\n    }\n   \
 if (extensions.has(\"EXT_texture_filter_anisotropic\") === true) {\n      if \
(texture2.magFilter === NearestFilter) return;\n      if (texture2.minFilter \
!== NearestMipmapLinearFilter && texture2.minFilter !== \
LinearMipmapLinearFilter) return;\n      if (texture2.type === FloatType && \
extensions.has(\"OES_texture_float_linear\") === false) return;\n      if \
(texture2.anisotropy > 1 || properties.get(texture2).__currentAnisotropy) {\n \
       const extension = \
extensions.get(\"EXT_texture_filter_anisotropic\");\n        \
_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, \
Math.min(texture2.anisotropy, capabilities.getMaxAnisotropy()));\n        \
properties.get(texture2).__currentAnisotropy = texture2.anisotropy;\n      \
}\n    }\n  }\n  function initTexture(textureProperties, texture2) {\n    let \
forceUpload = false;\n    if (textureProperties.__webglInit === void 0) {\n   \
   textureProperties.__webglInit = true;\n      \
texture2.addEventListener(\"dispose\", onTextureDispose2);\n    }\n    const \
source = texture2.source;\n    let webglTextures = _sources.get(source);\n    \
if (webglTextures === void 0) {\n      webglTextures = {};\n      \
_sources.set(source, webglTextures);\n    }\n    const textureCacheKey = \
getTextureCacheKey(texture2);\n    if (textureCacheKey !== \
textureProperties.__cacheKey) {\n      if (webglTextures[textureCacheKey] === \
void 0) {\n        webglTextures[textureCacheKey] = {\n          texture: \
_gl.createTexture(),\n          usedTimes: 0\n        };\n        \
info.memory.textures++;\n        forceUpload = true;\n      }\n      \
webglTextures[textureCacheKey].usedTimes++;\n      const webglTexture = \
webglTextures[textureProperties.__cacheKey];\n      if (webglTexture !== void \
0) {\n        webglTextures[textureProperties.__cacheKey].usedTimes--;\n      \
  if (webglTexture.usedTimes === 0) {\n          deleteTexture(texture2);\n   \
     }\n      }\n      textureProperties.__cacheKey = textureCacheKey;\n      \
textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;\n  \
  }\n    return forceUpload;\n  }\n  function \
uploadTexture(textureProperties, texture2, slot) {\n    let textureType = \
_gl.TEXTURE_2D;\n    if (texture2.isDataArrayTexture || \
texture2.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;\n    \
if (texture2.isData3DTexture) textureType = _gl.TEXTURE_3D;\n    const \
forceUpload = initTexture(textureProperties, texture2);\n    const source = \
texture2.source;\n    state.bindTexture(textureType, \
textureProperties.__webglTexture, _gl.TEXTURE0 + slot);\n    const \
sourceProperties = properties.get(source);\n    if (source.version !== \
sourceProperties.__version || forceUpload === true) {\n      \
state.activeTexture(_gl.TEXTURE0 + slot);\n      const workingPrimaries = \
ColorManagement.getPrimaries(ColorManagement.workingColorSpace);\n      const \
texturePrimaries = texture2.colorSpace === NoColorSpace ? null : \
ColorManagement.getPrimaries(texture2.colorSpace);\n      const \
unpackConversion = texture2.colorSpace === NoColorSpace || workingPrimaries \
=== texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n      \
_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture2.flipY);\n      \
_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, \
texture2.premultiplyAlpha);\n      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, \
texture2.unpackAlignment);\n      \
_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);\n  \
    let image = resizeImage(texture2.image, false, \
capabilities.maxTextureSize);\n      image = verifyColorSpace(texture2, \
image);\n      const glFormat = utils.convert(texture2.format, \
texture2.colorSpace);\n      const glType = utils.convert(texture2.type);\n   \
   let glInternalFormat = getInternalFormat(texture2.internalFormat, \
glFormat, glType, texture2.colorSpace, texture2.isVideoTexture);\n      \
setTextureParameters(textureType, texture2);\n      let mipmap;\n      const \
mipmaps = texture2.mipmaps;\n      const useTexStorage = \
texture2.isVideoTexture !== true;\n      const allocateMemory = \
sourceProperties.__version === void 0 || forceUpload === true;\n      const \
dataReady = source.dataReady;\n      const levels = getMipLevels(texture2, \
image);\n      if (texture2.isDepthTexture) {\n        glInternalFormat = \
getInternalDepthFormat(texture2.format === DepthStencilFormat, \
texture2.type);\n        if (allocateMemory) {\n          if (useTexStorage) \
{\n            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, \
image.width, image.height);\n          } else {\n            \
state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, \
image.height, 0, glFormat, glType, null);\n          }\n        }\n      } \
else if (texture2.isDataTexture) {\n        if (mipmaps.length > 0) {\n       \
   if (useTexStorage && allocateMemory) {\n            \
state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, \
mipmaps[0].width, mipmaps[0].height);\n          }\n          for (let i = 0, \
il = mipmaps.length; i < il; i++) {\n            mipmap = mipmaps[i];\n       \
     if (useTexStorage) {\n              if (dataReady) {\n                \
state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, \
glFormat, glType, mipmap.data);\n              }\n            } else {\n      \
        state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, \
mipmap.height, 0, glFormat, glType, mipmap.data);\n            }\n          \
}\n          texture2.generateMipmaps = false;\n        } else {\n          \
if (useTexStorage) {\n            if (allocateMemory) {\n              \
state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, \
image.height);\n            }\n            if (dataReady) {\n              \
state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, \
glFormat, glType, image.data);\n            }\n          } else {\n           \
 state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, \
image.height, 0, glFormat, glType, image.data);\n          }\n        }\n     \
 } else if (texture2.isCompressedTexture) {\n        if \
(texture2.isCompressedArrayTexture) {\n          if (useTexStorage && \
allocateMemory) {\n            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, \
levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, \
image.depth);\n          }\n          for (let i = 0, il = mipmaps.length; i \
< il; i++) {\n            mipmap = mipmaps[i];\n            if \
(texture2.format !== RGBAFormat) {\n              if (glFormat !== null) {\n  \
              if (useTexStorage) {\n                  if (dataReady) {\n      \
              if (texture2.layerUpdates.size > 0) {\n                      \
const layerByteLength = getByteLength(mipmap.width, mipmap.height, \
texture2.format, texture2.type);\n                      for (const layerIndex \
of texture2.layerUpdates) {\n                        const layerData = \
mipmap.data.subarray(\n                          layerIndex * layerByteLength \
/ mipmap.data.BYTES_PER_ELEMENT,\n                          (layerIndex + 1) \
* layerByteLength / mipmap.data.BYTES_PER_ELEMENT\n                        \
);\n                        \
state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, \
mipmap.width, mipmap.height, 1, glFormat, layerData);\n                      \
}\n                      texture2.clearLayerUpdates();\n                    } \
else {\n                      \
state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, \
mipmap.height, image.depth, glFormat, mipmap.data);\n                    }\n  \
                }\n                } else {\n                  \
state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, \
mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);\n            \
    }\n              } else {\n                \
console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed \
texture format in .uploadTexture()\");\n              }\n            } else \
{\n              if (useTexStorage) {\n                if (dataReady) {\n     \
             state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, \
mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);\n   \
             }\n              } else {\n                \
state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, \
mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);\n              \
}\n            }\n          }\n        } else {\n          if (useTexStorage \
&& allocateMemory) {\n            state.texStorage2D(_gl.TEXTURE_2D, levels, \
glInternalFormat, mipmaps[0].width, mipmaps[0].height);\n          }\n        \
  for (let i = 0, il = mipmaps.length; i < il; i++) {\n            mipmap = \
mipmaps[i];\n            if (texture2.format !== RGBAFormat) {\n              \
if (glFormat !== null) {\n                if (useTexStorage) {\n              \
    if (dataReady) {\n                    \
state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, \
mipmap.height, glFormat, mipmap.data);\n                  }\n                \
} else {\n                  state.compressedTexImage2D(_gl.TEXTURE_2D, i, \
glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n             \
   }\n              } else {\n                \
console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed \
texture format in .uploadTexture()\");\n              }\n            } else \
{\n              if (useTexStorage) {\n                if (dataReady) {\n     \
             state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, \
mipmap.height, glFormat, glType, mipmap.data);\n                }\n           \
   } else {\n                state.texImage2D(_gl.TEXTURE_2D, i, \
glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, \
mipmap.data);\n              }\n            }\n          }\n        }\n      \
} else if (texture2.isDataArrayTexture) {\n        if (useTexStorage) {\n     \
     if (allocateMemory) {\n            \
state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, \
image.width, image.height, image.depth);\n          }\n          if \
(dataReady) {\n            if (texture2.layerUpdates.size > 0) {\n            \
  const layerByteLength = getByteLength(image.width, image.height, \
texture2.format, texture2.type);\n              for (const layerIndex of \
texture2.layerUpdates) {\n                const layerData = \
image.data.subarray(\n                  layerIndex * layerByteLength / \
image.data.BYTES_PER_ELEMENT,\n                  (layerIndex + 1) * \
layerByteLength / image.data.BYTES_PER_ELEMENT\n                );\n          \
      state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, \
image.width, image.height, 1, glFormat, glType, layerData);\n              \
}\n              texture2.clearLayerUpdates();\n            } else {\n        \
      state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, \
image.height, image.depth, glFormat, glType, image.data);\n            }\n    \
      }\n        } else {\n          state.texImage3D(_gl.TEXTURE_2D_ARRAY, \
0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, \
glType, image.data);\n        }\n      } else if (texture2.isData3DTexture) \
{\n        if (useTexStorage) {\n          if (allocateMemory) {\n            \
state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, \
image.height, image.depth);\n          }\n          if (dataReady) {\n        \
    state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, \
image.height, image.depth, glFormat, glType, image.data);\n          }\n      \
  } else {\n          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, \
image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n   \
     }\n      } else if (texture2.isFramebufferTexture) {\n        if \
(allocateMemory) {\n          if (useTexStorage) {\n            \
state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, \
image.height);\n          } else {\n            let width = image.width, \
height = image.height;\n            for (let i = 0; i < levels; i++) {\n      \
        state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, \
0, glFormat, glType, null);\n              width >>= 1;\n              height \
>>= 1;\n            }\n          }\n        }\n      } else {\n        if \
(mipmaps.length > 0) {\n          if (useTexStorage && allocateMemory) {\n    \
        const dimensions = getDimensions(mipmaps[0]);\n            \
state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, \
dimensions.width, dimensions.height);\n          }\n          for (let i = 0, \
il = mipmaps.length; i < il; i++) {\n            mipmap = mipmaps[i];\n       \
     if (useTexStorage) {\n              if (dataReady) {\n                \
state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);\n     \
         }\n            } else {\n              \
state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, \
mipmap);\n            }\n          }\n          texture2.generateMipmaps = \
false;\n        } else {\n          if (useTexStorage) {\n            if \
(allocateMemory) {\n              const dimensions = getDimensions(image);\n  \
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, \
dimensions.width, dimensions.height);\n            }\n            if \
(dataReady) {\n              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, \
glFormat, glType, image);\n            }\n          } else {\n            \
state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, \
image);\n          }\n        }\n      }\n      if \
(textureNeedsGenerateMipmaps(texture2)) {\n        \
generateMipmap(textureType);\n      }\n      sourceProperties.__version = \
source.version;\n      if (texture2.onUpdate) texture2.onUpdate(texture2);\n  \
  }\n    textureProperties.__version = texture2.version;\n  }\n  function \
uploadCubeTexture(textureProperties, texture2, slot) {\n    if \
(texture2.image.length !== 6) return;\n    const forceUpload = \
initTexture(textureProperties, texture2);\n    const source = \
texture2.source;\n    state.bindTexture(_gl.TEXTURE_CUBE_MAP, \
textureProperties.__webglTexture, _gl.TEXTURE0 + slot);\n    const \
sourceProperties = properties.get(source);\n    if (source.version !== \
sourceProperties.__version || forceUpload === true) {\n      \
state.activeTexture(_gl.TEXTURE0 + slot);\n      const workingPrimaries = \
ColorManagement.getPrimaries(ColorManagement.workingColorSpace);\n      const \
texturePrimaries = texture2.colorSpace === NoColorSpace ? null : \
ColorManagement.getPrimaries(texture2.colorSpace);\n      const \
unpackConversion = texture2.colorSpace === NoColorSpace || workingPrimaries \
=== texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n      \
_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture2.flipY);\n      \
_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, \
texture2.premultiplyAlpha);\n      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, \
texture2.unpackAlignment);\n      \
_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);\n  \
    const isCompressed = texture2.isCompressedTexture || \
texture2.image[0].isCompressedTexture;\n      const isDataTexture = \
texture2.image[0] && texture2.image[0].isDataTexture;\n      const cubeImage \
= [];\n      for (let i = 0; i < 6; i++) {\n        if (!isCompressed && \
!isDataTexture) {\n          cubeImage[i] = resizeImage(texture2.image[i], \
true, capabilities.maxCubemapSize);\n        } else {\n          cubeImage[i] \
= isDataTexture ? texture2.image[i].image : texture2.image[i];\n        }\n   \
     cubeImage[i] = verifyColorSpace(texture2, cubeImage[i]);\n      }\n      \
const image = cubeImage[0], glFormat = utils.convert(texture2.format, \
texture2.colorSpace), glType = utils.convert(texture2.type), glInternalFormat \
= getInternalFormat(texture2.internalFormat, glFormat, glType, \
texture2.colorSpace);\n      const useTexStorage = texture2.isVideoTexture \
!== true;\n      const allocateMemory = sourceProperties.__version === void 0 \
|| forceUpload === true;\n      const dataReady = source.dataReady;\n      \
let levels = getMipLevels(texture2, image);\n      \
setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture2);\n      let mipmaps;\n   \
   if (isCompressed) {\n        if (useTexStorage && allocateMemory) {\n      \
    state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, \
image.width, image.height);\n        }\n        for (let i = 0; i < 6; i++) \
{\n          mipmaps = cubeImage[i].mipmaps;\n          for (let j = 0; j < \
mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n            \
if (texture2.format !== RGBAFormat) {\n              if (glFormat !== null) \
{\n                if (useTexStorage) {\n                  if (dataReady) {\n \
                   \
state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, \
mipmap.width, mipmap.height, glFormat, mipmap.data);\n                  }\n   \
             } else {\n                  \
state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, \
glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n             \
   }\n              } else {\n                \
console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed \
texture format in .setTextureCube()\");\n              }\n            } else \
{\n              if (useTexStorage) {\n                if (dataReady) {\n     \
             state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, \
0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n             \
   }\n              } else {\n                \
state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, \
mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n             \
 }\n            }\n          }\n        }\n      } else {\n        mipmaps = \
texture2.mipmaps;\n        if (useTexStorage && allocateMemory) {\n          \
if (mipmaps.length > 0) levels++;\n          const dimensions = \
getDimensions(cubeImage[0]);\n          \
state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, \
dimensions.width, dimensions.height);\n        }\n        for (let i = 0; i < \
6; i++) {\n          if (isDataTexture) {\n            if (useTexStorage) {\n \
             if (dataReady) {\n                \
state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, \
cubeImage[i].width, cubeImage[i].height, glFormat, glType, \
cubeImage[i].data);\n              }\n            } else {\n              \
state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, \
cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, \
cubeImage[i].data);\n            }\n            for (let j = 0; j < \
mipmaps.length; j++) {\n              const mipmap = mipmaps[j];\n            \
  const mipmapImage = mipmap.image[i].image;\n              if \
(useTexStorage) {\n                if (dataReady) {\n                  \
state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, \
mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);\n \
               }\n              } else {\n                \
state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, \
glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, \
mipmapImage.data);\n              }\n            }\n          } else {\n      \
      if (useTexStorage) {\n              if (dataReady) {\n                \
state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, \
glType, cubeImage[i]);\n              }\n            } else {\n              \
state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, \
glFormat, glType, cubeImage[i]);\n            }\n            for (let j = 0; \
j < mipmaps.length; j++) {\n              const mipmap = mipmaps[j];\n        \
      if (useTexStorage) {\n                if (dataReady) {\n                \
  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, \
glFormat, glType, mipmap.image[i]);\n                }\n              } else \
{\n                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + \
1, glInternalFormat, glFormat, glType, mipmap.image[i]);\n              }\n   \
         }\n          }\n        }\n      }\n      if \
(textureNeedsGenerateMipmaps(texture2)) {\n        \
generateMipmap(_gl.TEXTURE_CUBE_MAP);\n      }\n      \
sourceProperties.__version = source.version;\n      if (texture2.onUpdate) \
texture2.onUpdate(texture2);\n    }\n    textureProperties.__version = \
texture2.version;\n  }\n  function setupFrameBufferTexture(framebuffer, \
renderTarget, texture2, attachment, textureTarget, level) {\n    const \
glFormat = utils.convert(texture2.format, texture2.colorSpace);\n    const \
glType = utils.convert(texture2.type);\n    const glInternalFormat = \
getInternalFormat(texture2.internalFormat, glFormat, glType, \
texture2.colorSpace);\n    const renderTargetProperties = \
properties.get(renderTarget);\n    const textureProperties = \
properties.get(texture2);\n    textureProperties.__renderTarget = \
renderTarget;\n    if (!renderTargetProperties.__hasExternalTextures) {\n     \
 const width = Math.max(1, renderTarget.width >> level);\n      const height \
= Math.max(1, renderTarget.height >> level);\n      if (textureTarget === \
_gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {\n        \
state.texImage3D(textureTarget, level, glInternalFormat, width, height, \
renderTarget.depth, 0, glFormat, glType, null);\n      } else {\n        \
state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, \
glFormat, glType, null);\n      }\n    }\n    \
state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n    if \
(useMultisampledRTT(renderTarget)) {\n      \
multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, \
attachment, textureTarget, textureProperties.__webglTexture, 0, \
getRenderTargetSamples(renderTarget));\n    } else if (textureTarget === \
_gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && \
textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {\n      \
_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, \
textureProperties.__webglTexture, level);\n    }\n    \
state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n  }\n  function \
setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n    \
_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n    if \
(renderTarget.depthBuffer) {\n      const depthTexture = \
renderTarget.depthTexture;\n      const depthType = depthTexture && \
depthTexture.isDepthTexture ? depthTexture.type : null;\n      const \
glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, \
depthType);\n      const glAttachmentType = renderTarget.stencilBuffer ? \
_gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n      const samples = \
getRenderTargetSamples(renderTarget);\n      const isUseMultisampledRTT = \
useMultisampledRTT(renderTarget);\n      if (isUseMultisampledRTT) {\n        \
multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, \
samples, glInternalFormat, renderTarget.width, renderTarget.height);\n      } \
else if (isMultisample) {\n        \
_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, \
glInternalFormat, renderTarget.width, renderTarget.height);\n      } else {\n \
       _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, \
renderTarget.width, renderTarget.height);\n      }\n      \
_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, \
_gl.RENDERBUFFER, renderbuffer);\n    } else {\n      const textures = \
renderTarget.textures;\n      for (let i = 0; i < textures.length; i++) {\n   \
     const texture2 = textures[i];\n        const glFormat = \
utils.convert(texture2.format, texture2.colorSpace);\n        const glType = \
utils.convert(texture2.type);\n        const glInternalFormat = \
getInternalFormat(texture2.internalFormat, glFormat, glType, \
texture2.colorSpace);\n        const samples = \
getRenderTargetSamples(renderTarget);\n        if (isMultisample && \
useMultisampledRTT(renderTarget) === false) {\n          \
_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, \
glInternalFormat, renderTarget.width, renderTarget.height);\n        } else \
if (useMultisampledRTT(renderTarget)) {\n          \
multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, \
samples, glInternalFormat, renderTarget.width, renderTarget.height);\n        \
} else {\n          _gl.renderbufferStorage(_gl.RENDERBUFFER, \
glInternalFormat, renderTarget.width, renderTarget.height);\n        }\n      \
}\n    }\n    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n  }\n  function \
setupDepthTexture(framebuffer, renderTarget) {\n    const isCube = \
renderTarget && renderTarget.isWebGLCubeRenderTarget;\n    if (isCube) throw \
new Error(\"Depth Texture with cube render targets is not supported\");\n    \
state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n    if \
(!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) \
{\n      throw new Error(\"renderTarget.depthTexture must be an instance of \
THREE.DepthTexture\");\n    }\n    const textureProperties = \
properties.get(renderTarget.depthTexture);\n    \
textureProperties.__renderTarget = renderTarget;\n    if \
(!textureProperties.__webglTexture || renderTarget.depthTexture.image.width \
!== renderTarget.width || renderTarget.depthTexture.image.height !== \
renderTarget.height) {\n      renderTarget.depthTexture.image.width = \
renderTarget.width;\n      renderTarget.depthTexture.image.height = \
renderTarget.height;\n      renderTarget.depthTexture.needsUpdate = true;\n   \
 }\n    setTexture2D(renderTarget.depthTexture, 0);\n    const \
webglDepthTexture = textureProperties.__webglTexture;\n    const samples = \
getRenderTargetSamples(renderTarget);\n    if \
(renderTarget.depthTexture.format === DepthFormat) {\n      if \
(useMultisampledRTT(renderTarget)) {\n        \
multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, \
_gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);\n      \
} else {\n        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, \
_gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n      }\n    } \
else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n      if \
(useMultisampledRTT(renderTarget)) {\n        \
multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, \
_gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, \
samples);\n      } else {\n        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, \
_gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n      \
}\n    } else {\n      throw new Error(\"Unknown depthTexture format\");\n    \
}\n  }\n  function setupDepthRenderbuffer(renderTarget) {\n    const \
renderTargetProperties = properties.get(renderTarget);\n    const isCube = \
renderTarget.isWebGLCubeRenderTarget === true;\n    if \
(renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) \
{\n      const depthTexture = renderTarget.depthTexture;\n      if \
(renderTargetProperties.__depthDisposeCallback) {\n        \
renderTargetProperties.__depthDisposeCallback();\n      }\n      if \
(depthTexture) {\n        const disposeEvent = () => {\n          delete \
renderTargetProperties.__boundDepthTexture;\n          delete \
renderTargetProperties.__depthDisposeCallback;\n          \
depthTexture.removeEventListener(\"dispose\", disposeEvent);\n        };\n    \
    depthTexture.addEventListener(\"dispose\", disposeEvent);\n        \
renderTargetProperties.__depthDisposeCallback = disposeEvent;\n      }\n      \
renderTargetProperties.__boundDepthTexture = depthTexture;\n    }\n    if \
(renderTarget.depthTexture && \
!renderTargetProperties.__autoAllocateDepthBuffer) {\n      if (isCube) throw \
new Error(\"target.depthTexture not supported in Cube render targets\");\n    \
  setupDepthTexture(renderTargetProperties.__webglFramebuffer, \
renderTarget);\n    } else {\n      if (isCube) {\n        \
renderTargetProperties.__webglDepthbuffer = [];\n        for (let i = 0; i < \
6; i++) {\n          state.bindFramebuffer(_gl.FRAMEBUFFER, \
renderTargetProperties.__webglFramebuffer[i]);\n          if \
(renderTargetProperties.__webglDepthbuffer[i] === void 0) {\n            \
renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();\n    \
        \
setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], \
renderTarget, false);\n          } else {\n            const glAttachmentType \
= renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : \
_gl.DEPTH_ATTACHMENT;\n            const renderbuffer = \
renderTargetProperties.__webglDepthbuffer[i];\n            \
_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n            \
_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, \
_gl.RENDERBUFFER, renderbuffer);\n          }\n        }\n      } else {\n    \
    state.bindFramebuffer(_gl.FRAMEBUFFER, \
renderTargetProperties.__webglFramebuffer);\n        if \
(renderTargetProperties.__webglDepthbuffer === void 0) {\n          \
renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n       \
   setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, \
renderTarget, false);\n        } else {\n          const glAttachmentType = \
renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : \
_gl.DEPTH_ATTACHMENT;\n          const renderbuffer = \
renderTargetProperties.__webglDepthbuffer;\n          \
_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n          \
_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, \
_gl.RENDERBUFFER, renderbuffer);\n        }\n      }\n    }\n    \
state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n  }\n  function \
rebindTextures(renderTarget, colorTexture, depthTexture) {\n    const \
renderTargetProperties = properties.get(renderTarget);\n    if (colorTexture \
!== void 0) {\n      \
setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, \
renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, \
0);\n    }\n    if (depthTexture !== void 0) {\n      \
setupDepthRenderbuffer(renderTarget);\n    }\n  }\n  function \
setupRenderTarget(renderTarget) {\n    const texture2 = \
renderTarget.texture;\n    const renderTargetProperties = \
properties.get(renderTarget);\n    const textureProperties = \
properties.get(texture2);\n    renderTarget.addEventListener(\"dispose\", \
onRenderTargetDispose);\n    const textures = renderTarget.textures;\n    \
const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n    const \
isMultipleRenderTargets = textures.length > 1;\n    if \
(!isMultipleRenderTargets) {\n      if (textureProperties.__webglTexture === \
void 0) {\n        textureProperties.__webglTexture = _gl.createTexture();\n  \
    }\n      textureProperties.__version = texture2.version;\n      \
info.memory.textures++;\n    }\n    if (isCube) {\n      \
renderTargetProperties.__webglFramebuffer = [];\n      for (let i = 0; i < 6; \
i++) {\n        if (texture2.mipmaps && texture2.mipmaps.length > 0) {\n      \
    renderTargetProperties.__webglFramebuffer[i] = [];\n          for (let \
level = 0; level < texture2.mipmaps.length; level++) {\n            \
renderTargetProperties.__webglFramebuffer[i][level] = \
_gl.createFramebuffer();\n          }\n        } else {\n          \
renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n     \
   }\n      }\n    } else {\n      if (texture2.mipmaps && \
texture2.mipmaps.length > 0) {\n        \
renderTargetProperties.__webglFramebuffer = [];\n        for (let level = 0; \
level < texture2.mipmaps.length; level++) {\n          \
renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();\n \
       }\n      } else {\n        renderTargetProperties.__webglFramebuffer = \
_gl.createFramebuffer();\n      }\n      if (isMultipleRenderTargets) {\n     \
   for (let i = 0, il = textures.length; i < il; i++) {\n          const \
attachmentProperties = properties.get(textures[i]);\n          if \
(attachmentProperties.__webglTexture === void 0) {\n            \
attachmentProperties.__webglTexture = _gl.createTexture();\n            \
info.memory.textures++;\n          }\n        }\n      }\n      if \
(renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {\n  \
      renderTargetProperties.__webglMultisampledFramebuffer = \
_gl.createFramebuffer();\n        \
renderTargetProperties.__webglColorRenderbuffer = [];\n        \
state.bindFramebuffer(_gl.FRAMEBUFFER, \
renderTargetProperties.__webglMultisampledFramebuffer);\n        for (let i = \
0; i < textures.length; i++) {\n          const texture3 = textures[i];\n     \
     renderTargetProperties.__webglColorRenderbuffer[i] = \
_gl.createRenderbuffer();\n          _gl.bindRenderbuffer(_gl.RENDERBUFFER, \
renderTargetProperties.__webglColorRenderbuffer[i]);\n          const \
glFormat = utils.convert(texture3.format, texture3.colorSpace);\n          \
const glType = utils.convert(texture3.type);\n          const \
glInternalFormat = getInternalFormat(texture3.internalFormat, glFormat, \
glType, texture3.colorSpace, renderTarget.isXRRenderTarget === true);\n       \
   const samples = getRenderTargetSamples(renderTarget);\n          \
_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, \
glInternalFormat, renderTarget.width, renderTarget.height);\n          \
_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, \
_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);\n      \
  }\n        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n        if \
(renderTarget.depthBuffer) {\n          \
renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n \
         \
setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, \
renderTarget, true);\n        }\n        \
state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n      }\n    }\n    if \
(isCube) {\n      state.bindTexture(_gl.TEXTURE_CUBE_MAP, \
textureProperties.__webglTexture);\n      \
setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture2);\n      for (let i = 0; \
i < 6; i++) {\n        if (texture2.mipmaps && texture2.mipmaps.length > 0) \
{\n          for (let level = 0; level < texture2.mipmaps.length; level++) \
{\n            \
setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], \
renderTarget, texture2, _gl.COLOR_ATTACHMENT0, \
_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);\n          }\n        } else {\n \
         \
setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], \
renderTarget, texture2, _gl.COLOR_ATTACHMENT0, \
_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);\n        }\n      }\n      if \
(textureNeedsGenerateMipmaps(texture2)) {\n        \
generateMipmap(_gl.TEXTURE_CUBE_MAP);\n      }\n      \
state.unbindTexture();\n    } else if (isMultipleRenderTargets) {\n      for \
(let i = 0, il = textures.length; i < il; i++) {\n        const attachment = \
textures[i];\n        const attachmentProperties = \
properties.get(attachment);\n        state.bindTexture(_gl.TEXTURE_2D, \
attachmentProperties.__webglTexture);\n        \
setTextureParameters(_gl.TEXTURE_2D, attachment);\n        \
setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, \
renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0);\n    \
    if (textureNeedsGenerateMipmaps(attachment)) {\n          \
generateMipmap(_gl.TEXTURE_2D);\n        }\n      }\n      \
state.unbindTexture();\n    } else {\n      let glTextureType = \
_gl.TEXTURE_2D;\n      if (renderTarget.isWebGL3DRenderTarget || \
renderTarget.isWebGLArrayRenderTarget) {\n        glTextureType = \
renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n \
     }\n      state.bindTexture(glTextureType, \
textureProperties.__webglTexture);\n      setTextureParameters(glTextureType, \
texture2);\n      if (texture2.mipmaps && texture2.mipmaps.length > 0) {\n    \
    for (let level = 0; level < texture2.mipmaps.length; level++) {\n         \
 setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], \
renderTarget, texture2, _gl.COLOR_ATTACHMENT0, glTextureType, level);\n       \
 }\n      } else {\n        \
setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, \
renderTarget, texture2, _gl.COLOR_ATTACHMENT0, glTextureType, 0);\n      }\n  \
    if (textureNeedsGenerateMipmaps(texture2)) {\n        \
generateMipmap(glTextureType);\n      }\n      state.unbindTexture();\n    \
}\n    if (renderTarget.depthBuffer) {\n      \
setupDepthRenderbuffer(renderTarget);\n    }\n  }\n  function \
updateRenderTargetMipmap(renderTarget) {\n    const textures = \
renderTarget.textures;\n    for (let i = 0, il = textures.length; i < il; \
i++) {\n      const texture2 = textures[i];\n      if \
(textureNeedsGenerateMipmaps(texture2)) {\n        const targetType = \
getTargetType(renderTarget);\n        const webglTexture = \
properties.get(texture2).__webglTexture;\n        \
state.bindTexture(targetType, webglTexture);\n        \
generateMipmap(targetType);\n        state.unbindTexture();\n      }\n    }\n \
 }\n  const invalidationArrayRead = [];\n  const invalidationArrayDraw = \
[];\n  function updateMultisampleRenderTarget(renderTarget) {\n    if \
(renderTarget.samples > 0) {\n      if (useMultisampledRTT(renderTarget) === \
false) {\n        const textures = renderTarget.textures;\n        const \
width = renderTarget.width;\n        const height = renderTarget.height;\n    \
    let mask = _gl.COLOR_BUFFER_BIT;\n        const depthStyle = \
renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : \
_gl.DEPTH_ATTACHMENT;\n        const renderTargetProperties = \
properties.get(renderTarget);\n        const isMultipleRenderTargets = \
textures.length > 1;\n        if (isMultipleRenderTargets) {\n          for \
(let i = 0; i < textures.length; i++) {\n            \
state.bindFramebuffer(_gl.FRAMEBUFFER, \
renderTargetProperties.__webglMultisampledFramebuffer);\n            \
_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, \
_gl.RENDERBUFFER, null);\n            state.bindFramebuffer(_gl.FRAMEBUFFER, \
renderTargetProperties.__webglFramebuffer);\n            \
_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, \
_gl.TEXTURE_2D, null, 0);\n          }\n        }\n        \
state.bindFramebuffer(_gl.READ_FRAMEBUFFER, \
renderTargetProperties.__webglMultisampledFramebuffer);\n        \
state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, \
renderTargetProperties.__webglFramebuffer);\n        for (let i = 0; i < \
textures.length; i++) {\n          if (renderTarget.resolveDepthBuffer) {\n   \
         if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;\n        \
    if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask \
|= _gl.STENCIL_BUFFER_BIT;\n          }\n          if \
(isMultipleRenderTargets) {\n            \
_gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, \
_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);\n      \
      const webglTexture = properties.get(textures[i]).__webglTexture;\n      \
      _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, \
_gl.TEXTURE_2D, webglTexture, 0);\n          }\n          \
_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, \
_gl.NEAREST);\n          if (supportsInvalidateFramebuffer === true) {\n      \
      invalidationArrayRead.length = 0;\n            \
invalidationArrayDraw.length = 0;\n            \
invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i);\n            if \
(renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {\n   \
           invalidationArrayRead.push(depthStyle);\n              \
invalidationArrayDraw.push(depthStyle);\n              \
_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);\n     \
       }\n            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, \
invalidationArrayRead);\n          }\n        }\n        \
state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);\n        \
state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);\n        if \
(isMultipleRenderTargets) {\n          for (let i = 0; i < textures.length; \
i++) {\n            state.bindFramebuffer(_gl.FRAMEBUFFER, \
renderTargetProperties.__webglMultisampledFramebuffer);\n            \
_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, \
_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);\n      \
      const webglTexture = properties.get(textures[i]).__webglTexture;\n      \
      state.bindFramebuffer(_gl.FRAMEBUFFER, \
renderTargetProperties.__webglFramebuffer);\n            \
_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, \
_gl.TEXTURE_2D, webglTexture, 0);\n          }\n        }\n        \
state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, \
renderTargetProperties.__webglMultisampledFramebuffer);\n      } else {\n     \
   if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false \
&& supportsInvalidateFramebuffer) {\n          const depthStyle = \
renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : \
_gl.DEPTH_ATTACHMENT;\n          \
_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);\n        }\n   \
   }\n    }\n  }\n  function getRenderTargetSamples(renderTarget) {\n    \
return Math.min(capabilities.maxSamples, renderTarget.samples);\n  }\n  \
function useMultisampledRTT(renderTarget) {\n    const renderTargetProperties \
= properties.get(renderTarget);\n    return renderTarget.samples > 0 && \
extensions.has(\"WEBGL_multisampled_render_to_texture\") === true && \
renderTargetProperties.__useRenderToTexture !== false;\n  }\n  function \
updateVideoTexture(texture2) {\n    const frame2 = info.render.frame;\n    if \
(_videoTextures.get(texture2) !== frame2) {\n      \
_videoTextures.set(texture2, frame2);\n      texture2.update();\n    }\n  }\n \
 function verifyColorSpace(texture2, image) {\n    const colorSpace = \
texture2.colorSpace;\n    const format2 = texture2.format;\n    const type = \
texture2.type;\n    if (texture2.isCompressedTexture === true || \
texture2.isVideoTexture === true) return image;\n    if (colorSpace !== \
LinearSRGBColorSpace && colorSpace !== NoColorSpace) {\n      if \
(ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {\n        if \
(format2 !== RGBAFormat || type !== UnsignedByteType) {\n          \
console.warn(\"THREE.WebGLTextures: sRGB encoded textures have to use \
RGBAFormat and UnsignedByteType.\");\n        }\n      } else {\n        \
console.error(\"THREE.WebGLTextures: Unsupported texture color space:\", \
colorSpace);\n      }\n    }\n    return image;\n  }\n  function \
getDimensions(image) {\n    if (typeof HTMLImageElement !== \"undefined\" && \
image instanceof HTMLImageElement) {\n      _imageDimensions.width = \
image.naturalWidth || image.width;\n      _imageDimensions.height = \
image.naturalHeight || image.height;\n    } else if (typeof VideoFrame !== \
\"undefined\" && image instanceof VideoFrame) {\n      _imageDimensions.width \
= image.displayWidth;\n      _imageDimensions.height = image.displayHeight;\n \
   } else {\n      _imageDimensions.width = image.width;\n      \
_imageDimensions.height = image.height;\n    }\n    return \
_imageDimensions;\n  }\n  this.allocateTextureUnit = allocateTextureUnit;\n  \
this.resetTextureUnits = resetTextureUnits;\n  this.setTexture2D = \
setTexture2D;\n  this.setTexture2DArray = setTexture2DArray;\n  \
this.setTexture3D = setTexture3D;\n  this.setTextureCube = setTextureCube;\n  \
this.rebindTextures = rebindTextures;\n  this.setupRenderTarget = \
setupRenderTarget;\n  this.updateRenderTargetMipmap = \
updateRenderTargetMipmap;\n  this.updateMultisampleRenderTarget = \
updateMultisampleRenderTarget;\n  this.setupDepthRenderbuffer = \
setupDepthRenderbuffer;\n  this.setupFrameBufferTexture = \
setupFrameBufferTexture;\n  this.useMultisampledRTT = \
useMultisampledRTT;\n}\nfunction WebGLUtils(gl, extensions) {\n  function \
convert2(p, colorSpace = NoColorSpace) {\n    let extension;\n    const \
transfer = ColorManagement.getTransfer(colorSpace);\n    if (p === \
UnsignedByteType) return gl.UNSIGNED_BYTE;\n    if (p === \
UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;\n    if (p === \
UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;\n    if (p === \
UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;\n    if (p === \
ByteType) return gl.BYTE;\n    if (p === ShortType) return gl.SHORT;\n    if \
(p === UnsignedShortType) return gl.UNSIGNED_SHORT;\n    if (p === IntType) \
return gl.INT;\n    if (p === UnsignedIntType) return gl.UNSIGNED_INT;\n    \
if (p === FloatType) return gl.FLOAT;\n    if (p === HalfFloatType) return \
gl.HALF_FLOAT;\n    if (p === AlphaFormat) return gl.ALPHA;\n    if (p === \
RGBFormat) return gl.RGB;\n    if (p === RGBAFormat) return gl.RGBA;\n    if \
(p === LuminanceFormat) return gl.LUMINANCE;\n    if (p === \
LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;\n    if (p === DepthFormat) \
return gl.DEPTH_COMPONENT;\n    if (p === DepthStencilFormat) return \
gl.DEPTH_STENCIL;\n    if (p === RedFormat) return gl.RED;\n    if (p === \
RedIntegerFormat) return gl.RED_INTEGER;\n    if (p === RGFormat) return \
gl.RG;\n    if (p === RGIntegerFormat) return gl.RG_INTEGER;\n    if (p === \
RGBAIntegerFormat) return gl.RGBA_INTEGER;\n    if (p === \
RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === \
RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n      if (transfer \
=== SRGBTransfer) {\n        extension = \
extensions.get(\"WEBGL_compressed_texture_s3tc_srgb\");\n        if \
(extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return \
extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n          if (p === \
RGBA_S3TC_DXT1_Format) return \
extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n          if (p === \
RGBA_S3TC_DXT3_Format) return \
extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n          if (p === \
RGBA_S3TC_DXT5_Format) return \
extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n        } else {\n          \
return null;\n        }\n      } else {\n        extension = \
extensions.get(\"WEBGL_compressed_texture_s3tc\");\n        if (extension !== \
null) {\n          if (p === RGB_S3TC_DXT1_Format) return \
extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n          if (p === \
RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n      \
    if (p === RGBA_S3TC_DXT3_Format) return \
extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          if (p === \
RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n      \
  } else {\n          return null;\n        }\n      }\n    }\n    if (p === \
RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === \
RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n      \
extension = extensions.get(\"WEBGL_compressed_texture_pvrtc\");\n      if \
(extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format) return \
extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === \
RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n  \
      if (p === RGBA_PVRTC_4BPPV1_Format) return \
extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === \
RGBA_PVRTC_2BPPV1_Format) return \
extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return \
null;\n      }\n    }\n    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format \
|| p === RGBA_ETC2_EAC_Format) {\n      extension = \
extensions.get(\"WEBGL_compressed_texture_etc\");\n      if (extension !== \
null) {\n        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return \
transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : \
extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format) \
return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC \
: extension.COMPRESSED_RGBA8_ETC2_EAC;\n      } else {\n        return \
null;\n      }\n    }\n    if (p === RGBA_ASTC_4x4_Format || p === \
RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === \
RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === \
RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === \
RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === \
RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === \
RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === \
RGBA_ASTC_12x12_Format) {\n      extension = \
extensions.get(\"WEBGL_compressed_texture_astc\");\n      if (extension !== \
null) {\n        if (p === RGBA_ASTC_4x4_Format) return transfer === \
SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : \
extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n        if (p === \
RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : \
extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n        if (p === \
RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : \
extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n        if (p === \
RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : \
extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n        if (p === \
RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : \
extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n        if (p === \
RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : \
extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n        if (p === \
RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : \
extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n        if (p === \
RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : \
extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n        if (p === \
RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : \
extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n        if (p === \
RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : \
extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n        if (p === \
RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : \
extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n        if (p === \
RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : \
extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n        if (p === \
RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : \
extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n        if (p === \
RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : \
extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n      } else {\n        return \
null;\n      }\n    }\n    if (p === RGBA_BPTC_Format || p === \
RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {\n      extension \
= extensions.get(\"EXT_texture_compression_bptc\");\n      if (extension !== \
null) {\n        if (p === RGBA_BPTC_Format) return transfer === SRGBTransfer \
? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : \
extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n        if (p === \
RGB_BPTC_SIGNED_Format) return \
extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;\n        if (p === \
RGB_BPTC_UNSIGNED_Format) return \
extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;\n      } else {\n        \
return null;\n      }\n    }\n    if (p === RED_RGTC1_Format || p === \
SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === \
SIGNED_RED_GREEN_RGTC2_Format) {\n      extension = \
extensions.get(\"EXT_texture_compression_rgtc\");\n      if (extension !== \
null) {\n        if (p === RGBA_BPTC_Format) return \
extension.COMPRESSED_RED_RGTC1_EXT;\n        if (p === \
SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n  \
      if (p === RED_GREEN_RGTC2_Format) return \
extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n        if (p === \
SIGNED_RED_GREEN_RGTC2_Format) return \
extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n      } else {\n        \
return null;\n      }\n    }\n    if (p === UnsignedInt248Type) return \
gl.UNSIGNED_INT_24_8;\n    return gl[p] !== void 0 ? gl[p] : null;\n  }\n  \
return { convert: convert2 };\n}\nvar ArrayCamera = class extends \
PerspectiveCamera {\n  constructor(array = []) {\n    super();\n    \
this.isArrayCamera = true;\n    this.cameras = array;\n  }\n};\nvar Group = \
class extends Object3D {\n  constructor() {\n    super();\n    this.isGroup = \
true;\n    this.type = \"Group\";\n  }\n};\nvar _moveEvent = { type: \"move\" \
};\nvar WebXRController = class {\n  constructor() {\n    this._targetRay = \
null;\n    this._grip = null;\n    this._hand = null;\n  }\n  getHandSpace() \
{\n    if (this._hand === null) {\n      this._hand = new Group();\n      \
this._hand.matrixAutoUpdate = false;\n      this._hand.visible = false;\n     \
 this._hand.joints = {};\n      this._hand.inputState = { pinching: false \
};\n    }\n    return this._hand;\n  }\n  getTargetRaySpace() {\n    if \
(this._targetRay === null) {\n      this._targetRay = new Group();\n      \
this._targetRay.matrixAutoUpdate = false;\n      this._targetRay.visible = \
false;\n      this._targetRay.hasLinearVelocity = false;\n      \
this._targetRay.linearVelocity = new Vector3();\n      \
this._targetRay.hasAngularVelocity = false;\n      \
this._targetRay.angularVelocity = new Vector3();\n    }\n    return \
this._targetRay;\n  }\n  getGripSpace() {\n    if (this._grip === null) {\n   \
   this._grip = new Group();\n      this._grip.matrixAutoUpdate = false;\n    \
  this._grip.visible = false;\n      this._grip.hasLinearVelocity = false;\n  \
    this._grip.linearVelocity = new Vector3();\n      \
this._grip.hasAngularVelocity = false;\n      this._grip.angularVelocity = \
new Vector3();\n    }\n    return this._grip;\n  }\n  dispatchEvent(event) \
{\n    if (this._targetRay !== null) {\n      \
this._targetRay.dispatchEvent(event);\n    }\n    if (this._grip !== null) \
{\n      this._grip.dispatchEvent(event);\n    }\n    if (this._hand !== \
null) {\n      this._hand.dispatchEvent(event);\n    }\n    return this;\n  \
}\n  connect(inputSource) {\n    if (inputSource && inputSource.hand) {\n     \
 const hand = this._hand;\n      if (hand) {\n        for (const inputjoint \
of inputSource.hand.values()) {\n          this._getHandJoint(hand, \
inputjoint);\n        }\n      }\n    }\n    this.dispatchEvent({ type: \
\"connected\", data: inputSource });\n    return this;\n  }\n  \
disconnect(inputSource) {\n    this.dispatchEvent({ type: \"disconnected\", \
data: inputSource });\n    if (this._targetRay !== null) {\n      \
this._targetRay.visible = false;\n    }\n    if (this._grip !== null) {\n     \
 this._grip.visible = false;\n    }\n    if (this._hand !== null) {\n      \
this._hand.visible = false;\n    }\n    return this;\n  }\n  \
update(inputSource, frame2, referenceSpace) {\n    let inputPose = null;\n    \
let gripPose = null;\n    let handPose = null;\n    const targetRay = \
this._targetRay;\n    const grip = this._grip;\n    const hand = \
this._hand;\n    if (inputSource && frame2.session.visibilityState !== \
\"visible-blurred\") {\n      if (hand && inputSource.hand) {\n        \
handPose = true;\n        for (const inputjoint of inputSource.hand.values()) \
{\n          const jointPose = frame2.getJointPose(inputjoint, \
referenceSpace);\n          const joint = this._getHandJoint(hand, \
inputjoint);\n          if (jointPose !== null) {\n            \
joint.matrix.fromArray(jointPose.transform.matrix);\n            \
joint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n        \
    joint.matrixWorldNeedsUpdate = true;\n            joint.jointRadius = \
jointPose.radius;\n          }\n          joint.visible = jointPose !== \
null;\n        }\n        const indexTip = \
hand.joints[\"index-finger-tip\"];\n        const thumbTip = \
hand.joints[\"thumb-tip\"];\n        const distance2 = \
indexTip.position.distanceTo(thumbTip.position);\n        const \
distanceToPinch = 0.02;\n        const threshold = 5e-3;\n        if \
(hand.inputState.pinching && distance2 > distanceToPinch + threshold) {\n     \
     hand.inputState.pinching = false;\n          this.dispatchEvent({\n      \
      type: \"pinchend\",\n            handedness: inputSource.handedness,\n  \
          target: this\n          });\n        } else if \
(!hand.inputState.pinching && distance2 <= distanceToPinch - threshold) {\n   \
       hand.inputState.pinching = true;\n          this.dispatchEvent({\n     \
       type: \"pinchstart\",\n            handedness: \
inputSource.handedness,\n            target: this\n          });\n        }\n \
     } else {\n        if (grip !== null && inputSource.gripSpace) {\n        \
  gripPose = frame2.getPose(inputSource.gripSpace, referenceSpace);\n         \
 if (gripPose !== null) {\n            \
grip.matrix.fromArray(gripPose.transform.matrix);\n            \
grip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n            \
grip.matrixWorldNeedsUpdate = true;\n            if (gripPose.linearVelocity) \
{\n              grip.hasLinearVelocity = true;\n              \
grip.linearVelocity.copy(gripPose.linearVelocity);\n            } else {\n    \
          grip.hasLinearVelocity = false;\n            }\n            if \
(gripPose.angularVelocity) {\n              grip.hasAngularVelocity = true;\n \
             grip.angularVelocity.copy(gripPose.angularVelocity);\n           \
 } else {\n              grip.hasAngularVelocity = false;\n            }\n    \
      }\n        }\n      }\n      if (targetRay !== null) {\n        \
inputPose = frame2.getPose(inputSource.targetRaySpace, referenceSpace);\n     \
   if (inputPose === null && gripPose !== null) {\n          inputPose = \
gripPose;\n        }\n        if (inputPose !== null) {\n          \
targetRay.matrix.fromArray(inputPose.transform.matrix);\n          \
targetRay.matrix.decompose(targetRay.position, targetRay.rotation, \
targetRay.scale);\n          targetRay.matrixWorldNeedsUpdate = true;\n       \
   if (inputPose.linearVelocity) {\n            targetRay.hasLinearVelocity = \
true;\n            targetRay.linearVelocity.copy(inputPose.linearVelocity);\n \
         } else {\n            targetRay.hasLinearVelocity = false;\n         \
 }\n          if (inputPose.angularVelocity) {\n            \
targetRay.hasAngularVelocity = true;\n            \
targetRay.angularVelocity.copy(inputPose.angularVelocity);\n          } else \
{\n            targetRay.hasAngularVelocity = false;\n          }\n          \
this.dispatchEvent(_moveEvent);\n        }\n      }\n    }\n    if (targetRay \
!== null) {\n      targetRay.visible = inputPose !== null;\n    }\n    if \
(grip !== null) {\n      grip.visible = gripPose !== null;\n    }\n    if \
(hand !== null) {\n      hand.visible = handPose !== null;\n    }\n    return \
this;\n  }\n  // private method\n  _getHandJoint(hand, inputjoint) {\n    if \
(hand.joints[inputjoint.jointName] === void 0) {\n      const joint = new \
Group();\n      joint.matrixAutoUpdate = false;\n      joint.visible = \
false;\n      hand.joints[inputjoint.jointName] = joint;\n      \
hand.add(joint);\n    }\n    return hand.joints[inputjoint.jointName];\n  \
}\n};\nvar _occlusion_vertex = `\nvoid main() {\n\n\tgl_Position = vec4( \
position, 1.0 );\n\n}`;\nvar _occlusion_fragment = `\nuniform sampler2DArray \
depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid \
main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y \
/ depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( \
depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else \
{\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) \
).r;\n\n\t}\n\n}`;\nvar WebXRDepthSensing = class {\n  constructor() {\n    \
this.texture = null;\n    this.mesh = null;\n    this.depthNear = 0;\n    \
this.depthFar = 0;\n  }\n  init(renderer3, depthData, renderState) {\n    if \
(this.texture === null) {\n      const texture2 = new Texture();\n      const \
texProps = renderer3.properties.get(texture2);\n      texProps.__webglTexture \
= depthData.texture;\n      if (depthData.depthNear != renderState.depthNear \
|| depthData.depthFar != renderState.depthFar) {\n        this.depthNear = \
depthData.depthNear;\n        this.depthFar = depthData.depthFar;\n      }\n  \
    this.texture = texture2;\n    }\n  }\n  getMesh(cameraXR) {\n    if \
(this.texture !== null) {\n      if (this.mesh === null) {\n        const \
viewport2 = cameraXR.cameras[0].viewport;\n        const material = new \
ShaderMaterial({\n          vertexShader: _occlusion_vertex,\n          \
fragmentShader: _occlusion_fragment,\n          uniforms: {\n            \
depthColor: { value: this.texture },\n            depthWidth: { value: \
viewport2.z },\n            depthHeight: { value: viewport2.w }\n          \
}\n        });\n        this.mesh = new Mesh(new PlaneGeometry(20, 20), \
material);\n      }\n    }\n    return this.mesh;\n  }\n  reset() {\n    \
this.texture = null;\n    this.mesh = null;\n  }\n  getDepthTexture() {\n    \
return this.texture;\n  }\n};\nvar WebXRManager = class extends \
EventDispatcher {\n  constructor(renderer3, gl) {\n    super();\n    const \
scope = this;\n    let session = null;\n    let framebufferScaleFactor = 1;\n \
   let referenceSpace = null;\n    let referenceSpaceType = \
\"local-floor\";\n    let foveation = 1;\n    let customReferenceSpace = \
null;\n    let pose = null;\n    let glBinding = null;\n    let glProjLayer = \
null;\n    let glBaseLayer = null;\n    let xrFrame = null;\n    const \
depthSensing = new WebXRDepthSensing();\n    const attributes = \
gl.getContextAttributes();\n    let initialRenderTarget = null;\n    let \
newRenderTarget = null;\n    const controllers = [];\n    const \
controllerInputSources = [];\n    const currentSize = new Vector2();\n    let \
currentPixelRatio = null;\n    const cameraL = new PerspectiveCamera();\n    \
cameraL.viewport = new Vector4();\n    const cameraR = new \
PerspectiveCamera();\n    cameraR.viewport = new Vector4();\n    const \
cameras = [cameraL, cameraR];\n    const cameraXR = new ArrayCamera();\n    \
let _currentDepthNear = null;\n    let _currentDepthFar = null;\n    \
this.cameraAutoUpdate = true;\n    this.enabled = false;\n    \
this.isPresenting = false;\n    this.getController = function(index5) {\n     \
 let controller = controllers[index5];\n      if (controller === void 0) {\n  \
      controller = new WebXRController();\n        controllers[index5] = \
controller;\n      }\n      return controller.getTargetRaySpace();\n    };\n  \
  this.getControllerGrip = function(index5) {\n      let controller = \
controllers[index5];\n      if (controller === void 0) {\n        controller \
= new WebXRController();\n        controllers[index5] = controller;\n      \
}\n      return controller.getGripSpace();\n    };\n    this.getHand = \
function(index5) {\n      let controller = controllers[index5];\n      if \
(controller === void 0) {\n        controller = new WebXRController();\n      \
  controllers[index5] = controller;\n      }\n      return \
controller.getHandSpace();\n    };\n    function onSessionEvent(event) {\n    \
  const controllerIndex = \
controllerInputSources.indexOf(event.inputSource);\n      if (controllerIndex \
=== -1) {\n        return;\n      }\n      const controller = \
controllers[controllerIndex];\n      if (controller !== void 0) {\n        \
controller.update(event.inputSource, event.frame, customReferenceSpace || \
referenceSpace);\n        controller.dispatchEvent({ type: event.type, data: \
event.inputSource });\n      }\n    }\n    function onSessionEnd() {\n      \
session.removeEventListener(\"select\", onSessionEvent);\n      \
session.removeEventListener(\"selectstart\", onSessionEvent);\n      \
session.removeEventListener(\"selectend\", onSessionEvent);\n      \
session.removeEventListener(\"squeeze\", onSessionEvent);\n      \
session.removeEventListener(\"squeezestart\", onSessionEvent);\n      \
session.removeEventListener(\"squeezeend\", onSessionEvent);\n      \
session.removeEventListener(\"end\", onSessionEnd);\n      \
session.removeEventListener(\"inputsourceschange\", onInputSourcesChange);\n  \
    for (let i = 0; i < controllers.length; i++) {\n        const inputSource \
= controllerInputSources[i];\n        if (inputSource === null) continue;\n   \
     controllerInputSources[i] = null;\n        \
controllers[i].disconnect(inputSource);\n      }\n      _currentDepthNear = \
null;\n      _currentDepthFar = null;\n      depthSensing.reset();\n      \
renderer3.setRenderTarget(initialRenderTarget);\n      glBaseLayer = null;\n  \
    glProjLayer = null;\n      glBinding = null;\n      session = null;\n     \
 newRenderTarget = null;\n      animation.stop();\n      scope.isPresenting = \
false;\n      renderer3.setPixelRatio(currentPixelRatio);\n      \
renderer3.setSize(currentSize.width, currentSize.height, false);\n      \
scope.dispatchEvent({ type: \"sessionend\" });\n    }\n    \
this.setFramebufferScaleFactor = function(value) {\n      \
framebufferScaleFactor = value;\n      if (scope.isPresenting === true) {\n   \
     console.warn(\"THREE.WebXRManager: Cannot change framebuffer scale while \
presenting.\");\n      }\n    };\n    this.setReferenceSpaceType = \
function(value) {\n      referenceSpaceType = value;\n      if \
(scope.isPresenting === true) {\n        console.warn(\"THREE.WebXRManager: \
Cannot change reference space type while presenting.\");\n      }\n    };\n   \
 this.getReferenceSpace = function() {\n      return customReferenceSpace || \
referenceSpace;\n    };\n    this.setReferenceSpace = function(space) {\n     \
 customReferenceSpace = space;\n    };\n    this.getBaseLayer = function() \
{\n      return glProjLayer !== null ? glProjLayer : glBaseLayer;\n    };\n   \
 this.getBinding = function() {\n      return glBinding;\n    };\n    \
this.getFrame = function() {\n      return xrFrame;\n    };\n    \
this.getSession = function() {\n      return session;\n    };\n    \
this.setSession = async function(value) {\n      session = value;\n      if \
(session !== null) {\n        initialRenderTarget = \
renderer3.getRenderTarget();\n        session.addEventListener(\"select\", \
onSessionEvent);\n        session.addEventListener(\"selectstart\", \
onSessionEvent);\n        session.addEventListener(\"selectend\", \
onSessionEvent);\n        session.addEventListener(\"squeeze\", \
onSessionEvent);\n        session.addEventListener(\"squeezestart\", \
onSessionEvent);\n        session.addEventListener(\"squeezeend\", \
onSessionEvent);\n        session.addEventListener(\"end\", onSessionEnd);\n  \
      session.addEventListener(\"inputsourceschange\", \
onInputSourcesChange);\n        if (attributes.xrCompatible !== true) {\n     \
     await gl.makeXRCompatible();\n        }\n        currentPixelRatio = \
renderer3.getPixelRatio();\n        renderer3.getSize(currentSize);\n        \
if (session.renderState.layers === void 0) {\n          const layerInit = {\n \
           antialias: attributes.antialias,\n            alpha: true,\n       \
     depth: attributes.depth,\n            stencil: attributes.stencil,\n     \
       framebufferScaleFactor\n          };\n          glBaseLayer = new \
XRWebGLLayer(session, gl, layerInit);\n          session.updateRenderState({ \
baseLayer: glBaseLayer });\n          renderer3.setPixelRatio(1);\n          \
renderer3.setSize(glBaseLayer.framebufferWidth, \
glBaseLayer.framebufferHeight, false);\n          newRenderTarget = new \
WebGLRenderTarget(\n            glBaseLayer.framebufferWidth,\n            \
glBaseLayer.framebufferHeight,\n            {\n              format: \
RGBAFormat,\n              type: UnsignedByteType,\n              colorSpace: \
renderer3.outputColorSpace,\n              stencilBuffer: \
attributes.stencil\n            }\n          );\n        } else {\n          \
let depthFormat = null;\n          let depthType = null;\n          let \
glDepthFormat = null;\n          if (attributes.depth) {\n            \
glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : \
gl.DEPTH_COMPONENT24;\n            depthFormat = attributes.stencil ? \
DepthStencilFormat : DepthFormat;\n            depthType = attributes.stencil \
? UnsignedInt248Type : UnsignedIntType;\n          }\n          const \
projectionlayerInit = {\n            colorFormat: gl.RGBA8,\n            \
depthFormat: glDepthFormat,\n            scaleFactor: \
framebufferScaleFactor\n          };\n          glBinding = new \
XRWebGLBinding(session, gl);\n          glProjLayer = \
glBinding.createProjectionLayer(projectionlayerInit);\n          \
session.updateRenderState({ layers: [glProjLayer] });\n          \
renderer3.setPixelRatio(1);\n          \
renderer3.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, \
false);\n          newRenderTarget = new WebGLRenderTarget(\n            \
glProjLayer.textureWidth,\n            glProjLayer.textureHeight,\n           \
 {\n              format: RGBAFormat,\n              type: \
UnsignedByteType,\n              depthTexture: new \
DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, \
void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),\n              \
stencilBuffer: attributes.stencil,\n              colorSpace: \
renderer3.outputColorSpace,\n              samples: attributes.antialias ? 4 \
: 0,\n              resolveDepthBuffer: glProjLayer.ignoreDepthValues === \
false\n            }\n          );\n        }\n        \
newRenderTarget.isXRRenderTarget = true;\n        \
this.setFoveation(foveation);\n        customReferenceSpace = null;\n        \
referenceSpace = await session.requestReferenceSpace(referenceSpaceType);\n   \
     animation.setContext(session);\n        animation.start();\n        \
scope.isPresenting = true;\n        scope.dispatchEvent({ type: \
\"sessionstart\" });\n      }\n    };\n    this.getEnvironmentBlendMode = \
function() {\n      if (session !== null) {\n        return \
session.environmentBlendMode;\n      }\n    };\n    this.getDepthTexture = \
function() {\n      return depthSensing.getDepthTexture();\n    };\n    \
function onInputSourcesChange(event) {\n      for (let i = 0; i < \
event.removed.length; i++) {\n        const inputSource = event.removed[i];\n \
       const index5 = controllerInputSources.indexOf(inputSource);\n        \
if (index5 >= 0) {\n          controllerInputSources[index5] = null;\n        \
  controllers[index5].disconnect(inputSource);\n        }\n      }\n      for \
(let i = 0; i < event.added.length; i++) {\n        const inputSource = \
event.added[i];\n        let controllerIndex = \
controllerInputSources.indexOf(inputSource);\n        if (controllerIndex === \
-1) {\n          for (let i2 = 0; i2 < controllers.length; i2++) {\n          \
  if (i2 >= controllerInputSources.length) {\n              \
controllerInputSources.push(inputSource);\n              controllerIndex = \
i2;\n              break;\n            } else if (controllerInputSources[i2] \
=== null) {\n              controllerInputSources[i2] = inputSource;\n        \
      controllerIndex = i2;\n              break;\n            }\n          \
}\n          if (controllerIndex === -1) break;\n        }\n        const \
controller = controllers[controllerIndex];\n        if (controller) {\n       \
   controller.connect(inputSource);\n        }\n      }\n    }\n    const \
cameraLPos = new Vector3();\n    const cameraRPos = new Vector3();\n    \
function setProjectionFromUnion(camera3, cameraL2, cameraR2) {\n      \
cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);\n      \
cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);\n      const ipd = \
cameraLPos.distanceTo(cameraRPos);\n      const projL = \
cameraL2.projectionMatrix.elements;\n      const projR = \
cameraR2.projectionMatrix.elements;\n      const near = projL[14] / \
(projL[10] - 1);\n      const far = projL[14] / (projL[10] + 1);\n      const \
topFov = (projL[9] + 1) / projL[5];\n      const bottomFov = (projL[9] - 1) / \
projL[5];\n      const leftFov = (projL[8] - 1) / projL[0];\n      const \
rightFov = (projR[8] + 1) / projR[0];\n      const left = near * leftFov;\n   \
   const right = near * rightFov;\n      const zOffset = ipd / (-leftFov + \
rightFov);\n      const xOffset = zOffset * -leftFov;\n      \
cameraL2.matrixWorld.decompose(camera3.position, camera3.quaternion, \
camera3.scale);\n      camera3.translateX(xOffset);\n      \
camera3.translateZ(zOffset);\n      \
camera3.matrixWorld.compose(camera3.position, camera3.quaternion, \
camera3.scale);\n      \
camera3.matrixWorldInverse.copy(camera3.matrixWorld).invert();\n      if \
(projL[10] === -1) {\n        \
camera3.projectionMatrix.copy(cameraL2.projectionMatrix);\n        \
camera3.projectionMatrixInverse.copy(cameraL2.projectionMatrixInverse);\n     \
 } else {\n        const near2 = near + zOffset;\n        const far2 = far + \
zOffset;\n        const left2 = left - xOffset;\n        const right2 = right \
+ (ipd - xOffset);\n        const top2 = topFov * far / far2 * near2;\n       \
 const bottom2 = bottomFov * far / far2 * near2;\n        \
camera3.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, \
far2);\n        \
camera3.projectionMatrixInverse.copy(camera3.projectionMatrix).invert();\n    \
  }\n    }\n    function updateCamera(camera3, parent) {\n      if (parent \
=== null) {\n        camera3.matrixWorld.copy(camera3.matrix);\n      } else \
{\n        camera3.matrixWorld.multiplyMatrices(parent.matrixWorld, \
camera3.matrix);\n      }\n      \
camera3.matrixWorldInverse.copy(camera3.matrixWorld).invert();\n    }\n    \
this.updateCamera = function(camera3) {\n      if (session === null) \
return;\n      let depthNear = camera3.near;\n      let depthFar = \
camera3.far;\n      if (depthSensing.texture !== null) {\n        if \
(depthSensing.depthNear > 0) depthNear = depthSensing.depthNear;\n        if \
(depthSensing.depthFar > 0) depthFar = depthSensing.depthFar;\n      }\n      \
cameraXR.near = cameraR.near = cameraL.near = depthNear;\n      cameraXR.far \
= cameraR.far = cameraL.far = depthFar;\n      if (_currentDepthNear !== \
cameraXR.near || _currentDepthFar !== cameraXR.far) {\n        \
session.updateRenderState({\n          depthNear: cameraXR.near,\n          \
depthFar: cameraXR.far\n        });\n        _currentDepthNear = \
cameraXR.near;\n        _currentDepthFar = cameraXR.far;\n      }\n      \
cameraL.layers.mask = camera3.layers.mask | 2;\n      cameraR.layers.mask = \
camera3.layers.mask | 4;\n      cameraXR.layers.mask = cameraL.layers.mask | \
cameraR.layers.mask;\n      const parent = camera3.parent;\n      const \
cameras2 = cameraXR.cameras;\n      updateCamera(cameraXR, parent);\n      \
for (let i = 0; i < cameras2.length; i++) {\n        \
updateCamera(cameras2[i], parent);\n      }\n      if (cameras2.length === 2) \
{\n        setProjectionFromUnion(cameraXR, cameraL, cameraR);\n      } else \
{\n        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);\n      \
}\n      updateUserCamera(camera3, cameraXR, parent);\n    };\n    function \
updateUserCamera(camera3, cameraXR2, parent) {\n      if (parent === null) \
{\n        camera3.matrix.copy(cameraXR2.matrixWorld);\n      } else {\n      \
  camera3.matrix.copy(parent.matrixWorld);\n        \
camera3.matrix.invert();\n        \
camera3.matrix.multiply(cameraXR2.matrixWorld);\n      }\n      \
camera3.matrix.decompose(camera3.position, camera3.quaternion, \
camera3.scale);\n      camera3.updateMatrixWorld(true);\n      \
camera3.projectionMatrix.copy(cameraXR2.projectionMatrix);\n      \
camera3.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);\n    \
  if (camera3.isPerspectiveCamera) {\n        camera3.fov = RAD2DEG * 2 * \
Math.atan(1 / camera3.projectionMatrix.elements[5]);\n        camera3.zoom = \
1;\n      }\n    }\n    this.getCamera = function() {\n      return \
cameraXR;\n    };\n    this.getFoveation = function() {\n      if \
(glProjLayer === null && glBaseLayer === null) {\n        return void 0;\n    \
  }\n      return foveation;\n    };\n    this.setFoveation = function(value) \
{\n      foveation = value;\n      if (glProjLayer !== null) {\n        \
glProjLayer.fixedFoveation = value;\n      }\n      if (glBaseLayer !== null \
&& glBaseLayer.fixedFoveation !== void 0) {\n        \
glBaseLayer.fixedFoveation = value;\n      }\n    };\n    \
this.hasDepthSensing = function() {\n      return depthSensing.texture !== \
null;\n    };\n    this.getDepthSensingMesh = function() {\n      return \
depthSensing.getMesh(cameraXR);\n    };\n    let onAnimationFrameCallback = \
null;\n    function onAnimationFrame(time, frame2) {\n      pose = \
frame2.getViewerPose(customReferenceSpace || referenceSpace);\n      xrFrame \
= frame2;\n      if (pose !== null) {\n        const views = pose.views;\n    \
    if (glBaseLayer !== null) {\n          \
renderer3.setRenderTargetFramebuffer(newRenderTarget, \
glBaseLayer.framebuffer);\n          \
renderer3.setRenderTarget(newRenderTarget);\n        }\n        let \
cameraXRNeedsUpdate = false;\n        if (views.length !== \
cameraXR.cameras.length) {\n          cameraXR.cameras.length = 0;\n          \
cameraXRNeedsUpdate = true;\n        }\n        for (let i = 0; i < \
views.length; i++) {\n          const view = views[i];\n          let \
viewport2 = null;\n          if (glBaseLayer !== null) {\n            \
viewport2 = glBaseLayer.getViewport(view);\n          } else {\n            \
const glSubImage = glBinding.getViewSubImage(glProjLayer, view);\n            \
viewport2 = glSubImage.viewport;\n            if (i === 0) {\n              \
renderer3.setRenderTargetTextures(\n                newRenderTarget,\n        \
        glSubImage.colorTexture,\n                \
glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture\n     \
         );\n              renderer3.setRenderTarget(newRenderTarget);\n      \
      }\n          }\n          let camera3 = cameras[i];\n          if \
(camera3 === void 0) {\n            camera3 = new PerspectiveCamera();\n      \
      camera3.layers.enable(i);\n            camera3.viewport = new \
Vector4();\n            cameras[i] = camera3;\n          }\n          \
camera3.matrix.fromArray(view.transform.matrix);\n          \
camera3.matrix.decompose(camera3.position, camera3.quaternion, \
camera3.scale);\n          \
camera3.projectionMatrix.fromArray(view.projectionMatrix);\n          \
camera3.projectionMatrixInverse.copy(camera3.projectionMatrix).invert();\n    \
      camera3.viewport.set(viewport2.x, viewport2.y, viewport2.width, \
viewport2.height);\n          if (i === 0) {\n            \
cameraXR.matrix.copy(camera3.matrix);\n            \
cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, \
cameraXR.scale);\n          }\n          if (cameraXRNeedsUpdate === true) \
{\n            cameraXR.cameras.push(camera3);\n          }\n        }\n      \
  const enabledFeatures = session.enabledFeatures;\n        if \
(enabledFeatures && enabledFeatures.includes(\"depth-sensing\")) {\n          \
const depthData = glBinding.getDepthInformation(views[0]);\n          if \
(depthData && depthData.isValid && depthData.texture) {\n            \
depthSensing.init(renderer3, depthData, session.renderState);\n          }\n  \
      }\n      }\n      for (let i = 0; i < controllers.length; i++) {\n      \
  const inputSource = controllerInputSources[i];\n        const controller = \
controllers[i];\n        if (inputSource !== null && controller !== void 0) \
{\n          controller.update(inputSource, frame2, customReferenceSpace || \
referenceSpace);\n        }\n      }\n      if (onAnimationFrameCallback) \
onAnimationFrameCallback(time, frame2);\n      if (frame2.detectedPlanes) {\n \
       scope.dispatchEvent({ type: \"planesdetected\", data: frame2 });\n     \
 }\n      xrFrame = null;\n    }\n    const animation = new \
WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n    \
this.setAnimationLoop = function(callback) {\n      onAnimationFrameCallback \
= callback;\n    };\n    this.dispose = function() {\n    };\n  }\n};\nvar \
_e1 = /* @__PURE__ */ new Euler();\nvar _m1 = /* @__PURE__ */ new \
Matrix4();\nfunction WebGLMaterials(renderer3, properties) {\n  function \
refreshTransformUniform(map, uniform2) {\n    if (map.matrixAutoUpdate === \
true) {\n      map.updateMatrix();\n    }\n    \
uniform2.value.copy(map.matrix);\n  }\n  function \
refreshFogUniforms(uniforms, fog) {\n    \
fog.color.getRGB(uniforms.fogColor.value, \
getUnlitUniformColorSpace(renderer3));\n    if (fog.isFog) {\n      \
uniforms.fogNear.value = fog.near;\n      uniforms.fogFar.value = fog.far;\n  \
  } else if (fog.isFogExp2) {\n      uniforms.fogDensity.value = \
fog.density;\n    }\n  }\n  function refreshMaterialUniforms(uniforms, \
material, pixelRatio, height, transmissionRenderTarget) {\n    if \
(material.isMeshBasicMaterial) {\n      refreshUniformsCommon(uniforms, \
material);\n    } else if (material.isMeshLambertMaterial) {\n      \
refreshUniformsCommon(uniforms, material);\n    } else if \
(material.isMeshToonMaterial) {\n      refreshUniformsCommon(uniforms, \
material);\n      refreshUniformsToon(uniforms, material);\n    } else if \
(material.isMeshPhongMaterial) {\n      refreshUniformsCommon(uniforms, \
material);\n      refreshUniformsPhong(uniforms, material);\n    } else if \
(material.isMeshStandardMaterial) {\n      refreshUniformsCommon(uniforms, \
material);\n      refreshUniformsStandard(uniforms, material);\n      if \
(material.isMeshPhysicalMaterial) {\n        \
refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);\n      \
}\n    } else if (material.isMeshMatcapMaterial) {\n      \
refreshUniformsCommon(uniforms, material);\n      \
refreshUniformsMatcap(uniforms, material);\n    } else if \
(material.isMeshDepthMaterial) {\n      refreshUniformsCommon(uniforms, \
material);\n    } else if (material.isMeshDistanceMaterial) {\n      \
refreshUniformsCommon(uniforms, material);\n      \
refreshUniformsDistance(uniforms, material);\n    } else if \
(material.isMeshNormalMaterial) {\n      refreshUniformsCommon(uniforms, \
material);\n    } else if (material.isLineBasicMaterial) {\n      \
refreshUniformsLine(uniforms, material);\n      if \
(material.isLineDashedMaterial) {\n        refreshUniformsDash(uniforms, \
material);\n      }\n    } else if (material.isPointsMaterial) {\n      \
refreshUniformsPoints(uniforms, material, pixelRatio, height);\n    } else if \
(material.isSpriteMaterial) {\n      refreshUniformsSprites(uniforms, \
material);\n    } else if (material.isShadowMaterial) {\n      \
uniforms.color.value.copy(material.color);\n      uniforms.opacity.value = \
material.opacity;\n    } else if (material.isShaderMaterial) {\n      \
material.uniformsNeedUpdate = false;\n    }\n  }\n  function \
refreshUniformsCommon(uniforms, material) {\n    uniforms.opacity.value = \
material.opacity;\n    if (material.color) {\n      \
uniforms.diffuse.value.copy(material.color);\n    }\n    if \
(material.emissive) {\n      \
uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emiss\
iveIntensity);\n    }\n    if (material.map) {\n      uniforms.map.value = \
material.map;\n      refreshTransformUniform(material.map, \
uniforms.mapTransform);\n    }\n    if (material.alphaMap) {\n      \
uniforms.alphaMap.value = material.alphaMap;\n      \
refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);\n    \
}\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = \
material.bumpMap;\n      refreshTransformUniform(material.bumpMap, \
uniforms.bumpMapTransform);\n      uniforms.bumpScale.value = \
material.bumpScale;\n      if (material.side === BackSide) {\n        \
uniforms.bumpScale.value *= -1;\n      }\n    }\n    if (material.normalMap) \
{\n      uniforms.normalMap.value = material.normalMap;\n      \
refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);\n   \
   uniforms.normalScale.value.copy(material.normalScale);\n      if \
(material.side === BackSide) {\n        \
uniforms.normalScale.value.negate();\n      }\n    }\n    if \
(material.displacementMap) {\n      uniforms.displacementMap.value = \
material.displacementMap;\n      \
refreshTransformUniform(material.displacementMap, \
uniforms.displacementMapTransform);\n      uniforms.displacementScale.value = \
material.displacementScale;\n      uniforms.displacementBias.value = \
material.displacementBias;\n    }\n    if (material.emissiveMap) {\n      \
uniforms.emissiveMap.value = material.emissiveMap;\n      \
refreshTransformUniform(material.emissiveMap, \
uniforms.emissiveMapTransform);\n    }\n    if (material.specularMap) {\n     \
 uniforms.specularMap.value = material.specularMap;\n      \
refreshTransformUniform(material.specularMap, \
uniforms.specularMapTransform);\n    }\n    if (material.alphaTest > 0) {\n   \
   uniforms.alphaTest.value = material.alphaTest;\n    }\n    const \
materialProperties = properties.get(material);\n    const envMap = \
materialProperties.envMap;\n    const envMapRotation = \
materialProperties.envMapRotation;\n    if (envMap) {\n      \
uniforms.envMap.value = envMap;\n      _e1.copy(envMapRotation);\n      _e1.x \
*= -1;\n      _e1.y *= -1;\n      _e1.z *= -1;\n      if \
(envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {\n        \
_e1.y *= -1;\n        _e1.z *= -1;\n      }\n      \
uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));\
\n      uniforms.flipEnvMap.value = envMap.isCubeTexture && \
envMap.isRenderTargetTexture === false ? -1 : 1;\n      \
uniforms.reflectivity.value = material.reflectivity;\n      \
uniforms.ior.value = material.ior;\n      uniforms.refractionRatio.value = \
material.refractionRatio;\n    }\n    if (material.lightMap) {\n      \
uniforms.lightMap.value = material.lightMap;\n      \
uniforms.lightMapIntensity.value = material.lightMapIntensity;\n      \
refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);\n    \
}\n    if (material.aoMap) {\n      uniforms.aoMap.value = material.aoMap;\n  \
    uniforms.aoMapIntensity.value = material.aoMapIntensity;\n      \
refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);\n    }\n  \
}\n  function refreshUniformsLine(uniforms, material) {\n    \
uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = \
material.opacity;\n    if (material.map) {\n      uniforms.map.value = \
material.map;\n      refreshTransformUniform(material.map, \
uniforms.mapTransform);\n    }\n  }\n  function refreshUniformsDash(uniforms, \
material) {\n    uniforms.dashSize.value = material.dashSize;\n    \
uniforms.totalSize.value = material.dashSize + material.gapSize;\n    \
uniforms.scale.value = material.scale;\n  }\n  function \
refreshUniformsPoints(uniforms, material, pixelRatio, height) {\n    \
uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = \
material.opacity;\n    uniforms.size.value = material.size * pixelRatio;\n    \
uniforms.scale.value = height * 0.5;\n    if (material.map) {\n      \
uniforms.map.value = material.map;\n      \
refreshTransformUniform(material.map, uniforms.uvTransform);\n    }\n    if \
(material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n   \
   refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);\n  \
  }\n    if (material.alphaTest > 0) {\n      uniforms.alphaTest.value = \
material.alphaTest;\n    }\n  }\n  function refreshUniformsSprites(uniforms, \
material) {\n    uniforms.diffuse.value.copy(material.color);\n    \
uniforms.opacity.value = material.opacity;\n    uniforms.rotation.value = \
material.rotation;\n    if (material.map) {\n      uniforms.map.value = \
material.map;\n      refreshTransformUniform(material.map, \
uniforms.mapTransform);\n    }\n    if (material.alphaMap) {\n      \
uniforms.alphaMap.value = material.alphaMap;\n      \
refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);\n    \
}\n    if (material.alphaTest > 0) {\n      uniforms.alphaTest.value = \
material.alphaTest;\n    }\n  }\n  function refreshUniformsPhong(uniforms, \
material) {\n    uniforms.specular.value.copy(material.specular);\n    \
uniforms.shininess.value = Math.max(material.shininess, 1e-4);\n  }\n  \
function refreshUniformsToon(uniforms, material) {\n    if \
(material.gradientMap) {\n      uniforms.gradientMap.value = \
material.gradientMap;\n    }\n  }\n  function \
refreshUniformsStandard(uniforms, material) {\n    uniforms.metalness.value = \
material.metalness;\n    if (material.metalnessMap) {\n      \
uniforms.metalnessMap.value = material.metalnessMap;\n      \
refreshTransformUniform(material.metalnessMap, \
uniforms.metalnessMapTransform);\n    }\n    uniforms.roughness.value = \
material.roughness;\n    if (material.roughnessMap) {\n      \
uniforms.roughnessMap.value = material.roughnessMap;\n      \
refreshTransformUniform(material.roughnessMap, \
uniforms.roughnessMapTransform);\n    }\n    if (material.envMap) {\n      \
uniforms.envMapIntensity.value = material.envMapIntensity;\n    }\n  }\n  \
function refreshUniformsPhysical(uniforms, material, \
transmissionRenderTarget) {\n    uniforms.ior.value = material.ior;\n    if \
(material.sheen > 0) {\n      \
uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.s\
heen);\n      uniforms.sheenRoughness.value = material.sheenRoughness;\n      \
if (material.sheenColorMap) {\n        uniforms.sheenColorMap.value = \
material.sheenColorMap;\n        \
refreshTransformUniform(material.sheenColorMap, \
uniforms.sheenColorMapTransform);\n      }\n      if \
(material.sheenRoughnessMap) {\n        uniforms.sheenRoughnessMap.value = \
material.sheenRoughnessMap;\n        \
refreshTransformUniform(material.sheenRoughnessMap, \
uniforms.sheenRoughnessMapTransform);\n      }\n    }\n    if \
(material.clearcoat > 0) {\n      uniforms.clearcoat.value = \
material.clearcoat;\n      uniforms.clearcoatRoughness.value = \
material.clearcoatRoughness;\n      if (material.clearcoatMap) {\n        \
uniforms.clearcoatMap.value = material.clearcoatMap;\n        \
refreshTransformUniform(material.clearcoatMap, \
uniforms.clearcoatMapTransform);\n      }\n      if \
(material.clearcoatRoughnessMap) {\n        \
uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n      \
  refreshTransformUniform(material.clearcoatRoughnessMap, \
uniforms.clearcoatRoughnessMapTransform);\n      }\n      if \
(material.clearcoatNormalMap) {\n        uniforms.clearcoatNormalMap.value = \
material.clearcoatNormalMap;\n        \
refreshTransformUniform(material.clearcoatNormalMap, \
uniforms.clearcoatNormalMapTransform);\n        \
uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);\n    \
    if (material.side === BackSide) {\n          \
uniforms.clearcoatNormalScale.value.negate();\n        }\n      }\n    }\n    \
if (material.dispersion > 0) {\n      uniforms.dispersion.value = \
material.dispersion;\n    }\n    if (material.iridescence > 0) {\n      \
uniforms.iridescence.value = material.iridescence;\n      \
uniforms.iridescenceIOR.value = material.iridescenceIOR;\n      \
uniforms.iridescenceThicknessMinimum.value = \
material.iridescenceThicknessRange[0];\n      \
uniforms.iridescenceThicknessMaximum.value = \
material.iridescenceThicknessRange[1];\n      if (material.iridescenceMap) \
{\n        uniforms.iridescenceMap.value = material.iridescenceMap;\n        \
refreshTransformUniform(material.iridescenceMap, \
uniforms.iridescenceMapTransform);\n      }\n      if \
(material.iridescenceThicknessMap) {\n        \
uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;\n  \
      refreshTransformUniform(material.iridescenceThicknessMap, \
uniforms.iridescenceThicknessMapTransform);\n      }\n    }\n    if \
(material.transmission > 0) {\n      uniforms.transmission.value = \
material.transmission;\n      uniforms.transmissionSamplerMap.value = \
transmissionRenderTarget.texture;\n      \
uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, \
transmissionRenderTarget.height);\n      if (material.transmissionMap) {\n    \
    uniforms.transmissionMap.value = material.transmissionMap;\n        \
refreshTransformUniform(material.transmissionMap, \
uniforms.transmissionMapTransform);\n      }\n      uniforms.thickness.value \
= material.thickness;\n      if (material.thicknessMap) {\n        \
uniforms.thicknessMap.value = material.thicknessMap;\n        \
refreshTransformUniform(material.thicknessMap, \
uniforms.thicknessMapTransform);\n      }\n      \
uniforms.attenuationDistance.value = material.attenuationDistance;\n      \
uniforms.attenuationColor.value.copy(material.attenuationColor);\n    }\n    \
if (material.anisotropy > 0) {\n      \
uniforms.anisotropyVector.value.set(material.anisotropy * \
Math.cos(material.anisotropyRotation), material.anisotropy * \
Math.sin(material.anisotropyRotation));\n      if (material.anisotropyMap) \
{\n        uniforms.anisotropyMap.value = material.anisotropyMap;\n        \
refreshTransformUniform(material.anisotropyMap, \
uniforms.anisotropyMapTransform);\n      }\n    }\n    \
uniforms.specularIntensity.value = material.specularIntensity;\n    \
uniforms.specularColor.value.copy(material.specularColor);\n    if \
(material.specularColorMap) {\n      uniforms.specularColorMap.value = \
material.specularColorMap;\n      \
refreshTransformUniform(material.specularColorMap, \
uniforms.specularColorMapTransform);\n    }\n    if \
(material.specularIntensityMap) {\n      uniforms.specularIntensityMap.value \
= material.specularIntensityMap;\n      \
refreshTransformUniform(material.specularIntensityMap, \
uniforms.specularIntensityMapTransform);\n    }\n  }\n  function \
refreshUniformsMatcap(uniforms, material) {\n    if (material.matcap) {\n     \
 uniforms.matcap.value = material.matcap;\n    }\n  }\n  function \
refreshUniformsDistance(uniforms, material) {\n    const light = \
properties.get(material).light;\n    \
uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);\n  \
  uniforms.nearDistance.value = light.shadow.camera.near;\n    \
uniforms.farDistance.value = light.shadow.camera.far;\n  }\n  return {\n    \
refreshFogUniforms,\n    refreshMaterialUniforms\n  };\n}\nfunction \
WebGLUniformsGroups(gl, info, capabilities, state) {\n  let buffers = {};\n  \
let updateList = {};\n  let allocatedBindingPoints = [];\n  const \
maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);\n  \
function bind(uniformsGroup, program) {\n    const webglProgram = \
program.program;\n    state.uniformBlockBinding(uniformsGroup, \
webglProgram);\n  }\n  function update4(uniformsGroup, program) {\n    let \
buffer2 = buffers[uniformsGroup.id];\n    if (buffer2 === void 0) {\n      \
prepareUniformsGroup(uniformsGroup);\n      buffer2 = \
createBuffer(uniformsGroup);\n      buffers[uniformsGroup.id] = buffer2;\n    \
  uniformsGroup.addEventListener(\"dispose\", onUniformsGroupsDispose);\n    \
}\n    const webglProgram = program.program;\n    \
state.updateUBOMapping(uniformsGroup, webglProgram);\n    const frame2 = \
info.render.frame;\n    if (updateList[uniformsGroup.id] !== frame2) {\n      \
updateBufferData(uniformsGroup);\n      updateList[uniformsGroup.id] = \
frame2;\n    }\n  }\n  function createBuffer(uniformsGroup) {\n    const \
bindingPointIndex = allocateBindingPointIndex();\n    \
uniformsGroup.__bindingPointIndex = bindingPointIndex;\n    const buffer2 = \
gl.createBuffer();\n    const size = uniformsGroup.__size;\n    const usage = \
uniformsGroup.usage;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer2);\n    \
gl.bufferData(gl.UNIFORM_BUFFER, size, usage);\n    \
gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n    \
gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer2);\n    return \
buffer2;\n  }\n  function allocateBindingPointIndex() {\n    for (let i = 0; \
i < maxBindingPoints; i++) {\n      if (allocatedBindingPoints.indexOf(i) === \
-1) {\n        allocatedBindingPoints.push(i);\n        return i;\n      }\n  \
  }\n    console.error(\"THREE.WebGLRenderer: Maximum number of \
simultaneously usable uniforms groups reached.\");\n    return 0;\n  }\n  \
function updateBufferData(uniformsGroup) {\n    const buffer2 = \
buffers[uniformsGroup.id];\n    const uniforms = uniformsGroup.uniforms;\n    \
const cache2 = uniformsGroup.__cache;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, \
buffer2);\n    for (let i = 0, il = uniforms.length; i < il; i++) {\n      \
const uniformArray2 = Array.isArray(uniforms[i]) ? uniforms[i] : \
[uniforms[i]];\n      for (let j = 0, jl = uniformArray2.length; j < jl; j++) \
{\n        const uniform2 = uniformArray2[j];\n        if \
(hasUniformChanged(uniform2, i, j, cache2) === true) {\n          const \
offset = uniform2.__offset;\n          const values = \
Array.isArray(uniform2.value) ? uniform2.value : [uniform2.value];\n          \
let arrayOffset = 0;\n          for (let k = 0; k < values.length; k++) {\n   \
         const value = values[k];\n            const info2 = \
getUniformSize(value);\n            if (typeof value === \"number\" || typeof \
value === \"boolean\") {\n              uniform2.__data[0] = value;\n         \
     gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, \
uniform2.__data);\n            } else if (value.isMatrix3) {\n              \
uniform2.__data[0] = value.elements[0];\n              uniform2.__data[1] = \
value.elements[1];\n              uniform2.__data[2] = value.elements[2];\n   \
           uniform2.__data[3] = 0;\n              uniform2.__data[4] = \
value.elements[3];\n              uniform2.__data[5] = value.elements[4];\n   \
           uniform2.__data[6] = value.elements[5];\n              \
uniform2.__data[7] = 0;\n              uniform2.__data[8] = \
value.elements[6];\n              uniform2.__data[9] = value.elements[7];\n   \
           uniform2.__data[10] = value.elements[8];\n              \
uniform2.__data[11] = 0;\n            } else {\n              \
value.toArray(uniform2.__data, arrayOffset);\n              arrayOffset += \
info2.storage / Float32Array.BYTES_PER_ELEMENT;\n            }\n          }\n \
         gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform2.__data);\n      \
  }\n      }\n    }\n    gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n  }\n  \
function hasUniformChanged(uniform2, index5, indexArray, cache2) {\n    const \
value = uniform2.value;\n    const indexString = index5 + \"_\" + \
indexArray;\n    if (cache2[indexString] === void 0) {\n      if (typeof \
value === \"number\" || typeof value === \"boolean\") {\n        \
cache2[indexString] = value;\n      } else {\n        cache2[indexString] = \
value.clone();\n      }\n      return true;\n    } else {\n      const \
cachedObject = cache2[indexString];\n      if (typeof value === \"number\" || \
typeof value === \"boolean\") {\n        if (cachedObject !== value) {\n      \
    cache2[indexString] = value;\n          return true;\n        }\n      } \
else {\n        if (cachedObject.equals(value) === false) {\n          \
cachedObject.copy(value);\n          return true;\n        }\n      }\n    \
}\n    return false;\n  }\n  function prepareUniformsGroup(uniformsGroup) {\n \
   const uniforms = uniformsGroup.uniforms;\n    let offset = 0;\n    const \
chunkSize = 16;\n    for (let i = 0, l = uniforms.length; i < l; i++) {\n     \
 const uniformArray2 = Array.isArray(uniforms[i]) ? uniforms[i] : \
[uniforms[i]];\n      for (let j = 0, jl = uniformArray2.length; j < jl; j++) \
{\n        const uniform2 = uniformArray2[j];\n        const values = \
Array.isArray(uniform2.value) ? uniform2.value : [uniform2.value];\n        \
for (let k = 0, kl = values.length; k < kl; k++) {\n          const value = \
values[k];\n          const info2 = getUniformSize(value);\n          const \
chunkOffset2 = offset % chunkSize;\n          const chunkPadding = \
chunkOffset2 % info2.boundary;\n          const chunkStart = chunkOffset2 + \
chunkPadding;\n          offset += chunkPadding;\n          if (chunkStart \
!== 0 && chunkSize - chunkStart < info2.storage) {\n            offset += \
chunkSize - chunkStart;\n          }\n          uniform2.__data = new \
Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);\n          \
uniform2.__offset = offset;\n          offset += info2.storage;\n        }\n  \
    }\n    }\n    const chunkOffset = offset % chunkSize;\n    if \
(chunkOffset > 0) offset += chunkSize - chunkOffset;\n    \
uniformsGroup.__size = offset;\n    uniformsGroup.__cache = {};\n    return \
this;\n  }\n  function getUniformSize(value) {\n    const info2 = {\n      \
boundary: 0,\n      // bytes\n      storage: 0\n      // bytes\n    };\n    \
if (typeof value === \"number\" || typeof value === \"boolean\") {\n      \
info2.boundary = 4;\n      info2.storage = 4;\n    } else if \
(value.isVector2) {\n      info2.boundary = 8;\n      info2.storage = 8;\n    \
} else if (value.isVector3 || value.isColor) {\n      info2.boundary = 16;\n  \
    info2.storage = 12;\n    } else if (value.isVector4) {\n      \
info2.boundary = 16;\n      info2.storage = 16;\n    } else if \
(value.isMatrix3) {\n      info2.boundary = 48;\n      info2.storage = 48;\n  \
  } else if (value.isMatrix4) {\n      info2.boundary = 64;\n      \
info2.storage = 64;\n    } else if (value.isTexture) {\n      \
console.warn(\"THREE.WebGLRenderer: Texture samplers can not be part of an \
uniforms group.\");\n    } else {\n      console.warn(\"THREE.WebGLRenderer: \
Unsupported uniform value type.\", value);\n    }\n    return info2;\n  }\n  \
function onUniformsGroupsDispose(event) {\n    const uniformsGroup = \
event.target;\n    uniformsGroup.removeEventListener(\"dispose\", \
onUniformsGroupsDispose);\n    const index5 = \
allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);\n    \
allocatedBindingPoints.splice(index5, 1);\n    \
gl.deleteBuffer(buffers[uniformsGroup.id]);\n    delete \
buffers[uniformsGroup.id];\n    delete updateList[uniformsGroup.id];\n  }\n  \
function dispose() {\n    for (const id2 in buffers) {\n      \
gl.deleteBuffer(buffers[id2]);\n    }\n    allocatedBindingPoints = [];\n    \
buffers = {};\n    updateList = {};\n  }\n  return {\n    bind,\n    update: \
update4,\n    dispose\n  };\n}\nvar WebGLRenderer = class {\n  \
constructor(parameters = {}) {\n    const {\n      canvas = \
createCanvasElement(),\n      context: context2 = null,\n      depth: depth2 \
= true,\n      stencil = false,\n      alpha = false,\n      antialias = \
false,\n      premultipliedAlpha = true,\n      preserveDrawingBuffer = \
false,\n      powerPreference = \"default\",\n      \
failIfMajorPerformanceCaveat = false,\n      reverseDepthBuffer = false\n    \
} = parameters;\n    this.isWebGLRenderer = true;\n    let _alpha;\n    if \
(context2 !== null) {\n      if (typeof WebGLRenderingContext !== \
\"undefined\" && context2 instanceof WebGLRenderingContext) {\n        throw \
new Error(\"THREE.WebGLRenderer: WebGL 1 is not supported since r163.\");\n   \
   }\n      _alpha = context2.getContextAttributes().alpha;\n    } else {\n   \
   _alpha = alpha;\n    }\n    const uintClearColor = new Uint32Array(4);\n   \
 const intClearColor = new Int32Array(4);\n    let currentRenderList = \
null;\n    let currentRenderState = null;\n    const renderListStack = [];\n  \
  const renderStateStack = [];\n    this.domElement = canvas;\n    this.debug \
= {\n      /**\n       * Enables error checking and reporting when shader \
programs are being compiled\n       * @type {boolean}\n       */\n      \
checkShaderErrors: true,\n      /**\n       * Callback for custom error \
reporting.\n       * @type {?Function}\n       */\n      onShaderError: \
null\n    };\n    this.autoClear = true;\n    this.autoClearColor = true;\n   \
 this.autoClearDepth = true;\n    this.autoClearStencil = true;\n    \
this.sortObjects = true;\n    this.clippingPlanes = [];\n    \
this.localClippingEnabled = false;\n    this._outputColorSpace = \
SRGBColorSpace;\n    this.toneMapping = NoToneMapping;\n    \
this.toneMappingExposure = 1;\n    const _this = this;\n    let \
_isContextLost = false;\n    let _currentActiveCubeFace = 0;\n    let \
_currentActiveMipmapLevel = 0;\n    let _currentRenderTarget = null;\n    let \
_currentMaterialId = -1;\n    let _currentCamera = null;\n    const \
_currentViewport = new Vector4();\n    const _currentScissor = new \
Vector4();\n    let _currentScissorTest = null;\n    const _currentClearColor \
= new Color(0);\n    let _currentClearAlpha = 0;\n    let _width = \
canvas.width;\n    let _height = canvas.height;\n    let _pixelRatio = 1;\n   \
 let _opaqueSort = null;\n    let _transparentSort = null;\n    const \
_viewport = new Vector4(0, 0, _width, _height);\n    const _scissor = new \
Vector4(0, 0, _width, _height);\n    let _scissorTest = false;\n    const \
_frustum2 = new Frustum();\n    let _clippingEnabled = false;\n    let \
_localClippingEnabled = false;\n    const _currentProjectionMatrix = new \
Matrix4();\n    const _projScreenMatrix2 = new Matrix4();\n    const _vector3 \
= new Vector3();\n    const _vector42 = new Vector4();\n    const _emptyScene \
= { background: null, fog: null, environment: null, overrideMaterial: null, \
isScene: true };\n    let _renderBackground = false;\n    function \
getTargetPixelRatio() {\n      return _currentRenderTarget === null ? \
_pixelRatio : 1;\n    }\n    let _gl = context2;\n    function \
getContext(contextName, contextAttributes) {\n      return \
canvas.getContext(contextName, contextAttributes);\n    }\n    try {\n      \
const contextAttributes = {\n        alpha: true,\n        depth: depth2,\n   \
     stencil,\n        antialias,\n        premultipliedAlpha,\n        \
preserveDrawingBuffer,\n        powerPreference,\n        \
failIfMajorPerformanceCaveat\n      };\n      if (\"setAttribute\" in canvas) \
canvas.setAttribute(\"data-engine\", `three.js r${REVISION}`);\n      \
canvas.addEventListener(\"webglcontextlost\", onContextLost, false);\n      \
canvas.addEventListener(\"webglcontextrestored\", onContextRestore, false);\n \
     canvas.addEventListener(\"webglcontextcreationerror\", \
onContextCreationError, false);\n      if (_gl === null) {\n        const \
contextName = \"webgl2\";\n        _gl = getContext(contextName, \
contextAttributes);\n        if (_gl === null) {\n          if \
(getContext(contextName)) {\n            throw new Error(\"Error creating \
WebGL context with your selected attributes.\");\n          } else {\n        \
    throw new Error(\"Error creating WebGL context.\");\n          }\n        \
}\n      }\n    } catch (error) {\n      console.error(\"THREE.WebGLRenderer: \
\" + error.message);\n      throw error;\n    }\n    let extensions, \
capabilities, state, info;\n    let properties, textures, cubemaps, \
cubeuvmaps, attributes, geometries, objects;\n    let programCache, \
materials, renderLists, renderStates, clipping2, shadowMap;\n    let \
background, morphtargets, bufferRenderer, indexedBufferRenderer;\n    let \
utils, bindingStates, uniformsGroups;\n    function initGLContext() {\n      \
extensions = new WebGLExtensions(_gl);\n      extensions.init();\n      utils \
= new WebGLUtils(_gl, extensions);\n      capabilities = new \
WebGLCapabilities(_gl, extensions, parameters, utils);\n      state = new \
WebGLState(_gl, extensions);\n      if (capabilities.reverseDepthBuffer && \
reverseDepthBuffer) {\n        state.buffers.depth.setReversed(true);\n      \
}\n      info = new WebGLInfo(_gl);\n      properties = new \
WebGLProperties();\n      textures = new WebGLTextures(_gl, extensions, \
state, properties, capabilities, utils, info);\n      cubemaps = new \
WebGLCubeMaps(_this);\n      cubeuvmaps = new WebGLCubeUVMaps(_this);\n      \
attributes = new WebGLAttributes(_gl);\n      bindingStates = new \
WebGLBindingStates(_gl, attributes);\n      geometries = new \
WebGLGeometries(_gl, attributes, info, bindingStates);\n      objects = new \
WebGLObjects(_gl, geometries, attributes, info);\n      morphtargets = new \
WebGLMorphtargets(_gl, capabilities, textures);\n      clipping2 = new \
WebGLClipping(properties);\n      programCache = new WebGLPrograms(_this, \
cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping2);\n  \
    materials = new WebGLMaterials(_this, properties);\n      renderLists = \
new WebGLRenderLists();\n      renderStates = new \
WebGLRenderStates(extensions);\n      background = new WebGLBackground(_this, \
cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);\n      \
shadowMap = new WebGLShadowMap(_this, objects, capabilities);\n      \
uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);\n   \
   bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);\n      \
indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, \
info);\n      info.programs = programCache.programs;\n      \
_this.capabilities = capabilities;\n      _this.extensions = extensions;\n    \
  _this.properties = properties;\n      _this.renderLists = renderLists;\n    \
  _this.shadowMap = shadowMap;\n      _this.state = state;\n      _this.info \
= info;\n    }\n    initGLContext();\n    const xr = new WebXRManager(_this, \
_gl);\n    this.xr = xr;\n    this.getContext = function() {\n      return \
_gl;\n    };\n    this.getContextAttributes = function() {\n      return \
_gl.getContextAttributes();\n    };\n    this.forceContextLoss = function() \
{\n      const extension = extensions.get(\"WEBGL_lose_context\");\n      if \
(extension) extension.loseContext();\n    };\n    this.forceContextRestore = \
function() {\n      const extension = \
extensions.get(\"WEBGL_lose_context\");\n      if (extension) \
extension.restoreContext();\n    };\n    this.getPixelRatio = function() {\n  \
    return _pixelRatio;\n    };\n    this.setPixelRatio = function(value) {\n \
     if (value === void 0) return;\n      _pixelRatio = value;\n      \
this.setSize(_width, _height, false);\n    };\n    this.getSize = \
function(target) {\n      return target.set(_width, _height);\n    };\n    \
this.setSize = function(width, height, updateStyle = true) {\n      if \
(xr.isPresenting) {\n        console.warn(\"THREE.WebGLRenderer: Can't change \
size while VR device is presenting.\");\n        return;\n      }\n      \
_width = width;\n      _height = height;\n      canvas.width = \
Math.floor(width * _pixelRatio);\n      canvas.height = Math.floor(height * \
_pixelRatio);\n      if (updateStyle === true) {\n        canvas.style.width \
= width + \"px\";\n        canvas.style.height = height + \"px\";\n      }\n  \
    this.setViewport(0, 0, width, height);\n    };\n    \
this.getDrawingBufferSize = function(target) {\n      return \
target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n    };\n    \
this.setDrawingBufferSize = function(width, height, pixelRatio) {\n      \
_width = width;\n      _height = height;\n      _pixelRatio = pixelRatio;\n   \
   canvas.width = Math.floor(width * pixelRatio);\n      canvas.height = \
Math.floor(height * pixelRatio);\n      this.setViewport(0, 0, width, \
height);\n    };\n    this.getCurrentViewport = function(target) {\n      \
return target.copy(_currentViewport);\n    };\n    this.getViewport = \
function(target) {\n      return target.copy(_viewport);\n    };\n    \
this.setViewport = function(x2, y2, width, height) {\n      if (x2.isVector4) \
{\n        _viewport.set(x2.x, x2.y, x2.z, x2.w);\n      } else {\n        \
_viewport.set(x2, y2, width, height);\n      }\n      \
state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).r\
ound());\n    };\n    this.getScissor = function(target) {\n      return \
target.copy(_scissor);\n    };\n    this.setScissor = function(x2, y2, width, \
height) {\n      if (x2.isVector4) {\n        _scissor.set(x2.x, x2.y, x2.z, \
x2.w);\n      } else {\n        _scissor.set(x2, y2, width, height);\n      \
}\n      \
state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).roun\
d());\n    };\n    this.getScissorTest = function() {\n      return \
_scissorTest;\n    };\n    this.setScissorTest = function(boolean) {\n      \
state.setScissorTest(_scissorTest = boolean);\n    };\n    this.setOpaqueSort \
= function(method) {\n      _opaqueSort = method;\n    };\n    \
this.setTransparentSort = function(method) {\n      _transparentSort = \
method;\n    };\n    this.getClearColor = function(target) {\n      return \
target.copy(background.getClearColor());\n    };\n    this.setClearColor = \
function() {\n      background.setClearColor.apply(background, arguments);\n  \
  };\n    this.getClearAlpha = function() {\n      return \
background.getClearAlpha();\n    };\n    this.setClearAlpha = function() {\n  \
    background.setClearAlpha.apply(background, arguments);\n    };\n    \
this.clear = function(color2 = true, depth3 = true, stencil2 = true) {\n      \
let bits = 0;\n      if (color2) {\n        let isIntegerFormat = false;\n    \
    if (_currentRenderTarget !== null) {\n          const targetFormat = \
_currentRenderTarget.texture.format;\n          isIntegerFormat = \
targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || \
targetFormat === RedIntegerFormat;\n        }\n        if (isIntegerFormat) \
{\n          const targetType = _currentRenderTarget.texture.type;\n          \
const isUnsignedType = targetType === UnsignedByteType || targetType === \
UnsignedIntType || targetType === UnsignedShortType || targetType === \
UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === \
UnsignedShort5551Type;\n          const clearColor = \
background.getClearColor();\n          const a2 = \
background.getClearAlpha();\n          const r = clearColor.r;\n          \
const g = clearColor.g;\n          const b = clearColor.b;\n          if \
(isUnsignedType) {\n            uintClearColor[0] = r;\n            \
uintClearColor[1] = g;\n            uintClearColor[2] = b;\n            \
uintClearColor[3] = a2;\n            _gl.clearBufferuiv(_gl.COLOR, 0, \
uintClearColor);\n          } else {\n            intClearColor[0] = r;\n     \
       intClearColor[1] = g;\n            intClearColor[2] = b;\n            \
intClearColor[3] = a2;\n            _gl.clearBufferiv(_gl.COLOR, 0, \
intClearColor);\n          }\n        } else {\n          bits |= \
_gl.COLOR_BUFFER_BIT;\n        }\n      }\n      if (depth3) {\n        bits \
|= _gl.DEPTH_BUFFER_BIT;\n      }\n      if (stencil2) {\n        bits |= \
_gl.STENCIL_BUFFER_BIT;\n        \
this.state.buffers.stencil.setMask(4294967295);\n      }\n      \
_gl.clear(bits);\n    };\n    this.clearColor = function() {\n      \
this.clear(true, false, false);\n    };\n    this.clearDepth = function() {\n \
     this.clear(false, true, false);\n    };\n    this.clearStencil = \
function() {\n      this.clear(false, false, true);\n    };\n    this.dispose \
= function() {\n      canvas.removeEventListener(\"webglcontextlost\", \
onContextLost, false);\n      \
canvas.removeEventListener(\"webglcontextrestored\", onContextRestore, \
false);\n      canvas.removeEventListener(\"webglcontextcreationerror\", \
onContextCreationError, false);\n      renderLists.dispose();\n      \
renderStates.dispose();\n      properties.dispose();\n      \
cubemaps.dispose();\n      cubeuvmaps.dispose();\n      objects.dispose();\n  \
    bindingStates.dispose();\n      uniformsGroups.dispose();\n      \
programCache.dispose();\n      xr.dispose();\n      \
xr.removeEventListener(\"sessionstart\", onXRSessionStart);\n      \
xr.removeEventListener(\"sessionend\", onXRSessionEnd);\n      \
animation.stop();\n    };\n    function onContextLost(event) {\n      \
event.preventDefault();\n      console.log(\"THREE.WebGLRenderer: Context \
Lost.\");\n      _isContextLost = true;\n    }\n    function \
onContextRestore() {\n      console.log(\"THREE.WebGLRenderer: Context \
Restored.\");\n      _isContextLost = false;\n      const infoAutoReset = \
info.autoReset;\n      const shadowMapEnabled = shadowMap.enabled;\n      \
const shadowMapAutoUpdate = shadowMap.autoUpdate;\n      const \
shadowMapNeedsUpdate = shadowMap.needsUpdate;\n      const shadowMapType = \
shadowMap.type;\n      initGLContext();\n      info.autoReset = \
infoAutoReset;\n      shadowMap.enabled = shadowMapEnabled;\n      \
shadowMap.autoUpdate = shadowMapAutoUpdate;\n      shadowMap.needsUpdate = \
shadowMapNeedsUpdate;\n      shadowMap.type = shadowMapType;\n    }\n    \
function onContextCreationError(event) {\n      \
console.error(\"THREE.WebGLRenderer: A WebGL context could not be created. \
Reason: \", event.statusMessage);\n    }\n    function \
onMaterialDispose(event) {\n      const material = event.target;\n      \
material.removeEventListener(\"dispose\", onMaterialDispose);\n      \
deallocateMaterial(material);\n    }\n    function \
deallocateMaterial(material) {\n      \
releaseMaterialProgramReferences(material);\n      \
properties.remove(material);\n    }\n    function \
releaseMaterialProgramReferences(material) {\n      const programs = \
properties.get(material).programs;\n      if (programs !== void 0) {\n        \
programs.forEach(function(program) {\n          \
programCache.releaseProgram(program);\n        });\n        if \
(material.isShaderMaterial) {\n          \
programCache.releaseShaderCache(material);\n        }\n      }\n    }\n    \
this.renderBufferDirect = function(camera3, scene3, geometry, material, \
object, group) {\n      if (scene3 === null) scene3 = _emptyScene;\n      \
const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n  \
    const program = setProgram(camera3, scene3, geometry, material, \
object);\n      state.setMaterial(material, frontFaceCW);\n      let index5 = \
geometry.index;\n      let rangeFactor = 1;\n      if (material.wireframe === \
true) {\n        index5 = geometries.getWireframeAttribute(geometry);\n       \
 if (index5 === void 0) return;\n        rangeFactor = 2;\n      }\n      \
const drawRange = geometry.drawRange;\n      const position = \
geometry.attributes.position;\n      let drawStart = drawRange.start * \
rangeFactor;\n      let drawEnd = (drawRange.start + drawRange.count) * \
rangeFactor;\n      if (group !== null) {\n        drawStart = \
Math.max(drawStart, group.start * rangeFactor);\n        drawEnd = \
Math.min(drawEnd, (group.start + group.count) * rangeFactor);\n      }\n      \
if (index5 !== null) {\n        drawStart = Math.max(drawStart, 0);\n        \
drawEnd = Math.min(drawEnd, index5.count);\n      } else if (position !== \
void 0 && position !== null) {\n        drawStart = Math.max(drawStart, 0);\n \
       drawEnd = Math.min(drawEnd, position.count);\n      }\n      const \
drawCount = drawEnd - drawStart;\n      if (drawCount < 0 || drawCount === \
Infinity) return;\n      bindingStates.setup(object, material, program, \
geometry, index5);\n      let attribute2;\n      let renderer3 = \
bufferRenderer;\n      if (index5 !== null) {\n        attribute2 = \
attributes.get(index5);\n        renderer3 = indexedBufferRenderer;\n        \
renderer3.setIndex(attribute2);\n      }\n      if (object.isMesh) {\n        \
if (material.wireframe === true) {\n          \
state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n    \
      renderer3.setMode(_gl.LINES);\n        } else {\n          \
renderer3.setMode(_gl.TRIANGLES);\n        }\n      } else if (object.isLine) \
{\n        let lineWidth = material.linewidth;\n        if (lineWidth === \
void 0) lineWidth = 1;\n        state.setLineWidth(lineWidth * \
getTargetPixelRatio());\n        if (object.isLineSegments) {\n          \
renderer3.setMode(_gl.LINES);\n        } else if (object.isLineLoop) {\n      \
    renderer3.setMode(_gl.LINE_LOOP);\n        } else {\n          \
renderer3.setMode(_gl.LINE_STRIP);\n        }\n      } else if \
(object.isPoints) {\n        renderer3.setMode(_gl.POINTS);\n      } else if \
(object.isSprite) {\n        renderer3.setMode(_gl.TRIANGLES);\n      }\n     \
 if (object.isBatchedMesh) {\n        if (object._multiDrawInstances !== \
null) {\n          \
renderer3.renderMultiDrawInstances(object._multiDrawStarts, \
object._multiDrawCounts, object._multiDrawCount, \
object._multiDrawInstances);\n        } else {\n          if \
(!extensions.get(\"WEBGL_multi_draw\")) {\n            const starts = \
object._multiDrawStarts;\n            const counts = \
object._multiDrawCounts;\n            const drawCount2 = \
object._multiDrawCount;\n            const bytesPerElement = index5 ? \
attributes.get(index5).bytesPerElement : 1;\n            const uniforms = \
properties.get(material).currentProgram.getUniforms();\n            for (let \
i = 0; i < drawCount2; i++) {\n              uniforms.setValue(_gl, \
\"_gl_DrawID\", i);\n              renderer3.render(starts[i] / \
bytesPerElement, counts[i]);\n            }\n          } else {\n            \
renderer3.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, \
object._multiDrawCount);\n          }\n        }\n      } else if \
(object.isInstancedMesh) {\n        renderer3.renderInstances(drawStart, \
drawCount, object.count);\n      } else if \
(geometry.isInstancedBufferGeometry) {\n        const maxInstanceCount = \
geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : \
Infinity;\n        const instanceCount = Math.min(geometry.instanceCount, \
maxInstanceCount);\n        renderer3.renderInstances(drawStart, drawCount, \
instanceCount);\n      } else {\n        renderer3.render(drawStart, \
drawCount);\n      }\n    };\n    function prepareMaterial(material, scene3, \
object) {\n      if (material.transparent === true && material.side === \
DoubleSide && material.forceSinglePass === false) {\n        material.side = \
BackSide;\n        material.needsUpdate = true;\n        getProgram(material, \
scene3, object);\n        material.side = FrontSide;\n        \
material.needsUpdate = true;\n        getProgram(material, scene3, object);\n \
       material.side = DoubleSide;\n      } else {\n        \
getProgram(material, scene3, object);\n      }\n    }\n    this.compile = \
function(scene3, camera3, targetScene = null) {\n      if (targetScene === \
null) targetScene = scene3;\n      currentRenderState = \
renderStates.get(targetScene);\n      currentRenderState.init(camera3);\n     \
 renderStateStack.push(currentRenderState);\n      \
targetScene.traverseVisible(function(object) {\n        if (object.isLight && \
object.layers.test(camera3.layers)) {\n          \
currentRenderState.pushLight(object);\n          if (object.castShadow) {\n   \
         currentRenderState.pushShadow(object);\n          }\n        }\n     \
 });\n      if (scene3 !== targetScene) {\n        \
scene3.traverseVisible(function(object) {\n          if (object.isLight && \
object.layers.test(camera3.layers)) {\n            \
currentRenderState.pushLight(object);\n            if (object.castShadow) {\n \
             currentRenderState.pushShadow(object);\n            }\n          \
}\n        });\n      }\n      currentRenderState.setupLights();\n      const \
materials2 = /* @__PURE__ */ new Set();\n      \
scene3.traverse(function(object) {\n        if (!(object.isMesh || \
object.isPoints || object.isLine || object.isSprite)) {\n          return;\n  \
      }\n        const material = object.material;\n        if (material) {\n \
         if (Array.isArray(material)) {\n            for (let i = 0; i < \
material.length; i++) {\n              const material2 = material[i];\n       \
       prepareMaterial(material2, targetScene, object);\n              \
materials2.add(material2);\n            }\n          } else {\n            \
prepareMaterial(material, targetScene, object);\n            \
materials2.add(material);\n          }\n        }\n      });\n      \
renderStateStack.pop();\n      currentRenderState = null;\n      return \
materials2;\n    };\n    this.compileAsync = function(scene3, camera3, \
targetScene = null) {\n      const materials2 = this.compile(scene3, camera3, \
targetScene);\n      return new Promise((resolve) => {\n        function \
checkMaterialsReady() {\n          materials2.forEach(function(material) {\n  \
          const materialProperties = properties.get(material);\n            \
const program = materialProperties.currentProgram;\n            if \
(program.isReady()) {\n              materials2.delete(material);\n           \
 }\n          });\n          if (materials2.size === 0) {\n            \
resolve(scene3);\n            return;\n          }\n          \
setTimeout(checkMaterialsReady, 10);\n        }\n        if \
(extensions.get(\"KHR_parallel_shader_compile\") !== null) {\n          \
checkMaterialsReady();\n        } else {\n          \
setTimeout(checkMaterialsReady, 10);\n        }\n      });\n    };\n    let \
onAnimationFrameCallback = null;\n    function onAnimationFrame(time) {\n     \
 if (onAnimationFrameCallback) onAnimationFrameCallback(time);\n    }\n    \
function onXRSessionStart() {\n      animation.stop();\n    }\n    function \
onXRSessionEnd() {\n      animation.start();\n    }\n    const animation = \
new WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n    \
if (typeof self !== \"undefined\") animation.setContext(self);\n    \
this.setAnimationLoop = function(callback) {\n      onAnimationFrameCallback \
= callback;\n      xr.setAnimationLoop(callback);\n      callback === null ? \
animation.stop() : animation.start();\n    };\n    \
xr.addEventListener(\"sessionstart\", onXRSessionStart);\n    \
xr.addEventListener(\"sessionend\", onXRSessionEnd);\n    this.render = \
function(scene3, camera3) {\n      if (camera3 !== void 0 && camera3.isCamera \
!== true) {\n        console.error(\"THREE.WebGLRenderer.render: camera is \
not an instance of THREE.Camera.\");\n        return;\n      }\n      if \
(_isContextLost === true) return;\n      if (scene3.matrixWorldAutoUpdate === \
true) scene3.updateMatrixWorld();\n      if (camera3.parent === null && \
camera3.matrixWorldAutoUpdate === true) camera3.updateMatrixWorld();\n      \
if (xr.enabled === true && xr.isPresenting === true) {\n        if \
(xr.cameraAutoUpdate === true) xr.updateCamera(camera3);\n        camera3 = \
xr.getCamera();\n      }\n      if (scene3.isScene === true) \
scene3.onBeforeRender(_this, scene3, camera3, _currentRenderTarget);\n      \
currentRenderState = renderStates.get(scene3, renderStateStack.length);\n     \
 currentRenderState.init(camera3);\n      \
renderStateStack.push(currentRenderState);\n      \
_projScreenMatrix2.multiplyMatrices(camera3.projectionMatrix, \
camera3.matrixWorldInverse);\n      \
_frustum2.setFromProjectionMatrix(_projScreenMatrix2);\n      \
_localClippingEnabled = this.localClippingEnabled;\n      _clippingEnabled = \
clipping2.init(this.clippingPlanes, _localClippingEnabled);\n      \
currentRenderList = renderLists.get(scene3, renderListStack.length);\n      \
currentRenderList.init();\n      renderListStack.push(currentRenderList);\n   \
   if (xr.enabled === true && xr.isPresenting === true) {\n        const \
depthSensingMesh = _this.xr.getDepthSensingMesh();\n        if \
(depthSensingMesh !== null) {\n          projectObject(depthSensingMesh, \
camera3, -Infinity, _this.sortObjects);\n        }\n      }\n      \
projectObject(scene3, camera3, 0, _this.sortObjects);\n      \
currentRenderList.finish();\n      if (_this.sortObjects === true) {\n        \
currentRenderList.sort(_opaqueSort, _transparentSort);\n      }\n      \
_renderBackground = xr.enabled === false || xr.isPresenting === false || \
xr.hasDepthSensing() === false;\n      if (_renderBackground) {\n        \
background.addToRenderList(currentRenderList, scene3);\n      }\n      \
this.info.render.frame++;\n      if (_clippingEnabled === true) \
clipping2.beginShadows();\n      const shadowsArray = \
currentRenderState.state.shadowsArray;\n      shadowMap.render(shadowsArray, \
scene3, camera3);\n      if (_clippingEnabled === true) \
clipping2.endShadows();\n      if (this.info.autoReset === true) \
this.info.reset();\n      const opaqueObjects = currentRenderList.opaque;\n   \
   const transmissiveObjects = currentRenderList.transmissive;\n      \
currentRenderState.setupLights();\n      if (camera3.isArrayCamera) {\n       \
 const cameras = camera3.cameras;\n        if (transmissiveObjects.length > \
0) {\n          for (let i = 0, l = cameras.length; i < l; i++) {\n           \
 const camera22 = cameras[i];\n            \
renderTransmissionPass(opaqueObjects, transmissiveObjects, scene3, \
camera22);\n          }\n        }\n        if (_renderBackground) \
background.render(scene3);\n        for (let i = 0, l = cameras.length; i < \
l; i++) {\n          const camera22 = cameras[i];\n          \
renderScene(currentRenderList, scene3, camera22, camera22.viewport);\n        \
}\n      } else {\n        if (transmissiveObjects.length > 0) \
renderTransmissionPass(opaqueObjects, transmissiveObjects, scene3, \
camera3);\n        if (_renderBackground) background.render(scene3);\n        \
renderScene(currentRenderList, scene3, camera3);\n      }\n      if \
(_currentRenderTarget !== null) {\n        \
textures.updateMultisampleRenderTarget(_currentRenderTarget);\n        \
textures.updateRenderTargetMipmap(_currentRenderTarget);\n      }\n      if \
(scene3.isScene === true) scene3.onAfterRender(_this, scene3, camera3);\n     \
 bindingStates.resetDefaultState();\n      _currentMaterialId = -1;\n      \
_currentCamera = null;\n      renderStateStack.pop();\n      if \
(renderStateStack.length > 0) {\n        currentRenderState = \
renderStateStack[renderStateStack.length - 1];\n        if (_clippingEnabled \
=== true) clipping2.setGlobalState(_this.clippingPlanes, \
currentRenderState.state.camera);\n      } else {\n        currentRenderState \
= null;\n      }\n      renderListStack.pop();\n      if \
(renderListStack.length > 0) {\n        currentRenderList = \
renderListStack[renderListStack.length - 1];\n      } else {\n        \
currentRenderList = null;\n      }\n    };\n    function \
projectObject(object, camera3, groupOrder, sortObjects) {\n      if \
(object.visible === false) return;\n      const visible = \
object.layers.test(camera3.layers);\n      if (visible) {\n        if \
(object.isGroup) {\n          groupOrder = object.renderOrder;\n        } \
else if (object.isLOD) {\n          if (object.autoUpdate === true) \
object.update(camera3);\n        } else if (object.isLight) {\n          \
currentRenderState.pushLight(object);\n          if (object.castShadow) {\n   \
         currentRenderState.pushShadow(object);\n          }\n        } else \
if (object.isSprite) {\n          if (!object.frustumCulled || \
_frustum2.intersectsSprite(object)) {\n            if (sortObjects) {\n       \
       \
_vector42.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenM\
atrix2);\n            }\n            const geometry = \
objects.update(object);\n            const material = object.material;\n      \
      if (material.visible) {\n              currentRenderList.push(object, \
geometry, material, groupOrder, _vector42.z, null);\n            }\n          \
}\n        } else if (object.isMesh || object.isLine || object.isPoints) {\n  \
        if (!object.frustumCulled || _frustum2.intersectsObject(object)) {\n  \
          const geometry = objects.update(object);\n            const \
material = object.material;\n            if (sortObjects) {\n              if \
(object.boundingSphere !== void 0) {\n                if \
(object.boundingSphere === null) object.computeBoundingSphere();\n            \
    _vector42.copy(object.boundingSphere.center);\n              } else {\n   \
             if (geometry.boundingSphere === null) \
geometry.computeBoundingSphere();\n                \
_vector42.copy(geometry.boundingSphere.center);\n              }\n            \
  \
_vector42.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);\
\n            }\n            if (Array.isArray(material)) {\n              \
const groups = geometry.groups;\n              for (let i = 0, l = \
groups.length; i < l; i++) {\n                const group = groups[i];\n      \
          const groupMaterial = material[group.materialIndex];\n              \
  if (groupMaterial && groupMaterial.visible) {\n                  \
currentRenderList.push(object, geometry, groupMaterial, groupOrder, \
_vector42.z, group);\n                }\n              }\n            } else \
if (material.visible) {\n              currentRenderList.push(object, \
geometry, material, groupOrder, _vector42.z, null);\n            }\n          \
}\n        }\n      }\n      const children = object.children;\n      for \
(let i = 0, l = children.length; i < l; i++) {\n        \
projectObject(children[i], camera3, groupOrder, sortObjects);\n      }\n    \
}\n    function renderScene(currentRenderList2, scene3, camera3, viewport2) \
{\n      const opaqueObjects = currentRenderList2.opaque;\n      const \
transmissiveObjects = currentRenderList2.transmissive;\n      const \
transparentObjects = currentRenderList2.transparent;\n      \
currentRenderState.setupLightsView(camera3);\n      if (_clippingEnabled === \
true) clipping2.setGlobalState(_this.clippingPlanes, camera3);\n      if \
(viewport2) state.viewport(_currentViewport.copy(viewport2));\n      if \
(opaqueObjects.length > 0) renderObjects(opaqueObjects, scene3, camera3);\n   \
   if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, \
scene3, camera3);\n      if (transparentObjects.length > 0) \
renderObjects(transparentObjects, scene3, camera3);\n      \
state.buffers.depth.setTest(true);\n      \
state.buffers.depth.setMask(true);\n      \
state.buffers.color.setMask(true);\n      state.setPolygonOffset(false);\n    \
}\n    function renderTransmissionPass(opaqueObjects, transmissiveObjects, \
scene3, camera3) {\n      const overrideMaterial = scene3.isScene === true ? \
scene3.overrideMaterial : null;\n      if (overrideMaterial !== null) {\n     \
   return;\n      }\n      if \
(currentRenderState.state.transmissionRenderTarget[camera3.id] === void 0) \
{\n        currentRenderState.state.transmissionRenderTarget[camera3.id] = \
new WebGLRenderTarget(1, 1, {\n          generateMipmaps: true,\n          \
type: extensions.has(\"EXT_color_buffer_half_float\") || \
extensions.has(\"EXT_color_buffer_float\") ? HalfFloatType : \
UnsignedByteType,\n          minFilter: LinearMipmapLinearFilter,\n          \
samples: 4,\n          stencilBuffer: stencil,\n          resolveDepthBuffer: \
false,\n          resolveStencilBuffer: false,\n          colorSpace: \
ColorManagement.workingColorSpace\n        });\n      }\n      const \
transmissionRenderTarget = \
currentRenderState.state.transmissionRenderTarget[camera3.id];\n      const \
activeViewport = camera3.viewport || _currentViewport;\n      \
transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);\n      \
const currentRenderTarget = _this.getRenderTarget();\n      \
_this.setRenderTarget(transmissionRenderTarget);\n      \
_this.getClearColor(_currentClearColor);\n      _currentClearAlpha = \
_this.getClearAlpha();\n      if (_currentClearAlpha < 1) \
_this.setClearColor(16777215, 0.5);\n      _this.clear();\n      if \
(_renderBackground) background.render(scene3);\n      const \
currentToneMapping = _this.toneMapping;\n      _this.toneMapping = \
NoToneMapping;\n      const currentCameraViewport = camera3.viewport;\n      \
if (camera3.viewport !== void 0) camera3.viewport = void 0;\n      \
currentRenderState.setupLightsView(camera3);\n      if (_clippingEnabled === \
true) clipping2.setGlobalState(_this.clippingPlanes, camera3);\n      \
renderObjects(opaqueObjects, scene3, camera3);\n      \
textures.updateMultisampleRenderTarget(transmissionRenderTarget);\n      \
textures.updateRenderTargetMipmap(transmissionRenderTarget);\n      if \
(extensions.has(\"WEBGL_multisampled_render_to_texture\") === false) {\n      \
  let renderTargetNeedsUpdate = false;\n        for (let i = 0, l = \
transmissiveObjects.length; i < l; i++) {\n          const renderItem = \
transmissiveObjects[i];\n          const object = renderItem.object;\n        \
  const geometry = renderItem.geometry;\n          const material = \
renderItem.material;\n          const group = renderItem.group;\n          if \
(material.side === DoubleSide && object.layers.test(camera3.layers)) {\n      \
      const currentSide = material.side;\n            material.side = \
BackSide;\n            material.needsUpdate = true;\n            \
renderObject(object, scene3, camera3, geometry, material, group);\n           \
 material.side = currentSide;\n            material.needsUpdate = true;\n     \
       renderTargetNeedsUpdate = true;\n          }\n        }\n        if \
(renderTargetNeedsUpdate === true) {\n          \
textures.updateMultisampleRenderTarget(transmissionRenderTarget);\n          \
textures.updateRenderTargetMipmap(transmissionRenderTarget);\n        }\n     \
 }\n      _this.setRenderTarget(currentRenderTarget);\n      \
_this.setClearColor(_currentClearColor, _currentClearAlpha);\n      if \
(currentCameraViewport !== void 0) camera3.viewport = \
currentCameraViewport;\n      _this.toneMapping = currentToneMapping;\n    \
}\n    function renderObjects(renderList, scene3, camera3) {\n      const \
overrideMaterial = scene3.isScene === true ? scene3.overrideMaterial : \
null;\n      for (let i = 0, l = renderList.length; i < l; i++) {\n        \
const renderItem = renderList[i];\n        const object = \
renderItem.object;\n        const geometry = renderItem.geometry;\n        \
const material = overrideMaterial === null ? renderItem.material : \
overrideMaterial;\n        const group = renderItem.group;\n        if \
(object.layers.test(camera3.layers)) {\n          renderObject(object, \
scene3, camera3, geometry, material, group);\n        }\n      }\n    }\n    \
function renderObject(object, scene3, camera3, geometry, material, group) {\n \
     object.onBeforeRender(_this, scene3, camera3, geometry, material, \
group);\n      \
object.modelViewMatrix.multiplyMatrices(camera3.matrixWorldInverse, \
object.matrixWorld);\n      \
object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n      \
material.onBeforeRender(_this, scene3, camera3, geometry, object, group);\n   \
   if (material.transparent === true && material.side === DoubleSide && \
material.forceSinglePass === false) {\n        material.side = BackSide;\n    \
    material.needsUpdate = true;\n        _this.renderBufferDirect(camera3, \
scene3, geometry, material, object, group);\n        material.side = \
FrontSide;\n        material.needsUpdate = true;\n        \
_this.renderBufferDirect(camera3, scene3, geometry, material, object, \
group);\n        material.side = DoubleSide;\n      } else {\n        \
_this.renderBufferDirect(camera3, scene3, geometry, material, object, \
group);\n      }\n      object.onAfterRender(_this, scene3, camera3, \
geometry, material, group);\n    }\n    function getProgram(material, scene3, \
object) {\n      if (scene3.isScene !== true) scene3 = _emptyScene;\n      \
const materialProperties = properties.get(material);\n      const lights = \
currentRenderState.state.lights;\n      const shadowsArray = \
currentRenderState.state.shadowsArray;\n      const lightsStateVersion = \
lights.state.version;\n      const parameters2 = \
programCache.getParameters(material, lights.state, shadowsArray, scene3, \
object);\n      const programCacheKey = \
programCache.getProgramCacheKey(parameters2);\n      let programs = \
materialProperties.programs;\n      materialProperties.environment = \
material.isMeshStandardMaterial ? scene3.environment : null;\n      \
materialProperties.fog = scene3.fog;\n      materialProperties.envMap = \
(material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap \
|| materialProperties.environment);\n      materialProperties.envMapRotation \
= materialProperties.environment !== null && material.envMap === null ? \
scene3.environmentRotation : material.envMapRotation;\n      if (programs === \
void 0) {\n        material.addEventListener(\"dispose\", \
onMaterialDispose);\n        programs = /* @__PURE__ */ new Map();\n        \
materialProperties.programs = programs;\n      }\n      let program = \
programs.get(programCacheKey);\n      if (program !== void 0) {\n        if \
(materialProperties.currentProgram === program && \
materialProperties.lightsStateVersion === lightsStateVersion) {\n          \
updateCommonMaterialProperties(material, parameters2);\n          return \
program;\n        }\n      } else {\n        parameters2.uniforms = \
programCache.getUniforms(material);\n        \
material.onBeforeCompile(parameters2, _this);\n        program = \
programCache.acquireProgram(parameters2, programCacheKey);\n        \
programs.set(programCacheKey, program);\n        materialProperties.uniforms \
= parameters2.uniforms;\n      }\n      const uniforms = \
materialProperties.uniforms;\n      if (!material.isShaderMaterial && \
!material.isRawShaderMaterial || material.clipping === true) {\n        \
uniforms.clippingPlanes = clipping2.uniform;\n      }\n      \
updateCommonMaterialProperties(material, parameters2);\n      \
materialProperties.needsLights = materialNeedsLights(material);\n      \
materialProperties.lightsStateVersion = lightsStateVersion;\n      if \
(materialProperties.needsLights) {\n        uniforms.ambientLightColor.value \
= lights.state.ambient;\n        uniforms.lightProbe.value = \
lights.state.probe;\n        uniforms.directionalLights.value = \
lights.state.directional;\n        uniforms.directionalLightShadows.value = \
lights.state.directionalShadow;\n        uniforms.spotLights.value = \
lights.state.spot;\n        uniforms.spotLightShadows.value = \
lights.state.spotShadow;\n        uniforms.rectAreaLights.value = \
lights.state.rectArea;\n        uniforms.ltc_1.value = \
lights.state.rectAreaLTC1;\n        uniforms.ltc_2.value = \
lights.state.rectAreaLTC2;\n        uniforms.pointLights.value = \
lights.state.point;\n        uniforms.pointLightShadows.value = \
lights.state.pointShadow;\n        uniforms.hemisphereLights.value = \
lights.state.hemi;\n        uniforms.directionalShadowMap.value = \
lights.state.directionalShadowMap;\n        \
uniforms.directionalShadowMatrix.value = \
lights.state.directionalShadowMatrix;\n        uniforms.spotShadowMap.value = \
lights.state.spotShadowMap;\n        uniforms.spotLightMatrix.value = \
lights.state.spotLightMatrix;\n        uniforms.spotLightMap.value = \
lights.state.spotLightMap;\n        uniforms.pointShadowMap.value = \
lights.state.pointShadowMap;\n        uniforms.pointShadowMatrix.value = \
lights.state.pointShadowMatrix;\n      }\n      \
materialProperties.currentProgram = program;\n      \
materialProperties.uniformsList = null;\n      return program;\n    }\n    \
function getUniformList(materialProperties) {\n      if \
(materialProperties.uniformsList === null) {\n        const progUniforms = \
materialProperties.currentProgram.getUniforms();\n        \
materialProperties.uniformsList = \
WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);\n  \
    }\n      return materialProperties.uniformsList;\n    }\n    function \
updateCommonMaterialProperties(material, parameters2) {\n      const \
materialProperties = properties.get(material);\n      \
materialProperties.outputColorSpace = parameters2.outputColorSpace;\n      \
materialProperties.batching = parameters2.batching;\n      \
materialProperties.batchingColor = parameters2.batchingColor;\n      \
materialProperties.instancing = parameters2.instancing;\n      \
materialProperties.instancingColor = parameters2.instancingColor;\n      \
materialProperties.instancingMorph = parameters2.instancingMorph;\n      \
materialProperties.skinning = parameters2.skinning;\n      \
materialProperties.morphTargets = parameters2.morphTargets;\n      \
materialProperties.morphNormals = parameters2.morphNormals;\n      \
materialProperties.morphColors = parameters2.morphColors;\n      \
materialProperties.morphTargetsCount = parameters2.morphTargetsCount;\n      \
materialProperties.numClippingPlanes = parameters2.numClippingPlanes;\n      \
materialProperties.numIntersection = parameters2.numClipIntersection;\n      \
materialProperties.vertexAlphas = parameters2.vertexAlphas;\n      \
materialProperties.vertexTangents = parameters2.vertexTangents;\n      \
materialProperties.toneMapping = parameters2.toneMapping;\n    }\n    \
function setProgram(camera3, scene3, geometry, material, object) {\n      if \
(scene3.isScene !== true) scene3 = _emptyScene;\n      \
textures.resetTextureUnits();\n      const fog = scene3.fog;\n      const \
environment = material.isMeshStandardMaterial ? scene3.environment : null;\n  \
    const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace \
: _currentRenderTarget.isXRRenderTarget === true ? \
_currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;\n      const \
envMap = (material.isMeshStandardMaterial ? cubeuvmaps : \
cubemaps).get(material.envMap || environment);\n      const vertexAlphas = \
material.vertexColors === true && !!geometry.attributes.color && \
geometry.attributes.color.itemSize === 4;\n      const vertexTangents = \
!!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy \
> 0);\n      const morphTargets = !!geometry.morphAttributes.position;\n      \
const morphNormals = !!geometry.morphAttributes.normal;\n      const \
morphColors = !!geometry.morphAttributes.color;\n      let toneMapping2 = \
NoToneMapping;\n      if (material.toneMapped) {\n        if \
(_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === \
true) {\n          toneMapping2 = _this.toneMapping;\n        }\n      }\n    \
  const morphAttribute = geometry.morphAttributes.position || \
geometry.morphAttributes.normal || geometry.morphAttributes.color;\n      \
const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : \
0;\n      const materialProperties = properties.get(material);\n      const \
lights = currentRenderState.state.lights;\n      if (_clippingEnabled === \
true) {\n        if (_localClippingEnabled === true || camera3 !== \
_currentCamera) {\n          const useCache = camera3 === _currentCamera && \
material.id === _currentMaterialId;\n          clipping2.setState(material, \
camera3, useCache);\n        }\n      }\n      let needsProgramChange = \
false;\n      if (material.version === materialProperties.__version) {\n      \
  if (materialProperties.needsLights && materialProperties.lightsStateVersion \
!== lights.state.version) {\n          needsProgramChange = true;\n        } \
else if (materialProperties.outputColorSpace !== colorSpace) {\n          \
needsProgramChange = true;\n        } else if (object.isBatchedMesh && \
materialProperties.batching === false) {\n          needsProgramChange = \
true;\n        } else if (!object.isBatchedMesh && \
materialProperties.batching === true) {\n          needsProgramChange = \
true;\n        } else if (object.isBatchedMesh && \
materialProperties.batchingColor === true && object.colorTexture === null) \
{\n          needsProgramChange = true;\n        } else if \
(object.isBatchedMesh && materialProperties.batchingColor === false && \
object.colorTexture !== null) {\n          needsProgramChange = true;\n       \
 } else if (object.isInstancedMesh && materialProperties.instancing === \
false) {\n          needsProgramChange = true;\n        } else if \
(!object.isInstancedMesh && materialProperties.instancing === true) {\n       \
   needsProgramChange = true;\n        } else if (object.isSkinnedMesh && \
materialProperties.skinning === false) {\n          needsProgramChange = \
true;\n        } else if (!object.isSkinnedMesh && \
materialProperties.skinning === true) {\n          needsProgramChange = \
true;\n        } else if (object.isInstancedMesh && \
materialProperties.instancingColor === true && object.instanceColor === null) \
{\n          needsProgramChange = true;\n        } else if \
(object.isInstancedMesh && materialProperties.instancingColor === false && \
object.instanceColor !== null) {\n          needsProgramChange = true;\n      \
  } else if (object.isInstancedMesh && materialProperties.instancingMorph === \
true && object.morphTexture === null) {\n          needsProgramChange = \
true;\n        } else if (object.isInstancedMesh && \
materialProperties.instancingMorph === false && object.morphTexture !== null) \
{\n          needsProgramChange = true;\n        } else if \
(materialProperties.envMap !== envMap) {\n          needsProgramChange = \
true;\n        } else if (material.fog === true && materialProperties.fog !== \
fog) {\n          needsProgramChange = true;\n        } else if \
(materialProperties.numClippingPlanes !== void 0 && \
(materialProperties.numClippingPlanes !== clipping2.numPlanes || \
materialProperties.numIntersection !== clipping2.numIntersection)) {\n        \
  needsProgramChange = true;\n        } else if \
(materialProperties.vertexAlphas !== vertexAlphas) {\n          \
needsProgramChange = true;\n        } else if \
(materialProperties.vertexTangents !== vertexTangents) {\n          \
needsProgramChange = true;\n        } else if \
(materialProperties.morphTargets !== morphTargets) {\n          \
needsProgramChange = true;\n        } else if \
(materialProperties.morphNormals !== morphNormals) {\n          \
needsProgramChange = true;\n        } else if (materialProperties.morphColors \
!== morphColors) {\n          needsProgramChange = true;\n        } else if \
(materialProperties.toneMapping !== toneMapping2) {\n          \
needsProgramChange = true;\n        } else if \
(materialProperties.morphTargetsCount !== morphTargetsCount) {\n          \
needsProgramChange = true;\n        }\n      } else {\n        \
needsProgramChange = true;\n        materialProperties.__version = \
material.version;\n      }\n      let program = \
materialProperties.currentProgram;\n      if (needsProgramChange === true) \
{\n        program = getProgram(material, scene3, object);\n      }\n      \
let refreshProgram = false;\n      let refreshMaterial = false;\n      let \
refreshLights = false;\n      const p_uniforms = program.getUniforms(), \
m_uniforms = materialProperties.uniforms;\n      if \
(state.useProgram(program.program)) {\n        refreshProgram = true;\n       \
 refreshMaterial = true;\n        refreshLights = true;\n      }\n      if \
(material.id !== _currentMaterialId) {\n        _currentMaterialId = \
material.id;\n        refreshMaterial = true;\n      }\n      if \
(refreshProgram || _currentCamera !== camera3) {\n        const \
reverseDepthBuffer2 = state.buffers.depth.getReversed();\n        if \
(reverseDepthBuffer2) {\n          \
_currentProjectionMatrix.copy(camera3.projectionMatrix);\n          \
toNormalizedProjectionMatrix(_currentProjectionMatrix);\n          \
toReversedProjectionMatrix(_currentProjectionMatrix);\n          \
p_uniforms.setValue(_gl, \"projectionMatrix\", _currentProjectionMatrix);\n   \
     } else {\n          p_uniforms.setValue(_gl, \"projectionMatrix\", \
camera3.projectionMatrix);\n        }\n        p_uniforms.setValue(_gl, \
\"viewMatrix\", camera3.matrixWorldInverse);\n        const uCamPos = \
p_uniforms.map.cameraPosition;\n        if (uCamPos !== void 0) {\n          \
uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera3.matrixWorld));\n \
       }\n        if (capabilities.logarithmicDepthBuffer) {\n          \
p_uniforms.setValue(\n            _gl,\n            \"logDepthBufFC\",\n      \
      2 / (Math.log(camera3.far + 1) / Math.LN2)\n          );\n        }\n   \
     if (material.isMeshPhongMaterial || material.isMeshToonMaterial || \
material.isMeshLambertMaterial || material.isMeshBasicMaterial || \
material.isMeshStandardMaterial || material.isShaderMaterial) {\n          \
p_uniforms.setValue(_gl, \"isOrthographic\", camera3.isOrthographicCamera === \
true);\n        }\n        if (_currentCamera !== camera3) {\n          \
_currentCamera = camera3;\n          refreshMaterial = true;\n          \
refreshLights = true;\n        }\n      }\n      if (object.isSkinnedMesh) \
{\n        p_uniforms.setOptional(_gl, object, \"bindMatrix\");\n        \
p_uniforms.setOptional(_gl, object, \"bindMatrixInverse\");\n        const \
skeleton = object.skeleton;\n        if (skeleton) {\n          if \
(skeleton.boneTexture === null) skeleton.computeBoneTexture();\n          \
p_uniforms.setValue(_gl, \"boneTexture\", skeleton.boneTexture, textures);\n  \
      }\n      }\n      if (object.isBatchedMesh) {\n        \
p_uniforms.setOptional(_gl, object, \"batchingTexture\");\n        \
p_uniforms.setValue(_gl, \"batchingTexture\", object._matricesTexture, \
textures);\n        p_uniforms.setOptional(_gl, object, \
\"batchingIdTexture\");\n        p_uniforms.setValue(_gl, \
\"batchingIdTexture\", object._indirectTexture, textures);\n        \
p_uniforms.setOptional(_gl, object, \"batchingColorTexture\");\n        if \
(object._colorsTexture !== null) {\n          p_uniforms.setValue(_gl, \
\"batchingColorTexture\", object._colorsTexture, textures);\n        }\n      \
}\n      const morphAttributes = geometry.morphAttributes;\n      if \
(morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || \
morphAttributes.color !== void 0) {\n        morphtargets.update(object, \
geometry, program);\n      }\n      if (refreshMaterial || \
materialProperties.receiveShadow !== object.receiveShadow) {\n        \
materialProperties.receiveShadow = object.receiveShadow;\n        \
p_uniforms.setValue(_gl, \"receiveShadow\", object.receiveShadow);\n      }\n \
     if (material.isMeshGouraudMaterial && material.envMap !== null) {\n      \
  m_uniforms.envMap.value = envMap;\n        m_uniforms.flipEnvMap.value = \
envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;\n    \
  }\n      if (material.isMeshStandardMaterial && material.envMap === null && \
scene3.environment !== null) {\n        m_uniforms.envMapIntensity.value = \
scene3.environmentIntensity;\n      }\n      if (refreshMaterial) {\n        \
p_uniforms.setValue(_gl, \"toneMappingExposure\", \
_this.toneMappingExposure);\n        if (materialProperties.needsLights) {\n  \
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n        \
}\n        if (fog && material.fog === true) {\n          \
materials.refreshFogUniforms(m_uniforms, fog);\n        }\n        \
materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, \
currentRenderState.state.transmissionRenderTarget[camera3.id]);\n        \
WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, \
textures);\n      }\n      if (material.isShaderMaterial && \
material.uniformsNeedUpdate === true) {\n        WebGLUniforms.upload(_gl, \
getUniformList(materialProperties), m_uniforms, textures);\n        \
material.uniformsNeedUpdate = false;\n      }\n      if \
(material.isSpriteMaterial) {\n        p_uniforms.setValue(_gl, \"center\", \
object.center);\n      }\n      p_uniforms.setValue(_gl, \"modelViewMatrix\", \
object.modelViewMatrix);\n      p_uniforms.setValue(_gl, \"normalMatrix\", \
object.normalMatrix);\n      p_uniforms.setValue(_gl, \"modelMatrix\", \
object.matrixWorld);\n      if (material.isShaderMaterial || \
material.isRawShaderMaterial) {\n        const groups = \
material.uniformsGroups;\n        for (let i = 0, l = groups.length; i < l; \
i++) {\n          const group = groups[i];\n          \
uniformsGroups.update(group, program);\n          uniformsGroups.bind(group, \
program);\n        }\n      }\n      return program;\n    }\n    function \
markUniformsLightsNeedsUpdate(uniforms, value) {\n      \
uniforms.ambientLightColor.needsUpdate = value;\n      \
uniforms.lightProbe.needsUpdate = value;\n      \
uniforms.directionalLights.needsUpdate = value;\n      \
uniforms.directionalLightShadows.needsUpdate = value;\n      \
uniforms.pointLights.needsUpdate = value;\n      \
uniforms.pointLightShadows.needsUpdate = value;\n      \
uniforms.spotLights.needsUpdate = value;\n      \
uniforms.spotLightShadows.needsUpdate = value;\n      \
uniforms.rectAreaLights.needsUpdate = value;\n      \
uniforms.hemisphereLights.needsUpdate = value;\n    }\n    function \
materialNeedsLights(material) {\n      return material.isMeshLambertMaterial \
|| material.isMeshToonMaterial || material.isMeshPhongMaterial || \
material.isMeshStandardMaterial || material.isShadowMaterial || \
material.isShaderMaterial && material.lights === true;\n    }\n    \
this.getActiveCubeFace = function() {\n      return _currentActiveCubeFace;\n \
   };\n    this.getActiveMipmapLevel = function() {\n      return \
_currentActiveMipmapLevel;\n    };\n    this.getRenderTarget = function() {\n \
     return _currentRenderTarget;\n    };\n    this.setRenderTargetTextures = \
function(renderTarget, colorTexture, depthTexture) {\n      \
properties.get(renderTarget.texture).__webglTexture = colorTexture;\n      \
properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;\n    \
  const renderTargetProperties = properties.get(renderTarget);\n      \
renderTargetProperties.__hasExternalTextures = true;\n      \
renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;\n \
     if (!renderTargetProperties.__autoAllocateDepthBuffer) {\n        if \
(extensions.has(\"WEBGL_multisampled_render_to_texture\") === true) {\n       \
   console.warn(\"THREE.WebGLRenderer: Render-to-texture extension was \
disabled because an external texture was provided\");\n          \
renderTargetProperties.__useRenderToTexture = false;\n        }\n      }\n    \
};\n    this.setRenderTargetFramebuffer = function(renderTarget, \
defaultFramebuffer) {\n      const renderTargetProperties = \
properties.get(renderTarget);\n      \
renderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n      \
renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void \
0;\n    };\n    this.setRenderTarget = function(renderTarget, activeCubeFace \
= 0, activeMipmapLevel = 0) {\n      _currentRenderTarget = renderTarget;\n   \
   _currentActiveCubeFace = activeCubeFace;\n      _currentActiveMipmapLevel \
= activeMipmapLevel;\n      let useDefaultFramebuffer = true;\n      let \
framebuffer = null;\n      let isCube = false;\n      let isRenderTarget3D = \
false;\n      if (renderTarget) {\n        const renderTargetProperties = \
properties.get(renderTarget);\n        if \
(renderTargetProperties.__useDefaultFramebuffer !== void 0) {\n          \
state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n          \
useDefaultFramebuffer = false;\n        } else if \
(renderTargetProperties.__webglFramebuffer === void 0) {\n          \
textures.setupRenderTarget(renderTarget);\n        } else if \
(renderTargetProperties.__hasExternalTextures) {\n          \
textures.rebindTextures(renderTarget, \
properties.get(renderTarget.texture).__webglTexture, \
properties.get(renderTarget.depthTexture).__webglTexture);\n        } else if \
(renderTarget.depthBuffer) {\n          const depthTexture = \
renderTarget.depthTexture;\n          if \
(renderTargetProperties.__boundDepthTexture !== depthTexture) {\n            \
if (depthTexture !== null && properties.has(depthTexture) && \
(renderTarget.width !== depthTexture.image.width || renderTarget.height !== \
depthTexture.image.height)) {\n              throw new \
Error(\"WebGLRenderTarget: Attached DepthTexture is initialized to the \
incorrect size.\");\n            }\n            \
textures.setupDepthRenderbuffer(renderTarget);\n          }\n        }\n      \
  const texture2 = renderTarget.texture;\n        if \
(texture2.isData3DTexture || texture2.isDataArrayTexture || \
texture2.isCompressedArrayTexture) {\n          isRenderTarget3D = true;\n    \
    }\n        const __webglFramebuffer = \
properties.get(renderTarget).__webglFramebuffer;\n        if \
(renderTarget.isWebGLCubeRenderTarget) {\n          if \
(Array.isArray(__webglFramebuffer[activeCubeFace])) {\n            \
framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];\n        \
  } else {\n            framebuffer = __webglFramebuffer[activeCubeFace];\n   \
       }\n          isCube = true;\n        } else if (renderTarget.samples > \
0 && textures.useMultisampledRTT(renderTarget) === false) {\n          \
framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n  \
      } else {\n          if (Array.isArray(__webglFramebuffer)) {\n          \
  framebuffer = __webglFramebuffer[activeMipmapLevel];\n          } else {\n  \
          framebuffer = __webglFramebuffer;\n          }\n        }\n        \
_currentViewport.copy(renderTarget.viewport);\n        \
_currentScissor.copy(renderTarget.scissor);\n        _currentScissorTest = \
renderTarget.scissorTest;\n      } else {\n        \
_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n       \
 _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n        \
_currentScissorTest = _scissorTest;\n      }\n      const framebufferBound = \
state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n      if \
(framebufferBound && useDefaultFramebuffer) {\n        \
state.drawBuffers(renderTarget, framebuffer);\n      }\n      \
state.viewport(_currentViewport);\n      state.scissor(_currentScissor);\n    \
  state.setScissorTest(_currentScissorTest);\n      if (isCube) {\n        \
const textureProperties = properties.get(renderTarget.texture);\n        \
_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, \
_gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, \
textureProperties.__webglTexture, activeMipmapLevel);\n      } else if \
(isRenderTarget3D) {\n        const textureProperties = \
properties.get(renderTarget.texture);\n        const layer = activeCubeFace \
|| 0;\n        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, \
_gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || \
0, layer);\n      }\n      _currentMaterialId = -1;\n    };\n    \
this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, \
buffer2, activeCubeFaceIndex) {\n      if (!(renderTarget && \
renderTarget.isWebGLRenderTarget)) {\n        \
console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is \
not THREE.WebGLRenderTarget.\");\n        return;\n      }\n      let \
framebuffer = properties.get(renderTarget).__webglFramebuffer;\n      if \
(renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {\n  \
      framebuffer = framebuffer[activeCubeFaceIndex];\n      }\n      if \
(framebuffer) {\n        state.bindFramebuffer(_gl.FRAMEBUFFER, \
framebuffer);\n        try {\n          const texture2 = \
renderTarget.texture;\n          const textureFormat = texture2.format;\n     \
     const textureType = texture2.type;\n          if \
(!capabilities.textureFormatReadable(textureFormat)) {\n            \
console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is \
not in RGBA or implementation defined format.\");\n            return;\n      \
    }\n          if (!capabilities.textureTypeReadable(textureType)) {\n      \
      console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: \
renderTarget is not in UnsignedByteType or implementation defined type.\");\n \
           return;\n          }\n          if (x2 >= 0 && x2 <= \
renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - \
height)) {\n            _gl.readPixels(x2, y2, width, height, \
utils.convert(textureFormat), utils.convert(textureType), buffer2);\n         \
 }\n        } finally {\n          const framebuffer2 = _currentRenderTarget \
!== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n  \
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);\n        }\n    \
  }\n    };\n    this.readRenderTargetPixelsAsync = async \
function(renderTarget, x2, y2, width, height, buffer2, activeCubeFaceIndex) \
{\n      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n        \
throw new Error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is \
not THREE.WebGLRenderTarget.\");\n      }\n      let framebuffer = \
properties.get(renderTarget).__webglFramebuffer;\n      if \
(renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {\n  \
      framebuffer = framebuffer[activeCubeFaceIndex];\n      }\n      if \
(framebuffer) {\n        const texture2 = renderTarget.texture;\n        \
const textureFormat = texture2.format;\n        const textureType = \
texture2.type;\n        if \
(!capabilities.textureFormatReadable(textureFormat)) {\n          throw new \
Error(\"THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not \
in RGBA or implementation defined format.\");\n        }\n        if \
(!capabilities.textureTypeReadable(textureType)) {\n          throw new \
Error(\"THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not \
in UnsignedByteType or implementation defined type.\");\n        }\n        \
if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= \
renderTarget.height - height)) {\n          \
state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n          const \
glBuffer = _gl.createBuffer();\n          \
_gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);\n          \
_gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer2.byteLength, _gl.STREAM_READ);\n \
         _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), \
utils.convert(textureType), 0);\n          const currFramebuffer = \
_currentRenderTarget !== null ? \
properties.get(_currentRenderTarget).__webglFramebuffer : null;\n          \
state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);\n          const \
sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n          \
_gl.flush();\n          await probeAsync(_gl, sync, 4);\n          \
_gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);\n          \
_gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer2);\n          \
_gl.deleteBuffer(glBuffer);\n          _gl.deleteSync(sync);\n          \
return buffer2;\n        } else {\n          throw new \
Error(\"THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read \
bounds are out of range.\");\n        }\n      }\n    };\n    \
this.copyFramebufferToTexture = function(texture2, position = null, level = \
0) {\n      if (texture2.isTexture !== true) {\n        \
warnOnce(\"WebGLRenderer: copyFramebufferToTexture function signature has \
changed.\");\n        position = arguments[0] || null;\n        texture2 = \
arguments[1];\n      }\n      const levelScale = Math.pow(2, -level);\n      \
const width = Math.floor(texture2.image.width * levelScale);\n      const \
height = Math.floor(texture2.image.height * levelScale);\n      const x2 = \
position !== null ? position.x : 0;\n      const y2 = position !== null ? \
position.y : 0;\n      textures.setTexture2D(texture2, 0);\n      \
_gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x2, y2, width, height);\n  \
    state.unbindTexture();\n    };\n    this.copyTextureToTexture = \
function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level \
= 0) {\n      if (srcTexture.isTexture !== true) {\n        \
warnOnce(\"WebGLRenderer: copyTextureToTexture function signature has \
changed.\");\n        dstPosition = arguments[0] || null;\n        srcTexture \
= arguments[1];\n        dstTexture = arguments[2];\n        level = \
arguments[3] || 0;\n        srcRegion = null;\n      }\n      let width, \
height, depth3, minX, minY, minZ;\n      let dstX, dstY, dstZ;\n      const \
image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : \
srcTexture.image;\n      if (srcRegion !== null) {\n        width = \
srcRegion.max.x - srcRegion.min.x;\n        height = srcRegion.max.y - \
srcRegion.min.y;\n        depth3 = srcRegion.isBox3 ? srcRegion.max.z - \
srcRegion.min.z : 1;\n        minX = srcRegion.min.x;\n        minY = \
srcRegion.min.y;\n        minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;\n    \
  } else {\n        width = image.width;\n        height = image.height;\n    \
    depth3 = image.depth || 1;\n        minX = 0;\n        minY = 0;\n        \
minZ = 0;\n      }\n      if (dstPosition !== null) {\n        dstX = \
dstPosition.x;\n        dstY = dstPosition.y;\n        dstZ = \
dstPosition.z;\n      } else {\n        dstX = 0;\n        dstY = 0;\n        \
dstZ = 0;\n      }\n      const glFormat = \
utils.convert(dstTexture.format);\n      const glType = \
utils.convert(dstTexture.type);\n      let glTarget;\n      if \
(dstTexture.isData3DTexture) {\n        textures.setTexture3D(dstTexture, \
0);\n        glTarget = _gl.TEXTURE_3D;\n      } else if \
(dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {\n    \
    textures.setTexture2DArray(dstTexture, 0);\n        glTarget = \
_gl.TEXTURE_2D_ARRAY;\n      } else {\n        \
textures.setTexture2D(dstTexture, 0);\n        glTarget = _gl.TEXTURE_2D;\n   \
   }\n      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n     \
 _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, \
dstTexture.premultiplyAlpha);\n      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, \
dstTexture.unpackAlignment);\n      const currentUnpackRowLen = \
_gl.getParameter(_gl.UNPACK_ROW_LENGTH);\n      const \
currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);\n      \
const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);\n   \
   const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);\n    \
  const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);\n \
     _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);\n      \
_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);\n      \
_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);\n      \
_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);\n      \
_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);\n      const isSrc3D = \
srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;\n      const \
isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;\n      \
if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {\n        \
const srcTextureProperties = properties.get(srcTexture);\n        const \
dstTextureProperties = properties.get(dstTexture);\n        const \
srcRenderTargetProperties = \
properties.get(srcTextureProperties.__renderTarget);\n        const \
dstRenderTargetProperties = \
properties.get(dstTextureProperties.__renderTarget);\n        \
state.bindFramebuffer(_gl.READ_FRAMEBUFFER, \
srcRenderTargetProperties.__webglFramebuffer);\n        \
state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, \
dstRenderTargetProperties.__webglFramebuffer);\n        for (let i = 0; i < \
depth3; i++) {\n          if (isSrc3D) {\n            \
_gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, \
properties.get(srcTexture).__webglTexture, level, minZ + i);\n          }\n   \
       if (srcTexture.isDepthTexture) {\n            if (isDst3D) {\n         \
     _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, \
properties.get(dstTexture).__webglTexture, level, dstZ + i);\n            }\n \
           _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, \
height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST);\n          } else if (isDst3D) \
{\n            _gl.copyTexSubImage3D(glTarget, level, dstX, dstY, dstZ + i, \
minX, minY, width, height);\n          } else {\n            \
_gl.copyTexSubImage2D(glTarget, level, dstX, dstY, dstZ + i, minX, minY, \
width, height);\n          }\n        }\n        \
state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);\n        \
state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);\n      } else {\n        \
if (isDst3D) {\n          if (srcTexture.isDataTexture || \
srcTexture.isData3DTexture) {\n            _gl.texSubImage3D(glTarget, level, \
dstX, dstY, dstZ, width, height, depth3, glFormat, glType, image.data);\n     \
     } else if (dstTexture.isCompressedArrayTexture) {\n            \
_gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, \
depth3, glFormat, image.data);\n          } else {\n            \
_gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth3, \
glFormat, glType, image);\n          }\n        } else {\n          if \
(srcTexture.isDataTexture) {\n            _gl.texSubImage2D(_gl.TEXTURE_2D, \
level, dstX, dstY, width, height, glFormat, glType, image.data);\n          } \
else if (srcTexture.isCompressedTexture) {\n            \
_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image.width, \
image.height, glFormat, image.data);\n          } else {\n            \
_gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, \
glType, image);\n          }\n        }\n      }\n      \
_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);\n      \
_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);\n      \
_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);\n      \
_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);\n      \
_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);\n      if \
(level === 0 && dstTexture.generateMipmaps) {\n        \
_gl.generateMipmap(glTarget);\n      }\n      state.unbindTexture();\n    \
};\n    this.copyTextureToTexture3D = function(srcTexture, dstTexture, \
srcRegion = null, dstPosition = null, level = 0) {\n      if \
(srcTexture.isTexture !== true) {\n        warnOnce(\"WebGLRenderer: \
copyTextureToTexture3D function signature has changed.\");\n        srcRegion \
= arguments[0] || null;\n        dstPosition = arguments[1] || null;\n        \
srcTexture = arguments[2];\n        dstTexture = arguments[3];\n        level \
= arguments[4] || 0;\n      }\n      warnOnce('WebGLRenderer: \
copyTextureToTexture3D function has been deprecated. Use \
\"copyTextureToTexture\" instead.');\n      return \
this.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, \
level);\n    };\n    this.initRenderTarget = function(target) {\n      if \
(properties.get(target).__webglFramebuffer === void 0) {\n        \
textures.setupRenderTarget(target);\n      }\n    };\n    this.initTexture = \
function(texture2) {\n      if (texture2.isCubeTexture) {\n        \
textures.setTextureCube(texture2, 0);\n      } else if \
(texture2.isData3DTexture) {\n        textures.setTexture3D(texture2, 0);\n   \
   } else if (texture2.isDataArrayTexture || \
texture2.isCompressedArrayTexture) {\n        \
textures.setTexture2DArray(texture2, 0);\n      } else {\n        \
textures.setTexture2D(texture2, 0);\n      }\n      state.unbindTexture();\n  \
  };\n    this.resetState = function() {\n      _currentActiveCubeFace = 0;\n \
     _currentActiveMipmapLevel = 0;\n      _currentRenderTarget = null;\n     \
 state.reset();\n      bindingStates.reset();\n    };\n    if (typeof \
__THREE_DEVTOOLS__ !== \"undefined\") {\n      \
__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"observe\", { detail: this \
}));\n    }\n  }\n  get coordinateSystem() {\n    return \
WebGLCoordinateSystem;\n  }\n  get outputColorSpace() {\n    return \
this._outputColorSpace;\n  }\n  set outputColorSpace(colorSpace) {\n    \
this._outputColorSpace = colorSpace;\n    const gl = this.getContext();\n    \
gl.drawingBufferColorspace = \
ColorManagement._getDrawingBufferColorSpace(colorSpace);\n    \
gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();\n  }\n};\nvar \
Scene = class extends Object3D {\n  constructor() {\n    super();\n    \
this.isScene = true;\n    this.type = \"Scene\";\n    this.background = \
null;\n    this.environment = null;\n    this.fog = null;\n    \
this.backgroundBlurriness = 0;\n    this.backgroundIntensity = 1;\n    \
this.backgroundRotation = new Euler();\n    this.environmentIntensity = 1;\n  \
  this.environmentRotation = new Euler();\n    this.overrideMaterial = \
null;\n    if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n      \
__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"observe\", { detail: this \
}));\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, \
recursive);\n    if (source.background !== null) this.background = \
source.background.clone();\n    if (source.environment !== null) \
this.environment = source.environment.clone();\n    if (source.fog !== null) \
this.fog = source.fog.clone();\n    this.backgroundBlurriness = \
source.backgroundBlurriness;\n    this.backgroundIntensity = \
source.backgroundIntensity;\n    \
this.backgroundRotation.copy(source.backgroundRotation);\n    \
this.environmentIntensity = source.environmentIntensity;\n    \
this.environmentRotation.copy(source.environmentRotation);\n    if \
(source.overrideMaterial !== null) this.overrideMaterial = \
source.overrideMaterial.clone();\n    this.matrixAutoUpdate = \
source.matrixAutoUpdate;\n    return this;\n  }\n  toJSON(meta) {\n    const \
data = super.toJSON(meta);\n    if (this.fog !== null) data.object.fog = \
this.fog.toJSON();\n    if (this.backgroundBlurriness > 0) \
data.object.backgroundBlurriness = this.backgroundBlurriness;\n    if \
(this.backgroundIntensity !== 1) data.object.backgroundIntensity = \
this.backgroundIntensity;\n    data.object.backgroundRotation = \
this.backgroundRotation.toArray();\n    if (this.environmentIntensity !== 1) \
data.object.environmentIntensity = this.environmentIntensity;\n    \
data.object.environmentRotation = this.environmentRotation.toArray();\n    \
return data;\n  }\n};\nvar LineBasicMaterial = class extends Material {\n  \
static get type() {\n    return \"LineBasicMaterial\";\n  }\n  \
constructor(parameters) {\n    super();\n    this.isLineBasicMaterial = \
true;\n    this.color = new Color(16777215);\n    this.map = null;\n    \
this.linewidth = 1;\n    this.linecap = \"round\";\n    this.linejoin = \
\"round\";\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n \
   this.map = source.map;\n    this.linewidth = source.linewidth;\n    \
this.linecap = source.linecap;\n    this.linejoin = source.linejoin;\n    \
this.fog = source.fog;\n    return this;\n  }\n};\nvar _vStart = /* @__PURE__ \
*/ new Vector3();\nvar _vEnd = /* @__PURE__ */ new Vector3();\nvar \
_inverseMatrix$1 = /* @__PURE__ */ new Matrix4();\nvar _ray$1 = /* @__PURE__ \
*/ new Ray();\nvar _sphere$1 = /* @__PURE__ */ new Sphere();\nvar \
_intersectPointOnRay = /* @__PURE__ */ new Vector3();\nvar \
_intersectPointOnSegment = /* @__PURE__ */ new Vector3();\nvar Line = class \
extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = \
new LineBasicMaterial()) {\n    super();\n    this.isLine = true;\n    \
this.type = \"Line\";\n    this.geometry = geometry;\n    this.material = \
material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n \
   super.copy(source, recursive);\n    this.material = \
Array.isArray(source.material) ? source.material.slice() : source.material;\n \
   this.geometry = source.geometry;\n    return this;\n  }\n  \
computeLineDistances() {\n    const geometry = this.geometry;\n    if \
(geometry.index === null) {\n      const positionAttribute = \
geometry.attributes.position;\n      const lineDistances = [0];\n      for \
(let i = 1, l = positionAttribute.count; i < l; i++) {\n        \
_vStart.fromBufferAttribute(positionAttribute, i - 1);\n        \
_vEnd.fromBufferAttribute(positionAttribute, i);\n        lineDistances[i] = \
lineDistances[i - 1];\n        lineDistances[i] += \
_vStart.distanceTo(_vEnd);\n      }\n      \
geometry.setAttribute(\"lineDistance\", new \
Float32BufferAttribute(lineDistances, 1));\n    } else {\n      \
console.warn(\"THREE.Line.computeLineDistances(): Computation only possible \
with non-indexed BufferGeometry.\");\n    }\n    return this;\n  }\n  \
raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    \
const matrixWorld = this.matrixWorld;\n    const threshold = \
raycaster.params.Line.threshold;\n    const drawRange = geometry.drawRange;\n \
   if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n  \
  _sphere$1.copy(geometry.boundingSphere);\n    \
_sphere$1.applyMatrix4(matrixWorld);\n    _sphere$1.radius += threshold;\n    \
if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;\n    \
_inverseMatrix$1.copy(matrixWorld).invert();\n    \
_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n    const \
localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / \
3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const \
step2 = this.isLineSegments ? 2 : 1;\n    const index5 = geometry.index;\n    \
const attributes = geometry.attributes;\n    const positionAttribute = \
attributes.position;\n    if (index5 !== null) {\n      const start = \
Math.max(0, drawRange.start);\n      const end = Math.min(index5.count, \
drawRange.start + drawRange.count);\n      for (let i = start, l = end - 1; i \
< l; i += step2) {\n        const a2 = index5.getX(i);\n        const b = \
index5.getX(i + 1);\n        const intersect2 = checkIntersection(this, \
raycaster, _ray$1, localThresholdSq, a2, b);\n        if (intersect2) {\n     \
     intersects.push(intersect2);\n        }\n      }\n      if \
(this.isLineLoop) {\n        const a2 = index5.getX(end - 1);\n        const \
b = index5.getX(start);\n        const intersect2 = checkIntersection(this, \
raycaster, _ray$1, localThresholdSq, a2, b);\n        if (intersect2) {\n     \
     intersects.push(intersect2);\n        }\n      }\n    } else {\n      \
const start = Math.max(0, drawRange.start);\n      const end = \
Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      \
for (let i = start, l = end - 1; i < l; i += step2) {\n        const \
intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i, \
i + 1);\n        if (intersect2) {\n          intersects.push(intersect2);\n  \
      }\n      }\n      if (this.isLineLoop) {\n        const intersect2 = \
checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, \
start);\n        if (intersect2) {\n          intersects.push(intersect2);\n  \
      }\n      }\n    }\n  }\n  updateMorphTargets() {\n    const geometry = \
this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    \
const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      \
const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute \
!== void 0) {\n        this.morphTargetInfluences = [];\n        \
this.morphTargetDictionary = {};\n        for (let m2 = 0, ml = \
morphAttribute.length; m2 < ml; m2++) {\n          const name = \
morphAttribute[m2].name || String(m2);\n          \
this.morphTargetInfluences.push(0);\n          \
this.morphTargetDictionary[name] = m2;\n        }\n      }\n    }\n  \
}\n};\nfunction checkIntersection(object, raycaster, ray, thresholdSq, a2, b) \
{\n  const positionAttribute = object.geometry.attributes.position;\n  \
_vStart.fromBufferAttribute(positionAttribute, a2);\n  \
_vEnd.fromBufferAttribute(positionAttribute, b);\n  const distSq = \
ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, \
_intersectPointOnSegment);\n  if (distSq > thresholdSq) return;\n  \
_intersectPointOnRay.applyMatrix4(object.matrixWorld);\n  const distance2 = \
raycaster.ray.origin.distanceTo(_intersectPointOnRay);\n  if (distance2 < \
raycaster.near || distance2 > raycaster.far) return;\n  return {\n    \
distance: distance2,\n    // What do we want? intersection point on the ray \
or on the segment??\n    // point: raycaster.ray.at( distance ),\n    point: \
_intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),\n    \
index: a2,\n    face: null,\n    faceIndex: null,\n    barycoord: null,\n    \
object\n  };\n}\nvar Curve = class {\n  constructor() {\n    this.type = \
\"Curve\";\n    this.arcLengthDivisions = 200;\n  }\n  // Virtual base class \
method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n  \
getPoint() {\n    console.warn(\"THREE.Curve: .getPoint() not \
implemented.\");\n    return null;\n  }\n  // Get point at relative position \
in curve according to arc length\n  // - u [0 .. 1]\n  getPointAt(u, \
optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return \
this.getPoint(t, optionalTarget);\n  }\n  // Get sequence of points using \
getPoint( t )\n  getPoints(divisions = 5) {\n    const points = [];\n    for \
(let d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / \
divisions));\n    }\n    return points;\n  }\n  // Get sequence of points \
using getPointAt( u )\n  getSpacedPoints(divisions = 5) {\n    const points = \
[];\n    for (let d = 0; d <= divisions; d++) {\n      \
points.push(this.getPointAt(d / divisions));\n    }\n    return points;\n  \
}\n  // Get total curve arc length\n  getLength() {\n    const lengths = \
this.getLengths();\n    return lengths[lengths.length - 1];\n  }\n  // Get \
list of cumulative segment lengths\n  getLengths(divisions = \
this.arcLengthDivisions) {\n    if (this.cacheArcLengths && \
this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      \
return this.cacheArcLengths;\n    }\n    this.needsUpdate = false;\n    const \
cache2 = [];\n    let current, last = this.getPoint(0);\n    let sum = 0;\n   \
 cache2.push(0);\n    for (let p = 1; p <= divisions; p++) {\n      current = \
this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      \
cache2.push(sum);\n      last = current;\n    }\n    this.cacheArcLengths = \
cache2;\n    return cache2;\n  }\n  updateArcLengths() {\n    \
this.needsUpdate = true;\n    this.getLengths();\n  }\n  // Given u ( 0 .. 1 \
), get a t to find p. This gives you points which are equidistant\n  \
getUtoTmapping(u, distance2) {\n    const arcLengths = this.getLengths();\n   \
 let i = 0;\n    const il = arcLengths.length;\n    let targetArcLength;\n    \
if (distance2) {\n      targetArcLength = distance2;\n    } else {\n      \
targetArcLength = u * arcLengths[il - 1];\n    }\n    let low = 0, high = il \
- 1, comparison;\n    while (low <= high) {\n      i = Math.floor(low + (high \
- low) / 2);\n      comparison = arcLengths[i] - targetArcLength;\n      if \
(comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) \
{\n        high = i - 1;\n      } else {\n        high = i;\n        break;\n \
     }\n    }\n    i = high;\n    if (arcLengths[i] === targetArcLength) {\n  \
    return i / (il - 1);\n    }\n    const lengthBefore = arcLengths[i];\n    \
const lengthAfter = arcLengths[i + 1];\n    const segmentLength = lengthAfter \
- lengthBefore;\n    const segmentFraction = (targetArcLength - lengthBefore) \
/ segmentLength;\n    const t = (i + segmentFraction) / (il - 1);\n    return \
t;\n  }\n  // Returns a unit vector tangent at t\n  // In case any sub curve \
does not implement its tangent derivation,\n  // 2 points a small delta apart \
will be used to find its gradient\n  // which seems to give a reasonable \
approximation\n  getTangent(t, optionalTarget) {\n    const delta = 1e-4;\n   \
 let t1 = t - delta;\n    let t2 = t + delta;\n    if (t1 < 0) t1 = 0;\n    \
if (t2 > 1) t2 = 1;\n    const pt1 = this.getPoint(t1);\n    const pt2 = \
this.getPoint(t2);\n    const tangent = optionalTarget || (pt1.isVector2 ? \
new Vector2() : new Vector3());\n    \
tangent.copy(pt2).sub(pt1).normalize();\n    return tangent;\n  }\n  \
getTangentAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    \
return this.getTangent(t, optionalTarget);\n  }\n  \
computeFrenetFrames(segments, closed) {\n    const normal2 = new Vector3();\n \
   const tangents = [];\n    const normals = [];\n    const binormals = [];\n \
   const vec = new Vector3();\n    const mat = new Matrix4();\n    for (let i \
= 0; i <= segments; i++) {\n      const u = i / segments;\n      tangents[i] \
= this.getTangentAt(u, new Vector3());\n    }\n    normals[0] = new \
Vector3();\n    binormals[0] = new Vector3();\n    let min2 = \
Number.MAX_VALUE;\n    const tx = Math.abs(tangents[0].x);\n    const ty = \
Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n    if (tx \
<= min2) {\n      min2 = tx;\n      normal2.set(1, 0, 0);\n    }\n    if (ty \
<= min2) {\n      min2 = ty;\n      normal2.set(0, 1, 0);\n    }\n    if (tz \
<= min2) {\n      normal2.set(0, 0, 1);\n    }\n    \
vec.crossVectors(tangents[0], normal2).normalize();\n    \
normals[0].crossVectors(tangents[0], vec);\n    \
binormals[0].crossVectors(tangents[0], normals[0]);\n    for (let i = 1; i <= \
segments; i++) {\n      normals[i] = normals[i - 1].clone();\n      \
binormals[i] = binormals[i - 1].clone();\n      vec.crossVectors(tangents[i - \
1], tangents[i]);\n      if (vec.length() > Number.EPSILON) {\n        \
vec.normalize();\n        const theta = Math.acos(clamp(tangents[i - \
1].dot(tangents[i]), -1, 1));\n        \
normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n      \
binormals[i].crossVectors(tangents[i], normals[i]);\n    }\n    if (closed \
=== true) {\n      let theta = \
Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));\n      theta /= \
segments;\n      if (tangents[0].dot(vec.crossVectors(normals[0], \
normals[segments])) > 0) {\n        theta = -theta;\n      }\n      for (let \
i = 1; i <= segments; i++) {\n        \
normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n      \
  binormals[i].crossVectors(tangents[i], normals[i]);\n      }\n    }\n    \
return {\n      tangents,\n      normals,\n      binormals\n    };\n  }\n  \
clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) \
{\n    this.arcLengthDivisions = source.arcLengthDivisions;\n    return \
this;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        \
version: 4.6,\n        type: \"Curve\",\n        generator: \
\"Curve.toJSON\"\n      }\n    };\n    data.arcLengthDivisions = \
this.arcLengthDivisions;\n    data.type = this.type;\n    return data;\n  }\n \
 fromJSON(json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n   \
 return this;\n  }\n};\nvar EllipseCurve = class extends Curve {\n  \
constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, \
aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {\n    super();\n \
   this.isEllipseCurve = true;\n    this.type = \"EllipseCurve\";\n    \
this.aX = aX;\n    this.aY = aY;\n    this.xRadius = xRadius;\n    \
this.yRadius = yRadius;\n    this.aStartAngle = aStartAngle;\n    \
this.aEndAngle = aEndAngle;\n    this.aClockwise = aClockwise;\n    \
this.aRotation = aRotation;\n  }\n  getPoint(t, optionalTarget = new \
Vector2()) {\n    const point = optionalTarget;\n    const twoPi = Math.PI * \
2;\n    let deltaAngle = this.aEndAngle - this.aStartAngle;\n    const \
samePoints = Math.abs(deltaAngle) < Number.EPSILON;\n    while (deltaAngle < \
0) deltaAngle += twoPi;\n    while (deltaAngle > twoPi) deltaAngle -= \
twoPi;\n    if (deltaAngle < Number.EPSILON) {\n      if (samePoints) {\n     \
   deltaAngle = 0;\n      } else {\n        deltaAngle = twoPi;\n      }\n    \
}\n    if (this.aClockwise === true && !samePoints) {\n      if (deltaAngle \
=== twoPi) {\n        deltaAngle = -twoPi;\n      } else {\n        \
deltaAngle = deltaAngle - twoPi;\n      }\n    }\n    const angle = \
this.aStartAngle + t * deltaAngle;\n    let x2 = this.aX + this.xRadius * \
Math.cos(angle);\n    let y2 = this.aY + this.yRadius * Math.sin(angle);\n    \
if (this.aRotation !== 0) {\n      const cos2 = Math.cos(this.aRotation);\n   \
   const sin2 = Math.sin(this.aRotation);\n      const tx = x2 - this.aX;\n   \
   const ty = y2 - this.aY;\n      x2 = tx * cos2 - ty * sin2 + this.aX;\n    \
  y2 = tx * sin2 + ty * cos2 + this.aY;\n    }\n    return point.set(x2, \
y2);\n  }\n  copy(source) {\n    super.copy(source);\n    this.aX = \
source.aX;\n    this.aY = source.aY;\n    this.xRadius = source.xRadius;\n    \
this.yRadius = source.yRadius;\n    this.aStartAngle = source.aStartAngle;\n  \
  this.aEndAngle = source.aEndAngle;\n    this.aClockwise = \
source.aClockwise;\n    this.aRotation = source.aRotation;\n    return \
this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.aX = \
this.aX;\n    data.aY = this.aY;\n    data.xRadius = this.xRadius;\n    \
data.yRadius = this.yRadius;\n    data.aStartAngle = this.aStartAngle;\n    \
data.aEndAngle = this.aEndAngle;\n    data.aClockwise = this.aClockwise;\n    \
data.aRotation = this.aRotation;\n    return data;\n  }\n  fromJSON(json) {\n \
   super.fromJSON(json);\n    this.aX = json.aX;\n    this.aY = json.aY;\n    \
this.xRadius = json.xRadius;\n    this.yRadius = json.yRadius;\n    \
this.aStartAngle = json.aStartAngle;\n    this.aEndAngle = json.aEndAngle;\n  \
  this.aClockwise = json.aClockwise;\n    this.aRotation = json.aRotation;\n  \
  return this;\n  }\n};\nvar ArcCurve = class extends EllipseCurve {\n  \
constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    \
super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n    \
this.isArcCurve = true;\n    this.type = \"ArcCurve\";\n  }\n};\nfunction \
CubicPoly() {\n  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n  function init4(x0, \
x1, t0, t1) {\n    c0 = x0;\n    c1 = t0;\n    c2 = -3 * x0 + 3 * x1 - 2 * t0 \
- t1;\n    c3 = 2 * x0 - 2 * x1 + t0 + t1;\n  }\n  return {\n    \
initCatmullRom: function(x0, x1, x2, x3, tension) {\n      init4(x1, x2, \
tension * (x2 - x0), tension * (x3 - x1));\n    },\n    \
initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {\n      \
let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n      \
let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;\n      \
t1 *= dt1;\n      t2 *= dt1;\n      init4(x1, x2, t1, t2);\n    },\n    calc: \
function(t) {\n      const t2 = t * t;\n      const t3 = t2 * t;\n      \
return c0 + c1 * t + c2 * t2 + c3 * t3;\n    }\n  };\n}\nvar tmp = /* \
@__PURE__ */ new Vector3();\nvar px = /* @__PURE__ */ new CubicPoly();\nvar \
py = /* @__PURE__ */ new CubicPoly();\nvar pz = /* @__PURE__ */ new \
CubicPoly();\nvar CatmullRomCurve3 = class extends Curve {\n  \
constructor(points = [], closed = false, curveType = \"centripetal\", tension \
= 0.5) {\n    super();\n    this.isCatmullRomCurve3 = true;\n    this.type = \
\"CatmullRomCurve3\";\n    this.points = points;\n    this.closed = closed;\n \
   this.curveType = curveType;\n    this.tension = tension;\n  }\n  \
getPoint(t, optionalTarget = new Vector3()) {\n    const point = \
optionalTarget;\n    const points = this.points;\n    const l = \
points.length;\n    const p = (l - (this.closed ? 0 : 1)) * t;\n    let \
intPoint = Math.floor(p);\n    let weight = p - intPoint;\n    if \
(this.closed) {\n      intPoint += intPoint > 0 ? 0 : \
(Math.floor(Math.abs(intPoint) / l) + 1) * l;\n    } else if (weight === 0 && \
intPoint === l - 1) {\n      intPoint = l - 2;\n      weight = 1;\n    }\n    \
let p0, p3;\n    if (this.closed || intPoint > 0) {\n      p0 = \
points[(intPoint - 1) % l];\n    } else {\n      tmp.subVectors(points[0], \
points[1]).add(points[0]);\n      p0 = tmp;\n    }\n    const p1 = \
points[intPoint % l];\n    const p2 = points[(intPoint + 1) % l];\n    if \
(this.closed || intPoint + 2 < l) {\n      p3 = points[(intPoint + 2) % l];\n \
   } else {\n      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l \
- 1]);\n      p3 = tmp;\n    }\n    if (this.curveType === \"centripetal\" || \
this.curveType === \"chordal\") {\n      const pow5 = this.curveType === \
\"chordal\" ? 0.5 : 0.25;\n      let dt0 = Math.pow(p0.distanceToSquared(p1), \
pow5);\n      let dt1 = Math.pow(p1.distanceToSquared(p2), pow5);\n      let \
dt2 = Math.pow(p2.distanceToSquared(p3), pow5);\n      if (dt1 < 1e-4) dt1 = \
1;\n      if (dt0 < 1e-4) dt0 = dt1;\n      if (dt2 < 1e-4) dt2 = dt1;\n      \
px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n      \
py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n      \
pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n    } \
else if (this.curveType === \"catmullrom\") {\n      px.initCatmullRom(p0.x, \
p1.x, p2.x, p3.x, this.tension);\n      py.initCatmullRom(p0.y, p1.y, p2.y, \
p3.y, this.tension);\n      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, \
this.tension);\n    }\n    point.set(\n      px.calc(weight),\n      \
py.calc(weight),\n      pz.calc(weight)\n    );\n    return point;\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.points = [];\n    for (let \
i = 0, l = source.points.length; i < l; i++) {\n      const point = \
source.points[i];\n      this.points.push(point.clone());\n    }\n    \
this.closed = source.closed;\n    this.curveType = source.curveType;\n    \
this.tension = source.tension;\n    return this;\n  }\n  toJSON() {\n    \
const data = super.toJSON();\n    data.points = [];\n    for (let i = 0, l = \
this.points.length; i < l; i++) {\n      const point = this.points[i];\n      \
data.points.push(point.toArray());\n    }\n    data.closed = this.closed;\n   \
 data.curveType = this.curveType;\n    data.tension = this.tension;\n    \
return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    \
this.points = [];\n    for (let i = 0, l = json.points.length; i < l; i++) \
{\n      const point = json.points[i];\n      this.points.push(new \
Vector3().fromArray(point));\n    }\n    this.closed = json.closed;\n    \
this.curveType = json.curveType;\n    this.tension = json.tension;\n    \
return this;\n  }\n};\nfunction CatmullRom(t, p0, p1, p2, p3) {\n  const v0 = \
(p2 - p0) * 0.5;\n  const v1 = (p3 - p1) * 0.5;\n  const t2 = t * t;\n  const \
t3 = t * t2;\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - \
2 * v0 - v1) * t2 + v0 * t + p1;\n}\nfunction QuadraticBezierP0(t, p) {\n  \
const k = 1 - t;\n  return k * k * p;\n}\nfunction QuadraticBezierP1(t, p) \
{\n  return 2 * (1 - t) * t * p;\n}\nfunction QuadraticBezierP2(t, p) {\n  \
return t * t * p;\n}\nfunction QuadraticBezier(t, p0, p1, p2) {\n  return \
QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, \
p2);\n}\nfunction CubicBezierP0(t, p) {\n  const k = 1 - t;\n  return k * k * \
k * p;\n}\nfunction CubicBezierP1(t, p) {\n  const k = 1 - t;\n  return 3 * k \
* k * t * p;\n}\nfunction CubicBezierP2(t, p) {\n  return 3 * (1 - t) * t * t \
* p;\n}\nfunction CubicBezierP3(t, p) {\n  return t * t * t * p;\n}\nfunction \
CubicBezier(t, p0, p1, p2, p3) {\n  return CubicBezierP0(t, p0) + \
CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\n}\nvar \
CubicBezierCurve = class extends Curve {\n  constructor(v0 = new Vector2(), \
v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {\n    super();\n \
   this.isCubicBezierCurve = true;\n    this.type = \"CubicBezierCurve\";\n   \
 this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  \
}\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = \
optionalTarget;\n    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = \
this.v3;\n    point.set(\n      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),\n     \
 CubicBezier(t, v0.y, v1.y, v2.y, v3.y)\n    );\n    return point;\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    \
this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    \
this.v3.copy(source.v3);\n    return this;\n  }\n  toJSON() {\n    const data \
= super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = \
this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = \
this.v3.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    \
super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    \
this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    \
this.v3.fromArray(json.v3);\n    return this;\n  }\n};\nvar CubicBezierCurve3 \
= class extends Curve {\n  constructor(v0 = new Vector3(), v1 = new \
Vector3(), v2 = new Vector3(), v3 = new Vector3()) {\n    super();\n    \
this.isCubicBezierCurve3 = true;\n    this.type = \"CubicBezierCurve3\";\n    \
this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  }\n \
 getPoint(t, optionalTarget = new Vector3()) {\n    const point = \
optionalTarget;\n    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = \
this.v3;\n    point.set(\n      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),\n     \
 CubicBezier(t, v0.y, v1.y, v2.y, v3.y),\n      CubicBezier(t, v0.z, v1.z, \
v2.z, v3.z)\n    );\n    return point;\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.v0.copy(source.v0);\n    \
this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    \
this.v3.copy(source.v3);\n    return this;\n  }\n  toJSON() {\n    const data \
= super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = \
this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = \
this.v3.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    \
super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    \
this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    \
this.v3.fromArray(json.v3);\n    return this;\n  }\n};\nvar LineCurve = class \
extends Curve {\n  constructor(v1 = new Vector2(), v2 = new Vector2()) {\n    \
super();\n    this.isLineCurve = true;\n    this.type = \"LineCurve\";\n    \
this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new \
Vector2()) {\n    const point = optionalTarget;\n    if (t === 1) {\n      \
point.copy(this.v2);\n    } else {\n      point.copy(this.v2).sub(this.v1);\n \
     point.multiplyScalar(t).add(this.v1);\n    }\n    return point;\n  }\n  \
// Line curve is linear, so we can overwrite default getPointAt\n  \
getPointAt(u, optionalTarget) {\n    return this.getPoint(u, \
optionalTarget);\n  }\n  getTangent(t, optionalTarget = new Vector2()) {\n    \
return optionalTarget.subVectors(this.v2, this.v1).normalize();\n  }\n  \
getTangentAt(u, optionalTarget) {\n    return this.getTangent(u, \
optionalTarget);\n  }\n  copy(source) {\n    super.copy(source);\n    \
this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  \
}\n  toJSON() {\n    const data = super.toJSON();\n    data.v1 = \
this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n \
 fromJSON(json) {\n    super.fromJSON(json);\n    \
this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return \
this;\n  }\n};\nvar LineCurve3 = class extends Curve {\n  constructor(v1 = \
new Vector3(), v2 = new Vector3()) {\n    super();\n    this.isLineCurve3 = \
true;\n    this.type = \"LineCurve3\";\n    this.v1 = v1;\n    this.v2 = \
v2;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = \
optionalTarget;\n    if (t === 1) {\n      point.copy(this.v2);\n    } else \
{\n      point.copy(this.v2).sub(this.v1);\n      \
point.multiplyScalar(t).add(this.v1);\n    }\n    return point;\n  }\n  // \
Line curve is linear, so we can overwrite default getPointAt\n  getPointAt(u, \
optionalTarget) {\n    return this.getPoint(u, optionalTarget);\n  }\n  \
getTangent(t, optionalTarget = new Vector3()) {\n    return \
optionalTarget.subVectors(this.v2, this.v1).normalize();\n  }\n  \
getTangentAt(u, optionalTarget) {\n    return this.getTangent(u, \
optionalTarget);\n  }\n  copy(source) {\n    super.copy(source);\n    \
this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  \
}\n  toJSON() {\n    const data = super.toJSON();\n    data.v1 = \
this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n \
 fromJSON(json) {\n    super.fromJSON(json);\n    \
this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return \
this;\n  }\n};\nvar QuadraticBezierCurve = class extends Curve {\n  \
constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {\n   \
 super();\n    this.isQuadraticBezierCurve = true;\n    this.type = \
\"QuadraticBezierCurve\";\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 \
= v2;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point \
= optionalTarget;\n    const v0 = this.v0, v1 = this.v1, v2 = this.v2;\n    \
point.set(\n      QuadraticBezier(t, v0.x, v1.x, v2.x),\n      \
QuadraticBezier(t, v0.y, v1.y, v2.y)\n    );\n    return point;\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    \
this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  \
}\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = \
this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = \
this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    \
super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    \
this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return \
this;\n  }\n};\nvar QuadraticBezierCurve3 = class extends Curve {\n  \
constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {\n   \
 super();\n    this.isQuadraticBezierCurve3 = true;\n    this.type = \
\"QuadraticBezierCurve3\";\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 \
= v2;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point \
= optionalTarget;\n    const v0 = this.v0, v1 = this.v1, v2 = this.v2;\n    \
point.set(\n      QuadraticBezier(t, v0.x, v1.x, v2.x),\n      \
QuadraticBezier(t, v0.y, v1.y, v2.y),\n      QuadraticBezier(t, v0.z, v1.z, \
v2.z)\n    );\n    return point;\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.v0.copy(source.v0);\n    \
this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  \
}\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = \
this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = \
this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    \
super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    \
this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return \
this;\n  }\n};\nvar SplineCurve = class extends Curve {\n  constructor(points \
= []) {\n    super();\n    this.isSplineCurve = true;\n    this.type = \
\"SplineCurve\";\n    this.points = points;\n  }\n  getPoint(t, \
optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    \
const points = this.points;\n    const p = (points.length - 1) * t;\n    \
const intPoint = Math.floor(p);\n    const weight = p - intPoint;\n    const \
p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n    const p1 = \
points[intPoint];\n    const p2 = points[intPoint > points.length - 2 ? \
points.length - 1 : intPoint + 1];\n    const p3 = points[intPoint > \
points.length - 3 ? points.length - 1 : intPoint + 2];\n    point.set(\n      \
CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),\n      CatmullRom(weight, p0.y, \
p1.y, p2.y, p3.y)\n    );\n    return point;\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.points = [];\n    for (let i = 0, l = \
source.points.length; i < l; i++) {\n      const point = source.points[i];\n  \
    this.points.push(point.clone());\n    }\n    return this;\n  }\n  \
toJSON() {\n    const data = super.toJSON();\n    data.points = [];\n    for \
(let i = 0, l = this.points.length; i < l; i++) {\n      const point = \
this.points[i];\n      data.points.push(point.toArray());\n    }\n    return \
data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.points = \
[];\n    for (let i = 0, l = json.points.length; i < l; i++) {\n      const \
point = json.points[i];\n      this.points.push(new \
Vector2().fromArray(point));\n    }\n    return this;\n  }\n};\nvar Curves = \
/* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  ArcCurve,\n  \
CatmullRomCurve3,\n  CubicBezierCurve,\n  CubicBezierCurve3,\n  \
EllipseCurve,\n  LineCurve,\n  LineCurve3,\n  QuadraticBezierCurve,\n  \
QuadraticBezierCurve3,\n  SplineCurve\n});\nvar CylinderGeometry = class \
_CylinderGeometry extends BufferGeometry {\n  constructor(radiusTop = 1, \
radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, \
openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n    \
super();\n    this.type = \"CylinderGeometry\";\n    this.parameters = {\n    \
  radiusTop,\n      radiusBottom,\n      height,\n      radialSegments,\n     \
 heightSegments,\n      openEnded,\n      thetaStart,\n      thetaLength\n    \
};\n    const scope = this;\n    radialSegments = \
Math.floor(radialSegments);\n    heightSegments = \
Math.floor(heightSegments);\n    const indices = [];\n    const vertices = \
[];\n    const normals = [];\n    const uvs = [];\n    let index5 = 0;\n    \
const indexArray = [];\n    const halfHeight = height / 2;\n    let \
groupStart = 0;\n    generateTorso();\n    if (openEnded === false) {\n      \
if (radiusTop > 0) generateCap(true);\n      if (radiusBottom > 0) \
generateCap(false);\n    }\n    this.setIndex(indices);\n    \
this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n   \
 this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    \
this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function \
generateTorso() {\n      const normal2 = new Vector3();\n      const vertex2 \
= new Vector3();\n      let groupCount = 0;\n      const slope = \
(radiusBottom - radiusTop) / height;\n      for (let y2 = 0; y2 <= \
heightSegments; y2++) {\n        const indexRow = [];\n        const v = y2 / \
heightSegments;\n        const radius = v * (radiusBottom - radiusTop) + \
radiusTop;\n        for (let x2 = 0; x2 <= radialSegments; x2++) {\n          \
const u = x2 / radialSegments;\n          const theta = u * thetaLength + \
thetaStart;\n          const sinTheta = Math.sin(theta);\n          const \
cosTheta = Math.cos(theta);\n          vertex2.x = radius * sinTheta;\n       \
   vertex2.y = -v * height + halfHeight;\n          vertex2.z = radius * \
cosTheta;\n          vertices.push(vertex2.x, vertex2.y, vertex2.z);\n        \
  normal2.set(sinTheta, slope, cosTheta).normalize();\n          \
normals.push(normal2.x, normal2.y, normal2.z);\n          uvs.push(u, 1 - \
v);\n          indexRow.push(index5++);\n        }\n        \
indexArray.push(indexRow);\n      }\n      for (let x2 = 0; x2 < \
radialSegments; x2++) {\n        for (let y2 = 0; y2 < heightSegments; y2++) \
{\n          const a2 = indexArray[y2][x2];\n          const b = \
indexArray[y2 + 1][x2];\n          const c2 = indexArray[y2 + 1][x2 + 1];\n   \
       const d = indexArray[y2][x2 + 1];\n          if (radiusTop > 0 || y2 \
!== 0) {\n            indices.push(a2, b, d);\n            groupCount += 3;\n \
         }\n          if (radiusBottom > 0 || y2 !== heightSegments - 1) {\n  \
          indices.push(b, c2, d);\n            groupCount += 3;\n          \
}\n        }\n      }\n      scope.addGroup(groupStart, groupCount, 0);\n     \
 groupStart += groupCount;\n    }\n    function generateCap(top) {\n      \
const centerIndexStart = index5;\n      const uv2 = new Vector2();\n      \
const vertex2 = new Vector3();\n      let groupCount = 0;\n      const radius \
= top === true ? radiusTop : radiusBottom;\n      const sign2 = top === true \
? 1 : -1;\n      for (let x2 = 1; x2 <= radialSegments; x2++) {\n        \
vertices.push(0, halfHeight * sign2, 0);\n        normals.push(0, sign2, \
0);\n        uvs.push(0.5, 0.5);\n        index5++;\n      }\n      const \
centerIndexEnd = index5;\n      for (let x2 = 0; x2 <= radialSegments; x2++) \
{\n        const u = x2 / radialSegments;\n        const theta = u * \
thetaLength + thetaStart;\n        const cosTheta = Math.cos(theta);\n        \
const sinTheta = Math.sin(theta);\n        vertex2.x = radius * sinTheta;\n   \
     vertex2.y = halfHeight * sign2;\n        vertex2.z = radius * \
cosTheta;\n        vertices.push(vertex2.x, vertex2.y, vertex2.z);\n        \
normals.push(0, sign2, 0);\n        uv2.x = cosTheta * 0.5 + 0.5;\n        \
uv2.y = sinTheta * 0.5 * sign2 + 0.5;\n        uvs.push(uv2.x, uv2.y);\n      \
  index5++;\n      }\n      for (let x2 = 0; x2 < radialSegments; x2++) {\n   \
     const c2 = centerIndexStart + x2;\n        const i = centerIndexEnd + \
x2;\n        if (top === true) {\n          indices.push(i, i + 1, c2);\n     \
   } else {\n          indices.push(i + 1, i, c2);\n        }\n        \
groupCount += 3;\n      }\n      scope.addGroup(groupStart, groupCount, top \
=== true ? 1 : 2);\n      groupStart += groupCount;\n    }\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.parameters = \
Object.assign({}, source.parameters);\n    return this;\n  }\n  static \
fromJSON(data) {\n    return new _CylinderGeometry(data.radiusTop, \
data.radiusBottom, data.height, data.radialSegments, data.heightSegments, \
data.openEnded, data.thetaStart, data.thetaLength);\n  }\n};\nvar \
ConeGeometry = class _ConeGeometry extends CylinderGeometry {\n  \
constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, \
openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super(0, \
radius, height, radialSegments, heightSegments, openEnded, thetaStart, \
thetaLength);\n    this.type = \"ConeGeometry\";\n    this.parameters = {\n   \
   radius,\n      height,\n      radialSegments,\n      heightSegments,\n     \
 openEnded,\n      thetaStart,\n      thetaLength\n    };\n  }\n  static \
fromJSON(data) {\n    return new _ConeGeometry(data.radius, data.height, \
data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, \
data.thetaLength);\n  }\n};\nvar SphereGeometry = class _SphereGeometry \
extends BufferGeometry {\n  constructor(radius = 1, widthSegments = 32, \
heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, \
thetaLength = Math.PI) {\n    super();\n    this.type = \"SphereGeometry\";\n \
   this.parameters = {\n      radius,\n      widthSegments,\n      \
heightSegments,\n      phiStart,\n      phiLength,\n      thetaStart,\n      \
thetaLength\n    };\n    widthSegments = Math.max(3, \
Math.floor(widthSegments));\n    heightSegments = Math.max(2, \
Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + \
thetaLength, Math.PI);\n    let index5 = 0;\n    const grid = [];\n    const \
vertex2 = new Vector3();\n    const normal2 = new Vector3();\n    const \
indices = [];\n    const vertices = [];\n    const normals = [];\n    const \
uvs = [];\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const \
verticesRow = [];\n      const v = iy / heightSegments;\n      let uOffset = \
0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / \
widthSegments;\n      } else if (iy === heightSegments && thetaEnd === \
Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let \
ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n \
       vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * \
Math.sin(thetaStart + v * thetaLength);\n        vertex2.y = radius * \
Math.cos(thetaStart + v * thetaLength);\n        vertex2.z = radius * \
Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * \
thetaLength);\n        vertices.push(vertex2.x, vertex2.y, vertex2.z);\n      \
  normal2.copy(vertex2).normalize();\n        normals.push(normal2.x, \
normal2.y, normal2.z);\n        uvs.push(u + uOffset, 1 - v);\n        \
verticesRow.push(index5++);\n      }\n      grid.push(verticesRow);\n    }\n  \
  for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < \
widthSegments; ix++) {\n        const a2 = grid[iy][ix + 1];\n        const b \
= grid[iy][ix];\n        const c2 = grid[iy + 1][ix];\n        const d = \
grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) \
indices.push(a2, b, d);\n        if (iy !== heightSegments - 1 || thetaEnd < \
Math.PI) indices.push(b, c2, d);\n      }\n    }\n    \
this.setIndex(indices);\n    this.setAttribute(\"position\", new \
Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new \
Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new \
Float32BufferAttribute(uvs, 2));\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.parameters = Object.assign({}, \
source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    \
return new _SphereGeometry(data.radius, data.widthSegments, \
data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, \
data.thetaLength);\n  }\n};\nvar TubeGeometry = class _TubeGeometry extends \
BufferGeometry {\n  constructor(path = new QuadraticBezierCurve3(new \
Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), \
tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {\n    \
super();\n    this.type = \"TubeGeometry\";\n    this.parameters = {\n      \
path,\n      tubularSegments,\n      radius,\n      radialSegments,\n      \
closed\n    };\n    const frames = path.computeFrenetFrames(tubularSegments, \
closed);\n    this.tangents = frames.tangents;\n    this.normals = \
frames.normals;\n    this.binormals = frames.binormals;\n    const vertex2 = \
new Vector3();\n    const normal2 = new Vector3();\n    const uv2 = new \
Vector2();\n    let P = new Vector3();\n    const vertices = [];\n    const \
normals = [];\n    const uvs = [];\n    const indices = [];\n    \
generateBufferData();\n    this.setIndex(indices);\n    \
this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n   \
 this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    \
this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function \
generateBufferData() {\n      for (let i = 0; i < tubularSegments; i++) {\n   \
     generateSegment(i);\n      }\n      generateSegment(closed === false ? \
tubularSegments : 0);\n      generateUVs();\n      generateIndices();\n    \
}\n    function generateSegment(i) {\n      P = path.getPointAt(i / \
tubularSegments, P);\n      const N = frames.normals[i];\n      const B = \
frames.binormals[i];\n      for (let j = 0; j <= radialSegments; j++) {\n     \
   const v = j / radialSegments * Math.PI * 2;\n        const sin2 = \
Math.sin(v);\n        const cos2 = -Math.cos(v);\n        normal2.x = cos2 * \
N.x + sin2 * B.x;\n        normal2.y = cos2 * N.y + sin2 * B.y;\n        \
normal2.z = cos2 * N.z + sin2 * B.z;\n        normal2.normalize();\n        \
normals.push(normal2.x, normal2.y, normal2.z);\n        vertex2.x = P.x + \
radius * normal2.x;\n        vertex2.y = P.y + radius * normal2.y;\n        \
vertex2.z = P.z + radius * normal2.z;\n        vertices.push(vertex2.x, \
vertex2.y, vertex2.z);\n      }\n    }\n    function generateIndices() {\n    \
  for (let j = 1; j <= tubularSegments; j++) {\n        for (let i = 1; i <= \
radialSegments; i++) {\n          const a2 = (radialSegments + 1) * (j - 1) + \
(i - 1);\n          const b = (radialSegments + 1) * j + (i - 1);\n          \
const c2 = (radialSegments + 1) * j + i;\n          const d = (radialSegments \
+ 1) * (j - 1) + i;\n          indices.push(a2, b, d);\n          \
indices.push(b, c2, d);\n        }\n      }\n    }\n    function \
generateUVs() {\n      for (let i = 0; i <= tubularSegments; i++) {\n        \
for (let j = 0; j <= radialSegments; j++) {\n          uv2.x = i / \
tubularSegments;\n          uv2.y = j / radialSegments;\n          \
uvs.push(uv2.x, uv2.y);\n        }\n      }\n    }\n  }\n  copy(source) {\n   \
 super.copy(source);\n    this.parameters = Object.assign({}, \
source.parameters);\n    return this;\n  }\n  toJSON() {\n    const data = \
super.toJSON();\n    data.path = this.parameters.path.toJSON();\n    return \
data;\n  }\n  static fromJSON(data) {\n    return new _TubeGeometry(\n      \
new Curves[data.path.type]().fromJSON(data.path),\n      \
data.tubularSegments,\n      data.radius,\n      data.radialSegments,\n      \
data.closed\n    );\n  }\n};\nvar MeshLambertMaterial = class extends \
Material {\n  static get type() {\n    return \"MeshLambertMaterial\";\n  }\n \
 constructor(parameters) {\n    super();\n    this.isMeshLambertMaterial = \
true;\n    this.color = new Color(16777215);\n    this.map = null;\n    \
this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = \
null;\n    this.aoMapIntensity = 1;\n    this.emissive = new Color(0);\n    \
this.emissiveIntensity = 1;\n    this.emissiveMap = null;\n    this.bumpMap = \
null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    \
this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new \
Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale \
= 1;\n    this.displacementBias = 0;\n    this.specularMap = null;\n    \
this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new \
Euler();\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n \
   this.refractionRatio = 0.98;\n    this.wireframe = false;\n    \
this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    \
this.wireframeLinejoin = \"round\";\n    this.flatShading = false;\n    \
this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.color.copy(source.color);\n    this.map = \
source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity \
= source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    \
this.aoMapIntensity = source.aoMapIntensity;\n    \
this.emissive.copy(source.emissive);\n    this.emissiveMap = \
source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n \
   this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n   \
 this.normalMap = source.normalMap;\n    this.normalMapType = \
source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    \
this.displacementMap = source.displacementMap;\n    this.displacementScale = \
source.displacementScale;\n    this.displacementBias = \
source.displacementBias;\n    this.specularMap = source.specularMap;\n    \
this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    \
this.envMapRotation.copy(source.envMapRotation);\n    this.combine = \
source.combine;\n    this.reflectivity = source.reflectivity;\n    \
this.refractionRatio = source.refractionRatio;\n    this.wireframe = \
source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n \
   this.wireframeLinecap = source.wireframeLinecap;\n    \
this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = \
source.flatShading;\n    this.fog = source.fog;\n    return this;\n  \
}\n};\nfunction convertArray(array, type, forceClone) {\n  if (!array || // \
let 'undefined' and 'null' pass\n  !forceClone && array.constructor === type) \
return array;\n  if (typeof type.BYTES_PER_ELEMENT === \"number\") {\n    \
return new type(array);\n  }\n  return \
Array.prototype.slice.call(array);\n}\nfunction isTypedArray(object) {\n  \
return ArrayBuffer.isView(object) && !(object instanceof DataView);\n}\nvar \
Interpolant = class {\n  constructor(parameterPositions, sampleValues, \
sampleSize, resultBuffer) {\n    this.parameterPositions = \
parameterPositions;\n    this._cachedIndex = 0;\n    this.resultBuffer = \
resultBuffer !== void 0 ? resultBuffer : new \
sampleValues.constructor(sampleSize);\n    this.sampleValues = \
sampleValues;\n    this.valueSize = sampleSize;\n    this.settings = null;\n  \
  this.DefaultSettings_ = {};\n  }\n  evaluate(t) {\n    const pp = \
this.parameterPositions;\n    let i1 = this._cachedIndex, t1 = pp[i1], t0 = \
pp[i1 - 1];\n    validate_interval: {\n      seek: {\n        let right;\n    \
    linear_scan: {\n          forward_scan: if (!(t < t1)) {\n            for \
(let giveUpAt = i1 + 2; ; ) {\n              if (t1 === void 0) {\n           \
     if (t < t0) break forward_scan;\n                i1 = pp.length;\n       \
         this._cachedIndex = i1;\n                return \
this.copySampleValue_(i1 - 1);\n              }\n              if (i1 === \
giveUpAt) break;\n              t0 = t1;\n              t1 = pp[++i1];\n      \
        if (t < t1) {\n                break seek;\n              }\n         \
   }\n            right = pp.length;\n            break linear_scan;\n        \
  }\n          if (!(t >= t0)) {\n            const t1global = pp[1];\n       \
     if (t < t1global) {\n              i1 = 2;\n              t0 = \
t1global;\n            }\n            for (let giveUpAt = i1 - 2; ; ) {\n     \
         if (t0 === void 0) {\n                this._cachedIndex = 0;\n       \
         return this.copySampleValue_(0);\n              }\n              if \
(i1 === giveUpAt) break;\n              t1 = t0;\n              t0 = pp[--i1 \
- 1];\n              if (t >= t0) {\n                break seek;\n            \
  }\n            }\n            right = i1;\n            i1 = 0;\n            \
break linear_scan;\n          }\n          break validate_interval;\n        \
}\n        while (i1 < right) {\n          const mid = i1 + right >>> 1;\n    \
      if (t < pp[mid]) {\n            right = mid;\n          } else {\n      \
      i1 = mid + 1;\n          }\n        }\n        t1 = pp[i1];\n        t0 \
= pp[i1 - 1];\n        if (t0 === void 0) {\n          this._cachedIndex = \
0;\n          return this.copySampleValue_(0);\n        }\n        if (t1 === \
void 0) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n     \
     return this.copySampleValue_(i1 - 1);\n        }\n      }\n      \
this._cachedIndex = i1;\n      this.intervalChanged_(i1, t0, t1);\n    }\n    \
return this.interpolate_(i1, t0, t, t1);\n  }\n  getSettings_() {\n    return \
this.settings || this.DefaultSettings_;\n  }\n  copySampleValue_(index5) {\n  \
  const result = this.resultBuffer, values = this.sampleValues, stride = \
this.valueSize, offset = index5 * stride;\n    for (let i = 0; i !== stride; \
++i) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  \
}\n  // Template methods for derived classes:\n  interpolate_() {\n    throw \
new Error(\"call to abstract method\");\n  }\n  intervalChanged_() {\n  \
}\n};\nvar CubicInterpolant = class extends Interpolant {\n  \
constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n   \
 super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    \
this._weightPrev = -0;\n    this._offsetPrev = -0;\n    this._weightNext = \
-0;\n    this._offsetNext = -0;\n    this.DefaultSettings_ = {\n      \
endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    \
};\n  }\n  intervalChanged_(i1, t0, t1) {\n    const pp = \
this.parameterPositions;\n    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = \
pp[iPrev], tNext = pp[iNext];\n    if (tPrev === void 0) {\n      switch \
(this.getSettings_().endingStart) {\n        case ZeroSlopeEnding:\n          \
iPrev = i1;\n          tPrev = 2 * t0 - t1;\n          break;\n        case \
WrapAroundEnding:\n          iPrev = pp.length - 2;\n          tPrev = t0 + \
pp[iPrev] - pp[iPrev + 1];\n          break;\n        default:\n          \
iPrev = i1;\n          tPrev = t1;\n      }\n    }\n    if (tNext === void 0) \
{\n      switch (this.getSettings_().endingEnd) {\n        case \
ZeroSlopeEnding:\n          iNext = i1;\n          tNext = 2 * t1 - t0;\n     \
     break;\n        case WrapAroundEnding:\n          iNext = 1;\n          \
tNext = t1 + pp[1] - pp[0];\n          break;\n        default:\n          \
iNext = i1 - 1;\n          tNext = t0;\n      }\n    }\n    const halfDt = \
(t1 - t0) * 0.5, stride = this.valueSize;\n    this._weightPrev = halfDt / \
(t0 - tPrev);\n    this._weightNext = halfDt / (tNext - t1);\n    \
this._offsetPrev = iPrev * stride;\n    this._offsetNext = iNext * stride;\n  \
}\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer, \
values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = \
o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = \
this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * \
p, ppp = pp * p;\n    const sP = -wP * ppp + 2 * wP * pp - wP * p;\n    const \
s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const \
s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const sN = wN * ppp - \
wN * pp;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = sP * \
values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + \
i];\n    }\n    return result;\n  }\n};\nvar LinearInterpolant = class \
extends Interpolant {\n  constructor(parameterPositions, sampleValues, \
sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, \
sampleSize, resultBuffer);\n  }\n  interpolate_(i1, t0, t, t1) {\n    const \
result = this.resultBuffer, values = this.sampleValues, stride = \
this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = \
(t - t0) / (t1 - t0), weight0 = 1 - weight1;\n    for (let i = 0; i !== \
stride; ++i) {\n      result[i] = values[offset0 + i] * weight0 + \
values[offset1 + i] * weight1;\n    }\n    return result;\n  }\n};\nvar \
DiscreteInterpolant = class extends Interpolant {\n  \
constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n   \
 super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  \
interpolate_(i1) {\n    return this.copySampleValue_(i1 - 1);\n  }\n};\nvar \
KeyframeTrack = class {\n  constructor(name, times, values, interpolation) \
{\n    if (name === void 0) throw new Error(\"THREE.KeyframeTrack: track name \
is undefined\");\n    if (times === void 0 || times.length === 0) throw new \
Error(\"THREE.KeyframeTrack: no keyframes in track named \" + name);\n    \
this.name = name;\n    this.times = convertArray(times, \
this.TimeBufferType);\n    this.values = convertArray(values, \
this.ValueBufferType);\n    this.setInterpolation(interpolation || \
this.DefaultInterpolation);\n  }\n  // Serialization (in static context, \
because of constructor invocation\n  // and automatic invocation of \
.toJSON):\n  static toJSON(track) {\n    const trackType = \
track.constructor;\n    let json;\n    if (trackType.toJSON !== this.toJSON) \
{\n      json = trackType.toJSON(track);\n    } else {\n      json = {\n      \
  \"name\": track.name,\n        \"times\": convertArray(track.times, \
Array),\n        \"values\": convertArray(track.values, Array)\n      };\n    \
  const interpolation = track.getInterpolation();\n      if (interpolation \
!== track.DefaultInterpolation) {\n        json.interpolation = \
interpolation;\n      }\n    }\n    json.type = track.ValueTypeName;\n    \
return json;\n  }\n  InterpolantFactoryMethodDiscrete(result) {\n    return \
new DiscreteInterpolant(this.times, this.values, this.getValueSize(), \
result);\n  }\n  InterpolantFactoryMethodLinear(result) {\n    return new \
LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  \
}\n  InterpolantFactoryMethodSmooth(result) {\n    return new \
CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n  \
}\n  setInterpolation(interpolation) {\n    let factoryMethod;\n    switch \
(interpolation) {\n      case InterpolateDiscrete:\n        factoryMethod = \
this.InterpolantFactoryMethodDiscrete;\n        break;\n      case \
InterpolateLinear:\n        factoryMethod = \
this.InterpolantFactoryMethodLinear;\n        break;\n      case \
InterpolateSmooth:\n        factoryMethod = \
this.InterpolantFactoryMethodSmooth;\n        break;\n    }\n    if \
(factoryMethod === void 0) {\n      const message = \"unsupported \
interpolation for \" + this.ValueTypeName + \" keyframe track named \" + \
this.name;\n      if (this.createInterpolant === void 0) {\n        if \
(interpolation !== this.DefaultInterpolation) {\n          \
this.setInterpolation(this.DefaultInterpolation);\n        } else {\n         \
 throw new Error(message);\n        }\n      }\n      \
console.warn(\"THREE.KeyframeTrack:\", message);\n      return this;\n    }\n \
   this.createInterpolant = factoryMethod;\n    return this;\n  }\n  \
getInterpolation() {\n    switch (this.createInterpolant) {\n      case \
this.InterpolantFactoryMethodDiscrete:\n        return InterpolateDiscrete;\n \
     case this.InterpolantFactoryMethodLinear:\n        return \
InterpolateLinear;\n      case this.InterpolantFactoryMethodSmooth:\n        \
return InterpolateSmooth;\n    }\n  }\n  getValueSize() {\n    return \
this.values.length / this.times.length;\n  }\n  // move all keyframes either \
forwards or backwards in time\n  shift(timeOffset) {\n    if (timeOffset !== \
0) {\n      const times = this.times;\n      for (let i = 0, n = \
times.length; i !== n; ++i) {\n        times[i] += timeOffset;\n      }\n    \
}\n    return this;\n  }\n  // scale all keyframe times by a factor (useful \
for frame <-> seconds conversions)\n  scale(timeScale) {\n    if (timeScale \
!== 1) {\n      const times = this.times;\n      for (let i = 0, n = \
times.length; i !== n; ++i) {\n        times[i] *= timeScale;\n      }\n    \
}\n    return this;\n  }\n  // removes keyframes before and after animation \
without changing any values within the range [startTime, endTime].\n  // \
IMPORTANT: We do not shift around keys to the start of the track time, \
because for interpolated keys this will change their values\n  \
trim(startTime, endTime) {\n    const times = this.times, nKeys = \
times.length;\n    let from = 0, to = nKeys - 1;\n    while (from !== nKeys \
&& times[from] < startTime) {\n      ++from;\n    }\n    while (to !== -1 && \
times[to] > endTime) {\n      --to;\n    }\n    ++to;\n    if (from !== 0 || \
to !== nKeys) {\n      if (from >= to) {\n        to = Math.max(to, 1);\n     \
   from = to - 1;\n      }\n      const stride = this.getValueSize();\n      \
this.times = times.slice(from, to);\n      this.values = \
this.values.slice(from * stride, to * stride);\n    }\n    return this;\n  \
}\n  // ensure we do not get a GarbageInGarbageOut situation, make sure \
tracks are at least minimally viable\n  validate() {\n    let valid = true;\n \
   const valueSize = this.getValueSize();\n    if (valueSize - \
Math.floor(valueSize) !== 0) {\n      console.error(\"THREE.KeyframeTrack: \
Invalid value size in track.\", this);\n      valid = false;\n    }\n    \
const times = this.times, values = this.values, nKeys = times.length;\n    if \
(nKeys === 0) {\n      console.error(\"THREE.KeyframeTrack: Track is \
empty.\", this);\n      valid = false;\n    }\n    let prevTime = null;\n    \
for (let i = 0; i !== nKeys; i++) {\n      const currTime = times[i];\n      \
if (typeof currTime === \"number\" && isNaN(currTime)) {\n        \
console.error(\"THREE.KeyframeTrack: Time is not a valid number.\", this, i, \
currTime);\n        valid = false;\n        break;\n      }\n      if \
(prevTime !== null && prevTime > currTime) {\n        \
console.error(\"THREE.KeyframeTrack: Out of order keys.\", this, i, currTime, \
prevTime);\n        valid = false;\n        break;\n      }\n      prevTime = \
currTime;\n    }\n    if (values !== void 0) {\n      if \
(isTypedArray(values)) {\n        for (let i = 0, n = values.length; i !== n; \
++i) {\n          const value = values[i];\n          if (isNaN(value)) {\n   \
         console.error(\"THREE.KeyframeTrack: Value is not a valid number.\", \
this, i, value);\n            valid = false;\n            break;\n          \
}\n        }\n      }\n    }\n    return valid;\n  }\n  // removes equivalent \
sequential keys as common in morph target sequences\n  // \
(0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n  optimize() {\n    const \
times = this.times.slice(), values = this.values.slice(), stride = \
this.getValueSize(), smoothInterpolation = this.getInterpolation() === \
InterpolateSmooth, lastIndex = times.length - 1;\n    let writeIndex = 1;\n   \
 for (let i = 1; i < lastIndex; ++i) {\n      let keep = false;\n      const \
time = times[i];\n      const timeNext = times[i + 1];\n      if (time !== \
timeNext && (i !== 1 || time !== times[0])) {\n        if \
(!smoothInterpolation) {\n          const offset = i * stride, offsetP = \
offset - stride, offsetN = offset + stride;\n          for (let j = 0; j !== \
stride; ++j) {\n            const value = values[offset + j];\n            if \
(value !== values[offsetP + j] || value !== values[offsetN + j]) {\n          \
    keep = true;\n              break;\n            }\n          }\n        } \
else {\n          keep = true;\n        }\n      }\n      if (keep) {\n       \
 if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n          \
const readOffset = i * stride, writeOffset = writeIndex * stride;\n          \
for (let j = 0; j !== stride; ++j) {\n            values[writeOffset + j] = \
values[readOffset + j];\n          }\n        }\n        ++writeIndex;\n      \
}\n    }\n    if (lastIndex > 0) {\n      times[writeIndex] = \
times[lastIndex];\n      for (let readOffset = lastIndex * stride, \
writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n        \
values[writeOffset + j] = values[readOffset + j];\n      }\n      \
++writeIndex;\n    }\n    if (writeIndex !== times.length) {\n      \
this.times = times.slice(0, writeIndex);\n      this.values = values.slice(0, \
writeIndex * stride);\n    } else {\n      this.times = times;\n      \
this.values = values;\n    }\n    return this;\n  }\n  clone() {\n    const \
times = this.times.slice();\n    const values = this.values.slice();\n    \
const TypedKeyframeTrack = this.constructor;\n    const track = new \
TypedKeyframeTrack(this.name, times, values);\n    track.createInterpolant = \
this.createInterpolant;\n    return track;\n  \
}\n};\nKeyframeTrack.prototype.TimeBufferType = \
Float32Array;\nKeyframeTrack.prototype.ValueBufferType = \
Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = \
InterpolateLinear;\nvar BooleanKeyframeTrack = class extends KeyframeTrack \
{\n  // No interpolation parameter because only InterpolateDiscrete is \
valid.\n  constructor(name, times, values) {\n    super(name, times, \
values);\n  }\n};\nBooleanKeyframeTrack.prototype.ValueTypeName = \
\"bool\";\nBooleanKeyframeTrack.prototype.ValueBufferType = \
Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = \
InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethod\
Linear = void \
0;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void \
0;\nvar ColorKeyframeTrack = class extends KeyframeTrack \
{\n};\nColorKeyframeTrack.prototype.ValueTypeName = \"color\";\nvar \
NumberKeyframeTrack = class extends KeyframeTrack \
{\n};\nNumberKeyframeTrack.prototype.ValueTypeName = \"number\";\nvar \
QuaternionLinearInterpolant = class extends Interpolant {\n  \
constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n   \
 super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  \
interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer, values = \
this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);\n   \
 let offset = i1 * stride;\n    for (let end = offset + stride; offset !== \
end; offset += 4) {\n      Quaternion.slerpFlat(result, 0, values, offset - \
stride, values, offset, alpha);\n    }\n    return result;\n  }\n};\nvar \
QuaternionKeyframeTrack = class extends KeyframeTrack {\n  \
InterpolantFactoryMethodLinear(result) {\n    return new \
QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), \
result);\n  }\n};\nQuaternionKeyframeTrack.prototype.ValueTypeName = \
\"quaternion\";\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSm\
ooth = void 0;\nvar StringKeyframeTrack = class extends KeyframeTrack {\n  // \
No interpolation parameter because only InterpolateDiscrete is valid.\n  \
constructor(name, times, values) {\n    super(name, times, values);\n  \
}\n};\nStringKeyframeTrack.prototype.ValueTypeName = \
\"string\";\nStringKeyframeTrack.prototype.ValueBufferType = \
Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = \
InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodL\
inear = void 0;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth \
= void 0;\nvar VectorKeyframeTrack = class extends KeyframeTrack \
{\n};\nVectorKeyframeTrack.prototype.ValueTypeName = \"vector\";\nvar Cache = \
{\n  enabled: false,\n  files: {},\n  add: function(key, file) {\n    if \
(this.enabled === false) return;\n    this.files[key] = file;\n  },\n  get: \
function(key) {\n    if (this.enabled === false) return;\n    return \
this.files[key];\n  },\n  remove: function(key) {\n    delete \
this.files[key];\n  },\n  clear: function() {\n    this.files = {};\n  \
}\n};\nvar LoadingManager = class {\n  constructor(onLoad, onProgress, \
onError) {\n    const scope = this;\n    let isLoading = false;\n    let \
itemsLoaded = 0;\n    let itemsTotal = 0;\n    let urlModifier = void 0;\n    \
const handlers = [];\n    this.onStart = void 0;\n    this.onLoad = onLoad;\n \
   this.onProgress = onProgress;\n    this.onError = onError;\n    \
this.itemStart = function(url) {\n      itemsTotal++;\n      if (isLoading \
=== false) {\n        if (scope.onStart !== void 0) {\n          \
scope.onStart(url, itemsLoaded, itemsTotal);\n        }\n      }\n      \
isLoading = true;\n    };\n    this.itemEnd = function(url) {\n      \
itemsLoaded++;\n      if (scope.onProgress !== void 0) {\n        \
scope.onProgress(url, itemsLoaded, itemsTotal);\n      }\n      if \
(itemsLoaded === itemsTotal) {\n        isLoading = false;\n        if \
(scope.onLoad !== void 0) {\n          scope.onLoad();\n        }\n      }\n  \
  };\n    this.itemError = function(url) {\n      if (scope.onError !== void \
0) {\n        scope.onError(url);\n      }\n    };\n    this.resolveURL = \
function(url) {\n      if (urlModifier) {\n        return urlModifier(url);\n \
     }\n      return url;\n    };\n    this.setURLModifier = \
function(transform) {\n      urlModifier = transform;\n      return this;\n   \
 };\n    this.addHandler = function(regex, loader) {\n      \
handlers.push(regex, loader);\n      return this;\n    };\n    \
this.removeHandler = function(regex) {\n      const index5 = \
handlers.indexOf(regex);\n      if (index5 !== -1) {\n        \
handlers.splice(index5, 2);\n      }\n      return this;\n    };\n    \
this.getHandler = function(file) {\n      for (let i = 0, l = \
handlers.length; i < l; i += 2) {\n        const regex = handlers[i];\n       \
 const loader = handlers[i + 1];\n        if (regex.global) regex.lastIndex = \
0;\n        if (regex.test(file)) {\n          return loader;\n        }\n    \
  }\n      return null;\n    };\n  }\n};\nvar DefaultLoadingManager = /* \
@__PURE__ */ new LoadingManager();\nvar Loader = class {\n  \
constructor(manager) {\n    this.manager = manager !== void 0 ? manager : \
DefaultLoadingManager;\n    this.crossOrigin = \"anonymous\";\n    \
this.withCredentials = false;\n    this.path = \"\";\n    this.resourcePath = \
\"\";\n    this.requestHeader = {};\n  }\n  load() {\n  }\n  loadAsync(url, \
onProgress) {\n    const scope = this;\n    return new \
Promise(function(resolve, reject) {\n      scope.load(url, resolve, \
onProgress, reject);\n    });\n  }\n  parse() {\n  }\n  \
setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    \
return this;\n  }\n  setWithCredentials(value) {\n    this.withCredentials = \
value;\n    return this;\n  }\n  setPath(path) {\n    this.path = path;\n    \
return this;\n  }\n  setResourcePath(resourcePath) {\n    this.resourcePath = \
resourcePath;\n    return this;\n  }\n  setRequestHeader(requestHeader) {\n   \
 this.requestHeader = requestHeader;\n    return this;\n  \
}\n};\nLoader.DEFAULT_MATERIAL_NAME = \"__DEFAULT\";\nvar ImageLoader = class \
extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  \
load(url, onLoad, onProgress, onError) {\n    if (this.path !== void 0) url = \
this.path + url;\n    url = this.manager.resolveURL(url);\n    const scope = \
this;\n    const cached = Cache.get(url);\n    if (cached !== void 0) {\n     \
 scope.manager.itemStart(url);\n      setTimeout(function() {\n        if \
(onLoad) onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n \
     return cached;\n    }\n    const image = createElementNS(\"img\");\n    \
function onImageLoad() {\n      removeEventListeners();\n      Cache.add(url, \
this);\n      if (onLoad) onLoad(this);\n      scope.manager.itemEnd(url);\n  \
  }\n    function onImageError(event) {\n      removeEventListeners();\n      \
if (onError) onError(event);\n      scope.manager.itemError(url);\n      \
scope.manager.itemEnd(url);\n    }\n    function removeEventListeners() {\n   \
   image.removeEventListener(\"load\", onImageLoad, false);\n      \
image.removeEventListener(\"error\", onImageError, false);\n    }\n    \
image.addEventListener(\"load\", onImageLoad, false);\n    \
image.addEventListener(\"error\", onImageError, false);\n    if (url.slice(0, \
5) !== \"data:\") {\n      if (this.crossOrigin !== void 0) image.crossOrigin \
= this.crossOrigin;\n    }\n    scope.manager.itemStart(url);\n    image.src \
= url;\n    return image;\n  }\n};\nvar TextureLoader = class extends Loader \
{\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, \
onProgress, onError) {\n    const texture2 = new Texture();\n    const loader \
= new ImageLoader(this.manager);\n    \
loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n    \
loader.load(url, function(image) {\n      texture2.image = image;\n      \
texture2.needsUpdate = true;\n      if (onLoad !== void 0) {\n        \
onLoad(texture2);\n      }\n    }, onProgress, onError);\n    return \
texture2;\n  }\n};\nvar Light = class extends Object3D {\n  \
constructor(color2, intensity = 1) {\n    super();\n    this.isLight = \
true;\n    this.type = \"Light\";\n    this.color = new Color(color2);\n    \
this.intensity = intensity;\n  }\n  dispose() {\n  }\n  copy(source, \
recursive) {\n    super.copy(source, recursive);\n    \
this.color.copy(source.color);\n    this.intensity = source.intensity;\n    \
return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n   \
 data.object.color = this.color.getHex();\n    data.object.intensity = \
this.intensity;\n    if (this.groundColor !== void 0) data.object.groundColor \
= this.groundColor.getHex();\n    if (this.distance !== void 0) \
data.object.distance = this.distance;\n    if (this.angle !== void 0) \
data.object.angle = this.angle;\n    if (this.decay !== void 0) \
data.object.decay = this.decay;\n    if (this.penumbra !== void 0) \
data.object.penumbra = this.penumbra;\n    if (this.shadow !== void 0) \
data.object.shadow = this.shadow.toJSON();\n    if (this.target !== void 0) \
data.object.target = this.target.uuid;\n    return data;\n  }\n};\nvar \
_projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();\nvar \
_lightPositionWorld$1 = /* @__PURE__ */ new Vector3();\nvar _lookTarget$1 = \
/* @__PURE__ */ new Vector3();\nvar LightShadow = class {\n  \
constructor(camera3) {\n    this.camera = camera3;\n    this.intensity = 1;\n \
   this.bias = 0;\n    this.normalBias = 0;\n    this.radius = 1;\n    \
this.blurSamples = 8;\n    this.mapSize = new Vector2(512, 512);\n    \
this.map = null;\n    this.mapPass = null;\n    this.matrix = new \
Matrix4();\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n    \
this._frustum = new Frustum();\n    this._frameExtents = new Vector2(1, 1);\n \
   this._viewportCount = 1;\n    this._viewports = [\n      new Vector4(0, 0, \
1, 1)\n    ];\n  }\n  getViewportCount() {\n    return this._viewportCount;\n \
 }\n  getFrustum() {\n    return this._frustum;\n  }\n  updateMatrices(light) \
{\n    const shadowCamera = this.camera;\n    const shadowMatrix = \
this.matrix;\n    \
_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n    \
shadowCamera.position.copy(_lightPositionWorld$1);\n    \
_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n    \
shadowCamera.lookAt(_lookTarget$1);\n    shadowCamera.updateMatrixWorld();\n  \
  _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, \
shadowCamera.matrixWorldInverse);\n    \
this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n    \
shadowMatrix.set(\n      0.5,\n      0,\n      0,\n      0.5,\n      0,\n     \
 0.5,\n      0,\n      0.5,\n      0,\n      0,\n      0.5,\n      0.5,\n     \
 0,\n      0,\n      0,\n      1\n    );\n    \
shadowMatrix.multiply(_projScreenMatrix$1);\n  }\n  \
getViewport(viewportIndex) {\n    return this._viewports[viewportIndex];\n  \
}\n  getFrameExtents() {\n    return this._frameExtents;\n  }\n  dispose() \
{\n    if (this.map) {\n      this.map.dispose();\n    }\n    if \
(this.mapPass) {\n      this.mapPass.dispose();\n    }\n  }\n  copy(source) \
{\n    this.camera = source.camera.clone();\n    this.intensity = \
source.intensity;\n    this.bias = source.bias;\n    this.radius = \
source.radius;\n    this.mapSize.copy(source.mapSize);\n    return this;\n  \
}\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  \
toJSON() {\n    const object = {};\n    if (this.intensity !== 1) \
object.intensity = this.intensity;\n    if (this.bias !== 0) object.bias = \
this.bias;\n    if (this.normalBias !== 0) object.normalBias = \
this.normalBias;\n    if (this.radius !== 1) object.radius = this.radius;\n   \
 if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = \
this.mapSize.toArray();\n    object.camera = \
this.camera.toJSON(false).object;\n    delete object.camera.matrix;\n    \
return object;\n  }\n};\nvar DirectionalLightShadow = class extends \
LightShadow {\n  constructor() {\n    super(new OrthographicCamera(-5, 5, 5, \
-5, 0.5, 500));\n    this.isDirectionalLightShadow = true;\n  }\n};\nvar \
DirectionalLight = class extends Light {\n  constructor(color2, intensity) \
{\n    super(color2, intensity);\n    this.isDirectionalLight = true;\n    \
this.type = \"DirectionalLight\";\n    \
this.position.copy(Object3D.DEFAULT_UP);\n    this.updateMatrix();\n    \
this.target = new Object3D();\n    this.shadow = new \
DirectionalLightShadow();\n  }\n  dispose() {\n    this.shadow.dispose();\n  \
}\n  copy(source) {\n    super.copy(source);\n    this.target = \
source.target.clone();\n    this.shadow = source.shadow.clone();\n    return \
this;\n  }\n};\nvar AmbientLight = class extends Light {\n  \
constructor(color2, intensity) {\n    super(color2, intensity);\n    \
this.isAmbientLight = true;\n    this.type = \"AmbientLight\";\n  }\n};\nvar \
Clock = class {\n  constructor(autoStart = true) {\n    this.autoStart = \
autoStart;\n    this.startTime = 0;\n    this.oldTime = 0;\n    \
this.elapsedTime = 0;\n    this.running = false;\n  }\n  start() {\n    \
this.startTime = now();\n    this.oldTime = this.startTime;\n    \
this.elapsedTime = 0;\n    this.running = true;\n  }\n  stop() {\n    \
this.getElapsedTime();\n    this.running = false;\n    this.autoStart = \
false;\n  }\n  getElapsedTime() {\n    this.getDelta();\n    return \
this.elapsedTime;\n  }\n  getDelta() {\n    let diff = 0;\n    if \
(this.autoStart && !this.running) {\n      this.start();\n      return 0;\n   \
 }\n    if (this.running) {\n      const newTime = now();\n      diff = \
(newTime - this.oldTime) / 1e3;\n      this.oldTime = newTime;\n      \
this.elapsedTime += diff;\n    }\n    return diff;\n  }\n};\nfunction now() \
{\n  return performance.now();\n}\nvar _RESERVED_CHARS_RE = \
\"\\\\[\\\\]\\\\.:\\\\/\";\nvar _reservedRe = new RegExp(\"[\" + \
_RESERVED_CHARS_RE + \"]\", \"g\");\nvar _wordChar = \"[^\" + \
_RESERVED_CHARS_RE + \"]\";\nvar _wordCharOrDot = \"[^\" + \
_RESERVED_CHARS_RE.replace(\"\\\\.\", \"\") + \"]\";\nvar _directoryRe = /* \
@__PURE__ */ /((?:WC+[\\/:])*)/.source.replace(\"WC\", _wordChar);\nvar \
_nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace(\"WCOD\", \
_wordCharOrDot);\nvar _objectRe = /* @__PURE__ */ \
/(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace(\"WC\", _wordChar);\nvar \
_propertyRe = /* @__PURE__ */ \
/\\.(WC+)(?:\\[(.+)\\])?/.source.replace(\"WC\", _wordChar);\nvar _trackRe = \
new RegExp(\n  \"^\" + _directoryRe + _nodeRe + _objectRe + _propertyRe + \
\"$\"\n);\nvar _supportedObjectNames = [\"material\", \"materials\", \
\"bones\", \"map\"];\nvar Composite = class {\n  constructor(targetGroup, \
path, optionalParsedPath) {\n    const parsedPath = optionalParsedPath || \
PropertyBinding.parseTrackName(path);\n    this._targetGroup = targetGroup;\n \
   this._bindings = targetGroup.subscribe_(path, parsedPath);\n  }\n  \
getValue(array, offset) {\n    this.bind();\n    const firstValidIndex = \
this._targetGroup.nCachedObjects_, binding = \
this._bindings[firstValidIndex];\n    if (binding !== void 0) \
binding.getValue(array, offset);\n  }\n  setValue(array, offset) {\n    const \
bindings = this._bindings;\n    for (let i = \
this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n     \
 bindings[i].setValue(array, offset);\n    }\n  }\n  bind() {\n    const \
bindings = this._bindings;\n    for (let i = \
this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n     \
 bindings[i].bind();\n    }\n  }\n  unbind() {\n    const bindings = \
this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = \
bindings.length; i !== n; ++i) {\n      bindings[i].unbind();\n    }\n  \
}\n};\nvar PropertyBinding = class _PropertyBinding {\n  \
constructor(rootNode, path, parsedPath) {\n    this.path = path;\n    \
this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);\n    \
this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);\n  \
  this.rootNode = rootNode;\n    this.getValue = this._getValue_unbound;\n    \
this.setValue = this._setValue_unbound;\n  }\n  static create(root2, path, \
parsedPath) {\n    if (!(root2 && root2.isAnimationObjectGroup)) {\n      \
return new _PropertyBinding(root2, path, parsedPath);\n    } else {\n      \
return new _PropertyBinding.Composite(root2, path, parsedPath);\n    }\n  }\n \
 /**\n   * Replaces spaces with underscores and removes unsupported \
characters from\n   * node names, to ensure compatibility with \
parseTrackName().\n   *\n   * @param {string} name Node name to be \
sanitized.\n   * @return {string}\n   */\n  static sanitizeNodeName(name) {\n \
   return name.replace(/\\s/g, \"_\").replace(_reservedRe, \"\");\n  }\n  \
static parseTrackName(trackName) {\n    const matches = \
_trackRe.exec(trackName);\n    if (matches === null) {\n      throw new \
Error(\"PropertyBinding: Cannot parse trackName: \" + trackName);\n    }\n    \
const results = {\n      // directoryName: matches[ 1 ], // (tschw) currently \
unused\n      nodeName: matches[2],\n      objectName: matches[3],\n      \
objectIndex: matches[4],\n      propertyName: matches[5],\n      // \
required\n      propertyIndex: matches[6]\n    };\n    const lastDot = \
results.nodeName && results.nodeName.lastIndexOf(\".\");\n    if (lastDot !== \
void 0 && lastDot !== -1) {\n      const objectName = \
results.nodeName.substring(lastDot + 1);\n      if \
(_supportedObjectNames.indexOf(objectName) !== -1) {\n        \
results.nodeName = results.nodeName.substring(0, lastDot);\n        \
results.objectName = objectName;\n      }\n    }\n    if \
(results.propertyName === null || results.propertyName.length === 0) {\n      \
throw new Error(\"PropertyBinding: can not parse propertyName from trackName: \
\" + trackName);\n    }\n    return results;\n  }\n  static findNode(root2, \
nodeName) {\n    if (nodeName === void 0 || nodeName === \"\" || nodeName === \
\".\" || nodeName === -1 || nodeName === root2.name || nodeName === \
root2.uuid) {\n      return root2;\n    }\n    if (root2.skeleton) {\n      \
const bone = root2.skeleton.getBoneByName(nodeName);\n      if (bone !== void \
0) {\n        return bone;\n      }\n    }\n    if (root2.children) {\n      \
const searchNodeSubtree = function(children) {\n        for (let i = 0; i < \
children.length; i++) {\n          const childNode = children[i];\n          \
if (childNode.name === nodeName || childNode.uuid === nodeName) {\n           \
 return childNode;\n          }\n          const result = \
searchNodeSubtree(childNode.children);\n          if (result) return \
result;\n        }\n        return null;\n      };\n      const subTreeNode = \
searchNodeSubtree(root2.children);\n      if (subTreeNode) {\n        return \
subTreeNode;\n      }\n    }\n    return null;\n  }\n  // these are used to \
\"bind\" a nonexistent property\n  _getValue_unavailable() {\n  }\n  \
_setValue_unavailable() {\n  }\n  // Getters\n  _getValue_direct(buffer2, \
offset) {\n    buffer2[offset] = this.targetObject[this.propertyName];\n  }\n \
 _getValue_array(buffer2, offset) {\n    const source = \
this.resolvedProperty;\n    for (let i = 0, n = source.length; i !== n; ++i) \
{\n      buffer2[offset++] = source[i];\n    }\n  }\n  \
_getValue_arrayElement(buffer2, offset) {\n    buffer2[offset] = \
this.resolvedProperty[this.propertyIndex];\n  }\n  _getValue_toArray(buffer2, \
offset) {\n    this.resolvedProperty.toArray(buffer2, offset);\n  }\n  // \
Direct\n  _setValue_direct(buffer2, offset) {\n    \
this.targetObject[this.propertyName] = buffer2[offset];\n  }\n  \
_setValue_direct_setNeedsUpdate(buffer2, offset) {\n    \
this.targetObject[this.propertyName] = buffer2[offset];\n    \
this.targetObject.needsUpdate = true;\n  }\n  \
_setValue_direct_setMatrixWorldNeedsUpdate(buffer2, offset) {\n    \
this.targetObject[this.propertyName] = buffer2[offset];\n    \
this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  // EntireArray\n  \
_setValue_array(buffer2, offset) {\n    const dest = this.resolvedProperty;\n \
   for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = \
buffer2[offset++];\n    }\n  }\n  _setValue_array_setNeedsUpdate(buffer2, \
offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = \
dest.length; i !== n; ++i) {\n      dest[i] = buffer2[offset++];\n    }\n    \
this.targetObject.needsUpdate = true;\n  }\n  \
_setValue_array_setMatrixWorldNeedsUpdate(buffer2, offset) {\n    const dest \
= this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) \
{\n      dest[i] = buffer2[offset++];\n    }\n    \
this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  // ArrayElement\n  \
_setValue_arrayElement(buffer2, offset) {\n    \
this.resolvedProperty[this.propertyIndex] = buffer2[offset];\n  }\n  \
_setValue_arrayElement_setNeedsUpdate(buffer2, offset) {\n    \
this.resolvedProperty[this.propertyIndex] = buffer2[offset];\n    \
this.targetObject.needsUpdate = true;\n  }\n  \
_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer2, offset) {\n    \
this.resolvedProperty[this.propertyIndex] = buffer2[offset];\n    \
this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  // HasToFromArray\n  \
_setValue_fromArray(buffer2, offset) {\n    \
this.resolvedProperty.fromArray(buffer2, offset);\n  }\n  \
_setValue_fromArray_setNeedsUpdate(buffer2, offset) {\n    \
this.resolvedProperty.fromArray(buffer2, offset);\n    \
this.targetObject.needsUpdate = true;\n  }\n  \
_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer2, offset) {\n    \
this.resolvedProperty.fromArray(buffer2, offset);\n    \
this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  \
_getValue_unbound(targetArray, offset) {\n    this.bind();\n    \
this.getValue(targetArray, offset);\n  }\n  _setValue_unbound(sourceArray, \
offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  }\n  \
// create getter / setter pair for a property in the scene graph\n  bind() \
{\n    let targetObject = this.node;\n    const parsedPath = \
this.parsedPath;\n    const objectName = parsedPath.objectName;\n    const \
propertyName = parsedPath.propertyName;\n    let propertyIndex = \
parsedPath.propertyIndex;\n    if (!targetObject) {\n      targetObject = \
_PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);\n      \
this.node = targetObject;\n    }\n    this.getValue = \
this._getValue_unavailable;\n    this.setValue = \
this._setValue_unavailable;\n    if (!targetObject) {\n      \
console.warn(\"THREE.PropertyBinding: No target node found for track: \" + \
this.path + \".\");\n      return;\n    }\n    if (objectName) {\n      let \
objectIndex = parsedPath.objectIndex;\n      switch (objectName) {\n        \
case \"materials\":\n          if (!targetObject.material) {\n            \
console.error(\"THREE.PropertyBinding: Can not bind to material as node does \
not have a material.\", this);\n            return;\n          }\n          \
if (!targetObject.material.materials) {\n            \
console.error(\"THREE.PropertyBinding: Can not bind to material.materials as \
node.material does not have a materials array.\", this);\n            \
return;\n          }\n          targetObject = \
targetObject.material.materials;\n          break;\n        case \"bones\":\n \
         if (!targetObject.skeleton) {\n            \
console.error(\"THREE.PropertyBinding: Can not bind to bones as node does not \
have a skeleton.\", this);\n            return;\n          }\n          \
targetObject = targetObject.skeleton.bones;\n          for (let i = 0; i < \
targetObject.length; i++) {\n            if (targetObject[i].name === \
objectIndex) {\n              objectIndex = i;\n              break;\n        \
    }\n          }\n          break;\n        case \"map\":\n          if \
(\"map\" in targetObject) {\n            targetObject = targetObject.map;\n   \
         break;\n          }\n          if (!targetObject.material) {\n       \
     console.error(\"THREE.PropertyBinding: Can not bind to material as node \
does not have a material.\", this);\n            return;\n          }\n       \
   if (!targetObject.material.map) {\n            \
console.error(\"THREE.PropertyBinding: Can not bind to material.map as \
node.material does not have a map.\", this);\n            return;\n          \
}\n          targetObject = targetObject.material.map;\n          break;\n    \
    default:\n          if (targetObject[objectName] === void 0) {\n          \
  console.error(\"THREE.PropertyBinding: Can not bind to objectName of node \
undefined.\", this);\n            return;\n          }\n          \
targetObject = targetObject[objectName];\n      }\n      if (objectIndex !== \
void 0) {\n        if (targetObject[objectIndex] === void 0) {\n          \
console.error(\"THREE.PropertyBinding: Trying to bind to objectIndex of \
objectName, but is undefined.\", this, targetObject);\n          return;\n    \
    }\n        targetObject = targetObject[objectIndex];\n      }\n    }\n    \
const nodeProperty = targetObject[propertyName];\n    if (nodeProperty === \
void 0) {\n      const nodeName = parsedPath.nodeName;\n      \
console.error(\"THREE.PropertyBinding: Trying to update property for track: \
\" + nodeName + \".\" + propertyName + \" but it wasn't found.\", \
targetObject);\n      return;\n    }\n    let versioning = \
this.Versioning.None;\n    this.targetObject = targetObject;\n    if \
(targetObject.needsUpdate !== void 0) {\n      versioning = \
this.Versioning.NeedsUpdate;\n    } else if \
(targetObject.matrixWorldNeedsUpdate !== void 0) {\n      versioning = \
this.Versioning.MatrixWorldNeedsUpdate;\n    }\n    let bindingType = \
this.BindingType.Direct;\n    if (propertyIndex !== void 0) {\n      if \
(propertyName === \"morphTargetInfluences\") {\n        if \
(!targetObject.geometry) {\n          console.error(\"THREE.PropertyBinding: \
Can not bind to morphTargetInfluences because node does not have a \
geometry.\", this);\n          return;\n        }\n        if \
(!targetObject.geometry.morphAttributes) {\n          \
console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences \
because node does not have a geometry.morphAttributes.\", this);\n          \
return;\n        }\n        if \
(targetObject.morphTargetDictionary[propertyIndex] !== void 0) {\n          \
propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n        \
}\n      }\n      bindingType = this.BindingType.ArrayElement;\n      \
this.resolvedProperty = nodeProperty;\n      this.propertyIndex = \
propertyIndex;\n    } else if (nodeProperty.fromArray !== void 0 && \
nodeProperty.toArray !== void 0) {\n      bindingType = \
this.BindingType.HasFromToArray;\n      this.resolvedProperty = \
nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      \
bindingType = this.BindingType.EntireArray;\n      this.resolvedProperty = \
nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    }\n \
   this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue \
= this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  }\n  \
unbind() {\n    this.node = null;\n    this.getValue = \
this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  \
}\n};\nPropertyBinding.Composite = \
Composite;\nPropertyBinding.prototype.BindingType = {\n  Direct: 0,\n  \
EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: \
3\n};\nPropertyBinding.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: \
1,\n  MatrixWorldNeedsUpdate: \
2\n};\nPropertyBinding.prototype.GetterByBindingType = [\n  \
PropertyBinding.prototype._getValue_direct,\n  \
PropertyBinding.prototype._getValue_array,\n  \
PropertyBinding.prototype._getValue_arrayElement,\n  \
PropertyBinding.prototype._getValue_toArray\n];\nPropertyBinding.prototype.Se\
tterByBindingTypeAndVersioning = [\n  [\n    // Direct\n    \
PropertyBinding.prototype._setValue_direct,\n    \
PropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n    \
PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate\n  ],\n  \
[\n    // EntireArray\n    PropertyBinding.prototype._setValue_array,\n    \
PropertyBinding.prototype._setValue_array_setNeedsUpdate,\n    \
PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate\n  ],\n  \
[\n    // ArrayElement\n    \
PropertyBinding.prototype._setValue_arrayElement,\n    \
PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n    \
PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate\n  \
],\n  [\n    // HasToFromArray\n    \
PropertyBinding.prototype._setValue_fromArray,\n    \
PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n    \
PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate\n  \
]\n];\nvar _controlInterpolantsResultBuffer = new Float32Array(1);\nvar \
_matrix = /* @__PURE__ */ new Matrix4();\nvar Raycaster = class {\n  \
constructor(origin, direction2, near = 0, far = Infinity) {\n    this.ray = \
new Ray(origin, direction2);\n    this.near = near;\n    this.far = far;\n    \
this.camera = null;\n    this.layers = new Layers();\n    this.params = {\n   \
   Mesh: {},\n      Line: { threshold: 1 },\n      LOD: {},\n      Points: { \
threshold: 1 },\n      Sprite: {}\n    };\n  }\n  set(origin, direction2) {\n \
   this.ray.set(origin, direction2);\n  }\n  setFromCamera(coords, camera3) \
{\n    if (camera3.isPerspectiveCamera) {\n      \
this.ray.origin.setFromMatrixPosition(camera3.matrixWorld);\n      \
this.ray.direction.set(coords.x, coords.y, \
0.5).unproject(camera3).sub(this.ray.origin).normalize();\n      this.camera \
= camera3;\n    } else if (camera3.isOrthographicCamera) {\n      \
this.ray.origin.set(coords.x, coords.y, (camera3.near + camera3.far) / \
(camera3.near - camera3.far)).unproject(camera3);\n      \
this.ray.direction.set(0, 0, -1).transformDirection(camera3.matrixWorld);\n   \
   this.camera = camera3;\n    } else {\n      \
console.error(\"THREE.Raycaster: Unsupported camera type: \" + \
camera3.type);\n    }\n  }\n  setFromXRController(controller) {\n    \
_matrix.identity().extractRotation(controller.matrixWorld);\n    \
this.ray.origin.setFromMatrixPosition(controller.matrixWorld);\n    \
this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);\n    return this;\n  \
}\n  intersectObject(object, recursive = true, intersects = []) {\n    \
intersect(object, this, intersects, recursive);\n    \
intersects.sort(ascSort);\n    return intersects;\n  }\n  \
intersectObjects(objects, recursive = true, intersects = []) {\n    for (let \
i = 0, l = objects.length; i < l; i++) {\n      intersect(objects[i], this, \
intersects, recursive);\n    }\n    intersects.sort(ascSort);\n    return \
intersects;\n  }\n};\nfunction ascSort(a2, b) {\n  return a2.distance - \
b.distance;\n}\nfunction intersect(object, raycaster, intersects, recursive) \
{\n  let propagate = true;\n  if (object.layers.test(raycaster.layers)) {\n   \
 const result = object.raycast(raycaster, intersects);\n    if (result === \
false) propagate = false;\n  }\n  if (propagate === true && recursive === \
true) {\n    const children = object.children;\n    for (let i = 0, l = \
children.length; i < l; i++) {\n      intersect(children[i], raycaster, \
intersects, true);\n    }\n  }\n}\nvar Spherical = class {\n  \
constructor(radius = 1, phi = 0, theta = 0) {\n    this.radius = radius;\n    \
this.phi = phi;\n    this.theta = theta;\n    return this;\n  }\n  \
set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n   \
 this.theta = theta;\n    return this;\n  }\n  copy(other) {\n    this.radius \
= other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n   \
 return this;\n  }\n  // restrict phi to be between EPS and PI-EPS\n  \
makeSafe() {\n    const EPS = 1e-6;\n    this.phi = Math.max(EPS, \
Math.min(Math.PI - EPS, this.phi));\n    return this;\n  }\n  \
setFromVector3(v) {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n \
 }\n  setFromCartesianCoords(x2, y2, z2) {\n    this.radius = Math.sqrt(x2 * \
x2 + y2 * y2 + z2 * z2);\n    if (this.radius === 0) {\n      this.theta = \
0;\n      this.phi = 0;\n    } else {\n      this.theta = Math.atan2(x2, \
z2);\n      this.phi = Math.acos(clamp(y2 / this.radius, -1, 1));\n    }\n    \
return this;\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n};\nvar Controls = class extends \
EventDispatcher {\n  constructor(object, domElement = null) {\n    super();\n \
   this.object = object;\n    this.domElement = domElement;\n    this.enabled \
= true;\n    this.state = -1;\n    this.keys = {};\n    this.mouseButtons = { \
LEFT: null, MIDDLE: null, RIGHT: null };\n    this.touches = { ONE: null, \
TWO: null };\n  }\n  connect() {\n  }\n  disconnect() {\n  }\n  dispose() {\n \
 }\n  update() {\n  }\n};\nif (typeof __THREE_DEVTOOLS__ !== \"undefined\") \
{\n  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"register\", { detail: \
{\n    revision: REVISION\n  } }));\n}\nif (typeof window !== \"undefined\") \
{\n  if (window.__THREE__) {\n    console.warn(\"WARNING: Multiple instances \
of Three.js being imported.\");\n  } else {\n    window.__THREE__ = \
REVISION;\n  }\n}\n\n// \
../../node_modules/three/examples/jsm/controls/DragControls.js\nvar _plane = \
new Plane();\nvar _pointer = new Vector2();\nvar _offset2 = new \
Vector3();\nvar _diff2 = new Vector2();\nvar _previousPointer = new \
Vector2();\nvar _intersection = new Vector3();\nvar _worldPosition = new \
Vector3();\nvar _inverseMatrix = new Matrix4();\nvar _up = new \
Vector3();\nvar _right = new Vector3();\nvar _selected = null;\nvar _hovered \
= null;\nvar _intersections = [];\nvar STATE = {\n  NONE: -1,\n  PAN: 0,\n  \
ROTATE: 1\n};\nvar DragControls = class extends Controls {\n  \
constructor(objects, camera3, domElement = null) {\n    super(camera3, \
domElement);\n    this.objects = objects;\n    this.recursive = true;\n    \
this.transformGroup = false;\n    this.rotateSpeed = 1;\n    this.raycaster = \
new Raycaster();\n    this.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: \
MOUSE.PAN, RIGHT: MOUSE.ROTATE };\n    this.touches = { ONE: TOUCH.PAN };\n   \
 this._onPointerMove = onPointerMove.bind(this);\n    this._onPointerDown = \
onPointerDown.bind(this);\n    this._onPointerCancel = \
onPointerCancel.bind(this);\n    this._onContextMenu = \
onContextMenu.bind(this);\n    if (domElement !== null) {\n      \
this.connect();\n    }\n  }\n  connect() {\n    \
this.domElement.addEventListener(\"pointermove\", this._onPointerMove);\n    \
this.domElement.addEventListener(\"pointerdown\", this._onPointerDown);\n    \
this.domElement.addEventListener(\"pointerup\", this._onPointerCancel);\n    \
this.domElement.addEventListener(\"pointerleave\", this._onPointerCancel);\n  \
  this.domElement.addEventListener(\"contextmenu\", this._onContextMenu);\n   \
 this.domElement.style.touchAction = \"none\";\n  }\n  disconnect() {\n    \
this.domElement.removeEventListener(\"pointermove\", this._onPointerMove);\n  \
  this.domElement.removeEventListener(\"pointerdown\", \
this._onPointerDown);\n    this.domElement.removeEventListener(\"pointerup\", \
this._onPointerCancel);\n    \
this.domElement.removeEventListener(\"pointerleave\", \
this._onPointerCancel);\n    \
this.domElement.removeEventListener(\"contextmenu\", this._onContextMenu);\n  \
  this.domElement.style.touchAction = \"auto\";\n    \
this.domElement.style.cursor = \"\";\n  }\n  dispose() {\n    \
this.disconnect();\n  }\n  _updatePointer(event) {\n    const rect = \
this.domElement.getBoundingClientRect();\n    _pointer.x = (event.clientX - \
rect.left) / rect.width * 2 - 1;\n    _pointer.y = -(event.clientY - \
rect.top) / rect.height * 2 + 1;\n  }\n  _updateState(event) {\n    let \
action;\n    if (event.pointerType === \"touch\") {\n      action = \
this.touches.ONE;\n    } else {\n      switch (event.button) {\n        case \
0:\n          action = this.mouseButtons.LEFT;\n          break;\n        \
case 1:\n          action = this.mouseButtons.MIDDLE;\n          break;\n     \
   case 2:\n          action = this.mouseButtons.RIGHT;\n          break;\n   \
     default:\n          action = null;\n      }\n    }\n    switch (action) \
{\n      case MOUSE.PAN:\n      case TOUCH.PAN:\n        this.state = \
STATE.PAN;\n        break;\n      case MOUSE.ROTATE:\n      case \
TOUCH.ROTATE:\n        this.state = STATE.ROTATE;\n        break;\n      \
default:\n        this.state = STATE.NONE;\n    }\n  }\n  getRaycaster() {\n  \
  console.warn(\"THREE.DragControls: getRaycaster() has been deprecated. Use \
controls.raycaster instead.\");\n    return this.raycaster;\n  }\n  \
setObjects(objects) {\n    console.warn(\"THREE.DragControls: setObjects() \
has been deprecated. Use controls.objects instead.\");\n    this.objects = \
objects;\n  }\n  getObjects() {\n    console.warn(\"THREE.DragControls: \
getObjects() has been deprecated. Use controls.objects instead.\");\n    \
return this.objects;\n  }\n  activate() {\n    \
console.warn(\"THREE.DragControls: activate() has been renamed to \
connect().\");\n    this.connect();\n  }\n  deactivate() {\n    \
console.warn(\"THREE.DragControls: deactivate() has been renamed to \
disconnect().\");\n    this.disconnect();\n  }\n  set mode(value) {\n    \
console.warn(\"THREE.DragControls: The .mode property has been removed. \
Define the type of transformation via the .mouseButtons or .touches \
properties.\");\n  }\n  get mode() {\n    console.warn(\"THREE.DragControls: \
The .mode property has been removed. Define the type of transformation via \
the .mouseButtons or .touches properties.\");\n  }\n};\nfunction \
onPointerMove(event) {\n  const camera3 = this.object;\n  const domElement = \
this.domElement;\n  const raycaster = this.raycaster;\n  if (this.enabled === \
false) return;\n  this._updatePointer(event);\n  \
raycaster.setFromCamera(_pointer, camera3);\n  if (_selected) {\n    if \
(this.state === STATE.PAN) {\n      if (raycaster.ray.intersectPlane(_plane, \
_intersection)) {\n        \
_selected.position.copy(_intersection.sub(_offset2).applyMatrix4(_inverseMatr\
ix));\n      }\n    } else if (this.state === STATE.ROTATE) {\n      \
_diff2.subVectors(_pointer, \
_previousPointer).multiplyScalar(this.rotateSpeed);\n      \
_selected.rotateOnWorldAxis(_up, _diff2.x);\n      \
_selected.rotateOnWorldAxis(_right.normalize(), -_diff2.y);\n    }\n    \
this.dispatchEvent({ type: \"drag\", object: _selected });\n    \
_previousPointer.copy(_pointer);\n  } else {\n    if (event.pointerType === \
\"mouse\" || event.pointerType === \"pen\") {\n      _intersections.length = \
0;\n      raycaster.setFromCamera(_pointer, camera3);\n      \
raycaster.intersectObjects(this.objects, this.recursive, _intersections);\n   \
   if (_intersections.length > 0) {\n        const object = \
_intersections[0].object;\n        \
_plane.setFromNormalAndCoplanarPoint(camera3.getWorldDirection(_plane.normal)\
, _worldPosition.setFromMatrixPosition(object.matrixWorld));\n        if \
(_hovered !== object && _hovered !== null) {\n          this.dispatchEvent({ \
type: \"hoveroff\", object: _hovered });\n          domElement.style.cursor = \
\"auto\";\n          _hovered = null;\n        }\n        if (_hovered !== \
object) {\n          this.dispatchEvent({ type: \"hoveron\", object });\n     \
     domElement.style.cursor = \"pointer\";\n          _hovered = object;\n   \
     }\n      } else {\n        if (_hovered !== null) {\n          \
this.dispatchEvent({ type: \"hoveroff\", object: _hovered });\n          \
domElement.style.cursor = \"auto\";\n          _hovered = null;\n        }\n  \
    }\n    }\n  }\n  _previousPointer.copy(_pointer);\n}\nfunction \
onPointerDown(event) {\n  const camera3 = this.object;\n  const domElement = \
this.domElement;\n  const raycaster = this.raycaster;\n  if (this.enabled === \
false) return;\n  this._updatePointer(event);\n  this._updateState(event);\n  \
_intersections.length = 0;\n  raycaster.setFromCamera(_pointer, camera3);\n  \
raycaster.intersectObjects(this.objects, this.recursive, _intersections);\n  \
if (_intersections.length > 0) {\n    if (this.transformGroup === true) {\n   \
   _selected = findGroup(_intersections[0].object);\n    } else {\n      \
_selected = _intersections[0].object;\n    }\n    \
_plane.setFromNormalAndCoplanarPoint(camera3.getWorldDirection(_plane.normal)\
, _worldPosition.setFromMatrixPosition(_selected.matrixWorld));\n    if \
(raycaster.ray.intersectPlane(_plane, _intersection)) {\n      if (this.state \
=== STATE.PAN) {\n        \
_inverseMatrix.copy(_selected.parent.matrixWorld).invert();\n        \
_offset2.copy(_intersection).sub(_worldPosition.setFromMatrixPosition(_select\
ed.matrixWorld));\n      } else if (this.state === STATE.ROTATE) {\n        \
_up.set(0, 1, 0).applyQuaternion(camera3.quaternion).normalize();\n        \
_right.set(1, 0, 0).applyQuaternion(camera3.quaternion).normalize();\n      \
}\n    }\n    domElement.style.cursor = \"move\";\n    this.dispatchEvent({ \
type: \"dragstart\", object: _selected });\n  }\n  \
_previousPointer.copy(_pointer);\n}\nfunction onPointerCancel() {\n  if \
(this.enabled === false) return;\n  if (_selected) {\n    \
this.dispatchEvent({ type: \"dragend\", object: _selected });\n    _selected \
= null;\n  }\n  this.domElement.style.cursor = _hovered ? \"pointer\" : \
\"auto\";\n  this.state = STATE.NONE;\n}\nfunction onContextMenu(event) {\n  \
if (this.enabled === false) return;\n  event.preventDefault();\n}\nfunction \
findGroup(obj, group = null) {\n  if (obj.isGroup) group = obj;\n  if \
(obj.parent === null) return group;\n  return findGroup(obj.parent, \
group);\n}\n\n// ../../node_modules/d3-force-3d/src/center.js\nfunction \
center_default(x2, y2, z2) {\n  var nodes, strength = 1;\n  if (x2 == null) \
x2 = 0;\n  if (y2 == null) y2 = 0;\n  if (z2 == null) z2 = 0;\n  function \
force() {\n    var i, n = nodes.length, node, sx = 0, sy = 0, sz = 0;\n    \
for (i = 0; i < n; ++i) {\n      node = nodes[i], sx += node.x || 0, sy += \
node.y || 0, sz += node.z || 0;\n    }\n    for (sx = (sx / n - x2) * \
strength, sy = (sy / n - y2) * strength, sz = (sz / n - z2) * strength, i = \
0; i < n; ++i) {\n      node = nodes[i];\n      if (sx) {\n        node.x -= \
sx;\n      }\n      if (sy) {\n        node.y -= sy;\n      }\n      if (sz) \
{\n        node.z -= sz;\n      }\n    }\n  }\n  force.initialize = \
function(_) {\n    nodes = _;\n  };\n  force.x = function(_) {\n    return \
arguments.length ? (x2 = +_, force) : x2;\n  };\n  force.y = function(_) {\n  \
  return arguments.length ? (y2 = +_, force) : y2;\n  };\n  force.z = \
function(_) {\n    return arguments.length ? (z2 = +_, force) : z2;\n  };\n  \
force.strength = function(_) {\n    return arguments.length ? (strength = +_, \
force) : strength;\n  };\n  return force;\n}\n\n// \
../../node_modules/d3-binarytree/src/add.js\nfunction add_default(d) {\n  \
const x2 = +this._x.call(null, d);\n  return add(this.cover(x2), x2, \
d);\n}\nfunction add(tree, x2, d) {\n  if (isNaN(x2)) return tree;\n  var \
parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, x1 = tree._x1, \
xm, xp, right, i, j;\n  if (!node) return tree._root = leaf, tree;\n  while \
(node.length) {\n    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;\n    \
else x1 = xm;\n    if (parent = node, !(node = node[i = +right])) return \
parent[i] = leaf, tree;\n  }\n  xp = +tree._x.call(null, node.data);\n  if \
(x2 === xp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = \
leaf, tree;\n  do {\n    parent = parent ? parent[i] = new Array(2) : \
tree._root = new Array(2);\n    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = \
xm;\n    else x1 = xm;\n  } while ((i = +right) === (j = +(xp >= xm)));\n  \
return parent[j] = node, parent[i] = leaf, tree;\n}\nfunction addAll(data) \
{\n  if (!Array.isArray(data)) data = Array.from(data);\n  const n = \
data.length;\n  const xz = new Float64Array(n);\n  let x0 = Infinity, x1 = \
-Infinity;\n  for (let i = 0, x2; i < n; ++i) {\n    if (isNaN(x2 = \
+this._x.call(null, data[i]))) continue;\n    xz[i] = x2;\n    if (x2 < x0) \
x0 = x2;\n    if (x2 > x1) x1 = x2;\n  }\n  if (x0 > x1) return this;\n  \
this.cover(x0).cover(x1);\n  for (let i = 0; i < n; ++i) {\n    add(this, \
xz[i], data[i]);\n  }\n  return this;\n}\n\n// \
../../node_modules/d3-binarytree/src/cover.js\nfunction cover_default(x2) {\n \
 if (isNaN(x2 = +x2)) return this;\n  var x0 = this._x0, x1 = this._x1;\n  if \
(isNaN(x0)) {\n    x1 = (x0 = Math.floor(x2)) + 1;\n  } else {\n    var z2 = \
x1 - x0 || 1, node = this._root, parent, i;\n    while (x0 > x2 || x2 >= x1) \
{\n      i = +(x2 < x0);\n      parent = new Array(2), parent[i] = node, node \
= parent, z2 *= 2;\n      switch (i) {\n        case 0:\n          x1 = x0 + \
z2;\n          break;\n        case 1:\n          x0 = x1 - z2;\n          \
break;\n      }\n    }\n    if (this._root && this._root.length) this._root = \
node;\n  }\n  this._x0 = x0;\n  this._x1 = x1;\n  return this;\n}\n\n// \
../../node_modules/d3-binarytree/src/data.js\nfunction data_default() {\n  \
var data = [];\n  this.visit(function(node) {\n    if (!node.length) do\n     \
 data.push(node.data);\n    while (node = node.next);\n  });\n  return \
data;\n}\n\n// ../../node_modules/d3-binarytree/src/extent.js\nfunction \
extent_default(_) {\n  return arguments.length ? \
this.cover(+_[0][0]).cover(+_[1][0]) : isNaN(this._x0) ? void 0 : \
[[this._x0], [this._x1]];\n}\n\n// \
../../node_modules/d3-binarytree/src/half.js\nfunction half_default(node, x0, \
x1) {\n  this.node = node;\n  this.x0 = x0;\n  this.x1 = x1;\n}\n\n// \
../../node_modules/d3-binarytree/src/find.js\nfunction find_default(x2, \
radius) {\n  var data, x0 = this._x0, x1, x22, x3 = this._x1, halves = [], \
node = this._root, q, i;\n  if (node) halves.push(new half_default(node, x0, \
x3));\n  if (radius == null) radius = Infinity;\n  else {\n    x0 = x2 - \
radius;\n    x3 = x2 + radius;\n  }\n  while (q = halves.pop()) {\n    if \
(!(node = q.node) || (x1 = q.x0) > x3 || (x22 = q.x1) < x0) continue;\n    if \
(node.length) {\n      var xm = (x1 + x22) / 2;\n      halves.push(\n        \
new half_default(node[1], xm, x22),\n        new half_default(node[0], x1, \
xm)\n      );\n      if (i = +(x2 >= xm)) {\n        q = halves[halves.length \
- 1];\n        halves[halves.length - 1] = halves[halves.length - 1 - i];\n   \
     halves[halves.length - 1 - i] = q;\n      }\n    } else {\n      var d = \
Math.abs(x2 - +this._x.call(null, node.data));\n      if (d < radius) {\n     \
   radius = d;\n        x0 = x2 - d;\n        x3 = x2 + d;\n        data = \
node.data;\n      }\n    }\n  }\n  return data;\n}\n\n// \
../../node_modules/d3-binarytree/src/remove.js\nfunction remove_default(d) \
{\n  if (isNaN(x2 = +this._x.call(null, d))) return this;\n  var parent, node \
= this._root, retainer, previous, next, x0 = this._x0, x1 = this._x1, x2, xm, \
right, i, j;\n  if (!node) return this;\n  if (node.length) while (true) {\n  \
  if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;\n    else x1 = xm;\n    if \
(!(parent = node, node = node[i = +right])) return this;\n    if \
(!node.length) break;\n    if (parent[i + 1 & 1]) retainer = parent, j = i;\n \
 }\n  while (node.data !== d) if (!(previous = node, node = node.next)) \
return this;\n  if (next = node.next) delete node.next;\n  if (previous) \
return next ? previous.next = next : delete previous.next, this;\n  if \
(!parent) return this._root = next, this;\n  next ? parent[i] = next : delete \
parent[i];\n  if ((node = parent[0] || parent[1]) && node === (parent[1] || \
parent[0]) && !node.length) {\n    if (retainer) retainer[j] = node;\n    \
else this._root = node;\n  }\n  return this;\n}\nfunction removeAll(data) {\n \
 for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n  return \
this;\n}\n\n// ../../node_modules/d3-binarytree/src/root.js\nfunction \
root_default() {\n  return this._root;\n}\n\n// \
../../node_modules/d3-binarytree/src/size.js\nfunction size_default() {\n  \
var size = 0;\n  this.visit(function(node) {\n    if (!node.length) do\n      \
++size;\n    while (node = node.next);\n  });\n  return size;\n}\n\n// \
../../node_modules/d3-binarytree/src/visit.js\nfunction \
visit_default(callback) {\n  var halves = [], q, node = this._root, child, \
x0, x1;\n  if (node) halves.push(new half_default(node, this._x0, \
this._x1));\n  while (q = halves.pop()) {\n    if (!callback(node = q.node, \
x0 = q.x0, x1 = q.x1) && node.length) {\n      var xm = (x0 + x1) / 2;\n      \
if (child = node[1]) halves.push(new half_default(child, xm, x1));\n      if \
(child = node[0]) halves.push(new half_default(child, x0, xm));\n    }\n  }\n \
 return this;\n}\n\n// \
../../node_modules/d3-binarytree/src/visitAfter.js\nfunction \
visitAfter_default(callback) {\n  var halves = [], next = [], q;\n  if \
(this._root) halves.push(new half_default(this._root, this._x0, this._x1));\n \
 while (q = halves.pop()) {\n    var node = q.node;\n    if (node.length) {\n \
     var child, x0 = q.x0, x1 = q.x1, xm = (x0 + x1) / 2;\n      if (child = \
node[0]) halves.push(new half_default(child, x0, xm));\n      if (child = \
node[1]) halves.push(new half_default(child, xm, x1));\n    }\n    \
next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, \
q.x1);\n  }\n  return this;\n}\n\n// \
../../node_modules/d3-binarytree/src/x.js\nfunction defaultX(d) {\n  return \
d[0];\n}\nfunction x_default(_) {\n  return arguments.length ? (this._x = _, \
this) : this._x;\n}\n\n// \
../../node_modules/d3-binarytree/src/binarytree.js\nfunction \
binarytree(nodes, x2) {\n  var tree = new Binarytree(x2 == null ? defaultX : \
x2, NaN, NaN);\n  return nodes == null ? tree : \
tree.addAll(nodes);\n}\nfunction Binarytree(x2, x0, x1) {\n  this._x = x2;\n  \
this._x0 = x0;\n  this._x1 = x1;\n  this._root = void 0;\n}\nfunction \
leaf_copy(leaf) {\n  var copy = { data: leaf.data }, next = copy;\n  while \
(leaf = leaf.next) next = next.next = { data: leaf.data };\n  return \
copy;\n}\nvar treeProto = binarytree.prototype = \
Binarytree.prototype;\ntreeProto.copy = function() {\n  var copy = new \
Binarytree(this._x, this._x0, this._x1), node = this._root, nodes, child;\n  \
if (!node) return copy;\n  if (!node.length) return copy._root = \
leaf_copy(node), copy;\n  nodes = [{ source: node, target: copy._root = new \
Array(2) }];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 2; ++i) \
{\n      if (child = node.source[i]) {\n        if (child.length) \
nodes.push({ source: child, target: node.target[i] = new Array(2) });\n       \
 else node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n  return \
copy;\n};\ntreeProto.add = add_default;\ntreeProto.addAll = \
addAll;\ntreeProto.cover = cover_default;\ntreeProto.data = \
data_default;\ntreeProto.extent = extent_default;\ntreeProto.find = \
find_default;\ntreeProto.remove = remove_default;\ntreeProto.removeAll = \
removeAll;\ntreeProto.root = root_default;\ntreeProto.size = \
size_default;\ntreeProto.visit = visit_default;\ntreeProto.visitAfter = \
visitAfter_default;\ntreeProto.x = x_default;\n\n// \
../../node_modules/d3-quadtree/src/add.js\nfunction add_default2(d) {\n  \
const x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);\n  return \
add2(this.cover(x2, y2), x2, y2, d);\n}\nfunction add2(tree, x2, y2, d) {\n  \
if (isNaN(x2) || isNaN(y2)) return tree;\n  var parent, node = tree._root, \
leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = \
tree._y1, xm, ym, xp, yp, right, bottom, i, j;\n  if (!node) return \
tree._root = leaf, tree;\n  while (node.length) {\n    if (right = x2 >= (xm \
= (x0 + x1) / 2)) x0 = xm;\n    else x1 = xm;\n    if (bottom = y2 >= (ym = \
(y0 + y1) / 2)) y0 = ym;\n    else y1 = ym;\n    if (parent = node, !(node = \
node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n  xp = \
+tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  if \
(x2 === xp && y2 === yp) return leaf.next = node, parent ? parent[i] = leaf : \
tree._root = leaf, tree;\n  do {\n    parent = parent ? parent[i] = new \
Array(4) : tree._root = new Array(4);\n    if (right = x2 >= (xm = (x0 + x1) \
/ 2)) x0 = xm;\n    else x1 = xm;\n    if (bottom = y2 >= (ym = (y0 + y1) / \
2)) y0 = ym;\n    else y1 = ym;\n  } while ((i = bottom << 1 | right) === (j \
= (yp >= ym) << 1 | xp >= xm));\n  return parent[j] = node, parent[i] = leaf, \
tree;\n}\nfunction addAll2(data) {\n  var d, i, n = data.length, x2, y2, xz = \
new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = \
-Infinity, y1 = -Infinity;\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x2 = \
+this._x.call(null, d = data[i])) || isNaN(y2 = +this._y.call(null, d))) \
continue;\n    xz[i] = x2;\n    yz[i] = y2;\n    if (x2 < x0) x0 = x2;\n    \
if (x2 > x1) x1 = x2;\n    if (y2 < y0) y0 = y2;\n    if (y2 > y1) y1 = y2;\n \
 }\n  if (x0 > x1 || y0 > y1) return this;\n  this.cover(x0, y0).cover(x1, \
y1);\n  for (i = 0; i < n; ++i) {\n    add2(this, xz[i], yz[i], data[i]);\n  \
}\n  return this;\n}\n\n// \
../../node_modules/d3-quadtree/src/cover.js\nfunction cover_default2(x2, y2) \
{\n  if (isNaN(x2 = +x2) || isNaN(y2 = +y2)) return this;\n  var x0 = \
this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;\n  if (isNaN(x0)) {\n  \
  x1 = (x0 = Math.floor(x2)) + 1;\n    y1 = (y0 = Math.floor(y2)) + 1;\n  } \
else {\n    var z2 = x1 - x0 || 1, node = this._root, parent, i;\n    while \
(x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1) {\n      i = (y2 < y0) << 1 | x2 \
< x0;\n      parent = new Array(4), parent[i] = node, node = parent, z2 *= \
2;\n      switch (i) {\n        case 0:\n          x1 = x0 + z2, y1 = y0 + \
z2;\n          break;\n        case 1:\n          x0 = x1 - z2, y1 = y0 + \
z2;\n          break;\n        case 2:\n          x1 = x0 + z2, y0 = y1 - \
z2;\n          break;\n        case 3:\n          x0 = x1 - z2, y0 = y1 - \
z2;\n          break;\n      }\n    }\n    if (this._root && \
this._root.length) this._root = node;\n  }\n  this._x0 = x0;\n  this._y0 = \
y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  return this;\n}\n\n// \
../../node_modules/d3-quadtree/src/data.js\nfunction data_default2() {\n  var \
data = [];\n  this.visit(function(node) {\n    if (!node.length) do\n      \
data.push(node.data);\n    while (node = node.next);\n  });\n  return \
data;\n}\n\n// ../../node_modules/d3-quadtree/src/extent.js\nfunction \
extent_default2(_) {\n  return arguments.length ? this.cover(+_[0][0], \
+_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, \
this._y0], [this._x1, this._y1]];\n}\n\n// \
../../node_modules/d3-quadtree/src/quad.js\nfunction quad_default(node, x0, \
y0, x1, y1) {\n  this.node = node;\n  this.x0 = x0;\n  this.y0 = y0;\n  \
this.x1 = x1;\n  this.y1 = y1;\n}\n\n// \
../../node_modules/d3-quadtree/src/find.js\nfunction find_default2(x2, y2, \
radius) {\n  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x3 = \
this._x1, y3 = this._y1, quads = [], node = this._root, q, i;\n  if (node) \
quads.push(new quad_default(node, x0, y0, x3, y3));\n  if (radius == null) \
radius = Infinity;\n  else {\n    x0 = x2 - radius, y0 = y2 - radius;\n    x3 \
= x2 + radius, y3 = y2 + radius;\n    radius *= radius;\n  }\n  while (q = \
quads.pop()) {\n    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > \
y3 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0) continue;\n    if (node.length) \
{\n      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;\n      quads.push(\n   \
     new quad_default(node[3], xm, ym, x22, y22),\n        new \
quad_default(node[2], x1, ym, xm, y22),\n        new quad_default(node[1], \
xm, y1, x22, ym),\n        new quad_default(node[0], x1, y1, xm, ym)\n      \
);\n      if (i = (y2 >= ym) << 1 | x2 >= xm) {\n        q = \
quads[quads.length - 1];\n        quads[quads.length - 1] = \
quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      \
}\n    } else {\n      var dx = x2 - +this._x.call(null, node.data), dy = y2 \
- +this._y.call(null, node.data), d2 = dx * dx + dy * dy;\n      if (d2 < \
radius) {\n        var d = Math.sqrt(radius = d2);\n        x0 = x2 - d, y0 = \
y2 - d;\n        x3 = x2 + d, y3 = y2 + d;\n        data = node.data;\n      \
}\n    }\n  }\n  return data;\n}\n\n// \
../../node_modules/d3-quadtree/src/remove.js\nfunction remove_default2(d) {\n \
 if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, \
d))) return this;\n  var parent, node = this._root, retainer, previous, next, \
x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x2, y2, xm, ym, \
right, bottom, i, j;\n  if (!node) return this;\n  if (node.length) while \
(true) {\n    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;\n    else x1 = \
xm;\n    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;\n    else y1 = \
ym;\n    if (!(parent = node, node = node[i = bottom << 1 | right])) return \
this;\n    if (!node.length) break;\n    if (parent[i + 1 & 3] || parent[i + \
2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;\n  }\n  while \
(node.data !== d) if (!(previous = node, node = node.next)) return this;\n  \
if (next = node.next) delete node.next;\n  if (previous) return next ? \
previous.next = next : delete previous.next, this;\n  if (!parent) return \
this._root = next, this;\n  next ? parent[i] = next : delete parent[i];\n  if \
((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === \
(parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {\n    if \
(retainer) retainer[j] = node;\n    else this._root = node;\n  }\n  return \
this;\n}\nfunction removeAll2(data) {\n  for (var i = 0, n = data.length; i < \
n; ++i) this.remove(data[i]);\n  return this;\n}\n\n// \
../../node_modules/d3-quadtree/src/root.js\nfunction root_default2() {\n  \
return this._root;\n}\n\n// \
../../node_modules/d3-quadtree/src/size.js\nfunction size_default2() {\n  var \
size = 0;\n  this.visit(function(node) {\n    if (!node.length) do\n      \
++size;\n    while (node = node.next);\n  });\n  return size;\n}\n\n// \
../../node_modules/d3-quadtree/src/visit.js\nfunction \
visit_default2(callback) {\n  var quads = [], q, node = this._root, child, \
x0, y0, x1, y1;\n  if (node) quads.push(new quad_default(node, this._x0, \
this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if \
(!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && \
node.length) {\n      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if \
(child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));\n      \
if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));\n   \
   if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, \
ym));\n      if (child = node[0]) quads.push(new quad_default(child, x0, y0, \
xm, ym));\n    }\n  }\n  return this;\n}\n\n// \
../../node_modules/d3-quadtree/src/visitAfter.js\nfunction \
visitAfter_default2(callback) {\n  var quads = [], next = [], q;\n  if \
(this._root) quads.push(new quad_default(this._root, this._x0, this._y0, \
this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n  \
  if (node.length) {\n      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = \
q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[0]) \
quads.push(new quad_default(child, x0, y0, xm, ym));\n      if (child = \
node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));\n      if \
(child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));\n      \
if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));\n   \
 }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, \
q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n}\n\n// \
../../node_modules/d3-quadtree/src/x.js\nfunction defaultX2(d) {\n  return \
d[0];\n}\nfunction x_default2(_) {\n  return arguments.length ? (this._x = _, \
this) : this._x;\n}\n\n// ../../node_modules/d3-quadtree/src/y.js\nfunction \
defaultY(d) {\n  return d[1];\n}\nfunction y_default(_) {\n  return \
arguments.length ? (this._y = _, this) : this._y;\n}\n\n// \
../../node_modules/d3-quadtree/src/quadtree.js\nfunction quadtree(nodes, x2, \
y2) {\n  var tree = new Quadtree(x2 == null ? defaultX2 : x2, y2 == null ? \
defaultY : y2, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree : \
tree.addAll(nodes);\n}\nfunction Quadtree(x2, y2, x0, y0, x1, y1) {\n  \
this._x = x2;\n  this._y = y2;\n  this._x0 = x0;\n  this._y0 = y0;\n  \
this._x1 = x1;\n  this._y1 = y1;\n  this._root = void 0;\n}\nfunction \
leaf_copy2(leaf) {\n  var copy = { data: leaf.data }, next = copy;\n  while \
(leaf = leaf.next) next = next.next = { data: leaf.data };\n  return \
copy;\n}\nvar treeProto2 = quadtree.prototype = \
Quadtree.prototype;\ntreeProto2.copy = function() {\n  var copy = new \
Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = \
this._root, nodes, child;\n  if (!node) return copy;\n  if (!node.length) \
return copy._root = leaf_copy2(node), copy;\n  nodes = [{ source: node, \
target: copy._root = new Array(4) }];\n  while (node = nodes.pop()) {\n    \
for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        \
if (child.length) nodes.push({ source: child, target: node.target[i] = new \
Array(4) });\n        else node.target[i] = leaf_copy2(child);\n      }\n    \
}\n  }\n  return copy;\n};\ntreeProto2.add = add_default2;\ntreeProto2.addAll \
= addAll2;\ntreeProto2.cover = cover_default2;\ntreeProto2.data = \
data_default2;\ntreeProto2.extent = extent_default2;\ntreeProto2.find = \
find_default2;\ntreeProto2.remove = remove_default2;\ntreeProto2.removeAll = \
removeAll2;\ntreeProto2.root = root_default2;\ntreeProto2.size = \
size_default2;\ntreeProto2.visit = visit_default2;\ntreeProto2.visitAfter = \
visitAfter_default2;\ntreeProto2.x = x_default2;\ntreeProto2.y = \
y_default;\n\n// ../../node_modules/d3-octree/src/add.js\nfunction \
add_default3(d) {\n  const x2 = +this._x.call(null, d), y2 = \
+this._y.call(null, d), z2 = +this._z.call(null, d);\n  return \
add3(this.cover(x2, y2, z2), x2, y2, z2, d);\n}\nfunction add3(tree, x2, y2, \
z2, d) {\n  if (isNaN(x2) || isNaN(y2) || isNaN(z2)) return tree;\n  var \
parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, \
z0 = tree._z0, x1 = tree._x1, y1 = tree._y1, z1 = tree._z1, xm, ym, zm, xp, \
yp, zp, right, bottom, deep, i, j;\n  if (!node) return tree._root = leaf, \
tree;\n  while (node.length) {\n    if (right = x2 >= (xm = (x0 + x1) / 2)) \
x0 = xm;\n    else x1 = xm;\n    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 \
= ym;\n    else y1 = ym;\n    if (deep = z2 >= (zm = (z0 + z1) / 2)) z0 = \
zm;\n    else z1 = zm;\n    if (parent = node, !(node = node[i = deep << 2 | \
bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n  xp = \
+tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  zp \
= +tree._z.call(null, node.data);\n  if (x2 === xp && y2 === yp && z2 === zp) \
return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, \
tree;\n  do {\n    parent = parent ? parent[i] = new Array(8) : tree._root = \
new Array(8);\n    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;\n    else \
x1 = xm;\n    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;\n    else y1 \
= ym;\n    if (deep = z2 >= (zm = (z0 + z1) / 2)) z0 = zm;\n    else z1 = \
zm;\n  } while ((i = deep << 2 | bottom << 1 | right) === (j = (zp >= zm) << \
2 | (yp >= ym) << 1 | xp >= xm));\n  return parent[j] = node, parent[i] = \
leaf, tree;\n}\nfunction addAll3(data) {\n  if (!Array.isArray(data)) data = \
Array.from(data);\n  const n = data.length;\n  const xz = new \
Float64Array(n);\n  const yz = new Float64Array(n);\n  const zz = new \
Float64Array(n);\n  let x0 = Infinity, y0 = Infinity, z0 = Infinity, x1 = \
-Infinity, y1 = -Infinity, z1 = -Infinity;\n  for (let i = 0, d, x2, y2, z2; \
i < n; ++i) {\n    if (isNaN(x2 = +this._x.call(null, d = data[i])) || \
isNaN(y2 = +this._y.call(null, d)) || isNaN(z2 = +this._z.call(null, d))) \
continue;\n    xz[i] = x2;\n    yz[i] = y2;\n    zz[i] = z2;\n    if (x2 < \
x0) x0 = x2;\n    if (x2 > x1) x1 = x2;\n    if (y2 < y0) y0 = y2;\n    if \
(y2 > y1) y1 = y2;\n    if (z2 < z0) z0 = z2;\n    if (z2 > z1) z1 = z2;\n  \
}\n  if (x0 > x1 || y0 > y1 || z0 > z1) return this;\n  this.cover(x0, y0, \
z0).cover(x1, y1, z1);\n  for (let i = 0; i < n; ++i) {\n    add3(this, \
xz[i], yz[i], zz[i], data[i]);\n  }\n  return this;\n}\n\n// \
../../node_modules/d3-octree/src/cover.js\nfunction cover_default3(x2, y2, \
z2) {\n  if (isNaN(x2 = +x2) || isNaN(y2 = +y2) || isNaN(z2 = +z2)) return \
this;\n  var x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = \
this._y1, z1 = this._z1;\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x2)) \
+ 1;\n    y1 = (y0 = Math.floor(y2)) + 1;\n    z1 = (z0 = Math.floor(z2)) + \
1;\n  } else {\n    var t = x1 - x0 || 1, node = this._root, parent, i;\n    \
while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1 || z0 > z2 || z2 >= z1) {\n \
     i = (z2 < z0) << 2 | (y2 < y0) << 1 | x2 < x0;\n      parent = new \
Array(8), parent[i] = node, node = parent, t *= 2;\n      switch (i) {\n      \
  case 0:\n          x1 = x0 + t, y1 = y0 + t, z1 = z0 + t;\n          \
break;\n        case 1:\n          x0 = x1 - t, y1 = y0 + t, z1 = z0 + t;\n   \
       break;\n        case 2:\n          x1 = x0 + t, y0 = y1 - t, z1 = z0 + \
t;\n          break;\n        case 3:\n          x0 = x1 - t, y0 = y1 - t, z1 \
= z0 + t;\n          break;\n        case 4:\n          x1 = x0 + t, y1 = y0 \
+ t, z0 = z1 - t;\n          break;\n        case 5:\n          x0 = x1 - t, \
y1 = y0 + t, z0 = z1 - t;\n          break;\n        case 6:\n          x1 = \
x0 + t, y0 = y1 - t, z0 = z1 - t;\n          break;\n        case 7:\n        \
  x0 = x1 - t, y0 = y1 - t, z0 = z1 - t;\n          break;\n      }\n    }\n  \
  if (this._root && this._root.length) this._root = node;\n  }\n  this._x0 = \
x0;\n  this._y0 = y0;\n  this._z0 = z0;\n  this._x1 = x1;\n  this._y1 = y1;\n \
 this._z1 = z1;\n  return this;\n}\n\n// \
../../node_modules/d3-octree/src/data.js\nfunction data_default3() {\n  var \
data = [];\n  this.visit(function(node) {\n    if (!node.length) do\n      \
data.push(node.data);\n    while (node = node.next);\n  });\n  return \
data;\n}\n\n// ../../node_modules/d3-octree/src/extent.js\nfunction \
extent_default3(_) {\n  return arguments.length ? this.cover(+_[0][0], \
+_[0][1], +_[0][2]).cover(+_[1][0], +_[1][1], +_[1][2]) : isNaN(this._x0) ? \
void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, \
this._z1]];\n}\n\n// ../../node_modules/d3-octree/src/octant.js\nfunction \
octant_default(node, x0, y0, z0, x1, y1, z1) {\n  this.node = node;\n  \
this.x0 = x0;\n  this.y0 = y0;\n  this.z0 = z0;\n  this.x1 = x1;\n  this.y1 = \
y1;\n  this.z1 = z1;\n}\n\n// \
../../node_modules/d3-octree/src/find.js\nfunction find_default3(x2, y2, z2, \
radius) {\n  var data, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1, y1, \
z1, x22, y22, z22, x3 = this._x1, y3 = this._y1, z3 = this._z1, octs = [], \
node = this._root, q, i;\n  if (node) octs.push(new octant_default(node, x0, \
y0, z0, x3, y3, z3));\n  if (radius == null) radius = Infinity;\n  else {\n   \
 x0 = x2 - radius, y0 = y2 - radius, z0 = z2 - radius;\n    x3 = x2 + radius, \
y3 = y2 + radius, z3 = z2 + radius;\n    radius *= radius;\n  }\n  while (q = \
octs.pop()) {\n    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > \
y3 || (z1 = q.z0) > z3 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0 || (z22 = \
q.z1) < z0) continue;\n    if (node.length) {\n      var xm = (x1 + x22) / 2, \
ym = (y1 + y22) / 2, zm = (z1 + z22) / 2;\n      octs.push(\n        new \
octant_default(node[7], xm, ym, zm, x22, y22, z22),\n        new \
octant_default(node[6], x1, ym, zm, xm, y22, z22),\n        new \
octant_default(node[5], xm, y1, zm, x22, ym, z22),\n        new \
octant_default(node[4], x1, y1, zm, xm, ym, z22),\n        new \
octant_default(node[3], xm, ym, z1, x22, y22, zm),\n        new \
octant_default(node[2], x1, ym, z1, xm, y22, zm),\n        new \
octant_default(node[1], xm, y1, z1, x22, ym, zm),\n        new \
octant_default(node[0], x1, y1, z1, xm, ym, zm)\n      );\n      if (i = (z2 \
>= zm) << 2 | (y2 >= ym) << 1 | x2 >= xm) {\n        q = octs[octs.length - \
1];\n        octs[octs.length - 1] = octs[octs.length - 1 - i];\n        \
octs[octs.length - 1 - i] = q;\n      }\n    } else {\n      var dx = x2 - \
+this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), dz \
= z2 - +this._z.call(null, node.data), d2 = dx * dx + dy * dy + dz * dz;\n    \
  if (d2 < radius) {\n        var d = Math.sqrt(radius = d2);\n        x0 = \
x2 - d, y0 = y2 - d, z0 = z2 - d;\n        x3 = x2 + d, y3 = y2 + d, z3 = z2 \
+ d;\n        data = node.data;\n      }\n    }\n  }\n  return data;\n}\n\n// \
../../node_modules/d3-octree/src/remove.js\nfunction remove_default3(d) {\n  \
if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d)) \
|| isNaN(z2 = +this._z.call(null, d))) return this;\n  var parent, node = \
this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, z0 = \
this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1, x2, y2, z2, xm, ym, \
zm, right, bottom, deep, i, j;\n  if (!node) return this;\n  if (node.length) \
while (true) {\n    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;\n    \
else x1 = xm;\n    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;\n    \
else y1 = ym;\n    if (deep = z2 >= (zm = (z0 + z1) / 2)) z0 = zm;\n    else \
z1 = zm;\n    if (!(parent = node, node = node[i = deep << 2 | bottom << 1 | \
right])) return this;\n    if (!node.length) break;\n    if (parent[i + 1 & \
7] || parent[i + 2 & 7] || parent[i + 3 & 7] || parent[i + 4 & 7] || parent[i \
+ 5 & 7] || parent[i + 6 & 7] || parent[i + 7 & 7]) retainer = parent, j = \
i;\n  }\n  while (node.data !== d) if (!(previous = node, node = node.next)) \
return this;\n  if (next = node.next) delete node.next;\n  if (previous) \
return next ? previous.next = next : delete previous.next, this;\n  if \
(!parent) return this._root = next, this;\n  next ? parent[i] = next : delete \
parent[i];\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3] || \
parent[4] || parent[5] || parent[6] || parent[7]) && node === (parent[7] || \
parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || \
parent[0]) && !node.length) {\n    if (retainer) retainer[j] = node;\n    \
else this._root = node;\n  }\n  return this;\n}\nfunction removeAll3(data) \
{\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n  \
return this;\n}\n\n// ../../node_modules/d3-octree/src/root.js\nfunction \
root_default3() {\n  return this._root;\n}\n\n// \
../../node_modules/d3-octree/src/size.js\nfunction size_default3() {\n  var \
size = 0;\n  this.visit(function(node) {\n    if (!node.length) do\n      \
++size;\n    while (node = node.next);\n  });\n  return size;\n}\n\n// \
../../node_modules/d3-octree/src/visit.js\nfunction visit_default3(callback) \
{\n  var octs = [], q, node = this._root, child, x0, y0, z0, x1, y1, z1;\n  \
if (node) octs.push(new octant_default(node, this._x0, this._y0, this._z0, \
this._x1, this._y1, this._z1));\n  while (q = octs.pop()) {\n    if \
(!callback(node = q.node, x0 = q.x0, y0 = q.y0, z0 = q.z0, x1 = q.x1, y1 = \
q.y1, z1 = q.z1) && node.length) {\n      var xm = (x0 + x1) / 2, ym = (y0 + \
y1) / 2, zm = (z0 + z1) / 2;\n      if (child = node[7]) octs.push(new \
octant_default(child, xm, ym, zm, x1, y1, z1));\n      if (child = node[6]) \
octs.push(new octant_default(child, x0, ym, zm, xm, y1, z1));\n      if \
(child = node[5]) octs.push(new octant_default(child, xm, y0, zm, x1, ym, \
z1));\n      if (child = node[4]) octs.push(new octant_default(child, x0, y0, \
zm, xm, ym, z1));\n      if (child = node[3]) octs.push(new \
octant_default(child, xm, ym, z0, x1, y1, zm));\n      if (child = node[2]) \
octs.push(new octant_default(child, x0, ym, z0, xm, y1, zm));\n      if \
(child = node[1]) octs.push(new octant_default(child, xm, y0, z0, x1, ym, \
zm));\n      if (child = node[0]) octs.push(new octant_default(child, x0, y0, \
z0, xm, ym, zm));\n    }\n  }\n  return this;\n}\n\n// \
../../node_modules/d3-octree/src/visitAfter.js\nfunction \
visitAfter_default3(callback) {\n  var octs = [], next = [], q;\n  if \
(this._root) octs.push(new octant_default(this._root, this._x0, this._y0, \
this._z0, this._x1, this._y1, this._z1));\n  while (q = octs.pop()) {\n    \
var node = q.node;\n    if (node.length) {\n      var child, x0 = q.x0, y0 = \
q.y0, z0 = q.z0, x1 = q.x1, y1 = q.y1, z1 = q.z1, xm = (x0 + x1) / 2, ym = \
(y0 + y1) / 2, zm = (z0 + z1) / 2;\n      if (child = node[0]) octs.push(new \
octant_default(child, x0, y0, z0, xm, ym, zm));\n      if (child = node[1]) \
octs.push(new octant_default(child, xm, y0, z0, x1, ym, zm));\n      if \
(child = node[2]) octs.push(new octant_default(child, x0, ym, z0, xm, y1, \
zm));\n      if (child = node[3]) octs.push(new octant_default(child, xm, ym, \
z0, x1, y1, zm));\n      if (child = node[4]) octs.push(new \
octant_default(child, x0, y0, zm, xm, ym, z1));\n      if (child = node[5]) \
octs.push(new octant_default(child, xm, y0, zm, x1, ym, z1));\n      if \
(child = node[6]) octs.push(new octant_default(child, x0, ym, zm, xm, y1, \
z1));\n      if (child = node[7]) octs.push(new octant_default(child, xm, ym, \
zm, x1, y1, z1));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) \
{\n    callback(q.node, q.x0, q.y0, q.z0, q.x1, q.y1, q.z1);\n  }\n  return \
this;\n}\n\n// ../../node_modules/d3-octree/src/x.js\nfunction defaultX3(d) \
{\n  return d[0];\n}\nfunction x_default3(_) {\n  return arguments.length ? \
(this._x = _, this) : this._x;\n}\n\n// \
../../node_modules/d3-octree/src/y.js\nfunction defaultY2(d) {\n  return \
d[1];\n}\nfunction y_default2(_) {\n  return arguments.length ? (this._y = _, \
this) : this._y;\n}\n\n// ../../node_modules/d3-octree/src/z.js\nfunction \
defaultZ(d) {\n  return d[2];\n}\nfunction z_default(_) {\n  return \
arguments.length ? (this._z = _, this) : this._z;\n}\n\n// \
../../node_modules/d3-octree/src/octree.js\nfunction octree(nodes, x2, y2, \
z2) {\n  var tree = new Octree(x2 == null ? defaultX3 : x2, y2 == null ? \
defaultY2 : y2, z2 == null ? defaultZ : z2, NaN, NaN, NaN, NaN, NaN, NaN);\n  \
return nodes == null ? tree : tree.addAll(nodes);\n}\nfunction Octree(x2, y2, \
z2, x0, y0, z0, x1, y1, z1) {\n  this._x = x2;\n  this._y = y2;\n  this._z = \
z2;\n  this._x0 = x0;\n  this._y0 = y0;\n  this._z0 = z0;\n  this._x1 = x1;\n \
 this._y1 = y1;\n  this._z1 = z1;\n  this._root = void 0;\n}\nfunction \
leaf_copy3(leaf) {\n  var copy = { data: leaf.data }, next = copy;\n  while \
(leaf = leaf.next) next = next.next = { data: leaf.data };\n  return \
copy;\n}\nvar treeProto3 = octree.prototype = \
Octree.prototype;\ntreeProto3.copy = function() {\n  var copy = new \
Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, \
this._y1, this._z1), node = this._root, nodes, child;\n  if (!node) return \
copy;\n  if (!node.length) return copy._root = leaf_copy3(node), copy;\n  \
nodes = [{ source: node, target: copy._root = new Array(8) }];\n  while (node \
= nodes.pop()) {\n    for (var i = 0; i < 8; ++i) {\n      if (child = \
node.source[i]) {\n        if (child.length) nodes.push({ source: child, \
target: node.target[i] = new Array(8) });\n        else node.target[i] = \
leaf_copy3(child);\n      }\n    }\n  }\n  return copy;\n};\ntreeProto3.add = \
add_default3;\ntreeProto3.addAll = addAll3;\ntreeProto3.cover = \
cover_default3;\ntreeProto3.data = data_default3;\ntreeProto3.extent = \
extent_default3;\ntreeProto3.find = find_default3;\ntreeProto3.remove = \
remove_default3;\ntreeProto3.removeAll = removeAll3;\ntreeProto3.root = \
root_default3;\ntreeProto3.size = size_default3;\ntreeProto3.visit = \
visit_default3;\ntreeProto3.visitAfter = visitAfter_default3;\ntreeProto3.x = \
x_default3;\ntreeProto3.y = y_default2;\ntreeProto3.z = z_default;\n\n// \
../../node_modules/d3-force-3d/src/constant.js\nfunction constant_default(x2) \
{\n  return function() {\n    return x2;\n  };\n}\n\n// \
../../node_modules/d3-force-3d/src/jiggle.js\nfunction jiggle_default(random) \
{\n  return (random() - 0.5) * 1e-6;\n}\n\n// \
../../node_modules/d3-force-3d/src/link.js\nfunction index(d) {\n  return \
d.index;\n}\nfunction find(nodeById, nodeId) {\n  var node = \
nodeById.get(nodeId);\n  if (!node) throw new Error(\"node not found: \" + \
nodeId);\n  return node;\n}\nfunction link_default(links) {\n  var id2 = \
index, strength = defaultStrength, strengths, distance2 = \
constant_default(30), distances, nodes, nDim, count, bias, random, iterations \
= 1;\n  if (links == null) links = [];\n  function defaultStrength(link) {\n  \
  return 1 / Math.min(count[link.source.index], count[link.target.index]);\n  \
}\n  function force(alpha) {\n    for (var k = 0, n = links.length; k < \
iterations; ++k) {\n      for (var i = 0, link, source, target, x2 = 0, y2 = \
0, z2 = 0, l, b; i < n; ++i) {\n        link = links[i], source = \
link.source, target = link.target;\n        x2 = target.x + target.vx - \
source.x - source.vx || jiggle_default(random);\n        if (nDim > 1) {\n    \
      y2 = target.y + target.vy - source.y - source.vy || \
jiggle_default(random);\n        }\n        if (nDim > 2) {\n          z2 = \
target.z + target.vz - source.z - source.vz || jiggle_default(random);\n      \
  }\n        l = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);\n        l = (l - \
distances[i]) / l * alpha * strengths[i];\n        x2 *= l, y2 *= l, z2 *= \
l;\n        target.vx -= x2 * (b = bias[i]);\n        if (nDim > 1) {\n       \
   target.vy -= y2 * b;\n        }\n        if (nDim > 2) {\n          \
target.vz -= z2 * b;\n        }\n        source.vx += x2 * (b = 1 - b);\n     \
   if (nDim > 1) {\n          source.vy += y2 * b;\n        }\n        if \
(nDim > 2) {\n          source.vz += z2 * b;\n        }\n      }\n    }\n  \
}\n  function initialize() {\n    if (!nodes) return;\n    var i, n = \
nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => \
[id2(d, i2, nodes), d])), link;\n    for (i = 0, count = new Array(n); i < \
m2; ++i) {\n      link = links[i], link.index = i;\n      if (typeof \
link.source !== \"object\") link.source = find(nodeById, link.source);\n      \
if (typeof link.target !== \"object\") link.target = find(nodeById, \
link.target);\n      count[link.source.index] = (count[link.source.index] || \
0) + 1;\n      count[link.target.index] = (count[link.target.index] || 0) + \
1;\n    }\n    for (i = 0, bias = new Array(m2); i < m2; ++i) {\n      link = \
links[i], bias[i] = count[link.source.index] / (count[link.source.index] + \
count[link.target.index]);\n    }\n    strengths = new Array(m2), \
initializeStrength();\n    distances = new Array(m2), initializeDistance();\n \
 }\n  function initializeStrength() {\n    if (!nodes) return;\n    for (var \
i = 0, n = links.length; i < n; ++i) {\n      strengths[i] = \
+strength(links[i], i, links);\n    }\n  }\n  function initializeDistance() \
{\n    if (!nodes) return;\n    for (var i = 0, n = links.length; i < n; ++i) \
{\n      distances[i] = +distance2(links[i], i, links);\n    }\n  }\n  \
force.initialize = function(_nodes, ...args) {\n    nodes = _nodes;\n    \
random = args.find((arg) => typeof arg === \"function\") || Math.random;\n    \
nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;\n    initialize();\n \
 };\n  force.links = function(_) {\n    return arguments.length ? (links = _, \
initialize(), force) : links;\n  };\n  force.id = function(_) {\n    return \
arguments.length ? (id2 = _, force) : id2;\n  };\n  force.iterations = \
function(_) {\n    return arguments.length ? (iterations = +_, force) : \
iterations;\n  };\n  force.strength = function(_) {\n    return \
arguments.length ? (strength = typeof _ === \"function\" ? _ : \
constant_default(+_), initializeStrength(), force) : strength;\n  };\n  \
force.distance = function(_) {\n    return arguments.length ? (distance2 = \
typeof _ === \"function\" ? _ : constant_default(+_), initializeDistance(), \
force) : distance2;\n  };\n  return force;\n}\n\n// \
../../node_modules/d3-dispatch/src/dispatch.js\nvar noop = { value: () => \
{\n} };\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = \
{}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || t in _ || \
/[\\s.]/.test(t)) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  \
}\n  return new Dispatch(_);\n}\nfunction Dispatch(_) {\n  this._ = \
_;\n}\nfunction parseTypenames(typenames, types) {\n  return \
typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = \
t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, \
i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \
\" + t);\n    return { type: t, name };\n  });\n}\nDispatch.prototype = \
dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, \
callback) {\n    var _ = this._, T = parseTypenames(typename + \"\", _), t, i \
= -1, n = T.length;\n    if (arguments.length < 2) {\n      while (++i < n) \
if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return \
t;\n      return;\n    }\n    if (callback != null && typeof callback !== \
\"function\") throw new Error(\"invalid callback: \" + callback);\n    while \
(++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set(_[t], \
typename.name, callback);\n      else if (callback == null) for (t in _) _[t] \
= set(_[t], typename.name, null);\n    }\n    return this;\n  },\n  copy: \
function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = \
_[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, \
that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new \
Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if \
(!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n  \
  for (t = this._[type], i = 0, n = t.length; i < n; ++i) \
t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n  \
  if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + \
type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) \
t[i].value.apply(that, args);\n  }\n};\nfunction get(type, name) {\n  for \
(var i = 0, n = type.length, c2; i < n; ++i) {\n    if ((c2 = type[i]).name \
=== name) {\n      return c2.value;\n    }\n  }\n}\nfunction set(type, name, \
callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if \
(type[i].name === name) {\n      type[i] = noop, type = type.slice(0, \
i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != \
null) type.push({ name, value: callback });\n  return type;\n}\nvar \
dispatch_default = dispatch;\n\n// \
../../node_modules/d3-timer/src/timer.js\nvar frame = 0;\nvar timeout = \
0;\nvar interval = 0;\nvar pokeDelay = 1e3;\nvar taskHead;\nvar \
taskTail;\nvar clockLast = 0;\nvar clockNow = 0;\nvar clockSkew = 0;\nvar \
clock = typeof performance === \"object\" && performance.now ? performance : \
Date;\nvar setFrame = typeof window === \"object\" && \
window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : \
function(f) {\n  setTimeout(f, 17);\n};\nfunction now2() {\n  return clockNow \
|| (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\nfunction \
clearNow() {\n  clockNow = 0;\n}\nfunction Timer() {\n  this._call = \
this._time = this._next = null;\n}\nTimer.prototype = timer.prototype = {\n  \
constructor: Timer,\n  restart: function(callback, delay, time) {\n    if \
(typeof callback !== \"function\") throw new TypeError(\"callback is not a \
function\");\n    time = (time == null ? now2() : +time) + (delay == null ? 0 \
: +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail) \
taskTail._next = this;\n      else taskHead = this;\n      taskTail = this;\n \
   }\n    this._call = callback;\n    this._time = time;\n    sleep();\n  \
},\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n   \
   this._time = Infinity;\n      sleep();\n    }\n  }\n};\nfunction \
timer(callback, delay, time) {\n  var t = new Timer();\n  t.restart(callback, \
delay, time);\n  return t;\n}\nfunction timerFlush() {\n  now2();\n  \
++frame;\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - \
t._time) >= 0) t._call.call(void 0, e);\n    t = t._next;\n  }\n  \
--frame;\n}\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + \
clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally \
{\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\nfunction poke() {\n \
 var now5 = clock.now(), delay = now5 - clockLast;\n  if (delay > pokeDelay) \
clockSkew -= delay, clockLast = now5;\n}\nfunction nap() {\n  var t0, t1 = \
taskHead, t2, time = Infinity;\n  while (t1) {\n    if (t1._call) {\n      if \
(time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else \
{\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : \
taskHead = t2;\n    }\n  }\n  taskTail = t0;\n  sleep(time);\n}\nfunction \
sleep(time) {\n  if (frame) return;\n  if (timeout) timeout = \
clearTimeout(timeout);\n  var delay = time - clockNow;\n  if (delay > 24) {\n \
   if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - \
clockSkew);\n    if (interval) interval = clearInterval(interval);\n  } else \
{\n    if (!interval) clockLast = clock.now(), interval = setInterval(poke, \
pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n\n// \
../../node_modules/d3-force-3d/src/lcg.js\nvar a = 1664525;\nvar c = \
1013904223;\nvar m = 4294967296;\nfunction lcg_default() {\n  let s = 1;\n  \
return () => (s = (a * s + c) % m) / m;\n}\n\n// \
../../node_modules/d3-force-3d/src/simulation.js\nvar MAX_DIMENSIONS = \
3;\nfunction x(d) {\n  return d.x;\n}\nfunction y(d) {\n  return \
d.y;\n}\nfunction z(d) {\n  return d.z;\n}\nvar initialRadius = 10;\nvar \
initialAngleRoll = Math.PI * (3 - Math.sqrt(5));\nvar initialAngleYaw = \
Math.PI * 20 / (9 + Math.sqrt(221));\nfunction simulation_default(nodes, \
numDimensions) {\n  numDimensions = numDimensions || 2;\n  var nDim = \
Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))), simulation, \
alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), \
alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), \
stepper = timer(step2), event = dispatch_default(\"tick\", \"end\"), random = \
lcg_default();\n  if (nodes == null) nodes = [];\n  function step2() {\n    \
tick2();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) \
{\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  \
}\n  function tick2(iterations) {\n    var i, n = nodes.length, node;\n    if \
(iterations === void 0) iterations = 1;\n    for (var k = 0; k < iterations; \
++k) {\n      alpha += (alphaTarget - alpha) * alphaDecay;\n      \
forces.forEach(function(force) {\n        force(alpha);\n      });\n      for \
(i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null) \
node.x += node.vx *= velocityDecay;\n        else node.x = node.fx, node.vx = \
0;\n        if (nDim > 1) {\n          if (node.fy == null) node.y += node.vy \
*= velocityDecay;\n          else node.y = node.fy, node.vy = 0;\n        }\n \
       if (nDim > 2) {\n          if (node.fz == null) node.z += node.vz *= \
velocityDecay;\n          else node.z = node.fz, node.vz = 0;\n        }\n    \
  }\n    }\n    return simulation;\n  }\n  function initializeNodes() {\n    \
for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], \
node.index = i;\n      if (node.fx != null) node.x = node.fx;\n      if \
(node.fy != null) node.y = node.fy;\n      if (node.fz != null) node.z = \
node.fz;\n      if (isNaN(node.x) || nDim > 1 && isNaN(node.y) || nDim > 2 && \
isNaN(node.z)) {\n        var radius = initialRadius * (nDim > 2 ? \
Math.cbrt(0.5 + i) : nDim > 1 ? Math.sqrt(0.5 + i) : i), rollAngle = i * \
initialAngleRoll, yawAngle = i * initialAngleYaw;\n        if (nDim === 1) \
{\n          node.x = radius;\n        } else if (nDim === 2) {\n          \
node.x = radius * Math.cos(rollAngle);\n          node.y = radius * \
Math.sin(rollAngle);\n        } else {\n          node.x = radius * \
Math.sin(rollAngle) * Math.cos(yawAngle);\n          node.y = radius * \
Math.cos(rollAngle);\n          node.z = radius * Math.sin(rollAngle) * \
Math.sin(yawAngle);\n        }\n      }\n      if (isNaN(node.vx) || nDim > 1 \
&& isNaN(node.vy) || nDim > 2 && isNaN(node.vz)) {\n        node.vx = 0;\n    \
    if (nDim > 1) {\n          node.vy = 0;\n        }\n        if (nDim > 2) \
{\n          node.vz = 0;\n        }\n      }\n    }\n  }\n  function \
initializeForce(force) {\n    if (force.initialize) force.initialize(nodes, \
random, nDim);\n    return force;\n  }\n  initializeNodes();\n  return \
simulation = {\n    tick: tick2,\n    restart: function() {\n      return \
stepper.restart(step2), simulation;\n    },\n    stop: function() {\n      \
return stepper.stop(), simulation;\n    },\n    numDimensions: function(_) \
{\n      return arguments.length ? (nDim = Math.min(MAX_DIMENSIONS, \
Math.max(1, Math.round(_))), forces.forEach(initializeForce), simulation) : \
nDim;\n    },\n    nodes: function(_) {\n      return arguments.length ? \
(nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : \
nodes;\n    },\n    alpha: function(_) {\n      return arguments.length ? \
(alpha = +_, simulation) : alpha;\n    },\n    alphaMin: function(_) {\n      \
return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n   \
 alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, \
simulation) : +alphaDecay;\n    },\n    alphaTarget: function(_) {\n      \
return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    \
},\n    velocityDecay: function(_) {\n      return arguments.length ? \
(velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n    \
randomSource: function(_) {\n      return arguments.length ? (random = _, \
forces.forEach(initializeForce), simulation) : random;\n    },\n    force: \
function(name, _) {\n      return arguments.length > 1 ? (_ == null ? \
forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : \
forces.get(name);\n    },\n    find: function() {\n      var args = \
Array.prototype.slice.call(arguments);\n      var x2 = args.shift() || 0, y2 \
= (nDim > 1 ? args.shift() : null) || 0, z2 = (nDim > 2 ? args.shift() : \
null) || 0, radius = args.shift() || Infinity;\n      var i = 0, n = \
nodes.length, dx, dy, dz, d2, node, closest;\n      radius *= radius;\n      \
for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x2 - \
node.x;\n        dy = y2 - (node.y || 0);\n        dz = z2 - (node.z || 0);\n \
       d2 = dx * dx + dy * dy + dz * dz;\n        if (d2 < radius) closest = \
node, radius = d2;\n      }\n      return closest;\n    },\n    on: \
function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), \
simulation) : event.on(name);\n    }\n  };\n}\n\n// \
../../node_modules/d3-force-3d/src/manyBody.js\nfunction manyBody_default() \
{\n  var nodes, nDim, node, random, alpha, strength = constant_default(-30), \
strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;\n  \
function force(_) {\n    var i, n = nodes.length, tree = (nDim === 1 ? \
binarytree(nodes, x) : nDim === 2 ? quadtree(nodes, x, y) : nDim === 3 ? \
octree(nodes, x, y, z) : null).visitAfter(accumulate);\n    for (alpha = _, i \
= 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n  function \
initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, \
node2;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i) node2 = \
nodes[i], strengths[node2.index] = +strength(node2, i, nodes);\n  }\n  \
function accumulate(treeNode) {\n    var strength2 = 0, q, c2, weight = 0, \
x2, y2, z2, i;\n    var numChildren = treeNode.length;\n    if (numChildren) \
{\n      for (x2 = y2 = z2 = i = 0; i < numChildren; ++i) {\n        if ((q = \
treeNode[i]) && (c2 = Math.abs(q.value))) {\n          strength2 += q.value, \
weight += c2, x2 += c2 * (q.x || 0), y2 += c2 * (q.y || 0), z2 += c2 * (q.z \
|| 0);\n        }\n      }\n      strength2 *= Math.sqrt(4 / numChildren);\n  \
    treeNode.x = x2 / weight;\n      if (nDim > 1) {\n        treeNode.y = y2 \
/ weight;\n      }\n      if (nDim > 2) {\n        treeNode.z = z2 / \
weight;\n      }\n    } else {\n      q = treeNode;\n      q.x = q.data.x;\n  \
    if (nDim > 1) {\n        q.y = q.data.y;\n      }\n      if (nDim > 2) \
{\n        q.z = q.data.z;\n      }\n      do\n        strength2 += \
strengths[q.data.index];\n      while (q = q.next);\n    }\n    \
treeNode.value = strength2;\n  }\n  function apply(treeNode, x1, arg1, arg2, \
arg3) {\n    if (!treeNode.value) return true;\n    var x2 = [arg1, arg2, \
arg3][nDim - 1];\n    var x3 = treeNode.x - node.x, y2 = nDim > 1 ? \
treeNode.y - node.y : 0, z2 = nDim > 2 ? treeNode.z - node.z : 0, w = x2 - \
x1, l = x3 * x3 + y2 * y2 + z2 * z2;\n    if (w * w / theta2 < l) {\n      if \
(l < distanceMax2) {\n        if (x3 === 0) x3 = jiggle_default(random), l += \
x3 * x3;\n        if (nDim > 1 && y2 === 0) y2 = jiggle_default(random), l += \
y2 * y2;\n        if (nDim > 2 && z2 === 0) z2 = jiggle_default(random), l += \
z2 * z2;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    \
    node.vx += x3 * treeNode.value * alpha / l;\n        if (nDim > 1) {\n    \
      node.vy += y2 * treeNode.value * alpha / l;\n        }\n        if \
(nDim > 2) {\n          node.vz += z2 * treeNode.value * alpha / l;\n        \
}\n      }\n      return true;\n    } else if (treeNode.length || l >= \
distanceMax2) return;\n    if (treeNode.data !== node || treeNode.next) {\n   \
   if (x3 === 0) x3 = jiggle_default(random), l += x3 * x3;\n      if (nDim > \
1 && y2 === 0) y2 = jiggle_default(random), l += y2 * y2;\n      if (nDim > 2 \
&& z2 === 0) z2 = jiggle_default(random), l += z2 * z2;\n      if (l < \
distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n    do\n      if \
(treeNode.data !== node) {\n        w = strengths[treeNode.data.index] * \
alpha / l;\n        node.vx += x3 * w;\n        if (nDim > 1) {\n          \
node.vy += y2 * w;\n        }\n        if (nDim > 2) {\n          node.vz += \
z2 * w;\n        }\n      }\n    while (treeNode = treeNode.next);\n  }\n  \
force.initialize = function(_nodes, ...args) {\n    nodes = _nodes;\n    \
random = args.find((arg) => typeof arg === \"function\") || Math.random;\n    \
nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;\n    initialize();\n \
 };\n  force.strength = function(_) {\n    return arguments.length ? \
(strength = typeof _ === \"function\" ? _ : constant_default(+_), \
initialize(), force) : strength;\n  };\n  force.distanceMin = function(_) {\n \
   return arguments.length ? (distanceMin2 = _ * _, force) : \
Math.sqrt(distanceMin2);\n  };\n  force.distanceMax = function(_) {\n    \
return arguments.length ? (distanceMax2 = _ * _, force) : \
Math.sqrt(distanceMax2);\n  };\n  force.theta = function(_) {\n    return \
arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n  \
return force;\n}\n\n// ../../node_modules/d3-force-3d/src/radial.js\nfunction \
radial_default(radius, x2, y2, z2) {\n  var nodes, nDim, strength = \
constant_default(0.1), strengths, radiuses;\n  if (typeof radius !== \
\"function\") radius = constant_default(+radius);\n  if (x2 == null) x2 = \
0;\n  if (y2 == null) y2 = 0;\n  if (z2 == null) z2 = 0;\n  function \
force(alpha) {\n    for (var i = 0, n = nodes.length; i < n; ++i) {\n      \
var node = nodes[i], dx = node.x - x2 || 1e-6, dy = (node.y || 0) - y2 || \
1e-6, dz = (node.z || 0) - z2 || 1e-6, r = Math.sqrt(dx * dx + dy * dy + dz * \
dz), k = (radiuses[i] - r) * strengths[i] * alpha / r;\n      node.vx += dx * \
k;\n      if (nDim > 1) {\n        node.vy += dy * k;\n      }\n      if \
(nDim > 2) {\n        node.vz += dz * k;\n      }\n    }\n  }\n  function \
initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    \
strengths = new Array(n);\n    radiuses = new Array(n);\n    for (i = 0; i < \
n; ++i) {\n      radiuses[i] = +radius(nodes[i], i, nodes);\n      \
strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);\n    \
}\n  }\n  force.initialize = function(initNodes, ...args) {\n    nodes = \
initNodes;\n    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;\n    \
initialize();\n  };\n  force.strength = function(_) {\n    return \
arguments.length ? (strength = typeof _ === \"function\" ? _ : \
constant_default(+_), initialize(), force) : strength;\n  };\n  force.radius \
= function(_) {\n    return arguments.length ? (radius = typeof _ === \
\"function\" ? _ : constant_default(+_), initialize(), force) : radius;\n  \
};\n  force.x = function(_) {\n    return arguments.length ? (x2 = +_, force) \
: x2;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y2 = \
+_, force) : y2;\n  };\n  force.z = function(_) {\n    return \
arguments.length ? (z2 = +_, force) : z2;\n  };\n  return force;\n}\n\n// \
../../node_modules/three-forcegraph/dist/three-forcegraph.mjs\nvar \
import_ngraph = __toESM(require_ngraph2(), 1);\nvar import_ngraph2 = \
__toESM(require_ngraph5(), 1);\n\n// \
../../node_modules/lodash-es/isObject.js\nfunction isObject(value) {\n  var \
type = typeof value;\n  return value != null && (type == \"object\" || type \
== \"function\");\n}\nvar isObject_default = isObject;\n\n// \
../../node_modules/lodash-es/_freeGlobal.js\nvar freeGlobal = typeof global \
== \"object\" && global && global.Object === Object && global;\nvar \
freeGlobal_default = freeGlobal;\n\n// \
../../node_modules/lodash-es/_root.js\nvar freeSelf = typeof self == \
\"object\" && self && self.Object === Object && self;\nvar root = \
freeGlobal_default || freeSelf || Function(\"return this\")();\nvar \
root_default4 = root;\n\n// ../../node_modules/lodash-es/now.js\nvar now3 = \
function() {\n  return root_default4.Date.now();\n};\nvar now_default = \
now3;\n\n// ../../node_modules/lodash-es/_trimmedEndIndex.js\nvar \
reWhitespace = /\\s/;\nfunction trimmedEndIndex(string) {\n  var index5 = \
string.length;\n  while (index5-- && \
reWhitespace.test(string.charAt(index5))) {\n  }\n  return index5;\n}\nvar \
trimmedEndIndex_default = trimmedEndIndex;\n\n// \
../../node_modules/lodash-es/_baseTrim.js\nvar reTrimStart = \
/^\\s+/;\nfunction baseTrim(string) {\n  return string ? string.slice(0, \
trimmedEndIndex_default(string) + 1).replace(reTrimStart, \"\") : \
string;\n}\nvar baseTrim_default = baseTrim;\n\n// \
../../node_modules/lodash-es/_Symbol.js\nvar Symbol2 = \
root_default4.Symbol;\nvar Symbol_default = Symbol2;\n\n// \
../../node_modules/lodash-es/_getRawTag.js\nvar objectProto = \
Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar \
nativeObjectToString = objectProto.toString;\nvar symToStringTag = \
Symbol_default ? Symbol_default.toStringTag : void 0;\nfunction \
getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag), \
tag = value[symToStringTag];\n  try {\n    value[symToStringTag] = void 0;\n  \
  var unmasked = true;\n  } catch (e) {\n  }\n  var result = \
nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      \
value[symToStringTag] = tag;\n    } else {\n      delete \
value[symToStringTag];\n    }\n  }\n  return result;\n}\nvar \
getRawTag_default = getRawTag;\n\n// \
../../node_modules/lodash-es/_objectToString.js\nvar objectProto2 = \
Object.prototype;\nvar nativeObjectToString2 = \
objectProto2.toString;\nfunction objectToString(value) {\n  return \
nativeObjectToString2.call(value);\n}\nvar objectToString_default = \
objectToString;\n\n// ../../node_modules/lodash-es/_baseGetTag.js\nvar \
nullTag = \"[object Null]\";\nvar undefinedTag = \"[object Undefined]\";\nvar \
symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void \
0;\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value \
=== void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag2 && \
symToStringTag2 in Object(value) ? getRawTag_default(value) : \
objectToString_default(value);\n}\nvar baseGetTag_default = baseGetTag;\n\n// \
../../node_modules/lodash-es/isObjectLike.js\nfunction isObjectLike(value) \
{\n  return value != null && typeof value == \"object\";\n}\nvar \
isObjectLike_default = isObjectLike;\n\n// \
../../node_modules/lodash-es/isSymbol.js\nvar symbolTag = \"[object \
Symbol]\";\nfunction isSymbol(value) {\n  return typeof value == \"symbol\" \
|| isObjectLike_default(value) && baseGetTag_default(value) == \
symbolTag;\n}\nvar isSymbol_default = isSymbol;\n\n// \
../../node_modules/lodash-es/toNumber.js\nvar NAN = 0 / 0;\nvar reIsBadHex = \
/^[-+]0x[0-9a-f]+$/i;\nvar reIsBinary = /^0b[01]+$/i;\nvar reIsOctal = \
/^0o[0-7]+$/i;\nvar freeParseInt = parseInt;\nfunction toNumber(value) {\n  \
if (typeof value == \"number\") {\n    return value;\n  }\n  if \
(isSymbol_default(value)) {\n    return NAN;\n  }\n  if \
(isObject_default(value)) {\n    var other = typeof value.valueOf == \
\"function\" ? value.valueOf() : value;\n    value = isObject_default(other) \
? other + \"\" : other;\n  }\n  if (typeof value != \"string\") {\n    return \
value === 0 ? value : +value;\n  }\n  value = baseTrim_default(value);\n  var \
isBinary = reIsBinary.test(value);\n  return isBinary || \
reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : \
reIsBadHex.test(value) ? NAN : +value;\n}\nvar toNumber_default = \
toNumber;\n\n// ../../node_modules/lodash-es/debounce.js\nvar FUNC_ERROR_TEXT \
= \"Expected a function\";\nvar nativeMax = Math.max;\nvar nativeMin = \
Math.min;\nfunction debounce(func, wait, options) {\n  var lastArgs, \
lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading \
= false, maxing = false, trailing = true;\n  if (typeof func != \"function\") \
{\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = \
toNumber_default(wait) || 0;\n  if (isObject_default(options)) {\n    leading \
= !!options.leading;\n    maxing = \"maxWait\" in options;\n    maxWait = \
maxing ? nativeMax(toNumber_default(options.maxWait) || 0, wait) : maxWait;\n \
   trailing = \"trailing\" in options ? !!options.trailing : trailing;\n  }\n \
 function invokeFunc(time) {\n    var args = lastArgs, thisArg = lastThis;\n  \
  lastArgs = lastThis = void 0;\n    lastInvokeTime = time;\n    result = \
func.apply(thisArg, args);\n    return result;\n  }\n  function \
leadingEdge(time) {\n    lastInvokeTime = time;\n    timerId = \
setTimeout(timerExpired, wait);\n    return leading ? invokeFunc(time) : \
result;\n  }\n  function remainingWait(time) {\n    var timeSinceLastCall = \
time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting \
= wait - timeSinceLastCall;\n    return maxing ? nativeMin(timeWaiting, \
maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n  function \
shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime, \
timeSinceLastInvoke = time - lastInvokeTime;\n    return lastCallTime === \
void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && \
timeSinceLastInvoke >= maxWait;\n  }\n  function timerExpired() {\n    var \
time = now_default();\n    if (shouldInvoke(time)) {\n      return \
trailingEdge(time);\n    }\n    timerId = setTimeout(timerExpired, \
remainingWait(time));\n  }\n  function trailingEdge(time) {\n    timerId = \
void 0;\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    \
}\n    lastArgs = lastThis = void 0;\n    return result;\n  }\n  function \
cancel() {\n    if (timerId !== void 0) {\n      clearTimeout(timerId);\n    \
}\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId \
= void 0;\n  }\n  function flush() {\n    return timerId === void 0 ? result \
: trailingEdge(now_default());\n  }\n  function debounced() {\n    var time = \
now_default(), isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n  \
  lastThis = this;\n    lastCallTime = time;\n    if (isInvoking) {\n      if \
(timerId === void 0) {\n        return leadingEdge(lastCallTime);\n      }\n  \
    if (maxing) {\n        clearTimeout(timerId);\n        timerId = \
setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n   \
   }\n    }\n    if (timerId === void 0) {\n      timerId = \
setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  \
debounced.cancel = cancel;\n  debounced.flush = flush;\n  return \
debounced;\n}\nvar debounce_default = debounce;\n\n// \
../../node_modules/kapsule/dist/kapsule.mjs\nfunction _arrayLikeToArray(r, \
a2) {\n  (null == a2 || a2 > r.length) && (a2 = r.length);\n  for (var e = 0, \
n = Array(a2); e < a2; e++) n[e] = r[e];\n  return n;\n}\nfunction \
_arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction \
_classCallCheck(a2, n) {\n  if (!(a2 instanceof n)) throw new \
TypeError(\"Cannot call a class as a function\");\n}\nfunction \
_createClass(e, r, t) {\n  return Object.defineProperty(e, \"prototype\", {\n \
   writable: false\n  }), e;\n}\nfunction _iterableToArrayLimit(r, l) {\n  \
var t = null == r ? null : \"undefined\" != typeof Symbol && \
r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e, n, \
i, u, a2 = [], f = true, o = false;\n    try {\n      if (i = (t = \
t.call(r)).next, 0 === l) ;\n      else for (; !(f = (e = i.call(t)).done) && \
(a2.push(e.value), a2.length !== l); f = true) ;\n    } catch (r2) {\n      o \
= true, n = r2;\n    } finally {\n      try {\n        if (!f && null != \
t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n   \
     if (o) throw n;\n      }\n    }\n    return a2;\n  }\n}\nfunction \
_nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure \
non-iterable instance.\\nIn order to be iterable, non-array objects must have \
a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(r, e) {\n  \
return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || \
_unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction \
_unsupportedIterableToArray(r, a2) {\n  if (r) {\n    if (\"string\" == \
typeof r) return _arrayLikeToArray(r, a2);\n    var t = \
{}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && \
r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? \
Array.from(r) : \"Arguments\" === t || \
/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a2) \
: void 0;\n  }\n}\nvar Prop = /* @__PURE__ */ _createClass(function \
Prop2(name, _ref) {\n  var _ref$default = _ref[\"default\"], defaultVal = \
_ref$default === void 0 ? null : _ref$default, _ref$triggerUpdate = \
_ref.triggerUpdate, triggerUpdate = _ref$triggerUpdate === void 0 ? true : \
_ref$triggerUpdate, _ref$onChange = _ref.onChange, onChange13 = _ref$onChange \
=== void 0 ? function(newVal, state) {\n  } : _ref$onChange;\n  \
_classCallCheck(this, Prop2);\n  this.name = name;\n  this.defaultVal = \
defaultVal;\n  this.triggerUpdate = triggerUpdate;\n  this.onChange = \
onChange13;\n});\nfunction index2(_ref2) {\n  var _ref2$stateInit = \
_ref2.stateInit, stateInit4 = _ref2$stateInit === void 0 ? function() {\n    \
return {};\n  } : _ref2$stateInit, _ref2$props = _ref2.props, rawProps = \
_ref2$props === void 0 ? {} : _ref2$props, _ref2$methods = _ref2.methods, \
methods = _ref2$methods === void 0 ? {} : _ref2$methods, _ref2$aliases = \
_ref2.aliases, aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases, \
_ref2$init = _ref2.init, initFn = _ref2$init === void 0 ? function() {\n  } : \
_ref2$init, _ref2$update = _ref2.update, updateFn = _ref2$update === void 0 ? \
function() {\n  } : _ref2$update;\n  var props = \
Object.keys(rawProps).map(function(propName) {\n    return new Prop(propName, \
rawProps[propName]);\n  });\n  return function() {\n    var options = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    var \
state = Object.assign(\n      {},\n      stateInit4 instanceof Function ? \
stateInit4(options) : stateInit4,\n      // Support plain objects for \
backwards compatibility\n      {\n        initialised: false\n      }\n    \
);\n    var changedProps = {};\n    function comp(nodeElement) {\n      \
initStatic(nodeElement, options);\n      digest();\n      return comp;\n    \
}\n    var initStatic = function initStatic2(nodeElement, options2) {\n      \
initFn.call(comp, nodeElement, state, options2);\n      state.initialised = \
true;\n    };\n    var digest = debounce_default(function() {\n      if \
(!state.initialised) {\n        return;\n      }\n      updateFn.call(comp, \
state, changedProps);\n      changedProps = {};\n    }, 1);\n    \
props.forEach(function(prop) {\n      comp[prop.name] = getSetProp(prop);\n   \
   function getSetProp(_ref3) {\n        var prop2 = _ref3.name, \
_ref3$triggerUpdate = _ref3.triggerUpdate, redigest = _ref3$triggerUpdate === \
void 0 ? false : _ref3$triggerUpdate, _ref3$onChange = _ref3.onChange, \
onChange13 = _ref3$onChange === void 0 ? function(newVal, state2) {\n        \
} : _ref3$onChange, _ref3$defaultVal = _ref3.defaultVal, defaultVal = \
_ref3$defaultVal === void 0 ? null : _ref3$defaultVal;\n        return \
function(_) {\n          var curVal = state[prop2];\n          if \
(!arguments.length) {\n            return curVal;\n          }\n          var \
val = _ === void 0 ? defaultVal : _;\n          state[prop2] = val;\n         \
 onChange13.call(comp, val, state, curVal);\n          \
!changedProps.hasOwnProperty(prop2) && (changedProps[prop2] = curVal);\n      \
    if (redigest) {\n            digest();\n          }\n          return \
comp;\n        };\n      }\n    });\n    \
Object.keys(methods).forEach(function(methodName) {\n      comp[methodName] = \
function() {\n        var _methods$methodName;\n        for (var _len = \
arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n  \
        args[_key] = arguments[_key];\n        }\n        return \
(_methods$methodName = methods[methodName]).call.apply(_methods$methodName, \
[comp, state].concat(args));\n      };\n    });\n    \
Object.entries(aliases).forEach(function(_ref4) {\n      var _ref5 = \
_slicedToArray(_ref4, 2), alias = _ref5[0], target = _ref5[1];\n      return \
comp[alias] = comp[target];\n    });\n    comp.resetProps = function() {\n    \
  props.forEach(function(prop) {\n        comp[prop.name](prop.defaultVal);\n \
     });\n      return comp;\n    };\n    comp.resetProps();\n    \
state._rerender = digest;\n    return comp;\n  };\n}\n\n// \
../../node_modules/accessor-fn/dist/accessor-fn.mjs\nvar index3 = function(p) \
{\n  return typeof p === \"function\" ? p : typeof p === \"string\" ? \
function(obj) {\n    return obj[p];\n  } : function(obj) {\n    return p;\n  \
};\n};\n\n// ../../node_modules/internmap/src/index.js\nvar InternMap = class \
extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    \
Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() \
}, _key: { value: key } });\n    if (entries != null) for (const [key2, \
value] of entries) this.set(key2, value);\n  }\n  get(key) {\n    return \
super.get(intern_get(this, key));\n  }\n  has(key) {\n    return \
super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return \
super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return \
super.delete(intern_delete(this, key));\n  }\n};\nfunction intern_get({ \
_intern, _key }, value) {\n  const key = _key(value);\n  return \
_intern.has(key) ? _intern.get(key) : value;\n}\nfunction intern_set({ \
_intern, _key }, value) {\n  const key = _key(value);\n  if \
(_intern.has(key)) return _intern.get(key);\n  _intern.set(key, value);\n  \
return value;\n}\nfunction intern_delete({ _intern, _key }, value) {\n  const \
key = _key(value);\n  if (_intern.has(key)) {\n    value = \
_intern.get(key);\n    _intern.delete(key);\n  }\n  return \
value;\n}\nfunction keyof(value) {\n  return value !== null && typeof value \
=== \"object\" ? value.valueOf() : value;\n}\n\n// \
../../node_modules/d3-array/src/max.js\nfunction max(values, valueof) {\n  \
let max2;\n  if (valueof === void 0) {\n    for (const value of values) {\n   \
   if (value != null && (max2 < value || max2 === void 0 && value >= value)) \
{\n        max2 = value;\n      }\n    }\n  } else {\n    let index5 = -1;\n  \
  for (let value of values) {\n      if ((value = valueof(value, ++index5, \
values)) != null && (max2 < value || max2 === void 0 && value >= value)) {\n  \
      max2 = value;\n      }\n    }\n  }\n  return max2;\n}\n\n// \
../../node_modules/d3-array/src/min.js\nfunction min(values, valueof) {\n  \
let min2;\n  if (valueof === void 0) {\n    for (const value of values) {\n   \
   if (value != null && (min2 > value || min2 === void 0 && value >= value)) \
{\n        min2 = value;\n      }\n    }\n  } else {\n    let index5 = -1;\n  \
  for (let value of values) {\n      if ((value = valueof(value, ++index5, \
values)) != null && (min2 > value || min2 === void 0 && value >= value)) {\n  \
      min2 = value;\n      }\n    }\n  }\n  return min2;\n}\n\n// \
../../node_modules/index-array-by/dist/index-array-by.mjs\nfunction \
_arrayLikeToArray2(r, a2) {\n  (null == a2 || a2 > r.length) && (a2 = \
r.length);\n  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];\n  \
return n;\n}\nfunction _arrayWithHoles2(r) {\n  if (Array.isArray(r)) return \
r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return \
_arrayLikeToArray2(r);\n}\nfunction _iterableToArray(r) {\n  if \
(\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != \
r[\"@@iterator\"]) return Array.from(r);\n}\nfunction \
_iterableToArrayLimit2(r, l) {\n  var t = null == r ? null : \"undefined\" != \
typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) \
{\n    var e, n, i, u, a2 = [], f = true, o = false;\n    try {\n      if (i \
= (t = t.call(r)).next, 0 === l) ;\n      else for (; !(f = (e = \
i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;\n    } \
catch (r2) {\n      o = true, n = r2;\n    } finally {\n      try {\n        \
if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n    \
  } finally {\n        if (o) throw n;\n      }\n    }\n    return a2;\n  \
}\n}\nfunction _nonIterableRest2() {\n  throw new TypeError(\"Invalid attempt \
to destructure non-iterable instance.\\nIn order to be iterable, non-array \
objects must have a [Symbol.iterator]() method.\");\n}\nfunction \
_nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread \
non-iterable instance.\\nIn order to be iterable, non-array objects must have \
a [Symbol.iterator]() method.\");\n}\nfunction _objectWithoutProperties(e, t) \
{\n  if (null == e) return {};\n  var o, r, i = \
_objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n \
   var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; \
r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = \
e[o]);\n  }\n  return i;\n}\nfunction _objectWithoutPropertiesLoose(r, e) {\n \
 if (null == r) return {};\n  var t = {};\n  for (var n in r) if \
({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] \
= r[n];\n  }\n  return t;\n}\nfunction _slicedToArray2(r, e) {\n  return \
_arrayWithHoles2(r) || _iterableToArrayLimit2(r, e) || \
_unsupportedIterableToArray2(r, e) || _nonIterableRest2();\n}\nfunction \
_toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || \
_iterableToArray(r) || _unsupportedIterableToArray2(r) || \
_nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != \
typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== \
e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n  \
  throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  \
}\n  return String(t);\n}\nfunction _toPropertyKey(t) {\n  var i = \
_toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \
\"\";\n}\nfunction _unsupportedIterableToArray2(r, a2) {\n  if (r) {\n    if \
(\"string\" == typeof r) return _arrayLikeToArray2(r, a2);\n    var t = \
{}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && \
r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? \
Array.from(r) : \"Arguments\" === t || \
/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, \
a2) : void 0;\n  }\n}\nvar index4 = function() {\n  var list = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n  var \
keyAccessors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] \
: [];\n  var multiItem = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : true;\n  var flattenKeys = arguments.length > 3 && \
arguments[3] !== void 0 ? arguments[3] : false;\n  var keys = (keyAccessors \
instanceof Array ? keyAccessors.length ? keyAccessors : [void 0] : \
[keyAccessors]).map(function(key) {\n    return {\n      keyAccessor: key,\n  \
    isProp: !(key instanceof Function)\n    };\n  });\n  var indexedResult = \
list.reduce(function(res, item) {\n    var iterObj = res;\n    var itemVal = \
item;\n    keys.forEach(function(_ref, idx) {\n      var keyAccessor = \
_ref.keyAccessor, isProp = _ref.isProp;\n      var key;\n      if (isProp) \
{\n        var _itemVal = itemVal, propVal = _itemVal[keyAccessor], rest = \
_objectWithoutProperties(_itemVal, [keyAccessor].map(_toPropertyKey));\n      \
  key = propVal;\n        itemVal = rest;\n      } else {\n        key = \
keyAccessor(itemVal, idx);\n      }\n      if (idx + 1 < keys.length) {\n     \
   if (!iterObj.hasOwnProperty(key)) {\n          iterObj[key] = {};\n        \
}\n        iterObj = iterObj[key];\n      } else {\n        if (multiItem) \
{\n          if (!iterObj.hasOwnProperty(key)) {\n            iterObj[key] = \
[];\n          }\n          iterObj[key].push(itemVal);\n        } else {\n   \
       iterObj[key] = itemVal;\n        }\n      }\n    });\n    return \
res;\n  }, {});\n  if (multiItem instanceof Function) {\n    (function \
reduce(node) {\n      var level = arguments.length > 1 && arguments[1] !== \
void 0 ? arguments[1] : 1;\n      if (level === keys.length) {\n        \
Object.keys(node).forEach(function(k) {\n          return node[k] = \
multiItem(node[k]);\n        });\n      } else {\n        \
Object.values(node).forEach(function(child) {\n          return reduce(child, \
level + 1);\n        });\n      }\n    })(indexedResult);\n  }\n  var result \
= indexedResult;\n  if (flattenKeys) {\n    result = [];\n    (function \
flatten2(node) {\n      var accKeys = arguments.length > 1 && arguments[1] \
!== void 0 ? arguments[1] : [];\n      if (accKeys.length === keys.length) \
{\n        result.push({\n          keys: accKeys,\n          vals: node\n    \
    });\n      } else {\n        Object.entries(node).forEach(function(_ref2) \
{\n          var _ref3 = _slicedToArray2(_ref2, 2), key = _ref3[0], val = \
_ref3[1];\n          return flatten2(val, \
[].concat(_toConsumableArray(accKeys), [key]));\n        });\n      }\n    \
})(indexedResult);\n    if (keyAccessors instanceof Array && \
keyAccessors.length === 0 && result.length === 1) {\n      result[0].keys = \
[];\n    }\n  }\n  return result;\n};\n\n// \
../../node_modules/data-joint/dist/data-joint.mjs\nfunction \
_iterableToArrayLimit3(arr, i) {\n  var _i = null == arr ? null : \
\"undefined\" != typeof Symbol && arr[Symbol.iterator] || \
arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s, _e, _x3, _r, _arr = \
[], _n = true, _d = false;\n    try {\n      if (_x3 = (_i = \
_i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n      \
  _n = false;\n      } else for (; !(_n = (_s = _x3.call(_i)).done) && \
(_arr.push(_s.value), _arr.length !== i); _n = true) ;\n    } catch (err) {\n \
     _d = true, _e = err;\n    } finally {\n      try {\n        if (!_n && \
null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } \
finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  \
}\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = \
Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols \
= Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = \
symbols.filter(function(sym) {\n      return \
Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), \
keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction \
_objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    \
var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? \
ownKeys(Object(source), true).forEach(function(key) {\n      \
_defineProperty(target, key, source[key]);\n    }) : \
Object.getOwnPropertyDescriptors ? Object.defineProperties(target, \
Object.getOwnPropertyDescriptors(source)) : \
ownKeys(Object(source)).forEach(function(key) {\n      \
Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, \
key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, \
value) {\n  key = _toPropertyKey2(key);\n  if (key in obj) {\n    \
Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n    \
  configurable: true,\n      writable: true\n    });\n  } else {\n    \
obj[key] = value;\n  }\n  return obj;\n}\nfunction \
_objectWithoutPropertiesLoose2(source, excluded) {\n  if (source == null) \
return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  \
var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = \
sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    \
target[key] = source[key];\n  }\n  return target;\n}\nfunction \
_objectWithoutProperties2(source, excluded) {\n  if (source == null) return \
{};\n  var target = _objectWithoutPropertiesLoose2(source, excluded);\n  var \
key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = \
Object.getOwnPropertySymbols(source);\n    for (i = 0; i < \
sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if \
(excluded.indexOf(key) >= 0) continue;\n      if \
(!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      \
target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction \
_slicedToArray3(arr, i) {\n  return _arrayWithHoles3(arr) || \
_iterableToArrayLimit3(arr, i) || _unsupportedIterableToArray3(arr, i) || \
_nonIterableRest3();\n}\nfunction _toConsumableArray2(arr) {\n  return \
_arrayWithoutHoles2(arr) || _iterableToArray2(arr) || \
_unsupportedIterableToArray3(arr) || _nonIterableSpread2();\n}\nfunction \
_arrayWithoutHoles2(arr) {\n  if (Array.isArray(arr)) return \
_arrayLikeToArray3(arr);\n}\nfunction _arrayWithHoles3(arr) {\n  if \
(Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray2(iter) {\n  if \
(typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || \
iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction \
_unsupportedIterableToArray3(o, minLen) {\n  if (!o) return;\n  if (typeof o \
=== \"string\") return _arrayLikeToArray3(o, minLen);\n  var n = \
Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && \
o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") \
return Array.from(o);\n  if (n === \"Arguments\" || \
/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return \
_arrayLikeToArray3(o, minLen);\n}\nfunction _arrayLikeToArray3(arr, len) {\n  \
if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, \
arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return \
arr2;\n}\nfunction _nonIterableSpread2() {\n  throw new TypeError(\"Invalid \
attempt to spread non-iterable instance.\\nIn order to be iterable, non-array \
objects must have a [Symbol.iterator]() method.\");\n}\nfunction \
_nonIterableRest3() {\n  throw new TypeError(\"Invalid attempt to destructure \
non-iterable instance.\\nIn order to be iterable, non-array objects must have \
a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive2(input, hint) {\n \
 if (typeof input !== \"object\" || input === null) return input;\n  var prim \
= input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") \
return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive \
value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nfunction _toPropertyKey2(arg) {\n  var key = \
_toPrimitive2(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nvar _excluded = [\"createObj\", \"updateObj\", \"exitObj\", \
\"objBindAttr\", \"dataBindAttr\"];\nfunction diffArrays(prev, next, \
idAccessor) {\n  var result = {\n    enter: [],\n    update: [],\n    exit: \
[]\n  };\n  if (!idAccessor) {\n    var prevSet = new Set(prev);\n    var \
nextSet = new Set(next);\n    new Set([].concat(_toConsumableArray2(prevSet), \
_toConsumableArray2(nextSet))).forEach(function(item) {\n      var type = \
!prevSet.has(item) ? \"enter\" : !nextSet.has(item) ? \"exit\" : \
\"update\";\n      result[type].push(type === \"update\" ? [item, item] : \
item);\n    });\n  } else {\n    var prevById = index4(prev, idAccessor, \
false);\n    var nextById = index4(next, idAccessor, false);\n    var byId = \
Object.assign({}, prevById, nextById);\n    \
Object.entries(byId).forEach(function(_ref) {\n      var _ref2 = \
_slicedToArray3(_ref, 2), id2 = _ref2[0], item = _ref2[1];\n      var type = \
!prevById.hasOwnProperty(id2) ? \"enter\" : !nextById.hasOwnProperty(id2) ? \
\"exit\" : \"update\";\n      result[type].push(type === \"update\" ? \
[prevById[id2], nextById[id2]] : item);\n    });\n  }\n  return \
result;\n}\nfunction dataBindDiff(data, existingObjs, _ref3) {\n  var \
_ref3$objBindAttr = _ref3.objBindAttr, objBindAttr = _ref3$objBindAttr === \
void 0 ? \"__obj\" : _ref3$objBindAttr, _ref3$dataBindAttr = \
_ref3.dataBindAttr, dataBindAttr = _ref3$dataBindAttr === void 0 ? \"__data\" \
: _ref3$dataBindAttr, idAccessor = _ref3.idAccessor, _ref3$purge = \
_ref3.purge, purge = _ref3$purge === void 0 ? false : _ref3$purge;\n  var \
isObjValid = function isObjValid2(obj) {\n    return \
obj.hasOwnProperty(dataBindAttr);\n  };\n  var removeObjs = \
existingObjs.filter(function(obj) {\n    return !isObjValid(obj);\n  });\n  \
var prevD = existingObjs.filter(isObjValid).map(function(obj) {\n    return \
obj[dataBindAttr];\n  });\n  var nextD = data;\n  var diff = purge ? {\n    \
enter: nextD,\n    exit: prevD,\n    update: []\n  } : diffArrays(prevD, \
nextD, idAccessor);\n  diff.update = diff.update.map(function(_ref4) {\n    \
var _ref5 = _slicedToArray3(_ref4, 2), prevD2 = _ref5[0], nextD2 = \
_ref5[1];\n    if (prevD2 !== nextD2) {\n      nextD2[objBindAttr] = \
prevD2[objBindAttr];\n      nextD2[objBindAttr][dataBindAttr] = nextD2;\n    \
}\n    return nextD2;\n  });\n  diff.exit = \
diff.exit.concat(removeObjs.map(function(obj) {\n    return \
_defineProperty({}, objBindAttr, obj);\n  }));\n  return diff;\n}\nfunction \
viewDigest(data, existingObjs, appendObj, removeObj, _ref7) {\n  var \
_ref7$createObj = _ref7.createObj, createObj = _ref7$createObj === void 0 ? \
function(d) {\n    return {};\n  } : _ref7$createObj, _ref7$updateObj = \
_ref7.updateObj, updateObj = _ref7$updateObj === void 0 ? function(obj, d) \
{\n  } : _ref7$updateObj, _ref7$exitObj = _ref7.exitObj, exitObj = \
_ref7$exitObj === void 0 ? function(obj) {\n  } : _ref7$exitObj, \
_ref7$objBindAttr = _ref7.objBindAttr, objBindAttr = _ref7$objBindAttr === \
void 0 ? \"__obj\" : _ref7$objBindAttr, _ref7$dataBindAttr = \
_ref7.dataBindAttr, dataBindAttr = _ref7$dataBindAttr === void 0 ? \"__data\" \
: _ref7$dataBindAttr, dataDiffOptions = _objectWithoutProperties2(_ref7, \
_excluded);\n  var _dataBindDiff = dataBindDiff(data, existingObjs, \
_objectSpread2({\n    objBindAttr,\n    dataBindAttr\n  }, dataDiffOptions)), \
enter = _dataBindDiff.enter, update4 = _dataBindDiff.update, exit = \
_dataBindDiff.exit;\n  exit.forEach(function(d) {\n    var obj = \
d[objBindAttr];\n    delete d[objBindAttr];\n    exitObj(obj);\n    \
removeObj(obj);\n  });\n  var newObjs = createObjs(enter);\n  var pointsData \
= [].concat(_toConsumableArray2(enter), _toConsumableArray2(update4));\n  \
updateObjs(pointsData);\n  newObjs.forEach(appendObj);\n  function \
createObjs(data2) {\n    var newObjs2 = [];\n    data2.forEach(function(d) \
{\n      var obj = createObj(d);\n      if (obj) {\n        obj[dataBindAttr] \
= d;\n        d[objBindAttr] = obj;\n        newObjs2.push(obj);\n      }\n   \
 });\n    return newObjs2;\n  }\n  function updateObjs(data2) {\n    \
data2.forEach(function(d) {\n      var obj = d[objBindAttr];\n      if (obj) \
{\n        obj[dataBindAttr] = d;\n        updateObj(obj, d);\n      }\n    \
});\n  }\n}\n\n// ../../node_modules/d3-scale/src/init.js\nfunction \
initRange(domain, range) {\n  switch (arguments.length) {\n    case 0:\n      \
break;\n    case 1:\n      this.range(domain);\n      break;\n    default:\n  \
    this.range(range).domain(domain);\n      break;\n  }\n  return \
this;\n}\n\n// ../../node_modules/d3-scale/src/ordinal.js\nvar implicit = \
Symbol(\"implicit\");\nfunction ordinal() {\n  var index5 = new InternMap(), \
domain = [], range = [], unknown = implicit;\n  function scale(d) {\n    let \
i = index5.get(d);\n    if (i === void 0) {\n      if (unknown !== implicit) \
return unknown;\n      index5.set(d, i = domain.push(d) - 1);\n    }\n    \
return range[i % range.length];\n  }\n  scale.domain = function(_) {\n    if \
(!arguments.length) return domain.slice();\n    domain = [], index5 = new \
InternMap();\n    for (const value of _) {\n      if (index5.has(value)) \
continue;\n      index5.set(value, domain.push(value) - 1);\n    }\n    \
return scale;\n  };\n  scale.range = function(_) {\n    return \
arguments.length ? (range = Array.from(_), scale) : range.slice();\n  };\n  \
scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, \
scale) : unknown;\n  };\n  scale.copy = function() {\n    return \
ordinal(domain, range).unknown(unknown);\n  };\n  initRange.apply(scale, \
arguments);\n  return scale;\n}\n\n// \
../../node_modules/d3-scale-chromatic/src/colors.js\nfunction \
colors_default(specifier) {\n  var n = specifier.length / 6 | 0, colors = new \
Array(n), i = 0;\n  while (i < n) colors[i] = \"#\" + specifier.slice(i * 6, \
++i * 6);\n  return colors;\n}\n\n// \
../../node_modules/d3-scale-chromatic/src/categorical/Paired.js\nvar \
Paired_default = \
colors_default(\"a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9a\
ffff99b15928\");\n\n// \
../../node_modules/tinycolor2/esm/tinycolor.js\nfunction _typeof(obj) {\n  \
\"@babel/helpers - typeof\";\n  return _typeof = \"function\" == typeof \
Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n    return \
typeof obj2;\n  } : function(obj2) {\n    return obj2 && \"function\" == \
typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \
\"symbol\" : typeof obj2;\n  }, _typeof(obj);\n}\nvar trimLeft = \
/^\\s+/;\nvar trimRight = /\\s+$/;\nfunction tinycolor(color2, opts) {\n  \
color2 = color2 ? color2 : \"\";\n  opts = opts || {};\n  if (color2 \
instanceof tinycolor) {\n    return color2;\n  }\n  if (!(this instanceof \
tinycolor)) {\n    return new tinycolor(color2, opts);\n  }\n  var rgb2 = \
inputToRGB(color2);\n  this._originalInput = color2, this._r = rgb2.r, \
this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = \
Math.round(100 * this._a) / 100, this._format = opts.format || rgb2.format;\n \
 this._gradientType = opts.gradientType;\n  if (this._r < 1) this._r = \
Math.round(this._r);\n  if (this._g < 1) this._g = Math.round(this._g);\n  if \
(this._b < 1) this._b = Math.round(this._b);\n  this._ok = \
rgb2.ok;\n}\ntinycolor.prototype = {\n  isDark: function isDark() {\n    \
return this.getBrightness() < 128;\n  },\n  isLight: function isLight() {\n   \
 return !this.isDark();\n  },\n  isValid: function isValid() {\n    return \
this._ok;\n  },\n  getOriginalInput: function getOriginalInput() {\n    \
return this._originalInput;\n  },\n  getFormat: function getFormat() {\n    \
return this._format;\n  },\n  getAlpha: function getAlpha() {\n    return \
this._a;\n  },\n  getBrightness: function getBrightness() {\n    var rgb2 = \
this.toRgb();\n    return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / \
1e3;\n  },\n  getLuminance: function getLuminance() {\n    var rgb2 = \
this.toRgb();\n    var RsRGB, GsRGB, BsRGB, R, G, B;\n    RsRGB = rgb2.r / \
255;\n    GsRGB = rgb2.g / 255;\n    BsRGB = rgb2.b / 255;\n    if (RsRGB <= \
0.03928) R = RsRGB / 12.92;\n    else R = Math.pow((RsRGB + 0.055) / 1.055, \
2.4);\n    if (GsRGB <= 0.03928) G = GsRGB / 12.92;\n    else G = \
Math.pow((GsRGB + 0.055) / 1.055, 2.4);\n    if (BsRGB <= 0.03928) B = BsRGB \
/ 12.92;\n    else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);\n    return \
0.2126 * R + 0.7152 * G + 0.0722 * B;\n  },\n  setAlpha: function \
setAlpha(value) {\n    this._a = boundAlpha(value);\n    this._roundA = \
Math.round(100 * this._a) / 100;\n    return this;\n  },\n  toHsv: function \
toHsv() {\n    var hsv = rgbToHsv(this._r, this._g, this._b);\n    return {\n \
     h: hsv.h * 360,\n      s: hsv.s,\n      v: hsv.v,\n      a: this._a\n    \
};\n  },\n  toHsvString: function toHsvString() {\n    var hsv = \
rgbToHsv(this._r, this._g, this._b);\n    var h = Math.round(hsv.h * 360), s \
= Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);\n    return this._a \
== 1 ? \"hsv(\" + h + \", \" + s + \"%, \" + v + \"%)\" : \"hsva(\" + h + \", \
\" + s + \"%, \" + v + \"%, \" + this._roundA + \")\";\n  },\n  toHsl: \
function toHsl() {\n    var hsl2 = rgbToHsl(this._r, this._g, this._b);\n    \
return {\n      h: hsl2.h * 360,\n      s: hsl2.s,\n      l: hsl2.l,\n      \
a: this._a\n    };\n  },\n  toHslString: function toHslString() {\n    var \
hsl2 = rgbToHsl(this._r, this._g, this._b);\n    var h = Math.round(hsl2.h * \
360), s = Math.round(hsl2.s * 100), l = Math.round(hsl2.l * 100);\n    return \
this._a == 1 ? \"hsl(\" + h + \", \" + s + \"%, \" + l + \"%)\" : \"hsla(\" + \
h + \", \" + s + \"%, \" + l + \"%, \" + this._roundA + \")\";\n  },\n  \
toHex: function toHex(allow3Char) {\n    return rgbToHex(this._r, this._g, \
this._b, allow3Char);\n  },\n  toHexString: function toHexString(allow3Char) \
{\n    return \"#\" + this.toHex(allow3Char);\n  },\n  toHex8: function \
toHex8(allow4Char) {\n    return rgbaToHex(this._r, this._g, this._b, \
this._a, allow4Char);\n  },\n  toHex8String: function \
toHex8String(allow4Char) {\n    return \"#\" + this.toHex8(allow4Char);\n  \
},\n  toRgb: function toRgb() {\n    return {\n      r: \
Math.round(this._r),\n      g: Math.round(this._g),\n      b: \
Math.round(this._b),\n      a: this._a\n    };\n  },\n  toRgbString: function \
toRgbString() {\n    return this._a == 1 ? \"rgb(\" + Math.round(this._r) + \
\", \" + Math.round(this._g) + \", \" + Math.round(this._b) + \")\" : \
\"rgba(\" + Math.round(this._r) + \", \" + Math.round(this._g) + \", \" + \
Math.round(this._b) + \", \" + this._roundA + \")\";\n  },\n  \
toPercentageRgb: function toPercentageRgb() {\n    return {\n      r: \
Math.round(bound01(this._r, 255) * 100) + \"%\",\n      g: \
Math.round(bound01(this._g, 255) * 100) + \"%\",\n      b: \
Math.round(bound01(this._b, 255) * 100) + \"%\",\n      a: this._a\n    };\n  \
},\n  toPercentageRgbString: function toPercentageRgbString() {\n    return \
this._a == 1 ? \"rgb(\" + Math.round(bound01(this._r, 255) * 100) + \"%, \" + \
Math.round(bound01(this._g, 255) * 100) + \"%, \" + \
Math.round(bound01(this._b, 255) * 100) + \"%)\" : \"rgba(\" + \
Math.round(bound01(this._r, 255) * 100) + \"%, \" + \
Math.round(bound01(this._g, 255) * 100) + \"%, \" + \
Math.round(bound01(this._b, 255) * 100) + \"%, \" + this._roundA + \")\";\n  \
},\n  toName: function toName() {\n    if (this._a === 0) {\n      return \
\"transparent\";\n    }\n    if (this._a < 1) {\n      return false;\n    }\n \
   return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;\n  \
},\n  toFilter: function toFilter(secondColor) {\n    var hex8String = \"#\" \
+ rgbaToArgbHex(this._r, this._g, this._b, this._a);\n    var \
secondHex8String = hex8String;\n    var gradientType = this._gradientType ? \
\"GradientType = 1, \" : \"\";\n    if (secondColor) {\n      var s = \
tinycolor(secondColor);\n      secondHex8String = \"#\" + rgbaToArgbHex(s._r, \
s._g, s._b, s._a);\n    }\n    return \
\"progid:DXImageTransform.Microsoft.gradient(\" + gradientType + \
\"startColorstr=\" + hex8String + \",endColorstr=\" + secondHex8String + \
\")\";\n  },\n  toString: function toString(format2) {\n    var formatSet = \
!!format2;\n    format2 = format2 || this._format;\n    var formattedString = \
false;\n    var hasAlpha = this._a < 1 && this._a >= 0;\n    var \
needsAlphaFormat = !formatSet && hasAlpha && (format2 === \"hex\" || format2 \
=== \"hex6\" || format2 === \"hex3\" || format2 === \"hex4\" || format2 === \
\"hex8\" || format2 === \"name\");\n    if (needsAlphaFormat) {\n      if \
(format2 === \"name\" && this._a === 0) {\n        return this.toName();\n    \
  }\n      return this.toRgbString();\n    }\n    if (format2 === \"rgb\") \
{\n      formattedString = this.toRgbString();\n    }\n    if (format2 === \
\"prgb\") {\n      formattedString = this.toPercentageRgbString();\n    }\n   \
 if (format2 === \"hex\" || format2 === \"hex6\") {\n      formattedString = \
this.toHexString();\n    }\n    if (format2 === \"hex3\") {\n      \
formattedString = this.toHexString(true);\n    }\n    if (format2 === \
\"hex4\") {\n      formattedString = this.toHex8String(true);\n    }\n    if \
(format2 === \"hex8\") {\n      formattedString = this.toHex8String();\n    \
}\n    if (format2 === \"name\") {\n      formattedString = this.toName();\n  \
  }\n    if (format2 === \"hsl\") {\n      formattedString = \
this.toHslString();\n    }\n    if (format2 === \"hsv\") {\n      \
formattedString = this.toHsvString();\n    }\n    return formattedString || \
this.toHexString();\n  },\n  clone: function clone() {\n    return \
tinycolor(this.toString());\n  },\n  _applyModification: function \
_applyModification(fn, args) {\n    var color2 = fn.apply(null, \
[this].concat([].slice.call(args)));\n    this._r = color2._r;\n    this._g = \
color2._g;\n    this._b = color2._b;\n    this.setAlpha(color2._a);\n    \
return this;\n  },\n  lighten: function lighten() {\n    return \
this._applyModification(_lighten, arguments);\n  },\n  brighten: function \
brighten() {\n    return this._applyModification(_brighten, arguments);\n  \
},\n  darken: function darken() {\n    return \
this._applyModification(_darken, arguments);\n  },\n  desaturate: function \
desaturate() {\n    return this._applyModification(_desaturate, arguments);\n \
 },\n  saturate: function saturate() {\n    return \
this._applyModification(_saturate, arguments);\n  },\n  greyscale: function \
greyscale() {\n    return this._applyModification(_greyscale, arguments);\n  \
},\n  spin: function spin() {\n    return this._applyModification(_spin, \
arguments);\n  },\n  _applyCombination: function _applyCombination(fn, args) \
{\n    return fn.apply(null, [this].concat([].slice.call(args)));\n  },\n  \
analogous: function analogous() {\n    return \
this._applyCombination(_analogous, arguments);\n  },\n  complement: function \
complement() {\n    return this._applyCombination(_complement, arguments);\n  \
},\n  monochromatic: function monochromatic() {\n    return \
this._applyCombination(_monochromatic, arguments);\n  },\n  splitcomplement: \
function splitcomplement() {\n    return \
this._applyCombination(_splitcomplement, arguments);\n  },\n  // Disabled \
until https://github.com/bgrins/TinyColor/issues/254\n  // polyad: function \
(number) {\n  //   return this._applyCombination(polyad, [number]);\n  // \
},\n  triad: function triad() {\n    return this._applyCombination(polyad, \
[3]);\n  },\n  tetrad: function tetrad() {\n    return \
this._applyCombination(polyad, [4]);\n  }\n};\ntinycolor.fromRatio = \
function(color2, opts) {\n  if (_typeof(color2) == \"object\") {\n    var \
newColor = {};\n    for (var i in color2) {\n      if \
(color2.hasOwnProperty(i)) {\n        if (i === \"a\") {\n          \
newColor[i] = color2[i];\n        } else {\n          newColor[i] = \
convertToPercentage(color2[i]);\n        }\n      }\n    }\n    color2 = \
newColor;\n  }\n  return tinycolor(color2, opts);\n};\nfunction \
inputToRGB(color2) {\n  var rgb2 = {\n    r: 0,\n    g: 0,\n    b: 0\n  };\n  \
var a2 = 1;\n  var s = null;\n  var v = null;\n  var l = null;\n  var ok = \
false;\n  var format2 = false;\n  if (typeof color2 == \"string\") {\n    \
color2 = stringInputToObject(color2);\n  }\n  if (_typeof(color2) == \
\"object\") {\n    if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) \
&& isValidCSSUnit(color2.b)) {\n      rgb2 = rgbToRgb(color2.r, color2.g, \
color2.b);\n      ok = true;\n      format2 = String(color2.r).substr(-1) === \
\"%\" ? \"prgb\" : \"rgb\";\n    } else if (isValidCSSUnit(color2.h) && \
isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {\n      s = \
convertToPercentage(color2.s);\n      v = convertToPercentage(color2.v);\n    \
  rgb2 = hsvToRgb(color2.h, s, v);\n      ok = true;\n      format2 = \
\"hsv\";\n    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) \
&& isValidCSSUnit(color2.l)) {\n      s = convertToPercentage(color2.s);\n    \
  l = convertToPercentage(color2.l);\n      rgb2 = hslToRgb(color2.h, s, \
l);\n      ok = true;\n      format2 = \"hsl\";\n    }\n    if \
(color2.hasOwnProperty(\"a\")) {\n      a2 = color2.a;\n    }\n  }\n  a2 = \
boundAlpha(a2);\n  return {\n    ok,\n    format: color2.format || format2,\n \
   r: Math.min(255, Math.max(rgb2.r, 0)),\n    g: Math.min(255, \
Math.max(rgb2.g, 0)),\n    b: Math.min(255, Math.max(rgb2.b, 0)),\n    a: \
a2\n  };\n}\nfunction rgbToRgb(r, g, b) {\n  return {\n    r: bound01(r, 255) \
* 255,\n    g: bound01(g, 255) * 255,\n    b: bound01(b, 255) * 255\n  \
};\n}\nfunction rgbToHsl(r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, \
255);\n  b = bound01(b, 255);\n  var max2 = Math.max(r, g, b), min2 = \
Math.min(r, g, b);\n  var h, s, l = (max2 + min2) / 2;\n  if (max2 == min2) \
{\n    h = s = 0;\n  } else {\n    var d = max2 - min2;\n    s = l > 0.5 ? d \
/ (2 - max2 - min2) : d / (max2 + min2);\n    switch (max2) {\n      case \
r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case \
g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = \
(r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return {\n    \
h,\n    s,\n    l\n  };\n}\nfunction hslToRgb(h, s, l) {\n  var r, g, b;\n  h \
= bound01(h, 360);\n  s = bound01(s, 100);\n  l = bound01(l, 100);\n  \
function hue2rgb3(p2, q2, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= \
1;\n    if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;\n    if (t < 1 / 2) \
return q2;\n    if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;\n    \
return p2;\n  }\n  if (s === 0) {\n    r = g = b = l;\n  } else {\n    var q \
= l < 0.5 ? l * (1 + s) : l + s - l * s;\n    var p = 2 * l - q;\n    r = \
hue2rgb3(p, q, h + 1 / 3);\n    g = hue2rgb3(p, q, h);\n    b = hue2rgb3(p, \
q, h - 1 / 3);\n  }\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * \
255\n  };\n}\nfunction rgbToHsv(r, g, b) {\n  r = bound01(r, 255);\n  g = \
bound01(g, 255);\n  b = bound01(b, 255);\n  var max2 = Math.max(r, g, b), \
min2 = Math.min(r, g, b);\n  var h, s, v = max2;\n  var d = max2 - min2;\n  s \
= max2 === 0 ? 0 : d / max2;\n  if (max2 == min2) {\n    h = 0;\n  } else {\n \
   switch (max2) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : \
0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        \
break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n  \
  h /= 6;\n  }\n  return {\n    h,\n    s,\n    v\n  };\n}\nfunction \
hsvToRgb(h, s, v) {\n  h = bound01(h, 360) * 6;\n  s = bound01(s, 100);\n  v \
= bound01(v, 100);\n  var i = Math.floor(h), f = h - i, p = v * (1 - s), q = \
v * (1 - f * s), t = v * (1 - (1 - f) * s), mod2 = i % 6, r = [v, q, p, p, t, \
v][mod2], g = [t, v, v, q, p, p][mod2], b = [p, p, t, v, v, q][mod2];\n  \
return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\nfunction \
rgbToHex(r, g, b, allow3Char) {\n  var hex = \
[pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), \
pad2(Math.round(b).toString(16))];\n  if (allow3Char && hex[0].charAt(0) == \
hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) \
== hex[2].charAt(1)) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + \
hex[2].charAt(0);\n  }\n  return hex.join(\"\");\n}\nfunction rgbaToHex(r, g, \
b, a2, allow4Char) {\n  var hex = [pad2(Math.round(r).toString(16)), \
pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), \
pad2(convertDecimalToHex(a2))];\n  if (allow4Char && hex[0].charAt(0) == \
hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) \
== hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {\n    return \
hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);\n  \
}\n  return hex.join(\"\");\n}\nfunction rgbaToArgbHex(r, g, b, a2) {\n  var \
hex = [pad2(convertDecimalToHex(a2)), pad2(Math.round(r).toString(16)), \
pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];\n  \
return hex.join(\"\");\n}\ntinycolor.equals = function(color1, color2) {\n  \
if (!color1 || !color2) return false;\n  return \
tinycolor(color1).toRgbString() == \
tinycolor(color2).toRgbString();\n};\ntinycolor.random = function() {\n  \
return tinycolor.fromRatio({\n    r: Math.random(),\n    g: Math.random(),\n  \
  b: Math.random()\n  });\n};\nfunction _desaturate(color2, amount) {\n  \
amount = amount === 0 ? 0 : amount || 10;\n  var hsl2 = \
tinycolor(color2).toHsl();\n  hsl2.s -= amount / 100;\n  hsl2.s = \
clamp01(hsl2.s);\n  return tinycolor(hsl2);\n}\nfunction _saturate(color2, \
amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl2 = \
tinycolor(color2).toHsl();\n  hsl2.s += amount / 100;\n  hsl2.s = \
clamp01(hsl2.s);\n  return tinycolor(hsl2);\n}\nfunction _greyscale(color2) \
{\n  return tinycolor(color2).desaturate(100);\n}\nfunction _lighten(color2, \
amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl2 = \
tinycolor(color2).toHsl();\n  hsl2.l += amount / 100;\n  hsl2.l = \
clamp01(hsl2.l);\n  return tinycolor(hsl2);\n}\nfunction _brighten(color2, \
amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var rgb2 = \
tinycolor(color2).toRgb();\n  rgb2.r = Math.max(0, Math.min(255, rgb2.r - \
Math.round(255 * -(amount / 100))));\n  rgb2.g = Math.max(0, Math.min(255, \
rgb2.g - Math.round(255 * -(amount / 100))));\n  rgb2.b = Math.max(0, \
Math.min(255, rgb2.b - Math.round(255 * -(amount / 100))));\n  return \
tinycolor(rgb2);\n}\nfunction _darken(color2, amount) {\n  amount = amount \
=== 0 ? 0 : amount || 10;\n  var hsl2 = tinycolor(color2).toHsl();\n  hsl2.l \
-= amount / 100;\n  hsl2.l = clamp01(hsl2.l);\n  return \
tinycolor(hsl2);\n}\nfunction _spin(color2, amount) {\n  var hsl2 = \
tinycolor(color2).toHsl();\n  var hue = (hsl2.h + amount) % 360;\n  hsl2.h = \
hue < 0 ? 360 + hue : hue;\n  return tinycolor(hsl2);\n}\nfunction \
_complement(color2) {\n  var hsl2 = tinycolor(color2).toHsl();\n  hsl2.h = \
(hsl2.h + 180) % 360;\n  return tinycolor(hsl2);\n}\nfunction polyad(color2, \
number) {\n  if (isNaN(number) || number <= 0) {\n    throw new \
Error(\"Argument to polyad must be a positive number\");\n  }\n  var hsl2 = \
tinycolor(color2).toHsl();\n  var result = [tinycolor(color2)];\n  var step2 \
= 360 / number;\n  for (var i = 1; i < number; i++) {\n    \
result.push(tinycolor({\n      h: (hsl2.h + i * step2) % 360,\n      s: \
hsl2.s,\n      l: hsl2.l\n    }));\n  }\n  return result;\n}\nfunction \
_splitcomplement(color2) {\n  var hsl2 = tinycolor(color2).toHsl();\n  var h \
= hsl2.h;\n  return [tinycolor(color2), tinycolor({\n    h: (h + 72) % 360,\n \
   s: hsl2.s,\n    l: hsl2.l\n  }), tinycolor({\n    h: (h + 216) % 360,\n    \
s: hsl2.s,\n    l: hsl2.l\n  })];\n}\nfunction _analogous(color2, results, \
slices) {\n  results = results || 6;\n  slices = slices || 30;\n  var hsl2 = \
tinycolor(color2).toHsl();\n  var part = 360 / slices;\n  var ret = \
[tinycolor(color2)];\n  for (hsl2.h = (hsl2.h - (part * results >> 1) + 720) \
% 360; --results; ) {\n    hsl2.h = (hsl2.h + part) % 360;\n    \
ret.push(tinycolor(hsl2));\n  }\n  return ret;\n}\nfunction \
_monochromatic(color2, results) {\n  results = results || 6;\n  var hsv = \
tinycolor(color2).toHsv();\n  var h = hsv.h, s = hsv.s, v = hsv.v;\n  var ret \
= [];\n  var modification = 1 / results;\n  while (results--) {\n    \
ret.push(tinycolor({\n      h,\n      s,\n      v\n    }));\n    v = (v + \
modification) % 1;\n  }\n  return ret;\n}\ntinycolor.mix = function(color1, \
color2, amount) {\n  amount = amount === 0 ? 0 : amount || 50;\n  var rgb1 = \
tinycolor(color1).toRgb();\n  var rgb2 = tinycolor(color2).toRgb();\n  var p \
= amount / 100;\n  var rgba2 = {\n    r: (rgb2.r - rgb1.r) * p + rgb1.r,\n    \
g: (rgb2.g - rgb1.g) * p + rgb1.g,\n    b: (rgb2.b - rgb1.b) * p + rgb1.b,\n  \
  a: (rgb2.a - rgb1.a) * p + rgb1.a\n  };\n  return \
tinycolor(rgba2);\n};\ntinycolor.readability = function(color1, color2) {\n  \
var c1 = tinycolor(color1);\n  var c2 = tinycolor(color2);\n  return \
(Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / \
(Math.min(c1.getLuminance(), c2.getLuminance()) + \
0.05);\n};\ntinycolor.isReadable = function(color1, color2, wcag2) {\n  var \
readability = tinycolor.readability(color1, color2);\n  var wcag2Parms, \
out;\n  out = false;\n  wcag2Parms = validateWCAG2Parms(wcag2);\n  switch \
(wcag2Parms.level + wcag2Parms.size) {\n    case \"AAsmall\":\n    case \
\"AAAlarge\":\n      out = readability >= 4.5;\n      break;\n    case \
\"AAlarge\":\n      out = readability >= 3;\n      break;\n    case \
\"AAAsmall\":\n      out = readability >= 7;\n      break;\n  }\n  return \
out;\n};\ntinycolor.mostReadable = function(baseColor, colorList, args) {\n  \
var bestColor = null;\n  var bestScore = 0;\n  var readability;\n  var \
includeFallbackColors, level, size;\n  args = args || {};\n  \
includeFallbackColors = args.includeFallbackColors;\n  level = args.level;\n  \
size = args.size;\n  for (var i = 0; i < colorList.length; i++) {\n    \
readability = tinycolor.readability(baseColor, colorList[i]);\n    if \
(readability > bestScore) {\n      bestScore = readability;\n      bestColor \
= tinycolor(colorList[i]);\n    }\n  }\n  if (tinycolor.isReadable(baseColor, \
bestColor, {\n    level,\n    size\n  }) || !includeFallbackColors) {\n    \
return bestColor;\n  } else {\n    args.includeFallbackColors = false;\n    \
return tinycolor.mostReadable(baseColor, [\"#fff\", \"#000\"], args);\n  \
}\n};\nvar names = tinycolor.names = {\n  aliceblue: \"f0f8ff\",\n  \
antiquewhite: \"faebd7\",\n  aqua: \"0ff\",\n  aquamarine: \"7fffd4\",\n  \
azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \
\"000\",\n  blanchedalmond: \"ffebcd\",\n  blue: \"00f\",\n  blueviolet: \
\"8a2be2\",\n  brown: \"a52a2a\",\n  burlywood: \"deb887\",\n  burntsienna: \
\"ea7e5d\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n  \
chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \"6495ed\",\n \
 cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"0ff\",\n  darkblue: \
\"00008b\",\n  darkcyan: \"008b8b\",\n  darkgoldenrod: \"b8860b\",\n  \
darkgray: \"a9a9a9\",\n  darkgreen: \"006400\",\n  darkgrey: \"a9a9a9\",\n  \
darkkhaki: \"bdb76b\",\n  darkmagenta: \"8b008b\",\n  darkolivegreen: \
\"556b2f\",\n  darkorange: \"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \
\"8b0000\",\n  darksalmon: \"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  \
darkslateblue: \"483d8b\",\n  darkslategray: \"2f4f4f\",\n  darkslategrey: \
\"2f4f4f\",\n  darkturquoise: \"00ced1\",\n  darkviolet: \"9400d3\",\n  \
deeppink: \"ff1493\",\n  deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  \
dimgrey: \"696969\",\n  dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  \
floralwhite: \"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"f0f\",\n  \
gainsboro: \"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  \
goldenrod: \"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  \
greenyellow: \"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  \
hotpink: \"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  \
ivory: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  \
lavenderblush: \"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \
\"fffacd\",\n  lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  \
lightcyan: \"e0ffff\",\n  lightgoldenrodyellow: \"fafad2\",\n  lightgray: \
\"d3d3d3\",\n  lightgreen: \"90ee90\",\n  lightgrey: \"d3d3d3\",\n  \
lightpink: \"ffb6c1\",\n  lightsalmon: \"ffa07a\",\n  lightseagreen: \
\"20b2aa\",\n  lightskyblue: \"87cefa\",\n  lightslategray: \"789\",\n  \
lightslategrey: \"789\",\n  lightsteelblue: \"b0c4de\",\n  lightyellow: \
\"ffffe0\",\n  lime: \"0f0\",\n  limegreen: \"32cd32\",\n  linen: \
\"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \"800000\",\n  mediumaquamarine: \
\"66cdaa\",\n  mediumblue: \"0000cd\",\n  mediumorchid: \"ba55d3\",\n  \
mediumpurple: \"9370db\",\n  mediumseagreen: \"3cb371\",\n  mediumslateblue: \
\"7b68ee\",\n  mediumspringgreen: \"00fa9a\",\n  mediumturquoise: \
\"48d1cc\",\n  mediumvioletred: \"c71585\",\n  midnightblue: \"191970\",\n  \
mintcream: \"f5fffa\",\n  mistyrose: \"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  \
navajowhite: \"ffdead\",\n  navy: \"000080\",\n  oldlace: \"fdf5e6\",\n  \
olive: \"808000\",\n  olivedrab: \"6b8e23\",\n  orange: \"ffa500\",\n  \
orangered: \"ff4500\",\n  orchid: \"da70d6\",\n  palegoldenrod: \"eee8aa\",\n \
 palegreen: \"98fb98\",\n  paleturquoise: \"afeeee\",\n  palevioletred: \
\"db7093\",\n  papayawhip: \"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \
\"cd853f\",\n  pink: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \
\"b0e0e6\",\n  purple: \"800080\",\n  rebeccapurple: \"663399\",\n  red: \
\"f00\",\n  rosybrown: \"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \
\"8b4513\",\n  salmon: \"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \
\"2e8b57\",\n  seashell: \"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \
\"c0c0c0\",\n  skyblue: \"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \
\"708090\",\n  slategrey: \"708090\",\n  snow: \"fffafa\",\n  springgreen: \
\"00ff7f\",\n  steelblue: \"4682b4\",\n  tan: \"d2b48c\",\n  teal: \
\"008080\",\n  thistle: \"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \
\"40e0d0\",\n  violet: \"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n \
 whitesmoke: \"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \
\"9acd32\"\n};\nvar hexNames = tinycolor.hexNames = flip(names);\nfunction \
flip(o) {\n  var flipped = {};\n  for (var i in o) {\n    if \
(o.hasOwnProperty(i)) {\n      flipped[o[i]] = i;\n    }\n  }\n  return \
flipped;\n}\nfunction boundAlpha(a2) {\n  a2 = parseFloat(a2);\n  if \
(isNaN(a2) || a2 < 0 || a2 > 1) {\n    a2 = 1;\n  }\n  return \
a2;\n}\nfunction bound01(n, max2) {\n  if (isOnePointZero(n)) n = \"100%\";\n \
 var processPercent = isPercentage(n);\n  n = Math.min(max2, Math.max(0, \
parseFloat(n)));\n  if (processPercent) {\n    n = parseInt(n * max2, 10) / \
100;\n  }\n  if (Math.abs(n - max2) < 1e-6) {\n    return 1;\n  }\n  return n \
% max2 / parseFloat(max2);\n}\nfunction clamp01(val) {\n  return Math.min(1, \
Math.max(0, val));\n}\nfunction parseIntFromHex(val) {\n  return \
parseInt(val, 16);\n}\nfunction isOnePointZero(n) {\n  return typeof n == \
\"string\" && n.indexOf(\".\") != -1 && parseFloat(n) === 1;\n}\nfunction \
isPercentage(n) {\n  return typeof n === \"string\" && n.indexOf(\"%\") != \
-1;\n}\nfunction pad2(c2) {\n  return c2.length == 1 ? \"0\" + c2 : \"\" + \
c2;\n}\nfunction convertToPercentage(n) {\n  if (n <= 1) {\n    n = n * 100 + \
\"%\";\n  }\n  return n;\n}\nfunction convertDecimalToHex(d) {\n  return \
Math.round(parseFloat(d) * 255).toString(16);\n}\nfunction \
convertHexToDecimal(h) {\n  return parseIntFromHex(h) / 255;\n}\nvar matchers \
= function() {\n  var CSS_INTEGER = \"[-\\\\+]?\\\\d+%?\";\n  var CSS_NUMBER \
= \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";\n  var CSS_UNIT = \"(?:\" + CSS_NUMBER + \
\")|(?:\" + CSS_INTEGER + \")\";\n  var PERMISSIVE_MATCH3 = \
\"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \
\")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\n  var PERMISSIVE_MATCH4 = \
\"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \
\")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \
\")\\\\s*\\\\)?\";\n  return {\n    CSS_UNIT: new RegExp(CSS_UNIT),\n    rgb: \
new RegExp(\"rgb\" + PERMISSIVE_MATCH3),\n    rgba: new RegExp(\"rgba\" + \
PERMISSIVE_MATCH4),\n    hsl: new RegExp(\"hsl\" + PERMISSIVE_MATCH3),\n    \
hsla: new RegExp(\"hsla\" + PERMISSIVE_MATCH4),\n    hsv: new RegExp(\"hsv\" \
+ PERMISSIVE_MATCH3),\n    hsva: new RegExp(\"hsva\" + PERMISSIVE_MATCH4),\n  \
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex6: \
/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n    hex4: \
/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    \
hex8: \
/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/\n  \
};\n}();\nfunction isValidCSSUnit(color2) {\n  return \
!!matchers.CSS_UNIT.exec(color2);\n}\nfunction stringInputToObject(color2) \
{\n  color2 = color2.replace(trimLeft, \"\").replace(trimRight, \
\"\").toLowerCase();\n  var named = false;\n  if (names[color2]) {\n    \
color2 = names[color2];\n    named = true;\n  } else if (color2 == \
\"transparent\") {\n    return {\n      r: 0,\n      g: 0,\n      b: 0,\n     \
 a: 0,\n      format: \"name\"\n    };\n  }\n  var match;\n  if (match = \
matchers.rgb.exec(color2)) {\n    return {\n      r: match[1],\n      g: \
match[2],\n      b: match[3]\n    };\n  }\n  if (match = \
matchers.rgba.exec(color2)) {\n    return {\n      r: match[1],\n      g: \
match[2],\n      b: match[3],\n      a: match[4]\n    };\n  }\n  if (match = \
matchers.hsl.exec(color2)) {\n    return {\n      h: match[1],\n      s: \
match[2],\n      l: match[3]\n    };\n  }\n  if (match = \
matchers.hsla.exec(color2)) {\n    return {\n      h: match[1],\n      s: \
match[2],\n      l: match[3],\n      a: match[4]\n    };\n  }\n  if (match = \
matchers.hsv.exec(color2)) {\n    return {\n      h: match[1],\n      s: \
match[2],\n      v: match[3]\n    };\n  }\n  if (match = \
matchers.hsva.exec(color2)) {\n    return {\n      h: match[1],\n      s: \
match[2],\n      v: match[3],\n      a: match[4]\n    };\n  }\n  if (match = \
matchers.hex8.exec(color2)) {\n    return {\n      r: \
parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: \
parseIntFromHex(match[3]),\n      a: convertHexToDecimal(match[4]),\n      \
format: named ? \"name\" : \"hex8\"\n    };\n  }\n  if (match = \
matchers.hex6.exec(color2)) {\n    return {\n      r: \
parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: \
parseIntFromHex(match[3]),\n      format: named ? \"name\" : \"hex\"\n    \
};\n  }\n  if (match = matchers.hex4.exec(color2)) {\n    return {\n      r: \
parseIntFromHex(match[1] + \"\" + match[1]),\n      g: \
parseIntFromHex(match[2] + \"\" + match[2]),\n      b: \
parseIntFromHex(match[3] + \"\" + match[3]),\n      a: \
convertHexToDecimal(match[4] + \"\" + match[4]),\n      format: named ? \
\"name\" : \"hex8\"\n    };\n  }\n  if (match = matchers.hex3.exec(color2)) \
{\n    return {\n      r: parseIntFromHex(match[1] + \"\" + match[1]),\n      \
g: parseIntFromHex(match[2] + \"\" + match[2]),\n      b: \
parseIntFromHex(match[3] + \"\" + match[3]),\n      format: named ? \"name\" \
: \"hex\"\n    };\n  }\n  return false;\n}\nfunction \
validateWCAG2Parms(parms) {\n  var level, size;\n  parms = parms || {\n    \
level: \"AA\",\n    size: \"small\"\n  };\n  level = (parms.level || \
\"AA\").toUpperCase();\n  size = (parms.size || \"small\").toLowerCase();\n  \
if (level !== \"AA\" && level !== \"AAA\") {\n    level = \"AA\";\n  }\n  if \
(size !== \"small\" && size !== \"large\") {\n    size = \"small\";\n  }\n  \
return {\n    level,\n    size\n  };\n}\n\n// \
../../node_modules/three-forcegraph/dist/three-forcegraph.mjs\nfunction \
_arrayLikeToArray4(r, a2) {\n  (null == a2 || a2 > r.length) && (a2 = \
r.length);\n  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];\n  \
return n;\n}\nfunction _arrayWithHoles4(r) {\n  if (Array.isArray(r)) return \
r;\n}\nfunction _arrayWithoutHoles3(r) {\n  if (Array.isArray(r)) return \
_arrayLikeToArray4(r);\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 \
=== e) throw new ReferenceError(\"this hasn't been initialised - super() \
hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  \
return o = _getPrototypeOf(o), _possibleConstructorReturn(t, \
_isNativeReflectConstruct() ? Reflect.construct(o, e || [], \
_getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction \
_classCallCheck2(a2, n) {\n  if (!(a2 instanceof n)) throw new \
TypeError(\"Cannot call a class as a function\");\n}\nfunction _construct(t, \
e, r) {\n  if (_isNativeReflectConstruct()) return \
Reflect.construct.apply(null, arguments);\n  var o = [null];\n  \
o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return \
p;\n}\nfunction _createClass2(e, r, t) {\n  return Object.defineProperty(e, \
\"prototype\", {\n    writable: false\n  }), e;\n}\nfunction \
_defineProperty2(e, r, t) {\n  return (r = _toPropertyKey3(r)) in e ? \
Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    \
configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction \
_getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? \
Object.getPrototypeOf.bind() : function(t2) {\n    return t2.__proto__ || \
Object.getPrototypeOf(t2);\n  }, _getPrototypeOf(t);\n}\nfunction \
_inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new \
TypeError(\"Super expression must either be null or a function\");\n  \
t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      \
value: t,\n      writable: true,\n      configurable: true\n    }\n  }), \
Object.defineProperty(t, \"prototype\", {\n    writable: false\n  }), e && \
_setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n  \
  var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], \
function() {\n    }));\n  } catch (t2) {\n  }\n  return \
(_isNativeReflectConstruct = function() {\n    return !!t;\n  \
})();\n}\nfunction _iterableToArray3(r) {\n  if (\"undefined\" != typeof \
Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return \
Array.from(r);\n}\nfunction _iterableToArrayLimit4(r, l) {\n  var t = null == \
r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || \
r[\"@@iterator\"];\n  if (null != t) {\n    var e, n, i, u, a2 = [], f = \
true, o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ;\n \
     else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length \
!== l); f = true) ;\n    } catch (r2) {\n      o = true, n = r2;\n    } \
finally {\n      try {\n        if (!f && null != t.return && (u = \
t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) \
throw n;\n      }\n    }\n    return a2;\n  }\n}\nfunction \
_nonIterableRest4() {\n  throw new TypeError(\"Invalid attempt to destructure \
non-iterable instance.\\nIn order to be iterable, non-array objects must have \
a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread3() {\n  \
throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn \
order to be iterable, non-array objects must have a [Symbol.iterator]() \
method.\");\n}\nfunction ownKeys2(e, r) {\n  var t = Object.keys(e);\n  if \
(Object.getOwnPropertySymbols) {\n    var o = \
Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function(r2) {\n     \
 return Object.getOwnPropertyDescriptor(e, r2).enumerable;\n    })), \
t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread22(e) {\n  \
for (var r = 1; r < arguments.length; r++) {\n    var t = null != \
arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys2(Object(t), \
true).forEach(function(r2) {\n      _defineProperty2(e, r2, t[r2]);\n    }) : \
Object.getOwnPropertyDescriptors ? Object.defineProperties(e, \
Object.getOwnPropertyDescriptors(t)) : \
ownKeys2(Object(t)).forEach(function(r2) {\n      Object.defineProperty(e, \
r2, Object.getOwnPropertyDescriptor(t, r2));\n    });\n  }\n  return \
e;\n}\nfunction _objectWithoutProperties3(e, t) {\n  if (null == e) return \
{};\n  var o, r, i = _objectWithoutPropertiesLoose3(e, t);\n  if \
(Object.getOwnPropertySymbols) {\n    var s = \
Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = \
s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n \
 }\n  return i;\n}\nfunction _objectWithoutPropertiesLoose3(r, e) {\n  if \
(null == r) return {};\n  var t = {};\n  for (var n in r) if \
({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] \
= r[n];\n  }\n  return t;\n}\nfunction _possibleConstructorReturn(t, e) {\n  \
if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  \
if (void 0 !== e) throw new TypeError(\"Derived constructors may only return \
object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction \
_setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? \
Object.setPrototypeOf.bind() : function(t2, e2) {\n    return t2.__proto__ = \
e2, t2;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray4(r, e) {\n  \
return _arrayWithHoles4(r) || _iterableToArrayLimit4(r, e) || \
_unsupportedIterableToArray4(r, e) || _nonIterableRest4();\n}\nfunction \
_toConsumableArray3(r) {\n  return _arrayWithoutHoles3(r) || \
_iterableToArray3(r) || _unsupportedIterableToArray4(r) || \
_nonIterableSpread3();\n}\nfunction _toPrimitive3(t, r) {\n  if (\"object\" \
!= typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 \
!== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != \
typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (\"string\" === r ? String : \
Number)(t);\n}\nfunction _toPropertyKey3(t) {\n  var i = _toPrimitive3(t, \
\"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction \
_typeof2(o) {\n  \"@babel/helpers - typeof\";\n  return _typeof2 = \
\"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? \
function(o2) {\n    return typeof o2;\n  } : function(o2) {\n    return o2 && \
\"function\" == typeof Symbol && o2.constructor === Symbol && o2 !== \
Symbol.prototype ? \"symbol\" : typeof o2;\n  }, _typeof2(o);\n}\nfunction \
_unsupportedIterableToArray4(r, a2) {\n  if (r) {\n    if (\"string\" == \
typeof r) return _arrayLikeToArray4(r, a2);\n    var t = \
{}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && \
r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? \
Array.from(r) : \"Arguments\" === t || \
/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray4(r, \
a2) : void 0;\n  }\n}\nvar _materialDispose = function \
materialDispose(material) {\n  if (material instanceof Array) {\n    \
material.forEach(_materialDispose);\n  } else {\n    if (material.map) {\n    \
  material.map.dispose();\n    }\n    material.dispose();\n  }\n};\nvar \
_deallocate = function deallocate(obj) {\n  if (obj.geometry) {\n    \
obj.geometry.dispose();\n  }\n  if (obj.material) {\n    \
_materialDispose(obj.material);\n  }\n  if (obj.texture) {\n    \
obj.texture.dispose();\n  }\n  if (obj.children) {\n    \
obj.children.forEach(_deallocate);\n  }\n};\nvar emptyObject = function \
emptyObject2(obj) {\n  while (obj.children.length) {\n    var childObj = \
obj.children[0];\n    obj.remove(childObj);\n    _deallocate(childObj);\n  \
}\n};\nvar _excluded2 = [\"objFilter\"];\nfunction threeDigest(data, scene3) \
{\n  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : {}, _ref$objFilter = _ref.objFilter, objFilter = \
_ref$objFilter === void 0 ? function() {\n    return true;\n  } : \
_ref$objFilter, options = _objectWithoutProperties3(_ref, _excluded2);\n  \
return viewDigest(data, scene3.children.filter(objFilter), function(obj) {\n  \
  return scene3.add(obj);\n  }, function(obj) {\n    scene3.remove(obj);\n    \
emptyObject(obj);\n  }, _objectSpread22({\n    objBindAttr: \"__threeObj\"\n  \
}, options));\n}\nvar colorStr2Hex = function colorStr2Hex2(str) {\n  return \
isNaN(str) ? parseInt(tinycolor(str).toHex(), 16) : str;\n};\nvar colorAlpha \
= function colorAlpha2(str) {\n  return isNaN(str) ? \
tinycolor(str).getAlpha() : 1;\n};\nvar autoColorScale = \
ordinal(Paired_default);\nfunction autoColorObjects(objects, colorByAccessor, \
colorField) {\n  if (!colorByAccessor || typeof colorField !== \"string\") \
return;\n  objects.filter(function(obj) {\n    return !obj[colorField];\n  \
}).forEach(function(obj) {\n    obj[colorField] = \
autoColorScale(colorByAccessor(obj));\n  });\n}\nfunction getDagDepths(_ref, \
idAccessor) {\n  var nodes = _ref.nodes, links = _ref.links;\n  var _ref2 = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, \
_ref2$nodeFilter = _ref2.nodeFilter, nodeFilter = _ref2$nodeFilter === void 0 \
? function() {\n    return true;\n  } : _ref2$nodeFilter, _ref2$onLoopError = \
_ref2.onLoopError, onLoopError = _ref2$onLoopError === void 0 ? \
function(loopIds) {\n    throw \"Invalid DAG structure! Found cycle in node \
path: \".concat(loopIds.join(\" -> \"), \".\");\n  } : _ref2$onLoopError;\n  \
var graph2 = {};\n  nodes.forEach(function(node) {\n    return \
graph2[idAccessor(node)] = {\n      data: node,\n      out: [],\n      depth: \
-1,\n      skip: !nodeFilter(node)\n    };\n  });\n  \
links.forEach(function(_ref3) {\n    var source = _ref3.source, target = \
_ref3.target;\n    var sourceId = getNodeId(source);\n    var targetId = \
getNodeId(target);\n    if (!graph2.hasOwnProperty(sourceId)) throw \"Missing \
source node with id: \".concat(sourceId);\n    if \
(!graph2.hasOwnProperty(targetId)) throw \"Missing target node with id: \
\".concat(targetId);\n    var sourceNode = graph2[sourceId];\n    var \
targetNode = graph2[targetId];\n    sourceNode.out.push(targetNode);\n    \
function getNodeId(node) {\n      return _typeof2(node) === \"object\" ? \
idAccessor(node) : node;\n    }\n  });\n  var foundLoops = [];\n  \
traverse(Object.values(graph2));\n  var nodeDepths = \
Object.assign.apply(Object, \
[{}].concat(_toConsumableArray3(Object.entries(graph2).filter(function(_ref4) \
{\n    var _ref5 = _slicedToArray4(_ref4, 2), node = _ref5[1];\n    return \
!node.skip;\n  }).map(function(_ref6) {\n    var _ref7 = \
_slicedToArray4(_ref6, 2), id2 = _ref7[0], node = _ref7[1];\n    return \
_defineProperty2({}, id2, node.depth);\n  }))));\n  return nodeDepths;\n  \
function traverse(nodes2) {\n    var nodeStack = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : [];\n    var currentDepth = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    var \
_loop = function _loop2() {\n      var node = nodes2[i];\n      if \
(nodeStack.indexOf(node) !== -1) {\n        var loop = \
[].concat(_toConsumableArray3(nodeStack.slice(nodeStack.indexOf(node))), \
[node]).map(function(d) {\n          return idAccessor(d.data);\n        \
});\n        if (!foundLoops.some(function(foundLoop) {\n          return \
foundLoop.length === loop.length && foundLoop.every(function(id2, idx) {\n    \
        return id2 === loop[idx];\n          });\n        })) {\n          \
foundLoops.push(loop);\n          onLoopError(loop);\n        }\n        \
return 1;\n      }\n      if (currentDepth > node.depth) {\n        \
node.depth = currentDepth;\n        traverse(node.out, \
[].concat(_toConsumableArray3(nodeStack), [node]), currentDepth + (node.skip \
? 0 : 1));\n      }\n    };\n    for (var i = 0, l = nodes2.length; i < l; \
i++) {\n      if (_loop()) continue;\n    }\n  }\n}\nvar three$1 = \
window.THREE ? window.THREE : {\n  Group,\n  Mesh,\n  MeshLambertMaterial,\n  \
Color,\n  BufferGeometry,\n  BufferAttribute,\n  Matrix4,\n  Vector3,\n  \
SphereGeometry,\n  CylinderGeometry,\n  TubeGeometry,\n  ConeGeometry,\n  \
Line,\n  LineBasicMaterial,\n  QuadraticBezierCurve3,\n  CubicBezierCurve3,\n \
 Box3\n};\nvar ngraph = {\n  graph: import_ngraph.default,\n  forcelayout: \
import_ngraph2.default\n};\nvar DAG_LEVEL_NODE_RATIO = 2;\nvar setAttributeFn \
= new three$1.BufferGeometry().setAttribute ? \"setAttribute\" : \
\"addAttribute\";\nvar applyMatrix4Fn = new \
three$1.BufferGeometry().applyMatrix4 ? \"applyMatrix4\" : \
\"applyMatrix\";\nvar ForceGraph = index2({\n  props: {\n    jsonUrl: {\n     \
 onChange: function onChange(jsonUrl, state) {\n        var _this = this;\n   \
     if (jsonUrl && !state.fetchingJson) {\n          state.fetchingJson = \
true;\n          state.onLoading();\n          \
fetch(jsonUrl).then(function(r) {\n            return r.json();\n          \
}).then(function(json) {\n            state.fetchingJson = false;\n           \
 state.onFinishLoading(json);\n            _this.graphData(json);\n          \
});\n        }\n      },\n      triggerUpdate: false\n    },\n    graphData: \
{\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n    \
  onChange: function onChange2(graphData, state) {\n        \
state.engineRunning = false;\n      }\n    },\n    numDimensions: {\n      \
\"default\": 3,\n      onChange: function onChange3(numDim, state) {\n        \
var chargeForce = state.d3ForceLayout.force(\"charge\");\n        if \
(chargeForce) {\n          chargeForce.strength(numDim > 2 ? -60 : -30);\n    \
    }\n        if (numDim < 3) {\n          \
eraseDimension(state.graphData.nodes, \"z\");\n        }\n        if (numDim \
< 2) {\n          eraseDimension(state.graphData.nodes, \"y\");\n        }\n  \
      function eraseDimension(nodes, dim) {\n          \
nodes.forEach(function(d) {\n            delete d[dim];\n            delete \
d[\"v\".concat(dim)];\n          });\n        }\n      }\n    },\n    \
dagMode: {\n      onChange: function onChange4(dagMode, state) {\n        \
!dagMode && state.forceEngine === \"d3\" && (state.graphData.nodes || \
[]).forEach(function(n) {\n          return n.fx = n.fy = n.fz = void 0;\n    \
    });\n      }\n    },\n    dagLevelDistance: {},\n    dagNodeFilter: {\n   \
   \"default\": function _default(node) {\n        return true;\n      }\n    \
},\n    onDagError: {\n      triggerUpdate: false\n    },\n    nodeRelSize: \
{\n      \"default\": 4\n    },\n    // volume per val unit\n    nodeId: {\n  \
    \"default\": \"id\"\n    },\n    nodeVal: {\n      \"default\": \"val\"\n \
   },\n    nodeResolution: {\n      \"default\": 8\n    },\n    // how many \
slice segments in the sphere's circumference\n    nodeColor: {\n      \
\"default\": \"color\"\n    },\n    nodeAutoColorBy: {},\n    nodeOpacity: \
{\n      \"default\": 0.75\n    },\n    nodeVisibility: {\n      \"default\": \
true\n    },\n    nodeThreeObject: {},\n    nodeThreeObjectExtend: {\n      \
\"default\": false\n    },\n    nodePositionUpdate: {\n      triggerUpdate: \
false\n    },\n    // custom function to call for updating the node's \
position. Signature: (threeObj, { x, y, z}, node). If the function returns a \
truthy value, the regular node position update will not run.\n    linkSource: \
{\n      \"default\": \"source\"\n    },\n    linkTarget: {\n      \
\"default\": \"target\"\n    },\n    linkVisibility: {\n      \"default\": \
true\n    },\n    linkColor: {\n      \"default\": \"color\"\n    },\n    \
linkAutoColorBy: {},\n    linkOpacity: {\n      \"default\": 0.2\n    },\n    \
linkWidth: {},\n    // Rounded to nearest decimal. For falsy values use \
dimensionless line with 1px regardless of distance.\n    linkResolution: {\n  \
    \"default\": 6\n    },\n    // how many radial segments in each line \
tube's geometry\n    linkCurvature: {\n      \"default\": 0,\n      \
triggerUpdate: false\n    },\n    // line curvature radius (0: straight, 1: \
semi-circle)\n    linkCurveRotation: {\n      \"default\": 0,\n      \
triggerUpdate: false\n    },\n    // line curve rotation along the line axis \
(0: interection with XY plane, PI: upside down)\n    linkMaterial: {},\n    \
linkThreeObject: {},\n    linkThreeObjectExtend: {\n      \"default\": \
false\n    },\n    linkPositionUpdate: {\n      triggerUpdate: false\n    \
},\n    // custom function to call for updating the link's position. \
Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the \
function returns a truthy value, the regular link position update will not \
run.\n    linkDirectionalArrowLength: {\n      \"default\": 0\n    },\n    \
linkDirectionalArrowColor: {},\n    linkDirectionalArrowRelPos: {\n      \
\"default\": 0.5,\n      triggerUpdate: false\n    },\n    // value between \
0<>1 indicating the relative pos along the (exposed) line\n    \
linkDirectionalArrowResolution: {\n      \"default\": 8\n    },\n    // how \
many slice segments in the arrow's conic circumference\n    \
linkDirectionalParticles: {\n      \"default\": 0\n    },\n    // animate \
photons travelling in the link direction\n    linkDirectionalParticleSpeed: \
{\n      \"default\": 0.01,\n      triggerUpdate: false\n    },\n    // in \
link length ratio per frame\n    linkDirectionalParticleWidth: {\n      \
\"default\": 0.5\n    },\n    linkDirectionalParticleColor: {},\n    \
linkDirectionalParticleResolution: {\n      \"default\": 4\n    },\n    // \
how many slice segments in the particle sphere's circumference\n    \
forceEngine: {\n      \"default\": \"d3\"\n    },\n    // d3 or ngraph\n    \
d3AlphaMin: {\n      \"default\": 0\n    },\n    d3AlphaDecay: {\n      \
\"default\": 0.0228,\n      triggerUpdate: false,\n      onChange: function \
onChange5(alphaDecay, state) {\n        \
state.d3ForceLayout.alphaDecay(alphaDecay);\n      }\n    },\n    \
d3AlphaTarget: {\n      \"default\": 0,\n      triggerUpdate: false,\n      \
onChange: function onChange6(alphaTarget, state) {\n        \
state.d3ForceLayout.alphaTarget(alphaTarget);\n      }\n    },\n    \
d3VelocityDecay: {\n      \"default\": 0.4,\n      triggerUpdate: false,\n    \
  onChange: function onChange7(velocityDecay, state) {\n        \
state.d3ForceLayout.velocityDecay(velocityDecay);\n      }\n    },\n    \
ngraphPhysics: {\n      \"default\": {\n        // defaults from \
https://github.com/anvaka/ngraph.physics.simulator/blob/master/index.js\n     \
   timeStep: 20,\n        gravity: -1.2,\n        theta: 0.8,\n        \
springLength: 30,\n        springCoefficient: 8e-4,\n        dragCoefficient: \
0.02\n      }\n    },\n    warmupTicks: {\n      \"default\": 0,\n      \
triggerUpdate: false\n    },\n    // how many times to tick the force engine \
at init before starting to render\n    cooldownTicks: {\n      \"default\": \
Infinity,\n      triggerUpdate: false\n    },\n    cooldownTime: {\n      \
\"default\": 15e3,\n      triggerUpdate: false\n    },\n    // ms\n    \
onLoading: {\n      \"default\": function _default2() {\n      },\n      \
triggerUpdate: false\n    },\n    onFinishLoading: {\n      \"default\": \
function _default3() {\n      },\n      triggerUpdate: false\n    },\n    \
onUpdate: {\n      \"default\": function _default4() {\n      },\n      \
triggerUpdate: false\n    },\n    onFinishUpdate: {\n      \"default\": \
function _default5() {\n      },\n      triggerUpdate: false\n    },\n    \
onEngineTick: {\n      \"default\": function _default6() {\n      },\n      \
triggerUpdate: false\n    },\n    onEngineStop: {\n      \"default\": \
function _default7() {\n      },\n      triggerUpdate: false\n    }\n  },\n  \
methods: {\n    refresh: function refresh(state) {\n      state._flushObjects \
= true;\n      state._rerender();\n      return this;\n    },\n    // Expose \
d3 forces for external manipulation\n    d3Force: function d3Force(state, \
forceName, forceFn) {\n      if (forceFn === void 0) {\n        return \
state.d3ForceLayout.force(forceName);\n      }\n      \
state.d3ForceLayout.force(forceName, forceFn);\n      return this;\n    },\n  \
  d3ReheatSimulation: function d3ReheatSimulation(state) {\n      \
state.d3ForceLayout.alpha(1);\n      this.resetCountdown();\n      return \
this;\n    },\n    // reset cooldown state\n    resetCountdown: function \
resetCountdown(state) {\n      state.cntTicks = 0;\n      state.startTickTime \
= /* @__PURE__ */ new Date();\n      state.engineRunning = true;\n      \
return this;\n    },\n    tickFrame: function tickFrame(state) {\n      var \
isD3Sim = state.forceEngine !== \"ngraph\";\n      if (state.engineRunning) \
{\n        layoutTick();\n      }\n      updateArrows();\n      \
updatePhotons();\n      return this;\n      function layoutTick() {\n        \
if (++state.cntTicks > state.cooldownTicks || /* @__PURE__ */ new Date() - \
state.startTickTime > state.cooldownTime || isD3Sim && state.d3AlphaMin > 0 \
&& state.d3ForceLayout.alpha() < state.d3AlphaMin) {\n          \
state.engineRunning = false;\n          state.onEngineStop();\n        } else \
{\n          state.layout[isD3Sim ? \"tick\" : \"step\"]();\n          \
state.onEngineTick();\n        }\n        var nodeThreeObjectExtendAccessor = \
index3(state.nodeThreeObjectExtend);\n        \
state.graphData.nodes.forEach(function(node) {\n          var obj = \
node.__threeObj;\n          if (!obj) return;\n          var pos = isD3Sim ? \
node : state.layout.getNodePosition(node[state.nodeId]);\n          var \
extendedObj = nodeThreeObjectExtendAccessor(node);\n          if \
(!state.nodePositionUpdate || !state.nodePositionUpdate(extendedObj ? \
obj.children[0] : obj, {\n            x: pos.x,\n            y: pos.y,\n      \
      z: pos.z\n          }, node) || extendedObj) {\n            \
obj.position.x = pos.x;\n            obj.position.y = pos.y || 0;\n           \
 obj.position.z = pos.z || 0;\n          }\n        });\n        var \
linkWidthAccessor = index3(state.linkWidth);\n        var \
linkCurvatureAccessor = index3(state.linkCurvature);\n        var \
linkCurveRotationAccessor = index3(state.linkCurveRotation);\n        var \
linkThreeObjectExtendAccessor = index3(state.linkThreeObjectExtend);\n        \
state.graphData.links.forEach(function(link) {\n          var lineObj = \
link.__lineObj;\n          if (!lineObj) return;\n          var pos = isD3Sim \
? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, \
link.target).id);\n          var start = pos[isD3Sim ? \"source\" : \
\"from\"];\n          var end = pos[isD3Sim ? \"target\" : \"to\"];\n         \
 if (!start || !end || !start.hasOwnProperty(\"x\") || \
!end.hasOwnProperty(\"x\")) return;\n          calcLinkCurve(link);\n         \
 var extendedObj = linkThreeObjectExtendAccessor(link);\n          if \
(state.linkPositionUpdate && state.linkPositionUpdate(\n            \
extendedObj ? lineObj.children[1] : lineObj,\n            // pass child \
custom object if extending the default\n            {\n              start: \
{\n                x: start.x,\n                y: start.y,\n                \
z: start.z\n              },\n              end: {\n                x: \
end.x,\n                y: end.y,\n                z: end.z\n              \
}\n            },\n            link\n          ) && !extendedObj) {\n         \
   return;\n          }\n          var curveResolution = 30;\n          var \
curve = link.__curve;\n          var line = lineObj.children.length ? \
lineObj.children[0] : lineObj;\n          if (line.type === \"Line\") {\n     \
       if (!curve) {\n              var linePos = \
line.geometry.getAttribute(\"position\");\n              if (!linePos || \
!linePos.array || linePos.array.length !== 6) {\n                \
line.geometry[setAttributeFn](\"position\", linePos = new \
three$1.BufferAttribute(new Float32Array(2 * 3), 3));\n              }\n      \
        linePos.array[0] = start.x;\n              linePos.array[1] = start.y \
|| 0;\n              linePos.array[2] = start.z || 0;\n              \
linePos.array[3] = end.x;\n              linePos.array[4] = end.y || 0;\n     \
         linePos.array[5] = end.z || 0;\n              linePos.needsUpdate = \
true;\n            } else {\n              var curvePnts = \
curve.getPoints(curveResolution);\n              if \
(line.geometry.getAttribute(\"position\").array.length !== curvePnts.length * \
3) {\n                line.geometry[setAttributeFn](\"position\", new \
three$1.BufferAttribute(new Float32Array(curvePnts.length * 3), 3));\n        \
      }\n              line.geometry.setFromPoints(curvePnts);\n            \
}\n            line.geometry.computeBoundingSphere();\n          } else if \
(line.type === \"Mesh\") {\n            if (!curve) {\n              if \
(!line.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {\n                \
var linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;\n               \
 var r = linkWidth / 2;\n                var geometry = new \
three$1.CylinderGeometry(r, r, 1, state.linkResolution, 1, false);\n          \
      geometry[applyMatrix4Fn](new three$1.Matrix4().makeTranslation(0, 1 / \
2, 0));\n                geometry[applyMatrix4Fn](new \
three$1.Matrix4().makeRotationX(Math.PI / 2));\n                \
line.geometry.dispose();\n                line.geometry = geometry;\n         \
     }\n              var vStart = new three$1.Vector3(start.x, start.y || 0, \
start.z || 0);\n              var vEnd = new three$1.Vector3(end.x, end.y || \
0, end.z || 0);\n              var distance2 = vStart.distanceTo(vEnd);\n     \
         line.position.x = vStart.x;\n              line.position.y = \
vStart.y;\n              line.position.z = vStart.z;\n              \
line.scale.z = distance2;\n              line.parent.localToWorld(vEnd);\n    \
          line.lookAt(vEnd);\n            } else {\n              if \
(!line.geometry.type.match(/^Tube(Buffer)?Geometry$/)) {\n                \
line.position.set(0, 0, 0);\n                line.rotation.set(0, 0, 0);\n    \
            line.scale.set(1, 1, 1);\n              }\n              var \
_linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;\n              var \
_r = _linkWidth / 2;\n              var _geometry3 = new \
three$1.TubeGeometry(curve, curveResolution, _r, state.linkResolution, \
false);\n              line.geometry.dispose();\n              line.geometry \
= _geometry3;\n            }\n          }\n        });\n        function \
calcLinkCurve(link) {\n          var pos = isD3Sim ? link : \
state.layout.getLinkPosition(state.layout.graph.getLink(link.source, \
link.target).id);\n          var start = pos[isD3Sim ? \"source\" : \
\"from\"];\n          var end = pos[isD3Sim ? \"target\" : \"to\"];\n         \
 if (!start || !end || !start.hasOwnProperty(\"x\") || \
!end.hasOwnProperty(\"x\")) return;\n          var curvature = \
linkCurvatureAccessor(link);\n          if (!curvature) {\n            \
link.__curve = null;\n          } else {\n            var vStart = new \
three$1.Vector3(start.x, start.y || 0, start.z || 0);\n            var vEnd = \
new three$1.Vector3(end.x, end.y || 0, end.z || 0);\n            var l = \
vStart.distanceTo(vEnd);\n            var curve;\n            var \
curveRotation = linkCurveRotationAccessor(link);\n            if (l > 0) {\n  \
            var dx = end.x - start.x;\n              var dy = end.y - start.y \
|| 0;\n              var vLine = new three$1.Vector3().subVectors(vEnd, \
vStart);\n              var cp = \
vLine.clone().multiplyScalar(curvature).cross(dx !== 0 || dy !== 0 ? new \
three$1.Vector3(0, 0, 1) : new three$1.Vector3(0, 1, \
0)).applyAxisAngle(vLine.normalize(), curveRotation).add(new \
three$1.Vector3().addVectors(vStart, vEnd).divideScalar(2));\n              \
curve = new three$1.QuadraticBezierCurve3(vStart, cp, vEnd);\n            } \
else {\n              var d = curvature * 70;\n              var endAngle = \
-curveRotation;\n              var startAngle = endAngle + Math.PI / 2;\n     \
         curve = new three$1.CubicBezierCurve3(vStart, new three$1.Vector3(d \
* Math.cos(startAngle), d * Math.sin(startAngle), 0).add(vStart), new \
three$1.Vector3(d * Math.cos(endAngle), d * Math.sin(endAngle), \
0).add(vStart), vEnd);\n            }\n            link.__curve = curve;\n    \
      }\n        }\n      }\n      function updateArrows() {\n        var \
arrowRelPosAccessor = index3(state.linkDirectionalArrowRelPos);\n        var \
arrowLengthAccessor = index3(state.linkDirectionalArrowLength);\n        var \
nodeValAccessor = index3(state.nodeVal);\n        \
state.graphData.links.forEach(function(link) {\n          var arrowObj = \
link.__arrowObj;\n          if (!arrowObj) return;\n          var pos = \
isD3Sim ? link : \
state.layout.getLinkPosition(state.layout.graph.getLink(link.source, \
link.target).id);\n          var start = pos[isD3Sim ? \"source\" : \
\"from\"];\n          var end = pos[isD3Sim ? \"target\" : \"to\"];\n         \
 if (!start || !end || !start.hasOwnProperty(\"x\") || \
!end.hasOwnProperty(\"x\")) return;\n          var startR = \
Math.cbrt(Math.max(0, nodeValAccessor(start) || 1)) * state.nodeRelSize;\n    \
      var endR = Math.cbrt(Math.max(0, nodeValAccessor(end) || 1)) * \
state.nodeRelSize;\n          var arrowLength = arrowLengthAccessor(link);\n  \
        var arrowRelPos = arrowRelPosAccessor(link);\n          var \
getPosAlongLine = link.__curve ? function(t) {\n            return \
link.__curve.getPoint(t);\n          } : function(t) {\n            var iplt \
= function iplt2(dim, start2, end2, t2) {\n              return start2[dim] + \
(end2[dim] - start2[dim]) * t2 || 0;\n            };\n            return {\n  \
            x: iplt(\"x\", start, end, t),\n              y: iplt(\"y\", \
start, end, t),\n              z: iplt(\"z\", start, end, t)\n            \
};\n          };\n          var lineLen = link.__curve ? \
link.__curve.getLength() : Math.sqrt([\"x\", \"y\", \"z\"].map(function(dim) \
{\n            return Math.pow((end[dim] || 0) - (start[dim] || 0), 2);\n     \
     }).reduce(function(acc, v) {\n            return acc + v;\n          }, \
0));\n          var posAlongLine = startR + arrowLength + (lineLen - startR - \
endR - arrowLength) * arrowRelPos;\n          var arrowHead = \
getPosAlongLine(posAlongLine / lineLen);\n          var arrowTail = \
getPosAlongLine((posAlongLine - arrowLength) / lineLen);\n          [\"x\", \
\"y\", \"z\"].forEach(function(dim) {\n            return \
arrowObj.position[dim] = arrowTail[dim];\n          });\n          var \
headVec = _construct(three$1.Vector3, _toConsumableArray3([\"x\", \"y\", \
\"z\"].map(function(c2) {\n            return arrowHead[c2];\n          \
})));\n          arrowObj.parent.localToWorld(headVec);\n          \
arrowObj.lookAt(headVec);\n        });\n      }\n      function \
updatePhotons() {\n        var particleSpeedAccessor = \
index3(state.linkDirectionalParticleSpeed);\n        \
state.graphData.links.forEach(function(link) {\n          var cyclePhotons = \
link.__photonsObj && link.__photonsObj.children;\n          var \
singleHopPhotons = link.__singleHopPhotonsObj && \
link.__singleHopPhotonsObj.children;\n          if ((!singleHopPhotons || \
!singleHopPhotons.length) && (!cyclePhotons || !cyclePhotons.length)) \
return;\n          var pos = isD3Sim ? link : \
state.layout.getLinkPosition(state.layout.graph.getLink(link.source, \
link.target).id);\n          var start = pos[isD3Sim ? \"source\" : \
\"from\"];\n          var end = pos[isD3Sim ? \"target\" : \"to\"];\n         \
 if (!start || !end || !start.hasOwnProperty(\"x\") || \
!end.hasOwnProperty(\"x\")) return;\n          var particleSpeed = \
particleSpeedAccessor(link);\n          var getPhotonPos = link.__curve ? \
function(t) {\n            return link.__curve.getPoint(t);\n          } : \
function(t) {\n            var iplt = function iplt2(dim, start2, end2, t2) \
{\n              return start2[dim] + (end2[dim] - start2[dim]) * t2 || 0;\n  \
          };\n            return {\n              x: iplt(\"x\", start, end, \
t),\n              y: iplt(\"y\", start, end, t),\n              z: \
iplt(\"z\", start, end, t)\n            };\n          };\n          var \
photons = [].concat(_toConsumableArray3(cyclePhotons || []), \
_toConsumableArray3(singleHopPhotons || []));\n          \
photons.forEach(function(photon, idx) {\n            var singleHop = \
photon.parent.__linkThreeObjType === \"singleHopPhotons\";\n            if \
(!photon.hasOwnProperty(\"__progressRatio\")) {\n              \
photon.__progressRatio = singleHop ? 0 : idx / cyclePhotons.length;\n         \
   }\n            photon.__progressRatio += particleSpeed;\n            if \
(photon.__progressRatio >= 1) {\n              if (!singleHop) {\n            \
    photon.__progressRatio = photon.__progressRatio % 1;\n              } \
else {\n                photon.parent.remove(photon);\n                \
emptyObject(photon);\n                return;\n              }\n            \
}\n            var photonPosRatio = photon.__progressRatio;\n            var \
pos2 = getPhotonPos(photonPosRatio);\n            [\"x\", \"y\", \
\"z\"].forEach(function(dim) {\n              return photon.position[dim] = \
pos2[dim];\n            });\n          });\n        });\n      }\n    },\n    \
emitParticle: function emitParticle(state, link) {\n      if (link && \
state.graphData.links.includes(link)) {\n        if \
(!link.__singleHopPhotonsObj) {\n          var obj = new three$1.Group();\n   \
       obj.__linkThreeObjType = \"singleHopPhotons\";\n          \
link.__singleHopPhotonsObj = obj;\n          state.graphScene.add(obj);\n     \
   }\n        var particleWidthAccessor = \
index3(state.linkDirectionalParticleWidth);\n        var photonR = \
Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;\n        var \
numSegments = state.linkDirectionalParticleResolution;\n        var \
particleGeometry = new three$1.SphereGeometry(photonR, numSegments, \
numSegments);\n        var linkColorAccessor = index3(state.linkColor);\n     \
   var particleColorAccessor = index3(state.linkDirectionalParticleColor);\n  \
      var photonColor = particleColorAccessor(link) || \
linkColorAccessor(link) || \"#f0f0f0\";\n        var materialColor2 = new \
three$1.Color(colorStr2Hex(photonColor));\n        var opacity = \
state.linkOpacity * 3;\n        var particleMaterial = new \
three$1.MeshLambertMaterial({\n          color: materialColor2,\n          \
transparent: true,\n          opacity\n        });\n        \
link.__singleHopPhotonsObj.add(new three$1.Mesh(particleGeometry, \
particleMaterial));\n      }\n      return this;\n    },\n    getGraphBbox: \
function getGraphBbox(state) {\n      var nodeFilter = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : function() {\n        return \
true;\n      };\n      if (!state.initialised) return null;\n      var bboxes \
= function getBboxes(obj) {\n        var bboxes2 = [];\n        if \
(obj.geometry) {\n          obj.geometry.computeBoundingBox();\n          var \
box = new three$1.Box3();\n          \
box.copy(obj.geometry.boundingBox).applyMatrix4(obj.matrixWorld);\n          \
bboxes2.push(box);\n        }\n        return bboxes2.concat.apply(bboxes2, \
_toConsumableArray3((obj.children || []).filter(\n          function(obj2) \
{\n            return !obj2.hasOwnProperty(\"__graphObjType\") || \
obj2.__graphObjType === \"node\" && nodeFilter(obj2.__data);\n          }\n   \
       // exclude filtered out nodes\n        ).map(getBboxes)));\n      \
}(state.graphScene);\n      if (!bboxes.length) return null;\n      return \
Object.assign.apply(Object, _toConsumableArray3([\"x\", \"y\", \
\"z\"].map(function(c2) {\n        return _defineProperty2({}, c2, \
[min(bboxes, function(bb) {\n          return bb.min[c2];\n        }), \
max(bboxes, function(bb) {\n          return bb.max[c2];\n        })]);\n     \
 })));\n    }\n  },\n  stateInit: function stateInit() {\n    return {\n      \
d3ForceLayout: simulation_default().force(\"link\", \
link_default()).force(\"charge\", manyBody_default()).force(\"center\", \
center_default()).force(\"dagRadial\", null).stop(),\n      engineRunning: \
false\n    };\n  },\n  init: function init(threeObj, state) {\n    \
state.graphScene = threeObj;\n  },\n  update: function update(state, \
changedProps) {\n    var hasAnyPropChanged = function \
hasAnyPropChanged2(propList) {\n      return propList.some(function(p) {\n    \
    return changedProps.hasOwnProperty(p);\n      });\n    };\n    \
state.engineRunning = false;\n    state.onUpdate();\n    if \
(state.nodeAutoColorBy !== null && hasAnyPropChanged([\"nodeAutoColorBy\", \
\"graphData\", \"nodeColor\"])) {\n      \
autoColorObjects(state.graphData.nodes, index3(state.nodeAutoColorBy), \
state.nodeColor);\n    }\n    if (state.linkAutoColorBy !== null && \
hasAnyPropChanged([\"linkAutoColorBy\", \"graphData\", \"linkColor\"])) {\n   \
   autoColorObjects(state.graphData.links, index3(state.linkAutoColorBy), \
state.linkColor);\n    }\n    if (state._flushObjects || \
hasAnyPropChanged([\"graphData\", \"nodeThreeObject\", \
\"nodeThreeObjectExtend\", \"nodeVal\", \"nodeColor\", \"nodeVisibility\", \
\"nodeRelSize\", \"nodeResolution\", \"nodeOpacity\"])) {\n      var \
customObjectAccessor = index3(state.nodeThreeObject);\n      var \
customObjectExtendAccessor = index3(state.nodeThreeObjectExtend);\n      var \
valAccessor = index3(state.nodeVal);\n      var colorAccessor = \
index3(state.nodeColor);\n      var visibilityAccessor = \
index3(state.nodeVisibility);\n      var sphereGeometries = {};\n      var \
sphereMaterials = {};\n      \
threeDigest(state.graphData.nodes.filter(visibilityAccessor), \
state.graphScene, {\n        purge: state._flushObjects || \
hasAnyPropChanged([\n          // recreate objects if any of these props have \
changed\n          \"nodeThreeObject\",\n          \
\"nodeThreeObjectExtend\"\n        ]),\n        objFilter: function \
objFilter(obj) {\n          return obj.__graphObjType === \"node\";\n        \
},\n        createObj: function createObj(node) {\n          var customObj = \
customObjectAccessor(node);\n          var extendObj = \
customObjectExtendAccessor(node);\n          if (customObj && \
state.nodeThreeObject === customObj) {\n            customObj = \
customObj.clone();\n          }\n          var obj;\n          if (customObj \
&& !extendObj) {\n            obj = customObj;\n          } else {\n          \
  obj = new three$1.Mesh();\n            obj.__graphDefaultObj = true;\n      \
      if (customObj && extendObj) {\n              obj.add(customObj);\n      \
      }\n          }\n          obj.__graphObjType = \"node\";\n          \
return obj;\n        },\n        updateObj: function updateObj(obj, node) {\n \
         if (obj.__graphDefaultObj) {\n            var val = \
valAccessor(node) || 1;\n            var radius = Math.cbrt(val) * \
state.nodeRelSize;\n            var numSegments = state.nodeResolution;\n     \
       if (!obj.geometry.type.match(/^Sphere(Buffer)?Geometry$/) || \
obj.geometry.parameters.radius !== radius || \
obj.geometry.parameters.widthSegments !== numSegments) {\n              if \
(!sphereGeometries.hasOwnProperty(val)) {\n                \
sphereGeometries[val] = new three$1.SphereGeometry(radius, numSegments, \
numSegments);\n              }\n              obj.geometry.dispose();\n       \
       obj.geometry = sphereGeometries[val];\n            }\n            var \
color2 = colorAccessor(node);\n            var materialColor2 = new \
three$1.Color(colorStr2Hex(color2 || \"#ffffaa\"));\n            var opacity \
= state.nodeOpacity * colorAlpha(color2);\n            if (obj.material.type \
!== \"MeshLambertMaterial\" || !obj.material.color.equals(materialColor2) || \
obj.material.opacity !== opacity) {\n              if \
(!sphereMaterials.hasOwnProperty(color2)) {\n                \
sphereMaterials[color2] = new three$1.MeshLambertMaterial({\n                 \
 color: materialColor2,\n                  transparent: true,\n               \
   opacity\n                });\n              }\n              \
obj.material.dispose();\n              obj.material = \
sphereMaterials[color2];\n            }\n          }\n        }\n      });\n  \
  }\n    if (state._flushObjects || hasAnyPropChanged([\"graphData\", \
\"linkThreeObject\", \"linkThreeObjectExtend\", \"linkMaterial\", \
\"linkColor\", \"linkWidth\", \"linkVisibility\", \"linkResolution\", \
\"linkOpacity\", \"linkDirectionalArrowLength\", \
\"linkDirectionalArrowColor\", \"linkDirectionalArrowResolution\", \
\"linkDirectionalParticles\", \"linkDirectionalParticleWidth\", \
\"linkDirectionalParticleColor\", \"linkDirectionalParticleResolution\"])) \
{\n      var _customObjectAccessor = index3(state.linkThreeObject);\n      \
var _customObjectExtendAccessor = index3(state.linkThreeObjectExtend);\n      \
var customMaterialAccessor = index3(state.linkMaterial);\n      var \
_visibilityAccessor = index3(state.linkVisibility);\n      var _colorAccessor \
= index3(state.linkColor);\n      var widthAccessor = \
index3(state.linkWidth);\n      var cylinderGeometries = {};\n      var \
lambertLineMaterials = {};\n      var basicLineMaterials = {};\n      var \
visibleLinks = state.graphData.links.filter(_visibilityAccessor);\n      \
threeDigest(visibleLinks, state.graphScene, {\n        objBindAttr: \
\"__lineObj\",\n        purge: state._flushObjects || hasAnyPropChanged([\n   \
       // recreate objects if any of these props have changed\n          \
\"linkThreeObject\",\n          \"linkThreeObjectExtend\",\n          \
\"linkWidth\"\n        ]),\n        objFilter: function objFilter(obj) {\n    \
      return obj.__graphObjType === \"link\";\n        },\n        exitObj: \
function exitObj(obj) {\n          var singlePhotonsObj = obj.__data && \
obj.__data.__singleHopPhotonsObj;\n          if (singlePhotonsObj) {\n        \
    singlePhotonsObj.parent.remove(singlePhotonsObj);\n            \
emptyObject(singlePhotonsObj);\n            delete \
obj.__data.__singleHopPhotonsObj;\n          }\n        },\n        \
createObj: function createObj(link) {\n          var customObj = \
_customObjectAccessor(link);\n          var extendObj = \
_customObjectExtendAccessor(link);\n          if (customObj && \
state.linkThreeObject === customObj) {\n            customObj = \
customObj.clone();\n          }\n          var defaultObj;\n          if \
(!customObj || extendObj) {\n            var useCylinder = \
!!widthAccessor(link);\n            if (useCylinder) {\n              \
defaultObj = new three$1.Mesh();\n            } else {\n              var \
lineGeometry = new three$1.BufferGeometry();\n              \
lineGeometry[setAttributeFn](\"position\", new three$1.BufferAttribute(new \
Float32Array(2 * 3), 3));\n              defaultObj = new \
three$1.Line(lineGeometry);\n            }\n          }\n          var obj;\n \
         if (!customObj) {\n            obj = defaultObj;\n            \
obj.__graphDefaultObj = true;\n          } else {\n            if \
(!extendObj) {\n              obj = customObj;\n            } else {\n        \
      obj = new three$1.Group();\n              obj.__graphDefaultObj = \
true;\n              obj.add(defaultObj);\n              \
obj.add(customObj);\n            }\n          }\n          obj.renderOrder = \
10;\n          obj.__graphObjType = \"link\";\n          return obj;\n        \
},\n        updateObj: function updateObj(updObj, link) {\n          if \
(updObj.__graphDefaultObj) {\n            var obj = updObj.children.length ? \
updObj.children[0] : updObj;\n            var linkWidth = \
Math.ceil(widthAccessor(link) * 10) / 10;\n            var useCylinder = \
!!linkWidth;\n            if (useCylinder) {\n              var r = linkWidth \
/ 2;\n              var numSegments = state.linkResolution;\n              if \
(!obj.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || \
obj.geometry.parameters.radiusTop !== r || \
obj.geometry.parameters.radialSegments !== numSegments) {\n                if \
(!cylinderGeometries.hasOwnProperty(linkWidth)) {\n                  var \
geometry = new three$1.CylinderGeometry(r, r, 1, numSegments, 1, false);\n    \
              geometry[applyMatrix4Fn](new \
three$1.Matrix4().makeTranslation(0, 1 / 2, 0));\n                  \
geometry[applyMatrix4Fn](new three$1.Matrix4().makeRotationX(Math.PI / 2));\n \
                 cylinderGeometries[linkWidth] = geometry;\n                \
}\n                obj.geometry.dispose();\n                obj.geometry = \
cylinderGeometries[linkWidth];\n              }\n            }\n            \
var customMaterial = customMaterialAccessor(link);\n            if \
(customMaterial) {\n              obj.material = customMaterial;\n            \
} else {\n              var color2 = _colorAccessor(link);\n              var \
materialColor2 = new three$1.Color(colorStr2Hex(color2 || \"#f0f0f0\"));\n    \
          var opacity = state.linkOpacity * colorAlpha(color2);\n             \
 var materialType = useCylinder ? \"MeshLambertMaterial\" : \
\"LineBasicMaterial\";\n              if (obj.material.type !== materialType \
|| !obj.material.color.equals(materialColor2) || obj.material.opacity !== \
opacity) {\n                var lineMaterials = useCylinder ? \
lambertLineMaterials : basicLineMaterials;\n                if \
(!lineMaterials.hasOwnProperty(color2)) {\n                  \
lineMaterials[color2] = new three$1[materialType]({\n                    \
color: materialColor2,\n                    transparent: opacity < 1,\n       \
             opacity,\n                    depthWrite: opacity >= 1\n         \
           // Prevent transparency issues\n                  });\n            \
    }\n                obj.material.dispose();\n                obj.material \
= lineMaterials[color2];\n              }\n            }\n          }\n       \
 }\n      });\n      if (state.linkDirectionalArrowLength || \
changedProps.hasOwnProperty(\"linkDirectionalArrowLength\")) {\n        var \
arrowLengthAccessor = index3(state.linkDirectionalArrowLength);\n        var \
arrowColorAccessor = index3(state.linkDirectionalArrowColor);\n        \
threeDigest(visibleLinks.filter(arrowLengthAccessor), state.graphScene, {\n   \
       objBindAttr: \"__arrowObj\",\n          objFilter: function \
objFilter(obj) {\n            return obj.__linkThreeObjType === \"arrow\";\n  \
        },\n          createObj: function createObj() {\n            var obj \
= new three$1.Mesh(void 0, new three$1.MeshLambertMaterial({\n              \
transparent: true\n            }));\n            obj.__linkThreeObjType = \
\"arrow\";\n            return obj;\n          },\n          updateObj: \
function updateObj(obj, link) {\n            var arrowLength = \
arrowLengthAccessor(link);\n            var numSegments = \
state.linkDirectionalArrowResolution;\n            if \
(!obj.geometry.type.match(/^Cone(Buffer)?Geometry$/) || \
obj.geometry.parameters.height !== arrowLength || \
obj.geometry.parameters.radialSegments !== numSegments) {\n              var \
coneGeometry = new three$1.ConeGeometry(arrowLength * 0.25, arrowLength, \
numSegments);\n              coneGeometry.translate(0, arrowLength / 2, 0);\n \
             coneGeometry.rotateX(Math.PI / 2);\n              \
obj.geometry.dispose();\n              obj.geometry = coneGeometry;\n         \
   }\n            var arrowColor = arrowColorAccessor(link) || \
_colorAccessor(link) || \"#f0f0f0\";\n            obj.material.color = new \
three$1.Color(colorStr2Hex(arrowColor));\n            obj.material.opacity = \
state.linkOpacity * 3 * colorAlpha(arrowColor);\n          }\n        });\n   \
   }\n      if (state.linkDirectionalParticles || \
changedProps.hasOwnProperty(\"linkDirectionalParticles\")) {\n        var \
particlesAccessor = index3(state.linkDirectionalParticles);\n        var \
particleWidthAccessor = index3(state.linkDirectionalParticleWidth);\n        \
var particleColorAccessor = index3(state.linkDirectionalParticleColor);\n     \
   var particleMaterials = {};\n        var particleGeometries = {};\n        \
threeDigest(visibleLinks.filter(particlesAccessor), state.graphScene, {\n     \
     objBindAttr: \"__photonsObj\",\n          objFilter: function \
objFilter(obj) {\n            return obj.__linkThreeObjType === \
\"photons\";\n          },\n          createObj: function createObj() {\n     \
       var obj = new three$1.Group();\n            obj.__linkThreeObjType = \
\"photons\";\n            return obj;\n          },\n          updateObj: \
function updateObj(obj, link) {\n            var numPhotons = \
Math.round(Math.abs(particlesAccessor(link)));\n            var curPhoton = \
!!obj.children.length && obj.children[0];\n            var photonR = \
Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;\n            var \
numSegments = state.linkDirectionalParticleResolution;\n            var \
particleGeometry;\n            if (curPhoton && \
curPhoton.geometry.parameters.radius === photonR && \
curPhoton.geometry.parameters.widthSegments === numSegments) {\n              \
particleGeometry = curPhoton.geometry;\n            } else {\n              \
if (!particleGeometries.hasOwnProperty(photonR)) {\n                \
particleGeometries[photonR] = new three$1.SphereGeometry(photonR, \
numSegments, numSegments);\n              }\n              particleGeometry = \
particleGeometries[photonR];\n              curPhoton && \
curPhoton.geometry.dispose();\n            }\n            var photonColor = \
particleColorAccessor(link) || _colorAccessor(link) || \"#f0f0f0\";\n         \
   var materialColor2 = new three$1.Color(colorStr2Hex(photonColor));\n       \
     var opacity = state.linkOpacity * 3;\n            var \
particleMaterial;\n            if (curPhoton && \
curPhoton.material.color.equals(materialColor2) && curPhoton.material.opacity \
=== opacity) {\n              particleMaterial = curPhoton.material;\n        \
    } else {\n              if \
(!particleMaterials.hasOwnProperty(photonColor)) {\n                \
particleMaterials[photonColor] = new three$1.MeshLambertMaterial({\n          \
        color: materialColor2,\n                  transparent: true,\n        \
          opacity\n                });\n              }\n              \
particleMaterial = particleMaterials[photonColor];\n              curPhoton \
&& curPhoton.material.dispose();\n            }\n            \
threeDigest(_toConsumableArray3(new Array(numPhotons)).map(function(_, idx) \
{\n              return {\n                idx\n              };\n            \
}), obj, {\n              idAccessor: function idAccessor(d) {\n              \
  return d.idx;\n              },\n              createObj: function \
createObj() {\n                return new three$1.Mesh(particleGeometry, \
particleMaterial);\n              },\n              updateObj: function \
updateObj2(obj2) {\n                obj2.geometry = particleGeometry;\n       \
         obj2.material = particleMaterial;\n              }\n            \
});\n          }\n        });\n      }\n    }\n    state._flushObjects = \
false;\n    if (hasAnyPropChanged([\"graphData\", \"nodeId\", \"linkSource\", \
\"linkTarget\", \"numDimensions\", \"forceEngine\", \"dagMode\", \
\"dagNodeFilter\", \"dagLevelDistance\"])) {\n      state.engineRunning = \
false;\n      state.graphData.links.forEach(function(link) {\n        \
link.source = link[state.linkSource];\n        link.target = \
link[state.linkTarget];\n      });\n      var isD3Sim = state.forceEngine !== \
\"ngraph\";\n      var layout;\n      if (isD3Sim) {\n        (layout = \
state.d3ForceLayout).stop().alpha(1).numDimensions(state.numDimensions).nodes\
(state.graphData.nodes);\n        var linkForce = \
state.d3ForceLayout.force(\"link\");\n        if (linkForce) {\n          \
linkForce.id(function(d) {\n            return d[state.nodeId];\n          \
}).links(state.graphData.links);\n        }\n        var nodeDepths = \
state.dagMode && getDagDepths(state.graphData, function(node) {\n          \
return node[state.nodeId];\n        }, {\n          nodeFilter: \
state.dagNodeFilter,\n          onLoopError: state.onDagError || void 0\n     \
   });\n        var maxDepth = Math.max.apply(Math, \
_toConsumableArray3(Object.values(nodeDepths || [])));\n        var \
dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / \
(maxDepth || 1) * DAG_LEVEL_NODE_RATIO * ([\"radialin\", \
\"radialout\"].indexOf(state.dagMode) !== -1 ? 0.7 : 1);\n        if \
([\"lr\", \"rl\", \"td\", \"bu\", \"zin\", \
\"zout\"].includes(changedProps.dagMode)) {\n          var resetProp = \
[\"lr\", \"rl\"].includes(changedProps.dagMode) ? \"fx\" : [\"td\", \
\"bu\"].includes(changedProps.dagMode) ? \"fy\" : \"fz\";\n          \
state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {\n  \
          return delete node[resetProp];\n          });\n        }\n        \
if ([\"lr\", \"rl\", \"td\", \"bu\", \"zin\", \
\"zout\"].includes(state.dagMode)) {\n          var invert = [\"rl\", \"td\", \
\"zout\"].includes(state.dagMode);\n          var fixFn = function \
fixFn2(node) {\n            return (nodeDepths[node[state.nodeId]] - maxDepth \
/ 2) * dagLevelDistance * (invert ? -1 : 1);\n          };\n          var \
_resetProp = [\"lr\", \"rl\"].includes(state.dagMode) ? \"fx\" : [\"td\", \
\"bu\"].includes(state.dagMode) ? \"fy\" : \"fz\";\n          \
state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {\n  \
          return node[_resetProp] = fixFn(node);\n          });\n        }\n  \
      state.d3ForceLayout.force(\"dagRadial\", [\"radialin\", \
\"radialout\"].indexOf(state.dagMode) !== -1 ? radial_default(function(node) \
{\n          var nodeDepth = nodeDepths[node[state.nodeId]] || -1;\n          \
return (state.dagMode === \"radialin\" ? maxDepth - nodeDepth : nodeDepth) * \
dagLevelDistance;\n        }).strength(function(node) {\n          return \
state.dagNodeFilter(node) ? 1 : 0;\n        }) : null);\n      } else {\n     \
   var _graph = ngraph.graph();\n        \
state.graphData.nodes.forEach(function(node) {\n          \
_graph.addNode(node[state.nodeId]);\n        });\n        \
state.graphData.links.forEach(function(link) {\n          \
_graph.addLink(link.source, link.target);\n        });\n        layout = \
ngraph.forcelayout(_graph, _objectSpread22({\n          dimensions: \
state.numDimensions\n        }, state.ngraphPhysics));\n        layout.graph \
= _graph;\n      }\n      for (var i = 0; i < state.warmupTicks && !(isD3Sim \
&& state.d3AlphaMin > 0 && state.d3ForceLayout.alpha() < state.d3AlphaMin); \
i++) {\n        layout[isD3Sim ? \"tick\" : \"step\"]();\n      }\n      \
state.layout = layout;\n      this.resetCountdown();\n    }\n    \
state.engineRunning = true;\n    state.onFinishUpdate();\n  }\n});\nfunction \
fromKapsule(kapsule) {\n  var baseClass = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : Object;\n  var initKapsuleWithSelf = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n  \
var FromKapsule = /* @__PURE__ */ function(_baseClass) {\n    function \
FromKapsule2() {\n      var _this;\n      _classCallCheck2(this, \
FromKapsule2);\n      for (var _len = arguments.length, args = new \
Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = \
arguments[_key];\n      }\n      _this = _callSuper(this, FromKapsule2, \
[].concat(args));\n      _this.__kapsuleInstance = kapsule().apply(void 0, \
[].concat(_toConsumableArray3(initKapsuleWithSelf ? [_this] : []), args));\n  \
    return _this;\n    }\n    _inherits(FromKapsule2, _baseClass);\n    \
return _createClass2(FromKapsule2);\n  }(baseClass);\n  \
Object.keys(kapsule()).forEach(function(m2) {\n    return \
FromKapsule.prototype[m2] = function() {\n      var _this$__kapsuleInstan;\n  \
    var returnVal = (_this$__kapsuleInstan = \
this.__kapsuleInstance)[m2].apply(_this$__kapsuleInstan, arguments);\n      \
return returnVal === this.__kapsuleInstance ? this : returnVal;\n    };\n  \
});\n  return FromKapsule;\n}\nvar three = window.THREE ? window.THREE : {\n  \
Group\n};\nvar threeForcegraph = fromKapsule(ForceGraph, three.Group, \
true);\n\n// ../../node_modules/three/build/three.webgpu.js\nvar REVISION2 = \
\"170\";\nvar CullFaceNone2 = 0;\nvar CullFaceBack2 = 1;\nvar CullFaceFront2 \
= 2;\nvar PCFShadowMap$1 = 1;\nvar VSMShadowMap2 = 3;\nvar FrontSide2 = \
0;\nvar BackSide2 = 1;\nvar DoubleSide2 = 2;\nvar NoBlending2 = 0;\nvar \
NormalBlending2 = 1;\nvar AdditiveBlending2 = 2;\nvar SubtractiveBlending2 = \
3;\nvar MultiplyBlending2 = 4;\nvar CustomBlending2 = 5;\nvar AddEquation2 = \
100;\nvar SubtractEquation2 = 101;\nvar ReverseSubtractEquation2 = 102;\nvar \
MinEquation2 = 103;\nvar MaxEquation2 = 104;\nvar ZeroFactor2 = 200;\nvar \
OneFactor2 = 201;\nvar SrcColorFactor2 = 202;\nvar OneMinusSrcColorFactor2 = \
203;\nvar SrcAlphaFactor2 = 204;\nvar OneMinusSrcAlphaFactor2 = 205;\nvar \
DstAlphaFactor2 = 206;\nvar OneMinusDstAlphaFactor2 = 207;\nvar \
DstColorFactor2 = 208;\nvar OneMinusDstColorFactor2 = 209;\nvar \
SrcAlphaSaturateFactor2 = 210;\nvar NeverDepth2 = 0;\nvar AlwaysDepth2 = \
1;\nvar LessDepth2 = 2;\nvar LessEqualDepth2 = 3;\nvar EqualDepth2 = 4;\nvar \
GreaterEqualDepth2 = 5;\nvar GreaterDepth2 = 6;\nvar NotEqualDepth2 = 7;\nvar \
MultiplyOperation2 = 0;\nvar MixOperation2 = 1;\nvar AddOperation2 = 2;\nvar \
NoToneMapping2 = 0;\nvar LinearToneMapping2 = 1;\nvar ReinhardToneMapping2 = \
2;\nvar CineonToneMapping2 = 3;\nvar ACESFilmicToneMapping2 = 4;\nvar \
AgXToneMapping2 = 6;\nvar NeutralToneMapping2 = 7;\nvar UVMapping2 = \
300;\nvar CubeReflectionMapping2 = 301;\nvar CubeRefractionMapping2 = \
302;\nvar EquirectangularReflectionMapping2 = 303;\nvar \
EquirectangularRefractionMapping2 = 304;\nvar CubeUVReflectionMapping2 = \
306;\nvar RepeatWrapping2 = 1e3;\nvar ClampToEdgeWrapping2 = 1001;\nvar \
MirroredRepeatWrapping2 = 1002;\nvar NearestFilter2 = 1003;\nvar \
NearestMipmapNearestFilter2 = 1004;\nvar NearestMipmapLinearFilter2 = \
1005;\nvar LinearFilter2 = 1006;\nvar LinearMipmapNearestFilter2 = 1007;\nvar \
LinearMipmapLinearFilter2 = 1008;\nvar UnsignedByteType2 = 1009;\nvar \
ByteType2 = 1010;\nvar ShortType2 = 1011;\nvar UnsignedShortType2 = \
1012;\nvar IntType2 = 1013;\nvar UnsignedIntType2 = 1014;\nvar FloatType2 = \
1015;\nvar HalfFloatType2 = 1016;\nvar UnsignedShort4444Type2 = 1017;\nvar \
UnsignedShort5551Type2 = 1018;\nvar UnsignedInt248Type2 = 1020;\nvar \
UnsignedInt5999Type2 = 35902;\nvar AlphaFormat2 = 1021;\nvar RGBFormat2 = \
1022;\nvar RGBAFormat2 = 1023;\nvar LuminanceFormat2 = 1024;\nvar \
LuminanceAlphaFormat2 = 1025;\nvar DepthFormat2 = 1026;\nvar \
DepthStencilFormat2 = 1027;\nvar RedFormat2 = 1028;\nvar RedIntegerFormat2 = \
1029;\nvar RGFormat2 = 1030;\nvar RGIntegerFormat2 = 1031;\nvar \
RGBIntegerFormat = 1032;\nvar RGBAIntegerFormat2 = 1033;\nvar \
RGB_S3TC_DXT1_Format2 = 33776;\nvar RGBA_S3TC_DXT1_Format2 = 33777;\nvar \
RGBA_S3TC_DXT3_Format2 = 33778;\nvar RGBA_S3TC_DXT5_Format2 = 33779;\nvar \
RGB_PVRTC_4BPPV1_Format2 = 35840;\nvar RGB_PVRTC_2BPPV1_Format2 = 35841;\nvar \
RGBA_PVRTC_4BPPV1_Format2 = 35842;\nvar RGBA_PVRTC_2BPPV1_Format2 = \
35843;\nvar RGB_ETC1_Format2 = 36196;\nvar RGB_ETC2_Format2 = 37492;\nvar \
RGBA_ETC2_EAC_Format2 = 37496;\nvar RGBA_ASTC_4x4_Format2 = 37808;\nvar \
RGBA_ASTC_5x4_Format2 = 37809;\nvar RGBA_ASTC_5x5_Format2 = 37810;\nvar \
RGBA_ASTC_6x5_Format2 = 37811;\nvar RGBA_ASTC_6x6_Format2 = 37812;\nvar \
RGBA_ASTC_8x5_Format2 = 37813;\nvar RGBA_ASTC_8x6_Format2 = 37814;\nvar \
RGBA_ASTC_8x8_Format2 = 37815;\nvar RGBA_ASTC_10x5_Format2 = 37816;\nvar \
RGBA_ASTC_10x6_Format2 = 37817;\nvar RGBA_ASTC_10x8_Format2 = 37818;\nvar \
RGBA_ASTC_10x10_Format2 = 37819;\nvar RGBA_ASTC_12x10_Format2 = 37820;\nvar \
RGBA_ASTC_12x12_Format2 = 37821;\nvar RGBA_BPTC_Format2 = 36492;\nvar \
RED_RGTC1_Format2 = 36283;\nvar SIGNED_RED_RGTC1_Format2 = 36284;\nvar \
RED_GREEN_RGTC2_Format2 = 36285;\nvar SIGNED_RED_GREEN_RGTC2_Format2 = \
36286;\nvar InterpolateDiscrete2 = 2300;\nvar InterpolateLinear2 = 2301;\nvar \
InterpolateSmooth2 = 2302;\nvar ZeroCurvatureEnding2 = 2400;\nvar \
ZeroSlopeEnding2 = 2401;\nvar WrapAroundEnding2 = 2402;\nvar \
TangentSpaceNormalMap2 = 0;\nvar ObjectSpaceNormalMap2 = 1;\nvar \
NoColorSpace2 = \"\";\nvar SRGBColorSpace2 = \"srgb\";\nvar \
LinearSRGBColorSpace2 = \"srgb-linear\";\nvar LinearTransfer2 = \
\"linear\";\nvar SRGBTransfer2 = \"srgb\";\nvar ZeroStencilOp = 0;\nvar \
KeepStencilOp2 = 7680;\nvar ReplaceStencilOp = 7681;\nvar IncrementStencilOp \
= 7682;\nvar DecrementStencilOp = 7683;\nvar IncrementWrapStencilOp = \
34055;\nvar DecrementWrapStencilOp = 34056;\nvar InvertStencilOp = 5386;\nvar \
NeverStencilFunc = 512;\nvar LessStencilFunc = 513;\nvar EqualStencilFunc = \
514;\nvar LessEqualStencilFunc = 515;\nvar GreaterStencilFunc = 516;\nvar \
NotEqualStencilFunc = 517;\nvar GreaterEqualStencilFunc = 518;\nvar \
AlwaysStencilFunc2 = 519;\nvar NeverCompare2 = 512;\nvar LessCompare2 = \
513;\nvar EqualCompare2 = 514;\nvar LessEqualCompare2 = 515;\nvar \
GreaterCompare2 = 516;\nvar NotEqualCompare2 = 517;\nvar GreaterEqualCompare2 \
= 518;\nvar AlwaysCompare2 = 519;\nvar StaticDrawUsage2 = 35044;\nvar \
DynamicDrawUsage = 35048;\nvar WebGLCoordinateSystem2 = 2e3;\nvar \
WebGPUCoordinateSystem2 = 2001;\nvar EventDispatcher2 = class {\n  \
addEventListener(type, listener) {\n    if (this._listeners === void 0) \
this._listeners = {};\n    const listeners = this._listeners;\n    if \
(listeners[type] === void 0) {\n      listeners[type] = [];\n    }\n    if \
(listeners[type].indexOf(listener) === -1) {\n      \
listeners[type].push(listener);\n    }\n  }\n  hasEventListener(type, \
listener) {\n    if (this._listeners === void 0) return false;\n    const \
listeners = this._listeners;\n    return listeners[type] !== void 0 && \
listeners[type].indexOf(listener) !== -1;\n  }\n  removeEventListener(type, \
listener) {\n    if (this._listeners === void 0) return;\n    const listeners \
= this._listeners;\n    const listenerArray = listeners[type];\n    if \
(listenerArray !== void 0) {\n      const index5 = \
listenerArray.indexOf(listener);\n      if (index5 !== -1) {\n        \
listenerArray.splice(index5, 1);\n      }\n    }\n  }\n  dispatchEvent(event) \
{\n    if (this._listeners === void 0) return;\n    const listeners = \
this._listeners;\n    const listenerArray = listeners[event.type];\n    if \
(listenerArray !== void 0) {\n      event.target = this;\n      const array = \
listenerArray.slice(0);\n      for (let i = 0, l = array.length; i < l; i++) \
{\n        array[i].call(this, event);\n      }\n      event.target = null;\n \
   }\n  }\n};\nvar _lut2 = [\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \
\"06\", \"07\", \"08\", \"09\", \"0a\", \"0b\", \"0c\", \"0d\", \"0e\", \
\"0f\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \
\"18\", \"19\", \"1a\", \"1b\", \"1c\", \"1d\", \"1e\", \"1f\", \"20\", \
\"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \
\"2a\", \"2b\", \"2c\", \"2d\", \"2e\", \"2f\", \"30\", \"31\", \"32\", \
\"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3a\", \"3b\", \
\"3c\", \"3d\", \"3e\", \"3f\", \"40\", \"41\", \"42\", \"43\", \"44\", \
\"45\", \"46\", \"47\", \"48\", \"49\", \"4a\", \"4b\", \"4c\", \"4d\", \
\"4e\", \"4f\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \
\"57\", \"58\", \"59\", \"5a\", \"5b\", \"5c\", \"5d\", \"5e\", \"5f\", \
\"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \
\"69\", \"6a\", \"6b\", \"6c\", \"6d\", \"6e\", \"6f\", \"70\", \"71\", \
\"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7a\", \
\"7b\", \"7c\", \"7d\", \"7e\", \"7f\", \"80\", \"81\", \"82\", \"83\", \
\"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8a\", \"8b\", \"8c\", \
\"8d\", \"8e\", \"8f\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \
\"96\", \"97\", \"98\", \"99\", \"9a\", \"9b\", \"9c\", \"9d\", \"9e\", \
\"9f\", \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"a7\", \
\"a8\", \"a9\", \"aa\", \"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"b0\", \
\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\", \"b9\", \
\"ba\", \"bb\", \"bc\", \"bd\", \"be\", \"bf\", \"c0\", \"c1\", \"c2\", \
\"c3\", \"c4\", \"c5\", \"c6\", \"c7\", \"c8\", \"c9\", \"ca\", \"cb\", \
\"cc\", \"cd\", \"ce\", \"cf\", \"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \
\"d5\", \"d6\", \"d7\", \"d8\", \"d9\", \"da\", \"db\", \"dc\", \"dd\", \
\"de\", \"df\", \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \
\"e7\", \"e8\", \"e9\", \"ea\", \"eb\", \"ec\", \"ed\", \"ee\", \"ef\", \
\"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \
\"f9\", \"fa\", \"fb\", \"fc\", \"fd\", \"fe\", \"ff\"];\nvar _seed2 = \
1234567;\nvar DEG2RAD2 = Math.PI / 180;\nvar RAD2DEG2 = 180 / \
Math.PI;\nfunction generateUUID2() {\n  const d0 = Math.random() * 4294967295 \
| 0;\n  const d1 = Math.random() * 4294967295 | 0;\n  const d2 = \
Math.random() * 4294967295 | 0;\n  const d3 = Math.random() * 4294967295 | \
0;\n  const uuid = _lut2[d0 & 255] + _lut2[d0 >> 8 & 255] + _lut2[d0 >> 16 & \
255] + _lut2[d0 >> 24 & 255] + \"-\" + _lut2[d1 & 255] + _lut2[d1 >> 8 & 255] \
+ \"-\" + _lut2[d1 >> 16 & 15 | 64] + _lut2[d1 >> 24 & 255] + \"-\" + \
_lut2[d2 & 63 | 128] + _lut2[d2 >> 8 & 255] + \"-\" + _lut2[d2 >> 16 & 255] + \
_lut2[d2 >> 24 & 255] + _lut2[d3 & 255] + _lut2[d3 >> 8 & 255] + _lut2[d3 >> \
16 & 255] + _lut2[d3 >> 24 & 255];\n  return uuid.toLowerCase();\n}\nfunction \
clamp$1(value, min2, max2) {\n  return Math.max(min2, Math.min(max2, \
value));\n}\nfunction euclideanModulo2(n, m2) {\n  return (n % m2 + m2) % \
m2;\n}\nfunction mapLinear2(x2, a1, a2, b1, b2) {\n  return b1 + (x2 - a1) * \
(b2 - b1) / (a2 - a1);\n}\nfunction inverseLerp2(x2, y2, value) {\n  if (x2 \
!== y2) {\n    return (value - x2) / (y2 - x2);\n  } else {\n    return 0;\n  \
}\n}\nfunction lerp2(x2, y2, t) {\n  return (1 - t) * x2 + t * \
y2;\n}\nfunction damp2(x2, y2, lambda, dt) {\n  return lerp2(x2, y2, 1 - \
Math.exp(-lambda * dt));\n}\nfunction pingpong2(x2, length2 = 1) {\n  return \
length2 - Math.abs(euclideanModulo2(x2, length2 * 2) - length2);\n}\nfunction \
smoothstep$1(x2, min2, max2) {\n  if (x2 <= min2) return 0;\n  if (x2 >= \
max2) return 1;\n  x2 = (x2 - min2) / (max2 - min2);\n  return x2 * x2 * (3 - \
2 * x2);\n}\nfunction smootherstep2(x2, min2, max2) {\n  if (x2 <= min2) \
return 0;\n  if (x2 >= max2) return 1;\n  x2 = (x2 - min2) / (max2 - min2);\n \
 return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);\n}\nfunction randInt2(low, \
high) {\n  return low + Math.floor(Math.random() * (high - low + \
1));\n}\nfunction randFloat2(low, high) {\n  return low + Math.random() * \
(high - low);\n}\nfunction randFloatSpread2(range) {\n  return range * (0.5 - \
Math.random());\n}\nfunction seededRandom2(s) {\n  if (s !== void 0) _seed2 = \
s;\n  let t = _seed2 += 1831565813;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  \
t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / \
4294967296;\n}\nfunction degToRad2(degrees2) {\n  return degrees2 * \
DEG2RAD2;\n}\nfunction radToDeg2(radians2) {\n  return radians2 * \
RAD2DEG2;\n}\nfunction isPowerOfTwo2(value) {\n  return (value & value - 1) \
=== 0 && value !== 0;\n}\nfunction ceilPowerOfTwo2(value) {\n  return \
Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\nfunction \
floorPowerOfTwo2(value) {\n  return Math.pow(2, Math.floor(Math.log(value) / \
Math.LN2));\n}\nfunction setQuaternionFromProperEuler2(q, a2, b, c2, order) \
{\n  const cos2 = Math.cos;\n  const sin2 = Math.sin;\n  const c22 = cos2(b / \
2);\n  const s2 = sin2(b / 2);\n  const c13 = cos2((a2 + c2) / 2);\n  const \
s13 = sin2((a2 + c2) / 2);\n  const c1_3 = cos2((a2 - c2) / 2);\n  const s1_3 \
= sin2((a2 - c2) / 2);\n  const c3_1 = cos2((c2 - a2) / 2);\n  const s3_1 = \
sin2((c2 - a2) / 2);\n  switch (order) {\n    case \"XYX\":\n      q.set(c22 \
* s13, s2 * c1_3, s2 * s1_3, c22 * c13);\n      break;\n    case \"YZY\":\n   \
   q.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);\n      break;\n    case \
\"ZXZ\":\n      q.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);\n      \
break;\n    case \"XZX\":\n      q.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * \
c13);\n      break;\n    case \"YXY\":\n      q.set(s2 * c3_1, c22 * s13, s2 \
* s3_1, c22 * c13);\n      break;\n    case \"ZYZ\":\n      q.set(s2 * s3_1, \
s2 * c3_1, c22 * s13, c22 * c13);\n      break;\n    default:\n      \
console.warn(\"THREE.MathUtils: .setQuaternionFromProperEuler() encountered \
an unknown order: \" + order);\n  }\n}\nfunction denormalize2(value, array) \
{\n  switch (array.constructor) {\n    case Float32Array:\n      return \
value;\n    case Uint32Array:\n      return value / 4294967295;\n    case \
Uint16Array:\n      return value / 65535;\n    case Uint8Array:\n      return \
value / 255;\n    case Int32Array:\n      return Math.max(value / 2147483647, \
-1);\n    case Int16Array:\n      return Math.max(value / 32767, -1);\n    \
case Int8Array:\n      return Math.max(value / 127, -1);\n    default:\n      \
throw new Error(\"Invalid component type.\");\n  }\n}\nfunction \
normalize$1(value, array) {\n  switch (array.constructor) {\n    case \
Float32Array:\n      return value;\n    case Uint32Array:\n      return \
Math.round(value * 4294967295);\n    case Uint16Array:\n      return \
Math.round(value * 65535);\n    case Uint8Array:\n      return \
Math.round(value * 255);\n    case Int32Array:\n      return Math.round(value \
* 2147483647);\n    case Int16Array:\n      return Math.round(value * \
32767);\n    case Int8Array:\n      return Math.round(value * 127);\n    \
default:\n      throw new Error(\"Invalid component type.\");\n  }\n}\nvar \
MathUtils2 = {\n  DEG2RAD: DEG2RAD2,\n  RAD2DEG: RAD2DEG2,\n  generateUUID: \
generateUUID2,\n  clamp: clamp$1,\n  euclideanModulo: euclideanModulo2,\n  \
mapLinear: mapLinear2,\n  inverseLerp: inverseLerp2,\n  lerp: lerp2,\n  damp: \
damp2,\n  pingpong: pingpong2,\n  smoothstep: smoothstep$1,\n  smootherstep: \
smootherstep2,\n  randInt: randInt2,\n  randFloat: randFloat2,\n  \
randFloatSpread: randFloatSpread2,\n  seededRandom: seededRandom2,\n  \
degToRad: degToRad2,\n  radToDeg: radToDeg2,\n  isPowerOfTwo: \
isPowerOfTwo2,\n  ceilPowerOfTwo: ceilPowerOfTwo2,\n  floorPowerOfTwo: \
floorPowerOfTwo2,\n  setQuaternionFromProperEuler: \
setQuaternionFromProperEuler2,\n  normalize: normalize$1,\n  denormalize: \
denormalize2\n};\nvar Vector22 = class _Vector2 {\n  constructor(x2 = 0, y2 = \
0) {\n    _Vector2.prototype.isVector2 = true;\n    this.x = x2;\n    this.y \
= y2;\n  }\n  get width() {\n    return this.x;\n  }\n  set width(value) {\n  \
  this.x = value;\n  }\n  get height() {\n    return this.y;\n  }\n  set \
height(value) {\n    this.y = value;\n  }\n  set(x2, y2) {\n    this.x = \
x2;\n    this.y = y2;\n    return this;\n  }\n  setScalar(scalar) {\n    \
this.x = scalar;\n    this.y = scalar;\n    return this;\n  }\n  setX(x2) {\n \
   this.x = x2;\n    return this;\n  }\n  setY(y2) {\n    this.y = y2;\n    \
return this;\n  }\n  setComponent(index5, value) {\n    switch (index5) {\n   \
   case 0:\n        this.x = value;\n        break;\n      case 1:\n        \
this.y = value;\n        break;\n      default:\n        throw new \
Error(\"index is out of range: \" + index5);\n    }\n    return this;\n  }\n  \
getComponent(index5) {\n    switch (index5) {\n      case 0:\n        return \
this.x;\n      case 1:\n        return this.y;\n      default:\n        throw \
new Error(\"index is out of range: \" + index5);\n    }\n  }\n  clone() {\n   \
 return new this.constructor(this.x, this.y);\n  }\n  copy(v) {\n    this.x = \
v.x;\n    this.y = v.y;\n    return this;\n  }\n  add(v) {\n    this.x += \
v.x;\n    this.y += v.y;\n    return this;\n  }\n  addScalar(s) {\n    this.x \
+= s;\n    this.y += s;\n    return this;\n  }\n  addVectors(a2, b) {\n    \
this.x = a2.x + b.x;\n    this.y = a2.y + b.y;\n    return this;\n  }\n  \
addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    \
return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    \
return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    \
return this;\n  }\n  subVectors(a2, b) {\n    this.x = a2.x - b.x;\n    \
this.y = a2.y - b.y;\n    return this;\n  }\n  multiply(v) {\n    this.x *= \
v.x;\n    this.y *= v.y;\n    return this;\n  }\n  multiplyScalar(scalar) {\n \
   this.x *= scalar;\n    this.y *= scalar;\n    return this;\n  }\n  \
divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    return this;\n  }\n  \
divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  \
applyMatrix3(m2) {\n    const x2 = this.x, y2 = this.y;\n    const e = \
m2.elements;\n    this.x = e[0] * x2 + e[3] * y2 + e[6];\n    this.y = e[1] * \
x2 + e[4] * y2 + e[7];\n    return this;\n  }\n  min(v) {\n    this.x = \
Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    return \
this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = \
Math.max(this.y, v.y);\n    return this;\n  }\n  clamp(min2, max2) {\n    \
this.x = Math.max(min2.x, Math.min(max2.x, this.x));\n    this.y = \
Math.max(min2.y, Math.min(max2.y, this.y));\n    return this;\n  }\n  \
clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, \
this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    \
return this;\n  }\n  clampLength(min2, max2) {\n    const length2 = \
this.length();\n    return this.divideScalar(length2 || \
1).multiplyScalar(Math.max(min2, Math.min(max2, length2)));\n  }\n  floor() \
{\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    \
return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = \
Math.ceil(this.y);\n    return this;\n  }\n  round() {\n    this.x = \
Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  \
}\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = \
Math.trunc(this.y);\n    return this;\n  }\n  negate() {\n    this.x = \
-this.x;\n    this.y = -this.y;\n    return this;\n  }\n  dot(v) {\n    \
return this.x * v.x + this.y * v.y;\n  }\n  cross(v) {\n    return this.x * \
v.y - this.y * v.x;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y \
* this.y;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * \
this.y);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + \
Math.abs(this.y);\n  }\n  normalize() {\n    return \
this.divideScalar(this.length() || 1);\n  }\n  angle() {\n    const angle = \
Math.atan2(-this.y, -this.x) + Math.PI;\n    return angle;\n  }\n  angleTo(v) \
{\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if \
(denominator === 0) return Math.PI / 2;\n    const theta = this.dot(v) / \
denominator;\n    return Math.acos(clamp$1(theta, -1, 1));\n  }\n  \
distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  \
distanceToSquared(v) {\n    const dx = this.x - v.x, dy = this.y - v.y;\n    \
return dx * dx + dy * dy;\n  }\n  manhattanDistanceTo(v) {\n    return \
Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n  }\n  setLength(length2) \
{\n    return this.normalize().multiplyScalar(length2);\n  }\n  lerp(v, \
alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) \
* alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = \
v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n   \
 return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === \
this.y;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n \
   this.y = array[offset + 1];\n    return this;\n  }\n  toArray(array = [], \
offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n \
   return array;\n  }\n  fromBufferAttribute(attribute2, index5) {\n    \
this.x = attribute2.getX(index5);\n    this.y = attribute2.getY(index5);\n    \
return this;\n  }\n  rotateAround(center, angle) {\n    const c2 = \
Math.cos(angle), s = Math.sin(angle);\n    const x2 = this.x - center.x;\n    \
const y2 = this.y - center.y;\n    this.x = x2 * c2 - y2 * s + center.x;\n    \
this.y = x2 * s + y2 * c2 + center.y;\n    return this;\n  }\n  random() {\n  \
  this.x = Math.random();\n    this.y = Math.random();\n    return this;\n  \
}\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n  \
}\n};\nvar Matrix32 = class _Matrix3 {\n  constructor(n11, n12, n13, n21, \
n22, n23, n31, n32, n33) {\n    _Matrix3.prototype.isMatrix3 = true;\n    \
this.elements = [\n      1,\n      0,\n      0,\n      0,\n      1,\n      \
0,\n      0,\n      0,\n      1\n    ];\n    if (n11 !== void 0) {\n      \
this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n    }\n  }\n  \
set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    const te = \
this.elements;\n    te[0] = n11;\n    te[1] = n21;\n    te[2] = n31;\n    \
te[3] = n12;\n    te[4] = n22;\n    te[5] = n32;\n    te[6] = n13;\n    te[7] \
= n23;\n    te[8] = n33;\n    return this;\n  }\n  identity() {\n    \
this.set(\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      \
0,\n      0,\n      1\n    );\n    return this;\n  }\n  copy(m2) {\n    const \
te = this.elements;\n    const me = m2.elements;\n    te[0] = me[0];\n    \
te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n  \
  te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = \
me[8];\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    \
xAxis.setFromMatrix3Column(this, 0);\n    yAxis.setFromMatrix3Column(this, \
1);\n    zAxis.setFromMatrix3Column(this, 2);\n    return this;\n  }\n  \
setFromMatrix4(m2) {\n    const me = m2.elements;\n    this.set(\n      \
me[0],\n      me[4],\n      me[8],\n      me[1],\n      me[5],\n      \
me[9],\n      me[2],\n      me[6],\n      me[10]\n    );\n    return this;\n  \
}\n  multiply(m2) {\n    return this.multiplyMatrices(this, m2);\n  }\n  \
premultiply(m2) {\n    return this.multiplyMatrices(m2, this);\n  }\n  \
multiplyMatrices(a2, b) {\n    const ae = a2.elements;\n    const be = \
b.elements;\n    const te = this.elements;\n    const a11 = ae[0], a12 = \
ae[3], a13 = ae[6];\n    const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n    \
const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n    const b11 = be[0], b12 = \
be[3], b13 = be[6];\n    const b21 = be[1], b22 = be[4], b23 = be[7];\n    \
const b31 = be[2], b32 = be[5], b33 = be[8];\n    te[0] = a11 * b11 + a12 * \
b21 + a13 * b31;\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n    te[6] = \
a11 * b13 + a12 * b23 + a13 * b33;\n    te[1] = a21 * b11 + a22 * b21 + a23 * \
b31;\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n    te[7] = a21 * b13 + \
a22 * b23 + a23 * b33;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n    \
te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n    te[8] = a31 * b13 + a32 * b23 \
+ a33 * b33;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = \
this.elements;\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] \
*= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n   \
 te[8] *= s;\n    return this;\n  }\n  determinant() {\n    const te = \
this.elements;\n    const a2 = te[0], b = te[1], c2 = te[2], d = te[3], e = \
te[4], f = te[5], g = te[6], h = te[7], i = te[8];\n    return a2 * e * i - \
a2 * f * h - b * d * i + b * f * g + c2 * d * h - c2 * e * g;\n  }\n  \
invert() {\n    const te = this.elements, n11 = te[0], n21 = te[1], n31 = \
te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = \
te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * \
n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n    if (det === 0) \
return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    \
te[0] = t11 * detInv;\n    te[1] = (n31 * n23 - n33 * n21) * detInv;\n    \
te[2] = (n32 * n21 - n31 * n22) * detInv;\n    te[3] = t12 * detInv;\n    \
te[4] = (n33 * n11 - n31 * n13) * detInv;\n    te[5] = (n31 * n12 - n32 * \
n11) * detInv;\n    te[6] = t13 * detInv;\n    te[7] = (n21 * n13 - n23 * \
n11) * detInv;\n    te[8] = (n22 * n11 - n21 * n12) * detInv;\n    return \
this;\n  }\n  transpose() {\n    let tmp2;\n    const m2 = this.elements;\n   \
 tmp2 = m2[1];\n    m2[1] = m2[3];\n    m2[3] = tmp2;\n    tmp2 = m2[2];\n    \
m2[2] = m2[6];\n    m2[6] = tmp2;\n    tmp2 = m2[5];\n    m2[5] = m2[7];\n    \
m2[7] = tmp2;\n    return this;\n  }\n  getNormalMatrix(matrix4) {\n    \
return this.setFromMatrix4(matrix4).invert().transpose();\n  }\n  \
transposeIntoArray(r) {\n    const m2 = this.elements;\n    r[0] = m2[0];\n   \
 r[1] = m2[3];\n    r[2] = m2[6];\n    r[3] = m2[1];\n    r[4] = m2[4];\n    \
r[5] = m2[7];\n    r[6] = m2[2];\n    r[7] = m2[5];\n    r[8] = m2[8];\n    \
return this;\n  }\n  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n    \
const c2 = Math.cos(rotation);\n    const s = Math.sin(rotation);\n    \
this.set(\n      sx * c2,\n      sx * s,\n      -sx * (c2 * cx + s * cy) + cx \
+ tx,\n      -sy * s,\n      sy * c2,\n      -sy * (-s * cx + c2 * cy) + cy + \
ty,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  //\n  \
scale(sx, sy) {\n    this.premultiply(_m32.makeScale(sx, sy));\n    return \
this;\n  }\n  rotate(theta) {\n    \
this.premultiply(_m32.makeRotation(-theta));\n    return this;\n  }\n  \
translate(tx, ty) {\n    this.premultiply(_m32.makeTranslation(tx, ty));\n    \
return this;\n  }\n  // for 2D Transforms\n  makeTranslation(x2, y2) {\n    \
if (x2.isVector2) {\n      this.set(\n        1,\n        0,\n        x2.x,\n \
       0,\n        1,\n        x2.y,\n        0,\n        0,\n        1\n     \
 );\n    } else {\n      this.set(\n        1,\n        0,\n        x2,\n     \
   0,\n        1,\n        y2,\n        0,\n        0,\n        1\n      );\n \
   }\n    return this;\n  }\n  makeRotation(theta) {\n    const c2 = \
Math.cos(theta);\n    const s = Math.sin(theta);\n    this.set(\n      c2,\n  \
    -s,\n      0,\n      s,\n      c2,\n      0,\n      0,\n      0,\n      \
1\n    );\n    return this;\n  }\n  makeScale(x2, y2) {\n    this.set(\n      \
x2,\n      0,\n      0,\n      0,\n      y2,\n      0,\n      0,\n      0,\n  \
    1\n    );\n    return this;\n  }\n  //\n  equals(matrix) {\n    const te \
= this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 9; \
i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return true;\n  \
}\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 9; i++) {\n      \
this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  \
toArray(array = [], offset = 0) {\n    const te = this.elements;\n    \
array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] \
= te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    \
array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset \
+ 7] = te[7];\n    array[offset + 8] = te[8];\n    return array;\n  }\n  \
clone() {\n    return new this.constructor().fromArray(this.elements);\n  \
}\n};\nvar _m32 = /* @__PURE__ */ new Matrix32();\nfunction \
arrayNeedsUint32$1(array) {\n  for (let i = array.length - 1; i >= 0; --i) \
{\n    if (array[i] >= 65535) return true;\n  }\n  return false;\n}\nfunction \
createElementNS2(name) {\n  return \
document.createElementNS(\"http://www.w3.org/1999/xhtml\", \
name);\n}\nfunction createCanvasElement2() {\n  const canvas = \
createElementNS2(\"canvas\");\n  canvas.style.display = \"block\";\n  return \
canvas;\n}\nvar _cache$2 = {};\nfunction warnOnce2(message) {\n  if (message \
in _cache$2) return;\n  _cache$2[message] = true;\n  \
console.warn(message);\n}\nvar ColorManagement2 = {\n  enabled: true,\n  \
workingColorSpace: LinearSRGBColorSpace2,\n  /**\n   * Implementations of \
supported color spaces.\n   *\n   * Required:\n   *\t- primaries: \
chromaticity coordinates [ rx ry gx gy bx by ]\n   *\t- whitePoint: reference \
white [ x y ]\n   *\t- transfer: transfer function (pre-defined)\n   *\t- \
toXYZ: Matrix3 RGB to XYZ transform\n   *\t- fromXYZ: Matrix3 XYZ to RGB \
transform\n   *\t- luminanceCoefficients: RGB luminance coefficients\n   *\n  \
 * Optional:\n   *  - outputColorSpaceConfig: { drawingBufferColorSpace: \
ColorSpace }\n   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace \
}\n   *\n   * Reference:\n   * - \
https://www.russellcottrell.com/photo/matrixCalculator.htm\n   */\n  spaces: \
{},\n  convert: function(color2, sourceColorSpace, targetColorSpace) {\n    \
if (this.enabled === false || sourceColorSpace === targetColorSpace || \
!sourceColorSpace || !targetColorSpace) {\n      return color2;\n    }\n    \
if (this.spaces[sourceColorSpace].transfer === SRGBTransfer2) {\n      \
color2.r = SRGBToLinear2(color2.r);\n      color2.g = \
SRGBToLinear2(color2.g);\n      color2.b = SRGBToLinear2(color2.b);\n    }\n  \
  if (this.spaces[sourceColorSpace].primaries !== \
this.spaces[targetColorSpace].primaries) {\n      \
color2.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n      \
color2.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n    }\n    if \
(this.spaces[targetColorSpace].transfer === SRGBTransfer2) {\n      color2.r \
= LinearToSRGB2(color2.r);\n      color2.g = LinearToSRGB2(color2.g);\n      \
color2.b = LinearToSRGB2(color2.b);\n    }\n    return color2;\n  },\n  \
fromWorkingColorSpace: function(color2, targetColorSpace) {\n    return \
this.convert(color2, this.workingColorSpace, targetColorSpace);\n  },\n  \
toWorkingColorSpace: function(color2, sourceColorSpace) {\n    return \
this.convert(color2, sourceColorSpace, this.workingColorSpace);\n  },\n  \
getPrimaries: function(colorSpace) {\n    return \
this.spaces[colorSpace].primaries;\n  },\n  getTransfer: function(colorSpace) \
{\n    if (colorSpace === NoColorSpace2) return LinearTransfer2;\n    return \
this.spaces[colorSpace].transfer;\n  },\n  getLuminanceCoefficients: \
function(target, colorSpace = this.workingColorSpace) {\n    return \
target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n  },\n  \
define: function(colorSpaces) {\n    Object.assign(this.spaces, \
colorSpaces);\n  },\n  // Internal APIs\n  _getMatrix: function(targetMatrix, \
sourceColorSpace, targetColorSpace) {\n    return \
targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[t\
argetColorSpace].fromXYZ);\n  },\n  _getDrawingBufferColorSpace: \
function(colorSpace) {\n    return \
this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n  \
},\n  _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n \
   return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n \
 }\n};\nfunction SRGBToLinear2(c2) {\n  return c2 < 0.04045 ? c2 * \
0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);\n}\nfunction \
LinearToSRGB2(c2) {\n  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * \
Math.pow(c2, 0.41666) - 0.055;\n}\nvar REC709_PRIMARIES2 = [0.64, 0.33, 0.3, \
0.6, 0.15, 0.06];\nvar REC709_LUMINANCE_COEFFICIENTS2 = [0.2126, 0.7152, \
0.0722];\nvar D652 = [0.3127, 0.329];\nvar LINEAR_REC709_TO_XYZ2 = /* \
@__PURE__ */ new Matrix32().set(\n  0.4123908,\n  0.3575843,\n  0.1804808,\n  \
0.212639,\n  0.7151687,\n  0.0721923,\n  0.0193308,\n  0.1191948,\n  \
0.9505322\n);\nvar XYZ_TO_LINEAR_REC7092 = /* @__PURE__ */ new \
Matrix32().set(\n  3.2409699,\n  -1.5373832,\n  -0.4986108,\n  -0.9692436,\n  \
1.8759675,\n  0.0415551,\n  0.0556301,\n  -0.203977,\n  \
1.0569715\n);\nColorManagement2.define({\n  [LinearSRGBColorSpace2]: {\n    \
primaries: REC709_PRIMARIES2,\n    whitePoint: D652,\n    transfer: \
LinearTransfer2,\n    toXYZ: LINEAR_REC709_TO_XYZ2,\n    fromXYZ: \
XYZ_TO_LINEAR_REC7092,\n    luminanceCoefficients: \
REC709_LUMINANCE_COEFFICIENTS2,\n    workingColorSpaceConfig: { \
unpackColorSpace: SRGBColorSpace2 },\n    outputColorSpaceConfig: { \
drawingBufferColorSpace: SRGBColorSpace2 }\n  },\n  [SRGBColorSpace2]: {\n    \
primaries: REC709_PRIMARIES2,\n    whitePoint: D652,\n    transfer: \
SRGBTransfer2,\n    toXYZ: LINEAR_REC709_TO_XYZ2,\n    fromXYZ: \
XYZ_TO_LINEAR_REC7092,\n    luminanceCoefficients: \
REC709_LUMINANCE_COEFFICIENTS2,\n    outputColorSpaceConfig: { \
drawingBufferColorSpace: SRGBColorSpace2 }\n  }\n});\nvar _canvas2;\nvar \
ImageUtils2 = class {\n  static getDataURL(image) {\n    if \
(/^data:/i.test(image.src)) {\n      return image.src;\n    }\n    if (typeof \
HTMLCanvasElement === \"undefined\") {\n      return image.src;\n    }\n    \
let canvas;\n    if (image instanceof HTMLCanvasElement) {\n      canvas = \
image;\n    } else {\n      if (_canvas2 === void 0) _canvas2 = \
createElementNS2(\"canvas\");\n      _canvas2.width = image.width;\n      \
_canvas2.height = image.height;\n      const context2 = \
_canvas2.getContext(\"2d\");\n      if (image instanceof ImageData) {\n       \
 context2.putImageData(image, 0, 0);\n      } else {\n        \
context2.drawImage(image, 0, 0, image.width, image.height);\n      }\n      \
canvas = _canvas2;\n    }\n    if (canvas.width > 2048 || canvas.height > \
2048) {\n      console.warn(\"THREE.ImageUtils.getDataURL: Image converted to \
jpg for performance reasons\", image);\n      return \
canvas.toDataURL(\"image/jpeg\", 0.6);\n    } else {\n      return \
canvas.toDataURL(\"image/png\");\n    }\n  }\n  static sRGBToLinear(image) \
{\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof \
HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image \
instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image \
instanceof ImageBitmap) {\n      const canvas = \
createElementNS2(\"canvas\");\n      canvas.width = image.width;\n      \
canvas.height = image.height;\n      const context2 = \
canvas.getContext(\"2d\");\n      context2.drawImage(image, 0, 0, \
image.width, image.height);\n      const imageData = context2.getImageData(0, \
0, image.width, image.height);\n      const data = imageData.data;\n      for \
(let i = 0; i < data.length; i++) {\n        data[i] = SRGBToLinear2(data[i] \
/ 255) * 255;\n      }\n      context2.putImageData(imageData, 0, 0);\n      \
return canvas;\n    } else if (image.data) {\n      const data = \
image.data.slice(0);\n      for (let i = 0; i < data.length; i++) {\n        \
if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n      \
    data[i] = Math.floor(SRGBToLinear2(data[i] / 255) * 255);\n        } else \
{\n          data[i] = SRGBToLinear2(data[i]);\n        }\n      }\n      \
return {\n        data,\n        width: image.width,\n        height: \
image.height\n      };\n    } else {\n      \
console.warn(\"THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No \
color space conversion applied.\");\n      return image;\n    }\n  }\n};\nvar \
_sourceId2 = 0;\nvar Source2 = class {\n  constructor(data = null) {\n    \
this.isSource = true;\n    Object.defineProperty(this, \"id\", { value: \
_sourceId2++ });\n    this.uuid = generateUUID2();\n    this.data = data;\n   \
 this.dataReady = true;\n    this.version = 0;\n  }\n  set needsUpdate(value) \
{\n    if (value === true) this.version++;\n  }\n  toJSON(meta) {\n    const \
isRootObject = meta === void 0 || typeof meta === \"string\";\n    if \
(!isRootObject && meta.images[this.uuid] !== void 0) {\n      return \
meta.images[this.uuid];\n    }\n    const output2 = {\n      uuid: \
this.uuid,\n      url: \"\"\n    };\n    const data = this.data;\n    if \
(data !== null) {\n      let url;\n      if (Array.isArray(data)) {\n        \
url = [];\n        for (let i = 0, l = data.length; i < l; i++) {\n          \
if (data[i].isDataTexture) {\n            \
url.push(serializeImage2(data[i].image));\n          } else {\n            \
url.push(serializeImage2(data[i]));\n          }\n        }\n      } else {\n \
       url = serializeImage2(data);\n      }\n      output2.url = url;\n    \
}\n    if (!isRootObject) {\n      meta.images[this.uuid] = output2;\n    }\n \
   return output2;\n  }\n};\nfunction serializeImage2(image) {\n  if (typeof \
HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || \
typeof HTMLCanvasElement !== \"undefined\" && image instanceof \
HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof \
ImageBitmap) {\n    return ImageUtils2.getDataURL(image);\n  } else {\n    if \
(image.data) {\n      return {\n        data: Array.from(image.data),\n       \
 width: image.width,\n        height: image.height,\n        type: \
image.data.constructor.name\n      };\n    } else {\n      \
console.warn(\"THREE.Texture: Unable to serialize Texture.\");\n      return \
{};\n    }\n  }\n}\nvar _textureId2 = 0;\nvar Texture2 = class _Texture \
extends EventDispatcher2 {\n  constructor(image = _Texture.DEFAULT_IMAGE, \
mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping2, wrapT = \
ClampToEdgeWrapping2, magFilter = LinearFilter2, minFilter = \
LinearMipmapLinearFilter2, format2 = RGBAFormat2, type = UnsignedByteType2, \
anisotropy2 = _Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace2) {\n    \
super();\n    this.isTexture = true;\n    Object.defineProperty(this, \"id\", \
{ value: _textureId2++ });\n    this.uuid = generateUUID2();\n    this.name = \
\"\";\n    this.source = new Source2(image);\n    this.mipmaps = [];\n    \
this.mapping = mapping;\n    this.channel = 0;\n    this.wrapS = wrapS;\n    \
this.wrapT = wrapT;\n    this.magFilter = magFilter;\n    this.minFilter = \
minFilter;\n    this.anisotropy = anisotropy2;\n    this.format = format2;\n  \
  this.internalFormat = null;\n    this.type = type;\n    this.offset = new \
Vector22(0, 0);\n    this.repeat = new Vector22(1, 1);\n    this.center = new \
Vector22(0, 0);\n    this.rotation = 0;\n    this.matrixAutoUpdate = true;\n  \
  this.matrix = new Matrix32();\n    this.generateMipmaps = true;\n    \
this.premultiplyAlpha = false;\n    this.flipY = true;\n    \
this.unpackAlignment = 4;\n    this.colorSpace = colorSpace;\n    \
this.userData = {};\n    this.version = 0;\n    this.onUpdate = null;\n    \
this.isRenderTargetTexture = false;\n    this.pmremVersion = 0;\n  }\n  get \
image() {\n    return this.source.data;\n  }\n  set image(value = null) {\n   \
 this.source.data = value;\n  }\n  updateMatrix() {\n    \
this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, \
this.repeat.y, this.rotation, this.center.x, this.center.y);\n  }\n  clone() \
{\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    \
this.name = source.name;\n    this.source = source.source;\n    this.mipmaps \
= source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    \
this.channel = source.channel;\n    this.wrapS = source.wrapS;\n    \
this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    \
this.minFilter = source.minFilter;\n    this.anisotropy = \
source.anisotropy;\n    this.format = source.format;\n    this.internalFormat \
= source.internalFormat;\n    this.type = source.type;\n    \
this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    \
this.center.copy(source.center);\n    this.rotation = source.rotation;\n    \
this.matrixAutoUpdate = source.matrixAutoUpdate;\n    \
this.matrix.copy(source.matrix);\n    this.generateMipmaps = \
source.generateMipmaps;\n    this.premultiplyAlpha = \
source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    \
this.unpackAlignment = source.unpackAlignment;\n    this.colorSpace = \
source.colorSpace;\n    this.userData = \
JSON.parse(JSON.stringify(source.userData));\n    this.needsUpdate = true;\n  \
  return this;\n  }\n  toJSON(meta) {\n    const isRootObject = meta === void \
0 || typeof meta === \"string\";\n    if (!isRootObject && \
meta.textures[this.uuid] !== void 0) {\n      return \
meta.textures[this.uuid];\n    }\n    const output2 = {\n      metadata: {\n  \
      version: 4.6,\n        type: \"Texture\",\n        generator: \
\"Texture.toJSON\"\n      },\n      uuid: this.uuid,\n      name: \
this.name,\n      image: this.source.toJSON(meta).uuid,\n      mapping: \
this.mapping,\n      channel: this.channel,\n      repeat: [this.repeat.x, \
this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: \
[this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: \
[this.wrapS, this.wrapT],\n      format: this.format,\n      internalFormat: \
this.internalFormat,\n      type: this.type,\n      colorSpace: \
this.colorSpace,\n      minFilter: this.minFilter,\n      magFilter: \
this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: \
this.flipY,\n      generateMipmaps: this.generateMipmaps,\n      \
premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: \
this.unpackAlignment\n    };\n    if (Object.keys(this.userData).length > 0) \
output2.userData = this.userData;\n    if (!isRootObject) {\n      \
meta.textures[this.uuid] = output2;\n    }\n    return output2;\n  }\n  \
dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n  \
transformUv(uv2) {\n    if (this.mapping !== UVMapping2) return uv2;\n    \
uv2.applyMatrix3(this.matrix);\n    if (uv2.x < 0 || uv2.x > 1) {\n      \
switch (this.wrapS) {\n        case RepeatWrapping2:\n          uv2.x = uv2.x \
- Math.floor(uv2.x);\n          break;\n        case ClampToEdgeWrapping2:\n  \
        uv2.x = uv2.x < 0 ? 0 : 1;\n          break;\n        case \
MirroredRepeatWrapping2:\n          if (Math.abs(Math.floor(uv2.x) % 2) === \
1) {\n            uv2.x = Math.ceil(uv2.x) - uv2.x;\n          } else {\n     \
       uv2.x = uv2.x - Math.floor(uv2.x);\n          }\n          break;\n    \
  }\n    }\n    if (uv2.y < 0 || uv2.y > 1) {\n      switch (this.wrapT) {\n  \
      case RepeatWrapping2:\n          uv2.y = uv2.y - Math.floor(uv2.y);\n   \
       break;\n        case ClampToEdgeWrapping2:\n          uv2.y = uv2.y < \
0 ? 0 : 1;\n          break;\n        case MirroredRepeatWrapping2:\n         \
 if (Math.abs(Math.floor(uv2.y) % 2) === 1) {\n            uv2.y = \
Math.ceil(uv2.y) - uv2.y;\n          } else {\n            uv2.y = uv2.y - \
Math.floor(uv2.y);\n          }\n          break;\n      }\n    }\n    if \
(this.flipY) {\n      uv2.y = 1 - uv2.y;\n    }\n    return uv2;\n  }\n  set \
needsUpdate(value) {\n    if (value === true) {\n      this.version++;\n      \
this.source.needsUpdate = true;\n    }\n  }\n  set needsPMREMUpdate(value) \
{\n    if (value === true) {\n      this.pmremVersion++;\n    }\n  \
}\n};\nTexture2.DEFAULT_IMAGE = null;\nTexture2.DEFAULT_MAPPING = \
UVMapping2;\nTexture2.DEFAULT_ANISOTROPY = 1;\nvar Vector42 = class _Vector4 \
{\n  constructor(x2 = 0, y2 = 0, z2 = 0, w = 1) {\n    \
_Vector4.prototype.isVector4 = true;\n    this.x = x2;\n    this.y = y2;\n    \
this.z = z2;\n    this.w = w;\n  }\n  get width() {\n    return this.z;\n  \
}\n  set width(value) {\n    this.z = value;\n  }\n  get height() {\n    \
return this.w;\n  }\n  set height(value) {\n    this.w = value;\n  }\n  \
set(x2, y2, z2, w) {\n    this.x = x2;\n    this.y = y2;\n    this.z = z2;\n  \
  this.w = w;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = \
scalar;\n    this.y = scalar;\n    this.z = scalar;\n    this.w = scalar;\n   \
 return this;\n  }\n  setX(x2) {\n    this.x = x2;\n    return this;\n  }\n  \
setY(y2) {\n    this.y = y2;\n    return this;\n  }\n  setZ(z2) {\n    this.z \
= z2;\n    return this;\n  }\n  setW(w) {\n    this.w = w;\n    return \
this;\n  }\n  setComponent(index5, value) {\n    switch (index5) {\n      \
case 0:\n        this.x = value;\n        break;\n      case 1:\n        \
this.y = value;\n        break;\n      case 2:\n        this.z = value;\n     \
   break;\n      case 3:\n        this.w = value;\n        break;\n      \
default:\n        throw new Error(\"index is out of range: \" + index5);\n    \
}\n    return this;\n  }\n  getComponent(index5) {\n    switch (index5) {\n   \
   case 0:\n        return this.x;\n      case 1:\n        return this.y;\n   \
   case 2:\n        return this.z;\n      case 3:\n        return this.w;\n   \
   default:\n        throw new Error(\"index is out of range: \" + index5);\n \
   }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, \
this.z, this.w);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    \
this.z = v.z;\n    this.w = v.w !== void 0 ? v.w : 1;\n    return this;\n  \
}\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n   \
 this.w += v.w;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n  \
  this.y += s;\n    this.z += s;\n    this.w += s;\n    return this;\n  }\n  \
addVectors(a2, b) {\n    this.x = a2.x + b.x;\n    this.y = a2.y + b.y;\n    \
this.z = a2.z + b.z;\n    this.w = a2.w + b.w;\n    return this;\n  }\n  \
addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    \
this.z += v.z * s;\n    this.w += v.w * s;\n    return this;\n  }\n  sub(v) \
{\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= \
v.w;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y \
-= s;\n    this.z -= s;\n    this.w -= s;\n    return this;\n  }\n  \
subVectors(a2, b) {\n    this.x = a2.x - b.x;\n    this.y = a2.y - b.y;\n    \
this.z = a2.z - b.z;\n    this.w = a2.w - b.w;\n    return this;\n  }\n  \
multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n   \
 this.w *= v.w;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    \
this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w \
*= scalar;\n    return this;\n  }\n  applyMatrix4(m2) {\n    const x2 = \
this.x, y2 = this.y, z2 = this.z, w = this.w;\n    const e = m2.elements;\n   \
 this.x = e[0] * x2 + e[4] * y2 + e[8] * z2 + e[12] * w;\n    this.y = e[1] * \
x2 + e[5] * y2 + e[9] * z2 + e[13] * w;\n    this.z = e[2] * x2 + e[6] * y2 + \
e[10] * z2 + e[14] * w;\n    this.w = e[3] * x2 + e[7] * y2 + e[11] * z2 + \
e[15] * w;\n    return this;\n  }\n  divide(v) {\n    this.x /= v.x;\n    \
this.y /= v.y;\n    this.z /= v.z;\n    this.w /= v.w;\n    return this;\n  \
}\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  \
}\n  setAxisAngleFromQuaternion(q) {\n    this.w = 2 * Math.acos(q.w);\n    \
const s = Math.sqrt(1 - q.w * q.w);\n    if (s < 1e-4) {\n      this.x = 1;\n \
     this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n  \
    this.y = q.y / s;\n      this.z = q.z / s;\n    }\n    return this;\n  \
}\n  setAxisAngleFromRotationMatrix(m2) {\n    let angle, x2, y2, z2;\n    \
const epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = \
te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = \
te[6], m33 = te[10];\n    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - \
m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n      if (Math.abs(m12 + \
m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < \
epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n        this.set(1, \
0, 0, 0);\n        return this;\n      }\n      angle = Math.PI;\n      const \
xx = (m11 + 1) / 2;\n      const yy = (m22 + 1) / 2;\n      const zz = (m33 + \
1) / 2;\n      const xy = (m12 + m21) / 4;\n      const xz = (m13 + m31) / \
4;\n      const yz = (m23 + m32) / 4;\n      if (xx > yy && xx > zz) {\n      \
  if (xx < epsilon) {\n          x2 = 0;\n          y2 = 0.707106781;\n       \
   z2 = 0.707106781;\n        } else {\n          x2 = Math.sqrt(xx);\n       \
   y2 = xy / x2;\n          z2 = xz / x2;\n        }\n      } else if (yy > \
zz) {\n        if (yy < epsilon) {\n          x2 = 0.707106781;\n          y2 \
= 0;\n          z2 = 0.707106781;\n        } else {\n          y2 = \
Math.sqrt(yy);\n          x2 = xy / y2;\n          z2 = yz / y2;\n        }\n \
     } else {\n        if (zz < epsilon) {\n          x2 = 0.707106781;\n     \
     y2 = 0.707106781;\n          z2 = 0;\n        } else {\n          z2 = \
Math.sqrt(zz);\n          x2 = xz / z2;\n          y2 = yz / z2;\n        }\n \
     }\n      this.set(x2, y2, z2, angle);\n      return this;\n    }\n    \
let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + \
(m21 - m12) * (m21 - m12));\n    if (Math.abs(s) < 1e-3) s = 1;\n    this.x = \
(m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / \
s;\n    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n    return this;\n  \
}\n  setFromMatrixPosition(m2) {\n    const e = m2.elements;\n    this.x = \
e[12];\n    this.y = e[13];\n    this.z = e[14];\n    this.w = e[15];\n    \
return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    \
this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    \
this.w = Math.min(this.w, v.w);\n    return this;\n  }\n  max(v) {\n    \
this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    \
this.z = Math.max(this.z, v.z);\n    this.w = Math.max(this.w, v.w);\n    \
return this;\n  }\n  clamp(min2, max2) {\n    this.x = Math.max(min2.x, \
Math.min(max2.x, this.x));\n    this.y = Math.max(min2.y, Math.min(max2.y, \
this.y));\n    this.z = Math.max(min2.z, Math.min(max2.z, this.z));\n    \
this.w = Math.max(min2.w, Math.min(max2.w, this.w));\n    return this;\n  }\n \
 clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, \
Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, \
this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    \
this.w = Math.max(minVal, Math.min(maxVal, this.w));\n    return this;\n  }\n \
 clampLength(min2, max2) {\n    const length2 = this.length();\n    return \
this.divideScalar(length2 || 1).multiplyScalar(Math.max(min2, Math.min(max2, \
length2)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = \
Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = \
Math.floor(this.w);\n    return this;\n  }\n  ceil() {\n    this.x = \
Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = \
Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n    return this;\n  }\n  \
round() {\n    this.x = Math.round(this.x);\n    this.y = \
Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = \
Math.round(this.w);\n    return this;\n  }\n  roundToZero() {\n    this.x = \
Math.trunc(this.x);\n    this.y = Math.trunc(this.y);\n    this.z = \
Math.trunc(this.z);\n    this.w = Math.trunc(this.w);\n    return this;\n  \
}\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = \
-this.z;\n    this.w = -this.w;\n    return this;\n  }\n  dot(v) {\n    \
return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  }\n  \
lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z \
+ this.w * this.w;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + \
this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n  \
manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + \
Math.abs(this.z) + Math.abs(this.w);\n  }\n  normalize() {\n    return \
this.divideScalar(this.length() || 1);\n  }\n  setLength(length2) {\n    \
return this.normalize().multiplyScalar(length2);\n  }\n  lerp(v, alpha) {\n   \
 this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n   \
 this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n   \
 return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x \
- v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = \
v1.z + (v2.z - v1.z) * alpha;\n    this.w = v1.w + (v2.w - v1.w) * alpha;\n   \
 return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === \
this.y && v.z === this.z && v.w === this.w;\n  }\n  fromArray(array, offset = \
0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    \
this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return \
this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = \
this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n   \
 array[offset + 3] = this.w;\n    return array;\n  }\n  \
fromBufferAttribute(attribute2, index5) {\n    this.x = \
attribute2.getX(index5);\n    this.y = attribute2.getY(index5);\n    this.z = \
attribute2.getZ(index5);\n    this.w = attribute2.getW(index5);\n    return \
this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = \
Math.random();\n    this.z = Math.random();\n    this.w = Math.random();\n    \
return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield \
this.y;\n    yield this.z;\n    yield this.w;\n  }\n};\nvar RenderTarget2 = \
class extends EventDispatcher2 {\n  constructor(width = 1, height = 1, \
options = {}) {\n    super();\n    this.isRenderTarget = true;\n    \
this.width = width;\n    this.height = height;\n    this.depth = 1;\n    \
this.scissor = new Vector42(0, 0, width, height);\n    this.scissorTest = \
false;\n    this.viewport = new Vector42(0, 0, width, height);\n    const \
image = { width, height, depth: 1 };\n    options = Object.assign({\n      \
generateMipmaps: false,\n      internalFormat: null,\n      minFilter: \
LinearFilter2,\n      depthBuffer: true,\n      stencilBuffer: false,\n      \
resolveDepthBuffer: true,\n      resolveStencilBuffer: true,\n      \
depthTexture: null,\n      samples: 0,\n      count: 1\n    }, options);\n    \
const texture2 = new Texture2(image, options.mapping, options.wrapS, \
options.wrapT, options.magFilter, options.minFilter, options.format, \
options.type, options.anisotropy, options.colorSpace);\n    texture2.flipY = \
false;\n    texture2.generateMipmaps = options.generateMipmaps;\n    \
texture2.internalFormat = options.internalFormat;\n    this.textures = [];\n  \
  const count = options.count;\n    for (let i = 0; i < count; i++) {\n      \
this.textures[i] = texture2.clone();\n      \
this.textures[i].isRenderTargetTexture = true;\n    }\n    this.depthBuffer = \
options.depthBuffer;\n    this.stencilBuffer = options.stencilBuffer;\n    \
this.resolveDepthBuffer = options.resolveDepthBuffer;\n    \
this.resolveStencilBuffer = options.resolveStencilBuffer;\n    \
this.depthTexture = options.depthTexture;\n    this.samples = \
options.samples;\n  }\n  get texture() {\n    return this.textures[0];\n  }\n \
 set texture(value) {\n    this.textures[0] = value;\n  }\n  setSize(width, \
height, depth2 = 1) {\n    if (this.width !== width || this.height !== height \
|| this.depth !== depth2) {\n      this.width = width;\n      this.height = \
height;\n      this.depth = depth2;\n      for (let i = 0, il = \
this.textures.length; i < il; i++) {\n        this.textures[i].image.width = \
width;\n        this.textures[i].image.height = height;\n        \
this.textures[i].image.depth = depth2;\n      }\n      this.dispose();\n    \
}\n    this.viewport.set(0, 0, width, height);\n    this.scissor.set(0, 0, \
width, height);\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n  copy(source) {\n    this.width = \
source.width;\n    this.height = source.height;\n    this.depth = \
source.depth;\n    this.scissor.copy(source.scissor);\n    this.scissorTest = \
source.scissorTest;\n    this.viewport.copy(source.viewport);\n    \
this.textures.length = 0;\n    for (let i = 0, il = source.textures.length; i \
< il; i++) {\n      this.textures[i] = source.textures[i].clone();\n      \
this.textures[i].isRenderTargetTexture = true;\n    }\n    const image = \
Object.assign({}, source.texture.image);\n    this.texture.source = new \
Source2(image);\n    this.depthBuffer = source.depthBuffer;\n    \
this.stencilBuffer = source.stencilBuffer;\n    this.resolveDepthBuffer = \
source.resolveDepthBuffer;\n    this.resolveStencilBuffer = \
source.resolveStencilBuffer;\n    if (source.depthTexture !== null) \
this.depthTexture = source.depthTexture.clone();\n    this.samples = \
source.samples;\n    return this;\n  }\n  dispose() {\n    \
this.dispatchEvent({ type: \"dispose\" });\n  }\n};\nvar WebGLRenderTarget2 = \
class extends RenderTarget2 {\n  constructor(width = 1, height = 1, options = \
{}) {\n    super(width, height, options);\n    this.isWebGLRenderTarget = \
true;\n  }\n};\nvar DataArrayTexture2 = class extends Texture2 {\n  \
constructor(data = null, width = 1, height = 1, depth2 = 1) {\n    \
super(null);\n    this.isDataArrayTexture = true;\n    this.image = { data, \
width, height, depth: depth2 };\n    this.magFilter = NearestFilter2;\n    \
this.minFilter = NearestFilter2;\n    this.wrapR = ClampToEdgeWrapping2;\n    \
this.generateMipmaps = false;\n    this.flipY = false;\n    \
this.unpackAlignment = 1;\n    this.layerUpdates = /* @__PURE__ */ new \
Set();\n  }\n  addLayerUpdate(layerIndex) {\n    \
this.layerUpdates.add(layerIndex);\n  }\n  clearLayerUpdates() {\n    \
this.layerUpdates.clear();\n  }\n};\nvar Quaternion2 = class {\n  \
constructor(x2 = 0, y2 = 0, z2 = 0, w = 1) {\n    this.isQuaternion = true;\n \
   this._x = x2;\n    this._y = y2;\n    this._z = z2;\n    this._w = w;\n  \
}\n  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) \
{\n    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = \
src0[srcOffset0 + 2], w02 = src0[srcOffset0 + 3];\n    const x1 = \
src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], \
w12 = src1[srcOffset1 + 3];\n    if (t === 0) {\n      dst[dstOffset + 0] = \
x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      \
dst[dstOffset + 3] = w02;\n      return;\n    }\n    if (t === 1) {\n      \
dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset \
+ 2] = z1;\n      dst[dstOffset + 3] = w12;\n      return;\n    }\n    if \
(w02 !== w12 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - \
t;\n      const cos2 = x0 * x1 + y0 * y1 + z0 * z1 + w02 * w12, dir = cos2 >= \
0 ? 1 : -1, sqrSin = 1 - cos2 * cos2;\n      if (sqrSin > Number.EPSILON) {\n \
       const sin2 = Math.sqrt(sqrSin), len = Math.atan2(sin2, cos2 * dir);\n  \
      s = Math.sin(s * len) / sin2;\n        t = Math.sin(t * len) / sin2;\n  \
    }\n      const tDir = t * dir;\n      x0 = x0 * s + x1 * tDir;\n      y0 \
= y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w02 = w02 * s + \
w12 * tDir;\n      if (s === 1 - t) {\n        const f = 1 / Math.sqrt(x0 * \
x0 + y0 * y0 + z0 * z0 + w02 * w02);\n        x0 *= f;\n        y0 *= f;\n    \
    z0 *= f;\n        w02 *= f;\n      }\n    }\n    dst[dstOffset] = x0;\n   \
 dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + \
3] = w02;\n  }\n  static multiplyQuaternionsFlat(dst, dstOffset, src0, \
srcOffset0, src1, srcOffset1) {\n    const x0 = src0[srcOffset0];\n    const \
y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const \
w02 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1];\n    const y1 = \
src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w12 = \
src1[srcOffset1 + 3];\n    dst[dstOffset] = x0 * w12 + w02 * x1 + y0 * z1 - \
z0 * y1;\n    dst[dstOffset + 1] = y0 * w12 + w02 * y1 + z0 * x1 - x0 * z1;\n \
   dst[dstOffset + 2] = z0 * w12 + w02 * z1 + x0 * y1 - y0 * x1;\n    \
dst[dstOffset + 3] = w02 * w12 - x0 * x1 - y0 * y1 - z0 * z1;\n    return \
dst;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    \
this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return \
this._y;\n  }\n  set y(value) {\n    this._y = value;\n    \
this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set \
z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get \
w() {\n    return this._w;\n  }\n  set w(value) {\n    this._w = value;\n    \
this._onChangeCallback();\n  }\n  set(x2, y2, z2, w) {\n    this._x = x2;\n   \
 this._y = y2;\n    this._z = z2;\n    this._w = w;\n    \
this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new \
this.constructor(this._x, this._y, this._z, this._w);\n  }\n  \
copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = \
quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n    \
this._onChangeCallback();\n    return this;\n  }\n  setFromEuler(euler, \
update4 = true) {\n    const x2 = euler._x, y2 = euler._y, z2 = euler._z, \
order = euler._order;\n    const cos2 = Math.cos;\n    const sin2 = \
Math.sin;\n    const c1 = cos2(x2 / 2);\n    const c2 = cos2(y2 / 2);\n    \
const c3 = cos2(z2 / 2);\n    const s1 = sin2(x2 / 2);\n    const s2 = \
sin2(y2 / 2);\n    const s3 = sin2(z2 / 2);\n    switch (order) {\n      case \
\"XYZ\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = \
c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * \
c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      \
case \"YXZ\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n    \
  case \"ZXY\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n    \
  case \"ZYX\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n    \
  case \"YZX\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n    \
  case \"XZY\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        \
this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * \
s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n    \
  default:\n        console.warn(\"THREE.Quaternion: .setFromEuler() \
encountered an unknown order: \" + order);\n    }\n    if (update4 === true) \
this._onChangeCallback();\n    return this;\n  }\n  setFromAxisAngle(axis, \
angle) {\n    const halfAngle = angle / 2, s = Math.sin(halfAngle);\n    \
this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n \
   this._w = Math.cos(halfAngle);\n    this._onChangeCallback();\n    return \
this;\n  }\n  setFromRotationMatrix(m2) {\n    const te = m2.elements, m11 = \
te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = \
te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n    if (trace > \
0) {\n      const s = 0.5 / Math.sqrt(trace + 1);\n      this._w = 0.25 / \
s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      \
this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      \
const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n      this._w = (m32 - m23) / \
s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      \
this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s = 2 * \
Math.sqrt(1 + m22 - m11 - m33);\n      this._w = (m13 - m31) / s;\n      \
this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + \
m32) / s;\n    } else {\n      const s = 2 * Math.sqrt(1 + m33 - m11 - \
m22);\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n   \
   this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n    \
this._onChangeCallback();\n    return this;\n  }\n  setFromUnitVectors(vFrom, \
vTo) {\n    let r = vFrom.dot(vTo) + 1;\n    if (r < Number.EPSILON) {\n      \
r = 0;\n      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n        this._x = \
-vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w \
= r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n     \
   this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      \
this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x \
- vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      \
this._w = r;\n    }\n    return this.normalize();\n  }\n  angleTo(q) {\n    \
return 2 * Math.acos(Math.abs(clamp$1(this.dot(q), -1, 1)));\n  }\n  \
rotateTowards(q, step2) {\n    const angle = this.angleTo(q);\n    if (angle \
=== 0) return this;\n    const t = Math.min(1, step2 / angle);\n    \
this.slerp(q, t);\n    return this;\n  }\n  identity() {\n    return \
this.set(0, 0, 0, 1);\n  }\n  invert() {\n    return this.conjugate();\n  }\n \
 conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n  \
  this._onChangeCallback();\n    return this;\n  }\n  dot(v) {\n    return \
this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n  \
lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * \
this._z + this._w * this._w;\n  }\n  length() {\n    return Math.sqrt(this._x \
* this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  \
}\n  normalize() {\n    let l = this.length();\n    if (l === 0) {\n      \
this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    \
} else {\n      l = 1 / l;\n      this._x = this._x * l;\n      this._y = \
this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    \
}\n    this._onChangeCallback();\n    return this;\n  }\n  multiply(q) {\n    \
return this.multiplyQuaternions(this, q);\n  }\n  premultiply(q) {\n    \
return this.multiplyQuaternions(q, this);\n  }\n  multiplyQuaternions(a2, b) \
{\n    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;\n    const \
qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n    this._x = qax * qbw + \
qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz \
* qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * \
qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n    \
this._onChangeCallback();\n    return this;\n  }\n  slerp(qb, t) {\n    if (t \
=== 0) return this;\n    if (t === 1) return this.copy(qb);\n    const x2 = \
this._x, y2 = this._y, z2 = this._z, w = this._w;\n    let cosHalfTheta = w * \
qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;\n    if (cosHalfTheta < 0) {\n  \
    this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n     \
 this._z = -qb._z;\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      \
this.copy(qb);\n    }\n    if (cosHalfTheta >= 1) {\n      this._w = w;\n     \
 this._x = x2;\n      this._y = y2;\n      this._z = z2;\n      return \
this;\n    }\n    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n  \
  if (sqrSinHalfTheta <= Number.EPSILON) {\n      const s = 1 - t;\n      \
this._w = s * w + t * this._w;\n      this._x = s * x2 + t * this._x;\n      \
this._y = s * y2 + t * this._y;\n      this._z = s * z2 + t * this._z;\n      \
this.normalize();\n      return this;\n    }\n    const sinHalfTheta = \
Math.sqrt(sqrSinHalfTheta);\n    const halfTheta = Math.atan2(sinHalfTheta, \
cosHalfTheta);\n    const ratioA = Math.sin((1 - t) * halfTheta) / \
sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n    this._w = \
w * ratioA + this._w * ratioB;\n    this._x = x2 * ratioA + this._x * \
ratioB;\n    this._y = y2 * ratioA + this._y * ratioB;\n    this._z = z2 * \
ratioA + this._z * ratioB;\n    this._onChangeCallback();\n    return this;\n \
 }\n  slerpQuaternions(qa, qb, t) {\n    return this.copy(qa).slerp(qb, t);\n \
 }\n  random() {\n    const theta1 = 2 * Math.PI * Math.random();\n    const \
theta2 = 2 * Math.PI * Math.random();\n    const x0 = Math.random();\n    \
const r1 = Math.sqrt(1 - x0);\n    const r2 = Math.sqrt(x0);\n    return \
this.set(\n      r1 * Math.sin(theta1),\n      r1 * Math.cos(theta1),\n      \
r2 * Math.sin(theta2),\n      r2 * Math.cos(theta2)\n    );\n  }\n  \
equals(quaternion) {\n    return quaternion._x === this._x && quaternion._y \
=== this._y && quaternion._z === this._z && quaternion._w === this._w;\n  }\n \
 fromArray(array, offset = 0) {\n    this._x = array[offset];\n    this._y = \
array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = \
array[offset + 3];\n    this._onChangeCallback();\n    return this;\n  }\n  \
toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    \
array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    \
array[offset + 3] = this._w;\n    return array;\n  }\n  \
fromBufferAttribute(attribute2, index5) {\n    this._x = \
attribute2.getX(index5);\n    this._y = attribute2.getY(index5);\n    this._z \
= attribute2.getZ(index5);\n    this._w = attribute2.getW(index5);\n    \
this._onChangeCallback();\n    return this;\n  }\n  toJSON() {\n    return \
this.toArray();\n  }\n  _onChange(callback) {\n    this._onChangeCallback = \
callback;\n    return this;\n  }\n  _onChangeCallback() {\n  }\n  \
*[Symbol.iterator]() {\n    yield this._x;\n    yield this._y;\n    yield \
this._z;\n    yield this._w;\n  }\n};\nvar Vector32 = class _Vector3 {\n  \
constructor(x2 = 0, y2 = 0, z2 = 0) {\n    _Vector3.prototype.isVector3 = \
true;\n    this.x = x2;\n    this.y = y2;\n    this.z = z2;\n  }\n  set(x2, \
y2, z2) {\n    if (z2 === void 0) z2 = this.z;\n    this.x = x2;\n    this.y \
= y2;\n    this.z = z2;\n    return this;\n  }\n  setScalar(scalar) {\n    \
this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    return \
this;\n  }\n  setX(x2) {\n    this.x = x2;\n    return this;\n  }\n  setY(y2) \
{\n    this.y = y2;\n    return this;\n  }\n  setZ(z2) {\n    this.z = z2;\n  \
  return this;\n  }\n  setComponent(index5, value) {\n    switch (index5) {\n \
     case 0:\n        this.x = value;\n        break;\n      case 1:\n        \
this.y = value;\n        break;\n      case 2:\n        this.z = value;\n     \
   break;\n      default:\n        throw new Error(\"index is out of range: \
\" + index5);\n    }\n    return this;\n  }\n  getComponent(index5) {\n    \
switch (index5) {\n      case 0:\n        return this.x;\n      case 1:\n     \
   return this.y;\n      case 2:\n        return this.z;\n      default:\n    \
    throw new Error(\"index is out of range: \" + index5);\n    }\n  }\n  \
clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  }\n  \
copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    \
return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    \
this.z += v.z;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n   \
 this.y += s;\n    this.z += s;\n    return this;\n  }\n  addVectors(a2, b) \
{\n    this.x = a2.x + b.x;\n    this.y = a2.y + b.y;\n    this.z = a2.z + \
b.z;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * \
s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  }\n  \
sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    \
return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    \
this.z -= s;\n    return this;\n  }\n  subVectors(a2, b) {\n    this.x = a2.x \
- b.x;\n    this.y = a2.y - b.y;\n    this.z = a2.z - b.z;\n    return \
this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    \
this.z *= v.z;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x \
*= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  \
}\n  multiplyVectors(a2, b) {\n    this.x = a2.x * b.x;\n    this.y = a2.y * \
b.y;\n    this.z = a2.z * b.z;\n    return this;\n  }\n  applyEuler(euler) \
{\n    return this.applyQuaternion(_quaternion$42.setFromEuler(euler));\n  \
}\n  applyAxisAngle(axis, angle) {\n    return \
this.applyQuaternion(_quaternion$42.setFromAxisAngle(axis, angle));\n  }\n  \
applyMatrix3(m2) {\n    const x2 = this.x, y2 = this.y, z2 = this.z;\n    \
const e = m2.elements;\n    this.x = e[0] * x2 + e[3] * y2 + e[6] * z2;\n    \
this.y = e[1] * x2 + e[4] * y2 + e[7] * z2;\n    this.z = e[2] * x2 + e[5] * \
y2 + e[8] * z2;\n    return this;\n  }\n  applyNormalMatrix(m2) {\n    return \
this.applyMatrix3(m2).normalize();\n  }\n  applyMatrix4(m2) {\n    const x2 = \
this.x, y2 = this.y, z2 = this.z;\n    const e = m2.elements;\n    const w = \
1 / (e[3] * x2 + e[7] * y2 + e[11] * z2 + e[15]);\n    this.x = (e[0] * x2 + \
e[4] * y2 + e[8] * z2 + e[12]) * w;\n    this.y = (e[1] * x2 + e[5] * y2 + \
e[9] * z2 + e[13]) * w;\n    this.z = (e[2] * x2 + e[6] * y2 + e[10] * z2 + \
e[14]) * w;\n    return this;\n  }\n  applyQuaternion(q) {\n    const vx = \
this.x, vy = this.y, vz = this.z;\n    const qx = q.x, qy = q.y, qz = q.z, qw \
= q.w;\n    const tx = 2 * (qy * vz - qz * vy);\n    const ty = 2 * (qz * vx \
- qx * vz);\n    const tz = 2 * (qx * vy - qy * vx);\n    this.x = vx + qw * \
tx + qy * tz - qz * ty;\n    this.y = vy + qw * ty + qz * tx - qx * tz;\n    \
this.z = vz + qw * tz + qx * ty - qy * tx;\n    return this;\n  }\n  \
project(camera3) {\n    return \
this.applyMatrix4(camera3.matrixWorldInverse).applyMatrix4(camera3.projection\
Matrix);\n  }\n  unproject(camera3) {\n    return \
this.applyMatrix4(camera3.projectionMatrixInverse).applyMatrix4(camera3.matri\
xWorld);\n  }\n  transformDirection(m2) {\n    const x2 = this.x, y2 = \
this.y, z2 = this.z;\n    const e = m2.elements;\n    this.x = e[0] * x2 + \
e[4] * y2 + e[8] * z2;\n    this.y = e[1] * x2 + e[5] * y2 + e[9] * z2;\n    \
this.z = e[2] * x2 + e[6] * y2 + e[10] * z2;\n    return this.normalize();\n  \
}\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= \
v.z;\n    return this;\n  }\n  divideScalar(scalar) {\n    return \
this.multiplyScalar(1 / scalar);\n  }\n  min(v) {\n    this.x = \
Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = \
Math.min(this.z, v.z);\n    return this;\n  }\n  max(v) {\n    this.x = \
Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = \
Math.max(this.z, v.z);\n    return this;\n  }\n  clamp(min2, max2) {\n    \
this.x = Math.max(min2.x, Math.min(max2.x, this.x));\n    this.y = \
Math.max(min2.y, Math.min(max2.y, this.y));\n    this.z = Math.max(min2.z, \
Math.min(max2.z, this.z));\n    return this;\n  }\n  clampScalar(minVal, \
maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    \
this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = \
Math.max(minVal, Math.min(maxVal, this.z));\n    return this;\n  }\n  \
clampLength(min2, max2) {\n    const length2 = this.length();\n    return \
this.divideScalar(length2 || 1).multiplyScalar(Math.max(min2, Math.min(max2, \
length2)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = \
Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  \
}\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = \
Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  }\n  \
round() {\n    this.x = Math.round(this.x);\n    this.y = \
Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  \
}\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = \
Math.trunc(this.y);\n    this.z = Math.trunc(this.z);\n    return this;\n  \
}\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = \
-this.z;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y \
* v.y + this.z * v.z;\n  }\n  // TODO lengthSquared?\n  lengthSq() {\n    \
return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n  length() \
{\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * \
this.z);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + \
Math.abs(this.y) + Math.abs(this.z);\n  }\n  normalize() {\n    return \
this.divideScalar(this.length() || 1);\n  }\n  setLength(length2) {\n    \
return this.normalize().multiplyScalar(length2);\n  }\n  lerp(v, alpha) {\n   \
 this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n   \
 this.z += (v.z - this.z) * alpha;\n    return this;\n  }\n  lerpVectors(v1, \
v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + \
(v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    \
return this;\n  }\n  cross(v) {\n    return this.crossVectors(this, v);\n  \
}\n  crossVectors(a2, b) {\n    const ax = a2.x, ay = a2.y, az = a2.z;\n    \
const bx = b.x, by = b.y, bz = b.z;\n    this.x = ay * bz - az * by;\n    \
this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return \
this;\n  }\n  projectOnVector(v) {\n    const denominator = v.lengthSq();\n   \
 if (denominator === 0) return this.set(0, 0, 0);\n    const scalar = \
v.dot(this) / denominator;\n    return this.copy(v).multiplyScalar(scalar);\n \
 }\n  projectOnPlane(planeNormal) {\n    \
_vector$c2.copy(this).projectOnVector(planeNormal);\n    return \
this.sub(_vector$c2);\n  }\n  reflect(normal2) {\n    return \
this.sub(_vector$c2.copy(normal2).multiplyScalar(2 * this.dot(normal2)));\n  \
}\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * \
v.lengthSq());\n    if (denominator === 0) return Math.PI / 2;\n    const \
theta = this.dot(v) / denominator;\n    return Math.acos(clamp$1(theta, -1, \
1));\n  }\n  distanceTo(v) {\n    return \
Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    \
const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n    return dx \
* dx + dy * dy + dz * dz;\n  }\n  manhattanDistanceTo(v) {\n    return \
Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n  \
}\n  setFromSpherical(s) {\n    return this.setFromSphericalCoords(s.radius, \
s.phi, s.theta);\n  }\n  setFromSphericalCoords(radius, phi, theta) {\n    \
const sinPhiRadius = Math.sin(phi) * radius;\n    this.x = sinPhiRadius * \
Math.sin(theta);\n    this.y = Math.cos(phi) * radius;\n    this.z = \
sinPhiRadius * Math.cos(theta);\n    return this;\n  }\n  \
setFromCylindrical(c2) {\n    return this.setFromCylindricalCoords(c2.radius, \
c2.theta, c2.y);\n  }\n  setFromCylindricalCoords(radius, theta, y2) {\n    \
this.x = radius * Math.sin(theta);\n    this.y = y2;\n    this.z = radius * \
Math.cos(theta);\n    return this;\n  }\n  setFromMatrixPosition(m2) {\n    \
const e = m2.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z \
= e[14];\n    return this;\n  }\n  setFromMatrixScale(m2) {\n    const sx = \
this.setFromMatrixColumn(m2, 0).length();\n    const sy = \
this.setFromMatrixColumn(m2, 1).length();\n    const sz = \
this.setFromMatrixColumn(m2, 2).length();\n    this.x = sx;\n    this.y = \
sy;\n    this.z = sz;\n    return this;\n  }\n  setFromMatrixColumn(m2, \
index5) {\n    return this.fromArray(m2.elements, index5 * 4);\n  }\n  \
setFromMatrix3Column(m2, index5) {\n    return this.fromArray(m2.elements, \
index5 * 3);\n  }\n  setFromEuler(e) {\n    this.x = e._x;\n    this.y = \
e._y;\n    this.z = e._z;\n    return this;\n  }\n  setFromColor(c2) {\n    \
this.x = c2.r;\n    this.y = c2.g;\n    this.z = c2.b;\n    return this;\n  \
}\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === \
this.z;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n \
   this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return \
this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = \
this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n   \
 return array;\n  }\n  fromBufferAttribute(attribute2, index5) {\n    this.x \
= attribute2.getX(index5);\n    this.y = attribute2.getY(index5);\n    this.z \
= attribute2.getZ(index5);\n    return this;\n  }\n  random() {\n    this.x = \
Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    \
return this;\n  }\n  randomDirection() {\n    const theta = Math.random() * \
Math.PI * 2;\n    const u = Math.random() * 2 - 1;\n    const c2 = \
Math.sqrt(1 - u * u);\n    this.x = c2 * Math.cos(theta);\n    this.y = u;\n  \
  this.z = c2 * Math.sin(theta);\n    return this;\n  }\n  \
*[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield \
this.z;\n  }\n};\nvar _vector$c2 = /* @__PURE__ */ new Vector32();\nvar \
_quaternion$42 = /* @__PURE__ */ new Quaternion2();\nvar Box32 = class {\n  \
constructor(min2 = new Vector32(Infinity, Infinity, Infinity), max2 = new \
Vector32(-Infinity, -Infinity, -Infinity)) {\n    this.isBox3 = true;\n    \
this.min = min2;\n    this.max = max2;\n  }\n  set(min2, max2) {\n    \
this.min.copy(min2);\n    this.max.copy(max2);\n    return this;\n  }\n  \
setFromArray(array) {\n    this.makeEmpty();\n    for (let i = 0, il = \
array.length; i < il; i += 3) {\n      \
this.expandByPoint(_vector$b2.fromArray(array, i));\n    }\n    return \
this;\n  }\n  setFromBufferAttribute(attribute2) {\n    this.makeEmpty();\n   \
 for (let i = 0, il = attribute2.count; i < il; i++) {\n      \
this.expandByPoint(_vector$b2.fromBufferAttribute(attribute2, i));\n    }\n   \
 return this;\n  }\n  setFromPoints(points) {\n    this.makeEmpty();\n    for \
(let i = 0, il = points.length; i < il; i++) {\n      \
this.expandByPoint(points[i]);\n    }\n    return this;\n  }\n  \
setFromCenterAndSize(center, size) {\n    const halfSize = \
_vector$b2.copy(size).multiplyScalar(0.5);\n    \
this.min.copy(center).sub(halfSize);\n    \
this.max.copy(center).add(halfSize);\n    return this;\n  }\n  \
setFromObject(object, precise = false) {\n    this.makeEmpty();\n    return \
this.expandByObject(object, precise);\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n  copy(box) {\n    \
this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n \
 makeEmpty() {\n    this.min.x = this.min.y = this.min.z = Infinity;\n    \
this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  }\n  \
isEmpty() {\n    return this.max.x < this.min.x || this.max.y < this.min.y || \
this.max.z < this.min.z;\n  }\n  getCenter(target) {\n    return \
this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, \
this.max).multiplyScalar(0.5);\n  }\n  getSize(target) {\n    return \
this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, \
this.min);\n  }\n  expandByPoint(point) {\n    this.min.min(point);\n    \
this.max.max(point);\n    return this;\n  }\n  expandByVector(vector) {\n    \
this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n  \
expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    \
this.max.addScalar(scalar);\n    return this;\n  }\n  expandByObject(object, \
precise = false) {\n    object.updateWorldMatrix(false, false);\n    const \
geometry = object.geometry;\n    if (geometry !== void 0) {\n      const \
positionAttribute = geometry.getAttribute(\"position\");\n      if (precise \
=== true && positionAttribute !== void 0 && object.isInstancedMesh !== true) \
{\n        for (let i = 0, l = positionAttribute.count; i < l; i++) {\n       \
   if (object.isMesh === true) {\n            object.getVertexPosition(i, \
_vector$b2);\n          } else {\n            \
_vector$b2.fromBufferAttribute(positionAttribute, i);\n          }\n          \
_vector$b2.applyMatrix4(object.matrixWorld);\n          \
this.expandByPoint(_vector$b2);\n        }\n      } else {\n        if \
(object.boundingBox !== void 0) {\n          if (object.boundingBox === null) \
{\n            object.computeBoundingBox();\n          }\n          \
_box$42.copy(object.boundingBox);\n        } else {\n          if \
(geometry.boundingBox === null) {\n            \
geometry.computeBoundingBox();\n          }\n          \
_box$42.copy(geometry.boundingBox);\n        }\n        \
_box$42.applyMatrix4(object.matrixWorld);\n        this.union(_box$42);\n     \
 }\n    }\n    const children = object.children;\n    for (let i = 0, l = \
children.length; i < l; i++) {\n      this.expandByObject(children[i], \
precise);\n    }\n    return this;\n  }\n  containsPoint(point) {\n    return \
point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && \
point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n  \
}\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= \
this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && \
this.min.z <= box.min.z && box.max.z <= this.max.z;\n  }\n  \
getParameter(point, target) {\n    return target.set(\n      (point.x - \
this.min.x) / (this.max.x - this.min.x),\n      (point.y - this.min.y) / \
(this.max.y - this.min.y),\n      (point.z - this.min.z) / (this.max.z - \
this.min.z)\n    );\n  }\n  intersectsBox(box) {\n    return box.max.x >= \
this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y \
<= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n  }\n  \
intersectsSphere(sphere) {\n    this.clampPoint(sphere.center, _vector$b2);\n \
   return _vector$b2.distanceToSquared(sphere.center) <= sphere.radius * \
sphere.radius;\n  }\n  intersectsPlane(plane) {\n    let min2, max2;\n    if \
(plane.normal.x > 0) {\n      min2 = plane.normal.x * this.min.x;\n      max2 \
= plane.normal.x * this.max.x;\n    } else {\n      min2 = plane.normal.x * \
this.max.x;\n      max2 = plane.normal.x * this.min.x;\n    }\n    if \
(plane.normal.y > 0) {\n      min2 += plane.normal.y * this.min.y;\n      \
max2 += plane.normal.y * this.max.y;\n    } else {\n      min2 += \
plane.normal.y * this.max.y;\n      max2 += plane.normal.y * this.min.y;\n    \
}\n    if (plane.normal.z > 0) {\n      min2 += plane.normal.z * \
this.min.z;\n      max2 += plane.normal.z * this.max.z;\n    } else {\n      \
min2 += plane.normal.z * this.max.z;\n      max2 += plane.normal.z * \
this.min.z;\n    }\n    return min2 <= -plane.constant && max2 >= \
-plane.constant;\n  }\n  intersectsTriangle(triangle) {\n    if \
(this.isEmpty()) {\n      return false;\n    }\n    \
this.getCenter(_center2);\n    _extents2.subVectors(this.max, _center2);\n    \
_v0$22.subVectors(triangle.a, _center2);\n    _v1$72.subVectors(triangle.b, \
_center2);\n    _v2$42.subVectors(triangle.c, _center2);\n    \
_f02.subVectors(_v1$72, _v0$22);\n    _f12.subVectors(_v2$42, _v1$72);\n    \
_f22.subVectors(_v0$22, _v2$42);\n    let axes = [\n      0,\n      \
-_f02.z,\n      _f02.y,\n      0,\n      -_f12.z,\n      _f12.y,\n      0,\n  \
    -_f22.z,\n      _f22.y,\n      _f02.z,\n      0,\n      -_f02.x,\n      \
_f12.z,\n      0,\n      -_f12.x,\n      _f22.z,\n      0,\n      -_f22.x,\n  \
    -_f02.y,\n      _f02.x,\n      0,\n      -_f12.y,\n      _f12.x,\n      \
0,\n      -_f22.y,\n      _f22.x,\n      0\n    ];\n    if \
(!satForAxes2(axes, _v0$22, _v1$72, _v2$42, _extents2)) {\n      return \
false;\n    }\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    if \
(!satForAxes2(axes, _v0$22, _v1$72, _v2$42, _extents2)) {\n      return \
false;\n    }\n    _triangleNormal2.crossVectors(_f02, _f12);\n    axes = \
[_triangleNormal2.x, _triangleNormal2.y, _triangleNormal2.z];\n    return \
satForAxes2(axes, _v0$22, _v1$72, _v2$42, _extents2);\n  }\n  \
clampPoint(point, target) {\n    return target.copy(point).clamp(this.min, \
this.max);\n  }\n  distanceToPoint(point) {\n    return \
this.clampPoint(point, _vector$b2).distanceTo(point);\n  }\n  \
getBoundingSphere(target) {\n    if (this.isEmpty()) {\n      \
target.makeEmpty();\n    } else {\n      this.getCenter(target.center);\n     \
 target.radius = this.getSize(_vector$b2).length() * 0.5;\n    }\n    return \
target;\n  }\n  intersect(box) {\n    this.min.max(box.min);\n    \
this.max.min(box.max);\n    if (this.isEmpty()) this.makeEmpty();\n    return \
this;\n  }\n  union(box) {\n    this.min.min(box.min);\n    \
this.max.max(box.max);\n    return this;\n  }\n  applyMatrix4(matrix) {\n    \
if (this.isEmpty()) return this;\n    _points2[0].set(this.min.x, this.min.y, \
this.min.z).applyMatrix4(matrix);\n    _points2[1].set(this.min.x, \
this.min.y, this.max.z).applyMatrix4(matrix);\n    \
_points2[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n   \
 _points2[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n  \
  _points2[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n \
   _points2[5].set(this.max.x, this.min.y, \
this.max.z).applyMatrix4(matrix);\n    _points2[6].set(this.max.x, \
this.max.y, this.min.z).applyMatrix4(matrix);\n    \
_points2[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n   \
 this.setFromPoints(_points2);\n    return this;\n  }\n  translate(offset) \
{\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  \
}\n  equals(box) {\n    return box.min.equals(this.min) && \
box.max.equals(this.max);\n  }\n};\nvar _points2 = [\n  /* @__PURE__ */ new \
Vector32(),\n  /* @__PURE__ */ new Vector32(),\n  /* @__PURE__ */ new \
Vector32(),\n  /* @__PURE__ */ new Vector32(),\n  /* @__PURE__ */ new \
Vector32(),\n  /* @__PURE__ */ new Vector32(),\n  /* @__PURE__ */ new \
Vector32(),\n  /* @__PURE__ */ new Vector32()\n];\nvar _vector$b2 = /* \
@__PURE__ */ new Vector32();\nvar _box$42 = /* @__PURE__ */ new Box32();\nvar \
_v0$22 = /* @__PURE__ */ new Vector32();\nvar _v1$72 = /* @__PURE__ */ new \
Vector32();\nvar _v2$42 = /* @__PURE__ */ new Vector32();\nvar _f02 = /* \
@__PURE__ */ new Vector32();\nvar _f12 = /* @__PURE__ */ new Vector32();\nvar \
_f22 = /* @__PURE__ */ new Vector32();\nvar _center2 = /* @__PURE__ */ new \
Vector32();\nvar _extents2 = /* @__PURE__ */ new Vector32();\nvar \
_triangleNormal2 = /* @__PURE__ */ new Vector32();\nvar _testAxis2 = /* \
@__PURE__ */ new Vector32();\nfunction satForAxes2(axes, v0, v1, v2, extents) \
{\n  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n    \
_testAxis2.fromArray(axes, i);\n    const r = extents.x * \
Math.abs(_testAxis2.x) + extents.y * Math.abs(_testAxis2.y) + extents.z * \
Math.abs(_testAxis2.z);\n    const p0 = v0.dot(_testAxis2);\n    const p1 = \
v1.dot(_testAxis2);\n    const p2 = v2.dot(_testAxis2);\n    if \
(Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      return \
false;\n    }\n  }\n  return true;\n}\nvar _box$32 = /* @__PURE__ */ new \
Box32();\nvar _v1$62 = /* @__PURE__ */ new Vector32();\nvar _v2$32 = /* \
@__PURE__ */ new Vector32();\nvar Sphere2 = class {\n  constructor(center = \
new Vector32(), radius = -1) {\n    this.isSphere = true;\n    this.center = \
center;\n    this.radius = radius;\n  }\n  set(center, radius) {\n    \
this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n \
 setFromPoints(points, optionalCenter) {\n    const center = this.center;\n   \
 if (optionalCenter !== void 0) {\n      center.copy(optionalCenter);\n    } \
else {\n      _box$32.setFromPoints(points).getCenter(center);\n    }\n    \
let maxRadiusSq = 0;\n    for (let i = 0, il = points.length; i < il; i++) \
{\n      maxRadiusSq = Math.max(maxRadiusSq, \
center.distanceToSquared(points[i]));\n    }\n    this.radius = \
Math.sqrt(maxRadiusSq);\n    return this;\n  }\n  copy(sphere) {\n    \
this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    \
return this;\n  }\n  isEmpty() {\n    return this.radius < 0;\n  }\n  \
makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n    \
return this;\n  }\n  containsPoint(point) {\n    return \
point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n  \
distanceToPoint(point) {\n    return point.distanceTo(this.center) - \
this.radius;\n  }\n  intersectsSphere(sphere) {\n    const radiusSum = \
this.radius + sphere.radius;\n    return \
sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n \
 intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n  \
intersectsPlane(plane) {\n    return \
Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n  \
clampPoint(point, target) {\n    const deltaLengthSq = \
this.center.distanceToSquared(point);\n    target.copy(point);\n    if \
(deltaLengthSq > this.radius * this.radius) {\n      \
target.sub(this.center).normalize();\n      \
target.multiplyScalar(this.radius).add(this.center);\n    }\n    return \
target;\n  }\n  getBoundingBox(target) {\n    if (this.isEmpty()) {\n      \
target.makeEmpty();\n      return target;\n    }\n    target.set(this.center, \
this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  \
}\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    \
this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  \
}\n  translate(offset) {\n    this.center.add(offset);\n    return this;\n  \
}\n  expandByPoint(point) {\n    if (this.isEmpty()) {\n      \
this.center.copy(point);\n      this.radius = 0;\n      return this;\n    }\n \
   _v1$62.subVectors(point, this.center);\n    const lengthSq2 = \
_v1$62.lengthSq();\n    if (lengthSq2 > this.radius * this.radius) {\n      \
const length2 = Math.sqrt(lengthSq2);\n      const delta = (length2 - \
this.radius) * 0.5;\n      this.center.addScaledVector(_v1$62, delta / \
length2);\n      this.radius += delta;\n    }\n    return this;\n  }\n  \
union(sphere) {\n    if (sphere.isEmpty()) {\n      return this;\n    }\n    \
if (this.isEmpty()) {\n      this.copy(sphere);\n      return this;\n    }\n  \
  if (this.center.equals(sphere.center) === true) {\n      this.radius = \
Math.max(this.radius, sphere.radius);\n    } else {\n      \
_v2$32.subVectors(sphere.center, this.center).setLength(sphere.radius);\n     \
 this.expandByPoint(_v1$62.copy(sphere.center).add(_v2$32));\n      \
this.expandByPoint(_v1$62.copy(sphere.center).sub(_v2$32));\n    }\n    \
return this;\n  }\n  equals(sphere) {\n    return \
sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n  \
clone() {\n    return new this.constructor().copy(this);\n  }\n};\nvar \
_vector$a2 = /* @__PURE__ */ new Vector32();\nvar _segCenter2 = /* @__PURE__ \
*/ new Vector32();\nvar _segDir2 = /* @__PURE__ */ new Vector32();\nvar \
_diff3 = /* @__PURE__ */ new Vector32();\nvar _edge12 = /* @__PURE__ */ new \
Vector32();\nvar _edge22 = /* @__PURE__ */ new Vector32();\nvar _normal$2 = \
/* @__PURE__ */ new Vector32();\nvar Ray2 = class {\n  constructor(origin = \
new Vector32(), direction2 = new Vector32(0, 0, -1)) {\n    this.origin = \
origin;\n    this.direction = direction2;\n  }\n  set(origin, direction2) {\n \
   this.origin.copy(origin);\n    this.direction.copy(direction2);\n    \
return this;\n  }\n  copy(ray) {\n    this.origin.copy(ray.origin);\n    \
this.direction.copy(ray.direction);\n    return this;\n  }\n  at(t, target) \
{\n    return target.copy(this.origin).addScaledVector(this.direction, t);\n  \
}\n  lookAt(v) {\n    this.direction.copy(v).sub(this.origin).normalize();\n  \
  return this;\n  }\n  recast(t) {\n    this.origin.copy(this.at(t, \
_vector$a2));\n    return this;\n  }\n  closestPointToPoint(point, target) \
{\n    target.subVectors(point, this.origin);\n    const directionDistance = \
target.dot(this.direction);\n    if (directionDistance < 0) {\n      return \
target.copy(this.origin);\n    }\n    return \
target.copy(this.origin).addScaledVector(this.direction, \
directionDistance);\n  }\n  distanceToPoint(point) {\n    return \
Math.sqrt(this.distanceSqToPoint(point));\n  }\n  distanceSqToPoint(point) \
{\n    const directionDistance = _vector$a2.subVectors(point, \
this.origin).dot(this.direction);\n    if (directionDistance < 0) {\n      \
return this.origin.distanceToSquared(point);\n    }\n    \
_vector$a2.copy(this.origin).addScaledVector(this.direction, \
directionDistance);\n    return _vector$a2.distanceToSquared(point);\n  }\n  \
distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n   \
 _segCenter2.copy(v0).add(v1).multiplyScalar(0.5);\n    \
_segDir2.copy(v1).sub(v0).normalize();\n    \
_diff3.copy(this.origin).sub(_segCenter2);\n    const segExtent = \
v0.distanceTo(v1) * 0.5;\n    const a01 = -this.direction.dot(_segDir2);\n    \
const b0 = _diff3.dot(this.direction);\n    const b1 = \
-_diff3.dot(_segDir2);\n    const c2 = _diff3.lengthSq();\n    const det = \
Math.abs(1 - a01 * a01);\n    let s0, s1, sqrDist, extDet;\n    if (det > 0) \
{\n      s0 = a01 * b1 - b0;\n      s1 = a01 * b0 - b1;\n      extDet = \
segExtent * det;\n      if (s0 >= 0) {\n        if (s1 >= -extDet) {\n        \
  if (s1 <= extDet) {\n            const invDet = 1 / det;\n            s0 *= \
invDet;\n            s1 *= invDet;\n            sqrDist = s0 * (s0 + a01 * s1 \
+ 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;\n          } else {\n         \
   s1 = segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n         \
   sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;\n          }\n        } else \
{\n          s1 = -segExtent;\n          s0 = Math.max(0, -(a01 * s1 + \
b0));\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;\n        }\n   \
   } else {\n        if (s1 <= -extDet) {\n          s0 = Math.max(0, -(-a01 \
* segExtent + b0));\n          s1 = s0 > 0 ? -segExtent : \
Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 \
+ s1 * (s1 + 2 * b1) + c2;\n        } else if (s1 <= extDet) {\n          s0 \
= 0;\n          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n        \
  sqrDist = s1 * (s1 + 2 * b1) + c2;\n        } else {\n          s0 = \
Math.max(0, -(a01 * segExtent + b0));\n          s1 = s0 > 0 ? segExtent : \
Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 \
+ s1 * (s1 + 2 * b1) + c2;\n        }\n      }\n    } else {\n      s1 = a01 \
> 0 ? -segExtent : segExtent;\n      s0 = Math.max(0, -(a01 * s1 + b0));\n    \
  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;\n    }\n    if \
(optionalPointOnRay) {\n      \
optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n   \
 }\n    if (optionalPointOnSegment) {\n      \
optionalPointOnSegment.copy(_segCenter2).addScaledVector(_segDir2, s1);\n    \
}\n    return sqrDist;\n  }\n  intersectSphere(sphere, target) {\n    \
_vector$a2.subVectors(sphere.center, this.origin);\n    const tca = \
_vector$a2.dot(this.direction);\n    const d2 = _vector$a2.dot(_vector$a2) - \
tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > \
radius2) return null;\n    const thc = Math.sqrt(radius2 - d2);\n    const t0 \
= tca - thc;\n    const t1 = tca + thc;\n    if (t1 < 0) return null;\n    if \
(t0 < 0) return this.at(t1, target);\n    return this.at(t0, target);\n  }\n  \
intersectsSphere(sphere) {\n    return this.distanceSqToPoint(sphere.center) \
<= sphere.radius * sphere.radius;\n  }\n  distanceToPlane(plane) {\n    const \
denominator = plane.normal.dot(this.direction);\n    if (denominator === 0) \
{\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n \
     }\n      return null;\n    }\n    const t = \
-(this.origin.dot(plane.normal) + plane.constant) / denominator;\n    return \
t >= 0 ? t : null;\n  }\n  intersectPlane(plane, target) {\n    const t = \
this.distanceToPlane(plane);\n    if (t === null) {\n      return null;\n    \
}\n    return this.at(t, target);\n  }\n  intersectsPlane(plane) {\n    const \
distToPoint = plane.distanceToPoint(this.origin);\n    if (distToPoint === 0) \
{\n      return true;\n    }\n    const denominator = \
plane.normal.dot(this.direction);\n    if (denominator * distToPoint < 0) {\n \
     return true;\n    }\n    return false;\n  }\n  intersectBox(box, target) \
{\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / \
this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / \
this.direction.z;\n    const origin = this.origin;\n    if (invdirx >= 0) {\n \
     tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - \
origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * \
invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n    if \
(invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      \
tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = \
(box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * \
invdiry;\n    }\n    if (tmin > tymax || tymin > tmax) return null;\n    if \
(tymin > tmin || isNaN(tmin)) tmin = tymin;\n    if (tymax < tmax || \
isNaN(tmax)) tmax = tymax;\n    if (invdirz >= 0) {\n      tzmin = (box.min.z \
- origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    \
} else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = \
(box.min.z - origin.z) * invdirz;\n    }\n    if (tmin > tzmax || tzmin > \
tmax) return null;\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n    \
if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n    if (tmax < 0) return \
null;\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n  \
intersectsBox(box) {\n    return this.intersectBox(box, _vector$a2) !== \
null;\n  }\n  intersectTriangle(a2, b, c2, backfaceCulling, target) {\n    \
_edge12.subVectors(b, a2);\n    _edge22.subVectors(c2, a2);\n    \
_normal$2.crossVectors(_edge12, _edge22);\n    let DdN = \
this.direction.dot(_normal$2);\n    let sign2;\n    if (DdN > 0) {\n      if \
(backfaceCulling) return null;\n      sign2 = 1;\n    } else if (DdN < 0) {\n \
     sign2 = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    \
}\n    _diff3.subVectors(this.origin, a2);\n    const DdQxE2 = sign2 * \
this.direction.dot(_edge22.crossVectors(_diff3, _edge22));\n    if (DdQxE2 < \
0) {\n      return null;\n    }\n    const DdE1xQ = sign2 * \
this.direction.dot(_edge12.cross(_diff3));\n    if (DdE1xQ < 0) {\n      \
return null;\n    }\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n   \
 }\n    const QdN = -sign2 * _diff3.dot(_normal$2);\n    if (QdN < 0) {\n     \
 return null;\n    }\n    return this.at(QdN / DdN, target);\n  }\n  \
applyMatrix4(matrix4) {\n    this.origin.applyMatrix4(matrix4);\n    \
this.direction.transformDirection(matrix4);\n    return this;\n  }\n  \
equals(ray) {\n    return ray.origin.equals(this.origin) && \
ray.direction.equals(this.direction);\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n};\nvar Matrix42 = class _Matrix4 {\n  \
constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, \
n42, n43, n44) {\n    _Matrix4.prototype.isMatrix4 = true;\n    this.elements \
= [\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n   \
   0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n \
     1\n    ];\n    if (n11 !== void 0) {\n      this.set(n11, n12, n13, n14, \
n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n    }\n  }\n  \
set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, \
n43, n44) {\n    const te = this.elements;\n    te[0] = n11;\n    te[4] = \
n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = \
n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = \
n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = \
n42;\n    te[11] = n43;\n    te[15] = n44;\n    return this;\n  }\n  \
identity() {\n    this.set(\n      1,\n      0,\n      0,\n      0,\n      \
0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n    \
  0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  clone() \
{\n    return new _Matrix4().fromArray(this.elements);\n  }\n  copy(m2) {\n   \
 const te = this.elements;\n    const me = m2.elements;\n    te[0] = me[0];\n \
   te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = \
me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] \
= me[8];\n    te[9] = me[9];\n    te[10] = me[10];\n    te[11] = me[11];\n    \
te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    te[15] = \
me[15];\n    return this;\n  }\n  copyPosition(m2) {\n    const te = \
this.elements, me = m2.elements;\n    te[12] = me[12];\n    te[13] = \
me[13];\n    te[14] = me[14];\n    return this;\n  }\n  setFromMatrix3(m2) \
{\n    const me = m2.elements;\n    this.set(\n      me[0],\n      me[3],\n   \
   me[6],\n      0,\n      me[1],\n      me[4],\n      me[7],\n      0,\n     \
 me[2],\n      me[5],\n      me[8],\n      0,\n      0,\n      0,\n      0,\n \
     1\n    );\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) \
{\n    xAxis.setFromMatrixColumn(this, 0);\n    \
yAxis.setFromMatrixColumn(this, 1);\n    zAxis.setFromMatrixColumn(this, \
2);\n    return this;\n  }\n  makeBasis(xAxis, yAxis, zAxis) {\n    \
this.set(\n      xAxis.x,\n      yAxis.x,\n      zAxis.x,\n      0,\n      \
xAxis.y,\n      yAxis.y,\n      zAxis.y,\n      0,\n      xAxis.z,\n      \
yAxis.z,\n      zAxis.z,\n      0,\n      0,\n      0,\n      0,\n      1\n   \
 );\n    return this;\n  }\n  extractRotation(m2) {\n    const te = \
this.elements;\n    const me = m2.elements;\n    const scaleX = 1 / \
_v1$52.setFromMatrixColumn(m2, 0).length();\n    const scaleY = 1 / \
_v1$52.setFromMatrixColumn(m2, 1).length();\n    const scaleZ = 1 / \
_v1$52.setFromMatrixColumn(m2, 2).length();\n    te[0] = me[0] * scaleX;\n    \
te[1] = me[1] * scaleX;\n    te[2] = me[2] * scaleX;\n    te[3] = 0;\n    \
te[4] = me[4] * scaleY;\n    te[5] = me[5] * scaleY;\n    te[6] = me[6] * \
scaleY;\n    te[7] = 0;\n    te[8] = me[8] * scaleZ;\n    te[9] = me[9] * \
scaleZ;\n    te[10] = me[10] * scaleZ;\n    te[11] = 0;\n    te[12] = 0;\n    \
te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  \
makeRotationFromEuler(euler) {\n    const te = this.elements;\n    const x2 = \
euler.x, y2 = euler.y, z2 = euler.z;\n    const a2 = Math.cos(x2), b = \
Math.sin(x2);\n    const c2 = Math.cos(y2), d = Math.sin(y2);\n    const e = \
Math.cos(z2), f = Math.sin(z2);\n    if (euler.order === \"XYZ\") {\n      \
const ae = a2 * e, af = a2 * f, be = b * e, bf = b * f;\n      te[0] = c2 * \
e;\n      te[4] = -c2 * f;\n      te[8] = d;\n      te[1] = af + be * d;\n    \
  te[5] = ae - bf * d;\n      te[9] = -b * c2;\n      te[2] = bf - ae * d;\n  \
    te[6] = be + af * d;\n      te[10] = a2 * c2;\n    } else if (euler.order \
=== \"YXZ\") {\n      const ce = c2 * e, cf = c2 * f, de = d * e, df = d * \
f;\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a2 \
* d;\n      te[1] = a2 * f;\n      te[5] = a2 * e;\n      te[9] = -b;\n      \
te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a2 * c2;\n   \
 } else if (euler.order === \"ZXY\") {\n      const ce = c2 * e, cf = c2 * f, \
de = d * e, df = d * f;\n      te[0] = ce - df * b;\n      te[4] = -a2 * f;\n \
     te[8] = de + cf * b;\n      te[1] = cf + de * b;\n      te[5] = a2 * \
e;\n      te[9] = df - ce * b;\n      te[2] = -a2 * d;\n      te[6] = b;\n    \
  te[10] = a2 * c2;\n    } else if (euler.order === \"ZYX\") {\n      const \
ae = a2 * e, af = a2 * f, be = b * e, bf = b * f;\n      te[0] = c2 * e;\n    \
  te[4] = be * d - af;\n      te[8] = ae * d + bf;\n      te[1] = c2 * f;\n   \
   te[5] = bf * d + ae;\n      te[9] = af * d - be;\n      te[2] = -d;\n      \
te[6] = b * c2;\n      te[10] = a2 * c2;\n    } else if (euler.order === \
\"YZX\") {\n      const ac = a2 * c2, ad = a2 * d, bc = b * c2, bd = b * d;\n \
     te[0] = c2 * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + \
ad;\n      te[1] = f;\n      te[5] = a2 * e;\n      te[9] = -b * e;\n      \
te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    \
} else if (euler.order === \"XZY\") {\n      const ac = a2 * c2, ad = a2 * d, \
bc = b * c2, bd = b * d;\n      te[0] = c2 * e;\n      te[4] = -f;\n      \
te[8] = d * e;\n      te[1] = ac * f + bd;\n      te[5] = a2 * e;\n      \
te[9] = ad * f - bc;\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      \
te[10] = bd * f + ac;\n    }\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = \
0;\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    \
return this;\n  }\n  makeRotationFromQuaternion(q) {\n    return \
this.compose(_zero2, q, _one2);\n  }\n  lookAt(eye, target, up) {\n    const \
te = this.elements;\n    _z2.subVectors(eye, target);\n    if (_z2.lengthSq() \
=== 0) {\n      _z2.z = 1;\n    }\n    _z2.normalize();\n    \
_x2.crossVectors(up, _z2);\n    if (_x2.lengthSq() === 0) {\n      if \
(Math.abs(up.z) === 1) {\n        _z2.x += 1e-4;\n      } else {\n        \
_z2.z += 1e-4;\n      }\n      _z2.normalize();\n      _x2.crossVectors(up, \
_z2);\n    }\n    _x2.normalize();\n    _y2.crossVectors(_z2, _x2);\n    \
te[0] = _x2.x;\n    te[4] = _y2.x;\n    te[8] = _z2.x;\n    te[1] = _x2.y;\n  \
  te[5] = _y2.y;\n    te[9] = _z2.y;\n    te[2] = _x2.z;\n    te[6] = \
_y2.z;\n    te[10] = _z2.z;\n    return this;\n  }\n  multiply(m2) {\n    \
return this.multiplyMatrices(this, m2);\n  }\n  premultiply(m2) {\n    return \
this.multiplyMatrices(m2, this);\n  }\n  multiplyMatrices(a2, b) {\n    const \
ae = a2.elements;\n    const be = b.elements;\n    const te = \
this.elements;\n    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = \
ae[12];\n    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n    \
const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n    const a41 = \
ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n    const b11 = be[0], b12 = \
be[4], b13 = be[8], b14 = be[12];\n    const b21 = be[1], b22 = be[5], b23 = \
be[9], b24 = be[13];\n    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = \
be[14];\n    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n    \
te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 \
+ a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 \
* b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * \
b44;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = \
a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * \
b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 \
+ a24 * b44;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    \
te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * \
b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 \
+ a33 * b34 + a34 * b44;\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 \
* b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    \
te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * \
b14 + a42 * b24 + a43 * b34 + a44 * b44;\n    return this;\n  }\n  \
multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    \
te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= \
s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    \
te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] \
*= s;\n    te[15] *= s;\n    return this;\n  }\n  determinant() {\n    const \
te = this.elements;\n    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = \
te[12];\n    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n    \
const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n    const n41 = \
te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n    return n41 * (+n14 * n23 \
* n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 \
- n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * \
n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * \
n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * \
n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * \
n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n  }\n  \
transpose() {\n    const te = this.elements;\n    let tmp2;\n    tmp2 = \
te[1];\n    te[1] = te[4];\n    te[4] = tmp2;\n    tmp2 = te[2];\n    te[2] = \
te[8];\n    te[8] = tmp2;\n    tmp2 = te[6];\n    te[6] = te[9];\n    te[9] = \
tmp2;\n    tmp2 = te[3];\n    te[3] = te[12];\n    te[12] = tmp2;\n    tmp2 = \
te[7];\n    te[7] = te[13];\n    te[13] = tmp2;\n    tmp2 = te[11];\n    \
te[11] = te[14];\n    te[14] = tmp2;\n    return this;\n  }\n  \
setPosition(x2, y2, z2) {\n    const te = this.elements;\n    if \
(x2.isVector3) {\n      te[12] = x2.x;\n      te[13] = x2.y;\n      te[14] = \
x2.z;\n    } else {\n      te[12] = x2;\n      te[13] = y2;\n      te[14] = \
z2;\n    }\n    return this;\n  }\n  invert() {\n    const te = \
this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = \
te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = \
te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], \
t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - \
n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - \
n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = \
n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * \
n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * \
n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n    const \
det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n    if (det === 0) \
return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const \
detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n24 * n33 * n41 - \
n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * \
n33 * n44) * detInv;\n    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * \
n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n  \
  te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * \
n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n    te[4] = t12 * \
detInv;\n    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - \
n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n    te[6] = \
(n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 \
* n31 * n44 - n11 * n32 * n44) * detInv;\n    te[7] = (n12 * n33 * n41 - n13 \
* n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 \
* n43) * detInv;\n    te[8] = t13 * detInv;\n    te[9] = (n14 * n23 * n41 - \
n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * \
n23 * n44) * detInv;\n    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * \
n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n  \
  te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * \
n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n    te[12] = t14 * \
detInv;\n    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - \
n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n    te[14] = \
(n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 \
* n21 * n34 - n11 * n22 * n34) * detInv;\n    te[15] = (n12 * n23 * n31 - n13 \
* n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 \
* n33) * detInv;\n    return this;\n  }\n  scale(v) {\n    const te = \
this.elements;\n    const x2 = v.x, y2 = v.y, z2 = v.z;\n    te[0] *= x2;\n   \
 te[4] *= y2;\n    te[8] *= z2;\n    te[1] *= x2;\n    te[5] *= y2;\n    \
te[9] *= z2;\n    te[2] *= x2;\n    te[6] *= y2;\n    te[10] *= z2;\n    \
te[3] *= x2;\n    te[7] *= y2;\n    te[11] *= z2;\n    return this;\n  }\n  \
getMaxScaleOnAxis() {\n    const te = this.elements;\n    const scaleXSq = \
te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq = te[4] * \
te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq = te[8] * te[8] + \
te[9] * te[9] + te[10] * te[10];\n    return Math.sqrt(Math.max(scaleXSq, \
scaleYSq, scaleZSq));\n  }\n  makeTranslation(x2, y2, z2) {\n    if \
(x2.isVector3) {\n      this.set(\n        1,\n        0,\n        0,\n       \
 x2.x,\n        0,\n        1,\n        0,\n        x2.y,\n        0,\n       \
 0,\n        1,\n        x2.z,\n        0,\n        0,\n        0,\n        \
1\n      );\n    } else {\n      this.set(\n        1,\n        0,\n        \
0,\n        x2,\n        0,\n        1,\n        0,\n        y2,\n        \
0,\n        0,\n        1,\n        z2,\n        0,\n        0,\n        0,\n \
       1\n      );\n    }\n    return this;\n  }\n  makeRotationX(theta) {\n  \
  const c2 = Math.cos(theta), s = Math.sin(theta);\n    this.set(\n      1,\n \
     0,\n      0,\n      0,\n      0,\n      c2,\n      -s,\n      0,\n      \
0,\n      s,\n      c2,\n      0,\n      0,\n      0,\n      0,\n      1\n    \
);\n    return this;\n  }\n  makeRotationY(theta) {\n    const c2 = \
Math.cos(theta), s = Math.sin(theta);\n    this.set(\n      c2,\n      0,\n   \
   s,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -s,\n      \
0,\n      c2,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    \
return this;\n  }\n  makeRotationZ(theta) {\n    const c2 = Math.cos(theta), \
s = Math.sin(theta);\n    this.set(\n      c2,\n      -s,\n      0,\n      \
0,\n      s,\n      c2,\n      0,\n      0,\n      0,\n      0,\n      1,\n   \
   0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n \
 makeRotationAxis(axis, angle) {\n    const c2 = Math.cos(angle);\n    const \
s = Math.sin(angle);\n    const t = 1 - c2;\n    const x2 = axis.x, y2 = \
axis.y, z2 = axis.z;\n    const tx = t * x2, ty = t * y2;\n    this.set(\n    \
  tx * x2 + c2,\n      tx * y2 - s * z2,\n      tx * z2 + s * y2,\n      0,\n \
     tx * y2 + s * z2,\n      ty * y2 + c2,\n      ty * z2 - s * x2,\n      \
0,\n      tx * z2 - s * y2,\n      ty * z2 + s * x2,\n      t * z2 * z2 + \
c2,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return \
this;\n  }\n  makeScale(x2, y2, z2) {\n    this.set(\n      x2,\n      0,\n   \
   0,\n      0,\n      0,\n      y2,\n      0,\n      0,\n      0,\n      \
0,\n      z2,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    \
return this;\n  }\n  makeShear(xy, xz, yx, yz, zx, zy) {\n    this.set(\n     \
 1,\n      yx,\n      zx,\n      0,\n      xy,\n      1,\n      zy,\n      \
0,\n      xz,\n      yz,\n      1,\n      0,\n      0,\n      0,\n      0,\n  \
    1\n    );\n    return this;\n  }\n  compose(position, quaternion, scale) \
{\n    const te = this.elements;\n    const x2 = quaternion._x, y2 = \
quaternion._y, z2 = quaternion._z, w = quaternion._w;\n    const x22 = x2 + \
x2, y22 = y2 + y2, z22 = z2 + z2;\n    const xx = x2 * x22, xy = x2 * y22, xz \
= x2 * z22;\n    const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;\n    \
const wx = w * x22, wy = w * y22, wz = w * z22;\n    const sx = scale.x, sy = \
scale.y, sz = scale.z;\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + \
wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) \
* sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    \
te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    \
te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = position.x;\n   \
 te[13] = position.y;\n    te[14] = position.z;\n    te[15] = 1;\n    return \
this;\n  }\n  decompose(position, quaternion, scale) {\n    const te = \
this.elements;\n    let sx = _v1$52.set(te[0], te[1], te[2]).length();\n    \
const sy = _v1$52.set(te[4], te[5], te[6]).length();\n    const sz = \
_v1$52.set(te[8], te[9], te[10]).length();\n    const det = \
this.determinant();\n    if (det < 0) sx = -sx;\n    position.x = te[12];\n   \
 position.y = te[13];\n    position.z = te[14];\n    _m1$32.copy(this);\n    \
const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n \
   _m1$32.elements[0] *= invSX;\n    _m1$32.elements[1] *= invSX;\n    \
_m1$32.elements[2] *= invSX;\n    _m1$32.elements[4] *= invSY;\n    \
_m1$32.elements[5] *= invSY;\n    _m1$32.elements[6] *= invSY;\n    \
_m1$32.elements[8] *= invSZ;\n    _m1$32.elements[9] *= invSZ;\n    \
_m1$32.elements[10] *= invSZ;\n    \
quaternion.setFromRotationMatrix(_m1$32);\n    scale.x = sx;\n    scale.y = \
sy;\n    scale.z = sz;\n    return this;\n  }\n  makePerspective(left, right, \
top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem2) {\n    \
const te = this.elements;\n    const x2 = 2 * near / (right - left);\n    \
const y2 = 2 * near / (top - bottom);\n    const a2 = (right + left) / (right \
- left);\n    const b = (top + bottom) / (top - bottom);\n    let c2, d;\n    \
if (coordinateSystem === WebGLCoordinateSystem2) {\n      c2 = -(far + near) \
/ (far - near);\n      d = -2 * far * near / (far - near);\n    } else if \
(coordinateSystem === WebGPUCoordinateSystem2) {\n      c2 = -far / (far - \
near);\n      d = -far * near / (far - near);\n    } else {\n      throw new \
Error(\"THREE.Matrix4.makePerspective(): Invalid coordinate system: \" + \
coordinateSystem);\n    }\n    te[0] = x2;\n    te[4] = 0;\n    te[8] = a2;\n \
   te[12] = 0;\n    te[1] = 0;\n    te[5] = y2;\n    te[9] = b;\n    te[13] = \
0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c2;\n    te[14] = d;\n    \
te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n    return \
this;\n  }\n  makeOrthographic(left, right, top, bottom, near, far, \
coordinateSystem = WebGLCoordinateSystem2) {\n    const te = this.elements;\n \
   const w = 1 / (right - left);\n    const h = 1 / (top - bottom);\n    \
const p = 1 / (far - near);\n    const x2 = (right + left) * w;\n    const y2 \
= (top + bottom) * h;\n    let z2, zInv;\n    if (coordinateSystem === \
WebGLCoordinateSystem2) {\n      z2 = (far + near) * p;\n      zInv = -2 * \
p;\n    } else if (coordinateSystem === WebGPUCoordinateSystem2) {\n      z2 \
= near * p;\n      zInv = -1 * p;\n    } else {\n      throw new \
Error(\"THREE.Matrix4.makeOrthographic(): Invalid coordinate system: \" + \
coordinateSystem);\n    }\n    te[0] = 2 * w;\n    te[4] = 0;\n    te[8] = \
0;\n    te[12] = -x2;\n    te[1] = 0;\n    te[5] = 2 * h;\n    te[9] = 0;\n   \
 te[13] = -y2;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = zInv;\n    \
te[14] = -z2;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = \
1;\n    return this;\n  }\n  equals(matrix) {\n    const te = \
this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 16; \
i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return true;\n  \
}\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 16; i++) {\n     \
 this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  \
toArray(array = [], offset = 0) {\n    const te = this.elements;\n    \
array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] \
= te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    \
array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset \
+ 7] = te[7];\n    array[offset + 8] = te[8];\n    array[offset + 9] = \
te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n  \
  array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    \
array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n    return \
array;\n  }\n};\nvar _v1$52 = /* @__PURE__ */ new Vector32();\nvar _m1$32 = \
/* @__PURE__ */ new Matrix42();\nvar _zero2 = /* @__PURE__ */ new Vector32(0, \
0, 0);\nvar _one2 = /* @__PURE__ */ new Vector32(1, 1, 1);\nvar _x2 = /* \
@__PURE__ */ new Vector32();\nvar _y2 = /* @__PURE__ */ new Vector32();\nvar \
_z2 = /* @__PURE__ */ new Vector32();\nvar _matrix$22 = /* @__PURE__ */ new \
Matrix42();\nvar _quaternion$32 = /* @__PURE__ */ new Quaternion2();\nvar \
Euler2 = class _Euler {\n  constructor(x2 = 0, y2 = 0, z2 = 0, order = \
_Euler.DEFAULT_ORDER) {\n    this.isEuler = true;\n    this._x = x2;\n    \
this._y = y2;\n    this._z = z2;\n    this._order = order;\n  }\n  get x() \
{\n    return this._x;\n  }\n  set x(value) {\n    this._x = value;\n    \
this._onChangeCallback();\n  }\n  get y() {\n    return this._y;\n  }\n  set \
y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n  get \
z() {\n    return this._z;\n  }\n  set z(value) {\n    this._z = value;\n    \
this._onChangeCallback();\n  }\n  get order() {\n    return this._order;\n  \
}\n  set order(value) {\n    this._order = value;\n    \
this._onChangeCallback();\n  }\n  set(x2, y2, z2, order = this._order) {\n    \
this._x = x2;\n    this._y = y2;\n    this._z = z2;\n    this._order = \
order;\n    this._onChangeCallback();\n    return this;\n  }\n  clone() {\n   \
 return new this.constructor(this._x, this._y, this._z, this._order);\n  }\n  \
copy(euler) {\n    this._x = euler._x;\n    this._y = euler._y;\n    this._z \
= euler._z;\n    this._order = euler._order;\n    this._onChangeCallback();\n \
   return this;\n  }\n  setFromRotationMatrix(m2, order = this._order, \
update4 = true) {\n    const te = m2.elements;\n    const m11 = te[0], m12 = \
te[4], m13 = te[8];\n    const m21 = te[1], m22 = te[5], m23 = te[9];\n    \
const m31 = te[2], m32 = te[6], m33 = te[10];\n    switch (order) {\n      \
case \"XYZ\":\n        this._y = Math.asin(clamp$1(m13, -1, 1));\n        if \
(Math.abs(m13) < 0.9999999) {\n          this._x = Math.atan2(-m23, m33);\n   \
       this._z = Math.atan2(-m12, m11);\n        } else {\n          this._x \
= Math.atan2(m32, m22);\n          this._z = 0;\n        }\n        break;\n  \
    case \"YXZ\":\n        this._x = Math.asin(-clamp$1(m23, -1, 1));\n       \
 if (Math.abs(m23) < 0.9999999) {\n          this._y = Math.atan2(m13, \
m33);\n          this._z = Math.atan2(m21, m22);\n        } else {\n          \
this._y = Math.atan2(-m31, m11);\n          this._z = 0;\n        }\n        \
break;\n      case \"ZXY\":\n        this._x = Math.asin(clamp$1(m32, -1, \
1));\n        if (Math.abs(m32) < 0.9999999) {\n          this._y = \
Math.atan2(-m31, m33);\n          this._z = Math.atan2(-m12, m22);\n        } \
else {\n          this._y = 0;\n          this._z = Math.atan2(m21, m11);\n   \
     }\n        break;\n      case \"ZYX\":\n        this._y = \
Math.asin(-clamp$1(m31, -1, 1));\n        if (Math.abs(m31) < 0.9999999) {\n  \
        this._x = Math.atan2(m32, m33);\n          this._z = Math.atan2(m21, \
m11);\n        } else {\n          this._x = 0;\n          this._z = \
Math.atan2(-m12, m22);\n        }\n        break;\n      case \"YZX\":\n      \
  this._z = Math.asin(clamp$1(m21, -1, 1));\n        if (Math.abs(m21) < \
0.9999999) {\n          this._x = Math.atan2(-m23, m22);\n          this._y = \
Math.atan2(-m31, m11);\n        } else {\n          this._x = 0;\n          \
this._y = Math.atan2(m13, m33);\n        }\n        break;\n      case \
\"XZY\":\n        this._z = Math.asin(-clamp$1(m12, -1, 1));\n        if \
(Math.abs(m12) < 0.9999999) {\n          this._x = Math.atan2(m32, m22);\n    \
      this._y = Math.atan2(m13, m11);\n        } else {\n          this._x = \
Math.atan2(-m23, m33);\n          this._y = 0;\n        }\n        break;\n   \
   default:\n        console.warn(\"THREE.Euler: .setFromRotationMatrix() \
encountered an unknown order: \" + order);\n    }\n    this._order = order;\n \
   if (update4 === true) this._onChangeCallback();\n    return this;\n  }\n  \
setFromQuaternion(q, order, update4) {\n    \
_matrix$22.makeRotationFromQuaternion(q);\n    return \
this.setFromRotationMatrix(_matrix$22, order, update4);\n  }\n  \
setFromVector3(v, order = this._order) {\n    return this.set(v.x, v.y, v.z, \
order);\n  }\n  reorder(newOrder) {\n    _quaternion$32.setFromEuler(this);\n \
   return this.setFromQuaternion(_quaternion$32, newOrder);\n  }\n  \
equals(euler) {\n    return euler._x === this._x && euler._y === this._y && \
euler._z === this._z && euler._order === this._order;\n  }\n  \
fromArray(array) {\n    this._x = array[0];\n    this._y = array[1];\n    \
this._z = array[2];\n    if (array[3] !== void 0) this._order = array[3];\n   \
 this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], \
offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = \
this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = \
this._order;\n    return array;\n  }\n  _onChange(callback) {\n    \
this._onChangeCallback = callback;\n    return this;\n  }\n  \
_onChangeCallback() {\n  }\n  *[Symbol.iterator]() {\n    yield this._x;\n    \
yield this._y;\n    yield this._z;\n    yield this._order;\n  \
}\n};\nEuler2.DEFAULT_ORDER = \"XYZ\";\nvar Layers2 = class {\n  \
constructor() {\n    this.mask = 1 | 0;\n  }\n  set(channel) {\n    this.mask \
= (1 << channel | 0) >>> 0;\n  }\n  enable(channel) {\n    this.mask |= 1 << \
channel | 0;\n  }\n  enableAll() {\n    this.mask = 4294967295 | 0;\n  }\n  \
toggle(channel) {\n    this.mask ^= 1 << channel | 0;\n  }\n  \
disable(channel) {\n    this.mask &= ~(1 << channel | 0);\n  }\n  \
disableAll() {\n    this.mask = 0;\n  }\n  test(layers) {\n    return \
(this.mask & layers.mask) !== 0;\n  }\n  isEnabled(channel) {\n    return \
(this.mask & (1 << channel | 0)) !== 0;\n  }\n};\nvar _object3DId2 = 0;\nvar \
_v1$42 = /* @__PURE__ */ new Vector32();\nvar _q12 = /* @__PURE__ */ new \
Quaternion2();\nvar _m1$22 = /* @__PURE__ */ new Matrix42();\nvar _target$1 = \
/* @__PURE__ */ new Vector32();\nvar _position$32 = /* @__PURE__ */ new \
Vector32();\nvar _scale$22 = /* @__PURE__ */ new Vector32();\nvar \
_quaternion$22 = /* @__PURE__ */ new Quaternion2();\nvar _xAxis2 = /* \
@__PURE__ */ new Vector32(1, 0, 0);\nvar _yAxis2 = /* @__PURE__ */ new \
Vector32(0, 1, 0);\nvar _zAxis2 = /* @__PURE__ */ new Vector32(0, 0, 1);\nvar \
_addedEvent2 = { type: \"added\" };\nvar _removedEvent2 = { type: \"removed\" \
};\nvar _childaddedEvent2 = { type: \"childadded\", child: null };\nvar \
_childremovedEvent2 = { type: \"childremoved\", child: null };\nvar Object3D2 \
= class _Object3D extends EventDispatcher2 {\n  constructor() {\n    \
super();\n    this.isObject3D = true;\n    Object.defineProperty(this, \
\"id\", { value: _object3DId2++ });\n    this.uuid = generateUUID2();\n    \
this.name = \"\";\n    this.type = \"Object3D\";\n    this.parent = null;\n   \
 this.children = [];\n    this.up = _Object3D.DEFAULT_UP.clone();\n    const \
position = new Vector32();\n    const rotation = new Euler2();\n    const \
quaternion = new Quaternion2();\n    const scale = new Vector32(1, 1, 1);\n   \
 function onRotationChange() {\n      quaternion.setFromEuler(rotation, \
false);\n    }\n    function onQuaternionChange() {\n      \
rotation.setFromQuaternion(quaternion, void 0, false);\n    }\n    \
rotation._onChange(onRotationChange);\n    \
quaternion._onChange(onQuaternionChange);\n    Object.defineProperties(this, \
{\n      position: {\n        configurable: true,\n        enumerable: \
true,\n        value: position\n      },\n      rotation: {\n        \
configurable: true,\n        enumerable: true,\n        value: rotation\n     \
 },\n      quaternion: {\n        configurable: true,\n        enumerable: \
true,\n        value: quaternion\n      },\n      scale: {\n        \
configurable: true,\n        enumerable: true,\n        value: scale\n      \
},\n      modelViewMatrix: {\n        value: new Matrix42()\n      },\n      \
normalMatrix: {\n        value: new Matrix32()\n      }\n    });\n    \
this.matrix = new Matrix42();\n    this.matrixWorld = new Matrix42();\n    \
this.matrixAutoUpdate = _Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n    \
this.matrixWorldAutoUpdate = _Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;\n    \
this.matrixWorldNeedsUpdate = false;\n    this.layers = new Layers2();\n    \
this.visible = true;\n    this.castShadow = false;\n    this.receiveShadow = \
false;\n    this.frustumCulled = true;\n    this.renderOrder = 0;\n    \
this.animations = [];\n    this.userData = {};\n  }\n  onBeforeShadow() {\n  \
}\n  onAfterShadow() {\n  }\n  onBeforeRender() {\n  }\n  onAfterRender() {\n \
 }\n  applyMatrix4(matrix) {\n    if (this.matrixAutoUpdate) \
this.updateMatrix();\n    this.matrix.premultiply(matrix);\n    \
this.matrix.decompose(this.position, this.quaternion, this.scale);\n  }\n  \
applyQuaternion(q) {\n    this.quaternion.premultiply(q);\n    return this;\n \
 }\n  setRotationFromAxisAngle(axis, angle) {\n    \
this.quaternion.setFromAxisAngle(axis, angle);\n  }\n  \
setRotationFromEuler(euler) {\n    this.quaternion.setFromEuler(euler, \
true);\n  }\n  setRotationFromMatrix(m2) {\n    \
this.quaternion.setFromRotationMatrix(m2);\n  }\n  \
setRotationFromQuaternion(q) {\n    this.quaternion.copy(q);\n  }\n  \
rotateOnAxis(axis, angle) {\n    _q12.setFromAxisAngle(axis, angle);\n    \
this.quaternion.multiply(_q12);\n    return this;\n  }\n  \
rotateOnWorldAxis(axis, angle) {\n    _q12.setFromAxisAngle(axis, angle);\n   \
 this.quaternion.premultiply(_q12);\n    return this;\n  }\n  rotateX(angle) \
{\n    return this.rotateOnAxis(_xAxis2, angle);\n  }\n  rotateY(angle) {\n   \
 return this.rotateOnAxis(_yAxis2, angle);\n  }\n  rotateZ(angle) {\n    \
return this.rotateOnAxis(_zAxis2, angle);\n  }\n  translateOnAxis(axis, \
distance2) {\n    _v1$42.copy(axis).applyQuaternion(this.quaternion);\n    \
this.position.add(_v1$42.multiplyScalar(distance2));\n    return this;\n  }\n \
 translateX(distance2) {\n    return this.translateOnAxis(_xAxis2, \
distance2);\n  }\n  translateY(distance2) {\n    return \
this.translateOnAxis(_yAxis2, distance2);\n  }\n  translateZ(distance2) {\n   \
 return this.translateOnAxis(_zAxis2, distance2);\n  }\n  \
localToWorld(vector) {\n    this.updateWorldMatrix(true, false);\n    return \
vector.applyMatrix4(this.matrixWorld);\n  }\n  worldToLocal(vector) {\n    \
this.updateWorldMatrix(true, false);\n    return \
vector.applyMatrix4(_m1$22.copy(this.matrixWorld).invert());\n  }\n  \
lookAt(x2, y2, z2) {\n    if (x2.isVector3) {\n      _target$1.copy(x2);\n    \
} else {\n      _target$1.set(x2, y2, z2);\n    }\n    const parent = \
this.parent;\n    this.updateWorldMatrix(true, false);\n    \
_position$32.setFromMatrixPosition(this.matrixWorld);\n    if (this.isCamera \
|| this.isLight) {\n      _m1$22.lookAt(_position$32, _target$1, this.up);\n  \
  } else {\n      _m1$22.lookAt(_target$1, _position$32, this.up);\n    }\n   \
 this.quaternion.setFromRotationMatrix(_m1$22);\n    if (parent) {\n      \
_m1$22.extractRotation(parent.matrixWorld);\n      \
_q12.setFromRotationMatrix(_m1$22);\n      \
this.quaternion.premultiply(_q12.invert());\n    }\n  }\n  add(object) {\n    \
if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) \
{\n        this.add(arguments[i]);\n      }\n      return this;\n    }\n    \
if (object === this) {\n      console.error(\"THREE.Object3D.add: object \
can't be added as a child of itself.\", object);\n      return this;\n    }\n \
   if (object && object.isObject3D) {\n      object.removeFromParent();\n     \
 object.parent = this;\n      this.children.push(object);\n      \
object.dispatchEvent(_addedEvent2);\n      _childaddedEvent2.child = \
object;\n      this.dispatchEvent(_childaddedEvent2);\n      \
_childaddedEvent2.child = null;\n    } else {\n      \
console.error(\"THREE.Object3D.add: object not an instance of \
THREE.Object3D.\", object);\n    }\n    return this;\n  }\n  remove(object) \
{\n    if (arguments.length > 1) {\n      for (let i = 0; i < \
arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n      \
return this;\n    }\n    const index5 = this.children.indexOf(object);\n    \
if (index5 !== -1) {\n      object.parent = null;\n      \
this.children.splice(index5, 1);\n      \
object.dispatchEvent(_removedEvent2);\n      _childremovedEvent2.child = \
object;\n      this.dispatchEvent(_childremovedEvent2);\n      \
_childremovedEvent2.child = null;\n    }\n    return this;\n  }\n  \
removeFromParent() {\n    const parent = this.parent;\n    if (parent !== \
null) {\n      parent.remove(this);\n    }\n    return this;\n  }\n  clear() \
{\n    return this.remove(...this.children);\n  }\n  attach(object) {\n    \
this.updateWorldMatrix(true, false);\n    \
_m1$22.copy(this.matrixWorld).invert();\n    if (object.parent !== null) {\n  \
    object.parent.updateWorldMatrix(true, false);\n      \
_m1$22.multiply(object.parent.matrixWorld);\n    }\n    \
object.applyMatrix4(_m1$22);\n    object.removeFromParent();\n    \
object.parent = this;\n    this.children.push(object);\n    \
object.updateWorldMatrix(false, true);\n    \
object.dispatchEvent(_addedEvent2);\n    _childaddedEvent2.child = object;\n  \
  this.dispatchEvent(_childaddedEvent2);\n    _childaddedEvent2.child = \
null;\n    return this;\n  }\n  getObjectById(id2) {\n    return \
this.getObjectByProperty(\"id\", id2);\n  }\n  getObjectByName(name) {\n    \
return this.getObjectByProperty(\"name\", name);\n  }\n  \
getObjectByProperty(name, value) {\n    if (this[name] === value) return \
this;\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      \
const child = this.children[i];\n      const object = \
child.getObjectByProperty(name, value);\n      if (object !== void 0) {\n     \
   return object;\n      }\n    }\n    return void 0;\n  }\n  \
getObjectsByProperty(name, value, result = []) {\n    if (this[name] === \
value) result.push(this);\n    const children = this.children;\n    for (let \
i = 0, l = children.length; i < l; i++) {\n      \
children[i].getObjectsByProperty(name, value, result);\n    }\n    return \
result;\n  }\n  getWorldPosition(target) {\n    this.updateWorldMatrix(true, \
false);\n    return target.setFromMatrixPosition(this.matrixWorld);\n  }\n  \
getWorldQuaternion(target) {\n    this.updateWorldMatrix(true, false);\n    \
this.matrixWorld.decompose(_position$32, target, _scale$22);\n    return \
target;\n  }\n  getWorldScale(target) {\n    this.updateWorldMatrix(true, \
false);\n    this.matrixWorld.decompose(_position$32, _quaternion$22, \
target);\n    return target;\n  }\n  getWorldDirection(target) {\n    \
this.updateWorldMatrix(true, false);\n    const e = \
this.matrixWorld.elements;\n    return target.set(e[8], e[9], \
e[10]).normalize();\n  }\n  raycast() {\n  }\n  traverse(callback) {\n    \
callback(this);\n    const children = this.children;\n    for (let i = 0, l = \
children.length; i < l; i++) {\n      children[i].traverse(callback);\n    \
}\n  }\n  traverseVisible(callback) {\n    if (this.visible === false) \
return;\n    callback(this);\n    const children = this.children;\n    for \
(let i = 0, l = children.length; i < l; i++) {\n      \
children[i].traverseVisible(callback);\n    }\n  }\n  \
traverseAncestors(callback) {\n    const parent = this.parent;\n    if \
(parent !== null) {\n      callback(parent);\n      \
parent.traverseAncestors(callback);\n    }\n  }\n  updateMatrix() {\n    \
this.matrix.compose(this.position, this.quaternion, this.scale);\n    \
this.matrixWorldNeedsUpdate = true;\n  }\n  updateMatrixWorld(force) {\n    \
if (this.matrixAutoUpdate) this.updateMatrix();\n    if \
(this.matrixWorldNeedsUpdate || force) {\n      if \
(this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) \
{\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          \
this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    \
    }\n      }\n      this.matrixWorldNeedsUpdate = false;\n      force = \
true;\n    }\n    const children = this.children;\n    for (let i = 0, l = \
children.length; i < l; i++) {\n      const child = children[i];\n      \
child.updateMatrixWorld(force);\n    }\n  }\n  \
updateWorldMatrix(updateParents, updateChildren) {\n    const parent = \
this.parent;\n    if (updateParents === true && parent !== null) {\n      \
parent.updateWorldMatrix(true, false);\n    }\n    if (this.matrixAutoUpdate) \
this.updateMatrix();\n    if (this.matrixWorldAutoUpdate === true) {\n      \
if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n    \
  } else {\n        \
this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    \
  }\n    }\n    if (updateChildren === true) {\n      const children = \
this.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n    \
    const child = children[i];\n        child.updateWorldMatrix(false, \
true);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRootObject = meta \
=== void 0 || typeof meta === \"string\";\n    const output2 = {};\n    if \
(isRootObject) {\n      meta = {\n        geometries: {},\n        materials: \
{},\n        textures: {},\n        images: {},\n        shapes: {},\n        \
skeletons: {},\n        animations: {},\n        nodes: {}\n      };\n      \
output2.metadata = {\n        version: 4.6,\n        type: \"Object\",\n      \
  generator: \"Object3D.toJSON\"\n      };\n    }\n    const object = {};\n   \
 object.uuid = this.uuid;\n    object.type = this.type;\n    if (this.name \
!== \"\") object.name = this.name;\n    if (this.castShadow === true) \
object.castShadow = true;\n    if (this.receiveShadow === true) \
object.receiveShadow = true;\n    if (this.visible === false) object.visible \
= false;\n    if (this.frustumCulled === false) object.frustumCulled = \
false;\n    if (this.renderOrder !== 0) object.renderOrder = \
this.renderOrder;\n    if (Object.keys(this.userData).length > 0) \
object.userData = this.userData;\n    object.layers = this.layers.mask;\n    \
object.matrix = this.matrix.toArray();\n    object.up = this.up.toArray();\n  \
  if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n    \
if (this.isInstancedMesh) {\n      object.type = \"InstancedMesh\";\n      \
object.count = this.count;\n      object.instanceMatrix = \
this.instanceMatrix.toJSON();\n      if (this.instanceColor !== null) \
object.instanceColor = this.instanceColor.toJSON();\n    }\n    if \
(this.isBatchedMesh) {\n      object.type = \"BatchedMesh\";\n      \
object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n      \
object.sortObjects = this.sortObjects;\n      object.drawRanges = \
this._drawRanges;\n      object.reservedRanges = this._reservedRanges;\n      \
object.visibility = this._visibility;\n      object.active = this._active;\n  \
    object.bounds = this._bounds.map((bound) => ({\n        boxInitialized: \
bound.boxInitialized,\n        boxMin: bound.box.min.toArray(),\n        \
boxMax: bound.box.max.toArray(),\n        sphereInitialized: \
bound.sphereInitialized,\n        sphereRadius: bound.sphere.radius,\n        \
sphereCenter: bound.sphere.center.toArray()\n      }));\n      \
object.maxInstanceCount = this._maxInstanceCount;\n      \
object.maxVertexCount = this._maxVertexCount;\n      object.maxIndexCount = \
this._maxIndexCount;\n      object.geometryInitialized = \
this._geometryInitialized;\n      object.geometryCount = \
this._geometryCount;\n      object.matricesTexture = \
this._matricesTexture.toJSON(meta);\n      if (this._colorsTexture !== null) \
object.colorsTexture = this._colorsTexture.toJSON(meta);\n      if \
(this.boundingSphere !== null) {\n        object.boundingSphere = {\n         \
 center: object.boundingSphere.center.toArray(),\n          radius: \
object.boundingSphere.radius\n        };\n      }\n      if (this.boundingBox \
!== null) {\n        object.boundingBox = {\n          min: \
object.boundingBox.min.toArray(),\n          max: \
object.boundingBox.max.toArray()\n        };\n      }\n    }\n    function \
serialize(library, element2) {\n      if (library[element2.uuid] === void 0) \
{\n        library[element2.uuid] = element2.toJSON(meta);\n      }\n      \
return element2.uuid;\n    }\n    if (this.isScene) {\n      if \
(this.background) {\n        if (this.background.isColor) {\n          \
object.background = this.background.toJSON();\n        } else if \
(this.background.isTexture) {\n          object.background = \
this.background.toJSON(meta).uuid;\n        }\n      }\n      if \
(this.environment && this.environment.isTexture && \
this.environment.isRenderTargetTexture !== true) {\n        \
object.environment = this.environment.toJSON(meta).uuid;\n      }\n    } else \
if (this.isMesh || this.isLine || this.isPoints) {\n      object.geometry = \
serialize(meta.geometries, this.geometry);\n      const parameters = \
this.geometry.parameters;\n      if (parameters !== void 0 && \
parameters.shapes !== void 0) {\n        const shapes = parameters.shapes;\n  \
      if (Array.isArray(shapes)) {\n          for (let i = 0, l = \
shapes.length; i < l; i++) {\n            const shape = shapes[i];\n          \
  serialize(meta.shapes, shape);\n          }\n        } else {\n          \
serialize(meta.shapes, shapes);\n        }\n      }\n    }\n    if \
(this.isSkinnedMesh) {\n      object.bindMode = this.bindMode;\n      \
object.bindMatrix = this.bindMatrix.toArray();\n      if (this.skeleton !== \
void 0) {\n        serialize(meta.skeletons, this.skeleton);\n        \
object.skeleton = this.skeleton.uuid;\n      }\n    }\n    if (this.material \
!== void 0) {\n      if (Array.isArray(this.material)) {\n        const uuids \
= [];\n        for (let i = 0, l = this.material.length; i < l; i++) {\n      \
    uuids.push(serialize(meta.materials, this.material[i]));\n        }\n     \
   object.material = uuids;\n      } else {\n        object.material = \
serialize(meta.materials, this.material);\n      }\n    }\n    if \
(this.children.length > 0) {\n      object.children = [];\n      for (let i = \
0; i < this.children.length; i++) {\n        \
object.children.push(this.children[i].toJSON(meta).object);\n      }\n    }\n \
   if (this.animations.length > 0) {\n      object.animations = [];\n      \
for (let i = 0; i < this.animations.length; i++) {\n        const animation = \
this.animations[i];\n        \
object.animations.push(serialize(meta.animations, animation));\n      }\n    \
}\n    if (isRootObject) {\n      const geometries = \
extractFromCache(meta.geometries);\n      const materials = \
extractFromCache(meta.materials);\n      const textures = \
extractFromCache(meta.textures);\n      const images = \
extractFromCache(meta.images);\n      const shapes = \
extractFromCache(meta.shapes);\n      const skeletons = \
extractFromCache(meta.skeletons);\n      const animations = \
extractFromCache(meta.animations);\n      const nodes = \
extractFromCache(meta.nodes);\n      if (geometries.length > 0) \
output2.geometries = geometries;\n      if (materials.length > 0) \
output2.materials = materials;\n      if (textures.length > 0) \
output2.textures = textures;\n      if (images.length > 0) output2.images = \
images;\n      if (shapes.length > 0) output2.shapes = shapes;\n      if \
(skeletons.length > 0) output2.skeletons = skeletons;\n      if \
(animations.length > 0) output2.animations = animations;\n      if \
(nodes.length > 0) output2.nodes = nodes;\n    }\n    output2.object = \
object;\n    return output2;\n    function extractFromCache(cache2) {\n      \
const values = [];\n      for (const key in cache2) {\n        const data = \
cache2[key];\n        delete data.metadata;\n        values.push(data);\n     \
 }\n      return values;\n    }\n  }\n  clone(recursive) {\n    return new \
this.constructor().copy(this, recursive);\n  }\n  copy(source, recursive = \
true) {\n    this.name = source.name;\n    this.up.copy(source.up);\n    \
this.position.copy(source.position);\n    this.rotation.order = \
source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    \
this.scale.copy(source.scale);\n    this.matrix.copy(source.matrix);\n    \
this.matrixWorld.copy(source.matrixWorld);\n    this.matrixAutoUpdate = \
source.matrixAutoUpdate;\n    this.matrixWorldAutoUpdate = \
source.matrixWorldAutoUpdate;\n    this.matrixWorldNeedsUpdate = \
source.matrixWorldNeedsUpdate;\n    this.layers.mask = source.layers.mask;\n  \
  this.visible = source.visible;\n    this.castShadow = source.castShadow;\n  \
  this.receiveShadow = source.receiveShadow;\n    this.frustumCulled = \
source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n    \
this.animations = source.animations.slice();\n    this.userData = \
JSON.parse(JSON.stringify(source.userData));\n    if (recursive === true) {\n \
     for (let i = 0; i < source.children.length; i++) {\n        const child \
= source.children[i];\n        this.add(child.clone());\n      }\n    }\n    \
return this;\n  }\n};\nObject3D2.DEFAULT_UP = /* @__PURE__ */ new Vector32(0, \
1, 0);\nObject3D2.DEFAULT_MATRIX_AUTO_UPDATE = \
true;\nObject3D2.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\nvar _v0$12 = /* \
@__PURE__ */ new Vector32();\nvar _v1$32 = /* @__PURE__ */ new \
Vector32();\nvar _v2$22 = /* @__PURE__ */ new Vector32();\nvar _v3$22 = /* \
@__PURE__ */ new Vector32();\nvar _vab2 = /* @__PURE__ */ new \
Vector32();\nvar _vac2 = /* @__PURE__ */ new Vector32();\nvar _vbc2 = /* \
@__PURE__ */ new Vector32();\nvar _vap2 = /* @__PURE__ */ new \
Vector32();\nvar _vbp2 = /* @__PURE__ */ new Vector32();\nvar _vcp2 = /* \
@__PURE__ */ new Vector32();\nvar _v402 = /* @__PURE__ */ new \
Vector42();\nvar _v412 = /* @__PURE__ */ new Vector42();\nvar _v422 = /* \
@__PURE__ */ new Vector42();\nvar Triangle2 = class _Triangle {\n  \
constructor(a2 = new Vector32(), b = new Vector32(), c2 = new Vector32()) {\n \
   this.a = a2;\n    this.b = b;\n    this.c = c2;\n  }\n  static \
getNormal(a2, b, c2, target) {\n    target.subVectors(c2, b);\n    \
_v0$12.subVectors(a2, b);\n    target.cross(_v0$12);\n    const \
targetLengthSq = target.lengthSq();\n    if (targetLengthSq > 0) {\n      \
return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n    }\n    \
return target.set(0, 0, 0);\n  }\n  // static/instance method to calculate \
barycentric coordinates\n  // based on: \
http://www.blackpawn.com/texts/pointinpoly/default.html\n  static \
getBarycoord(point, a2, b, c2, target) {\n    _v0$12.subVectors(c2, a2);\n    \
_v1$32.subVectors(b, a2);\n    _v2$22.subVectors(point, a2);\n    const dot00 \
= _v0$12.dot(_v0$12);\n    const dot01 = _v0$12.dot(_v1$32);\n    const dot02 \
= _v0$12.dot(_v2$22);\n    const dot11 = _v1$32.dot(_v1$32);\n    const dot12 \
= _v1$32.dot(_v2$22);\n    const denom = dot00 * dot11 - dot01 * dot01;\n    \
if (denom === 0) {\n      target.set(0, 0, 0);\n      return null;\n    }\n   \
 const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * \
invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    \
return target.set(1 - u - v, v, u);\n  }\n  static containsPoint(point, a2, \
b, c2) {\n    if (this.getBarycoord(point, a2, b, c2, _v3$22) === null) {\n   \
   return false;\n    }\n    return _v3$22.x >= 0 && _v3$22.y >= 0 && \
_v3$22.x + _v3$22.y <= 1;\n  }\n  static getInterpolation(point, p1, p2, p3, \
v1, v2, v3, target) {\n    if (this.getBarycoord(point, p1, p2, p3, _v3$22) \
=== null) {\n      target.x = 0;\n      target.y = 0;\n      if (\"z\" in \
target) target.z = 0;\n      if (\"w\" in target) target.w = 0;\n      return \
null;\n    }\n    target.setScalar(0);\n    target.addScaledVector(v1, \
_v3$22.x);\n    target.addScaledVector(v2, _v3$22.y);\n    \
target.addScaledVector(v3, _v3$22.z);\n    return target;\n  }\n  static \
getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {\n    \
_v402.setScalar(0);\n    _v412.setScalar(0);\n    _v422.setScalar(0);\n    \
_v402.fromBufferAttribute(attr, i1);\n    _v412.fromBufferAttribute(attr, \
i2);\n    _v422.fromBufferAttribute(attr, i3);\n    target.setScalar(0);\n    \
target.addScaledVector(_v402, barycoord.x);\n    \
target.addScaledVector(_v412, barycoord.y);\n    \
target.addScaledVector(_v422, barycoord.z);\n    return target;\n  }\n  \
static isFrontFacing(a2, b, c2, direction2) {\n    _v0$12.subVectors(c2, \
b);\n    _v1$32.subVectors(a2, b);\n    return \
_v0$12.cross(_v1$32).dot(direction2) < 0 ? true : false;\n  }\n  set(a2, b, \
c2) {\n    this.a.copy(a2);\n    this.b.copy(b);\n    this.c.copy(c2);\n    \
return this;\n  }\n  setFromPointsAndIndices(points, i0, i1, i2) {\n    \
this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    \
this.c.copy(points[i2]);\n    return this;\n  }\n  \
setFromAttributeAndIndices(attribute2, i0, i1, i2) {\n    \
this.a.fromBufferAttribute(attribute2, i0);\n    \
this.b.fromBufferAttribute(attribute2, i1);\n    \
this.c.fromBufferAttribute(attribute2, i2);\n    return this;\n  }\n  clone() \
{\n    return new this.constructor().copy(this);\n  }\n  copy(triangle) {\n   \
 this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    \
this.c.copy(triangle.c);\n    return this;\n  }\n  getArea() {\n    \
_v0$12.subVectors(this.c, this.b);\n    _v1$32.subVectors(this.a, this.b);\n  \
  return _v0$12.cross(_v1$32).length() * 0.5;\n  }\n  getMidpoint(target) {\n \
   return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / \
3);\n  }\n  getNormal(target) {\n    return _Triangle.getNormal(this.a, \
this.b, this.c, target);\n  }\n  getPlane(target) {\n    return \
target.setFromCoplanarPoints(this.a, this.b, this.c);\n  }\n  \
getBarycoord(point, target) {\n    return _Triangle.getBarycoord(point, \
this.a, this.b, this.c, target);\n  }\n  getInterpolation(point, v1, v2, v3, \
target) {\n    return _Triangle.getInterpolation(point, this.a, this.b, \
this.c, v1, v2, v3, target);\n  }\n  containsPoint(point) {\n    return \
_Triangle.containsPoint(point, this.a, this.b, this.c);\n  }\n  \
isFrontFacing(direction2) {\n    return _Triangle.isFrontFacing(this.a, \
this.b, this.c, direction2);\n  }\n  intersectsBox(box) {\n    return \
box.intersectsTriangle(this);\n  }\n  closestPointToPoint(p, target) {\n    \
const a2 = this.a, b = this.b, c2 = this.c;\n    let v, w;\n    \
_vab2.subVectors(b, a2);\n    _vac2.subVectors(c2, a2);\n    \
_vap2.subVectors(p, a2);\n    const d1 = _vab2.dot(_vap2);\n    const d2 = \
_vac2.dot(_vap2);\n    if (d1 <= 0 && d2 <= 0) {\n      return \
target.copy(a2);\n    }\n    _vbp2.subVectors(p, b);\n    const d3 = \
_vab2.dot(_vbp2);\n    const d4 = _vac2.dot(_vbp2);\n    if (d3 >= 0 && d4 <= \
d3) {\n      return target.copy(b);\n    }\n    const vc = d1 * d4 - d3 * \
d2;\n    if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n      v = d1 / (d1 - d3);\n    \
  return target.copy(a2).addScaledVector(_vab2, v);\n    }\n    \
_vcp2.subVectors(p, c2);\n    const d5 = _vab2.dot(_vcp2);\n    const d6 = \
_vac2.dot(_vcp2);\n    if (d6 >= 0 && d5 <= d6) {\n      return \
target.copy(c2);\n    }\n    const vb = d5 * d2 - d1 * d6;\n    if (vb <= 0 \
&& d2 >= 0 && d6 <= 0) {\n      w = d2 / (d2 - d6);\n      return \
target.copy(a2).addScaledVector(_vac2, w);\n    }\n    const va = d3 * d6 - \
d5 * d4;\n    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n      \
_vbc2.subVectors(c2, b);\n      w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n      \
return target.copy(b).addScaledVector(_vbc2, w);\n    }\n    const denom = 1 \
/ (va + vb + vc);\n    v = vb * denom;\n    w = vc * denom;\n    return \
target.copy(a2).addScaledVector(_vab2, v).addScaledVector(_vac2, w);\n  }\n  \
equals(triangle) {\n    return triangle.a.equals(this.a) && \
triangle.b.equals(this.b) && triangle.c.equals(this.c);\n  }\n};\nvar \
_colorKeywords2 = {\n  \"aliceblue\": 15792383,\n  \"antiquewhite\": \
16444375,\n  \"aqua\": 65535,\n  \"aquamarine\": 8388564,\n  \"azure\": \
15794175,\n  \"beige\": 16119260,\n  \"bisque\": 16770244,\n  \"black\": 0,\n \
 \"blanchedalmond\": 16772045,\n  \"blue\": 255,\n  \"blueviolet\": \
9055202,\n  \"brown\": 10824234,\n  \"burlywood\": 14596231,\n  \
\"cadetblue\": 6266528,\n  \"chartreuse\": 8388352,\n  \"chocolate\": \
13789470,\n  \"coral\": 16744272,\n  \"cornflowerblue\": 6591981,\n  \
\"cornsilk\": 16775388,\n  \"crimson\": 14423100,\n  \"cyan\": 65535,\n  \
\"darkblue\": 139,\n  \"darkcyan\": 35723,\n  \"darkgoldenrod\": 12092939,\n  \
\"darkgray\": 11119017,\n  \"darkgreen\": 25600,\n  \"darkgrey\": 11119017,\n \
 \"darkkhaki\": 12433259,\n  \"darkmagenta\": 9109643,\n  \"darkolivegreen\": \
5597999,\n  \"darkorange\": 16747520,\n  \"darkorchid\": 10040012,\n  \
\"darkred\": 9109504,\n  \"darksalmon\": 15308410,\n  \"darkseagreen\": \
9419919,\n  \"darkslateblue\": 4734347,\n  \"darkslategray\": 3100495,\n  \
\"darkslategrey\": 3100495,\n  \"darkturquoise\": 52945,\n  \"darkviolet\": \
9699539,\n  \"deeppink\": 16716947,\n  \"deepskyblue\": 49151,\n  \
\"dimgray\": 6908265,\n  \"dimgrey\": 6908265,\n  \"dodgerblue\": 2003199,\n  \
\"firebrick\": 11674146,\n  \"floralwhite\": 16775920,\n  \"forestgreen\": \
2263842,\n  \"fuchsia\": 16711935,\n  \"gainsboro\": 14474460,\n  \
\"ghostwhite\": 16316671,\n  \"gold\": 16766720,\n  \"goldenrod\": \
14329120,\n  \"gray\": 8421504,\n  \"green\": 32768,\n  \"greenyellow\": \
11403055,\n  \"grey\": 8421504,\n  \"honeydew\": 15794160,\n  \"hotpink\": \
16738740,\n  \"indianred\": 13458524,\n  \"indigo\": 4915330,\n  \"ivory\": \
16777200,\n  \"khaki\": 15787660,\n  \"lavender\": 15132410,\n  \
\"lavenderblush\": 16773365,\n  \"lawngreen\": 8190976,\n  \"lemonchiffon\": \
16775885,\n  \"lightblue\": 11393254,\n  \"lightcoral\": 15761536,\n  \
\"lightcyan\": 14745599,\n  \"lightgoldenrodyellow\": 16448210,\n  \
\"lightgray\": 13882323,\n  \"lightgreen\": 9498256,\n  \"lightgrey\": \
13882323,\n  \"lightpink\": 16758465,\n  \"lightsalmon\": 16752762,\n  \
\"lightseagreen\": 2142890,\n  \"lightskyblue\": 8900346,\n  \
\"lightslategray\": 7833753,\n  \"lightslategrey\": 7833753,\n  \
\"lightsteelblue\": 11584734,\n  \"lightyellow\": 16777184,\n  \"lime\": \
65280,\n  \"limegreen\": 3329330,\n  \"linen\": 16445670,\n  \"magenta\": \
16711935,\n  \"maroon\": 8388608,\n  \"mediumaquamarine\": 6737322,\n  \
\"mediumblue\": 205,\n  \"mediumorchid\": 12211667,\n  \"mediumpurple\": \
9662683,\n  \"mediumseagreen\": 3978097,\n  \"mediumslateblue\": 8087790,\n  \
\"mediumspringgreen\": 64154,\n  \"mediumturquoise\": 4772300,\n  \
\"mediumvioletred\": 13047173,\n  \"midnightblue\": 1644912,\n  \
\"mintcream\": 16121850,\n  \"mistyrose\": 16770273,\n  \"moccasin\": \
16770229,\n  \"navajowhite\": 16768685,\n  \"navy\": 128,\n  \"oldlace\": \
16643558,\n  \"olive\": 8421376,\n  \"olivedrab\": 7048739,\n  \"orange\": \
16753920,\n  \"orangered\": 16729344,\n  \"orchid\": 14315734,\n  \
\"palegoldenrod\": 15657130,\n  \"palegreen\": 10025880,\n  \
\"paleturquoise\": 11529966,\n  \"palevioletred\": 14381203,\n  \
\"papayawhip\": 16773077,\n  \"peachpuff\": 16767673,\n  \"peru\": \
13468991,\n  \"pink\": 16761035,\n  \"plum\": 14524637,\n  \"powderblue\": \
11591910,\n  \"purple\": 8388736,\n  \"rebeccapurple\": 6697881,\n  \"red\": \
16711680,\n  \"rosybrown\": 12357519,\n  \"royalblue\": 4286945,\n  \
\"saddlebrown\": 9127187,\n  \"salmon\": 16416882,\n  \"sandybrown\": \
16032864,\n  \"seagreen\": 3050327,\n  \"seashell\": 16774638,\n  \"sienna\": \
10506797,\n  \"silver\": 12632256,\n  \"skyblue\": 8900331,\n  \"slateblue\": \
6970061,\n  \"slategray\": 7372944,\n  \"slategrey\": 7372944,\n  \"snow\": \
16775930,\n  \"springgreen\": 65407,\n  \"steelblue\": 4620980,\n  \"tan\": \
13808780,\n  \"teal\": 32896,\n  \"thistle\": 14204888,\n  \"tomato\": \
16737095,\n  \"turquoise\": 4251856,\n  \"violet\": 15631086,\n  \"wheat\": \
16113331,\n  \"white\": 16777215,\n  \"whitesmoke\": 16119285,\n  \"yellow\": \
16776960,\n  \"yellowgreen\": 10145074\n};\nvar _hslA2 = { h: 0, s: 0, l: 0 \
};\nvar _hslB2 = { h: 0, s: 0, l: 0 };\nfunction hue2rgb2(p, q, t) {\n  if (t \
< 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * \
t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * 6 * (2 \
/ 3 - t);\n  return p;\n}\nvar Color2 = class {\n  constructor(r, g, b) {\n   \
 this.isColor = true;\n    this.r = 1;\n    this.g = 1;\n    this.b = 1;\n    \
return this.set(r, g, b);\n  }\n  set(r, g, b) {\n    if (g === void 0 && b \
=== void 0) {\n      const value = r;\n      if (value && value.isColor) {\n  \
      this.copy(value);\n      } else if (typeof value === \"number\") {\n    \
    this.setHex(value);\n      } else if (typeof value === \"string\") {\n    \
    this.setStyle(value);\n      }\n    } else {\n      this.setRGB(r, g, \
b);\n    }\n    return this;\n  }\n  setScalar(scalar) {\n    this.r = \
scalar;\n    this.g = scalar;\n    this.b = scalar;\n    return this;\n  }\n  \
setHex(hex, colorSpace = SRGBColorSpace2) {\n    hex = Math.floor(hex);\n    \
this.r = (hex >> 16 & 255) / 255;\n    this.g = (hex >> 8 & 255) / 255;\n    \
this.b = (hex & 255) / 255;\n    ColorManagement2.toWorkingColorSpace(this, \
colorSpace);\n    return this;\n  }\n  setRGB(r, g, b, colorSpace = \
ColorManagement2.workingColorSpace) {\n    this.r = r;\n    this.g = g;\n    \
this.b = b;\n    ColorManagement2.toWorkingColorSpace(this, colorSpace);\n    \
return this;\n  }\n  setHSL(h, s, l, colorSpace = \
ColorManagement2.workingColorSpace) {\n    h = euclideanModulo2(h, 1);\n    s \
= clamp$1(s, 0, 1);\n    l = clamp$1(l, 0, 1);\n    if (s === 0) {\n      \
this.r = this.g = this.b = l;\n    } else {\n      const p = l <= 0.5 ? l * \
(1 + s) : l + s - l * s;\n      const q = 2 * l - p;\n      this.r = \
hue2rgb2(q, p, h + 1 / 3);\n      this.g = hue2rgb2(q, p, h);\n      this.b = \
hue2rgb2(q, p, h - 1 / 3);\n    }\n    \
ColorManagement2.toWorkingColorSpace(this, colorSpace);\n    return this;\n  \
}\n  setStyle(style, colorSpace = SRGBColorSpace2) {\n    function \
handleAlpha(string) {\n      if (string === void 0) return;\n      if \
(parseFloat(string) < 1) {\n        console.warn(\"THREE.Color: Alpha \
component of \" + style + \" will be ignored.\");\n      }\n    }\n    let \
m2;\n    if (m2 = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n      let \
color2;\n      const name = m2[1];\n      const components = m2[2];\n      \
switch (name) {\n        case \"rgb\":\n        case \"rgba\":\n          if \
(color2 = \
/^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.\
exec(components)) {\n            handleAlpha(color2[4]);\n            return \
this.setRGB(\n              Math.min(255, parseInt(color2[1], 10)) / 255,\n   \
           Math.min(255, parseInt(color2[2], 10)) / 255,\n              \
Math.min(255, parseInt(color2[3], 10)) / 255,\n              colorSpace\n     \
       );\n          }\n          if (color2 = \
/^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\
\\s*)?$/.exec(components)) {\n            handleAlpha(color2[4]);\n           \
 return this.setRGB(\n              Math.min(100, parseInt(color2[1], 10)) / \
100,\n              Math.min(100, parseInt(color2[2], 10)) / 100,\n           \
   Math.min(100, parseInt(color2[3], 10)) / 100,\n              colorSpace\n  \
          );\n          }\n          break;\n        case \"hsl\":\n        \
case \"hsla\":\n          if (color2 = \
/^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(\
?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            \
handleAlpha(color2[4]);\n            return this.setHSL(\n              \
parseFloat(color2[1]) / 360,\n              parseFloat(color2[2]) / 100,\n    \
          parseFloat(color2[3]) / 100,\n              colorSpace\n            \
);\n          }\n          break;\n        default:\n          \
console.warn(\"THREE.Color: Unknown color model \" + style);\n      }\n    } \
else if (m2 = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n      const hex = \
m2[1];\n      const size = hex.length;\n      if (size === 3) {\n        \
return this.setRGB(\n          parseInt(hex.charAt(0), 16) / 15,\n          \
parseInt(hex.charAt(1), 16) / 15,\n          parseInt(hex.charAt(2), 16) / \
15,\n          colorSpace\n        );\n      } else if (size === 6) {\n       \
 return this.setHex(parseInt(hex, 16), colorSpace);\n      } else {\n        \
console.warn(\"THREE.Color: Invalid hex color \" + style);\n      }\n    } \
else if (style && style.length > 0) {\n      return this.setColorName(style, \
colorSpace);\n    }\n    return this;\n  }\n  setColorName(style, colorSpace \
= SRGBColorSpace2) {\n    const hex = _colorKeywords2[style.toLowerCase()];\n \
   if (hex !== void 0) {\n      this.setHex(hex, colorSpace);\n    } else {\n \
     console.warn(\"THREE.Color: Unknown color \" + style);\n    }\n    \
return this;\n  }\n  clone() {\n    return new this.constructor(this.r, \
this.g, this.b);\n  }\n  copy(color2) {\n    this.r = color2.r;\n    this.g = \
color2.g;\n    this.b = color2.b;\n    return this;\n  }\n  \
copySRGBToLinear(color2) {\n    this.r = SRGBToLinear2(color2.r);\n    this.g \
= SRGBToLinear2(color2.g);\n    this.b = SRGBToLinear2(color2.b);\n    return \
this;\n  }\n  copyLinearToSRGB(color2) {\n    this.r = \
LinearToSRGB2(color2.r);\n    this.g = LinearToSRGB2(color2.g);\n    this.b = \
LinearToSRGB2(color2.b);\n    return this;\n  }\n  convertSRGBToLinear() {\n  \
  this.copySRGBToLinear(this);\n    return this;\n  }\n  \
convertLinearToSRGB() {\n    this.copyLinearToSRGB(this);\n    return this;\n \
 }\n  getHex(colorSpace = SRGBColorSpace2) {\n    \
ColorManagement2.fromWorkingColorSpace(_color2.copy(this), colorSpace);\n    \
return Math.round(clamp$1(_color2.r * 255, 0, 255)) * 65536 + \
Math.round(clamp$1(_color2.g * 255, 0, 255)) * 256 + \
Math.round(clamp$1(_color2.b * 255, 0, 255));\n  }\n  getHexString(colorSpace \
= SRGBColorSpace2) {\n    return (\"000000\" + \
this.getHex(colorSpace).toString(16)).slice(-6);\n  }\n  getHSL(target, \
colorSpace = ColorManagement2.workingColorSpace) {\n    \
ColorManagement2.fromWorkingColorSpace(_color2.copy(this), colorSpace);\n    \
const r = _color2.r, g = _color2.g, b = _color2.b;\n    const max2 = \
Math.max(r, g, b);\n    const min2 = Math.min(r, g, b);\n    let hue, \
saturation;\n    const lightness = (min2 + max2) / 2;\n    if (min2 === max2) \
{\n      hue = 0;\n      saturation = 0;\n    } else {\n      const delta = \
max2 - min2;\n      saturation = lightness <= 0.5 ? delta / (max2 + min2) : \
delta / (2 - max2 - min2);\n      switch (max2) {\n        case r:\n          \
hue = (g - b) / delta + (g < b ? 6 : 0);\n          break;\n        case g:\n \
         hue = (b - r) / delta + 2;\n          break;\n        case b:\n      \
    hue = (r - g) / delta + 4;\n          break;\n      }\n      hue /= 6;\n  \
  }\n    target.h = hue;\n    target.s = saturation;\n    target.l = \
lightness;\n    return target;\n  }\n  getRGB(target, colorSpace = \
ColorManagement2.workingColorSpace) {\n    \
ColorManagement2.fromWorkingColorSpace(_color2.copy(this), colorSpace);\n    \
target.r = _color2.r;\n    target.g = _color2.g;\n    target.b = _color2.b;\n \
   return target;\n  }\n  getStyle(colorSpace = SRGBColorSpace2) {\n    \
ColorManagement2.fromWorkingColorSpace(_color2.copy(this), colorSpace);\n    \
const r = _color2.r, g = _color2.g, b = _color2.b;\n    if (colorSpace !== \
SRGBColorSpace2) {\n      return `color(${colorSpace} ${r.toFixed(3)} \
${g.toFixed(3)} ${b.toFixed(3)})`;\n    }\n    return `rgb(${Math.round(r * \
255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n  }\n  offsetHSL(h, \
s, l) {\n    this.getHSL(_hslA2);\n    return this.setHSL(_hslA2.h + h, \
_hslA2.s + s, _hslA2.l + l);\n  }\n  add(color2) {\n    this.r += color2.r;\n \
   this.g += color2.g;\n    this.b += color2.b;\n    return this;\n  }\n  \
addColors(color1, color2) {\n    this.r = color1.r + color2.r;\n    this.g = \
color1.g + color2.g;\n    this.b = color1.b + color2.b;\n    return this;\n  \
}\n  addScalar(s) {\n    this.r += s;\n    this.g += s;\n    this.b += s;\n   \
 return this;\n  }\n  sub(color2) {\n    this.r = Math.max(0, this.r - \
color2.r);\n    this.g = Math.max(0, this.g - color2.g);\n    this.b = \
Math.max(0, this.b - color2.b);\n    return this;\n  }\n  multiply(color2) \
{\n    this.r *= color2.r;\n    this.g *= color2.g;\n    this.b *= \
color2.b;\n    return this;\n  }\n  multiplyScalar(s) {\n    this.r *= s;\n   \
 this.g *= s;\n    this.b *= s;\n    return this;\n  }\n  lerp(color2, alpha) \
{\n    this.r += (color2.r - this.r) * alpha;\n    this.g += (color2.g - \
this.g) * alpha;\n    this.b += (color2.b - this.b) * alpha;\n    return \
this;\n  }\n  lerpColors(color1, color2, alpha) {\n    this.r = color1.r + \
(color2.r - color1.r) * alpha;\n    this.g = color1.g + (color2.g - color1.g) \
* alpha;\n    this.b = color1.b + (color2.b - color1.b) * alpha;\n    return \
this;\n  }\n  lerpHSL(color2, alpha) {\n    this.getHSL(_hslA2);\n    \
color2.getHSL(_hslB2);\n    const h = lerp2(_hslA2.h, _hslB2.h, alpha);\n    \
const s = lerp2(_hslA2.s, _hslB2.s, alpha);\n    const l = lerp2(_hslA2.l, \
_hslB2.l, alpha);\n    this.setHSL(h, s, l);\n    return this;\n  }\n  \
setFromVector3(v) {\n    this.r = v.x;\n    this.g = v.y;\n    this.b = \
v.z;\n    return this;\n  }\n  applyMatrix3(m2) {\n    const r = this.r, g = \
this.g, b = this.b;\n    const e = m2.elements;\n    this.r = e[0] * r + e[3] \
* g + e[6] * b;\n    this.g = e[1] * r + e[4] * g + e[7] * b;\n    this.b = \
e[2] * r + e[5] * g + e[8] * b;\n    return this;\n  }\n  equals(c2) {\n    \
return c2.r === this.r && c2.g === this.g && c2.b === this.b;\n  }\n  \
fromArray(array, offset = 0) {\n    this.r = array[offset];\n    this.g = \
array[offset + 1];\n    this.b = array[offset + 2];\n    return this;\n  }\n  \
toArray(array = [], offset = 0) {\n    array[offset] = this.r;\n    \
array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n    return \
array;\n  }\n  fromBufferAttribute(attribute2, index5) {\n    this.r = \
attribute2.getX(index5);\n    this.g = attribute2.getY(index5);\n    this.b = \
attribute2.getZ(index5);\n    return this;\n  }\n  toJSON() {\n    return \
this.getHex();\n  }\n  *[Symbol.iterator]() {\n    yield this.r;\n    yield \
this.g;\n    yield this.b;\n  }\n};\nvar _color2 = /* @__PURE__ */ new \
Color2();\nColor2.NAMES = _colorKeywords2;\nvar _materialId2 = 0;\nvar \
Material2 = class extends EventDispatcher2 {\n  static get type() {\n    \
return \"Material\";\n  }\n  get type() {\n    return \
this.constructor.type;\n  }\n  set type(_value) {\n  }\n  constructor() {\n   \
 super();\n    this.isMaterial = true;\n    Object.defineProperty(this, \
\"id\", { value: _materialId2++ });\n    this.uuid = generateUUID2();\n    \
this.name = \"\";\n    this.blending = NormalBlending2;\n    this.side = \
FrontSide2;\n    this.vertexColors = false;\n    this.opacity = 1;\n    \
this.transparent = false;\n    this.alphaHash = false;\n    this.blendSrc = \
SrcAlphaFactor2;\n    this.blendDst = OneMinusSrcAlphaFactor2;\n    \
this.blendEquation = AddEquation2;\n    this.blendSrcAlpha = null;\n    \
this.blendDstAlpha = null;\n    this.blendEquationAlpha = null;\n    \
this.blendColor = new Color2(0, 0, 0);\n    this.blendAlpha = 0;\n    \
this.depthFunc = LessEqualDepth2;\n    this.depthTest = true;\n    \
this.depthWrite = true;\n    this.stencilWriteMask = 255;\n    \
this.stencilFunc = AlwaysStencilFunc2;\n    this.stencilRef = 0;\n    \
this.stencilFuncMask = 255;\n    this.stencilFail = KeepStencilOp2;\n    \
this.stencilZFail = KeepStencilOp2;\n    this.stencilZPass = \
KeepStencilOp2;\n    this.stencilWrite = false;\n    this.clippingPlanes = \
null;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n    \
this.shadowSide = null;\n    this.colorWrite = true;\n    this.precision = \
null;\n    this.polygonOffset = false;\n    this.polygonOffsetFactor = 0;\n   \
 this.polygonOffsetUnits = 0;\n    this.dithering = false;\n    \
this.alphaToCoverage = false;\n    this.premultipliedAlpha = false;\n    \
this.forceSinglePass = false;\n    this.visible = true;\n    this.toneMapped \
= true;\n    this.userData = {};\n    this.version = 0;\n    this._alphaTest \
= 0;\n  }\n  get alphaTest() {\n    return this._alphaTest;\n  }\n  set \
alphaTest(value) {\n    if (this._alphaTest > 0 !== value > 0) {\n      \
this.version++;\n    }\n    this._alphaTest = value;\n  }\n  // \
onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n  \
onBeforeRender() {\n  }\n  onBeforeCompile() {\n  }\n  \
customProgramCacheKey() {\n    return this.onBeforeCompile.toString();\n  }\n \
 setValues(values) {\n    if (values === void 0) return;\n    for (const key \
in values) {\n      const newValue = values[key];\n      if (newValue === \
void 0) {\n        console.warn(`THREE.Material: parameter '${key}' has value \
of undefined.`);\n        continue;\n      }\n      const currentValue = \
this[key];\n      if (currentValue === void 0) {\n        \
console.warn(`THREE.Material: '${key}' is not a property of \
THREE.${this.type}.`);\n        continue;\n      }\n      if (currentValue && \
currentValue.isColor) {\n        currentValue.set(newValue);\n      } else if \
(currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) \
{\n        currentValue.copy(newValue);\n      } else {\n        this[key] = \
newValue;\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRootObject = \
meta === void 0 || typeof meta === \"string\";\n    if (isRootObject) {\n     \
 meta = {\n        textures: {},\n        images: {}\n      };\n    }\n    \
const data = {\n      metadata: {\n        version: 4.6,\n        type: \
\"Material\",\n        generator: \"Material.toJSON\"\n      }\n    };\n    \
data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \
\"\") data.name = this.name;\n    if (this.color && this.color.isColor) \
data.color = this.color.getHex();\n    if (this.roughness !== void 0) \
data.roughness = this.roughness;\n    if (this.metalness !== void 0) \
data.metalness = this.metalness;\n    if (this.sheen !== void 0) data.sheen = \
this.sheen;\n    if (this.sheenColor && this.sheenColor.isColor) \
data.sheenColor = this.sheenColor.getHex();\n    if (this.sheenRoughness !== \
void 0) data.sheenRoughness = this.sheenRoughness;\n    if (this.emissive && \
this.emissive.isColor) data.emissive = this.emissive.getHex();\n    if \
(this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) \
data.emissiveIntensity = this.emissiveIntensity;\n    if (this.specular && \
this.specular.isColor) data.specular = this.specular.getHex();\n    if \
(this.specularIntensity !== void 0) data.specularIntensity = \
this.specularIntensity;\n    if (this.specularColor && \
this.specularColor.isColor) data.specularColor = \
this.specularColor.getHex();\n    if (this.shininess !== void 0) \
data.shininess = this.shininess;\n    if (this.clearcoat !== void 0) \
data.clearcoat = this.clearcoat;\n    if (this.clearcoatRoughness !== void 0) \
data.clearcoatRoughness = this.clearcoatRoughness;\n    if (this.clearcoatMap \
&& this.clearcoatMap.isTexture) {\n      data.clearcoatMap = \
this.clearcoatMap.toJSON(meta).uuid;\n    }\n    if \
(this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n      \
data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n  \
  }\n    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) \
{\n      data.clearcoatNormalMap = \
this.clearcoatNormalMap.toJSON(meta).uuid;\n      data.clearcoatNormalScale = \
this.clearcoatNormalScale.toArray();\n    }\n    if (this.dispersion !== void \
0) data.dispersion = this.dispersion;\n    if (this.iridescence !== void 0) \
data.iridescence = this.iridescence;\n    if (this.iridescenceIOR !== void 0) \
data.iridescenceIOR = this.iridescenceIOR;\n    if \
(this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = \
this.iridescenceThicknessRange;\n    if (this.iridescenceMap && \
this.iridescenceMap.isTexture) {\n      data.iridescenceMap = \
this.iridescenceMap.toJSON(meta).uuid;\n    }\n    if \
(this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n  \
    data.iridescenceThicknessMap = \
this.iridescenceThicknessMap.toJSON(meta).uuid;\n    }\n    if \
(this.anisotropy !== void 0) data.anisotropy = this.anisotropy;\n    if \
(this.anisotropyRotation !== void 0) data.anisotropyRotation = \
this.anisotropyRotation;\n    if (this.anisotropyMap && \
this.anisotropyMap.isTexture) {\n      data.anisotropyMap = \
this.anisotropyMap.toJSON(meta).uuid;\n    }\n    if (this.map && \
this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n    if \
(this.matcap && this.matcap.isTexture) data.matcap = \
this.matcap.toJSON(meta).uuid;\n    if (this.alphaMap && \
this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n   \
 if (this.lightMap && this.lightMap.isTexture) {\n      data.lightMap = \
this.lightMap.toJSON(meta).uuid;\n      data.lightMapIntensity = \
this.lightMapIntensity;\n    }\n    if (this.aoMap && this.aoMap.isTexture) \
{\n      data.aoMap = this.aoMap.toJSON(meta).uuid;\n      \
data.aoMapIntensity = this.aoMapIntensity;\n    }\n    if (this.bumpMap && \
this.bumpMap.isTexture) {\n      data.bumpMap = \
this.bumpMap.toJSON(meta).uuid;\n      data.bumpScale = this.bumpScale;\n    \
}\n    if (this.normalMap && this.normalMap.isTexture) {\n      \
data.normalMap = this.normalMap.toJSON(meta).uuid;\n      data.normalMapType \
= this.normalMapType;\n      data.normalScale = this.normalScale.toArray();\n \
   }\n    if (this.displacementMap && this.displacementMap.isTexture) {\n     \
 data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n      \
data.displacementScale = this.displacementScale;\n      data.displacementBias \
= this.displacementBias;\n    }\n    if (this.roughnessMap && \
this.roughnessMap.isTexture) data.roughnessMap = \
this.roughnessMap.toJSON(meta).uuid;\n    if (this.metalnessMap && \
this.metalnessMap.isTexture) data.metalnessMap = \
this.metalnessMap.toJSON(meta).uuid;\n    if (this.emissiveMap && \
this.emissiveMap.isTexture) data.emissiveMap = \
this.emissiveMap.toJSON(meta).uuid;\n    if (this.specularMap && \
this.specularMap.isTexture) data.specularMap = \
this.specularMap.toJSON(meta).uuid;\n    if (this.specularIntensityMap && \
this.specularIntensityMap.isTexture) data.specularIntensityMap = \
this.specularIntensityMap.toJSON(meta).uuid;\n    if (this.specularColorMap \
&& this.specularColorMap.isTexture) data.specularColorMap = \
this.specularColorMap.toJSON(meta).uuid;\n    if (this.envMap && \
this.envMap.isTexture) {\n      data.envMap = \
this.envMap.toJSON(meta).uuid;\n      if (this.combine !== void 0) \
data.combine = this.combine;\n    }\n    if (this.envMapRotation !== void 0) \
data.envMapRotation = this.envMapRotation.toArray();\n    if \
(this.envMapIntensity !== void 0) data.envMapIntensity = \
this.envMapIntensity;\n    if (this.reflectivity !== void 0) \
data.reflectivity = this.reflectivity;\n    if (this.refractionRatio !== void \
0) data.refractionRatio = this.refractionRatio;\n    if (this.gradientMap && \
this.gradientMap.isTexture) {\n      data.gradientMap = \
this.gradientMap.toJSON(meta).uuid;\n    }\n    if (this.transmission !== \
void 0) data.transmission = this.transmission;\n    if (this.transmissionMap \
&& this.transmissionMap.isTexture) data.transmissionMap = \
this.transmissionMap.toJSON(meta).uuid;\n    if (this.thickness !== void 0) \
data.thickness = this.thickness;\n    if (this.thicknessMap && \
this.thicknessMap.isTexture) data.thicknessMap = \
this.thicknessMap.toJSON(meta).uuid;\n    if (this.attenuationDistance !== \
void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = \
this.attenuationDistance;\n    if (this.attenuationColor !== void 0) \
data.attenuationColor = this.attenuationColor.getHex();\n    if (this.size \
!== void 0) data.size = this.size;\n    if (this.shadowSide !== null) \
data.shadowSide = this.shadowSide;\n    if (this.sizeAttenuation !== void 0) \
data.sizeAttenuation = this.sizeAttenuation;\n    if (this.blending !== \
NormalBlending2) data.blending = this.blending;\n    if (this.side !== \
FrontSide2) data.side = this.side;\n    if (this.vertexColors === true) \
data.vertexColors = true;\n    if (this.opacity < 1) data.opacity = \
this.opacity;\n    if (this.transparent === true) data.transparent = true;\n  \
  if (this.blendSrc !== SrcAlphaFactor2) data.blendSrc = this.blendSrc;\n    \
if (this.blendDst !== OneMinusSrcAlphaFactor2) data.blendDst = \
this.blendDst;\n    if (this.blendEquation !== AddEquation2) \
data.blendEquation = this.blendEquation;\n    if (this.blendSrcAlpha !== \
null) data.blendSrcAlpha = this.blendSrcAlpha;\n    if (this.blendDstAlpha \
!== null) data.blendDstAlpha = this.blendDstAlpha;\n    if \
(this.blendEquationAlpha !== null) data.blendEquationAlpha = \
this.blendEquationAlpha;\n    if (this.blendColor && this.blendColor.isColor) \
data.blendColor = this.blendColor.getHex();\n    if (this.blendAlpha !== 0) \
data.blendAlpha = this.blendAlpha;\n    if (this.depthFunc !== \
LessEqualDepth2) data.depthFunc = this.depthFunc;\n    if (this.depthTest === \
false) data.depthTest = this.depthTest;\n    if (this.depthWrite === false) \
data.depthWrite = this.depthWrite;\n    if (this.colorWrite === false) \
data.colorWrite = this.colorWrite;\n    if (this.stencilWriteMask !== 255) \
data.stencilWriteMask = this.stencilWriteMask;\n    if (this.stencilFunc !== \
AlwaysStencilFunc2) data.stencilFunc = this.stencilFunc;\n    if \
(this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n    if \
(this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;\n \
   if (this.stencilFail !== KeepStencilOp2) data.stencilFail = \
this.stencilFail;\n    if (this.stencilZFail !== KeepStencilOp2) \
data.stencilZFail = this.stencilZFail;\n    if (this.stencilZPass !== \
KeepStencilOp2) data.stencilZPass = this.stencilZPass;\n    if \
(this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n    if \
(this.rotation !== void 0 && this.rotation !== 0) data.rotation = \
this.rotation;\n    if (this.polygonOffset === true) data.polygonOffset = \
true;\n    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = \
this.polygonOffsetFactor;\n    if (this.polygonOffsetUnits !== 0) \
data.polygonOffsetUnits = this.polygonOffsetUnits;\n    if (this.linewidth \
!== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;\n    if \
(this.dashSize !== void 0) data.dashSize = this.dashSize;\n    if \
(this.gapSize !== void 0) data.gapSize = this.gapSize;\n    if (this.scale \
!== void 0) data.scale = this.scale;\n    if (this.dithering === true) \
data.dithering = true;\n    if (this.alphaTest > 0) data.alphaTest = \
this.alphaTest;\n    if (this.alphaHash === true) data.alphaHash = true;\n    \
if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n    if \
(this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n    if \
(this.forceSinglePass === true) data.forceSinglePass = true;\n    if \
(this.wireframe === true) data.wireframe = true;\n    if \
(this.wireframeLinewidth > 1) data.wireframeLinewidth = \
this.wireframeLinewidth;\n    if (this.wireframeLinecap !== \"round\") \
data.wireframeLinecap = this.wireframeLinecap;\n    if \
(this.wireframeLinejoin !== \"round\") data.wireframeLinejoin = \
this.wireframeLinejoin;\n    if (this.flatShading === true) data.flatShading \
= true;\n    if (this.visible === false) data.visible = false;\n    if \
(this.toneMapped === false) data.toneMapped = false;\n    if (this.fog === \
false) data.fog = false;\n    if (Object.keys(this.userData).length > 0) \
data.userData = this.userData;\n    function extractFromCache(cache2) {\n     \
 const values = [];\n      for (const key in cache2) {\n        const data2 = \
cache2[key];\n        delete data2.metadata;\n        values.push(data2);\n   \
   }\n      return values;\n    }\n    if (isRootObject) {\n      const \
textures = extractFromCache(meta.textures);\n      const images = \
extractFromCache(meta.images);\n      if (textures.length > 0) data.textures \
= textures;\n      if (images.length > 0) data.images = images;\n    }\n    \
return data;\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n  copy(source) {\n    this.name = \
source.name;\n    this.blending = source.blending;\n    this.side = \
source.side;\n    this.vertexColors = source.vertexColors;\n    this.opacity \
= source.opacity;\n    this.transparent = source.transparent;\n    \
this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    \
this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = \
source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    \
this.blendEquationAlpha = source.blendEquationAlpha;\n    \
this.blendColor.copy(source.blendColor);\n    this.blendAlpha = \
source.blendAlpha;\n    this.depthFunc = source.depthFunc;\n    \
this.depthTest = source.depthTest;\n    this.depthWrite = \
source.depthWrite;\n    this.stencilWriteMask = source.stencilWriteMask;\n    \
this.stencilFunc = source.stencilFunc;\n    this.stencilRef = \
source.stencilRef;\n    this.stencilFuncMask = source.stencilFuncMask;\n    \
this.stencilFail = source.stencilFail;\n    this.stencilZFail = \
source.stencilZFail;\n    this.stencilZPass = source.stencilZPass;\n    \
this.stencilWrite = source.stencilWrite;\n    const srcPlanes = \
source.clippingPlanes;\n    let dstPlanes = null;\n    if (srcPlanes !== \
null) {\n      const n = srcPlanes.length;\n      dstPlanes = new Array(n);\n \
     for (let i = 0; i !== n; ++i) {\n        dstPlanes[i] = \
srcPlanes[i].clone();\n      }\n    }\n    this.clippingPlanes = dstPlanes;\n \
   this.clipIntersection = source.clipIntersection;\n    this.clipShadows = \
source.clipShadows;\n    this.shadowSide = source.shadowSide;\n    \
this.colorWrite = source.colorWrite;\n    this.precision = \
source.precision;\n    this.polygonOffset = source.polygonOffset;\n    \
this.polygonOffsetFactor = source.polygonOffsetFactor;\n    \
this.polygonOffsetUnits = source.polygonOffsetUnits;\n    this.dithering = \
source.dithering;\n    this.alphaTest = source.alphaTest;\n    this.alphaHash \
= source.alphaHash;\n    this.alphaToCoverage = source.alphaToCoverage;\n    \
this.premultipliedAlpha = source.premultipliedAlpha;\n    \
this.forceSinglePass = source.forceSinglePass;\n    this.visible = \
source.visible;\n    this.toneMapped = source.toneMapped;\n    this.userData \
= JSON.parse(JSON.stringify(source.userData));\n    return this;\n  }\n  \
dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n  set \
needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  \
onBuild() {\n    console.warn(\"Material: onBuild() has been removed.\");\n  \
}\n};\nvar MeshBasicMaterial2 = class extends Material2 {\n  static get \
type() {\n    return \"MeshBasicMaterial\";\n  }\n  constructor(parameters) \
{\n    super();\n    this.isMeshBasicMaterial = true;\n    this.color = new \
Color2(16777215);\n    this.map = null;\n    this.lightMap = null;\n    \
this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity \
= 1;\n    this.specularMap = null;\n    this.alphaMap = null;\n    \
this.envMap = null;\n    this.envMapRotation = new Euler2();\n    \
this.combine = MultiplyOperation2;\n    this.reflectivity = 1;\n    \
this.refractionRatio = 0.98;\n    this.wireframe = false;\n    \
this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    \
this.wireframeLinejoin = \"round\";\n    this.fog = true;\n    \
this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n \
   this.color.copy(source.color);\n    this.map = source.map;\n    \
this.lightMap = source.lightMap;\n    this.lightMapIntensity = \
source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    \
this.aoMapIntensity = source.aoMapIntensity;\n    this.specularMap = \
source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = \
source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    \
this.combine = source.combine;\n    this.reflectivity = \
source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    \
this.wireframe = source.wireframe;\n    this.wireframeLinewidth = \
source.wireframeLinewidth;\n    this.wireframeLinecap = \
source.wireframeLinecap;\n    this.wireframeLinejoin = \
source.wireframeLinejoin;\n    this.fog = source.fog;\n    return this;\n  \
}\n};\nvar _tables = /* @__PURE__ */ _generateTables();\nfunction \
_generateTables() {\n  const buffer2 = new ArrayBuffer(4);\n  const floatView \
= new Float32Array(buffer2);\n  const uint32View = new \
Uint32Array(buffer2);\n  const baseTable = new Uint32Array(512);\n  const \
shiftTable = new Uint32Array(512);\n  for (let i = 0; i < 256; ++i) {\n    \
const e = i - 127;\n    if (e < -27) {\n      baseTable[i] = 0;\n      \
baseTable[i | 256] = 32768;\n      shiftTable[i] = 24;\n      shiftTable[i | \
256] = 24;\n    } else if (e < -14) {\n      baseTable[i] = 1024 >> -e - \
14;\n      baseTable[i | 256] = 1024 >> -e - 14 | 32768;\n      shiftTable[i] \
= -e - 1;\n      shiftTable[i | 256] = -e - 1;\n    } else if (e <= 15) {\n   \
   baseTable[i] = e + 15 << 10;\n      baseTable[i | 256] = e + 15 << 10 | \
32768;\n      shiftTable[i] = 13;\n      shiftTable[i | 256] = 13;\n    } \
else if (e < 128) {\n      baseTable[i] = 31744;\n      baseTable[i | 256] = \
64512;\n      shiftTable[i] = 24;\n      shiftTable[i | 256] = 24;\n    } \
else {\n      baseTable[i] = 31744;\n      baseTable[i | 256] = 64512;\n      \
shiftTable[i] = 13;\n      shiftTable[i | 256] = 13;\n    }\n  }\n  const \
mantissaTable = new Uint32Array(2048);\n  const exponentTable = new \
Uint32Array(64);\n  const offsetTable = new Uint32Array(64);\n  for (let i = \
1; i < 1024; ++i) {\n    let m2 = i << 13;\n    let e = 0;\n    while ((m2 & \
8388608) === 0) {\n      m2 <<= 1;\n      e -= 8388608;\n    }\n    m2 &= \
~8388608;\n    e += 947912704;\n    mantissaTable[i] = m2 | e;\n  }\n  for \
(let i = 1024; i < 2048; ++i) {\n    mantissaTable[i] = 939524096 + (i - 1024 \
<< 13);\n  }\n  for (let i = 1; i < 31; ++i) {\n    exponentTable[i] = i << \
23;\n  }\n  exponentTable[31] = 1199570944;\n  exponentTable[32] = \
2147483648;\n  for (let i = 33; i < 63; ++i) {\n    exponentTable[i] = \
2147483648 + (i - 32 << 23);\n  }\n  exponentTable[63] = 3347054592;\n  for \
(let i = 1; i < 64; ++i) {\n    if (i !== 32) {\n      offsetTable[i] = \
1024;\n    }\n  }\n  return {\n    floatView,\n    uint32View,\n    \
baseTable,\n    shiftTable,\n    mantissaTable,\n    exponentTable,\n    \
offsetTable\n  };\n}\nfunction toHalfFloat(val) {\n  if (Math.abs(val) > \
65504) console.warn(\"THREE.DataUtils.toHalfFloat(): Value out of \
range.\");\n  val = clamp$1(val, -65504, 65504);\n  _tables.floatView[0] = \
val;\n  const f = _tables.uint32View[0];\n  const e = f >> 23 & 511;\n  \
return _tables.baseTable[e] + ((f & 8388607) >> \
_tables.shiftTable[e]);\n}\nfunction fromHalfFloat(val) {\n  const m2 = val \
>> 10;\n  _tables.uint32View[0] = \
_tables.mantissaTable[_tables.offsetTable[m2] + (val & 1023)] + \
_tables.exponentTable[m2];\n  return _tables.floatView[0];\n}\nvar _vector$92 \
= /* @__PURE__ */ new Vector32();\nvar _vector2$12 = /* @__PURE__ */ new \
Vector22();\nvar BufferAttribute2 = class {\n  constructor(array, itemSize, \
normalized = false) {\n    if (Array.isArray(array)) {\n      throw new \
TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");\n    \
}\n    this.isBufferAttribute = true;\n    this.name = \"\";\n    this.array \
= array;\n    this.itemSize = itemSize;\n    this.count = array !== void 0 ? \
array.length / itemSize : 0;\n    this.normalized = normalized;\n    \
this.usage = StaticDrawUsage2;\n    this.updateRanges = [];\n    this.gpuType \
= FloatType2;\n    this.version = 0;\n  }\n  onUploadCallback() {\n  }\n  set \
needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  \
setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n  \
addUpdateRange(start, count) {\n    this.updateRanges.push({ start, count \
});\n  }\n  clearUpdateRanges() {\n    this.updateRanges.length = 0;\n  }\n  \
copy(source) {\n    this.name = source.name;\n    this.array = new \
source.array.constructor(source.array);\n    this.itemSize = \
source.itemSize;\n    this.count = source.count;\n    this.normalized = \
source.normalized;\n    this.usage = source.usage;\n    this.gpuType = \
source.gpuType;\n    return this;\n  }\n  copyAt(index1, attribute2, index22) \
{\n    index1 *= this.itemSize;\n    index22 *= attribute2.itemSize;\n    for \
(let i = 0, l = this.itemSize; i < l; i++) {\n      this.array[index1 + i] = \
attribute2.array[index22 + i];\n    }\n    return this;\n  }\n  \
copyArray(array) {\n    this.array.set(array);\n    return this;\n  }\n  \
applyMatrix3(m2) {\n    if (this.itemSize === 2) {\n      for (let i = 0, l = \
this.count; i < l; i++) {\n        _vector2$12.fromBufferAttribute(this, \
i);\n        _vector2$12.applyMatrix3(m2);\n        this.setXY(i, \
_vector2$12.x, _vector2$12.y);\n      }\n    } else if (this.itemSize === 3) \
{\n      for (let i = 0, l = this.count; i < l; i++) {\n        \
_vector$92.fromBufferAttribute(this, i);\n        \
_vector$92.applyMatrix3(m2);\n        this.setXYZ(i, _vector$92.x, \
_vector$92.y, _vector$92.z);\n      }\n    }\n    return this;\n  }\n  \
applyMatrix4(m2) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      \
_vector$92.fromBufferAttribute(this, i);\n      \
_vector$92.applyMatrix4(m2);\n      this.setXYZ(i, _vector$92.x, \
_vector$92.y, _vector$92.z);\n    }\n    return this;\n  }\n  \
applyNormalMatrix(m2) {\n    for (let i = 0, l = this.count; i < l; i++) {\n  \
    _vector$92.fromBufferAttribute(this, i);\n      \
_vector$92.applyNormalMatrix(m2);\n      this.setXYZ(i, _vector$92.x, \
_vector$92.y, _vector$92.z);\n    }\n    return this;\n  }\n  \
transformDirection(m2) {\n    for (let i = 0, l = this.count; i < l; i++) {\n \
     _vector$92.fromBufferAttribute(this, i);\n      \
_vector$92.transformDirection(m2);\n      this.setXYZ(i, _vector$92.x, \
_vector$92.y, _vector$92.z);\n    }\n    return this;\n  }\n  set(value, \
offset = 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n  \
getComponent(index5, component) {\n    let value = this.array[index5 * \
this.itemSize + component];\n    if (this.normalized) value = \
denormalize2(value, this.array);\n    return value;\n  }\n  \
setComponent(index5, component, value) {\n    if (this.normalized) value = \
normalize$1(value, this.array);\n    this.array[index5 * this.itemSize + \
component] = value;\n    return this;\n  }\n  getX(index5) {\n    let x2 = \
this.array[index5 * this.itemSize];\n    if (this.normalized) x2 = \
denormalize2(x2, this.array);\n    return x2;\n  }\n  setX(index5, x2) {\n    \
if (this.normalized) x2 = normalize$1(x2, this.array);\n    this.array[index5 \
* this.itemSize] = x2;\n    return this;\n  }\n  getY(index5) {\n    let y2 = \
this.array[index5 * this.itemSize + 1];\n    if (this.normalized) y2 = \
denormalize2(y2, this.array);\n    return y2;\n  }\n  setY(index5, y2) {\n    \
if (this.normalized) y2 = normalize$1(y2, this.array);\n    this.array[index5 \
* this.itemSize + 1] = y2;\n    return this;\n  }\n  getZ(index5) {\n    let \
z2 = this.array[index5 * this.itemSize + 2];\n    if (this.normalized) z2 = \
denormalize2(z2, this.array);\n    return z2;\n  }\n  setZ(index5, z2) {\n    \
if (this.normalized) z2 = normalize$1(z2, this.array);\n    this.array[index5 \
* this.itemSize + 2] = z2;\n    return this;\n  }\n  getW(index5) {\n    let \
w = this.array[index5 * this.itemSize + 3];\n    if (this.normalized) w = \
denormalize2(w, this.array);\n    return w;\n  }\n  setW(index5, w) {\n    if \
(this.normalized) w = normalize$1(w, this.array);\n    this.array[index5 * \
this.itemSize + 3] = w;\n    return this;\n  }\n  setXY(index5, x2, y2) {\n   \
 index5 *= this.itemSize;\n    if (this.normalized) {\n      x2 = \
normalize$1(x2, this.array);\n      y2 = normalize$1(y2, this.array);\n    \
}\n    this.array[index5 + 0] = x2;\n    this.array[index5 + 1] = y2;\n    \
return this;\n  }\n  setXYZ(index5, x2, y2, z2) {\n    index5 *= \
this.itemSize;\n    if (this.normalized) {\n      x2 = normalize$1(x2, \
this.array);\n      y2 = normalize$1(y2, this.array);\n      z2 = \
normalize$1(z2, this.array);\n    }\n    this.array[index5 + 0] = x2;\n    \
this.array[index5 + 1] = y2;\n    this.array[index5 + 2] = z2;\n    return \
this;\n  }\n  setXYZW(index5, x2, y2, z2, w) {\n    index5 *= \
this.itemSize;\n    if (this.normalized) {\n      x2 = normalize$1(x2, \
this.array);\n      y2 = normalize$1(y2, this.array);\n      z2 = \
normalize$1(z2, this.array);\n      w = normalize$1(w, this.array);\n    }\n  \
  this.array[index5 + 0] = x2;\n    this.array[index5 + 1] = y2;\n    \
this.array[index5 + 2] = z2;\n    this.array[index5 + 3] = w;\n    return \
this;\n  }\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n   \
 return this;\n  }\n  clone() {\n    return new this.constructor(this.array, \
this.itemSize).copy(this);\n  }\n  toJSON() {\n    const data = {\n      \
itemSize: this.itemSize,\n      type: this.array.constructor.name,\n      \
array: Array.from(this.array),\n      normalized: this.normalized\n    };\n   \
 if (this.name !== \"\") data.name = this.name;\n    if (this.usage !== \
StaticDrawUsage2) data.usage = this.usage;\n    return data;\n  }\n};\nvar \
Uint16BufferAttribute2 = class extends BufferAttribute2 {\n  \
constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), \
itemSize, normalized);\n  }\n};\nvar Uint32BufferAttribute2 = class extends \
BufferAttribute2 {\n  constructor(array, itemSize, normalized) {\n    \
super(new Uint32Array(array), itemSize, normalized);\n  }\n};\nvar \
Float16BufferAttribute = class extends BufferAttribute2 {\n  \
constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), \
itemSize, normalized);\n    this.isFloat16BufferAttribute = true;\n  }\n  \
getX(index5) {\n    let x2 = fromHalfFloat(this.array[index5 * \
this.itemSize]);\n    if (this.normalized) x2 = denormalize2(x2, \
this.array);\n    return x2;\n  }\n  setX(index5, x2) {\n    if \
(this.normalized) x2 = normalize$1(x2, this.array);\n    this.array[index5 * \
this.itemSize] = toHalfFloat(x2);\n    return this;\n  }\n  getY(index5) {\n  \
  let y2 = fromHalfFloat(this.array[index5 * this.itemSize + 1]);\n    if \
(this.normalized) y2 = denormalize2(y2, this.array);\n    return y2;\n  }\n  \
setY(index5, y2) {\n    if (this.normalized) y2 = normalize$1(y2, \
this.array);\n    this.array[index5 * this.itemSize + 1] = toHalfFloat(y2);\n \
   return this;\n  }\n  getZ(index5) {\n    let z2 = \
fromHalfFloat(this.array[index5 * this.itemSize + 2]);\n    if \
(this.normalized) z2 = denormalize2(z2, this.array);\n    return z2;\n  }\n  \
setZ(index5, z2) {\n    if (this.normalized) z2 = normalize$1(z2, \
this.array);\n    this.array[index5 * this.itemSize + 2] = toHalfFloat(z2);\n \
   return this;\n  }\n  getW(index5) {\n    let w = \
fromHalfFloat(this.array[index5 * this.itemSize + 3]);\n    if \
(this.normalized) w = denormalize2(w, this.array);\n    return w;\n  }\n  \
setW(index5, w) {\n    if (this.normalized) w = normalize$1(w, this.array);\n \
   this.array[index5 * this.itemSize + 3] = toHalfFloat(w);\n    return \
this;\n  }\n  setXY(index5, x2, y2) {\n    index5 *= this.itemSize;\n    if \
(this.normalized) {\n      x2 = normalize$1(x2, this.array);\n      y2 = \
normalize$1(y2, this.array);\n    }\n    this.array[index5 + 0] = \
toHalfFloat(x2);\n    this.array[index5 + 1] = toHalfFloat(y2);\n    return \
this;\n  }\n  setXYZ(index5, x2, y2, z2) {\n    index5 *= this.itemSize;\n    \
if (this.normalized) {\n      x2 = normalize$1(x2, this.array);\n      y2 = \
normalize$1(y2, this.array);\n      z2 = normalize$1(z2, this.array);\n    \
}\n    this.array[index5 + 0] = toHalfFloat(x2);\n    this.array[index5 + 1] \
= toHalfFloat(y2);\n    this.array[index5 + 2] = toHalfFloat(z2);\n    return \
this;\n  }\n  setXYZW(index5, x2, y2, z2, w) {\n    index5 *= \
this.itemSize;\n    if (this.normalized) {\n      x2 = normalize$1(x2, \
this.array);\n      y2 = normalize$1(y2, this.array);\n      z2 = \
normalize$1(z2, this.array);\n      w = normalize$1(w, this.array);\n    }\n  \
  this.array[index5 + 0] = toHalfFloat(x2);\n    this.array[index5 + 1] = \
toHalfFloat(y2);\n    this.array[index5 + 2] = toHalfFloat(z2);\n    \
this.array[index5 + 3] = toHalfFloat(w);\n    return this;\n  }\n};\nvar \
Float32BufferAttribute2 = class extends BufferAttribute2 {\n  \
constructor(array, itemSize, normalized) {\n    super(new \
Float32Array(array), itemSize, normalized);\n  }\n};\nvar _id$9 = 0;\nvar \
_m1$12 = /* @__PURE__ */ new Matrix42();\nvar _obj2 = /* @__PURE__ */ new \
Object3D2();\nvar _offset3 = /* @__PURE__ */ new Vector32();\nvar _box$22 = \
/* @__PURE__ */ new Box32();\nvar _boxMorphTargets2 = /* @__PURE__ */ new \
Box32();\nvar _vector$82 = /* @__PURE__ */ new Vector32();\nvar \
BufferGeometry2 = class _BufferGeometry extends EventDispatcher2 {\n  \
constructor() {\n    super();\n    this.isBufferGeometry = true;\n    \
Object.defineProperty(this, \"id\", { value: _id$9++ });\n    this.uuid = \
generateUUID2();\n    this.name = \"\";\n    this.type = \
\"BufferGeometry\";\n    this.index = null;\n    this.indirect = null;\n    \
this.attributes = {};\n    this.morphAttributes = {};\n    \
this.morphTargetsRelative = false;\n    this.groups = [];\n    \
this.boundingBox = null;\n    this.boundingSphere = null;\n    this.drawRange \
= { start: 0, count: Infinity };\n    this.userData = {};\n  }\n  getIndex() \
{\n    return this.index;\n  }\n  setIndex(index5) {\n    if \
(Array.isArray(index5)) {\n      this.index = new (arrayNeedsUint32$1(index5) \
? Uint32BufferAttribute2 : Uint16BufferAttribute2)(index5, 1);\n    } else \
{\n      this.index = index5;\n    }\n    return this;\n  }\n  \
setIndirect(indirect) {\n    this.indirect = indirect;\n    return this;\n  \
}\n  getIndirect() {\n    return this.indirect;\n  }\n  getAttribute(name) \
{\n    return this.attributes[name];\n  }\n  setAttribute(name, attribute2) \
{\n    this.attributes[name] = attribute2;\n    return this;\n  }\n  \
deleteAttribute(name) {\n    delete this.attributes[name];\n    return \
this;\n  }\n  hasAttribute(name) {\n    return this.attributes[name] !== void \
0;\n  }\n  addGroup(start, count, materialIndex = 0) {\n    \
this.groups.push({\n      start,\n      count,\n      materialIndex\n    \
});\n  }\n  clearGroups() {\n    this.groups = [];\n  }\n  \
setDrawRange(start, count) {\n    this.drawRange.start = start;\n    \
this.drawRange.count = count;\n  }\n  applyMatrix4(matrix) {\n    const \
position = this.attributes.position;\n    if (position !== void 0) {\n      \
position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n   \
 const normal2 = this.attributes.normal;\n    if (normal2 !== void 0) {\n     \
 const normalMatrix = new Matrix32().getNormalMatrix(matrix);\n      \
normal2.applyNormalMatrix(normalMatrix);\n      normal2.needsUpdate = true;\n \
   }\n    const tangent = this.attributes.tangent;\n    if (tangent !== void \
0) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = \
true;\n    }\n    if (this.boundingBox !== null) {\n      \
this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n  \
    this.computeBoundingSphere();\n    }\n    return this;\n  }\n  \
applyQuaternion(q) {\n    _m1$12.makeRotationFromQuaternion(q);\n    \
this.applyMatrix4(_m1$12);\n    return this;\n  }\n  rotateX(angle) {\n    \
_m1$12.makeRotationX(angle);\n    this.applyMatrix4(_m1$12);\n    return \
this;\n  }\n  rotateY(angle) {\n    _m1$12.makeRotationY(angle);\n    \
this.applyMatrix4(_m1$12);\n    return this;\n  }\n  rotateZ(angle) {\n    \
_m1$12.makeRotationZ(angle);\n    this.applyMatrix4(_m1$12);\n    return \
this;\n  }\n  translate(x2, y2, z2) {\n    _m1$12.makeTranslation(x2, y2, \
z2);\n    this.applyMatrix4(_m1$12);\n    return this;\n  }\n  scale(x2, y2, \
z2) {\n    _m1$12.makeScale(x2, y2, z2);\n    this.applyMatrix4(_m1$12);\n    \
return this;\n  }\n  lookAt(vector) {\n    _obj2.lookAt(vector);\n    \
_obj2.updateMatrix();\n    this.applyMatrix4(_obj2.matrix);\n    return \
this;\n  }\n  center() {\n    this.computeBoundingBox();\n    \
this.boundingBox.getCenter(_offset3).negate();\n    \
this.translate(_offset3.x, _offset3.y, _offset3.z);\n    return this;\n  }\n  \
setFromPoints(points) {\n    const positionAttribute = \
this.getAttribute(\"position\");\n    if (positionAttribute === void 0) {\n   \
   const position = [];\n      for (let i = 0, l = points.length; i < l; i++) \
{\n        const point = points[i];\n        position.push(point.x, point.y, \
point.z || 0);\n      }\n      this.setAttribute(\"position\", new \
Float32BufferAttribute2(position, 3));\n    } else {\n      for (let i = 0, l \
= positionAttribute.count; i < l; i++) {\n        const point = points[i];\n  \
      positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);\n      }\n \
     if (points.length > positionAttribute.count) {\n        \
console.warn(\"THREE.BufferGeometry: Buffer size too small for points data. \
Use .dispose() and create a new geometry.\");\n      }\n      \
positionAttribute.needsUpdate = true;\n    }\n    return this;\n  }\n  \
computeBoundingBox() {\n    if (this.boundingBox === null) {\n      \
this.boundingBox = new Box32();\n    }\n    const position = \
this.attributes.position;\n    const morphAttributesPosition = \
this.morphAttributes.position;\n    if (position && \
position.isGLBufferAttribute) {\n      \
console.error(\"THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute \
requires a manual bounding box.\", this);\n      this.boundingBox.set(\n      \
  new Vector32(-Infinity, -Infinity, -Infinity),\n        new \
Vector32(Infinity, Infinity, Infinity)\n      );\n      return;\n    }\n    \
if (position !== void 0) {\n      \
this.boundingBox.setFromBufferAttribute(position);\n      if \
(morphAttributesPosition) {\n        for (let i = 0, il = \
morphAttributesPosition.length; i < il; i++) {\n          const \
morphAttribute = morphAttributesPosition[i];\n          \
_box$22.setFromBufferAttribute(morphAttribute);\n          if \
(this.morphTargetsRelative) {\n            \
_vector$82.addVectors(this.boundingBox.min, _box$22.min);\n            \
this.boundingBox.expandByPoint(_vector$82);\n            \
_vector$82.addVectors(this.boundingBox.max, _box$22.max);\n            \
this.boundingBox.expandByPoint(_vector$82);\n          } else {\n            \
this.boundingBox.expandByPoint(_box$22.min);\n            \
this.boundingBox.expandByPoint(_box$22.max);\n          }\n        }\n      \
}\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n    if \
(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || \
isNaN(this.boundingBox.min.z)) {\n      \
console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max \
have NaN values. The \"position\" attribute is likely to have NaN values.', \
this);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere \
=== null) {\n      this.boundingSphere = new Sphere2();\n    }\n    const \
position = this.attributes.position;\n    const morphAttributesPosition = \
this.morphAttributes.position;\n    if (position && \
position.isGLBufferAttribute) {\n      \
console.error(\"THREE.BufferGeometry.computeBoundingSphere(): \
GLBufferAttribute requires a manual bounding sphere.\", this);\n      \
this.boundingSphere.set(new Vector32(), Infinity);\n      return;\n    }\n    \
if (position) {\n      const center = this.boundingSphere.center;\n      \
_box$22.setFromBufferAttribute(position);\n      if (morphAttributesPosition) \
{\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) \
{\n          const morphAttribute = morphAttributesPosition[i];\n          \
_boxMorphTargets2.setFromBufferAttribute(morphAttribute);\n          if \
(this.morphTargetsRelative) {\n            _vector$82.addVectors(_box$22.min, \
_boxMorphTargets2.min);\n            _box$22.expandByPoint(_vector$82);\n     \
       _vector$82.addVectors(_box$22.max, _boxMorphTargets2.max);\n           \
 _box$22.expandByPoint(_vector$82);\n          } else {\n            \
_box$22.expandByPoint(_boxMorphTargets2.min);\n            \
_box$22.expandByPoint(_boxMorphTargets2.max);\n          }\n        }\n      \
}\n      _box$22.getCenter(center);\n      let maxRadiusSq = 0;\n      for \
(let i = 0, il = position.count; i < il; i++) {\n        \
_vector$82.fromBufferAttribute(position, i);\n        maxRadiusSq = \
Math.max(maxRadiusSq, center.distanceToSquared(_vector$82));\n      }\n      \
if (morphAttributesPosition) {\n        for (let i = 0, il = \
morphAttributesPosition.length; i < il; i++) {\n          const \
morphAttribute = morphAttributesPosition[i];\n          const \
morphTargetsRelative = this.morphTargetsRelative;\n          for (let j = 0, \
jl = morphAttribute.count; j < jl; j++) {\n            \
_vector$82.fromBufferAttribute(morphAttribute, j);\n            if \
(morphTargetsRelative) {\n              \
_offset3.fromBufferAttribute(position, j);\n              \
_vector$82.add(_offset3);\n            }\n            maxRadiusSq = \
Math.max(maxRadiusSq, center.distanceToSquared(_vector$82));\n          }\n   \
     }\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n \
     if (isNaN(this.boundingSphere.radius)) {\n        \
console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius \
is NaN. The \"position\" attribute is likely to have NaN values.', this);\n   \
   }\n    }\n  }\n  computeTangents() {\n    const index5 = this.index;\n    \
const attributes = this.attributes;\n    if (index5 === null || \
attributes.position === void 0 || attributes.normal === void 0 || \
attributes.uv === void 0) {\n      console.error(\"THREE.BufferGeometry: \
.computeTangents() failed. Missing required attributes (index, position, \
normal or uv)\");\n      return;\n    }\n    const positionAttribute = \
attributes.position;\n    const normalAttribute = attributes.normal;\n    \
const uvAttribute = attributes.uv;\n    if (this.hasAttribute(\"tangent\") \
=== false) {\n      this.setAttribute(\"tangent\", new BufferAttribute2(new \
Float32Array(4 * positionAttribute.count), 4));\n    }\n    const \
tangentAttribute = this.getAttribute(\"tangent\");\n    const tan1 = [], tan2 \
= [];\n    for (let i = 0; i < positionAttribute.count; i++) {\n      tan1[i] \
= new Vector32();\n      tan2[i] = new Vector32();\n    }\n    const vA = new \
Vector32(), vB = new Vector32(), vC = new Vector32(), uvA = new Vector22(), \
uvB = new Vector22(), uvC = new Vector22(), sdir = new Vector32(), tdir = new \
Vector32();\n    function handleTriangle(a2, b, c2) {\n      \
vA.fromBufferAttribute(positionAttribute, a2);\n      \
vB.fromBufferAttribute(positionAttribute, b);\n      \
vC.fromBufferAttribute(positionAttribute, c2);\n      \
uvA.fromBufferAttribute(uvAttribute, a2);\n      \
uvB.fromBufferAttribute(uvAttribute, b);\n      \
uvC.fromBufferAttribute(uvAttribute, c2);\n      vB.sub(vA);\n      \
vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1 / \
(uvB.x * uvC.y - uvC.x * uvB.y);\n      if (!isFinite(r)) return;\n      \
sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, \
-uvB.y).multiplyScalar(r);\n      \
tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, \
-uvC.x).multiplyScalar(r);\n      tan1[a2].add(sdir);\n      \
tan1[b].add(sdir);\n      tan1[c2].add(sdir);\n      tan2[a2].add(tdir);\n    \
  tan2[b].add(tdir);\n      tan2[c2].add(tdir);\n    }\n    let groups = \
this.groups;\n    if (groups.length === 0) {\n      groups = [{\n        \
start: 0,\n        count: index5.count\n      }];\n    }\n    for (let i = 0, \
il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      \
const start = group.start;\n      const count = group.count;\n      for (let \
j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(\n   \
       index5.getX(j + 0),\n          index5.getX(j + 1),\n          \
index5.getX(j + 2)\n        );\n      }\n    }\n    const tmp2 = new \
Vector32(), tmp22 = new Vector32();\n    const n = new Vector32(), n2 = new \
Vector32();\n    function handleVertex(v) {\n      \
n.fromBufferAttribute(normalAttribute, v);\n      n2.copy(n);\n      const t \
= tan1[v];\n      tmp2.copy(t);\n      \
tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();\n      \
tmp22.crossVectors(n2, t);\n      const test = tmp22.dot(tan2[v]);\n      \
const w = test < 0 ? -1 : 1;\n      tangentAttribute.setXYZW(v, tmp2.x, \
tmp2.y, tmp2.z, w);\n    }\n    for (let i = 0, il = groups.length; i < il; \
++i) {\n      const group = groups[i];\n      const start = group.start;\n    \
  const count = group.count;\n      for (let j = start, jl = start + count; j \
< jl; j += 3) {\n        handleVertex(index5.getX(j + 0));\n        \
handleVertex(index5.getX(j + 1));\n        handleVertex(index5.getX(j + \
2));\n      }\n    }\n  }\n  computeVertexNormals() {\n    const index5 = \
this.index;\n    const positionAttribute = this.getAttribute(\"position\");\n \
   if (positionAttribute !== void 0) {\n      let normalAttribute = \
this.getAttribute(\"normal\");\n      if (normalAttribute === void 0) {\n     \
   normalAttribute = new BufferAttribute2(new \
Float32Array(positionAttribute.count * 3), 3);\n        \
this.setAttribute(\"normal\", normalAttribute);\n      } else {\n        for \
(let i = 0, il = normalAttribute.count; i < il; i++) {\n          \
normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n      const pA = new \
Vector32(), pB = new Vector32(), pC = new Vector32();\n      const nA = new \
Vector32(), nB = new Vector32(), nC = new Vector32();\n      const cb = new \
Vector32(), ab = new Vector32();\n      if (index5) {\n        for (let i = \
0, il = index5.count; i < il; i += 3) {\n          const vA = index5.getX(i + \
0);\n          const vB = index5.getX(i + 1);\n          const vC = \
index5.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, \
vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          \
pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, \
pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          \
nA.fromBufferAttribute(normalAttribute, vA);\n          \
nB.fromBufferAttribute(normalAttribute, vB);\n          \
nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n         \
 nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, \
nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n \
         normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } \
else {\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) \
{\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          \
pB.fromBufferAttribute(positionAttribute, i + 1);\n          \
pC.fromBufferAttribute(positionAttribute, i + 2);\n          \
cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          \
cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n   \
       normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          \
normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n      \
this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  \
}\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n    \
for (let i = 0, il = normals.count; i < il; i++) {\n      \
_vector$82.fromBufferAttribute(normals, i);\n      _vector$82.normalize();\n  \
    normals.setXYZ(i, _vector$82.x, _vector$82.y, _vector$82.z);\n    }\n  \
}\n  toNonIndexed() {\n    function convertBufferAttribute(attribute2, \
indices2) {\n      const array = attribute2.array;\n      const itemSize = \
attribute2.itemSize;\n      const normalized = attribute2.normalized;\n      \
const array2 = new array.constructor(indices2.length * itemSize);\n      let \
index5 = 0, index22 = 0;\n      for (let i = 0, l = indices2.length; i < l; \
i++) {\n        if (attribute2.isInterleavedBufferAttribute) {\n          \
index5 = indices2[i] * attribute2.data.stride + attribute2.offset;\n        } \
else {\n          index5 = indices2[i] * itemSize;\n        }\n        for \
(let j = 0; j < itemSize; j++) {\n          array2[index22++] = \
array[index5++];\n        }\n      }\n      return new \
BufferAttribute2(array2, itemSize, normalized);\n    }\n    if (this.index \
=== null) {\n      console.warn(\"THREE.BufferGeometry.toNonIndexed(): \
BufferGeometry is already non-indexed.\");\n      return this;\n    }\n    \
const geometry2 = new _BufferGeometry();\n    const indices = \
this.index.array;\n    const attributes = this.attributes;\n    for (const \
name in attributes) {\n      const attribute2 = attributes[name];\n      \
const newAttribute = convertBufferAttribute(attribute2, indices);\n      \
geometry2.setAttribute(name, newAttribute);\n    }\n    const morphAttributes \
= this.morphAttributes;\n    for (const name in morphAttributes) {\n      \
const morphArray = [];\n      const morphAttribute = morphAttributes[name];\n \
     for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        \
const attribute2 = morphAttribute[i];\n        const newAttribute = \
convertBufferAttribute(attribute2, indices);\n        \
morphArray.push(newAttribute);\n      }\n      \
geometry2.morphAttributes[name] = morphArray;\n    }\n    \
geometry2.morphTargetsRelative = this.morphTargetsRelative;\n    const groups \
= this.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      \
const group = groups[i];\n      geometry2.addGroup(group.start, group.count, \
group.materialIndex);\n    }\n    return geometry2;\n  }\n  toJSON() {\n    \
const data = {\n      metadata: {\n        version: 4.6,\n        type: \
\"BufferGeometry\",\n        generator: \"BufferGeometry.toJSON\"\n      }\n  \
  };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if \
(this.name !== \"\") data.name = this.name;\n    if \
(Object.keys(this.userData).length > 0) data.userData = this.userData;\n    \
if (this.parameters !== void 0) {\n      const parameters = \
this.parameters;\n      for (const key in parameters) {\n        if \
(parameters[key] !== void 0) data[key] = parameters[key];\n      }\n      \
return data;\n    }\n    data.data = { attributes: {} };\n    const index5 = \
this.index;\n    if (index5 !== null) {\n      data.data.index = {\n        \
type: index5.array.constructor.name,\n        array: \
Array.prototype.slice.call(index5.array)\n      };\n    }\n    const \
attributes = this.attributes;\n    for (const key in attributes) {\n      \
const attribute2 = attributes[key];\n      data.data.attributes[key] = \
attribute2.toJSON(data.data);\n    }\n    const morphAttributes = {};\n    \
let hasMorphAttributes = false;\n    for (const key in this.morphAttributes) \
{\n      const attributeArray = this.morphAttributes[key];\n      const array \
= [];\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n     \
   const attribute2 = attributeArray[i];\n        \
array.push(attribute2.toJSON(data.data));\n      }\n      if (array.length > \
0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = \
true;\n      }\n    }\n    if (hasMorphAttributes) {\n      \
data.data.morphAttributes = morphAttributes;\n      \
data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n    const \
groups = this.groups;\n    if (groups.length > 0) {\n      data.data.groups = \
JSON.parse(JSON.stringify(groups));\n    }\n    const boundingSphere = \
this.boundingSphere;\n    if (boundingSphere !== null) {\n      \
data.data.boundingSphere = {\n        center: \
boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n     \
 };\n    }\n    return data;\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n  copy(source) {\n    this.index = \
null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    \
this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = \
null;\n    const data = {};\n    this.name = source.name;\n    const index5 = \
source.index;\n    if (index5 !== null) {\n      \
this.setIndex(index5.clone(data));\n    }\n    const attributes = \
source.attributes;\n    for (const name in attributes) {\n      const \
attribute2 = attributes[name];\n      this.setAttribute(name, \
attribute2.clone(data));\n    }\n    const morphAttributes = \
source.morphAttributes;\n    for (const name in morphAttributes) {\n      \
const array = [];\n      const morphAttribute = morphAttributes[name];\n      \
for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        \
array.push(morphAttribute[i].clone(data));\n      }\n      \
this.morphAttributes[name] = array;\n    }\n    this.morphTargetsRelative = \
source.morphTargetsRelative;\n    const groups = source.groups;\n    for (let \
i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n     \
 this.addGroup(group.start, group.count, group.materialIndex);\n    }\n    \
const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n    \
  this.boundingBox = boundingBox.clone();\n    }\n    const boundingSphere = \
source.boundingSphere;\n    if (boundingSphere !== null) {\n      \
this.boundingSphere = boundingSphere.clone();\n    }\n    \
this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = \
source.drawRange.count;\n    this.userData = source.userData;\n    return \
this;\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  \
}\n};\nvar _inverseMatrix$32 = /* @__PURE__ */ new Matrix42();\nvar _ray$32 = \
/* @__PURE__ */ new Ray2();\nvar _sphere$62 = /* @__PURE__ */ new \
Sphere2();\nvar _sphereHitAt2 = /* @__PURE__ */ new Vector32();\nvar _vA$12 = \
/* @__PURE__ */ new Vector32();\nvar _vB$12 = /* @__PURE__ */ new \
Vector32();\nvar _vC$12 = /* @__PURE__ */ new Vector32();\nvar _tempA2 = /* \
@__PURE__ */ new Vector32();\nvar _morphA2 = /* @__PURE__ */ new \
Vector32();\nvar _intersectionPoint2 = /* @__PURE__ */ new Vector32();\nvar \
_intersectionPointWorld2 = /* @__PURE__ */ new Vector32();\nvar Mesh2 = class \
extends Object3D2 {\n  constructor(geometry = new BufferGeometry2(), material \
= new MeshBasicMaterial2()) {\n    super();\n    this.isMesh = true;\n    \
this.type = \"Mesh\";\n    this.geometry = geometry;\n    this.material = \
material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n \
   super.copy(source, recursive);\n    if (source.morphTargetInfluences !== \
void 0) {\n      this.morphTargetInfluences = \
source.morphTargetInfluences.slice();\n    }\n    if \
(source.morphTargetDictionary !== void 0) {\n      this.morphTargetDictionary \
= Object.assign({}, source.morphTargetDictionary);\n    }\n    this.material \
= Array.isArray(source.material) ? source.material.slice() : \
source.material;\n    this.geometry = source.geometry;\n    return this;\n  \
}\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const \
morphAttributes = geometry.morphAttributes;\n    const keys = \
Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const \
morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== void \
0) {\n        this.morphTargetInfluences = [];\n        \
this.morphTargetDictionary = {};\n        for (let m2 = 0, ml = \
morphAttribute.length; m2 < ml; m2++) {\n          const name = \
morphAttribute[m2].name || String(m2);\n          \
this.morphTargetInfluences.push(0);\n          \
this.morphTargetDictionary[name] = m2;\n        }\n      }\n    }\n  }\n  \
getVertexPosition(index5, target) {\n    const geometry = this.geometry;\n    \
const position = geometry.attributes.position;\n    const morphPosition = \
geometry.morphAttributes.position;\n    const morphTargetsRelative = \
geometry.morphTargetsRelative;\n    target.fromBufferAttribute(position, \
index5);\n    const morphInfluences = this.morphTargetInfluences;\n    if \
(morphPosition && morphInfluences) {\n      _morphA2.set(0, 0, 0);\n      for \
(let i = 0, il = morphPosition.length; i < il; i++) {\n        const \
influence = morphInfluences[i];\n        const morphAttribute = \
morphPosition[i];\n        if (influence === 0) continue;\n        \
_tempA2.fromBufferAttribute(morphAttribute, index5);\n        if \
(morphTargetsRelative) {\n          _morphA2.addScaledVector(_tempA2, \
influence);\n        } else {\n          \
_morphA2.addScaledVector(_tempA2.sub(target), influence);\n        }\n      \
}\n      target.add(_morphA2);\n    }\n    return target;\n  }\n  \
raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    \
const material = this.material;\n    const matrixWorld = this.matrixWorld;\n  \
  if (material === void 0) return;\n    if (geometry.boundingSphere === null) \
geometry.computeBoundingSphere();\n    \
_sphere$62.copy(geometry.boundingSphere);\n    \
_sphere$62.applyMatrix4(matrixWorld);\n    \
_ray$32.copy(raycaster.ray).recast(raycaster.near);\n    if \
(_sphere$62.containsPoint(_ray$32.origin) === false) {\n      if \
(_ray$32.intersectSphere(_sphere$62, _sphereHitAt2) === null) return;\n      \
if (_ray$32.origin.distanceToSquared(_sphereHitAt2) > (raycaster.far - \
raycaster.near) ** 2) return;\n    }\n    \
_inverseMatrix$32.copy(matrixWorld).invert();\n    \
_ray$32.copy(raycaster.ray).applyMatrix4(_inverseMatrix$32);\n    if \
(geometry.boundingBox !== null) {\n      if \
(_ray$32.intersectsBox(geometry.boundingBox) === false) return;\n    }\n    \
this._computeIntersections(raycaster, intersects, _ray$32);\n  }\n  \
_computeIntersections(raycaster, intersects, rayLocalSpace) {\n    let \
intersection;\n    const geometry = this.geometry;\n    const material = \
this.material;\n    const index5 = geometry.index;\n    const position = \
geometry.attributes.position;\n    const uv2 = geometry.attributes.uv;\n    \
const uv1 = geometry.attributes.uv1;\n    const normal2 = \
geometry.attributes.normal;\n    const groups = geometry.groups;\n    const \
drawRange = geometry.drawRange;\n    if (index5 !== null) {\n      if \
(Array.isArray(material)) {\n        for (let i = 0, il = groups.length; i < \
il; i++) {\n          const group = groups[i];\n          const groupMaterial \
= material[group.materialIndex];\n          const start = \
Math.max(group.start, drawRange.start);\n          const end = \
Math.min(index5.count, Math.min(group.start + group.count, drawRange.start + \
drawRange.count));\n          for (let j = start, jl = end; j < jl; j += 3) \
{\n            const a2 = index5.getX(j);\n            const b = \
index5.getX(j + 1);\n            const c2 = index5.getX(j + 2);\n            \
intersection = checkGeometryIntersection2(this, groupMaterial, raycaster, \
rayLocalSpace, uv2, uv1, normal2, a2, b, c2);\n            if (intersection) \
{\n              intersection.faceIndex = Math.floor(j / 3);\n              \
intersection.face.materialIndex = group.materialIndex;\n              \
intersects.push(intersection);\n            }\n          }\n        }\n      \
} else {\n        const start = Math.max(0, drawRange.start);\n        const \
end = Math.min(index5.count, drawRange.start + drawRange.count);\n        for \
(let i = start, il = end; i < il; i += 3) {\n          const a2 = \
index5.getX(i);\n          const b = index5.getX(i + 1);\n          const c2 \
= index5.getX(i + 2);\n          intersection = \
checkGeometryIntersection2(this, material, raycaster, rayLocalSpace, uv2, \
uv1, normal2, a2, b, c2);\n          if (intersection) {\n            \
intersection.faceIndex = Math.floor(i / 3);\n            \
intersects.push(intersection);\n          }\n        }\n      }\n    } else \
if (position !== void 0) {\n      if (Array.isArray(material)) {\n        for \
(let i = 0, il = groups.length; i < il; i++) {\n          const group = \
groups[i];\n          const groupMaterial = material[group.materialIndex];\n  \
        const start = Math.max(group.start, drawRange.start);\n          \
const end = Math.min(position.count, Math.min(group.start + group.count, \
drawRange.start + drawRange.count));\n          for (let j = start, jl = end; \
j < jl; j += 3) {\n            const a2 = j;\n            const b = j + 1;\n  \
          const c2 = j + 2;\n            intersection = \
checkGeometryIntersection2(this, groupMaterial, raycaster, rayLocalSpace, \
uv2, uv1, normal2, a2, b, c2);\n            if (intersection) {\n             \
 intersection.faceIndex = Math.floor(j / 3);\n              \
intersection.face.materialIndex = group.materialIndex;\n              \
intersects.push(intersection);\n            }\n          }\n        }\n      \
} else {\n        const start = Math.max(0, drawRange.start);\n        const \
end = Math.min(position.count, drawRange.start + drawRange.count);\n        \
for (let i = start, il = end; i < il; i += 3) {\n          const a2 = i;\n    \
      const b = i + 1;\n          const c2 = i + 2;\n          intersection = \
checkGeometryIntersection2(this, material, raycaster, rayLocalSpace, uv2, \
uv1, normal2, a2, b, c2);\n          if (intersection) {\n            \
intersection.faceIndex = Math.floor(i / 3);\n            \
intersects.push(intersection);\n          }\n        }\n      }\n    }\n  \
}\n};\nfunction checkIntersection$12(object, material, raycaster, ray, pA, \
pB, pC, point) {\n  let intersect2;\n  if (material.side === BackSide2) {\n   \
 intersect2 = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n   \
 intersect2 = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide2, \
point);\n  }\n  if (intersect2 === null) return null;\n  \
_intersectionPointWorld2.copy(point);\n  \
_intersectionPointWorld2.applyMatrix4(object.matrixWorld);\n  const distance2 \
= raycaster.ray.origin.distanceTo(_intersectionPointWorld2);\n  if (distance2 \
< raycaster.near || distance2 > raycaster.far) return null;\n  return {\n    \
distance: distance2,\n    point: _intersectionPointWorld2.clone(),\n    \
object\n  };\n}\nfunction checkGeometryIntersection2(object, material, \
raycaster, ray, uv2, uv1, normal2, a2, b, c2) {\n  \
object.getVertexPosition(a2, _vA$12);\n  object.getVertexPosition(b, \
_vB$12);\n  object.getVertexPosition(c2, _vC$12);\n  const intersection = \
checkIntersection$12(object, material, raycaster, ray, _vA$12, _vB$12, \
_vC$12, _intersectionPoint2);\n  if (intersection) {\n    const barycoord = \
new Vector32();\n    Triangle2.getBarycoord(_intersectionPoint2, _vA$12, \
_vB$12, _vC$12, barycoord);\n    if (uv2) {\n      intersection.uv = \
Triangle2.getInterpolatedAttribute(uv2, a2, b, c2, barycoord, new \
Vector22());\n    }\n    if (uv1) {\n      intersection.uv1 = \
Triangle2.getInterpolatedAttribute(uv1, a2, b, c2, barycoord, new \
Vector22());\n    }\n    if (normal2) {\n      intersection.normal = \
Triangle2.getInterpolatedAttribute(normal2, a2, b, c2, barycoord, new \
Vector32());\n      if (intersection.normal.dot(ray.direction) > 0) {\n       \
 intersection.normal.multiplyScalar(-1);\n      }\n    }\n    const face = \
{\n      a: a2,\n      b,\n      c: c2,\n      normal: new Vector32(),\n      \
materialIndex: 0\n    };\n    Triangle2.getNormal(_vA$12, _vB$12, _vC$12, \
face.normal);\n    intersection.face = face;\n    intersection.barycoord = \
barycoord;\n  }\n  return intersection;\n}\nvar BoxGeometry2 = class \
_BoxGeometry extends BufferGeometry2 {\n  constructor(width = 1, height = 1, \
depth2 = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n    \
super();\n    this.type = \"BoxGeometry\";\n    this.parameters = {\n      \
width,\n      height,\n      depth: depth2,\n      widthSegments,\n      \
heightSegments,\n      depthSegments\n    };\n    const scope = this;\n    \
widthSegments = Math.floor(widthSegments);\n    heightSegments = \
Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments);\n \
   const indices = [];\n    const vertices = [];\n    const normals = [];\n   \
 const uvs = [];\n    let numberOfVertices = 0;\n    let groupStart = 0;\n    \
buildPlane(\"z\", \"y\", \"x\", -1, -1, depth2, height, width, depthSegments, \
heightSegments, 0);\n    buildPlane(\"z\", \"y\", \"x\", 1, -1, depth2, \
height, -width, depthSegments, heightSegments, 1);\n    buildPlane(\"x\", \
\"z\", \"y\", 1, 1, width, depth2, height, widthSegments, depthSegments, \
2);\n    buildPlane(\"x\", \"z\", \"y\", 1, -1, width, depth2, -height, \
widthSegments, depthSegments, 3);\n    buildPlane(\"x\", \"y\", \"z\", 1, -1, \
width, height, depth2, widthSegments, heightSegments, 4);\n    \
buildPlane(\"x\", \"y\", \"z\", -1, -1, width, height, -depth2, \
widthSegments, heightSegments, 5);\n    this.setIndex(indices);\n    \
this.setAttribute(\"position\", new Float32BufferAttribute2(vertices, 3));\n  \
  this.setAttribute(\"normal\", new Float32BufferAttribute2(normals, 3));\n   \
 this.setAttribute(\"uv\", new Float32BufferAttribute2(uvs, 2));\n    \
function buildPlane(u, v, w, udir, vdir, width2, height2, depth3, gridX, \
gridY, materialIndex) {\n      const segmentWidth = width2 / gridX;\n      \
const segmentHeight = height2 / gridY;\n      const widthHalf = width2 / 2;\n \
     const heightHalf = height2 / 2;\n      const depthHalf = depth3 / 2;\n   \
   const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      let \
vertexCounter = 0;\n      let groupCount = 0;\n      const vector = new \
Vector32();\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y2 = \
iy * segmentHeight - heightHalf;\n        for (let ix = 0; ix < gridX1; ix++) \
{\n          const x2 = ix * segmentWidth - widthHalf;\n          vector[u] = \
x2 * udir;\n          vector[v] = y2 * vdir;\n          vector[w] = \
depthHalf;\n          vertices.push(vector.x, vector.y, vector.z);\n          \
vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth3 > 0 ? \
1 : -1;\n          normals.push(vector.x, vector.y, vector.z);\n          \
uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n          \
vertexCounter += 1;\n        }\n      }\n      for (let iy = 0; iy < gridY; \
iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a2 = \
numberOfVertices + ix + gridX1 * iy;\n          const b = numberOfVertices + \
ix + gridX1 * (iy + 1);\n          const c2 = numberOfVertices + (ix + 1) + \
gridX1 * (iy + 1);\n          const d = numberOfVertices + (ix + 1) + gridX1 \
* iy;\n          indices.push(a2, b, d);\n          indices.push(b, c2, d);\n \
         groupCount += 6;\n        }\n      }\n      \
scope.addGroup(groupStart, groupCount, materialIndex);\n      groupStart += \
groupCount;\n      numberOfVertices += vertexCounter;\n    }\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.parameters = \
Object.assign({}, source.parameters);\n    return this;\n  }\n  static \
fromJSON(data) {\n    return new _BoxGeometry(data.width, data.height, \
data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n  \
}\n};\nfunction cloneUniforms2(src) {\n  const dst = {};\n  for (const u in \
src) {\n    dst[u] = {};\n    for (const p in src[u]) {\n      const \
property2 = src[u][p];\n      if (property2 && (property2.isColor || \
property2.isMatrix3 || property2.isMatrix4 || property2.isVector2 || \
property2.isVector3 || property2.isVector4 || property2.isTexture || \
property2.isQuaternion)) {\n        if (property2.isRenderTargetTexture) {\n  \
        console.warn(\"UniformsUtils: Textures of render targets cannot be \
cloned via cloneUniforms() or mergeUniforms().\");\n          dst[u][p] = \
null;\n        } else {\n          dst[u][p] = property2.clone();\n        \
}\n      } else if (Array.isArray(property2)) {\n        dst[u][p] = \
property2.slice();\n      } else {\n        dst[u][p] = property2;\n      }\n \
   }\n  }\n  return dst;\n}\nfunction cloneUniformsGroups2(src) {\n  const \
dst = [];\n  for (let u = 0; u < src.length; u++) {\n    \
dst.push(src[u].clone());\n  }\n  return dst;\n}\nvar default_vertex2 = (\n  \
/* glsl */\n  `\nvoid main() {\n\tgl_Position = projectionMatrix * \
modelViewMatrix * vec4( position, 1.0 );\n}\n`\n);\nvar default_fragment2 = \
(\n  /* glsl */\n  `\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, \
1.0 );\n}\n`\n);\nvar ShaderMaterial2 = class extends Material2 {\n  static \
get type() {\n    return \"ShaderMaterial\";\n  }\n  constructor(parameters) \
{\n    super();\n    this.isShaderMaterial = true;\n    this.defines = {};\n  \
  this.uniforms = {};\n    this.uniformsGroups = [];\n    this.vertexShader = \
default_vertex2;\n    this.fragmentShader = default_fragment2;\n    \
this.linewidth = 1;\n    this.wireframe = false;\n    this.wireframeLinewidth \
= 1;\n    this.fog = false;\n    this.lights = false;\n    this.clipping = \
false;\n    this.forceSinglePass = true;\n    this.extensions = {\n      \
clipCullDistance: false,\n      // set to use vertex shader clipping\n      \
multiDraw: false\n      // set to use vertex shader multi_draw / enable \
gl_DrawID\n    };\n    this.defaultAttributeValues = {\n      \"color\": [1, \
1, 1],\n      \"uv\": [0, 0],\n      \"uv1\": [0, 0]\n    };\n    \
this.index0AttributeName = void 0;\n    this.uniformsNeedUpdate = false;\n    \
this.glslVersion = null;\n    if (parameters !== void 0) {\n      \
this.setValues(parameters);\n    }\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.fragmentShader = source.fragmentShader;\n    \
this.vertexShader = source.vertexShader;\n    this.uniforms = \
cloneUniforms2(source.uniforms);\n    this.uniformsGroups = \
cloneUniformsGroups2(source.uniformsGroups);\n    this.defines = \
Object.assign({}, source.defines);\n    this.wireframe = source.wireframe;\n  \
  this.wireframeLinewidth = source.wireframeLinewidth;\n    this.fog = \
source.fog;\n    this.lights = source.lights;\n    this.clipping = \
source.clipping;\n    this.extensions = Object.assign({}, \
source.extensions);\n    this.glslVersion = source.glslVersion;\n    return \
this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    \
data.glslVersion = this.glslVersion;\n    data.uniforms = {};\n    for (const \
name in this.uniforms) {\n      const uniform2 = this.uniforms[name];\n      \
const value = uniform2.value;\n      if (value && value.isTexture) {\n        \
data.uniforms[name] = {\n          type: \"t\",\n          value: \
value.toJSON(meta).uuid\n        };\n      } else if (value && value.isColor) \
{\n        data.uniforms[name] = {\n          type: \"c\",\n          value: \
value.getHex()\n        };\n      } else if (value && value.isVector2) {\n    \
    data.uniforms[name] = {\n          type: \"v2\",\n          value: \
value.toArray()\n        };\n      } else if (value && value.isVector3) {\n   \
     data.uniforms[name] = {\n          type: \"v3\",\n          value: \
value.toArray()\n        };\n      } else if (value && value.isVector4) {\n   \
     data.uniforms[name] = {\n          type: \"v4\",\n          value: \
value.toArray()\n        };\n      } else if (value && value.isMatrix3) {\n   \
     data.uniforms[name] = {\n          type: \"m3\",\n          value: \
value.toArray()\n        };\n      } else if (value && value.isMatrix4) {\n   \
     data.uniforms[name] = {\n          type: \"m4\",\n          value: \
value.toArray()\n        };\n      } else {\n        data.uniforms[name] = \
{\n          value\n        };\n      }\n    }\n    if \
(Object.keys(this.defines).length > 0) data.defines = this.defines;\n    \
data.vertexShader = this.vertexShader;\n    data.fragmentShader = \
this.fragmentShader;\n    data.lights = this.lights;\n    data.clipping = \
this.clipping;\n    const extensions = {};\n    for (const key in \
this.extensions) {\n      if (this.extensions[key] === true) extensions[key] \
= true;\n    }\n    if (Object.keys(extensions).length > 0) data.extensions = \
extensions;\n    return data;\n  }\n};\nvar Camera2 = class extends Object3D2 \
{\n  constructor() {\n    super();\n    this.isCamera = true;\n    this.type \
= \"Camera\";\n    this.matrixWorldInverse = new Matrix42();\n    \
this.projectionMatrix = new Matrix42();\n    this.projectionMatrixInverse = \
new Matrix42();\n    this.coordinateSystem = WebGLCoordinateSystem2;\n  }\n  \
copy(source, recursive) {\n    super.copy(source, recursive);\n    \
this.matrixWorldInverse.copy(source.matrixWorldInverse);\n    \
this.projectionMatrix.copy(source.projectionMatrix);\n    \
this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n    \
this.coordinateSystem = source.coordinateSystem;\n    return this;\n  }\n  \
getWorldDirection(target) {\n    return \
super.getWorldDirection(target).negate();\n  }\n  updateMatrixWorld(force) \
{\n    super.updateMatrixWorld(force);\n    \
this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  \
updateWorldMatrix(updateParents, updateChildren) {\n    \
super.updateWorldMatrix(updateParents, updateChildren);\n    \
this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  clone() {\n  \
  return new this.constructor().copy(this);\n  }\n};\nvar _v3$12 = /* \
@__PURE__ */ new Vector32();\nvar _minTarget2 = /* @__PURE__ */ new \
Vector22();\nvar _maxTarget2 = /* @__PURE__ */ new Vector22();\nvar \
PerspectiveCamera2 = class extends Camera2 {\n  constructor(fov3 = 50, \
aspect3 = 1, near = 0.1, far = 2e3) {\n    super();\n    \
this.isPerspectiveCamera = true;\n    this.type = \"PerspectiveCamera\";\n    \
this.fov = fov3;\n    this.zoom = 1;\n    this.near = near;\n    this.far = \
far;\n    this.focus = 10;\n    this.aspect = aspect3;\n    this.view = \
null;\n    this.filmGauge = 35;\n    this.filmOffset = 0;\n    \
this.updateProjectionMatrix();\n  }\n  copy(source, recursive) {\n    \
super.copy(source, recursive);\n    this.fov = source.fov;\n    this.zoom = \
source.zoom;\n    this.near = source.near;\n    this.far = source.far;\n    \
this.focus = source.focus;\n    this.aspect = source.aspect;\n    this.view = \
source.view === null ? null : Object.assign({}, source.view);\n    \
this.filmGauge = source.filmGauge;\n    this.filmOffset = \
source.filmOffset;\n    return this;\n  }\n  /**\n   * Sets the FOV by focal \
length in respect to the current .filmGauge.\n   *\n   * The default film \
gauge is 35, so that the focal length can be specified for\n   * a 35mm (full \
frame) camera.\n   *\n   * Values for focal length and film gauge must have \
the same unit.\n   */\n  setFocalLength(focalLength) {\n    const \
vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov = \
RAD2DEG2 * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n \
 }\n  /**\n   * Calculates the focal length from the current .fov and \
.filmGauge.\n   */\n  getFocalLength() {\n    const vExtentSlope = \
Math.tan(DEG2RAD2 * 0.5 * this.fov);\n    return 0.5 * this.getFilmHeight() / \
vExtentSlope;\n  }\n  getEffectiveFOV() {\n    return RAD2DEG2 * 2 * \
Math.atan(\n      Math.tan(DEG2RAD2 * 0.5 * this.fov) / this.zoom\n    );\n  \
}\n  getFilmWidth() {\n    return this.filmGauge * Math.min(this.aspect, \
1);\n  }\n  getFilmHeight() {\n    return this.filmGauge / \
Math.max(this.aspect, 1);\n  }\n  /**\n   * Computes the 2D bounds of the \
camera's viewable rectangle at a given distance along the viewing \
direction.\n   * Sets minTarget and maxTarget to the coordinates of the \
lower-left and upper-right corners of the view rectangle.\n   */\n  \
getViewBounds(distance2, minTarget, maxTarget) {\n    _v3$12.set(-1, -1, \
0.5).applyMatrix4(this.projectionMatrixInverse);\n    minTarget.set(_v3$12.x, \
_v3$12.y).multiplyScalar(-distance2 / _v3$12.z);\n    _v3$12.set(1, 1, \
0.5).applyMatrix4(this.projectionMatrixInverse);\n    maxTarget.set(_v3$12.x, \
_v3$12.y).multiplyScalar(-distance2 / _v3$12.z);\n  }\n  /**\n   * Computes \
the width and height of the camera's viewable rectangle at a given distance \
along the viewing direction.\n   * Copies the result into the target Vector2, \
where x is width and y is height.\n   */\n  getViewSize(distance2, target) \
{\n    this.getViewBounds(distance2, _minTarget2, _maxTarget2);\n    return \
target.subVectors(_maxTarget2, _minTarget2);\n  }\n  /**\n   * Sets an offset \
in a larger frustum. This is useful for multi-window or\n   * \
multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 \
monitors and each monitor is 1920x1080 and\n   * the monitors are in grid \
like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   \
+---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then \
for each monitor you would call it like this\n   *\n   *   const w = 1920;\n  \
 *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const \
fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( \
fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   \
camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   \
--C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h \
);\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, \
h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, \
fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( \
fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no \
reason monitors have to be the same size or in a grid.\n   */\n  \
setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {\n    \
this.aspect = fullWidth / fullHeight;\n    if (this.view === null) {\n      \
this.view = {\n        enabled: true,\n        fullWidth: 1,\n        \
fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n \
       height: 1\n      };\n    }\n    this.view.enabled = true;\n    \
this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    \
this.view.offsetX = x2;\n    this.view.offsetY = y2;\n    this.view.width = \
width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  \
}\n  clearViewOffset() {\n    if (this.view !== null) {\n      \
this.view.enabled = false;\n    }\n    this.updateProjectionMatrix();\n  }\n  \
updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * \
Math.tan(DEG2RAD2 * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n \
   let width = this.aspect * height;\n    let left = -0.5 * width;\n    const \
view = this.view;\n    if (this.view !== null && this.view.enabled) {\n      \
const fullWidth = view.fullWidth, fullHeight = view.fullHeight;\n      left \
+= view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / \
fullHeight;\n      width *= view.width / fullWidth;\n      height *= \
view.height / fullHeight;\n    }\n    const skew = this.filmOffset;\n    if \
(skew !== 0) left += near * skew / this.getFilmWidth();\n    \
this.projectionMatrix.makePerspective(left, left + width, top, top - height, \
near, this.far, this.coordinateSystem);\n    \
this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  \
toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.fov = \
this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = \
this.near;\n    data.object.far = this.far;\n    data.object.focus = \
this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== \
null) data.object.view = Object.assign({}, this.view);\n    \
data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = \
this.filmOffset;\n    return data;\n  }\n};\nvar fov2 = -90;\nvar aspect2 = \
1;\nvar CubeCamera2 = class extends Object3D2 {\n  constructor(near, far, \
renderTarget) {\n    super();\n    this.type = \"CubeCamera\";\n    \
this.renderTarget = renderTarget;\n    this.coordinateSystem = null;\n    \
this.activeMipmapLevel = 0;\n    const cameraPX = new \
PerspectiveCamera2(fov2, aspect2, near, far);\n    cameraPX.layers = \
this.layers;\n    this.add(cameraPX);\n    const cameraNX = new \
PerspectiveCamera2(fov2, aspect2, near, far);\n    cameraNX.layers = \
this.layers;\n    this.add(cameraNX);\n    const cameraPY = new \
PerspectiveCamera2(fov2, aspect2, near, far);\n    cameraPY.layers = \
this.layers;\n    this.add(cameraPY);\n    const cameraNY = new \
PerspectiveCamera2(fov2, aspect2, near, far);\n    cameraNY.layers = \
this.layers;\n    this.add(cameraNY);\n    const cameraPZ = new \
PerspectiveCamera2(fov2, aspect2, near, far);\n    cameraPZ.layers = \
this.layers;\n    this.add(cameraPZ);\n    const cameraNZ = new \
PerspectiveCamera2(fov2, aspect2, near, far);\n    cameraNZ.layers = \
this.layers;\n    this.add(cameraNZ);\n  }\n  updateCoordinateSystem() {\n    \
const coordinateSystem = this.coordinateSystem;\n    const cameras = \
this.children.concat();\n    const [cameraPX, cameraNX, cameraPY, cameraNY, \
cameraPZ, cameraNZ] = cameras;\n    for (const camera3 of cameras) \
this.remove(camera3);\n    if (coordinateSystem === WebGLCoordinateSystem2) \
{\n      cameraPX.up.set(0, 1, 0);\n      cameraPX.lookAt(1, 0, 0);\n      \
cameraNX.up.set(0, 1, 0);\n      cameraNX.lookAt(-1, 0, 0);\n      \
cameraPY.up.set(0, 0, -1);\n      cameraPY.lookAt(0, 1, 0);\n      \
cameraNY.up.set(0, 0, 1);\n      cameraNY.lookAt(0, -1, 0);\n      \
cameraPZ.up.set(0, 1, 0);\n      cameraPZ.lookAt(0, 0, 1);\n      \
cameraNZ.up.set(0, 1, 0);\n      cameraNZ.lookAt(0, 0, -1);\n    } else if \
(coordinateSystem === WebGPUCoordinateSystem2) {\n      cameraPX.up.set(0, \
-1, 0);\n      cameraPX.lookAt(-1, 0, 0);\n      cameraNX.up.set(0, -1, 0);\n \
     cameraNX.lookAt(1, 0, 0);\n      cameraPY.up.set(0, 0, 1);\n      \
cameraPY.lookAt(0, 1, 0);\n      cameraNY.up.set(0, 0, -1);\n      \
cameraNY.lookAt(0, -1, 0);\n      cameraPZ.up.set(0, -1, 0);\n      \
cameraPZ.lookAt(0, 0, 1);\n      cameraNZ.up.set(0, -1, 0);\n      \
cameraNZ.lookAt(0, 0, -1);\n    } else {\n      throw new \
Error(\"THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: \
\" + coordinateSystem);\n    }\n    for (const camera3 of cameras) {\n      \
this.add(camera3);\n      camera3.updateMatrixWorld();\n    }\n  }\n  \
update(renderer3, scene3) {\n    if (this.parent === null) \
this.updateMatrixWorld();\n    const { renderTarget, activeMipmapLevel } = \
this;\n    if (this.coordinateSystem !== renderer3.coordinateSystem) {\n      \
this.coordinateSystem = renderer3.coordinateSystem;\n      \
this.updateCoordinateSystem();\n    }\n    const [cameraPX, cameraNX, \
cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;\n    const \
currentRenderTarget = renderer3.getRenderTarget();\n    const \
currentActiveCubeFace = renderer3.getActiveCubeFace();\n    const \
currentActiveMipmapLevel = renderer3.getActiveMipmapLevel();\n    const \
currentXrEnabled = renderer3.xr.enabled;\n    renderer3.xr.enabled = false;\n \
   const generateMipmaps = renderTarget.texture.generateMipmaps;\n    \
renderTarget.texture.generateMipmaps = false;\n    \
renderer3.setRenderTarget(renderTarget, 0, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraPX);\n    \
renderer3.setRenderTarget(renderTarget, 1, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraNX);\n    \
renderer3.setRenderTarget(renderTarget, 2, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraPY);\n    \
renderer3.setRenderTarget(renderTarget, 3, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraNY);\n    \
renderer3.setRenderTarget(renderTarget, 4, activeMipmapLevel);\n    \
renderer3.render(scene3, cameraPZ);\n    renderTarget.texture.generateMipmaps \
= generateMipmaps;\n    renderer3.setRenderTarget(renderTarget, 5, \
activeMipmapLevel);\n    renderer3.render(scene3, cameraNZ);\n    \
renderer3.setRenderTarget(currentRenderTarget, currentActiveCubeFace, \
currentActiveMipmapLevel);\n    renderer3.xr.enabled = currentXrEnabled;\n    \
renderTarget.texture.needsPMREMUpdate = true;\n  }\n};\nvar CubeTexture2 = \
class extends Texture2 {\n  constructor(images, mapping, wrapS, wrapT, \
magFilter, minFilter, format2, type, anisotropy2, colorSpace) {\n    images = \
images !== void 0 ? images : [];\n    mapping = mapping !== void 0 ? mapping \
: CubeReflectionMapping2;\n    super(images, mapping, wrapS, wrapT, \
magFilter, minFilter, format2, type, anisotropy2, colorSpace);\n    \
this.isCubeTexture = true;\n    this.flipY = false;\n  }\n  get images() {\n  \
  return this.image;\n  }\n  set images(value) {\n    this.image = value;\n  \
}\n};\nvar WebGLCubeRenderTarget2 = class extends WebGLRenderTarget2 {\n  \
constructor(size = 1, options = {}) {\n    super(size, size, options);\n    \
this.isWebGLCubeRenderTarget = true;\n    const image = { width: size, \
height: size, depth: 1 };\n    const images = [image, image, image, image, \
image, image];\n    this.texture = new CubeTexture2(images, options.mapping, \
options.wrapS, options.wrapT, options.magFilter, options.minFilter, \
options.format, options.type, options.anisotropy, options.colorSpace);\n    \
this.texture.isRenderTargetTexture = true;\n    this.texture.generateMipmaps \
= options.generateMipmaps !== void 0 ? options.generateMipmaps : false;\n    \
this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : \
LinearFilter2;\n  }\n  fromEquirectangularTexture(renderer3, texture2) {\n    \
this.texture.type = texture2.type;\n    this.texture.colorSpace = \
texture2.colorSpace;\n    this.texture.generateMipmaps = \
texture2.generateMipmaps;\n    this.texture.minFilter = texture2.minFilter;\n \
   this.texture.magFilter = texture2.magFilter;\n    const shader = {\n      \
uniforms: {\n        tEquirect: { value: null }\n      },\n      \
vertexShader: (\n        /* glsl */\n        `\n\n\t\t\t\tvarying vec3 \
vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 \
matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz \
);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = \
transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include \
<begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`\n   \
   ),\n      fragmentShader: (\n        /* glsl */\n        \
`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 \
vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() \
{\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection \
);\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction \
);\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV \
);\n\n\t\t\t\t}\n\t\t\t`\n      )\n    };\n    const geometry = new \
BoxGeometry2(5, 5, 5);\n    const material = new ShaderMaterial2({\n      \
name: \"CubemapFromEquirect\",\n      uniforms: \
cloneUniforms2(shader.uniforms),\n      vertexShader: shader.vertexShader,\n  \
    fragmentShader: shader.fragmentShader,\n      side: BackSide2,\n      \
blending: NoBlending2\n    });\n    material.uniforms.tEquirect.value = \
texture2;\n    const mesh = new Mesh2(geometry, material);\n    const \
currentMinFilter = texture2.minFilter;\n    if (texture2.minFilter === \
LinearMipmapLinearFilter2) texture2.minFilter = LinearFilter2;\n    const \
camera3 = new CubeCamera2(1, 10, this);\n    camera3.update(renderer3, \
mesh);\n    texture2.minFilter = currentMinFilter;\n    \
mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  \
}\n  clear(renderer3, color2, depth2, stencil) {\n    const \
currentRenderTarget = renderer3.getRenderTarget();\n    for (let i = 0; i < \
6; i++) {\n      renderer3.setRenderTarget(this, i);\n      \
renderer3.clear(color2, depth2, stencil);\n    }\n    \
renderer3.setRenderTarget(currentRenderTarget);\n  }\n};\nvar Scene2 = class \
extends Object3D2 {\n  constructor() {\n    super();\n    this.isScene = \
true;\n    this.type = \"Scene\";\n    this.background = null;\n    \
this.environment = null;\n    this.fog = null;\n    this.backgroundBlurriness \
= 0;\n    this.backgroundIntensity = 1;\n    this.backgroundRotation = new \
Euler2();\n    this.environmentIntensity = 1;\n    this.environmentRotation = \
new Euler2();\n    this.overrideMaterial = null;\n    if (typeof \
__THREE_DEVTOOLS__ !== \"undefined\") {\n      \
__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"observe\", { detail: this \
}));\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, \
recursive);\n    if (source.background !== null) this.background = \
source.background.clone();\n    if (source.environment !== null) \
this.environment = source.environment.clone();\n    if (source.fog !== null) \
this.fog = source.fog.clone();\n    this.backgroundBlurriness = \
source.backgroundBlurriness;\n    this.backgroundIntensity = \
source.backgroundIntensity;\n    \
this.backgroundRotation.copy(source.backgroundRotation);\n    \
this.environmentIntensity = source.environmentIntensity;\n    \
this.environmentRotation.copy(source.environmentRotation);\n    if \
(source.overrideMaterial !== null) this.overrideMaterial = \
source.overrideMaterial.clone();\n    this.matrixAutoUpdate = \
source.matrixAutoUpdate;\n    return this;\n  }\n  toJSON(meta) {\n    const \
data = super.toJSON(meta);\n    if (this.fog !== null) data.object.fog = \
this.fog.toJSON();\n    if (this.backgroundBlurriness > 0) \
data.object.backgroundBlurriness = this.backgroundBlurriness;\n    if \
(this.backgroundIntensity !== 1) data.object.backgroundIntensity = \
this.backgroundIntensity;\n    data.object.backgroundRotation = \
this.backgroundRotation.toArray();\n    if (this.environmentIntensity !== 1) \
data.object.environmentIntensity = this.environmentIntensity;\n    \
data.object.environmentRotation = this.environmentRotation.toArray();\n    \
return data;\n  }\n};\nvar InterleavedBuffer = class {\n  constructor(array, \
stride) {\n    this.isInterleavedBuffer = true;\n    this.array = array;\n    \
this.stride = stride;\n    this.count = array !== void 0 ? array.length / \
stride : 0;\n    this.usage = StaticDrawUsage2;\n    this.updateRanges = \
[];\n    this.version = 0;\n    this.uuid = generateUUID2();\n  }\n  \
onUploadCallback() {\n  }\n  set needsUpdate(value) {\n    if (value === \
true) this.version++;\n  }\n  setUsage(value) {\n    this.usage = value;\n    \
return this;\n  }\n  addUpdateRange(start, count) {\n    \
this.updateRanges.push({ start, count });\n  }\n  clearUpdateRanges() {\n    \
this.updateRanges.length = 0;\n  }\n  copy(source) {\n    this.array = new \
source.array.constructor(source.array);\n    this.count = source.count;\n    \
this.stride = source.stride;\n    this.usage = source.usage;\n    return \
this;\n  }\n  copyAt(index1, attribute2, index22) {\n    index1 *= \
this.stride;\n    index22 *= attribute2.stride;\n    for (let i = 0, l = \
this.stride; i < l; i++) {\n      this.array[index1 + i] = \
attribute2.array[index22 + i];\n    }\n    return this;\n  }\n  set(value, \
offset = 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n  \
clone(data) {\n    if (data.arrayBuffers === void 0) {\n      \
data.arrayBuffers = {};\n    }\n    if (this.array.buffer._uuid === void 0) \
{\n      this.array.buffer._uuid = generateUUID2();\n    }\n    if \
(data.arrayBuffers[this.array.buffer._uuid] === void 0) {\n      \
data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n    \
}\n    const array = new \
this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n    \
const ib = new this.constructor(array, this.stride);\n    \
ib.setUsage(this.usage);\n    return ib;\n  }\n  onUpload(callback) {\n    \
this.onUploadCallback = callback;\n    return this;\n  }\n  toJSON(data) {\n  \
  if (data.arrayBuffers === void 0) {\n      data.arrayBuffers = {};\n    }\n \
   if (this.array.buffer._uuid === void 0) {\n      this.array.buffer._uuid = \
generateUUID2();\n    }\n    if (data.arrayBuffers[this.array.buffer._uuid] \
=== void 0) {\n      data.arrayBuffers[this.array.buffer._uuid] = \
Array.from(new Uint32Array(this.array.buffer));\n    }\n    return {\n      \
uuid: this.uuid,\n      buffer: this.array.buffer._uuid,\n      type: \
this.array.constructor.name,\n      stride: this.stride\n    };\n  }\n};\nvar \
_vector$72 = /* @__PURE__ */ new Vector32();\nvar InterleavedBufferAttribute \
= class _InterleavedBufferAttribute {\n  constructor(interleavedBuffer, \
itemSize, offset, normalized = false) {\n    \
this.isInterleavedBufferAttribute = true;\n    this.name = \"\";\n    \
this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    \
this.offset = offset;\n    this.normalized = normalized;\n  }\n  get count() \
{\n    return this.data.count;\n  }\n  get array() {\n    return \
this.data.array;\n  }\n  set needsUpdate(value) {\n    this.data.needsUpdate \
= value;\n  }\n  applyMatrix4(m2) {\n    for (let i = 0, l = this.data.count; \
i < l; i++) {\n      _vector$72.fromBufferAttribute(this, i);\n      \
_vector$72.applyMatrix4(m2);\n      this.setXYZ(i, _vector$72.x, \
_vector$72.y, _vector$72.z);\n    }\n    return this;\n  }\n  \
applyNormalMatrix(m2) {\n    for (let i = 0, l = this.count; i < l; i++) {\n  \
    _vector$72.fromBufferAttribute(this, i);\n      \
_vector$72.applyNormalMatrix(m2);\n      this.setXYZ(i, _vector$72.x, \
_vector$72.y, _vector$72.z);\n    }\n    return this;\n  }\n  \
transformDirection(m2) {\n    for (let i = 0, l = this.count; i < l; i++) {\n \
     _vector$72.fromBufferAttribute(this, i);\n      \
_vector$72.transformDirection(m2);\n      this.setXYZ(i, _vector$72.x, \
_vector$72.y, _vector$72.z);\n    }\n    return this;\n  }\n  \
getComponent(index5, component) {\n    let value = this.array[index5 * \
this.data.stride + this.offset + component];\n    if (this.normalized) value \
= denormalize2(value, this.array);\n    return value;\n  }\n  \
setComponent(index5, component, value) {\n    if (this.normalized) value = \
normalize$1(value, this.array);\n    this.data.array[index5 * \
this.data.stride + this.offset + component] = value;\n    return this;\n  }\n \
 setX(index5, x2) {\n    if (this.normalized) x2 = normalize$1(x2, \
this.array);\n    this.data.array[index5 * this.data.stride + this.offset] = \
x2;\n    return this;\n  }\n  setY(index5, y2) {\n    if (this.normalized) y2 \
= normalize$1(y2, this.array);\n    this.data.array[index5 * this.data.stride \
+ this.offset + 1] = y2;\n    return this;\n  }\n  setZ(index5, z2) {\n    if \
(this.normalized) z2 = normalize$1(z2, this.array);\n    \
this.data.array[index5 * this.data.stride + this.offset + 2] = z2;\n    \
return this;\n  }\n  setW(index5, w) {\n    if (this.normalized) w = \
normalize$1(w, this.array);\n    this.data.array[index5 * this.data.stride + \
this.offset + 3] = w;\n    return this;\n  }\n  getX(index5) {\n    let x2 = \
this.data.array[index5 * this.data.stride + this.offset];\n    if \
(this.normalized) x2 = denormalize2(x2, this.array);\n    return x2;\n  }\n  \
getY(index5) {\n    let y2 = this.data.array[index5 * this.data.stride + \
this.offset + 1];\n    if (this.normalized) y2 = denormalize2(y2, \
this.array);\n    return y2;\n  }\n  getZ(index5) {\n    let z2 = \
this.data.array[index5 * this.data.stride + this.offset + 2];\n    if \
(this.normalized) z2 = denormalize2(z2, this.array);\n    return z2;\n  }\n  \
getW(index5) {\n    let w = this.data.array[index5 * this.data.stride + \
this.offset + 3];\n    if (this.normalized) w = denormalize2(w, \
this.array);\n    return w;\n  }\n  setXY(index5, x2, y2) {\n    index5 = \
index5 * this.data.stride + this.offset;\n    if (this.normalized) {\n      \
x2 = normalize$1(x2, this.array);\n      y2 = normalize$1(y2, this.array);\n  \
  }\n    this.data.array[index5 + 0] = x2;\n    this.data.array[index5 + 1] = \
y2;\n    return this;\n  }\n  setXYZ(index5, x2, y2, z2) {\n    index5 = \
index5 * this.data.stride + this.offset;\n    if (this.normalized) {\n      \
x2 = normalize$1(x2, this.array);\n      y2 = normalize$1(y2, this.array);\n  \
    z2 = normalize$1(z2, this.array);\n    }\n    this.data.array[index5 + 0] \
= x2;\n    this.data.array[index5 + 1] = y2;\n    this.data.array[index5 + 2] \
= z2;\n    return this;\n  }\n  setXYZW(index5, x2, y2, z2, w) {\n    index5 \
= index5 * this.data.stride + this.offset;\n    if (this.normalized) {\n      \
x2 = normalize$1(x2, this.array);\n      y2 = normalize$1(y2, this.array);\n  \
    z2 = normalize$1(z2, this.array);\n      w = normalize$1(w, \
this.array);\n    }\n    this.data.array[index5 + 0] = x2;\n    \
this.data.array[index5 + 1] = y2;\n    this.data.array[index5 + 2] = z2;\n    \
this.data.array[index5 + 3] = w;\n    return this;\n  }\n  clone(data) {\n    \
if (data === void 0) {\n      \
console.log(\"THREE.InterleavedBufferAttribute.clone(): Cloning an \
interleaved buffer attribute will de-interleave buffer data.\");\n      const \
array = [];\n      for (let i = 0; i < this.count; i++) {\n        const \
index5 = i * this.data.stride + this.offset;\n        for (let j = 0; j < \
this.itemSize; j++) {\n          array.push(this.data.array[index5 + j]);\n   \
     }\n      }\n      return new BufferAttribute2(new \
this.array.constructor(array), this.itemSize, this.normalized);\n    } else \
{\n      if (data.interleavedBuffers === void 0) {\n        \
data.interleavedBuffers = {};\n      }\n      if \
(data.interleavedBuffers[this.data.uuid] === void 0) {\n        \
data.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n      }\n   \
   return new \
_InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], \
this.itemSize, this.offset, this.normalized);\n    }\n  }\n  toJSON(data) {\n \
   if (data === void 0) {\n      \
console.log(\"THREE.InterleavedBufferAttribute.toJSON(): Serializing an \
interleaved buffer attribute will de-interleave buffer data.\");\n      const \
array = [];\n      for (let i = 0; i < this.count; i++) {\n        const \
index5 = i * this.data.stride + this.offset;\n        for (let j = 0; j < \
this.itemSize; j++) {\n          array.push(this.data.array[index5 + j]);\n   \
     }\n      }\n      return {\n        itemSize: this.itemSize,\n        \
type: this.array.constructor.name,\n        array,\n        normalized: \
this.normalized\n      };\n    } else {\n      if (data.interleavedBuffers \
=== void 0) {\n        data.interleavedBuffers = {};\n      }\n      if \
(data.interleavedBuffers[this.data.uuid] === void 0) {\n        \
data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n      }\n  \
    return {\n        isInterleavedBufferAttribute: true,\n        itemSize: \
this.itemSize,\n        data: this.data.uuid,\n        offset: this.offset,\n \
       normalized: this.normalized\n      };\n    }\n  }\n};\nvar \
SpriteMaterial = class extends Material2 {\n  static get type() {\n    return \
\"SpriteMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    \
this.isSpriteMaterial = true;\n    this.color = new Color2(16777215);\n    \
this.map = null;\n    this.alphaMap = null;\n    this.rotation = 0;\n    \
this.sizeAttenuation = true;\n    this.transparent = true;\n    this.fog = \
true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.color.copy(source.color);\n    this.map = \
source.map;\n    this.alphaMap = source.alphaMap;\n    this.rotation = \
source.rotation;\n    this.sizeAttenuation = source.sizeAttenuation;\n    \
this.fog = source.fog;\n    return this;\n  }\n};\nvar DataTexture = class \
extends Texture2 {\n  constructor(data = null, width = 1, height = 1, \
format2, type, mapping, wrapS, wrapT, magFilter = NearestFilter2, minFilter = \
NearestFilter2, anisotropy2, colorSpace) {\n    super(null, mapping, wrapS, \
wrapT, magFilter, minFilter, format2, type, anisotropy2, colorSpace);\n    \
this.isDataTexture = true;\n    this.image = { data, width, height };\n    \
this.generateMipmaps = false;\n    this.flipY = false;\n    \
this.unpackAlignment = 1;\n  }\n};\nvar InstancedBufferAttribute = class \
extends BufferAttribute2 {\n  constructor(array, itemSize, normalized, \
meshPerAttribute = 1) {\n    super(array, itemSize, normalized);\n    \
this.isInstancedBufferAttribute = true;\n    this.meshPerAttribute = \
meshPerAttribute;\n  }\n  copy(source) {\n    super.copy(source);\n    \
this.meshPerAttribute = source.meshPerAttribute;\n    return this;\n  }\n  \
toJSON() {\n    const data = super.toJSON();\n    data.meshPerAttribute = \
this.meshPerAttribute;\n    data.isInstancedBufferAttribute = true;\n    \
return data;\n  }\n};\nvar _vector12 = /* @__PURE__ */ new Vector32();\nvar \
_vector22 = /* @__PURE__ */ new Vector32();\nvar _normalMatrix2 = /* \
@__PURE__ */ new Matrix32();\nvar Plane2 = class {\n  constructor(normal2 = \
new Vector32(1, 0, 0), constant = 0) {\n    this.isPlane = true;\n    \
this.normal = normal2;\n    this.constant = constant;\n  }\n  set(normal2, \
constant) {\n    this.normal.copy(normal2);\n    this.constant = constant;\n  \
  return this;\n  }\n  setComponents(x2, y2, z2, w) {\n    \
this.normal.set(x2, y2, z2);\n    this.constant = w;\n    return this;\n  }\n \
 setFromNormalAndCoplanarPoint(normal2, point) {\n    \
this.normal.copy(normal2);\n    this.constant = -point.dot(this.normal);\n    \
return this;\n  }\n  setFromCoplanarPoints(a2, b, c2) {\n    const normal2 = \
_vector12.subVectors(c2, b).cross(_vector22.subVectors(a2, b)).normalize();\n \
   this.setFromNormalAndCoplanarPoint(normal2, a2);\n    return this;\n  }\n  \
copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = \
plane.constant;\n    return this;\n  }\n  normalize() {\n    const \
inverseNormalLength = 1 / this.normal.length();\n    \
this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= \
inverseNormalLength;\n    return this;\n  }\n  negate() {\n    this.constant \
*= -1;\n    this.normal.negate();\n    return this;\n  }\n  \
distanceToPoint(point) {\n    return this.normal.dot(point) + \
this.constant;\n  }\n  distanceToSphere(sphere) {\n    return \
this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n  \
projectPoint(point, target) {\n    return \
target.copy(point).addScaledVector(this.normal, \
-this.distanceToPoint(point));\n  }\n  intersectLine(line, target) {\n    \
const direction2 = line.delta(_vector12);\n    const denominator = \
this.normal.dot(direction2);\n    if (denominator === 0) {\n      if \
(this.distanceToPoint(line.start) === 0) {\n        return \
target.copy(line.start);\n      }\n      return null;\n    }\n    const t = \
-(line.start.dot(this.normal) + this.constant) / denominator;\n    if (t < 0 \
|| t > 1) {\n      return null;\n    }\n    return \
target.copy(line.start).addScaledVector(direction2, t);\n  }\n  \
intersectsLine(line) {\n    const startSign = \
this.distanceToPoint(line.start);\n    const endSign = \
this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || \
endSign < 0 && startSign > 0;\n  }\n  intersectsBox(box) {\n    return \
box.intersectsPlane(this);\n  }\n  intersectsSphere(sphere) {\n    return \
sphere.intersectsPlane(this);\n  }\n  coplanarPoint(target) {\n    return \
target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n  \
applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = \
optionalNormalMatrix || _normalMatrix2.getNormalMatrix(matrix);\n    const \
referencePoint = this.coplanarPoint(_vector12).applyMatrix4(matrix);\n    \
const normal2 = this.normal.applyMatrix3(normalMatrix).normalize();\n    \
this.constant = -referencePoint.dot(normal2);\n    return this;\n  }\n  \
translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    \
return this;\n  }\n  equals(plane) {\n    return \
plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n  \
clone() {\n    return new this.constructor().copy(this);\n  }\n};\nvar \
_sphere$3 = /* @__PURE__ */ new Sphere2();\nvar _vector$6 = /* @__PURE__ */ \
new Vector32();\nvar Frustum2 = class {\n  constructor(p0 = new Plane2(), p1 \
= new Plane2(), p2 = new Plane2(), p3 = new Plane2(), p4 = new Plane2(), p5 = \
new Plane2()) {\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n  set(p0, \
p1, p2, p3, p4, p5) {\n    const planes = this.planes;\n    \
planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    \
planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n    \
return this;\n  }\n  copy(frustum) {\n    const planes = this.planes;\n    \
for (let i = 0; i < 6; i++) {\n      planes[i].copy(frustum.planes[i]);\n    \
}\n    return this;\n  }\n  setFromProjectionMatrix(m2, coordinateSystem = \
WebGLCoordinateSystem2) {\n    const planes = this.planes;\n    const me = \
m2.elements;\n    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n \
   const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n    const me8 = \
me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n    const me12 = me[12], \
me13 = me[13], me14 = me[14], me15 = me[15];\n    planes[0].setComponents(me3 \
- me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n    \
planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + \
me12).normalize();\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + \
me9, me15 + me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - \
me5, me11 - me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - \
me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n    if \
(coordinateSystem === WebGLCoordinateSystem2) {\n      \
planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + \
me14).normalize();\n    } else if (coordinateSystem === \
WebGPUCoordinateSystem2) {\n      planes[5].setComponents(me2, me6, me10, \
me14).normalize();\n    } else {\n      throw new \
Error(\"THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: \
\" + coordinateSystem);\n    }\n    return this;\n  }\n  \
intersectsObject(object) {\n    if (object.boundingSphere !== void 0) {\n     \
 if (object.boundingSphere === null) object.computeBoundingSphere();\n      \
_sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);\n    \
} else {\n      const geometry = object.geometry;\n      if \
(geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      \
_sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n   \
 }\n    return this.intersectsSphere(_sphere$3);\n  }\n  \
intersectsSprite(sprite) {\n    _sphere$3.center.set(0, 0, 0);\n    \
_sphere$3.radius = 0.7071067811865476;\n    \
_sphere$3.applyMatrix4(sprite.matrixWorld);\n    return \
this.intersectsSphere(_sphere$3);\n  }\n  intersectsSphere(sphere) {\n    \
const planes = this.planes;\n    const center = sphere.center;\n    const \
negRadius = -sphere.radius;\n    for (let i = 0; i < 6; i++) {\n      const \
distance2 = planes[i].distanceToPoint(center);\n      if (distance2 < \
negRadius) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \
intersectsBox(box) {\n    const planes = this.planes;\n    for (let i = 0; i \
< 6; i++) {\n      const plane = planes[i];\n      _vector$6.x = \
plane.normal.x > 0 ? box.max.x : box.min.x;\n      _vector$6.y = \
plane.normal.y > 0 ? box.max.y : box.min.y;\n      _vector$6.z = \
plane.normal.z > 0 ? box.max.z : box.min.z;\n      if \
(plane.distanceToPoint(_vector$6) < 0) {\n        return false;\n      }\n    \
}\n    return true;\n  }\n  containsPoint(point) {\n    const planes = \
this.planes;\n    for (let i = 0; i < 6; i++) {\n      if \
(planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    \
}\n    return true;\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n};\nvar LineBasicMaterial2 = class \
extends Material2 {\n  static get type() {\n    return \
\"LineBasicMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    \
this.isLineBasicMaterial = true;\n    this.color = new Color2(16777215);\n    \
this.map = null;\n    this.linewidth = 1;\n    this.linecap = \"round\";\n    \
this.linejoin = \"round\";\n    this.fog = true;\n    \
this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n \
   this.color.copy(source.color);\n    this.map = source.map;\n    \
this.linewidth = source.linewidth;\n    this.linecap = source.linecap;\n    \
this.linejoin = source.linejoin;\n    this.fog = source.fog;\n    return \
this;\n  }\n};\nvar PointsMaterial = class extends Material2 {\n  static get \
type() {\n    return \"PointsMaterial\";\n  }\n  constructor(parameters) {\n  \
  super();\n    this.isPointsMaterial = true;\n    this.color = new \
Color2(16777215);\n    this.map = null;\n    this.alphaMap = null;\n    \
this.size = 1;\n    this.sizeAttenuation = true;\n    this.fog = true;\n    \
this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n \
   this.color.copy(source.color);\n    this.map = source.map;\n    \
this.alphaMap = source.alphaMap;\n    this.size = source.size;\n    \
this.sizeAttenuation = source.sizeAttenuation;\n    this.fog = source.fog;\n  \
  return this;\n  }\n};\nvar FramebufferTexture = class extends Texture2 {\n  \
constructor(width, height) {\n    super({ width, height });\n    \
this.isFramebufferTexture = true;\n    this.magFilter = NearestFilter2;\n    \
this.minFilter = NearestFilter2;\n    this.generateMipmaps = false;\n    \
this.needsUpdate = true;\n  }\n};\nvar DepthTexture2 = class extends Texture2 \
{\n  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, \
minFilter, anisotropy2, format2 = DepthFormat2) {\n    if (format2 !== \
DepthFormat2 && format2 !== DepthStencilFormat2) {\n      throw new \
Error(\"DepthTexture format must be either THREE.DepthFormat or \
THREE.DepthStencilFormat\");\n    }\n    if (type === void 0 && format2 === \
DepthFormat2) type = UnsignedIntType2;\n    if (type === void 0 && format2 \
=== DepthStencilFormat2) type = UnsignedInt248Type2;\n    super(null, \
mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy2);\n   \
 this.isDepthTexture = true;\n    this.image = { width, height };\n    \
this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter2;\n    \
this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter2;\n    \
this.flipY = false;\n    this.generateMipmaps = false;\n    \
this.compareFunction = null;\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.compareFunction = source.compareFunction;\n    \
return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n   \
 if (this.compareFunction !== null) data.compareFunction = \
this.compareFunction;\n    return data;\n  }\n};\nvar SphereGeometry2 = class \
_SphereGeometry extends BufferGeometry2 {\n  constructor(radius = 1, \
widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * \
2, thetaStart = 0, thetaLength = Math.PI) {\n    super();\n    this.type = \
\"SphereGeometry\";\n    this.parameters = {\n      radius,\n      \
widthSegments,\n      heightSegments,\n      phiStart,\n      phiLength,\n    \
  thetaStart,\n      thetaLength\n    };\n    widthSegments = Math.max(3, \
Math.floor(widthSegments));\n    heightSegments = Math.max(2, \
Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + \
thetaLength, Math.PI);\n    let index5 = 0;\n    const grid = [];\n    const \
vertex2 = new Vector32();\n    const normal2 = new Vector32();\n    const \
indices = [];\n    const vertices = [];\n    const normals = [];\n    const \
uvs = [];\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const \
verticesRow = [];\n      const v = iy / heightSegments;\n      let uOffset = \
0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / \
widthSegments;\n      } else if (iy === heightSegments && thetaEnd === \
Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let \
ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n \
       vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * \
Math.sin(thetaStart + v * thetaLength);\n        vertex2.y = radius * \
Math.cos(thetaStart + v * thetaLength);\n        vertex2.z = radius * \
Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * \
thetaLength);\n        vertices.push(vertex2.x, vertex2.y, vertex2.z);\n      \
  normal2.copy(vertex2).normalize();\n        normals.push(normal2.x, \
normal2.y, normal2.z);\n        uvs.push(u + uOffset, 1 - v);\n        \
verticesRow.push(index5++);\n      }\n      grid.push(verticesRow);\n    }\n  \
  for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < \
widthSegments; ix++) {\n        const a2 = grid[iy][ix + 1];\n        const b \
= grid[iy][ix];\n        const c2 = grid[iy + 1][ix];\n        const d = \
grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) \
indices.push(a2, b, d);\n        if (iy !== heightSegments - 1 || thetaEnd < \
Math.PI) indices.push(b, c2, d);\n      }\n    }\n    \
this.setIndex(indices);\n    this.setAttribute(\"position\", new \
Float32BufferAttribute2(vertices, 3));\n    this.setAttribute(\"normal\", new \
Float32BufferAttribute2(normals, 3));\n    this.setAttribute(\"uv\", new \
Float32BufferAttribute2(uvs, 2));\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.parameters = Object.assign({}, \
source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    \
return new _SphereGeometry(data.radius, data.widthSegments, \
data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, \
data.thetaLength);\n  }\n};\nvar ShadowMaterial = class extends Material2 {\n \
 static get type() {\n    return \"ShadowMaterial\";\n  }\n  \
constructor(parameters) {\n    super();\n    this.isShadowMaterial = true;\n  \
  this.color = new Color2(0);\n    this.transparent = true;\n    this.fog = \
true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.color.copy(source.color);\n    this.fog = \
source.fog;\n    return this;\n  }\n};\nvar MeshStandardMaterial = class \
extends Material2 {\n  static get type() {\n    return \
\"MeshStandardMaterial\";\n  }\n  constructor(parameters) {\n    super();\n   \
 this.isMeshStandardMaterial = true;\n    this.defines = { \"STANDARD\": \"\" \
};\n    this.color = new Color2(16777215);\n    this.roughness = 1;\n    \
this.metalness = 0;\n    this.map = null;\n    this.lightMap = null;\n    \
this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity \
= 1;\n    this.emissive = new Color2(0);\n    this.emissiveIntensity = 1;\n   \
 this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = \
1;\n    this.normalMap = null;\n    this.normalMapType = \
TangentSpaceNormalMap2;\n    this.normalScale = new Vector22(1, 1);\n    \
this.displacementMap = null;\n    this.displacementScale = 1;\n    \
this.displacementBias = 0;\n    this.roughnessMap = null;\n    \
this.metalnessMap = null;\n    this.alphaMap = null;\n    this.envMap = \
null;\n    this.envMapRotation = new Euler2();\n    this.envMapIntensity = \
1;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    \
this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n \
   this.flatShading = false;\n    this.fog = true;\n    \
this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n \
   this.defines = { \"STANDARD\": \"\" };\n    \
this.color.copy(source.color);\n    this.roughness = source.roughness;\n    \
this.metalness = source.metalness;\n    this.map = source.map;\n    \
this.lightMap = source.lightMap;\n    this.lightMapIntensity = \
source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    \
this.aoMapIntensity = source.aoMapIntensity;\n    \
this.emissive.copy(source.emissive);\n    this.emissiveMap = \
source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n \
   this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n   \
 this.normalMap = source.normalMap;\n    this.normalMapType = \
source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    \
this.displacementMap = source.displacementMap;\n    this.displacementScale = \
source.displacementScale;\n    this.displacementBias = \
source.displacementBias;\n    this.roughnessMap = source.roughnessMap;\n    \
this.metalnessMap = source.metalnessMap;\n    this.alphaMap = \
source.alphaMap;\n    this.envMap = source.envMap;\n    \
this.envMapRotation.copy(source.envMapRotation);\n    this.envMapIntensity = \
source.envMapIntensity;\n    this.wireframe = source.wireframe;\n    \
this.wireframeLinewidth = source.wireframeLinewidth;\n    \
this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin \
= source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    \
this.fog = source.fog;\n    return this;\n  }\n};\nvar MeshPhysicalMaterial = \
class extends MeshStandardMaterial {\n  static get type() {\n    return \
\"MeshPhysicalMaterial\";\n  }\n  constructor(parameters) {\n    super();\n   \
 this.isMeshPhysicalMaterial = true;\n    this.defines = {\n      \
\"STANDARD\": \"\",\n      \"PHYSICAL\": \"\"\n    };\n    \
this.anisotropyRotation = 0;\n    this.anisotropyMap = null;\n    \
this.clearcoatMap = null;\n    this.clearcoatRoughness = 0;\n    \
this.clearcoatRoughnessMap = null;\n    this.clearcoatNormalScale = new \
Vector22(1, 1);\n    this.clearcoatNormalMap = null;\n    this.ior = 1.5;\n   \
 Object.defineProperty(this, \"reflectivity\", {\n      get: function() {\n   \
     return clamp$1(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);\n      },\n \
     set: function(reflectivity) {\n        this.ior = (1 + 0.4 * \
reflectivity) / (1 - 0.4 * reflectivity);\n      }\n    });\n    \
this.iridescenceMap = null;\n    this.iridescenceIOR = 1.3;\n    \
this.iridescenceThicknessRange = [100, 400];\n    \
this.iridescenceThicknessMap = null;\n    this.sheenColor = new Color2(0);\n  \
  this.sheenColorMap = null;\n    this.sheenRoughness = 1;\n    \
this.sheenRoughnessMap = null;\n    this.transmissionMap = null;\n    \
this.thickness = 0;\n    this.thicknessMap = null;\n    \
this.attenuationDistance = Infinity;\n    this.attenuationColor = new \
Color2(1, 1, 1);\n    this.specularIntensity = 1;\n    \
this.specularIntensityMap = null;\n    this.specularColor = new Color2(1, 1, \
1);\n    this.specularColorMap = null;\n    this._anisotropy = 0;\n    \
this._clearcoat = 0;\n    this._dispersion = 0;\n    this._iridescence = 0;\n \
   this._sheen = 0;\n    this._transmission = 0;\n    \
this.setValues(parameters);\n  }\n  get anisotropy() {\n    return \
this._anisotropy;\n  }\n  set anisotropy(value) {\n    if (this._anisotropy > \
0 !== value > 0) {\n      this.version++;\n    }\n    this._anisotropy = \
value;\n  }\n  get clearcoat() {\n    return this._clearcoat;\n  }\n  set \
clearcoat(value) {\n    if (this._clearcoat > 0 !== value > 0) {\n      \
this.version++;\n    }\n    this._clearcoat = value;\n  }\n  get \
iridescence() {\n    return this._iridescence;\n  }\n  set iridescence(value) \
{\n    if (this._iridescence > 0 !== value > 0) {\n      this.version++;\n    \
}\n    this._iridescence = value;\n  }\n  get dispersion() {\n    return \
this._dispersion;\n  }\n  set dispersion(value) {\n    if (this._dispersion > \
0 !== value > 0) {\n      this.version++;\n    }\n    this._dispersion = \
value;\n  }\n  get sheen() {\n    return this._sheen;\n  }\n  set \
sheen(value) {\n    if (this._sheen > 0 !== value > 0) {\n      \
this.version++;\n    }\n    this._sheen = value;\n  }\n  get transmission() \
{\n    return this._transmission;\n  }\n  set transmission(value) {\n    if \
(this._transmission > 0 !== value > 0) {\n      this.version++;\n    }\n    \
this._transmission = value;\n  }\n  copy(source) {\n    super.copy(source);\n \
   this.defines = {\n      \"STANDARD\": \"\",\n      \"PHYSICAL\": \"\"\n    \
};\n    this.anisotropy = source.anisotropy;\n    this.anisotropyRotation = \
source.anisotropyRotation;\n    this.anisotropyMap = source.anisotropyMap;\n  \
  this.clearcoat = source.clearcoat;\n    this.clearcoatMap = \
source.clearcoatMap;\n    this.clearcoatRoughness = \
source.clearcoatRoughness;\n    this.clearcoatRoughnessMap = \
source.clearcoatRoughnessMap;\n    this.clearcoatNormalMap = \
source.clearcoatNormalMap;\n    \
this.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n    \
this.dispersion = source.dispersion;\n    this.ior = source.ior;\n    \
this.iridescence = source.iridescence;\n    this.iridescenceMap = \
source.iridescenceMap;\n    this.iridescenceIOR = source.iridescenceIOR;\n    \
this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];\n    \
this.iridescenceThicknessMap = source.iridescenceThicknessMap;\n    \
this.sheen = source.sheen;\n    this.sheenColor.copy(source.sheenColor);\n    \
this.sheenColorMap = source.sheenColorMap;\n    this.sheenRoughness = \
source.sheenRoughness;\n    this.sheenRoughnessMap = \
source.sheenRoughnessMap;\n    this.transmission = source.transmission;\n    \
this.transmissionMap = source.transmissionMap;\n    this.thickness = \
source.thickness;\n    this.thicknessMap = source.thicknessMap;\n    \
this.attenuationDistance = source.attenuationDistance;\n    \
this.attenuationColor.copy(source.attenuationColor);\n    \
this.specularIntensity = source.specularIntensity;\n    \
this.specularIntensityMap = source.specularIntensityMap;\n    \
this.specularColor.copy(source.specularColor);\n    this.specularColorMap = \
source.specularColorMap;\n    return this;\n  }\n};\nvar MeshPhongMaterial = \
class extends Material2 {\n  static get type() {\n    return \
\"MeshPhongMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    \
this.isMeshPhongMaterial = true;\n    this.color = new Color2(16777215);\n    \
this.specular = new Color2(1118481);\n    this.shininess = 30;\n    this.map \
= null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    \
this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.emissive = new \
Color2(0);\n    this.emissiveIntensity = 1;\n    this.emissiveMap = null;\n   \
 this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n  \
  this.normalMapType = TangentSpaceNormalMap2;\n    this.normalScale = new \
Vector22(1, 1);\n    this.displacementMap = null;\n    this.displacementScale \
= 1;\n    this.displacementBias = 0;\n    this.specularMap = null;\n    \
this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new \
Euler2();\n    this.combine = MultiplyOperation2;\n    this.reflectivity = \
1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    \
this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    \
this.wireframeLinejoin = \"round\";\n    this.flatShading = false;\n    \
this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.color.copy(source.color);\n    \
this.specular.copy(source.specular);\n    this.shininess = \
source.shininess;\n    this.map = source.map;\n    this.lightMap = \
source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    \
this.aoMap = source.aoMap;\n    this.aoMapIntensity = \
source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    \
this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = \
source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    \
this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n  \
  this.normalMapType = source.normalMapType;\n    \
this.normalScale.copy(source.normalScale);\n    this.displacementMap = \
source.displacementMap;\n    this.displacementScale = \
source.displacementScale;\n    this.displacementBias = \
source.displacementBias;\n    this.specularMap = source.specularMap;\n    \
this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    \
this.envMapRotation.copy(source.envMapRotation);\n    this.combine = \
source.combine;\n    this.reflectivity = source.reflectivity;\n    \
this.refractionRatio = source.refractionRatio;\n    this.wireframe = \
source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n \
   this.wireframeLinecap = source.wireframeLinecap;\n    \
this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = \
source.flatShading;\n    this.fog = source.fog;\n    return this;\n  \
}\n};\nvar MeshToonMaterial = class extends Material2 {\n  static get type() \
{\n    return \"MeshToonMaterial\";\n  }\n  constructor(parameters) {\n    \
super();\n    this.isMeshToonMaterial = true;\n    this.defines = { \"TOON\": \
\"\" };\n    this.color = new Color2(16777215);\n    this.map = null;\n    \
this.gradientMap = null;\n    this.lightMap = null;\n    \
this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity \
= 1;\n    this.emissive = new Color2(0);\n    this.emissiveIntensity = 1;\n   \
 this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = \
1;\n    this.normalMap = null;\n    this.normalMapType = \
TangentSpaceNormalMap2;\n    this.normalScale = new Vector22(1, 1);\n    \
this.displacementMap = null;\n    this.displacementScale = 1;\n    \
this.displacementBias = 0;\n    this.alphaMap = null;\n    this.wireframe = \
false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \
\"round\";\n    this.wireframeLinejoin = \"round\";\n    this.fog = true;\n   \
 this.setValues(parameters);\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.color.copy(source.color);\n    this.map = \
source.map;\n    this.gradientMap = source.gradientMap;\n    this.lightMap = \
source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    \
this.aoMap = source.aoMap;\n    this.aoMapIntensity = \
source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    \
this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = \
source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    \
this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n  \
  this.normalMapType = source.normalMapType;\n    \
this.normalScale.copy(source.normalScale);\n    this.displacementMap = \
source.displacementMap;\n    this.displacementScale = \
source.displacementScale;\n    this.displacementBias = \
source.displacementBias;\n    this.alphaMap = source.alphaMap;\n    \
this.wireframe = source.wireframe;\n    this.wireframeLinewidth = \
source.wireframeLinewidth;\n    this.wireframeLinecap = \
source.wireframeLinecap;\n    this.wireframeLinejoin = \
source.wireframeLinejoin;\n    this.fog = source.fog;\n    return this;\n  \
}\n};\nvar MeshNormalMaterial = class extends Material2 {\n  static get \
type() {\n    return \"MeshNormalMaterial\";\n  }\n  constructor(parameters) \
{\n    super();\n    this.isMeshNormalMaterial = true;\n    this.bumpMap = \
null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    \
this.normalMapType = TangentSpaceNormalMap2;\n    this.normalScale = new \
Vector22(1, 1);\n    this.displacementMap = null;\n    this.displacementScale \
= 1;\n    this.displacementBias = 0;\n    this.wireframe = false;\n    \
this.wireframeLinewidth = 1;\n    this.flatShading = false;\n    \
this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n \
   this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n   \
 this.normalMap = source.normalMap;\n    this.normalMapType = \
source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    \
this.displacementMap = source.displacementMap;\n    this.displacementScale = \
source.displacementScale;\n    this.displacementBias = \
source.displacementBias;\n    this.wireframe = source.wireframe;\n    \
this.wireframeLinewidth = source.wireframeLinewidth;\n    this.flatShading = \
source.flatShading;\n    return this;\n  }\n};\nvar MeshLambertMaterial2 = \
class extends Material2 {\n  static get type() {\n    return \
\"MeshLambertMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    \
this.isMeshLambertMaterial = true;\n    this.color = new Color2(16777215);\n  \
  this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = \
1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.emissive = \
new Color2(0);\n    this.emissiveIntensity = 1;\n    this.emissiveMap = \
null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap \
= null;\n    this.normalMapType = TangentSpaceNormalMap2;\n    \
this.normalScale = new Vector22(1, 1);\n    this.displacementMap = null;\n    \
this.displacementScale = 1;\n    this.displacementBias = 0;\n    \
this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = \
null;\n    this.envMapRotation = new Euler2();\n    this.combine = \
MultiplyOperation2;\n    this.reflectivity = 1;\n    this.refractionRatio = \
0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    \
this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n \
   this.flatShading = false;\n    this.fog = true;\n    \
this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n \
   this.color.copy(source.color);\n    this.map = source.map;\n    \
this.lightMap = source.lightMap;\n    this.lightMapIntensity = \
source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    \
this.aoMapIntensity = source.aoMapIntensity;\n    \
this.emissive.copy(source.emissive);\n    this.emissiveMap = \
source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n \
   this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n   \
 this.normalMap = source.normalMap;\n    this.normalMapType = \
source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    \
this.displacementMap = source.displacementMap;\n    this.displacementScale = \
source.displacementScale;\n    this.displacementBias = \
source.displacementBias;\n    this.specularMap = source.specularMap;\n    \
this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    \
this.envMapRotation.copy(source.envMapRotation);\n    this.combine = \
source.combine;\n    this.reflectivity = source.reflectivity;\n    \
this.refractionRatio = source.refractionRatio;\n    this.wireframe = \
source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n \
   this.wireframeLinecap = source.wireframeLinecap;\n    \
this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = \
source.flatShading;\n    this.fog = source.fog;\n    return this;\n  \
}\n};\nvar MeshMatcapMaterial = class extends Material2 {\n  static get \
type() {\n    return \"MeshMatcapMaterial\";\n  }\n  constructor(parameters) \
{\n    super();\n    this.isMeshMatcapMaterial = true;\n    this.defines = { \
\"MATCAP\": \"\" };\n    this.color = new Color2(16777215);\n    this.matcap \
= null;\n    this.map = null;\n    this.bumpMap = null;\n    this.bumpScale = \
1;\n    this.normalMap = null;\n    this.normalMapType = \
TangentSpaceNormalMap2;\n    this.normalScale = new Vector22(1, 1);\n    \
this.displacementMap = null;\n    this.displacementScale = 1;\n    \
this.displacementBias = 0;\n    this.alphaMap = null;\n    this.flatShading = \
false;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.defines = { \"MATCAP\": \
\"\" };\n    this.color.copy(source.color);\n    this.matcap = \
source.matcap;\n    this.map = source.map;\n    this.bumpMap = \
source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = \
source.normalMap;\n    this.normalMapType = source.normalMapType;\n    \
this.normalScale.copy(source.normalScale);\n    this.displacementMap = \
source.displacementMap;\n    this.displacementScale = \
source.displacementScale;\n    this.displacementBias = \
source.displacementBias;\n    this.alphaMap = source.alphaMap;\n    \
this.flatShading = source.flatShading;\n    this.fog = source.fog;\n    \
return this;\n  }\n};\nvar LineDashedMaterial = class extends \
LineBasicMaterial2 {\n  static get type() {\n    return \
\"LineDashedMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    \
this.isLineDashedMaterial = true;\n    this.scale = 1;\n    this.dashSize = \
3;\n    this.gapSize = 1;\n    this.setValues(parameters);\n  }\n  \
copy(source) {\n    super.copy(source);\n    this.scale = source.scale;\n    \
this.dashSize = source.dashSize;\n    this.gapSize = source.gapSize;\n    \
return this;\n  }\n};\nfunction convertArray2(array, type, forceClone) {\n  \
if (!array || // let 'undefined' and 'null' pass\n  !forceClone && \
array.constructor === type) return array;\n  if (typeof \
type.BYTES_PER_ELEMENT === \"number\") {\n    return new type(array);\n  }\n  \
return Array.prototype.slice.call(array);\n}\nfunction isTypedArray2(object) \
{\n  return ArrayBuffer.isView(object) && !(object instanceof \
DataView);\n}\nvar Interpolant2 = class {\n  constructor(parameterPositions, \
sampleValues, sampleSize, resultBuffer) {\n    this.parameterPositions = \
parameterPositions;\n    this._cachedIndex = 0;\n    this.resultBuffer = \
resultBuffer !== void 0 ? resultBuffer : new \
sampleValues.constructor(sampleSize);\n    this.sampleValues = \
sampleValues;\n    this.valueSize = sampleSize;\n    this.settings = null;\n  \
  this.DefaultSettings_ = {};\n  }\n  evaluate(t) {\n    const pp = \
this.parameterPositions;\n    let i1 = this._cachedIndex, t1 = pp[i1], t0 = \
pp[i1 - 1];\n    validate_interval: {\n      seek: {\n        let right;\n    \
    linear_scan: {\n          forward_scan: if (!(t < t1)) {\n            for \
(let giveUpAt = i1 + 2; ; ) {\n              if (t1 === void 0) {\n           \
     if (t < t0) break forward_scan;\n                i1 = pp.length;\n       \
         this._cachedIndex = i1;\n                return \
this.copySampleValue_(i1 - 1);\n              }\n              if (i1 === \
giveUpAt) break;\n              t0 = t1;\n              t1 = pp[++i1];\n      \
        if (t < t1) {\n                break seek;\n              }\n         \
   }\n            right = pp.length;\n            break linear_scan;\n        \
  }\n          if (!(t >= t0)) {\n            const t1global = pp[1];\n       \
     if (t < t1global) {\n              i1 = 2;\n              t0 = \
t1global;\n            }\n            for (let giveUpAt = i1 - 2; ; ) {\n     \
         if (t0 === void 0) {\n                this._cachedIndex = 0;\n       \
         return this.copySampleValue_(0);\n              }\n              if \
(i1 === giveUpAt) break;\n              t1 = t0;\n              t0 = pp[--i1 \
- 1];\n              if (t >= t0) {\n                break seek;\n            \
  }\n            }\n            right = i1;\n            i1 = 0;\n            \
break linear_scan;\n          }\n          break validate_interval;\n        \
}\n        while (i1 < right) {\n          const mid = i1 + right >>> 1;\n    \
      if (t < pp[mid]) {\n            right = mid;\n          } else {\n      \
      i1 = mid + 1;\n          }\n        }\n        t1 = pp[i1];\n        t0 \
= pp[i1 - 1];\n        if (t0 === void 0) {\n          this._cachedIndex = \
0;\n          return this.copySampleValue_(0);\n        }\n        if (t1 === \
void 0) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n     \
     return this.copySampleValue_(i1 - 1);\n        }\n      }\n      \
this._cachedIndex = i1;\n      this.intervalChanged_(i1, t0, t1);\n    }\n    \
return this.interpolate_(i1, t0, t, t1);\n  }\n  getSettings_() {\n    return \
this.settings || this.DefaultSettings_;\n  }\n  copySampleValue_(index5) {\n  \
  const result = this.resultBuffer, values = this.sampleValues, stride = \
this.valueSize, offset = index5 * stride;\n    for (let i = 0; i !== stride; \
++i) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  \
}\n  // Template methods for derived classes:\n  interpolate_() {\n    throw \
new Error(\"call to abstract method\");\n  }\n  intervalChanged_() {\n  \
}\n};\nvar CubicInterpolant2 = class extends Interpolant2 {\n  \
constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n   \
 super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    \
this._weightPrev = -0;\n    this._offsetPrev = -0;\n    this._weightNext = \
-0;\n    this._offsetNext = -0;\n    this.DefaultSettings_ = {\n      \
endingStart: ZeroCurvatureEnding2,\n      endingEnd: ZeroCurvatureEnding2\n   \
 };\n  }\n  intervalChanged_(i1, t0, t1) {\n    const pp = \
this.parameterPositions;\n    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = \
pp[iPrev], tNext = pp[iNext];\n    if (tPrev === void 0) {\n      switch \
(this.getSettings_().endingStart) {\n        case ZeroSlopeEnding2:\n         \
 iPrev = i1;\n          tPrev = 2 * t0 - t1;\n          break;\n        case \
WrapAroundEnding2:\n          iPrev = pp.length - 2;\n          tPrev = t0 + \
pp[iPrev] - pp[iPrev + 1];\n          break;\n        default:\n          \
iPrev = i1;\n          tPrev = t1;\n      }\n    }\n    if (tNext === void 0) \
{\n      switch (this.getSettings_().endingEnd) {\n        case \
ZeroSlopeEnding2:\n          iNext = i1;\n          tNext = 2 * t1 - t0;\n    \
      break;\n        case WrapAroundEnding2:\n          iNext = 1;\n         \
 tNext = t1 + pp[1] - pp[0];\n          break;\n        default:\n          \
iNext = i1 - 1;\n          tNext = t0;\n      }\n    }\n    const halfDt = \
(t1 - t0) * 0.5, stride = this.valueSize;\n    this._weightPrev = halfDt / \
(t0 - tPrev);\n    this._weightNext = halfDt / (tNext - t1);\n    \
this._offsetPrev = iPrev * stride;\n    this._offsetNext = iNext * stride;\n  \
}\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer, \
values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = \
o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = \
this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * \
p, ppp = pp * p;\n    const sP = -wP * ppp + 2 * wP * pp - wP * p;\n    const \
s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const \
s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const sN = wN * ppp - \
wN * pp;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = sP * \
values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + \
i];\n    }\n    return result;\n  }\n};\nvar LinearInterpolant2 = class \
extends Interpolant2 {\n  constructor(parameterPositions, sampleValues, \
sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, \
sampleSize, resultBuffer);\n  }\n  interpolate_(i1, t0, t, t1) {\n    const \
result = this.resultBuffer, values = this.sampleValues, stride = \
this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = \
(t - t0) / (t1 - t0), weight0 = 1 - weight1;\n    for (let i = 0; i !== \
stride; ++i) {\n      result[i] = values[offset0 + i] * weight0 + \
values[offset1 + i] * weight1;\n    }\n    return result;\n  }\n};\nvar \
DiscreteInterpolant2 = class extends Interpolant2 {\n  \
constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n   \
 super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  \
interpolate_(i1) {\n    return this.copySampleValue_(i1 - 1);\n  }\n};\nvar \
KeyframeTrack2 = class {\n  constructor(name, times, values, interpolation) \
{\n    if (name === void 0) throw new Error(\"THREE.KeyframeTrack: track name \
is undefined\");\n    if (times === void 0 || times.length === 0) throw new \
Error(\"THREE.KeyframeTrack: no keyframes in track named \" + name);\n    \
this.name = name;\n    this.times = convertArray2(times, \
this.TimeBufferType);\n    this.values = convertArray2(values, \
this.ValueBufferType);\n    this.setInterpolation(interpolation || \
this.DefaultInterpolation);\n  }\n  // Serialization (in static context, \
because of constructor invocation\n  // and automatic invocation of \
.toJSON):\n  static toJSON(track) {\n    const trackType = \
track.constructor;\n    let json;\n    if (trackType.toJSON !== this.toJSON) \
{\n      json = trackType.toJSON(track);\n    } else {\n      json = {\n      \
  \"name\": track.name,\n        \"times\": convertArray2(track.times, \
Array),\n        \"values\": convertArray2(track.values, Array)\n      };\n   \
   const interpolation = track.getInterpolation();\n      if (interpolation \
!== track.DefaultInterpolation) {\n        json.interpolation = \
interpolation;\n      }\n    }\n    json.type = track.ValueTypeName;\n    \
return json;\n  }\n  InterpolantFactoryMethodDiscrete(result) {\n    return \
new DiscreteInterpolant2(this.times, this.values, this.getValueSize(), \
result);\n  }\n  InterpolantFactoryMethodLinear(result) {\n    return new \
LinearInterpolant2(this.times, this.values, this.getValueSize(), result);\n  \
}\n  InterpolantFactoryMethodSmooth(result) {\n    return new \
CubicInterpolant2(this.times, this.values, this.getValueSize(), result);\n  \
}\n  setInterpolation(interpolation) {\n    let factoryMethod;\n    switch \
(interpolation) {\n      case InterpolateDiscrete2:\n        factoryMethod = \
this.InterpolantFactoryMethodDiscrete;\n        break;\n      case \
InterpolateLinear2:\n        factoryMethod = \
this.InterpolantFactoryMethodLinear;\n        break;\n      case \
InterpolateSmooth2:\n        factoryMethod = \
this.InterpolantFactoryMethodSmooth;\n        break;\n    }\n    if \
(factoryMethod === void 0) {\n      const message = \"unsupported \
interpolation for \" + this.ValueTypeName + \" keyframe track named \" + \
this.name;\n      if (this.createInterpolant === void 0) {\n        if \
(interpolation !== this.DefaultInterpolation) {\n          \
this.setInterpolation(this.DefaultInterpolation);\n        } else {\n         \
 throw new Error(message);\n        }\n      }\n      \
console.warn(\"THREE.KeyframeTrack:\", message);\n      return this;\n    }\n \
   this.createInterpolant = factoryMethod;\n    return this;\n  }\n  \
getInterpolation() {\n    switch (this.createInterpolant) {\n      case \
this.InterpolantFactoryMethodDiscrete:\n        return \
InterpolateDiscrete2;\n      case this.InterpolantFactoryMethodLinear:\n      \
  return InterpolateLinear2;\n      case \
this.InterpolantFactoryMethodSmooth:\n        return InterpolateSmooth2;\n    \
}\n  }\n  getValueSize() {\n    return this.values.length / \
this.times.length;\n  }\n  // move all keyframes either forwards or backwards \
in time\n  shift(timeOffset) {\n    if (timeOffset !== 0) {\n      const \
times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) \
{\n        times[i] += timeOffset;\n      }\n    }\n    return this;\n  }\n  \
// scale all keyframe times by a factor (useful for frame <-> seconds \
conversions)\n  scale(timeScale) {\n    if (timeScale !== 1) {\n      const \
times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) \
{\n        times[i] *= timeScale;\n      }\n    }\n    return this;\n  }\n  \
// removes keyframes before and after animation without changing any values \
within the range [startTime, endTime].\n  // IMPORTANT: We do not shift \
around keys to the start of the track time, because for interpolated keys \
this will change their values\n  trim(startTime, endTime) {\n    const times \
= this.times, nKeys = times.length;\n    let from = 0, to = nKeys - 1;\n    \
while (from !== nKeys && times[from] < startTime) {\n      ++from;\n    }\n   \
 while (to !== -1 && times[to] > endTime) {\n      --to;\n    }\n    ++to;\n  \
  if (from !== 0 || to !== nKeys) {\n      if (from >= to) {\n        to = \
Math.max(to, 1);\n        from = to - 1;\n      }\n      const stride = \
this.getValueSize();\n      this.times = times.slice(from, to);\n      \
this.values = this.values.slice(from * stride, to * stride);\n    }\n    \
return this;\n  }\n  // ensure we do not get a GarbageInGarbageOut situation, \
make sure tracks are at least minimally viable\n  validate() {\n    let valid \
= true;\n    const valueSize = this.getValueSize();\n    if (valueSize - \
Math.floor(valueSize) !== 0) {\n      console.error(\"THREE.KeyframeTrack: \
Invalid value size in track.\", this);\n      valid = false;\n    }\n    \
const times = this.times, values = this.values, nKeys = times.length;\n    if \
(nKeys === 0) {\n      console.error(\"THREE.KeyframeTrack: Track is \
empty.\", this);\n      valid = false;\n    }\n    let prevTime = null;\n    \
for (let i = 0; i !== nKeys; i++) {\n      const currTime = times[i];\n      \
if (typeof currTime === \"number\" && isNaN(currTime)) {\n        \
console.error(\"THREE.KeyframeTrack: Time is not a valid number.\", this, i, \
currTime);\n        valid = false;\n        break;\n      }\n      if \
(prevTime !== null && prevTime > currTime) {\n        \
console.error(\"THREE.KeyframeTrack: Out of order keys.\", this, i, currTime, \
prevTime);\n        valid = false;\n        break;\n      }\n      prevTime = \
currTime;\n    }\n    if (values !== void 0) {\n      if \
(isTypedArray2(values)) {\n        for (let i = 0, n = values.length; i !== \
n; ++i) {\n          const value = values[i];\n          if (isNaN(value)) \
{\n            console.error(\"THREE.KeyframeTrack: Value is not a valid \
number.\", this, i, value);\n            valid = false;\n            break;\n \
         }\n        }\n      }\n    }\n    return valid;\n  }\n  // removes \
equivalent sequential keys as common in morph target sequences\n  // \
(0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n  optimize() {\n    const \
times = this.times.slice(), values = this.values.slice(), stride = \
this.getValueSize(), smoothInterpolation = this.getInterpolation() === \
InterpolateSmooth2, lastIndex = times.length - 1;\n    let writeIndex = 1;\n  \
  for (let i = 1; i < lastIndex; ++i) {\n      let keep = false;\n      const \
time = times[i];\n      const timeNext = times[i + 1];\n      if (time !== \
timeNext && (i !== 1 || time !== times[0])) {\n        if \
(!smoothInterpolation) {\n          const offset = i * stride, offsetP = \
offset - stride, offsetN = offset + stride;\n          for (let j = 0; j !== \
stride; ++j) {\n            const value = values[offset + j];\n            if \
(value !== values[offsetP + j] || value !== values[offsetN + j]) {\n          \
    keep = true;\n              break;\n            }\n          }\n        } \
else {\n          keep = true;\n        }\n      }\n      if (keep) {\n       \
 if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n          \
const readOffset = i * stride, writeOffset = writeIndex * stride;\n          \
for (let j = 0; j !== stride; ++j) {\n            values[writeOffset + j] = \
values[readOffset + j];\n          }\n        }\n        ++writeIndex;\n      \
}\n    }\n    if (lastIndex > 0) {\n      times[writeIndex] = \
times[lastIndex];\n      for (let readOffset = lastIndex * stride, \
writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n        \
values[writeOffset + j] = values[readOffset + j];\n      }\n      \
++writeIndex;\n    }\n    if (writeIndex !== times.length) {\n      \
this.times = times.slice(0, writeIndex);\n      this.values = values.slice(0, \
writeIndex * stride);\n    } else {\n      this.times = times;\n      \
this.values = values;\n    }\n    return this;\n  }\n  clone() {\n    const \
times = this.times.slice();\n    const values = this.values.slice();\n    \
const TypedKeyframeTrack = this.constructor;\n    const track = new \
TypedKeyframeTrack(this.name, times, values);\n    track.createInterpolant = \
this.createInterpolant;\n    return track;\n  \
}\n};\nKeyframeTrack2.prototype.TimeBufferType = \
Float32Array;\nKeyframeTrack2.prototype.ValueBufferType = \
Float32Array;\nKeyframeTrack2.prototype.DefaultInterpolation = \
InterpolateLinear2;\nvar BooleanKeyframeTrack2 = class extends KeyframeTrack2 \
{\n  // No interpolation parameter because only InterpolateDiscrete is \
valid.\n  constructor(name, times, values) {\n    super(name, times, \
values);\n  }\n};\nBooleanKeyframeTrack2.prototype.ValueTypeName = \
\"bool\";\nBooleanKeyframeTrack2.prototype.ValueBufferType = \
Array;\nBooleanKeyframeTrack2.prototype.DefaultInterpolation = \
InterpolateDiscrete2;\nBooleanKeyframeTrack2.prototype.InterpolantFactoryMeth\
odLinear = void \
0;\nBooleanKeyframeTrack2.prototype.InterpolantFactoryMethodSmooth = void \
0;\nvar ColorKeyframeTrack2 = class extends KeyframeTrack2 \
{\n};\nColorKeyframeTrack2.prototype.ValueTypeName = \"color\";\nvar \
NumberKeyframeTrack2 = class extends KeyframeTrack2 \
{\n};\nNumberKeyframeTrack2.prototype.ValueTypeName = \"number\";\nvar \
QuaternionLinearInterpolant2 = class extends Interpolant2 {\n  \
constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n   \
 super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  \
interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer, values = \
this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);\n   \
 let offset = i1 * stride;\n    for (let end = offset + stride; offset !== \
end; offset += 4) {\n      Quaternion2.slerpFlat(result, 0, values, offset - \
stride, values, offset, alpha);\n    }\n    return result;\n  }\n};\nvar \
QuaternionKeyframeTrack2 = class extends KeyframeTrack2 {\n  \
InterpolantFactoryMethodLinear(result) {\n    return new \
QuaternionLinearInterpolant2(this.times, this.values, this.getValueSize(), \
result);\n  }\n};\nQuaternionKeyframeTrack2.prototype.ValueTypeName = \
\"quaternion\";\nQuaternionKeyframeTrack2.prototype.InterpolantFactoryMethodS\
mooth = void 0;\nvar StringKeyframeTrack2 = class extends KeyframeTrack2 {\n  \
// No interpolation parameter because only InterpolateDiscrete is valid.\n  \
constructor(name, times, values) {\n    super(name, times, values);\n  \
}\n};\nStringKeyframeTrack2.prototype.ValueTypeName = \
\"string\";\nStringKeyframeTrack2.prototype.ValueBufferType = \
Array;\nStringKeyframeTrack2.prototype.DefaultInterpolation = \
InterpolateDiscrete2;\nStringKeyframeTrack2.prototype.InterpolantFactoryMetho\
dLinear = void \
0;\nStringKeyframeTrack2.prototype.InterpolantFactoryMethodSmooth = void \
0;\nvar VectorKeyframeTrack2 = class extends KeyframeTrack2 \
{\n};\nVectorKeyframeTrack2.prototype.ValueTypeName = \"vector\";\nvar \
LoadingManager2 = class {\n  constructor(onLoad, onProgress, onError) {\n    \
const scope = this;\n    let isLoading = false;\n    let itemsLoaded = 0;\n   \
 let itemsTotal = 0;\n    let urlModifier = void 0;\n    const handlers = \
[];\n    this.onStart = void 0;\n    this.onLoad = onLoad;\n    \
this.onProgress = onProgress;\n    this.onError = onError;\n    \
this.itemStart = function(url) {\n      itemsTotal++;\n      if (isLoading \
=== false) {\n        if (scope.onStart !== void 0) {\n          \
scope.onStart(url, itemsLoaded, itemsTotal);\n        }\n      }\n      \
isLoading = true;\n    };\n    this.itemEnd = function(url) {\n      \
itemsLoaded++;\n      if (scope.onProgress !== void 0) {\n        \
scope.onProgress(url, itemsLoaded, itemsTotal);\n      }\n      if \
(itemsLoaded === itemsTotal) {\n        isLoading = false;\n        if \
(scope.onLoad !== void 0) {\n          scope.onLoad();\n        }\n      }\n  \
  };\n    this.itemError = function(url) {\n      if (scope.onError !== void \
0) {\n        scope.onError(url);\n      }\n    };\n    this.resolveURL = \
function(url) {\n      if (urlModifier) {\n        return urlModifier(url);\n \
     }\n      return url;\n    };\n    this.setURLModifier = \
function(transform) {\n      urlModifier = transform;\n      return this;\n   \
 };\n    this.addHandler = function(regex, loader) {\n      \
handlers.push(regex, loader);\n      return this;\n    };\n    \
this.removeHandler = function(regex) {\n      const index5 = \
handlers.indexOf(regex);\n      if (index5 !== -1) {\n        \
handlers.splice(index5, 2);\n      }\n      return this;\n    };\n    \
this.getHandler = function(file) {\n      for (let i = 0, l = \
handlers.length; i < l; i += 2) {\n        const regex = handlers[i];\n       \
 const loader = handlers[i + 1];\n        if (regex.global) regex.lastIndex = \
0;\n        if (regex.test(file)) {\n          return loader;\n        }\n    \
  }\n      return null;\n    };\n  }\n};\nvar DefaultLoadingManager2 = /* \
@__PURE__ */ new LoadingManager2();\nvar Loader2 = class {\n  \
constructor(manager) {\n    this.manager = manager !== void 0 ? manager : \
DefaultLoadingManager2;\n    this.crossOrigin = \"anonymous\";\n    \
this.withCredentials = false;\n    this.path = \"\";\n    this.resourcePath = \
\"\";\n    this.requestHeader = {};\n  }\n  load() {\n  }\n  loadAsync(url, \
onProgress) {\n    const scope = this;\n    return new \
Promise(function(resolve, reject) {\n      scope.load(url, resolve, \
onProgress, reject);\n    });\n  }\n  parse() {\n  }\n  \
setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    \
return this;\n  }\n  setWithCredentials(value) {\n    this.withCredentials = \
value;\n    return this;\n  }\n  setPath(path) {\n    this.path = path;\n    \
return this;\n  }\n  setResourcePath(resourcePath) {\n    this.resourcePath = \
resourcePath;\n    return this;\n  }\n  setRequestHeader(requestHeader) {\n   \
 this.requestHeader = requestHeader;\n    return this;\n  \
}\n};\nLoader2.DEFAULT_MATERIAL_NAME = \"__DEFAULT\";\nvar Light2 = class \
extends Object3D2 {\n  constructor(color2, intensity = 1) {\n    super();\n   \
 this.isLight = true;\n    this.type = \"Light\";\n    this.color = new \
Color2(color2);\n    this.intensity = intensity;\n  }\n  dispose() {\n  }\n  \
copy(source, recursive) {\n    super.copy(source, recursive);\n    \
this.color.copy(source.color);\n    this.intensity = source.intensity;\n    \
return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n   \
 data.object.color = this.color.getHex();\n    data.object.intensity = \
this.intensity;\n    if (this.groundColor !== void 0) data.object.groundColor \
= this.groundColor.getHex();\n    if (this.distance !== void 0) \
data.object.distance = this.distance;\n    if (this.angle !== void 0) \
data.object.angle = this.angle;\n    if (this.decay !== void 0) \
data.object.decay = this.decay;\n    if (this.penumbra !== void 0) \
data.object.penumbra = this.penumbra;\n    if (this.shadow !== void 0) \
data.object.shadow = this.shadow.toJSON();\n    if (this.target !== void 0) \
data.object.target = this.target.uuid;\n    return data;\n  }\n};\nvar \
HemisphereLight = class extends Light2 {\n  constructor(skyColor, \
groundColor, intensity) {\n    super(skyColor, intensity);\n    \
this.isHemisphereLight = true;\n    this.type = \"HemisphereLight\";\n    \
this.position.copy(Object3D2.DEFAULT_UP);\n    this.updateMatrix();\n    \
this.groundColor = new Color2(groundColor);\n  }\n  copy(source, recursive) \
{\n    super.copy(source, recursive);\n    \
this.groundColor.copy(source.groundColor);\n    return this;\n  }\n};\nvar \
_projScreenMatrix$2 = /* @__PURE__ */ new Matrix42();\nvar \
_lightPositionWorld$12 = /* @__PURE__ */ new Vector32();\nvar _lookTarget$12 \
= /* @__PURE__ */ new Vector32();\nvar LightShadow2 = class {\n  \
constructor(camera3) {\n    this.camera = camera3;\n    this.intensity = 1;\n \
   this.bias = 0;\n    this.normalBias = 0;\n    this.radius = 1;\n    \
this.blurSamples = 8;\n    this.mapSize = new Vector22(512, 512);\n    \
this.map = null;\n    this.mapPass = null;\n    this.matrix = new \
Matrix42();\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n    \
this._frustum = new Frustum2();\n    this._frameExtents = new Vector22(1, \
1);\n    this._viewportCount = 1;\n    this._viewports = [\n      new \
Vector42(0, 0, 1, 1)\n    ];\n  }\n  getViewportCount() {\n    return \
this._viewportCount;\n  }\n  getFrustum() {\n    return this._frustum;\n  }\n \
 updateMatrices(light) {\n    const shadowCamera = this.camera;\n    const \
shadowMatrix = this.matrix;\n    \
_lightPositionWorld$12.setFromMatrixPosition(light.matrixWorld);\n    \
shadowCamera.position.copy(_lightPositionWorld$12);\n    \
_lookTarget$12.setFromMatrixPosition(light.target.matrixWorld);\n    \
shadowCamera.lookAt(_lookTarget$12);\n    shadowCamera.updateMatrixWorld();\n \
   _projScreenMatrix$2.multiplyMatrices(shadowCamera.projectionMatrix, \
shadowCamera.matrixWorldInverse);\n    \
this._frustum.setFromProjectionMatrix(_projScreenMatrix$2);\n    \
shadowMatrix.set(\n      0.5,\n      0,\n      0,\n      0.5,\n      0,\n     \
 0.5,\n      0,\n      0.5,\n      0,\n      0,\n      0.5,\n      0.5,\n     \
 0,\n      0,\n      0,\n      1\n    );\n    \
shadowMatrix.multiply(_projScreenMatrix$2);\n  }\n  \
getViewport(viewportIndex) {\n    return this._viewports[viewportIndex];\n  \
}\n  getFrameExtents() {\n    return this._frameExtents;\n  }\n  dispose() \
{\n    if (this.map) {\n      this.map.dispose();\n    }\n    if \
(this.mapPass) {\n      this.mapPass.dispose();\n    }\n  }\n  copy(source) \
{\n    this.camera = source.camera.clone();\n    this.intensity = \
source.intensity;\n    this.bias = source.bias;\n    this.radius = \
source.radius;\n    this.mapSize.copy(source.mapSize);\n    return this;\n  \
}\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  \
toJSON() {\n    const object = {};\n    if (this.intensity !== 1) \
object.intensity = this.intensity;\n    if (this.bias !== 0) object.bias = \
this.bias;\n    if (this.normalBias !== 0) object.normalBias = \
this.normalBias;\n    if (this.radius !== 1) object.radius = this.radius;\n   \
 if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = \
this.mapSize.toArray();\n    object.camera = \
this.camera.toJSON(false).object;\n    delete object.camera.matrix;\n    \
return object;\n  }\n};\nvar SpotLightShadow = class extends LightShadow2 {\n \
 constructor() {\n    super(new PerspectiveCamera2(50, 1, 0.5, 500));\n    \
this.isSpotLightShadow = true;\n    this.focus = 1;\n  }\n  \
updateMatrices(light) {\n    const camera3 = this.camera;\n    const fov3 = \
RAD2DEG2 * 2 * light.angle * this.focus;\n    const aspect3 = \
this.mapSize.width / this.mapSize.height;\n    const far = light.distance || \
camera3.far;\n    if (fov3 !== camera3.fov || aspect3 !== camera3.aspect || \
far !== camera3.far) {\n      camera3.fov = fov3;\n      camera3.aspect = \
aspect3;\n      camera3.far = far;\n      camera3.updateProjectionMatrix();\n \
   }\n    super.updateMatrices(light);\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.focus = source.focus;\n    return this;\n  \
}\n};\nvar SpotLight = class extends Light2 {\n  constructor(color2, \
intensity, distance2 = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {\n   \
 super(color2, intensity);\n    this.isSpotLight = true;\n    this.type = \
\"SpotLight\";\n    this.position.copy(Object3D2.DEFAULT_UP);\n    \
this.updateMatrix();\n    this.target = new Object3D2();\n    this.distance = \
distance2;\n    this.angle = angle;\n    this.penumbra = penumbra;\n    \
this.decay = decay;\n    this.map = null;\n    this.shadow = new \
SpotLightShadow();\n  }\n  get power() {\n    return this.intensity * \
Math.PI;\n  }\n  set power(power) {\n    this.intensity = power / Math.PI;\n  \
}\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source, recursive) \
{\n    super.copy(source, recursive);\n    this.distance = source.distance;\n \
   this.angle = source.angle;\n    this.penumbra = source.penumbra;\n    \
this.decay = source.decay;\n    this.target = source.target.clone();\n    \
this.shadow = source.shadow.clone();\n    return this;\n  }\n};\nvar \
_projScreenMatrix$12 = /* @__PURE__ */ new Matrix42();\nvar \
_lightPositionWorld = /* @__PURE__ */ new Vector32();\nvar _lookTarget = /* \
@__PURE__ */ new Vector32();\nvar PointLightShadow = class extends \
LightShadow2 {\n  constructor() {\n    super(new PerspectiveCamera2(90, 1, \
0.5, 500));\n    this.isPointLightShadow = true;\n    this._frameExtents = \
new Vector22(4, 2);\n    this._viewportCount = 6;\n    this._viewports = [\n  \
    // These viewports map a cube-map onto a 2D texture with the\n      // \
following orientation:\n      //\n      //  xzXZ\n      //   y Y\n      //\n  \
    // X - Positive x direction\n      // x - Negative x direction\n      // \
Y - Positive y direction\n      // y - Negative y direction\n      // Z - \
Positive z direction\n      // z - Negative z direction\n      // positive \
X\n      new Vector42(2, 1, 1, 1),\n      // negative X\n      new \
Vector42(0, 1, 1, 1),\n      // positive Z\n      new Vector42(3, 1, 1, 1),\n \
     // negative Z\n      new Vector42(1, 1, 1, 1),\n      // positive Y\n    \
  new Vector42(3, 0, 1, 1),\n      // negative Y\n      new Vector42(1, 0, 1, \
1)\n    ];\n    this._cubeDirections = [\n      new Vector32(1, 0, 0),\n      \
new Vector32(-1, 0, 0),\n      new Vector32(0, 0, 1),\n      new Vector32(0, \
0, -1),\n      new Vector32(0, 1, 0),\n      new Vector32(0, -1, 0)\n    ];\n \
   this._cubeUps = [\n      new Vector32(0, 1, 0),\n      new Vector32(0, 1, \
0),\n      new Vector32(0, 1, 0),\n      new Vector32(0, 1, 0),\n      new \
Vector32(0, 0, 1),\n      new Vector32(0, 0, -1)\n    ];\n  }\n  \
updateMatrices(light, viewportIndex = 0) {\n    const camera3 = \
this.camera;\n    const shadowMatrix = this.matrix;\n    const far = \
light.distance || camera3.far;\n    if (far !== camera3.far) {\n      \
camera3.far = far;\n      camera3.updateProjectionMatrix();\n    }\n    \
_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n    \
camera3.position.copy(_lightPositionWorld);\n    \
_lookTarget.copy(camera3.position);\n    \
_lookTarget.add(this._cubeDirections[viewportIndex]);\n    \
camera3.up.copy(this._cubeUps[viewportIndex]);\n    \
camera3.lookAt(_lookTarget);\n    camera3.updateMatrixWorld();\n    \
shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, \
-_lightPositionWorld.z);\n    \
_projScreenMatrix$12.multiplyMatrices(camera3.projectionMatrix, \
camera3.matrixWorldInverse);\n    \
this._frustum.setFromProjectionMatrix(_projScreenMatrix$12);\n  }\n};\nvar \
PointLight = class extends Light2 {\n  constructor(color2, intensity, \
distance2 = 0, decay = 2) {\n    super(color2, intensity);\n    \
this.isPointLight = true;\n    this.type = \"PointLight\";\n    this.distance \
= distance2;\n    this.decay = decay;\n    this.shadow = new \
PointLightShadow();\n  }\n  get power() {\n    return this.intensity * 4 * \
Math.PI;\n  }\n  set power(power) {\n    this.intensity = power / (4 * \
Math.PI);\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  \
copy(source, recursive) {\n    super.copy(source, recursive);\n    \
this.distance = source.distance;\n    this.decay = source.decay;\n    \
this.shadow = source.shadow.clone();\n    return this;\n  }\n};\nvar \
OrthographicCamera2 = class extends Camera2 {\n  constructor(left = -1, right \
= 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {\n    super();\n    \
this.isOrthographicCamera = true;\n    this.type = \"OrthographicCamera\";\n  \
  this.zoom = 1;\n    this.view = null;\n    this.left = left;\n    \
this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n    \
this.near = near;\n    this.far = far;\n    this.updateProjectionMatrix();\n  \
}\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    \
this.left = source.left;\n    this.right = source.right;\n    this.top = \
source.top;\n    this.bottom = source.bottom;\n    this.near = source.near;\n \
   this.far = source.far;\n    this.zoom = source.zoom;\n    this.view = \
source.view === null ? null : Object.assign({}, source.view);\n    return \
this;\n  }\n  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {\n \
   if (this.view === null) {\n      this.view = {\n        enabled: true,\n   \
     fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        \
offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n    \
this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    \
this.view.fullHeight = fullHeight;\n    this.view.offsetX = x2;\n    \
this.view.offsetY = y2;\n    this.view.width = width;\n    this.view.height = \
height;\n    this.updateProjectionMatrix();\n  }\n  clearViewOffset() {\n    \
if (this.view !== null) {\n      this.view.enabled = false;\n    }\n    \
this.updateProjectionMatrix();\n  }\n  updateProjectionMatrix() {\n    const \
dx = (this.right - this.left) / (2 * this.zoom);\n    const dy = (this.top - \
this.bottom) / (2 * this.zoom);\n    const cx = (this.right + this.left) / \
2;\n    const cy = (this.top + this.bottom) / 2;\n    let left = cx - dx;\n   \
 let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n    \
if (this.view !== null && this.view.enabled) {\n      const scaleW = \
(this.right - this.left) / this.view.fullWidth / this.zoom;\n      const \
scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n      \
left += scaleW * this.view.offsetX;\n      right = left + scaleW * \
this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = \
top - scaleH * this.view.height;\n    }\n    \
this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, \
this.far, this.coordinateSystem);\n    \
this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  \
toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.zoom = \
this.zoom;\n    data.object.left = this.left;\n    data.object.right = \
this.right;\n    data.object.top = this.top;\n    data.object.bottom = \
this.bottom;\n    data.object.near = this.near;\n    data.object.far = \
this.far;\n    if (this.view !== null) data.object.view = Object.assign({}, \
this.view);\n    return data;\n  }\n};\nvar DirectionalLightShadow2 = class \
extends LightShadow2 {\n  constructor() {\n    super(new \
OrthographicCamera2(-5, 5, 5, -5, 0.5, 500));\n    \
this.isDirectionalLightShadow = true;\n  }\n};\nvar DirectionalLight2 = class \
extends Light2 {\n  constructor(color2, intensity) {\n    super(color2, \
intensity);\n    this.isDirectionalLight = true;\n    this.type = \
\"DirectionalLight\";\n    this.position.copy(Object3D2.DEFAULT_UP);\n    \
this.updateMatrix();\n    this.target = new Object3D2();\n    this.shadow = \
new DirectionalLightShadow2();\n  }\n  dispose() {\n    \
this.shadow.dispose();\n  }\n  copy(source) {\n    super.copy(source);\n    \
this.target = source.target.clone();\n    this.shadow = \
source.shadow.clone();\n    return this;\n  }\n};\nvar AmbientLight2 = class \
extends Light2 {\n  constructor(color2, intensity) {\n    super(color2, \
intensity);\n    this.isAmbientLight = true;\n    this.type = \
\"AmbientLight\";\n  }\n};\nvar RectAreaLight = class extends Light2 {\n  \
constructor(color2, intensity, width = 10, height = 10) {\n    super(color2, \
intensity);\n    this.isRectAreaLight = true;\n    this.type = \
\"RectAreaLight\";\n    this.width = width;\n    this.height = height;\n  }\n \
 get power() {\n    return this.intensity * this.width * this.height * \
Math.PI;\n  }\n  set power(power) {\n    this.intensity = power / (this.width \
* this.height * Math.PI);\n  }\n  copy(source) {\n    super.copy(source);\n   \
 this.width = source.width;\n    this.height = source.height;\n    return \
this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    \
data.object.width = this.width;\n    data.object.height = this.height;\n    \
return data;\n  }\n};\nvar SphericalHarmonics3 = class {\n  constructor() {\n \
   this.isSphericalHarmonics3 = true;\n    this.coefficients = [];\n    for \
(let i = 0; i < 9; i++) {\n      this.coefficients.push(new Vector32());\n    \
}\n  }\n  set(coefficients) {\n    for (let i = 0; i < 9; i++) {\n      \
this.coefficients[i].copy(coefficients[i]);\n    }\n    return this;\n  }\n  \
zero() {\n    for (let i = 0; i < 9; i++) {\n      \
this.coefficients[i].set(0, 0, 0);\n    }\n    return this;\n  }\n  // get \
the radiance in the direction of the normal\n  // target is a Vector3\n  \
getAt(normal2, target) {\n    const x2 = normal2.x, y2 = normal2.y, z2 = \
normal2.z;\n    const coeff = this.coefficients;\n    \
target.copy(coeff[0]).multiplyScalar(0.282095);\n    \
target.addScaledVector(coeff[1], 0.488603 * y2);\n    \
target.addScaledVector(coeff[2], 0.488603 * z2);\n    \
target.addScaledVector(coeff[3], 0.488603 * x2);\n    \
target.addScaledVector(coeff[4], 1.092548 * (x2 * y2));\n    \
target.addScaledVector(coeff[5], 1.092548 * (y2 * z2));\n    \
target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));\n    \
target.addScaledVector(coeff[7], 1.092548 * (x2 * z2));\n    \
target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y2 * y2));\n    return \
target;\n  }\n  // get the irradiance (radiance convolved with cosine lobe) \
in the direction of the normal\n  // target is a Vector3\n  // \
https://graphics.stanford.edu/papers/envmap/envmap.pdf\n  \
getIrradianceAt(normal2, target) {\n    const x2 = normal2.x, y2 = normal2.y, \
z2 = normal2.z;\n    const coeff = this.coefficients;\n    \
target.copy(coeff[0]).multiplyScalar(0.886227);\n    \
target.addScaledVector(coeff[1], 2 * 0.511664 * y2);\n    \
target.addScaledVector(coeff[2], 2 * 0.511664 * z2);\n    \
target.addScaledVector(coeff[3], 2 * 0.511664 * x2);\n    \
target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y2);\n    \
target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);\n    \
target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);\n    \
target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z2);\n    \
target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y2 * y2));\n    return \
target;\n  }\n  add(sh) {\n    for (let i = 0; i < 9; i++) {\n      \
this.coefficients[i].add(sh.coefficients[i]);\n    }\n    return this;\n  }\n \
 addScaledSH(sh, s) {\n    for (let i = 0; i < 9; i++) {\n      \
this.coefficients[i].addScaledVector(sh.coefficients[i], s);\n    }\n    \
return this;\n  }\n  scale(s) {\n    for (let i = 0; i < 9; i++) {\n      \
this.coefficients[i].multiplyScalar(s);\n    }\n    return this;\n  }\n  \
lerp(sh, alpha) {\n    for (let i = 0; i < 9; i++) {\n      \
this.coefficients[i].lerp(sh.coefficients[i], alpha);\n    }\n    return \
this;\n  }\n  equals(sh) {\n    for (let i = 0; i < 9; i++) {\n      if \
(!this.coefficients[i].equals(sh.coefficients[i])) {\n        return false;\n \
     }\n    }\n    return true;\n  }\n  copy(sh) {\n    return \
this.set(sh.coefficients);\n  }\n  clone() {\n    return new \
this.constructor().copy(this);\n  }\n  fromArray(array, offset = 0) {\n    \
const coefficients = this.coefficients;\n    for (let i = 0; i < 9; i++) {\n  \
    coefficients[i].fromArray(array, offset + i * 3);\n    }\n    return \
this;\n  }\n  toArray(array = [], offset = 0) {\n    const coefficients = \
this.coefficients;\n    for (let i = 0; i < 9; i++) {\n      \
coefficients[i].toArray(array, offset + i * 3);\n    }\n    return array;\n  \
}\n  // evaluate the basis functions\n  // shBasis is an Array[ 9 ]\n  static \
getBasisAt(normal2, shBasis) {\n    const x2 = normal2.x, y2 = normal2.y, z2 \
= normal2.z;\n    shBasis[0] = 0.282095;\n    shBasis[1] = 0.488603 * y2;\n   \
 shBasis[2] = 0.488603 * z2;\n    shBasis[3] = 0.488603 * x2;\n    shBasis[4] \
= 1.092548 * x2 * y2;\n    shBasis[5] = 1.092548 * y2 * z2;\n    shBasis[6] = \
0.315392 * (3 * z2 * z2 - 1);\n    shBasis[7] = 1.092548 * x2 * z2;\n    \
shBasis[8] = 0.546274 * (x2 * x2 - y2 * y2);\n  }\n};\nvar LightProbe = class \
extends Light2 {\n  constructor(sh = new SphericalHarmonics3(), intensity = \
1) {\n    super(void 0, intensity);\n    this.isLightProbe = true;\n    \
this.sh = sh;\n  }\n  copy(source) {\n    super.copy(source);\n    \
this.sh.copy(source.sh);\n    return this;\n  }\n  fromJSON(json) {\n    \
this.intensity = json.intensity;\n    this.sh.fromArray(json.sh);\n    return \
this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    \
data.object.sh = this.sh.toArray();\n    return data;\n  }\n};\nvar \
_RESERVED_CHARS_RE2 = \"\\\\[\\\\]\\\\.:\\\\/\";\nvar _reservedRe2 = new \
RegExp(\"[\" + _RESERVED_CHARS_RE2 + \"]\", \"g\");\nvar _wordChar2 = \"[^\" \
+ _RESERVED_CHARS_RE2 + \"]\";\nvar _wordCharOrDot2 = \"[^\" + \
_RESERVED_CHARS_RE2.replace(\"\\\\.\", \"\") + \"]\";\nvar _directoryRe2 = /* \
@__PURE__ */ /((?:WC+[\\/:])*)/.source.replace(\"WC\", _wordChar2);\nvar \
_nodeRe2 = /* @__PURE__ */ /(WCOD+)?/.source.replace(\"WCOD\", \
_wordCharOrDot2);\nvar _objectRe2 = /* @__PURE__ */ \
/(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace(\"WC\", _wordChar2);\nvar \
_propertyRe2 = /* @__PURE__ */ \
/\\.(WC+)(?:\\[(.+)\\])?/.source.replace(\"WC\", _wordChar2);\nvar _trackRe2 \
= new RegExp(\n  \"^\" + _directoryRe2 + _nodeRe2 + _objectRe2 + _propertyRe2 \
+ \"$\"\n);\nvar _supportedObjectNames2 = [\"material\", \"materials\", \
\"bones\", \"map\"];\nvar Composite2 = class {\n  constructor(targetGroup, \
path, optionalParsedPath) {\n    const parsedPath = optionalParsedPath || \
PropertyBinding2.parseTrackName(path);\n    this._targetGroup = \
targetGroup;\n    this._bindings = targetGroup.subscribe_(path, \
parsedPath);\n  }\n  getValue(array, offset) {\n    this.bind();\n    const \
firstValidIndex = this._targetGroup.nCachedObjects_, binding = \
this._bindings[firstValidIndex];\n    if (binding !== void 0) \
binding.getValue(array, offset);\n  }\n  setValue(array, offset) {\n    const \
bindings = this._bindings;\n    for (let i = \
this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n     \
 bindings[i].setValue(array, offset);\n    }\n  }\n  bind() {\n    const \
bindings = this._bindings;\n    for (let i = \
this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n     \
 bindings[i].bind();\n    }\n  }\n  unbind() {\n    const bindings = \
this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = \
bindings.length; i !== n; ++i) {\n      bindings[i].unbind();\n    }\n  \
}\n};\nvar PropertyBinding2 = class _PropertyBinding {\n  \
constructor(rootNode, path, parsedPath) {\n    this.path = path;\n    \
this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);\n    \
this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);\n  \
  this.rootNode = rootNode;\n    this.getValue = this._getValue_unbound;\n    \
this.setValue = this._setValue_unbound;\n  }\n  static create(root2, path, \
parsedPath) {\n    if (!(root2 && root2.isAnimationObjectGroup)) {\n      \
return new _PropertyBinding(root2, path, parsedPath);\n    } else {\n      \
return new _PropertyBinding.Composite(root2, path, parsedPath);\n    }\n  }\n \
 /**\n   * Replaces spaces with underscores and removes unsupported \
characters from\n   * node names, to ensure compatibility with \
parseTrackName().\n   *\n   * @param {string} name Node name to be \
sanitized.\n   * @return {string}\n   */\n  static sanitizeNodeName(name) {\n \
   return name.replace(/\\s/g, \"_\").replace(_reservedRe2, \"\");\n  }\n  \
static parseTrackName(trackName) {\n    const matches = \
_trackRe2.exec(trackName);\n    if (matches === null) {\n      throw new \
Error(\"PropertyBinding: Cannot parse trackName: \" + trackName);\n    }\n    \
const results = {\n      // directoryName: matches[ 1 ], // (tschw) currently \
unused\n      nodeName: matches[2],\n      objectName: matches[3],\n      \
objectIndex: matches[4],\n      propertyName: matches[5],\n      // \
required\n      propertyIndex: matches[6]\n    };\n    const lastDot = \
results.nodeName && results.nodeName.lastIndexOf(\".\");\n    if (lastDot !== \
void 0 && lastDot !== -1) {\n      const objectName = \
results.nodeName.substring(lastDot + 1);\n      if \
(_supportedObjectNames2.indexOf(objectName) !== -1) {\n        \
results.nodeName = results.nodeName.substring(0, lastDot);\n        \
results.objectName = objectName;\n      }\n    }\n    if \
(results.propertyName === null || results.propertyName.length === 0) {\n      \
throw new Error(\"PropertyBinding: can not parse propertyName from trackName: \
\" + trackName);\n    }\n    return results;\n  }\n  static findNode(root2, \
nodeName) {\n    if (nodeName === void 0 || nodeName === \"\" || nodeName === \
\".\" || nodeName === -1 || nodeName === root2.name || nodeName === \
root2.uuid) {\n      return root2;\n    }\n    if (root2.skeleton) {\n      \
const bone = root2.skeleton.getBoneByName(nodeName);\n      if (bone !== void \
0) {\n        return bone;\n      }\n    }\n    if (root2.children) {\n      \
const searchNodeSubtree = function(children) {\n        for (let i = 0; i < \
children.length; i++) {\n          const childNode = children[i];\n          \
if (childNode.name === nodeName || childNode.uuid === nodeName) {\n           \
 return childNode;\n          }\n          const result = \
searchNodeSubtree(childNode.children);\n          if (result) return \
result;\n        }\n        return null;\n      };\n      const subTreeNode = \
searchNodeSubtree(root2.children);\n      if (subTreeNode) {\n        return \
subTreeNode;\n      }\n    }\n    return null;\n  }\n  // these are used to \
\"bind\" a nonexistent property\n  _getValue_unavailable() {\n  }\n  \
_setValue_unavailable() {\n  }\n  // Getters\n  _getValue_direct(buffer2, \
offset) {\n    buffer2[offset] = this.targetObject[this.propertyName];\n  }\n \
 _getValue_array(buffer2, offset) {\n    const source = \
this.resolvedProperty;\n    for (let i = 0, n = source.length; i !== n; ++i) \
{\n      buffer2[offset++] = source[i];\n    }\n  }\n  \
_getValue_arrayElement(buffer2, offset) {\n    buffer2[offset] = \
this.resolvedProperty[this.propertyIndex];\n  }\n  _getValue_toArray(buffer2, \
offset) {\n    this.resolvedProperty.toArray(buffer2, offset);\n  }\n  // \
Direct\n  _setValue_direct(buffer2, offset) {\n    \
this.targetObject[this.propertyName] = buffer2[offset];\n  }\n  \
_setValue_direct_setNeedsUpdate(buffer2, offset) {\n    \
this.targetObject[this.propertyName] = buffer2[offset];\n    \
this.targetObject.needsUpdate = true;\n  }\n  \
_setValue_direct_setMatrixWorldNeedsUpdate(buffer2, offset) {\n    \
this.targetObject[this.propertyName] = buffer2[offset];\n    \
this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  // EntireArray\n  \
_setValue_array(buffer2, offset) {\n    const dest = this.resolvedProperty;\n \
   for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = \
buffer2[offset++];\n    }\n  }\n  _setValue_array_setNeedsUpdate(buffer2, \
offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = \
dest.length; i !== n; ++i) {\n      dest[i] = buffer2[offset++];\n    }\n    \
this.targetObject.needsUpdate = true;\n  }\n  \
_setValue_array_setMatrixWorldNeedsUpdate(buffer2, offset) {\n    const dest \
= this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) \
{\n      dest[i] = buffer2[offset++];\n    }\n    \
this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  // ArrayElement\n  \
_setValue_arrayElement(buffer2, offset) {\n    \
this.resolvedProperty[this.propertyIndex] = buffer2[offset];\n  }\n  \
_setValue_arrayElement_setNeedsUpdate(buffer2, offset) {\n    \
this.resolvedProperty[this.propertyIndex] = buffer2[offset];\n    \
this.targetObject.needsUpdate = true;\n  }\n  \
_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer2, offset) {\n    \
this.resolvedProperty[this.propertyIndex] = buffer2[offset];\n    \
this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  // HasToFromArray\n  \
_setValue_fromArray(buffer2, offset) {\n    \
this.resolvedProperty.fromArray(buffer2, offset);\n  }\n  \
_setValue_fromArray_setNeedsUpdate(buffer2, offset) {\n    \
this.resolvedProperty.fromArray(buffer2, offset);\n    \
this.targetObject.needsUpdate = true;\n  }\n  \
_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer2, offset) {\n    \
this.resolvedProperty.fromArray(buffer2, offset);\n    \
this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  \
_getValue_unbound(targetArray, offset) {\n    this.bind();\n    \
this.getValue(targetArray, offset);\n  }\n  _setValue_unbound(sourceArray, \
offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  }\n  \
// create getter / setter pair for a property in the scene graph\n  bind() \
{\n    let targetObject = this.node;\n    const parsedPath = \
this.parsedPath;\n    const objectName = parsedPath.objectName;\n    const \
propertyName = parsedPath.propertyName;\n    let propertyIndex = \
parsedPath.propertyIndex;\n    if (!targetObject) {\n      targetObject = \
_PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);\n      \
this.node = targetObject;\n    }\n    this.getValue = \
this._getValue_unavailable;\n    this.setValue = \
this._setValue_unavailable;\n    if (!targetObject) {\n      \
console.warn(\"THREE.PropertyBinding: No target node found for track: \" + \
this.path + \".\");\n      return;\n    }\n    if (objectName) {\n      let \
objectIndex = parsedPath.objectIndex;\n      switch (objectName) {\n        \
case \"materials\":\n          if (!targetObject.material) {\n            \
console.error(\"THREE.PropertyBinding: Can not bind to material as node does \
not have a material.\", this);\n            return;\n          }\n          \
if (!targetObject.material.materials) {\n            \
console.error(\"THREE.PropertyBinding: Can not bind to material.materials as \
node.material does not have a materials array.\", this);\n            \
return;\n          }\n          targetObject = \
targetObject.material.materials;\n          break;\n        case \"bones\":\n \
         if (!targetObject.skeleton) {\n            \
console.error(\"THREE.PropertyBinding: Can not bind to bones as node does not \
have a skeleton.\", this);\n            return;\n          }\n          \
targetObject = targetObject.skeleton.bones;\n          for (let i = 0; i < \
targetObject.length; i++) {\n            if (targetObject[i].name === \
objectIndex) {\n              objectIndex = i;\n              break;\n        \
    }\n          }\n          break;\n        case \"map\":\n          if \
(\"map\" in targetObject) {\n            targetObject = targetObject.map;\n   \
         break;\n          }\n          if (!targetObject.material) {\n       \
     console.error(\"THREE.PropertyBinding: Can not bind to material as node \
does not have a material.\", this);\n            return;\n          }\n       \
   if (!targetObject.material.map) {\n            \
console.error(\"THREE.PropertyBinding: Can not bind to material.map as \
node.material does not have a map.\", this);\n            return;\n          \
}\n          targetObject = targetObject.material.map;\n          break;\n    \
    default:\n          if (targetObject[objectName] === void 0) {\n          \
  console.error(\"THREE.PropertyBinding: Can not bind to objectName of node \
undefined.\", this);\n            return;\n          }\n          \
targetObject = targetObject[objectName];\n      }\n      if (objectIndex !== \
void 0) {\n        if (targetObject[objectIndex] === void 0) {\n          \
console.error(\"THREE.PropertyBinding: Trying to bind to objectIndex of \
objectName, but is undefined.\", this, targetObject);\n          return;\n    \
    }\n        targetObject = targetObject[objectIndex];\n      }\n    }\n    \
const nodeProperty = targetObject[propertyName];\n    if (nodeProperty === \
void 0) {\n      const nodeName = parsedPath.nodeName;\n      \
console.error(\"THREE.PropertyBinding: Trying to update property for track: \
\" + nodeName + \".\" + propertyName + \" but it wasn't found.\", \
targetObject);\n      return;\n    }\n    let versioning = \
this.Versioning.None;\n    this.targetObject = targetObject;\n    if \
(targetObject.needsUpdate !== void 0) {\n      versioning = \
this.Versioning.NeedsUpdate;\n    } else if \
(targetObject.matrixWorldNeedsUpdate !== void 0) {\n      versioning = \
this.Versioning.MatrixWorldNeedsUpdate;\n    }\n    let bindingType = \
this.BindingType.Direct;\n    if (propertyIndex !== void 0) {\n      if \
(propertyName === \"morphTargetInfluences\") {\n        if \
(!targetObject.geometry) {\n          console.error(\"THREE.PropertyBinding: \
Can not bind to morphTargetInfluences because node does not have a \
geometry.\", this);\n          return;\n        }\n        if \
(!targetObject.geometry.morphAttributes) {\n          \
console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences \
because node does not have a geometry.morphAttributes.\", this);\n          \
return;\n        }\n        if \
(targetObject.morphTargetDictionary[propertyIndex] !== void 0) {\n          \
propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n        \
}\n      }\n      bindingType = this.BindingType.ArrayElement;\n      \
this.resolvedProperty = nodeProperty;\n      this.propertyIndex = \
propertyIndex;\n    } else if (nodeProperty.fromArray !== void 0 && \
nodeProperty.toArray !== void 0) {\n      bindingType = \
this.BindingType.HasFromToArray;\n      this.resolvedProperty = \
nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      \
bindingType = this.BindingType.EntireArray;\n      this.resolvedProperty = \
nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    }\n \
   this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue \
= this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  }\n  \
unbind() {\n    this.node = null;\n    this.getValue = \
this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  \
}\n};\nPropertyBinding2.Composite = \
Composite2;\nPropertyBinding2.prototype.BindingType = {\n  Direct: 0,\n  \
EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: \
3\n};\nPropertyBinding2.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: \
1,\n  MatrixWorldNeedsUpdate: \
2\n};\nPropertyBinding2.prototype.GetterByBindingType = [\n  \
PropertyBinding2.prototype._getValue_direct,\n  \
PropertyBinding2.prototype._getValue_array,\n  \
PropertyBinding2.prototype._getValue_arrayElement,\n  \
PropertyBinding2.prototype._getValue_toArray\n];\nPropertyBinding2.prototype.\
SetterByBindingTypeAndVersioning = [\n  [\n    // Direct\n    \
PropertyBinding2.prototype._setValue_direct,\n    \
PropertyBinding2.prototype._setValue_direct_setNeedsUpdate,\n    \
PropertyBinding2.prototype._setValue_direct_setMatrixWorldNeedsUpdate\n  ],\n \
 [\n    // EntireArray\n    PropertyBinding2.prototype._setValue_array,\n    \
PropertyBinding2.prototype._setValue_array_setNeedsUpdate,\n    \
PropertyBinding2.prototype._setValue_array_setMatrixWorldNeedsUpdate\n  ],\n  \
[\n    // ArrayElement\n    \
PropertyBinding2.prototype._setValue_arrayElement,\n    \
PropertyBinding2.prototype._setValue_arrayElement_setNeedsUpdate,\n    \
PropertyBinding2.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate\n \
 ],\n  [\n    // HasToFromArray\n    \
PropertyBinding2.prototype._setValue_fromArray,\n    \
PropertyBinding2.prototype._setValue_fromArray_setNeedsUpdate,\n    \
PropertyBinding2.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate\n  \
]\n];\nvar _controlInterpolantsResultBuffer2 = new Float32Array(1);\nvar \
InstancedInterleavedBuffer = class extends InterleavedBuffer {\n  \
constructor(array, stride, meshPerAttribute = 1) {\n    super(array, \
stride);\n    this.isInstancedInterleavedBuffer = true;\n    \
this.meshPerAttribute = meshPerAttribute;\n  }\n  copy(source) {\n    \
super.copy(source);\n    this.meshPerAttribute = source.meshPerAttribute;\n   \
 return this;\n  }\n  clone(data) {\n    const ib = super.clone(data);\n    \
ib.meshPerAttribute = this.meshPerAttribute;\n    return ib;\n  }\n  \
toJSON(data) {\n    const json = super.toJSON(data);\n    \
json.isInstancedInterleavedBuffer = true;\n    json.meshPerAttribute = \
this.meshPerAttribute;\n    return json;\n  }\n};\nvar refreshUniforms = [\n  \
\"alphaMap\",\n  \"alphaTest\",\n  \"anisotropy\",\n  \"anisotropyMap\",\n  \
\"anisotropyRotation\",\n  \"aoMap\",\n  \"attenuationColor\",\n  \
\"attenuationDistance\",\n  \"bumpMap\",\n  \"clearcoat\",\n  \
\"clearcoatMap\",\n  \"clearcoatNormalMap\",\n  \"clearcoatNormalScale\",\n  \
\"clearcoatRoughness\",\n  \"color\",\n  \"dispersion\",\n  \
\"displacementMap\",\n  \"emissive\",\n  \"emissiveMap\",\n  \"envMap\",\n  \
\"gradientMap\",\n  \"ior\",\n  \"iridescence\",\n  \"iridescenceIOR\",\n  \
\"iridescenceMap\",\n  \"iridescenceThicknessMap\",\n  \"lightMap\",\n  \
\"map\",\n  \"matcap\",\n  \"metalness\",\n  \"metalnessMap\",\n  \
\"normalMap\",\n  \"normalScale\",\n  \"opacity\",\n  \"roughness\",\n  \
\"roughnessMap\",\n  \"sheen\",\n  \"sheenColor\",\n  \"sheenColorMap\",\n  \
\"sheenRoughnessMap\",\n  \"shininess\",\n  \"specular\",\n  \
\"specularColor\",\n  \"specularColorMap\",\n  \"specularIntensity\",\n  \
\"specularIntensityMap\",\n  \"specularMap\",\n  \"thickness\",\n  \
\"transmission\",\n  \"transmissionMap\"\n];\nvar NodeMaterialObserver = \
class {\n  constructor(builder) {\n    this.renderObjects = /* @__PURE__ */ \
new WeakMap();\n    this.hasNode = this.containsNode(builder);\n    \
this.hasAnimation = builder.object.isSkinnedMesh === true;\n    \
this.refreshUniforms = refreshUniforms;\n    this.renderId = 0;\n  }\n  \
firstInitialization(renderObject) {\n    const hasInitialized = \
this.renderObjects.has(renderObject);\n    if (hasInitialized === false) {\n  \
    this.getRenderObjectData(renderObject);\n      return true;\n    }\n    \
return false;\n  }\n  getRenderObjectData(renderObject) {\n    let data = \
this.renderObjects.get(renderObject);\n    if (data === void 0) {\n      \
const { geometry, material } = renderObject;\n      data = {\n        \
material: this.getMaterialData(material),\n        geometry: {\n          \
attributes: this.getAttributesData(geometry.attributes),\n          \
indexVersion: geometry.index ? geometry.index.version : null,\n          \
drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count \
}\n        },\n        worldMatrix: renderObject.object.matrixWorld.clone()\n \
     };\n      if (renderObject.object.center) {\n        data.center = \
renderObject.object.center.clone();\n      }\n      if \
(renderObject.object.morphTargetInfluences) {\n        \
data.morphTargetInfluences = \
renderObject.object.morphTargetInfluences.slice();\n      }\n      if \
(renderObject.bundle !== null) {\n        data.version = \
renderObject.bundle.version;\n      }\n      if (data.material.transmission > \
0) {\n        const { width, height } = renderObject.context;\n        \
data.bufferWidth = width;\n        data.bufferHeight = height;\n      }\n     \
 this.renderObjects.set(renderObject, data);\n    }\n    return data;\n  }\n  \
getAttributesData(attributes) {\n    const attributesData = {};\n    for \
(const name in attributes) {\n      const attribute2 = attributes[name];\n    \
  attributesData[name] = {\n        version: attribute2.version\n      };\n   \
 }\n    return attributesData;\n  }\n  containsNode(builder) {\n    const \
material = builder.material;\n    for (const property2 in material) {\n      \
if (material[property2] && material[property2].isNode)\n        return \
true;\n    }\n    if (builder.renderer.nodes.modelViewMatrix !== null || \
builder.renderer.nodes.modelNormalViewMatrix !== null)\n      return true;\n  \
  return false;\n  }\n  getMaterialData(material) {\n    const data = {};\n   \
 for (const property2 of this.refreshUniforms) {\n      const value = \
material[property2];\n      if (value === null || value === void 0) \
continue;\n      if (typeof value === \"object\" && value.clone !== void 0) \
{\n        if (value.isTexture === true) {\n          data[property2] = { id: \
value.id, version: value.version };\n        } else {\n          \
data[property2] = value.clone();\n        }\n      } else {\n        \
data[property2] = value;\n      }\n    }\n    return data;\n  }\n  \
equals(renderObject) {\n    const { object, material, geometry } = \
renderObject;\n    const renderObjectData = \
this.getRenderObjectData(renderObject);\n    if \
(renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {\n      \
renderObjectData.worldMatrix.copy(object.matrixWorld);\n      return false;\n \
   }\n    const materialData = renderObjectData.material;\n    for (const \
property2 in materialData) {\n      const value = materialData[property2];\n  \
    const mtlValue = material[property2];\n      if (value.equals !== void 0) \
{\n        if (value.equals(mtlValue) === false) {\n          \
value.copy(mtlValue);\n          return false;\n        }\n      } else if \
(mtlValue.isTexture === true) {\n        if (value.id !== mtlValue.id || \
value.version !== mtlValue.version) {\n          value.id = mtlValue.id;\n    \
      value.version = mtlValue.version;\n          return false;\n        }\n \
     } else if (value !== mtlValue) {\n        materialData[property2] = \
mtlValue;\n        return false;\n      }\n    }\n    if \
(materialData.transmission > 0) {\n      const { width, height } = \
renderObject.context;\n      if (renderObjectData.bufferWidth !== width || \
renderObjectData.bufferHeight !== height) {\n        \
renderObjectData.bufferWidth = width;\n        renderObjectData.bufferHeight \
= height;\n        return false;\n      }\n    }\n    const \
storedGeometryData = renderObjectData.geometry;\n    const attributes = \
geometry.attributes;\n    const storedAttributes = \
storedGeometryData.attributes;\n    const storedAttributeNames = \
Object.keys(storedAttributes);\n    const currentAttributeNames = \
Object.keys(attributes);\n    if (storedAttributeNames.length !== \
currentAttributeNames.length) {\n      renderObjectData.geometry.attributes = \
this.getAttributesData(attributes);\n      return false;\n    }\n    for \
(const name of storedAttributeNames) {\n      const storedAttributeData = \
storedAttributes[name];\n      const attribute2 = attributes[name];\n      if \
(attribute2 === void 0) {\n        delete storedAttributes[name];\n        \
return false;\n      }\n      if (storedAttributeData.version !== \
attribute2.version) {\n        storedAttributeData.version = \
attribute2.version;\n        return false;\n      }\n    }\n    const index5 \
= geometry.index;\n    const storedIndexVersion = \
storedGeometryData.indexVersion;\n    const currentIndexVersion = index5 ? \
index5.version : null;\n    if (storedIndexVersion !== currentIndexVersion) \
{\n      storedGeometryData.indexVersion = currentIndexVersion;\n      return \
false;\n    }\n    if (storedGeometryData.drawRange.start !== \
geometry.drawRange.start || storedGeometryData.drawRange.count !== \
geometry.drawRange.count) {\n      storedGeometryData.drawRange.start = \
geometry.drawRange.start;\n      storedGeometryData.drawRange.count = \
geometry.drawRange.count;\n      return false;\n    }\n    if \
(renderObjectData.morphTargetInfluences) {\n      let morphChanged = false;\n \
     for (let i = 0; i < renderObjectData.morphTargetInfluences.length; i++) \
{\n        if (renderObjectData.morphTargetInfluences[i] !== \
object.morphTargetInfluences[i]) {\n          morphChanged = true;\n        \
}\n      }\n      if (morphChanged) return true;\n    }\n    if \
(renderObjectData.center) {\n      if \
(renderObjectData.center.equals(object.center) === false) {\n        \
renderObjectData.center.copy(object.center);\n        return true;\n      }\n \
   }\n    if (renderObject.bundle !== null) {\n      renderObjectData.version \
= renderObject.bundle.version;\n    }\n    return true;\n  }\n  \
needsRefresh(renderObject, nodeFrame) {\n    if (this.hasNode || \
this.hasAnimation || this.firstInitialization(renderObject))\n      return \
true;\n    const { renderId } = nodeFrame;\n    if (this.renderId !== \
renderId) {\n      this.renderId = renderId;\n      return true;\n    }\n    \
const isStatic = renderObject.object.static === true;\n    const isBundle = \
renderObject.bundle !== null && renderObject.bundle.static === true && \
this.getRenderObjectData(renderObject).version === \
renderObject.bundle.version;\n    if (isStatic || isBundle)\n      return \
false;\n    const notEqual2 = this.equals(renderObject) !== true;\n    return \
notEqual2;\n  }\n};\nfunction cyrb53(value, seed = 0) {\n  let h12 = \
3735928559 ^ seed, h2 = 1103547991 ^ seed;\n  if (value instanceof Array) {\n \
   for (let i = 0, val; i < value.length; i++) {\n      val = value[i];\n     \
 h12 = Math.imul(h12 ^ val, 2654435761);\n      h2 = Math.imul(h2 ^ val, \
1597334677);\n    }\n  } else {\n    for (let i = 0, ch; i < value.length; \
i++) {\n      ch = value.charCodeAt(i);\n      h12 = Math.imul(h12 ^ ch, \
2654435761);\n      h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n  }\n  h12 = \
Math.imul(h12 ^ h12 >>> 16, 2246822507);\n  h12 ^= Math.imul(h2 ^ h2 >>> 13, \
3266489909);\n  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n  h2 ^= \
Math.imul(h12 ^ h12 >>> 13, 3266489909);\n  return 4294967296 * (2097151 & \
h2) + (h12 >>> 0);\n}\nvar hashString = (str) => cyrb53(str);\nvar hashArray \
= (array) => cyrb53(array);\nvar hash$1 = (...params) => \
cyrb53(params);\nfunction getCacheKey$1(object, force = false) {\n  const \
values = [];\n  if (object.isNode === true) {\n    values.push(object.id);\n  \
  object = object.getSelf();\n  }\n  for (const { property: property2, \
childNode } of getNodeChildren(object)) {\n    values.push(values, \
cyrb53(property2.slice(0, -4)), childNode.getCacheKey(force));\n  }\n  return \
cyrb53(values);\n}\nfunction* getNodeChildren(node, toJSON = false) {\n  for \
(const property2 in node) {\n    if (property2.startsWith(\"_\") === true) \
continue;\n    const object = node[property2];\n    if (Array.isArray(object) \
=== true) {\n      for (let i = 0; i < object.length; i++) {\n        const \
child = object[i];\n        if (child && (child.isNode === true || toJSON && \
typeof child.toJSON === \"function\")) {\n          yield { property: \
property2, index: i, childNode: child };\n        }\n      }\n    } else if \
(object && object.isNode === true) {\n      yield { property: property2, \
childNode: object };\n    } else if (typeof object === \"object\") {\n      \
for (const subProperty in object) {\n        const child = \
object[subProperty];\n        if (child && (child.isNode === true || toJSON \
&& typeof child.toJSON === \"function\")) {\n          yield { property: \
property2, index: subProperty, childNode: child };\n        }\n      }\n    \
}\n  }\n}\nfunction getValueType(value) {\n  if (value === void 0 || value \
=== null) return null;\n  const typeOf = typeof value;\n  if (value.isNode \
=== true) {\n    return \"node\";\n  } else if (typeOf === \"number\") {\n    \
return \"float\";\n  } else if (typeOf === \"boolean\") {\n    return \
\"bool\";\n  } else if (typeOf === \"string\") {\n    return \"string\";\n  } \
else if (typeOf === \"function\") {\n    return \"shader\";\n  } else if \
(value.isVector2 === true) {\n    return \"vec2\";\n  } else if \
(value.isVector3 === true) {\n    return \"vec3\";\n  } else if \
(value.isVector4 === true) {\n    return \"vec4\";\n  } else if \
(value.isMatrix3 === true) {\n    return \"mat3\";\n  } else if \
(value.isMatrix4 === true) {\n    return \"mat4\";\n  } else if \
(value.isColor === true) {\n    return \"color\";\n  } else if (value \
instanceof ArrayBuffer) {\n    return \"ArrayBuffer\";\n  }\n  return \
null;\n}\nfunction getValueFromType(type, ...params) {\n  const last4 = type \
? type.slice(-4) : void 0;\n  if (params.length === 1) {\n    if (last4 === \
\"vec2\") params = [params[0], params[0]];\n    else if (last4 === \"vec3\") \
params = [params[0], params[0], params[0]];\n    else if (last4 === \"vec4\") \
params = [params[0], params[0], params[0], params[0]];\n  }\n  if (type === \
\"color\") {\n    return new Color2(...params);\n  } else if (last4 === \
\"vec2\") {\n    return new Vector22(...params);\n  } else if (last4 === \
\"vec3\") {\n    return new Vector32(...params);\n  } else if (last4 === \
\"vec4\") {\n    return new Vector42(...params);\n  } else if (last4 === \
\"mat3\") {\n    return new Matrix32(...params);\n  } else if (last4 === \
\"mat4\") {\n    return new Matrix42(...params);\n  } else if (type === \
\"bool\") {\n    return params[0] || false;\n  } else if (type === \"float\" \
|| type === \"int\" || type === \"uint\") {\n    return params[0] || 0;\n  } \
else if (type === \"string\") {\n    return params[0] || \"\";\n  } else if \
(type === \"ArrayBuffer\") {\n    return base64ToArrayBuffer(params[0]);\n  \
}\n  return null;\n}\nfunction arrayBufferToBase64(arrayBuffer) {\n  let \
chars = \"\";\n  const array = new Uint8Array(arrayBuffer);\n  for (let i = \
0; i < array.length; i++) {\n    chars += String.fromCharCode(array[i]);\n  \
}\n  return btoa(chars);\n}\nfunction base64ToArrayBuffer(base64) {\n  return \
Uint8Array.from(atob(base64), (c2) => c2.charCodeAt(0)).buffer;\n}\nvar \
NodeShaderStage = {\n  VERTEX: \"vertex\",\n  FRAGMENT: \"fragment\"\n};\nvar \
NodeUpdateType = {\n  NONE: \"none\",\n  FRAME: \"frame\",\n  RENDER: \
\"render\",\n  OBJECT: \"object\"\n};\nvar defaultShaderStages = \
[\"fragment\", \"vertex\"];\nvar defaultBuildStages = [\"setup\", \
\"analyze\", \"generate\"];\nvar shaderStages = [...defaultShaderStages, \
\"compute\"];\nvar vectorComponents = [\"x\", \"y\", \"z\", \"w\"];\nvar \
_nodeId = 0;\nvar Node = class extends EventDispatcher2 {\n  static get \
type() {\n    return \"Node\";\n  }\n  constructor(nodeType = null) {\n    \
super();\n    this.nodeType = nodeType;\n    this.updateType = \
NodeUpdateType.NONE;\n    this.updateBeforeType = NodeUpdateType.NONE;\n    \
this.updateAfterType = NodeUpdateType.NONE;\n    this.uuid = \
MathUtils2.generateUUID();\n    this.version = 0;\n    this._cacheKey = \
null;\n    this._cacheKeyVersion = 0;\n    this.global = false;\n    \
this.isNode = true;\n    Object.defineProperty(this, \"id\", { value: \
_nodeId++ });\n  }\n  set needsUpdate(value) {\n    if (value === true) {\n   \
   this.version++;\n    }\n  }\n  get type() {\n    return \
this.constructor.type;\n  }\n  onUpdate(callback, updateType) {\n    \
this.updateType = updateType;\n    this.update = \
callback.bind(this.getSelf());\n    return this;\n  }\n  \
onFrameUpdate(callback) {\n    return this.onUpdate(callback, \
NodeUpdateType.FRAME);\n  }\n  onRenderUpdate(callback) {\n    return \
this.onUpdate(callback, NodeUpdateType.RENDER);\n  }\n  \
onObjectUpdate(callback) {\n    return this.onUpdate(callback, \
NodeUpdateType.OBJECT);\n  }\n  onReference(callback) {\n    \
this.updateReference = callback.bind(this.getSelf());\n    return this;\n  \
}\n  getSelf() {\n    return this.self || this;\n  }\n  updateReference() {\n \
   return this;\n  }\n  isGlobal() {\n    return this.global;\n  }\n  \
*getChildren() {\n    for (const { childNode } of getNodeChildren(this)) {\n  \
    yield childNode;\n    }\n  }\n  dispose() {\n    this.dispatchEvent({ \
type: \"dispose\" });\n  }\n  traverse(callback) {\n    callback(this);\n    \
for (const childNode of this.getChildren()) {\n      \
childNode.traverse(callback);\n    }\n  }\n  getCacheKey(force = false) {\n   \
 force = force || this.version !== this._cacheKeyVersion;\n    if (force === \
true || this._cacheKey === null) {\n      this._cacheKey = \
getCacheKey$1(this, force);\n      this._cacheKeyVersion = this.version;\n    \
}\n    return this._cacheKey;\n  }\n  getScope() {\n    return this;\n  }\n  \
getHash() {\n    return this.uuid;\n  }\n  getUpdateType() {\n    return \
this.updateType;\n  }\n  getUpdateBeforeType() {\n    return \
this.updateBeforeType;\n  }\n  getUpdateAfterType() {\n    return \
this.updateAfterType;\n  }\n  getElementType(builder) {\n    const type = \
this.getNodeType(builder);\n    const elementType = \
builder.getElementType(type);\n    return elementType;\n  }\n  \
getNodeType(builder) {\n    const nodeProperties = \
builder.getNodeProperties(this);\n    if (nodeProperties.outputNode) {\n      \
return nodeProperties.outputNode.getNodeType(builder);\n    }\n    return \
this.nodeType;\n  }\n  getShared(builder) {\n    const hash = \
this.getHash(builder);\n    const nodeFromHash = \
builder.getNodeFromHash(hash);\n    return nodeFromHash || this;\n  }\n  \
setup(builder) {\n    const nodeProperties = \
builder.getNodeProperties(this);\n    let index5 = 0;\n    for (const \
childNode of this.getChildren()) {\n      nodeProperties[\"node\" + index5++] \
= childNode;\n    }\n    return null;\n  }\n  analyze(builder) {\n    const \
usageCount = builder.increaseUsage(this);\n    if (usageCount === 1) {\n      \
const nodeProperties = builder.getNodeProperties(this);\n      for (const \
childNode of Object.values(nodeProperties)) {\n        if (childNode && \
childNode.isNode === true) {\n          childNode.build(builder);\n        \
}\n      }\n    }\n  }\n  generate(builder, output2) {\n    const { \
outputNode } = builder.getNodeProperties(this);\n    if (outputNode && \
outputNode.isNode === true) {\n      return outputNode.build(builder, \
output2);\n    }\n  }\n  updateBefore() {\n    console.warn(\"Abstract \
function.\");\n  }\n  updateAfter() {\n    console.warn(\"Abstract \
function.\");\n  }\n  update() {\n    console.warn(\"Abstract function.\");\n \
 }\n  build(builder, output2 = null) {\n    const refNode = \
this.getShared(builder);\n    if (this !== refNode) {\n      return \
refNode.build(builder, output2);\n    }\n    builder.addNode(this);\n    \
builder.addChain(this);\n    let result = null;\n    const buildStage = \
builder.getBuildStage();\n    if (buildStage === \"setup\") {\n      \
this.updateReference(builder);\n      const properties = \
builder.getNodeProperties(this);\n      if (properties.initialized !== true) \
{\n        const stackNodesBeforeSetup = builder.stack.nodes.length;\n        \
properties.initialized = true;\n        properties.outputNode = \
this.setup(builder);\n        if (properties.outputNode !== null && \
builder.stack.nodes.length !== stackNodesBeforeSetup) ;\n        for (const \
childNode of Object.values(properties)) {\n          if (childNode && \
childNode.isNode === true) {\n            childNode.build(builder);\n         \
 }\n        }\n      }\n    } else if (buildStage === \"analyze\") {\n      \
this.analyze(builder);\n    } else if (buildStage === \"generate\") {\n      \
const isGenerateOnce = this.generate.length === 1;\n      if (isGenerateOnce) \
{\n        const type = this.getNodeType(builder);\n        const nodeData = \
builder.getDataFromNode(this);\n        result = nodeData.snippet;\n        \
if (result === void 0) {\n          result = this.generate(builder) || \
\"\";\n          nodeData.snippet = result;\n        } else if \
(nodeData.flowCodes !== void 0 && builder.context.nodeBlock !== void 0) {\n   \
       builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);\n       \
 }\n        result = builder.format(result, type, output2);\n      } else {\n \
       result = this.generate(builder, output2) || \"\";\n      }\n    }\n    \
builder.removeChain(this);\n    builder.addSequentialNode(this);\n    return \
result;\n  }\n  getSerializeChildren() {\n    return getNodeChildren(this);\n \
 }\n  serialize(json) {\n    const nodeChildren = \
this.getSerializeChildren();\n    const inputNodes = {};\n    for (const { \
property: property2, index: index5, childNode } of nodeChildren) {\n      if \
(index5 !== void 0) {\n        if (inputNodes[property2] === void 0) {\n      \
    inputNodes[property2] = Number.isInteger(index5) ? [] : {};\n        }\n  \
      inputNodes[property2][index5] = childNode.toJSON(json.meta).uuid;\n     \
 } else {\n        inputNodes[property2] = \
childNode.toJSON(json.meta).uuid;\n      }\n    }\n    if \
(Object.keys(inputNodes).length > 0) {\n      json.inputNodes = inputNodes;\n \
   }\n  }\n  deserialize(json) {\n    if (json.inputNodes !== void 0) {\n     \
 const nodes = json.meta.nodes;\n      for (const property2 in \
json.inputNodes) {\n        if (Array.isArray(json.inputNodes[property2])) \
{\n          const inputArray = [];\n          for (const uuid of \
json.inputNodes[property2]) {\n            inputArray.push(nodes[uuid]);\n    \
      }\n          this[property2] = inputArray;\n        } else if (typeof \
json.inputNodes[property2] === \"object\") {\n          const inputObject = \
{};\n          for (const subProperty in json.inputNodes[property2]) {\n      \
      const uuid = json.inputNodes[property2][subProperty];\n            \
inputObject[subProperty] = nodes[uuid];\n          }\n          \
this[property2] = inputObject;\n        } else {\n          const uuid = \
json.inputNodes[property2];\n          this[property2] = nodes[uuid];\n       \
 }\n      }\n    }\n  }\n  toJSON(meta) {\n    const { uuid, type } = this;\n \
   const isRoot = meta === void 0 || typeof meta === \"string\";\n    if \
(isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n      \
  nodes: {}\n      };\n    }\n    let data = meta.nodes[uuid];\n    if (data \
=== void 0) {\n      data = {\n        uuid,\n        type,\n        meta,\n  \
      metadata: {\n          version: 4.6,\n          type: \"Node\",\n       \
   generator: \"Node.toJSON\"\n        }\n      };\n      if (isRoot !== \
true) meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      \
delete data.meta;\n    }\n    function extractFromCache(cache2) {\n      \
const values = [];\n      for (const key in cache2) {\n        const data2 = \
cache2[key];\n        delete data2.metadata;\n        values.push(data2);\n   \
   }\n      return values;\n    }\n    if (isRoot) {\n      const textures = \
extractFromCache(meta.textures);\n      const images = \
extractFromCache(meta.images);\n      const nodes = \
extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = \
textures;\n      if (images.length > 0) data.images = images;\n      if \
(nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n};\nvar \
ArrayElementNode = class extends Node {\n  static get type() {\n    return \
\"ArrayElementNode\";\n  }\n  // @TODO: If extending from TempNode it breaks \
webgpu_compute\n  constructor(node, indexNode) {\n    super();\n    this.node \
= node;\n    this.indexNode = indexNode;\n    this.isArrayElementNode = \
true;\n  }\n  getNodeType(builder) {\n    return \
this.node.getElementType(builder);\n  }\n  generate(builder) {\n    const \
nodeSnippet = this.node.build(builder);\n    const indexSnippet = \
this.indexNode.build(builder, \"uint\");\n    return `${nodeSnippet}[ \
${indexSnippet} ]`;\n  }\n};\nvar ConvertNode = class extends Node {\n  \
static get type() {\n    return \"ConvertNode\";\n  }\n  constructor(node, \
convertTo) {\n    super();\n    this.node = node;\n    this.convertTo = \
convertTo;\n  }\n  getNodeType(builder) {\n    const requestType = \
this.node.getNodeType(builder);\n    let convertTo = null;\n    for (const \
overloadingType of this.convertTo.split(\"|\")) {\n      if (convertTo === \
null || builder.getTypeLength(requestType) === \
builder.getTypeLength(overloadingType)) {\n        convertTo = \
overloadingType;\n      }\n    }\n    return convertTo;\n  }\n  \
serialize(data) {\n    super.serialize(data);\n    data.convertTo = \
this.convertTo;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n   \
 this.convertTo = data.convertTo;\n  }\n  generate(builder, output2) {\n    \
const node = this.node;\n    const type = this.getNodeType(builder);\n    \
const snippet = node.build(builder, type);\n    return \
builder.format(snippet, type, output2);\n  }\n};\nvar TempNode = class \
extends Node {\n  static get type() {\n    return \"TempNode\";\n  }\n  \
constructor(type) {\n    super(type);\n    this.isTempNode = true;\n  }\n  \
hasDependencies(builder) {\n    return \
builder.getDataFromNode(this).usageCount > 1;\n  }\n  build(builder, output2) \
{\n    const buildStage = builder.getBuildStage();\n    if (buildStage === \
\"generate\") {\n      const type = \
builder.getVectorType(this.getNodeType(builder, output2));\n      const \
nodeData = builder.getDataFromNode(this);\n      if (nodeData.propertyName \
!== void 0) {\n        return builder.format(nodeData.propertyName, type, \
output2);\n      } else if (type !== \"void\" && output2 !== \"void\" && \
this.hasDependencies(builder)) {\n        const snippet = \
super.build(builder, type);\n        const nodeVar = \
builder.getVarFromNode(this, null, type);\n        const propertyName = \
builder.getPropertyName(nodeVar);\n        \
builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n        \
nodeData.snippet = snippet;\n        nodeData.propertyName = propertyName;\n  \
      return builder.format(nodeData.propertyName, type, output2);\n      }\n \
   }\n    return super.build(builder, output2);\n  }\n};\nvar JoinNode = \
class extends TempNode {\n  static get type() {\n    return \"JoinNode\";\n  \
}\n  constructor(nodes = [], nodeType = null) {\n    super(nodeType);\n    \
this.nodes = nodes;\n  }\n  getNodeType(builder) {\n    if (this.nodeType !== \
null) {\n      return builder.getVectorType(this.nodeType);\n    }\n    \
return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + \
builder.getTypeLength(cur.getNodeType(builder)), 0));\n  }\n  \
generate(builder, output2) {\n    const type = this.getNodeType(builder);\n   \
 const nodes = this.nodes;\n    const primitiveType = \
builder.getComponentType(type);\n    const snippetValues = [];\n    for \
(const input of nodes) {\n      let inputSnippet = input.build(builder);\n    \
  const inputPrimitiveType = \
builder.getComponentType(input.getNodeType(builder));\n      if \
(inputPrimitiveType !== primitiveType) {\n        inputSnippet = \
builder.format(inputSnippet, inputPrimitiveType, primitiveType);\n      }\n   \
   snippetValues.push(inputSnippet);\n    }\n    const snippet = \
`${builder.getType(type)}( ${snippetValues.join(\", \")} )`;\n    return \
builder.format(snippet, type, output2);\n  }\n};\nvar stringVectorComponents \
= vectorComponents.join(\"\");\nvar SplitNode = class extends Node {\n  \
static get type() {\n    return \"SplitNode\";\n  }\n  constructor(node, \
components = \"x\") {\n    super();\n    this.node = node;\n    \
this.components = components;\n    this.isSplitNode = true;\n  }\n  \
getVectorLength() {\n    let vectorLength = this.components.length;\n    for \
(const c2 of this.components) {\n      vectorLength = \
Math.max(vectorComponents.indexOf(c2) + 1, vectorLength);\n    }\n    return \
vectorLength;\n  }\n  getComponentType(builder) {\n    return \
builder.getComponentType(this.node.getNodeType(builder));\n  }\n  \
getNodeType(builder) {\n    return \
builder.getTypeFromLength(this.components.length, \
this.getComponentType(builder));\n  }\n  generate(builder, output2) {\n    \
const node = this.node;\n    const nodeTypeLength = \
builder.getTypeLength(node.getNodeType(builder));\n    let snippet = null;\n  \
  if (nodeTypeLength > 1) {\n      let type = null;\n      const \
componentsLength = this.getVectorLength();\n      if (componentsLength >= \
nodeTypeLength) {\n        type = \
builder.getTypeFromLength(this.getVectorLength(), \
this.getComponentType(builder));\n      }\n      const nodeSnippet = \
node.build(builder, type);\n      if (this.components.length === \
nodeTypeLength && this.components === stringVectorComponents.slice(0, \
this.components.length)) {\n        snippet = builder.format(nodeSnippet, \
type, output2);\n      } else {\n        snippet = \
builder.format(`${nodeSnippet}.${this.components}`, \
this.getNodeType(builder), output2);\n      }\n    } else {\n      snippet = \
node.build(builder, output2);\n    }\n    return snippet;\n  }\n  \
serialize(data) {\n    super.serialize(data);\n    data.components = \
this.components;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n  \
  this.components = data.components;\n  }\n};\nvar SetNode = class extends \
TempNode {\n  static get type() {\n    return \"SetNode\";\n  }\n  \
constructor(sourceNode, components, targetNode) {\n    super();\n    \
this.sourceNode = sourceNode;\n    this.components = components;\n    \
this.targetNode = targetNode;\n  }\n  getNodeType(builder) {\n    return \
this.sourceNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const \
{ sourceNode, components, targetNode } = this;\n    const sourceType = \
this.getNodeType(builder);\n    const targetType = \
builder.getTypeFromLength(components.length, \
targetNode.getNodeType(builder));\n    const targetSnippet = \
targetNode.build(builder, targetType);\n    const sourceSnippet = \
sourceNode.build(builder, sourceType);\n    const length2 = \
builder.getTypeLength(sourceType);\n    const snippetValues = [];\n    for \
(let i = 0; i < length2; i++) {\n      const component = \
vectorComponents[i];\n      if (component === components[0]) {\n        \
snippetValues.push(targetSnippet);\n        i += components.length - 1;\n     \
 } else {\n        snippetValues.push(sourceSnippet + \".\" + component);\n   \
   }\n    }\n    return `${builder.getType(sourceType)}( \
${snippetValues.join(\", \")} )`;\n  }\n};\nvar FlipNode = class extends \
TempNode {\n  static get type() {\n    return \"FlipNode\";\n  }\n  \
constructor(sourceNode, components) {\n    super();\n    this.sourceNode = \
sourceNode;\n    this.components = components;\n  }\n  getNodeType(builder) \
{\n    return this.sourceNode.getNodeType(builder);\n  }\n  generate(builder) \
{\n    const { components, sourceNode } = this;\n    const sourceType = \
this.getNodeType(builder);\n    const sourceSnippet = \
sourceNode.build(builder);\n    const sourceCache = \
builder.getVarFromNode(this);\n    const sourceProperty = \
builder.getPropertyName(sourceCache);\n    \
builder.addLineFlowCode(sourceProperty + \" = \" + sourceSnippet, this);\n    \
const length2 = builder.getTypeLength(sourceType);\n    const snippetValues = \
[];\n    let componentIndex = 0;\n    for (let i = 0; i < length2; i++) {\n   \
   const component = vectorComponents[i];\n      if (component === \
components[componentIndex]) {\n        snippetValues.push(\"1.0 - \" + \
(sourceProperty + \".\" + component));\n        componentIndex++;\n      } \
else {\n        snippetValues.push(sourceProperty + \".\" + component);\n     \
 }\n    }\n    return `${builder.getType(sourceType)}( \
${snippetValues.join(\", \")} )`;\n  }\n};\nvar InputNode = class extends \
Node {\n  static get type() {\n    return \"InputNode\";\n  }\n  \
constructor(value, nodeType = null) {\n    super(nodeType);\n    \
this.isInputNode = true;\n    this.value = value;\n    this.precision = \
null;\n  }\n  getNodeType() {\n    if (this.nodeType === null) {\n      \
return getValueType(this.value);\n    }\n    return this.nodeType;\n  }\n  \
getInputType(builder) {\n    return this.getNodeType(builder);\n  }\n  \
setPrecision(precision) {\n    this.precision = precision;\n    return \
this;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.value = \
this.value;\n    if (this.value && this.value.toArray) data.value = \
this.value.toArray();\n    data.valueType = getValueType(this.value);\n    \
data.nodeType = this.nodeType;\n    if (data.valueType === \"ArrayBuffer\") \
data.value = arrayBufferToBase64(data.value);\n    data.precision = \
this.precision;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n   \
 this.nodeType = data.nodeType;\n    this.value = Array.isArray(data.value) ? \
getValueFromType(data.valueType, ...data.value) : data.value;\n    \
this.precision = data.precision || null;\n    if (this.value && \
this.value.fromArray) this.value = this.value.fromArray(data.value);\n  }\n  \
generate() {\n    console.warn(\"Abstract function.\");\n  }\n};\nvar \
ConstNode = class extends InputNode {\n  static get type() {\n    return \
\"ConstNode\";\n  }\n  constructor(value, nodeType = null) {\n    \
super(value, nodeType);\n    this.isConstNode = true;\n  }\n  \
generateConst(builder) {\n    return \
builder.generateConst(this.getNodeType(builder), this.value);\n  }\n  \
generate(builder, output2) {\n    const type = this.getNodeType(builder);\n   \
 return builder.format(this.generateConst(builder), type, output2);\n  \
}\n};\nvar currentStack = null;\nvar NodeElements = /* @__PURE__ */ new \
Map();\nfunction addMethodChaining(name, nodeElement) {\n  if \
(NodeElements.has(name)) {\n    console.warn(`Redefinition of method chaining \
${name}`);\n    return;\n  }\n  if (typeof nodeElement !== \"function\") \
throw new Error(`Node element ${name} is not a function`);\n  \
NodeElements.set(name, nodeElement);\n}\nvar parseSwizzle = (props) => \
props.replace(/r|s/g, \"x\").replace(/g|t/g, \"y\").replace(/b|p/g, \
\"z\").replace(/a|q/g, \"w\");\nvar parseSwizzleAndSort = (props) => \
parseSwizzle(props).split(\"\").sort().join(\"\");\nvar shaderNodeHandler = \
{\n  setup(NodeClosure, params) {\n    const inputs = params.shift();\n    \
return NodeClosure(nodeObjects(inputs), ...params);\n  },\n  get(node, prop, \
nodeObj) {\n    if (typeof prop === \"string\" && node[prop] === void 0) {\n  \
    if (node.isStackNode !== true && prop === \"assign\") {\n        return \
(...params) => {\n          currentStack.assign(nodeObj, ...params);\n        \
  return nodeObj;\n        };\n      } else if (NodeElements.has(prop)) {\n   \
     const nodeElement = NodeElements.get(prop);\n        return \
node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : \
(...params) => nodeElement(nodeObj, ...params);\n      } else if (prop === \
\"self\") {\n        return node;\n      } else if (prop.endsWith(\"Assign\") \
&& NodeElements.has(prop.slice(0, prop.length - \"Assign\".length))) {\n      \
  const nodeElement = NodeElements.get(prop.slice(0, prop.length - \
\"Assign\".length));\n        return node.isStackNode ? (...params) => \
nodeObj.assign(params[0], nodeElement(...params)) : (...params) => \
nodeObj.assign(nodeElement(nodeObj, ...params));\n      } else if \
(/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        prop = \
parseSwizzle(prop);\n        return nodeObject(new SplitNode(nodeObj, \
prop));\n      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n \
       prop = parseSwizzleAndSort(prop.slice(3).toLowerCase());\n        \
return (value) => nodeObject(new SetNode(node, prop, value));\n      } else \
if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        prop = \
parseSwizzleAndSort(prop.slice(4).toLowerCase());\n        return () => \
nodeObject(new FlipNode(nodeObject(node), prop));\n      } else if (prop === \
\"width\" || prop === \"height\" || prop === \"depth\") {\n        if (prop \
=== \"width\") prop = \"x\";\n        else if (prop === \"height\") prop = \
\"y\";\n        else if (prop === \"depth\") prop = \"z\";\n        return \
nodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) \
=== true) {\n        return nodeObject(new ArrayElementNode(nodeObj, new \
ConstNode(Number(prop), \"uint\")));\n      }\n    }\n    return \
Reflect.get(node, prop, nodeObj);\n  },\n  set(node, prop, value, nodeObj) \
{\n    if (typeof prop === \"string\" && node[prop] === void 0) {\n      if \
(/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === \"width\" || prop \
=== \"height\" || prop === \"depth\" || /^\\d+$/.test(prop) === true) {\n     \
   nodeObj[prop].assign(value);\n        return true;\n      }\n    }\n    \
return Reflect.set(node, prop, value, nodeObj);\n  }\n};\nvar \
nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();\nvar \
nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();\nvar \
ShaderNodeObject = function(obj, altType = null) {\n  const type = \
getValueType(obj);\n  if (type === \"node\") {\n    let nodeObject2 = \
nodeObjectsCacheMap.get(obj);\n    if (nodeObject2 === void 0) {\n      \
nodeObject2 = new Proxy(obj, shaderNodeHandler);\n      \
nodeObjectsCacheMap.set(obj, nodeObject2);\n      \
nodeObjectsCacheMap.set(nodeObject2, nodeObject2);\n    }\n    return \
nodeObject2;\n  } else if (altType === null && (type === \"float\" || type \
=== \"boolean\") || type && type !== \"shader\" && type !== \"string\") {\n   \
 return nodeObject(getConstNode(obj, altType));\n  } else if (type === \
\"shader\") {\n    return Fn(obj);\n  }\n  return obj;\n};\nvar \
ShaderNodeObjects = function(objects, altType = null) {\n  for (const name in \
objects) {\n    objects[name] = nodeObject(objects[name], altType);\n  }\n  \
return objects;\n};\nvar ShaderNodeArray = function(array, altType = null) \
{\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    \
array[i] = nodeObject(array[i], altType);\n  }\n  return array;\n};\nvar \
ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = \
null) {\n  const assignNode = (node) => nodeObject(settings !== null ? \
Object.assign(node, settings) : node);\n  if (scope === null) {\n    return \
(...params) => {\n      return assignNode(new \
NodeClass(...nodeArray(params)));\n    };\n  } else if (factor !== null) {\n  \
  factor = nodeObject(factor);\n    return (...params) => {\n      return \
assignNode(new NodeClass(scope, ...nodeArray(params), factor));\n    };\n  } \
else {\n    return (...params) => {\n      return assignNode(new \
NodeClass(scope, ...nodeArray(params)));\n    };\n  }\n};\nvar \
ShaderNodeImmutable = function(NodeClass, ...params) {\n  return \
nodeObject(new NodeClass(...nodeArray(params)));\n};\nvar \
ShaderCallNodeInternal = class extends Node {\n  constructor(shaderNode, \
inputNodes) {\n    super();\n    this.shaderNode = shaderNode;\n    \
this.inputNodes = inputNodes;\n  }\n  getNodeType(builder) {\n    return \
this.shaderNode.nodeType || \
this.getOutputNode(builder).getNodeType(builder);\n  }\n  call(builder) {\n   \
 const { shaderNode, inputNodes } = this;\n    const properties = \
builder.getNodeProperties(shaderNode);\n    if (properties.onceOutput) return \
properties.onceOutput;\n    let result = null;\n    if (shaderNode.layout) \
{\n      let functionNodesCacheMap = \
nodeBuilderFunctionsCacheMap.get(builder.constructor);\n      if \
(functionNodesCacheMap === void 0) {\n        functionNodesCacheMap = /* \
@__PURE__ */ new WeakMap();\n        \
nodeBuilderFunctionsCacheMap.set(builder.constructor, \
functionNodesCacheMap);\n      }\n      let functionNode = \
functionNodesCacheMap.get(shaderNode);\n      if (functionNode === void 0) \
{\n        functionNode = \
nodeObject(builder.buildFunctionNode(shaderNode));\n        \
functionNodesCacheMap.set(shaderNode, functionNode);\n      }\n      if \
(builder.currentFunctionNode !== null) {\n        \
builder.currentFunctionNode.includes.push(functionNode);\n      }\n      \
result = nodeObject(functionNode.call(inputNodes));\n    } else {\n      \
const jsFunc = shaderNode.jsFunc;\n      const outputNode = inputNodes !== \
null ? jsFunc(inputNodes, builder) : jsFunc(builder);\n      result = \
nodeObject(outputNode);\n    }\n    if (shaderNode.once) {\n      \
properties.onceOutput = result;\n    }\n    return result;\n  }\n  \
getOutputNode(builder) {\n    const properties = \
builder.getNodeProperties(this);\n    if (properties.outputNode === null) {\n \
     properties.outputNode = this.setupOutput(builder);\n    }\n    return \
properties.outputNode;\n  }\n  setup(builder) {\n    return \
this.getOutputNode(builder);\n  }\n  setupOutput(builder) {\n    \
builder.addStack();\n    builder.stack.outputNode = this.call(builder);\n    \
return builder.removeStack();\n  }\n  generate(builder, output2) {\n    const \
outputNode = this.getOutputNode(builder);\n    return \
outputNode.build(builder, output2);\n  }\n};\nvar ShaderNodeInternal = class \
extends Node {\n  constructor(jsFunc, nodeType) {\n    super(nodeType);\n    \
this.jsFunc = jsFunc;\n    this.layout = null;\n    this.global = true;\n    \
this.once = false;\n  }\n  setLayout(layout) {\n    this.layout = layout;\n   \
 return this;\n  }\n  call(inputs = null) {\n    nodeObjects(inputs);\n    \
return nodeObject(new ShaderCallNodeInternal(this, inputs));\n  }\n  setup() \
{\n    return this.call();\n  }\n};\nvar bools = [false, true];\nvar uints = \
[0, 1, 2, 3];\nvar ints = [-1, -2];\nvar floats = [0.5, 1.5, 1 / 3, 1e-6, \
1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), \
Math.PI / 2];\nvar boolsCacheMap = /* @__PURE__ */ new Map();\nfor (const \
bool2 of bools) boolsCacheMap.set(bool2, new ConstNode(bool2));\nvar \
uintsCacheMap = /* @__PURE__ */ new Map();\nfor (const uint2 of uints) \
uintsCacheMap.set(uint2, new ConstNode(uint2, \"uint\"));\nvar intsCacheMap = \
new Map([...uintsCacheMap].map((el) => new ConstNode(el.value, \
\"int\")));\nfor (const int2 of ints) intsCacheMap.set(int2, new \
ConstNode(int2, \"int\"));\nvar floatsCacheMap = new \
Map([...intsCacheMap].map((el) => new ConstNode(el.value)));\nfor (const \
float2 of floats) floatsCacheMap.set(float2, new ConstNode(float2));\nfor \
(const float2 of floats) floatsCacheMap.set(-float2, new \
ConstNode(-float2));\nvar cacheMaps = { bool: boolsCacheMap, uint: \
uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\nvar \
constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nvar \
getConstNode = (value, type) => {\n  if (constNodesCacheMap.has(value)) {\n   \
 return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) \
{\n    return value;\n  } else {\n    return new ConstNode(value, type);\n  \
}\n};\nvar safeGetNodeType = (node) => {\n  try {\n    return \
node.getNodeType();\n  } catch (_) {\n    return void 0;\n  }\n};\nvar \
ConvertType = function(type, cacheMap = null) {\n  return (...params) => {\n  \
  if (params.length === 0 || ![\"bool\", \"float\", \"int\", \
\"uint\"].includes(type) && params.every((param) => typeof param !== \
\"object\")) {\n      params = [getValueFromType(type, ...params)];\n    }\n  \
  if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) \
{\n      return nodeObject(cacheMap.get(params[0]));\n    }\n    if \
(params.length === 1) {\n      const node = getConstNode(params[0], type);\n  \
    if (safeGetNodeType(node) === type) return nodeObject(node);\n      \
return nodeObject(new ConvertNode(node, type));\n    }\n    const nodes = \
params.map((param) => getConstNode(param));\n    return nodeObject(new \
JoinNode(nodes, type));\n  };\n};\nvar defined = (v) => typeof v === \
\"object\" && v !== null ? v.value : v;\nvar getConstNodeType = (value) => \
value !== void 0 && value !== null ? value.nodeType || value.convertTo || \
(typeof value === \"string\" ? value : null) : null;\nfunction \
ShaderNode(jsFunc, nodeType) {\n  return new Proxy(new \
ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);\n}\nvar nodeObject \
= (val, altType = null) => (\n  /* new */\n  ShaderNodeObject(val, \
altType)\n);\nvar nodeObjects = (val, altType = null) => new \
ShaderNodeObjects(val, altType);\nvar nodeArray = (val, altType = null) => \
new ShaderNodeArray(val, altType);\nvar nodeProxy = (...params) => new \
ShaderNodeProxy(...params);\nvar nodeImmutable = (...params) => new \
ShaderNodeImmutable(...params);\nvar Fn = (jsFunc, nodeType) => {\n  const \
shaderNode = new ShaderNode(jsFunc, nodeType);\n  const fn = (...params) => \
{\n    let inputs;\n    nodeObjects(params);\n    if (params[0] && \
params[0].isNode) {\n      inputs = [...params];\n    } else {\n      inputs \
= params[0];\n    }\n    return shaderNode.call(inputs);\n  };\n  \
fn.shaderNode = shaderNode;\n  fn.setLayout = (layout) => {\n    \
shaderNode.setLayout(layout);\n    return fn;\n  };\n  fn.once = () => {\n    \
shaderNode.once = true;\n    return fn;\n  };\n  return \
fn;\n};\naddMethodChaining(\"toGlobal\", (node) => {\n  node.global = true;\n \
 return node;\n});\nvar setCurrentStack = (stack2) => {\n  currentStack = \
stack2;\n};\nvar getCurrentStack = () => currentStack;\nvar If = (...params) \
=> currentStack.If(...params);\nfunction append(node) {\n  if (currentStack) \
currentStack.add(node);\n  return node;\n}\naddMethodChaining(\"append\", \
append);\nvar color = new ConvertType(\"color\");\nvar float = new \
ConvertType(\"float\", cacheMaps.float);\nvar int = new ConvertType(\"int\", \
cacheMaps.ints);\nvar uint = new ConvertType(\"uint\", cacheMaps.uint);\nvar \
bool = new ConvertType(\"bool\", cacheMaps.bool);\nvar vec2 = new \
ConvertType(\"vec2\");\nvar ivec2 = new ConvertType(\"ivec2\");\nvar uvec2 = \
new ConvertType(\"uvec2\");\nvar bvec2 = new ConvertType(\"bvec2\");\nvar \
vec3 = new ConvertType(\"vec3\");\nvar ivec3 = new \
ConvertType(\"ivec3\");\nvar uvec3 = new ConvertType(\"uvec3\");\nvar bvec3 = \
new ConvertType(\"bvec3\");\nvar vec4 = new ConvertType(\"vec4\");\nvar ivec4 \
= new ConvertType(\"ivec4\");\nvar uvec4 = new ConvertType(\"uvec4\");\nvar \
bvec4 = new ConvertType(\"bvec4\");\nvar mat2 = new \
ConvertType(\"mat2\");\nvar mat3 = new ConvertType(\"mat3\");\nvar mat4 = new \
ConvertType(\"mat4\");\naddMethodChaining(\"toColor\", \
color);\naddMethodChaining(\"toFloat\", float);\naddMethodChaining(\"toInt\", \
int);\naddMethodChaining(\"toUint\", uint);\naddMethodChaining(\"toBool\", \
bool);\naddMethodChaining(\"toVec2\", vec2);\naddMethodChaining(\"toIVec2\", \
ivec2);\naddMethodChaining(\"toUVec2\", \
uvec2);\naddMethodChaining(\"toBVec2\", \
bvec2);\naddMethodChaining(\"toVec3\", vec3);\naddMethodChaining(\"toIVec3\", \
ivec3);\naddMethodChaining(\"toUVec3\", \
uvec3);\naddMethodChaining(\"toBVec3\", \
bvec3);\naddMethodChaining(\"toVec4\", vec4);\naddMethodChaining(\"toIVec4\", \
ivec4);\naddMethodChaining(\"toUVec4\", \
uvec4);\naddMethodChaining(\"toBVec4\", \
bvec4);\naddMethodChaining(\"toMat2\", mat2);\naddMethodChaining(\"toMat3\", \
mat3);\naddMethodChaining(\"toMat4\", mat4);\nvar element = /* @__PURE__ */ \
nodeProxy(ArrayElementNode);\nvar convert = (node, types) => nodeObject(new \
ConvertNode(nodeObject(node), types));\naddMethodChaining(\"element\", \
element);\naddMethodChaining(\"convert\", convert);\nvar UniformGroupNode = \
class extends Node {\n  static get type() {\n    return \
\"UniformGroupNode\";\n  }\n  constructor(name, shared = false, order = 1) \
{\n    super(\"string\");\n    this.name = name;\n    this.version = 0;\n    \
this.shared = shared;\n    this.order = order;\n    this.isUniformGroup = \
true;\n  }\n  set needsUpdate(value) {\n    if (value === true) \
this.version++;\n  }\n  serialize(data) {\n    super.serialize(data);\n    \
data.name = this.name;\n    data.version = this.version;\n    data.shared = \
this.shared;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    \
this.name = data.name;\n    this.version = data.version;\n    this.shared = \
data.shared;\n  }\n};\nvar uniformGroup = (name) => new \
UniformGroupNode(name);\nvar sharedUniformGroup = (name, order = 0) => new \
UniformGroupNode(name, true, order);\nvar frameGroup = /* @__PURE__ */ \
sharedUniformGroup(\"frame\");\nvar renderGroup = /* @__PURE__ */ \
sharedUniformGroup(\"render\");\nvar objectGroup = /* @__PURE__ */ \
uniformGroup(\"object\");\nvar UniformNode = class extends InputNode {\n  \
static get type() {\n    return \"UniformNode\";\n  }\n  constructor(value, \
nodeType = null) {\n    super(value, nodeType);\n    this.isUniformNode = \
true;\n    this.name = \"\";\n    this.groupNode = objectGroup;\n  }\n  \
label(name) {\n    this.name = name;\n    return this;\n  }\n  \
setGroup(group) {\n    this.groupNode = group;\n    return this;\n  }\n  \
getGroup() {\n    return this.groupNode;\n  }\n  getUniformHash(builder) {\n  \
  return this.getHash(builder);\n  }\n  onUpdate(callback, updateType) {\n    \
const self2 = this.getSelf();\n    callback = callback.bind(self2);\n    \
return super.onUpdate((frame2) => {\n      const value = callback(frame2, \
self2);\n      if (value !== void 0) {\n        this.value = value;\n      \
}\n    }, updateType);\n  }\n  generate(builder, output2) {\n    const type = \
this.getNodeType(builder);\n    const hash = this.getUniformHash(builder);\n  \
  let sharedNode = builder.getNodeFromHash(hash);\n    if (sharedNode === \
void 0) {\n      builder.setHashNode(this, hash);\n      sharedNode = this;\n \
   }\n    const sharedNodeType = sharedNode.getInputType(builder);\n    const \
nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, \
builder.shaderStage, this.name || builder.context.label);\n    const \
propertyName = builder.getPropertyName(nodeUniform);\n    if \
(builder.context.label !== void 0) delete builder.context.label;\n    return \
builder.format(propertyName, type, output2);\n  }\n};\nvar uniform = (arg1, \
arg2) => {\n  const nodeType = getConstNodeType(arg2 || arg1);\n  const value \
= arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : \
arg1;\n  return nodeObject(new UniformNode(value, nodeType));\n};\nvar \
PropertyNode = class extends Node {\n  static get type() {\n    return \
\"PropertyNode\";\n  }\n  constructor(nodeType, name = null, varying2 = \
false) {\n    super(nodeType);\n    this.name = name;\n    this.varying = \
varying2;\n    this.isPropertyNode = true;\n  }\n  getHash(builder) {\n    \
return this.name || super.getHash(builder);\n  }\n  isGlobal() {\n    return \
true;\n  }\n  generate(builder) {\n    let nodeVar;\n    if (this.varying === \
true) {\n      nodeVar = builder.getVaryingFromNode(this, this.name);\n      \
nodeVar.needsInterpolation = true;\n    } else {\n      nodeVar = \
builder.getVarFromNode(this, this.name);\n    }\n    return \
builder.getPropertyName(nodeVar);\n  }\n};\nvar property = (type, name) => \
nodeObject(new PropertyNode(type, name));\nvar varyingProperty = (type, name) \
=> nodeObject(new PropertyNode(type, name, true));\nvar diffuseColor = /* \
@__PURE__ */ nodeImmutable(PropertyNode, \"vec4\", \"DiffuseColor\");\nvar \
emissive = /* @__PURE__ */ nodeImmutable(PropertyNode, \"vec3\", \
\"EmissiveColor\");\nvar roughness = /* @__PURE__ */ \
nodeImmutable(PropertyNode, \"float\", \"Roughness\");\nvar metalness = /* \
@__PURE__ */ nodeImmutable(PropertyNode, \"float\", \"Metalness\");\nvar \
clearcoat = /* @__PURE__ */ nodeImmutable(PropertyNode, \"float\", \
\"Clearcoat\");\nvar clearcoatRoughness = /* @__PURE__ */ \
nodeImmutable(PropertyNode, \"float\", \"ClearcoatRoughness\");\nvar sheen = \
/* @__PURE__ */ nodeImmutable(PropertyNode, \"vec3\", \"Sheen\");\nvar \
sheenRoughness = /* @__PURE__ */ nodeImmutable(PropertyNode, \"float\", \
\"SheenRoughness\");\nvar iridescence = /* @__PURE__ */ \
nodeImmutable(PropertyNode, \"float\", \"Iridescence\");\nvar iridescenceIOR \
= /* @__PURE__ */ nodeImmutable(PropertyNode, \"float\", \
\"IridescenceIOR\");\nvar iridescenceThickness = /* @__PURE__ */ \
nodeImmutable(PropertyNode, \"float\", \"IridescenceThickness\");\nvar alphaT \
= /* @__PURE__ */ nodeImmutable(PropertyNode, \"float\", \"AlphaT\");\nvar \
anisotropy = /* @__PURE__ */ nodeImmutable(PropertyNode, \"float\", \
\"Anisotropy\");\nvar anisotropyT = /* @__PURE__ */ \
nodeImmutable(PropertyNode, \"vec3\", \"AnisotropyT\");\nvar anisotropyB = /* \
@__PURE__ */ nodeImmutable(PropertyNode, \"vec3\", \"AnisotropyB\");\nvar \
specularColor = /* @__PURE__ */ nodeImmutable(PropertyNode, \"color\", \
\"SpecularColor\");\nvar specularF90 = /* @__PURE__ */ \
nodeImmutable(PropertyNode, \"float\", \"SpecularF90\");\nvar shininess = /* \
@__PURE__ */ nodeImmutable(PropertyNode, \"float\", \"Shininess\");\nvar \
output = /* @__PURE__ */ nodeImmutable(PropertyNode, \"vec4\", \
\"Output\");\nvar dashSize = /* @__PURE__ */ nodeImmutable(PropertyNode, \
\"float\", \"dashSize\");\nvar gapSize = /* @__PURE__ */ \
nodeImmutable(PropertyNode, \"float\", \"gapSize\");\nvar ior = /* @__PURE__ \
*/ nodeImmutable(PropertyNode, \"float\", \"IOR\");\nvar transmission = /* \
@__PURE__ */ nodeImmutable(PropertyNode, \"float\", \"Transmission\");\nvar \
thickness = /* @__PURE__ */ nodeImmutable(PropertyNode, \"float\", \
\"Thickness\");\nvar attenuationDistance = /* @__PURE__ */ \
nodeImmutable(PropertyNode, \"float\", \"AttenuationDistance\");\nvar \
attenuationColor = /* @__PURE__ */ nodeImmutable(PropertyNode, \"color\", \
\"AttenuationColor\");\nvar dispersion = /* @__PURE__ */ \
nodeImmutable(PropertyNode, \"float\", \"Dispersion\");\nvar AssignNode = \
class extends TempNode {\n  static get type() {\n    return \"AssignNode\";\n \
 }\n  constructor(targetNode, sourceNode) {\n    super();\n    \
this.targetNode = targetNode;\n    this.sourceNode = sourceNode;\n  }\n  \
hasDependencies() {\n    return false;\n  }\n  getNodeType(builder, output2) \
{\n    return output2 !== \"void\" ? this.targetNode.getNodeType(builder) : \
\"void\";\n  }\n  needsSplitAssign(builder) {\n    const { targetNode } = \
this;\n    if (builder.isAvailable(\"swizzleAssign\") === false && \
targetNode.isSplitNode && targetNode.components.length > 1) {\n      const \
targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));\n \
     const assignDiferentVector = vectorComponents.join(\"\").slice(0, \
targetLength) !== targetNode.components;\n      return \
assignDiferentVector;\n    }\n    return false;\n  }\n  generate(builder, \
output2) {\n    const { targetNode, sourceNode } = this;\n    const \
needsSplitAssign = this.needsSplitAssign(builder);\n    const targetType = \
targetNode.getNodeType(builder);\n    const target = targetNode.context({ \
assign: true }).build(builder);\n    const source = sourceNode.build(builder, \
targetType);\n    const sourceType = sourceNode.getNodeType(builder);\n    \
const nodeData = builder.getDataFromNode(this);\n    let snippet;\n    if \
(nodeData.initialized === true) {\n      if (output2 !== \"void\") {\n        \
snippet = target;\n      }\n    } else if (needsSplitAssign) {\n      const \
sourceVar = builder.getVarFromNode(this, null, targetType);\n      const \
sourceProperty = builder.getPropertyName(sourceVar);\n      \
builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);\n      const \
targetRoot = targetNode.node.context({ assign: true }).build(builder);\n      \
for (let i = 0; i < targetNode.components.length; i++) {\n        const \
component = targetNode.components[i];\n        \
builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} \
]`, this);\n      }\n      if (output2 !== \"void\") {\n        snippet = \
target;\n      }\n    } else {\n      snippet = `${target} = ${source}`;\n    \
  if (output2 === \"void\" || sourceType === \"void\") {\n        \
builder.addLineFlowCode(snippet, this);\n        if (output2 !== \"void\") \
{\n          snippet = target;\n        }\n      }\n    }\n    \
nodeData.initialized = true;\n    return builder.format(snippet, targetType, \
output2);\n  }\n};\nvar assign = /* @__PURE__ */ \
nodeProxy(AssignNode);\naddMethodChaining(\"assign\", assign);\nvar \
FunctionCallNode = class extends TempNode {\n  static get type() {\n    \
return \"FunctionCallNode\";\n  }\n  constructor(functionNode = null, \
parameters = {}) {\n    super();\n    this.functionNode = functionNode;\n    \
this.parameters = parameters;\n  }\n  setParameters(parameters) {\n    \
this.parameters = parameters;\n    return this;\n  }\n  getParameters() {\n   \
 return this.parameters;\n  }\n  getNodeType(builder) {\n    return \
this.functionNode.getNodeType(builder);\n  }\n  generate(builder) {\n    \
const params = [];\n    const functionNode = this.functionNode;\n    const \
inputs = functionNode.getInputs(builder);\n    const parameters = \
this.parameters;\n    const generateInput = (node, inputNode) => {\n      \
const type = inputNode.type;\n      const pointer = type === \"pointer\";\n   \
   let output2;\n      if (pointer) output2 = \"&\" + node.build(builder);\n  \
    else output2 = node.build(builder, type);\n      return output2;\n    \
};\n    if (Array.isArray(parameters)) {\n      for (let i = 0; i < \
parameters.length; i++) {\n        params.push(generateInput(parameters[i], \
inputs[i]));\n      }\n    } else {\n      for (const inputNode of inputs) \
{\n        const node = parameters[inputNode.name];\n        if (node !== \
void 0) {\n          params.push(generateInput(node, inputNode));\n        } \
else {\n          throw new Error(`FunctionCallNode: Input \
'${inputNode.name}' not found in FunctionNode.`);\n        }\n      }\n    \
}\n    const functionName = functionNode.build(builder, \"property\");\n    \
return `${functionName}( ${params.join(\", \")} )`;\n  }\n};\nvar call = \
(func, ...params) => {\n  params = params.length > 1 || params[0] && \
params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);\n  \
return nodeObject(new FunctionCallNode(nodeObject(func), \
params));\n};\naddMethodChaining(\"call\", call);\nvar OperatorNode = class \
_OperatorNode extends TempNode {\n  static get type() {\n    return \
\"OperatorNode\";\n  }\n  constructor(op, aNode, bNode, ...params) {\n    \
super();\n    if (params.length > 0) {\n      let finalOp = new \
_OperatorNode(op, aNode, bNode);\n      for (let i = 0; i < params.length - \
1; i++) {\n        finalOp = new _OperatorNode(op, finalOp, params[i]);\n     \
 }\n      aNode = finalOp;\n      bNode = params[params.length - 1];\n    }\n \
   this.op = op;\n    this.aNode = aNode;\n    this.bNode = bNode;\n  }\n  \
getNodeType(builder, output2) {\n    const op = this.op;\n    const aNode = \
this.aNode;\n    const bNode = this.bNode;\n    const typeA = \
aNode.getNodeType(builder);\n    const typeB = typeof bNode !== \"undefined\" \
? bNode.getNodeType(builder) : null;\n    if (typeA === \"void\" || typeB === \
\"void\") {\n      return \"void\";\n    } else if (op === \"%\") {\n      \
return typeA;\n    } else if (op === \"~\" || op === \"&\" || op === \"|\" || \
op === \"^\" || op === \">>\" || op === \"<<\") {\n      return \
builder.getIntegerType(typeA);\n    } else if (op === \"!\" || op === \"==\" \
|| op === \"&&\" || op === \"||\" || op === \"^^\") {\n      return \
\"bool\";\n    } else if (op === \"<\" || op === \">\" || op === \"<=\" || op \
=== \">=\") {\n      const typeLength = output2 ? \
builder.getTypeLength(output2) : Math.max(builder.getTypeLength(typeA), \
builder.getTypeLength(typeB));\n      return typeLength > 1 ? \
`bvec${typeLength}` : \"bool\";\n    } else {\n      if (typeA === \"float\" \
&& builder.isMatrix(typeB)) {\n        return typeB;\n      } else if \
(builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        return \
builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) \
&& builder.isMatrix(typeB)) {\n        return \
builder.getVectorFromMatrix(typeB);\n      } else if \
(builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\n        \
return typeB;\n      }\n      return typeA;\n    }\n  }\n  generate(builder, \
output2) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const \
bNode = this.bNode;\n    const type = this.getNodeType(builder, output2);\n   \
 let typeA = null;\n    let typeB = null;\n    if (type !== \"void\") {\n     \
 typeA = aNode.getNodeType(builder);\n      typeB = typeof bNode !== \
\"undefined\" ? bNode.getNodeType(builder) : null;\n      if (op === \"<\" || \
op === \">\" || op === \"<=\" || op === \">=\" || op === \"==\") {\n        \
if (builder.isVector(typeA)) {\n          typeB = typeA;\n        } else if \
(typeA !== typeB) {\n          typeA = typeB = \"float\";\n        }\n      } \
else if (op === \">>\" || op === \"<<\") {\n        typeA = type;\n        \
typeB = builder.changeComponentType(typeB, \"uint\");\n      } else if \
(builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        typeB = \
builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) \
&& builder.isMatrix(typeB)) {\n        typeA = \
builder.getVectorFromMatrix(typeB);\n      } else {\n        typeA = typeB = \
type;\n      }\n    } else {\n      typeA = typeB = type;\n    }\n    const \
a2 = aNode.build(builder, typeA);\n    const b = typeof bNode !== \
\"undefined\" ? bNode.build(builder, typeB) : null;\n    const outputLength = \
builder.getTypeLength(output2);\n    const fnOpSnippet = \
builder.getFunctionOperator(op);\n    if (output2 !== \"void\") {\n      if \
(op === \"<\" && outputLength > 1) {\n        if \
(builder.useComparisonMethod) {\n          return \
builder.format(`${builder.getMethod(\"lessThan\", output2)}( ${a2}, ${b} )`, \
type, output2);\n        } else {\n          return builder.format(`( ${a2} < \
${b} )`, type, output2);\n        }\n      } else if (op === \"<=\" && \
outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          \
return builder.format(`${builder.getMethod(\"lessThanEqual\", output2)}( \
${a2}, ${b} )`, type, output2);\n        } else {\n          return \
builder.format(`( ${a2} <= ${b} )`, type, output2);\n        }\n      } else \
if (op === \">\" && outputLength > 1) {\n        if \
(builder.useComparisonMethod) {\n          return \
builder.format(`${builder.getMethod(\"greaterThan\", output2)}( ${a2}, ${b} \
)`, type, output2);\n        } else {\n          return builder.format(`( \
${a2} > ${b} )`, type, output2);\n        }\n      } else if (op === \">=\" \
&& outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          \
return builder.format(`${builder.getMethod(\"greaterThanEqual\", output2)}( \
${a2}, ${b} )`, type, output2);\n        } else {\n          return \
builder.format(`( ${a2} >= ${b} )`, type, output2);\n        }\n      } else \
if (op === \"!\" || op === \"~\") {\n        return \
builder.format(`(${op}${a2})`, typeA, output2);\n      } else if \
(fnOpSnippet) {\n        return builder.format(`${fnOpSnippet}( ${a2}, ${b} \
)`, type, output2);\n      } else {\n        return builder.format(`( ${a2} \
${op} ${b} )`, type, output2);\n      }\n    } else if (typeA !== \"void\") \
{\n      if (fnOpSnippet) {\n        return builder.format(`${fnOpSnippet}( \
${a2}, ${b} )`, type, output2);\n      } else {\n        return \
builder.format(`${a2} ${op} ${b}`, type, output2);\n      }\n    }\n  }\n  \
serialize(data) {\n    super.serialize(data);\n    data.op = this.op;\n  }\n  \
deserialize(data) {\n    super.deserialize(data);\n    this.op = data.op;\n  \
}\n};\nvar add4 = /* @__PURE__ */ nodeProxy(OperatorNode, \"+\");\nvar sub = \
/* @__PURE__ */ nodeProxy(OperatorNode, \"-\");\nvar mul = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"*\");\nvar div = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"/\");\nvar modInt = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"%\");\nvar equal = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"==\");\nvar notEqual = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"!=\");\nvar lessThan = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"<\");\nvar greaterThan = /* @__PURE__ */ \
nodeProxy(OperatorNode, \">\");\nvar lessThanEqual = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"<=\");\nvar greaterThanEqual = /* @__PURE__ */ \
nodeProxy(OperatorNode, \">=\");\nvar and = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"&&\");\nvar or = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"||\");\nvar not = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"!\");\nvar xor = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"^^\");\nvar bitAnd = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"&\");\nvar bitNot = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"~\");\nvar bitOr = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"|\");\nvar bitXor = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"^\");\nvar shiftLeft = /* @__PURE__ */ \
nodeProxy(OperatorNode, \"<<\");\nvar shiftRight = /* @__PURE__ */ \
nodeProxy(OperatorNode, \">>\");\naddMethodChaining(\"add\", \
add4);\naddMethodChaining(\"sub\", sub);\naddMethodChaining(\"mul\", \
mul);\naddMethodChaining(\"div\", div);\naddMethodChaining(\"modInt\", \
modInt);\naddMethodChaining(\"equal\", \
equal);\naddMethodChaining(\"notEqual\", \
notEqual);\naddMethodChaining(\"lessThan\", \
lessThan);\naddMethodChaining(\"greaterThan\", \
greaterThan);\naddMethodChaining(\"lessThanEqual\", \
lessThanEqual);\naddMethodChaining(\"greaterThanEqual\", \
greaterThanEqual);\naddMethodChaining(\"and\", \
and);\naddMethodChaining(\"or\", or);\naddMethodChaining(\"not\", \
not);\naddMethodChaining(\"xor\", xor);\naddMethodChaining(\"bitAnd\", \
bitAnd);\naddMethodChaining(\"bitNot\", \
bitNot);\naddMethodChaining(\"bitOr\", bitOr);\naddMethodChaining(\"bitXor\", \
bitXor);\naddMethodChaining(\"shiftLeft\", \
shiftLeft);\naddMethodChaining(\"shiftRight\", shiftRight);\nvar remainder = \
(...params) => {\n  console.warn(\"TSL.OperatorNode: .remainder() has been \
renamed to .modInt().\");\n  return \
modInt(...params);\n};\naddMethodChaining(\"remainder\", remainder);\nvar \
MathNode = class _MathNode extends TempNode {\n  static get type() {\n    \
return \"MathNode\";\n  }\n  constructor(method, aNode, bNode = null, cNode = \
null) {\n    super();\n    this.method = method;\n    this.aNode = aNode;\n   \
 this.bNode = bNode;\n    this.cNode = cNode;\n  }\n  getInputType(builder) \
{\n    const aType = this.aNode.getNodeType(builder);\n    const bType = \
this.bNode ? this.bNode.getNodeType(builder) : null;\n    const cType = \
this.cNode ? this.cNode.getNodeType(builder) : null;\n    const aLen = \
builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);\n    const bLen = \
builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);\n    const cLen = \
builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);\n    if (aLen > \
bLen && aLen > cLen) {\n      return aType;\n    } else if (bLen > cLen) {\n  \
    return bType;\n    } else if (cLen > aLen) {\n      return cType;\n    \
}\n    return aType;\n  }\n  getNodeType(builder) {\n    const method = \
this.method;\n    if (method === _MathNode.LENGTH || method === \
_MathNode.DISTANCE || method === _MathNode.DOT) {\n      return \"float\";\n  \
  } else if (method === _MathNode.CROSS) {\n      return \"vec3\";\n    } \
else if (method === _MathNode.ALL) {\n      return \"bool\";\n    } else if \
(method === _MathNode.EQUALS) {\n      return \
builder.changeComponentType(this.aNode.getNodeType(builder), \"bool\");\n    \
} else if (method === _MathNode.MOD) {\n      return \
this.aNode.getNodeType(builder);\n    } else {\n      return \
this.getInputType(builder);\n    }\n  }\n  generate(builder, output2) {\n    \
const method = this.method;\n    const type = this.getNodeType(builder);\n    \
const inputType = this.getInputType(builder);\n    const a2 = this.aNode;\n   \
 const b = this.bNode;\n    const c2 = this.cNode;\n    const isWebGL = \
builder.renderer.isWebGLRenderer === true;\n    if (method === \
_MathNode.TRANSFORM_DIRECTION) {\n      let tA = a2;\n      let tB = b;\n     \
 if (builder.isMatrix(tA.getNodeType(builder))) {\n        tB = \
vec4(vec3(tB), 0);\n      } else {\n        tA = vec4(vec3(tA), 0);\n      \
}\n      const mulNode = mul(tA, tB).xyz;\n      return \
normalize2(mulNode).build(builder, output2);\n    } else if (method === \
_MathNode.NEGATE) {\n      return builder.format(\"( - \" + a2.build(builder, \
inputType) + \" )\", type, output2);\n    } else if (method === \
_MathNode.ONE_MINUS) {\n      return sub(1, a2).build(builder, output2);\n    \
} else if (method === _MathNode.RECIPROCAL) {\n      return div(1, \
a2).build(builder, output2);\n    } else if (method === _MathNode.DIFFERENCE) \
{\n      return abs(sub(a2, b)).build(builder, output2);\n    } else {\n      \
const params = [];\n      if (method === _MathNode.CROSS || method === \
_MathNode.MOD) {\n        params.push(\n          a2.build(builder, type),\n  \
        b.build(builder, type)\n        );\n      } else if (isWebGL && \
method === _MathNode.STEP) {\n        params.push(\n          \
a2.build(builder, builder.getTypeLength(a2.getNodeType(builder)) === 1 ? \
\"float\" : inputType),\n          b.build(builder, inputType)\n        );\n  \
    } else if (isWebGL && (method === _MathNode.MIN || method === \
_MathNode.MAX) || method === _MathNode.MOD) {\n        params.push(\n         \
 a2.build(builder, inputType),\n          b.build(builder, \
builder.getTypeLength(b.getNodeType(builder)) === 1 ? \"float\" : \
inputType)\n        );\n      } else if (method === _MathNode.REFRACT) {\n    \
    params.push(\n          a2.build(builder, inputType),\n          \
b.build(builder, inputType),\n          c2.build(builder, \"float\")\n        \
);\n      } else if (method === _MathNode.MIX) {\n        params.push(\n      \
    a2.build(builder, inputType),\n          b.build(builder, inputType),\n   \
       c2.build(builder, builder.getTypeLength(c2.getNodeType(builder)) === 1 \
? \"float\" : inputType)\n        );\n      } else {\n        \
params.push(a2.build(builder, inputType));\n        if (b !== null) \
params.push(b.build(builder, inputType));\n        if (c2 !== null) \
params.push(c2.build(builder, inputType));\n      }\n      return \
builder.format(`${builder.getMethod(method, type)}( ${params.join(\", \")} \
)`, type, output2);\n    }\n  }\n  serialize(data) {\n    \
super.serialize(data);\n    data.method = this.method;\n  }\n  \
deserialize(data) {\n    super.deserialize(data);\n    this.method = \
data.method;\n  }\n};\nMathNode.ALL = \"all\";\nMathNode.ANY = \
\"any\";\nMathNode.EQUALS = \"equals\";\nMathNode.RADIANS = \
\"radians\";\nMathNode.DEGREES = \"degrees\";\nMathNode.EXP = \
\"exp\";\nMathNode.EXP2 = \"exp2\";\nMathNode.LOG = \"log\";\nMathNode.LOG2 = \
\"log2\";\nMathNode.SQRT = \"sqrt\";\nMathNode.INVERSE_SQRT = \
\"inversesqrt\";\nMathNode.FLOOR = \"floor\";\nMathNode.CEIL = \
\"ceil\";\nMathNode.NORMALIZE = \"normalize\";\nMathNode.FRACT = \
\"fract\";\nMathNode.SIN = \"sin\";\nMathNode.COS = \"cos\";\nMathNode.TAN = \
\"tan\";\nMathNode.ASIN = \"asin\";\nMathNode.ACOS = \"acos\";\nMathNode.ATAN \
= \"atan\";\nMathNode.ABS = \"abs\";\nMathNode.SIGN = \
\"sign\";\nMathNode.LENGTH = \"length\";\nMathNode.NEGATE = \
\"negate\";\nMathNode.ONE_MINUS = \"oneMinus\";\nMathNode.DFDX = \
\"dFdx\";\nMathNode.DFDY = \"dFdy\";\nMathNode.ROUND = \
\"round\";\nMathNode.RECIPROCAL = \"reciprocal\";\nMathNode.TRUNC = \
\"trunc\";\nMathNode.FWIDTH = \"fwidth\";\nMathNode.BITCAST = \
\"bitcast\";\nMathNode.TRANSPOSE = \"transpose\";\nMathNode.ATAN2 = \
\"atan2\";\nMathNode.MIN = \"min\";\nMathNode.MAX = \"max\";\nMathNode.MOD = \
\"mod\";\nMathNode.STEP = \"step\";\nMathNode.REFLECT = \
\"reflect\";\nMathNode.DISTANCE = \"distance\";\nMathNode.DIFFERENCE = \
\"difference\";\nMathNode.DOT = \"dot\";\nMathNode.CROSS = \
\"cross\";\nMathNode.POW = \"pow\";\nMathNode.TRANSFORM_DIRECTION = \
\"transformDirection\";\nMathNode.MIX = \"mix\";\nMathNode.CLAMP = \
\"clamp\";\nMathNode.REFRACT = \"refract\";\nMathNode.SMOOTHSTEP = \
\"smoothstep\";\nMathNode.FACEFORWARD = \"faceforward\";\nvar EPSILON = /* \
@__PURE__ */ float(1e-6);\nvar PI = /* @__PURE__ */ float(Math.PI);\nvar PI2 \
= /* @__PURE__ */ float(Math.PI * 2);\nvar all = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.ALL);\nvar any = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.ANY);\nvar equals = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.EQUALS);\nvar radians = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.RADIANS);\nvar degrees = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.DEGREES);\nvar exp = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.EXP);\nvar exp2 = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.EXP2);\nvar log = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.LOG);\nvar log2 = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.LOG2);\nvar sqrt = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.SQRT);\nvar inverseSqrt = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.INVERSE_SQRT);\nvar floor = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.FLOOR);\nvar ceil = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.CEIL);\nvar normalize2 = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.NORMALIZE);\nvar fract = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.FRACT);\nvar sin = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.SIN);\nvar cos = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.COS);\nvar tan = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.TAN);\nvar asin = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.ASIN);\nvar acos = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.ACOS);\nvar atan = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.ATAN);\nvar abs = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.ABS);\nvar sign = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.SIGN);\nvar length = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.LENGTH);\nvar negate = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.NEGATE);\nvar oneMinus = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.ONE_MINUS);\nvar dFdx = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.DFDX);\nvar dFdy = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.DFDY);\nvar round = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.ROUND);\nvar reciprocal = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.RECIPROCAL);\nvar trunc = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.TRUNC);\nvar fwidth = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.FWIDTH);\nvar bitcast = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.BITCAST);\nvar transpose = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.TRANSPOSE);\nvar atan2 = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.ATAN2);\nvar min$1 = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.MIN);\nvar max$1 = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.MAX);\nvar mod = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.MOD);\nvar step = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.STEP);\nvar reflect = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.REFLECT);\nvar distance = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.DISTANCE);\nvar difference = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.DIFFERENCE);\nvar dot = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.DOT);\nvar cross = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.CROSS);\nvar pow = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.POW);\nvar pow2 = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.POW, 2);\nvar pow3 = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.POW, 3);\nvar pow4 = /* @__PURE__ */ \
nodeProxy(MathNode, MathNode.POW, 4);\nvar transformDirection = /* @__PURE__ \
*/ nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);\nvar cbrt = (a2) => \
mul(sign(a2), pow(abs(a2), 1 / 3));\nvar lengthSq = (a2) => dot(a2, a2);\nvar \
mix = /* @__PURE__ */ nodeProxy(MathNode, MathNode.MIX);\nvar clamp2 = \
(value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, \
nodeObject(value), nodeObject(low), nodeObject(high)));\nvar saturate2 = \
(value) => clamp2(value);\nvar refract = /* @__PURE__ */ nodeProxy(MathNode, \
MathNode.REFRACT);\nvar smoothstep2 = /* @__PURE__ */ nodeProxy(MathNode, \
MathNode.SMOOTHSTEP);\nvar faceForward = /* @__PURE__ */ nodeProxy(MathNode, \
MathNode.FACEFORWARD);\nvar rand = /* @__PURE__ */ Fn(([uv2]) => {\n  const \
a2 = 12.9898, b = 78.233, c2 = 43758.5453;\n  const dt = dot(uv2.xy, vec2(a2, \
b)), sn = mod(dt, PI);\n  return fract(sin(sn).mul(c2));\n});\nvar mixElement \
= (t, e1, e2) => mix(e1, e2, t);\nvar smoothstepElement = (x2, low, high) => \
smoothstep2(low, high, x2);\naddMethodChaining(\"all\", \
all);\naddMethodChaining(\"any\", any);\naddMethodChaining(\"equals\", \
equals);\naddMethodChaining(\"radians\", \
radians);\naddMethodChaining(\"degrees\", \
degrees);\naddMethodChaining(\"exp\", exp);\naddMethodChaining(\"exp2\", \
exp2);\naddMethodChaining(\"log\", log);\naddMethodChaining(\"log2\", \
log2);\naddMethodChaining(\"sqrt\", \
sqrt);\naddMethodChaining(\"inverseSqrt\", \
inverseSqrt);\naddMethodChaining(\"floor\", \
floor);\naddMethodChaining(\"ceil\", ceil);\naddMethodChaining(\"normalize\", \
normalize2);\naddMethodChaining(\"fract\", \
fract);\naddMethodChaining(\"sin\", sin);\naddMethodChaining(\"cos\", \
cos);\naddMethodChaining(\"tan\", tan);\naddMethodChaining(\"asin\", \
asin);\naddMethodChaining(\"acos\", acos);\naddMethodChaining(\"atan\", \
atan);\naddMethodChaining(\"abs\", abs);\naddMethodChaining(\"sign\", \
sign);\naddMethodChaining(\"length\", \
length);\naddMethodChaining(\"lengthSq\", \
lengthSq);\naddMethodChaining(\"negate\", \
negate);\naddMethodChaining(\"oneMinus\", \
oneMinus);\naddMethodChaining(\"dFdx\", dFdx);\naddMethodChaining(\"dFdy\", \
dFdy);\naddMethodChaining(\"round\", \
round);\naddMethodChaining(\"reciprocal\", \
reciprocal);\naddMethodChaining(\"trunc\", \
trunc);\naddMethodChaining(\"fwidth\", fwidth);\naddMethodChaining(\"atan2\", \
atan2);\naddMethodChaining(\"min\", min$1);\naddMethodChaining(\"max\", \
max$1);\naddMethodChaining(\"mod\", mod);\naddMethodChaining(\"step\", \
step);\naddMethodChaining(\"reflect\", \
reflect);\naddMethodChaining(\"distance\", \
distance);\naddMethodChaining(\"dot\", dot);\naddMethodChaining(\"cross\", \
cross);\naddMethodChaining(\"pow\", pow);\naddMethodChaining(\"pow2\", \
pow2);\naddMethodChaining(\"pow3\", pow3);\naddMethodChaining(\"pow4\", \
pow4);\naddMethodChaining(\"transformDirection\", \
transformDirection);\naddMethodChaining(\"mix\", \
mixElement);\naddMethodChaining(\"clamp\", \
clamp2);\naddMethodChaining(\"refract\", \
refract);\naddMethodChaining(\"smoothstep\", \
smoothstepElement);\naddMethodChaining(\"faceForward\", \
faceForward);\naddMethodChaining(\"difference\", \
difference);\naddMethodChaining(\"saturate\", \
saturate2);\naddMethodChaining(\"cbrt\", \
cbrt);\naddMethodChaining(\"transpose\", \
transpose);\naddMethodChaining(\"rand\", rand);\nvar ConditionalNode = class \
extends Node {\n  static get type() {\n    return \"ConditionalNode\";\n  }\n \
 constructor(condNode, ifNode, elseNode = null) {\n    super();\n    \
this.condNode = condNode;\n    this.ifNode = ifNode;\n    this.elseNode = \
elseNode;\n  }\n  getNodeType(builder) {\n    const ifType = \
this.ifNode.getNodeType(builder);\n    if (this.elseNode !== null) {\n      \
const elseType = this.elseNode.getNodeType(builder);\n      if \
(builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {\n        \
return elseType;\n      }\n    }\n    return ifType;\n  }\n  setup(builder) \
{\n    const condNode = this.condNode.cache();\n    const ifNode = \
this.ifNode.cache();\n    const elseNode = this.elseNode ? \
this.elseNode.cache() : null;\n    const currentNodeBlock = \
builder.context.nodeBlock;\n    \
builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;\n    if \
(elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = \
currentNodeBlock;\n    const properties = builder.getNodeProperties(this);\n  \
  properties.condNode = condNode;\n    properties.ifNode = ifNode.context({ \
nodeBlock: ifNode });\n    properties.elseNode = elseNode ? \
elseNode.context({ nodeBlock: elseNode }) : null;\n  }\n  generate(builder, \
output2) {\n    const type = this.getNodeType(builder);\n    const nodeData = \
builder.getDataFromNode(this);\n    if (nodeData.nodeProperty !== void 0) {\n \
     return nodeData.nodeProperty;\n    }\n    const { condNode, ifNode, \
elseNode } = builder.getNodeProperties(this);\n    const needsOutput = \
output2 !== \"void\";\n    const nodeProperty = needsOutput ? \
property(type).build(builder) : \"\";\n    nodeData.nodeProperty = \
nodeProperty;\n    const nodeSnippet = condNode.build(builder, \"bool\");\n   \
 builder.addFlowCode(`\n${builder.tab}if ( ${nodeSnippet} ) \
{\n\n`).addFlowTab();\n    let ifSnippet = ifNode.build(builder, type);\n    \
if (ifSnippet) {\n      if (needsOutput) {\n        ifSnippet = nodeProperty \
+ \" = \" + ifSnippet + \";\";\n      } else {\n        ifSnippet = \"return \
\" + ifSnippet + \";\";\n      }\n    }\n    \
builder.removeFlowTab().addFlowCode(builder.tab + \"\t\" + ifSnippet + \
\"\\n\\n\" + builder.tab + \"}\");\n    if (elseNode !== null) {\n      \
builder.addFlowCode(\" else {\\n\\n\").addFlowTab();\n      let elseSnippet = \
elseNode.build(builder, type);\n      if (elseSnippet) {\n        if \
(needsOutput) {\n          elseSnippet = nodeProperty + \" = \" + elseSnippet \
+ \";\";\n        } else {\n          elseSnippet = \"return \" + elseSnippet \
+ \";\";\n        }\n      }\n      \
builder.removeFlowTab().addFlowCode(builder.tab + \"\t\" + elseSnippet + \
\"\\n\\n\" + builder.tab + \"}\\n\\n\");\n    } else {\n      \
builder.addFlowCode(\"\\n\\n\");\n    }\n    return \
builder.format(nodeProperty, type, output2);\n  }\n};\nvar select = /* \
@__PURE__ */ nodeProxy(ConditionalNode);\naddMethodChaining(\"select\", \
select);\nvar cond = (...params) => {\n  console.warn(\"TSL.ConditionalNode: \
cond() has been renamed to select().\");\n  return \
select(...params);\n};\naddMethodChaining(\"cond\", cond);\nvar ContextNode = \
class extends Node {\n  static get type() {\n    return \"ContextNode\";\n  \
}\n  constructor(node, value = {}) {\n    super();\n    this.isContextNode = \
true;\n    this.node = node;\n    this.value = value;\n  }\n  getScope() {\n  \
  return this.node.getScope();\n  }\n  getNodeType(builder) {\n    return \
this.node.getNodeType(builder);\n  }\n  analyze(builder) {\n    \
this.node.build(builder);\n  }\n  setup(builder) {\n    const previousContext \
= builder.getContext();\n    builder.setContext({ ...builder.context, \
...this.value });\n    const node = this.node.build(builder);\n    \
builder.setContext(previousContext);\n    return node;\n  }\n  \
generate(builder, output2) {\n    const previousContext = \
builder.getContext();\n    builder.setContext({ ...builder.context, \
...this.value });\n    const snippet = this.node.build(builder, output2);\n   \
 builder.setContext(previousContext);\n    return snippet;\n  }\n};\nvar \
context = /* @__PURE__ */ nodeProxy(ContextNode);\nvar label = (node, name) \
=> context(node, { label: name });\naddMethodChaining(\"context\", \
context);\naddMethodChaining(\"label\", label);\nvar VarNode = class extends \
Node {\n  static get type() {\n    return \"VarNode\";\n  }\n  \
constructor(node, name = null) {\n    super();\n    this.node = node;\n    \
this.name = name;\n    this.global = true;\n    this.isVarNode = true;\n  }\n \
 getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  \
getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  \
generate(builder) {\n    const { node, name } = this;\n    const nodeVar = \
builder.getVarFromNode(this, name, \
builder.getVectorType(this.getNodeType(builder)));\n    const propertyName = \
builder.getPropertyName(nodeVar);\n    const snippet = node.build(builder, \
nodeVar.type);\n    builder.addLineFlowCode(`${propertyName} = ${snippet}`, \
this);\n    return propertyName;\n  }\n};\nvar createVar = /* @__PURE__ */ \
nodeProxy(VarNode);\naddMethodChaining(\"toVar\", (...params) => \
createVar(...params).append());\nvar temp = (node) => {\n  console.warn('TSL: \
\"temp\" is deprecated. Use \".toVar()\" instead.');\n  return \
createVar(node);\n};\naddMethodChaining(\"temp\", temp);\nvar VaryingNode = \
class extends Node {\n  static get type() {\n    return \"VaryingNode\";\n  \
}\n  constructor(node, name = null) {\n    super();\n    this.node = node;\n  \
  this.name = name;\n    this.isVaryingNode = true;\n  }\n  isGlobal() {\n    \
return true;\n  }\n  getHash(builder) {\n    return this.name || \
super.getHash(builder);\n  }\n  getNodeType(builder) {\n    return \
this.node.getNodeType(builder);\n  }\n  setupVarying(builder) {\n    const \
properties = builder.getNodeProperties(this);\n    let varying2 = \
properties.varying;\n    if (varying2 === void 0) {\n      const name = \
this.name;\n      const type = this.getNodeType(builder);\n      \
properties.varying = varying2 = builder.getVaryingFromNode(this, name, \
type);\n      properties.node = this.node;\n    }\n    \
varying2.needsInterpolation || (varying2.needsInterpolation = \
builder.shaderStage === \"fragment\");\n    return varying2;\n  }\n  \
setup(builder) {\n    this.setupVarying(builder);\n  }\n  analyze(builder) \
{\n    this.setupVarying(builder);\n    return this.node.analyze(builder);\n  \
}\n  generate(builder) {\n    const properties = \
builder.getNodeProperties(this);\n    const varying2 = \
this.setupVarying(builder);\n    if (properties.propertyName === void 0) {\n  \
    const type = this.getNodeType(builder);\n      const propertyName = \
builder.getPropertyName(varying2, NodeShaderStage.VERTEX);\n      \
builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node, type, \
propertyName);\n      properties.propertyName = propertyName;\n    }\n    \
return builder.getPropertyName(varying2);\n  }\n};\nvar varying = /* \
@__PURE__ */ nodeProxy(VaryingNode);\naddMethodChaining(\"varying\", \
varying);\nvar sRGBTransferEOTF = /* @__PURE__ */ Fn(([color2]) => {\n  const \
a2 = color2.mul(0.9478672986).add(0.0521327014).pow(2.4);\n  const b = \
color2.mul(0.0773993808);\n  const factor = color2.lessThanEqual(0.04045);\n  \
const rgbResult = mix(a2, b, factor);\n  return rgbResult;\n}).setLayout({\n  \
name: \"sRGBTransferEOTF\",\n  type: \"vec3\",\n  inputs: [\n    { name: \
\"color\", type: \"vec3\" }\n  ]\n});\nvar sRGBTransferOETF = /* @__PURE__ */ \
Fn(([color2]) => {\n  const a2 = color2.pow(0.41666).mul(1.055).sub(0.055);\n \
 const b = color2.mul(12.92);\n  const factor = \
color2.lessThanEqual(31308e-7);\n  const rgbResult = mix(a2, b, factor);\n  \
return rgbResult;\n}).setLayout({\n  name: \"sRGBTransferOETF\",\n  type: \
\"vec3\",\n  inputs: [\n    { name: \"color\", type: \"vec3\" }\n  \
]\n});\nvar WORKING_COLOR_SPACE = \"WorkingColorSpace\";\nvar \
OUTPUT_COLOR_SPACE = \"OutputColorSpace\";\nvar ColorSpaceNode = class \
extends TempNode {\n  static get type() {\n    return \"ColorSpaceNode\";\n  \
}\n  constructor(colorNode, source, target) {\n    super(\"vec4\");\n    \
this.colorNode = colorNode;\n    this.source = source;\n    this.target = \
target;\n  }\n  resolveColorSpace(builder, colorSpace) {\n    if (colorSpace \
=== WORKING_COLOR_SPACE) {\n      return \
ColorManagement2.workingColorSpace;\n    } else if (colorSpace === \
OUTPUT_COLOR_SPACE) {\n      return builder.context.outputColorSpace || \
builder.renderer.outputColorSpace;\n    }\n    return colorSpace;\n  }\n  \
setup(builder) {\n    const { colorNode } = this;\n    const source = \
this.resolveColorSpace(builder, this.source);\n    const target = \
this.resolveColorSpace(builder, this.target);\n    let outputNode = \
colorNode;\n    if (ColorManagement2.enabled === false || source === target \
|| !source || !target) {\n      return outputNode;\n    }\n    if \
(ColorManagement2.getTransfer(source) === SRGBTransfer2) {\n      outputNode \
= vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);\n    }\n    if \
(ColorManagement2.getPrimaries(source) !== \
ColorManagement2.getPrimaries(target)) {\n      outputNode = vec4(\n        \
mat3(ColorManagement2._getMatrix(new Matrix32(), source, \
target)).mul(outputNode.rgb),\n        outputNode.a\n      );\n    }\n    if \
(ColorManagement2.getTransfer(target) === SRGBTransfer2) {\n      outputNode \
= vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);\n    }\n    return \
outputNode;\n  }\n};\nvar toOutputColorSpace = (node) => nodeObject(new \
ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, \
OUTPUT_COLOR_SPACE));\nvar toWorkingColorSpace = (node) => nodeObject(new \
ColorSpaceNode(nodeObject(node), OUTPUT_COLOR_SPACE, \
WORKING_COLOR_SPACE));\nvar workingToColorSpace = (node, colorSpace) => \
nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, \
colorSpace));\nvar colorSpaceToWorking = (node, colorSpace) => nodeObject(new \
ColorSpaceNode(nodeObject(node), colorSpace, \
WORKING_COLOR_SPACE));\naddMethodChaining(\"toOutputColorSpace\", \
toOutputColorSpace);\naddMethodChaining(\"toWorkingColorSpace\", \
toWorkingColorSpace);\naddMethodChaining(\"workingToColorSpace\", \
workingToColorSpace);\naddMethodChaining(\"colorSpaceToWorking\", \
colorSpaceToWorking);\nvar ReferenceElementNode$1 = class \
ReferenceElementNode extends ArrayElementNode {\n  static get type() {\n    \
return \"ReferenceElementNode\";\n  }\n  constructor(referenceNode, \
indexNode) {\n    super(referenceNode, indexNode);\n    this.referenceNode = \
referenceNode;\n    this.isReferenceElementNode = true;\n  }\n  getNodeType() \
{\n    return this.referenceNode.uniformType;\n  }\n  generate(builder) {\n   \
 const snippet = super.generate(builder);\n    const arrayType = \
this.referenceNode.getNodeType();\n    const elementType = \
this.getNodeType();\n    return builder.format(snippet, arrayType, \
elementType);\n  }\n};\nvar ReferenceBaseNode = class extends Node {\n  \
static get type() {\n    return \"ReferenceBaseNode\";\n  }\n  \
constructor(property2, uniformType, object = null, count = null) {\n    \
super();\n    this.property = property2;\n    this.uniformType = \
uniformType;\n    this.object = object;\n    this.count = count;\n    \
this.properties = property2.split(\".\");\n    this.reference = object;\n    \
this.node = null;\n    this.group = null;\n    this.updateType = \
NodeUpdateType.OBJECT;\n  }\n  setGroup(group) {\n    this.group = group;\n   \
 return this;\n  }\n  element(indexNode) {\n    return nodeObject(new \
ReferenceElementNode$1(this, nodeObject(indexNode)));\n  }\n  \
setNodeType(uniformType) {\n    const node = uniform(null, \
uniformType).getSelf();\n    if (this.group !== null) {\n      \
node.setGroup(this.group);\n    }\n    this.node = node;\n  }\n  \
getNodeType(builder) {\n    if (this.node === null) {\n      \
this.updateReference(builder);\n      this.updateValue();\n    }\n    return \
this.node.getNodeType(builder);\n  }\n  getValueFromReference(object = \
this.reference) {\n    const { properties } = this;\n    let value = \
object[properties[0]];\n    for (let i = 1; i < properties.length; i++) {\n   \
   value = value[properties[i]];\n    }\n    return value;\n  }\n  \
updateReference(state) {\n    this.reference = this.object !== null ? \
this.object : state.object;\n    return this.reference;\n  }\n  setup() {\n   \
 this.updateValue();\n    return this.node;\n  }\n  update() {\n    \
this.updateValue();\n  }\n  updateValue() {\n    if (this.node === null) \
this.setNodeType(this.uniformType);\n    const value = \
this.getValueFromReference();\n    if (Array.isArray(value)) {\n      \
this.node.array = value;\n    } else {\n      this.node.value = value;\n    \
}\n  }\n};\nvar reference$1 = (name, type, object) => nodeObject(new \
ReferenceBaseNode(name, type, object));\nvar RendererReferenceNode = class \
extends ReferenceBaseNode {\n  static get type() {\n    return \
\"RendererReferenceNode\";\n  }\n  constructor(property2, inputType, \
renderer3 = null) {\n    super(property2, inputType, renderer3);\n    \
this.renderer = renderer3;\n    this.setGroup(renderGroup);\n  }\n  \
updateReference(state) {\n    this.reference = this.renderer !== null ? \
this.renderer : state.renderer;\n    return this.reference;\n  }\n};\nvar \
rendererReference = (name, type, renderer3) => nodeObject(new \
RendererReferenceNode(name, type, renderer3));\nvar ToneMappingNode = class \
extends TempNode {\n  static get type() {\n    return \"ToneMappingNode\";\n  \
}\n  constructor(toneMapping2, exposureNode = toneMappingExposure, colorNode \
= null) {\n    super(\"vec3\");\n    this.toneMapping = toneMapping2;\n    \
this.exposureNode = exposureNode;\n    this.colorNode = colorNode;\n  }\n  \
getCacheKey() {\n    return hash$1(super.getCacheKey(), this.toneMapping);\n  \
}\n  setup(builder) {\n    const colorNode = this.colorNode || \
builder.context.color;\n    const toneMapping2 = this.toneMapping;\n    if \
(toneMapping2 === NoToneMapping2) return colorNode;\n    let outputNode = \
null;\n    const toneMappingFn = \
builder.renderer.library.getToneMappingFunction(toneMapping2);\n    if \
(toneMappingFn !== null) {\n      outputNode = \
vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);\n    } \
else {\n      console.error(\"ToneMappingNode: Unsupported Tone Mapping \
configuration.\", toneMapping2);\n      outputNode = colorNode;\n    }\n    \
return outputNode;\n  }\n};\nvar toneMapping = (mapping, exposure, color2) => \
nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), \
nodeObject(color2)));\nvar toneMappingExposure = /* @__PURE__ */ \
rendererReference(\"toneMappingExposure\", \
\"float\");\naddMethodChaining(\"toneMapping\", (color2, mapping, exposure) \
=> toneMapping(mapping, exposure, color2));\nvar BufferAttributeNode = class \
extends InputNode {\n  static get type() {\n    return \
\"BufferAttributeNode\";\n  }\n  constructor(value, bufferType = null, \
bufferStride = 0, bufferOffset = 0) {\n    super(value, bufferType);\n    \
this.isBufferNode = true;\n    this.bufferType = bufferType;\n    \
this.bufferStride = bufferStride;\n    this.bufferOffset = bufferOffset;\n    \
this.usage = StaticDrawUsage2;\n    this.instanced = false;\n    \
this.attribute = null;\n    this.global = true;\n    if (value && \
value.isBufferAttribute === true) {\n      this.attribute = value;\n      \
this.usage = value.usage;\n      this.instanced = \
value.isInstancedBufferAttribute;\n    }\n  }\n  getHash(builder) {\n    if \
(this.bufferStride === 0 && this.bufferOffset === 0) {\n      let bufferData \
= builder.globalCache.getData(this.value);\n      if (bufferData === void 0) \
{\n        bufferData = {\n          node: this\n        };\n        \
builder.globalCache.setData(this.value, bufferData);\n      }\n      return \
bufferData.node.uuid;\n    }\n    return this.uuid;\n  }\n  \
getNodeType(builder) {\n    if (this.bufferType === null) {\n      \
this.bufferType = builder.getTypeFromAttribute(this.attribute);\n    }\n    \
return this.bufferType;\n  }\n  setup(builder) {\n    if (this.attribute !== \
null) return;\n    const type = this.getNodeType(builder);\n    const array = \
this.value;\n    const itemSize = builder.getTypeLength(type);\n    const \
stride = this.bufferStride || itemSize;\n    const offset = \
this.bufferOffset;\n    const buffer2 = array.isInterleavedBuffer === true ? \
array : new InterleavedBuffer(array, stride);\n    const bufferAttribute2 = \
new InterleavedBufferAttribute(buffer2, itemSize, offset);\n    \
buffer2.setUsage(this.usage);\n    this.attribute = bufferAttribute2;\n    \
this.attribute.isInstancedBufferAttribute = this.instanced;\n  }\n  \
generate(builder) {\n    const nodeType = this.getNodeType(builder);\n    \
const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);\n   \
 const propertyName = builder.getPropertyName(nodeAttribute);\n    let \
output2 = null;\n    if (builder.shaderStage === \"vertex\" || \
builder.shaderStage === \"compute\") {\n      this.name = propertyName;\n     \
 output2 = propertyName;\n    } else {\n      const nodeVarying = \
varying(this);\n      output2 = nodeVarying.build(builder, nodeType);\n    \
}\n    return output2;\n  }\n  getInputType() {\n    return \
\"bufferAttribute\";\n  }\n  setUsage(value) {\n    this.usage = value;\n    \
if (this.attribute && this.attribute.isBufferAttribute === true) {\n      \
this.attribute.usage = value;\n    }\n    return this;\n  }\n  \
setInstanced(value) {\n    this.instanced = value;\n    return this;\n  \
}\n};\nvar bufferAttribute = (array, type, stride, offset) => nodeObject(new \
BufferAttributeNode(array, type, stride, offset));\nvar \
dynamicBufferAttribute = (array, type, stride, offset) => \
bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);\nvar \
instancedBufferAttribute = (array, type, stride, offset) => \
bufferAttribute(array, type, stride, offset).setInstanced(true);\nvar \
instancedDynamicBufferAttribute = (array, type, stride, offset) => \
dynamicBufferAttribute(array, type, stride, \
offset).setInstanced(true);\naddMethodChaining(\"toAttribute\", (bufferNode) \
=> bufferAttribute(bufferNode.value));\nvar ComputeNode = class extends Node \
{\n  static get type() {\n    return \"ComputeNode\";\n  }\n  \
constructor(computeNode, count, workgroupSize = [64]) {\n    \
super(\"void\");\n    this.isComputeNode = true;\n    this.computeNode = \
computeNode;\n    this.count = count;\n    this.workgroupSize = \
workgroupSize;\n    this.dispatchCount = 0;\n    this.version = 1;\n    \
this.updateBeforeType = NodeUpdateType.OBJECT;\n    this.onInitFunction = \
null;\n    this.updateDispatchCount();\n  }\n  dispose() {\n    \
this.dispatchEvent({ type: \"dispose\" });\n  }\n  set needsUpdate(value) {\n \
   if (value === true) this.version++;\n  }\n  updateDispatchCount() {\n    \
const { count, workgroupSize } = this;\n    let size = workgroupSize[0];\n    \
for (let i = 1; i < workgroupSize.length; i++)\n      size *= \
workgroupSize[i];\n    this.dispatchCount = Math.ceil(count / size);\n  }\n  \
onInit(callback) {\n    this.onInitFunction = callback;\n    return this;\n  \
}\n  updateBefore({ renderer: renderer3 }) {\n    renderer3.compute(this);\n  \
}\n  generate(builder) {\n    const { shaderStage } = builder;\n    if \
(shaderStage === \"compute\") {\n      const snippet = \
this.computeNode.build(builder, \"void\");\n      if (snippet !== \"\") {\n   \
     builder.addLineFlowCode(snippet, this);\n      }\n    }\n  }\n};\nvar \
compute = (node, count, workgroupSize) => nodeObject(new \
ComputeNode(nodeObject(node), count, \
workgroupSize));\naddMethodChaining(\"compute\", compute);\nvar CacheNode = \
class extends Node {\n  static get type() {\n    return \"CacheNode\";\n  }\n \
 constructor(node, parent = true) {\n    super();\n    this.node = node;\n    \
this.parent = parent;\n    this.isCacheNode = true;\n  }\n  \
getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  \
build(builder, ...params) {\n    const previousCache = builder.getCache();\n  \
  const cache2 = builder.getCacheFromNode(this, this.parent);\n    \
builder.setCache(cache2);\n    const data = this.node.build(builder, \
...params);\n    builder.setCache(previousCache);\n    return data;\n  \
}\n};\nvar cache = (node, ...params) => nodeObject(new \
CacheNode(nodeObject(node), ...params));\naddMethodChaining(\"cache\", \
cache);\nvar BypassNode = class extends Node {\n  static get type() {\n    \
return \"BypassNode\";\n  }\n  constructor(returnNode, callNode) {\n    \
super();\n    this.isBypassNode = true;\n    this.outputNode = returnNode;\n  \
  this.callNode = callNode;\n  }\n  getNodeType(builder) {\n    return \
this.outputNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const \
snippet = this.callNode.build(builder, \"void\");\n    if (snippet !== \"\") \
{\n      builder.addLineFlowCode(snippet, this);\n    }\n    return \
this.outputNode.build(builder);\n  }\n};\nvar bypass = /* @__PURE__ */ \
nodeProxy(BypassNode);\naddMethodChaining(\"bypass\", bypass);\nvar RemapNode \
= class extends Node {\n  static get type() {\n    return \"RemapNode\";\n  \
}\n  constructor(node, inLowNode, inHighNode, outLowNode = float(0), \
outHighNode = float(1)) {\n    super();\n    this.node = node;\n    \
this.inLowNode = inLowNode;\n    this.inHighNode = inHighNode;\n    \
this.outLowNode = outLowNode;\n    this.outHighNode = outHighNode;\n    \
this.doClamp = true;\n  }\n  setup() {\n    const { node, inLowNode, \
inHighNode, outLowNode, outHighNode, doClamp } = this;\n    let t = \
node.sub(inLowNode).div(inHighNode.sub(inLowNode));\n    if (doClamp === \
true) t = t.clamp();\n    return \
t.mul(outHighNode.sub(outLowNode)).add(outLowNode);\n  }\n};\nvar remap = /* \
@__PURE__ */ nodeProxy(RemapNode, null, null, { doClamp: false });\nvar \
remapClamp = /* @__PURE__ */ \
nodeProxy(RemapNode);\naddMethodChaining(\"remap\", \
remap);\naddMethodChaining(\"remapClamp\", remapClamp);\nvar ExpressionNode = \
class extends Node {\n  static get type() {\n    return \"ExpressionNode\";\n \
 }\n  constructor(snippet = \"\", nodeType = \"void\") {\n    \
super(nodeType);\n    this.snippet = snippet;\n  }\n  generate(builder, \
output2) {\n    const type = this.getNodeType(builder);\n    const snippet = \
this.snippet;\n    if (type === \"void\") {\n      \
builder.addLineFlowCode(snippet, this);\n    } else {\n      return \
builder.format(`( ${snippet} )`, type, output2);\n    }\n  }\n};\nvar \
expression = /* @__PURE__ */ nodeProxy(ExpressionNode);\nvar Discard = \
(conditional) => (conditional ? select(conditional, expression(\"discard\")) \
: expression(\"discard\")).append();\naddMethodChaining(\"discard\", \
Discard);\nvar RenderOutputNode = class extends TempNode {\n  static get \
type() {\n    return \"RenderOutputNode\";\n  }\n  constructor(colorNode, \
toneMapping2, outputColorSpace) {\n    super(\"vec4\");\n    this.colorNode = \
colorNode;\n    this.toneMapping = toneMapping2;\n    this.outputColorSpace = \
outputColorSpace;\n    this.isRenderOutput = true;\n  }\n  setup({ context: \
context2 }) {\n    let outputNode = this.colorNode || context2.color;\n    \
const toneMapping2 = (this.toneMapping !== null ? this.toneMapping : \
context2.toneMapping) || NoToneMapping2;\n    const outputColorSpace = \
(this.outputColorSpace !== null ? this.outputColorSpace : \
context2.outputColorSpace) || NoColorSpace2;\n    if (toneMapping2 !== \
NoToneMapping2) {\n      outputNode = outputNode.toneMapping(toneMapping2);\n \
   }\n    if (outputColorSpace !== NoColorSpace2 && outputColorSpace !== \
ColorManagement2.workingColorSpace) {\n      outputNode = \
outputNode.workingToColorSpace(outputColorSpace);\n    }\n    return \
outputNode;\n  }\n};\nvar renderOutput = (color2, toneMapping2 = null, \
outputColorSpace = null) => nodeObject(new \
RenderOutputNode(nodeObject(color2), toneMapping2, \
outputColorSpace));\naddMethodChaining(\"renderOutput\", renderOutput);\nvar \
AttributeNode = class extends Node {\n  static get type() {\n    return \
\"AttributeNode\";\n  }\n  constructor(attributeName, nodeType = null) {\n    \
super(nodeType);\n    this.global = true;\n    this._attributeName = \
attributeName;\n  }\n  getHash(builder) {\n    return \
this.getAttributeName(builder);\n  }\n  getNodeType(builder) {\n    let \
nodeType = this.nodeType;\n    if (nodeType === null) {\n      const \
attributeName = this.getAttributeName(builder);\n      if \
(builder.hasGeometryAttribute(attributeName)) {\n        const attribute2 = \
builder.geometry.getAttribute(attributeName);\n        nodeType = \
builder.getTypeFromAttribute(attribute2);\n      } else {\n        nodeType = \
\"float\";\n      }\n    }\n    return nodeType;\n  }\n  \
setAttributeName(attributeName) {\n    this._attributeName = attributeName;\n \
   return this;\n  }\n  getAttributeName() {\n    return \
this._attributeName;\n  }\n  generate(builder) {\n    const attributeName = \
this.getAttributeName(builder);\n    const nodeType = \
this.getNodeType(builder);\n    const geometryAttribute = \
builder.hasGeometryAttribute(attributeName);\n    if (geometryAttribute === \
true) {\n      const attribute2 = \
builder.geometry.getAttribute(attributeName);\n      const attributeType = \
builder.getTypeFromAttribute(attribute2);\n      const nodeAttribute = \
builder.getAttribute(attributeName, attributeType);\n      if \
(builder.shaderStage === \"vertex\") {\n        return \
builder.format(nodeAttribute.name, attributeType, nodeType);\n      } else \
{\n        const nodeVarying = varying(this);\n        return \
nodeVarying.build(builder, nodeType);\n      }\n    } else {\n      \
console.warn(`AttributeNode: Vertex attribute \"${attributeName}\" not found \
on geometry.`);\n      return builder.generateConst(nodeType);\n    }\n  }\n  \
serialize(data) {\n    super.serialize(data);\n    data.global = \
this.global;\n    data._attributeName = this._attributeName;\n  }\n  \
deserialize(data) {\n    super.deserialize(data);\n    this.global = \
data.global;\n    this._attributeName = data._attributeName;\n  }\n};\nvar \
attribute = (name, nodeType) => nodeObject(new AttributeNode(name, \
nodeType));\nvar uv = (index5) => attribute(\"uv\" + (index5 > 0 ? index5 : \
\"\"), \"vec2\");\nvar TextureSizeNode = class extends Node {\n  static get \
type() {\n    return \"TextureSizeNode\";\n  }\n  constructor(textureNode, \
levelNode = null) {\n    super(\"uvec2\");\n    this.isTextureSizeNode = \
true;\n    this.textureNode = textureNode;\n    this.levelNode = levelNode;\n \
 }\n  generate(builder, output2) {\n    const textureProperty = \
this.textureNode.build(builder, \"property\");\n    const level = \
this.levelNode === null ? \"0\" : this.levelNode.build(builder, \"int\");\n   \
 return builder.format(`${builder.getMethod(\"textureDimensions\")}( \
${textureProperty}, ${level} )`, this.getNodeType(builder), output2);\n  \
}\n};\nvar textureSize = /* @__PURE__ */ nodeProxy(TextureSizeNode);\nvar \
MaxMipLevelNode = class extends UniformNode {\n  static get type() {\n    \
return \"MaxMipLevelNode\";\n  }\n  constructor(textureNode) {\n    \
super(0);\n    this._textureNode = textureNode;\n    this.updateType = \
NodeUpdateType.FRAME;\n  }\n  get textureNode() {\n    return \
this._textureNode;\n  }\n  get texture() {\n    return \
this._textureNode.value;\n  }\n  update() {\n    const texture2 = \
this.texture;\n    const images = texture2.images;\n    const image = images \
&& images.length > 0 ? images[0] && images[0].image || images[0] : \
texture2.image;\n    if (image && image.width !== void 0) {\n      const { \
width, height } = image;\n      this.value = Math.log2(Math.max(width, \
height));\n    }\n  }\n};\nvar maxMipLevel = /* @__PURE__ */ \
nodeProxy(MaxMipLevelNode);\nvar TextureNode = class extends UniformNode {\n  \
static get type() {\n    return \"TextureNode\";\n  }\n  constructor(value, \
uvNode = null, levelNode = null, biasNode = null) {\n    super(value);\n    \
this.isTextureNode = true;\n    this.uvNode = uvNode;\n    this.levelNode = \
levelNode;\n    this.biasNode = biasNode;\n    this.compareNode = null;\n    \
this.depthNode = null;\n    this.gradNode = null;\n    this.sampler = true;\n \
   this.updateMatrix = false;\n    this.updateType = NodeUpdateType.NONE;\n   \
 this.referenceNode = null;\n    this._value = value;\n    \
this._matrixUniform = null;\n    this.setUpdateMatrix(uvNode === null);\n  \
}\n  set value(value) {\n    if (this.referenceNode) {\n      \
this.referenceNode.value = value;\n    } else {\n      this._value = value;\n \
   }\n  }\n  get value() {\n    return this.referenceNode ? \
this.referenceNode.value : this._value;\n  }\n  getUniformHash() {\n    \
return this.value.uuid;\n  }\n  getNodeType() {\n    if \
(this.value.isDepthTexture === true) return \"float\";\n    if \
(this.value.type === UnsignedIntType2) {\n      return \"uvec4\";\n    } else \
if (this.value.type === IntType2) {\n      return \"ivec4\";\n    }\n    \
return \"vec4\";\n  }\n  getInputType() {\n    return \"texture\";\n  }\n  \
getDefaultUV() {\n    return uv(this.value.channel);\n  }\n  \
updateReference() {\n    return this.value;\n  }\n  getTransformedUV(uvNode) \
{\n    if (this._matrixUniform === null) this._matrixUniform = \
uniform(this.value.matrix);\n    return this._matrixUniform.mul(vec3(uvNode, \
1)).xy;\n  }\n  setUpdateMatrix(value) {\n    this.updateMatrix = value;\n    \
this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n    \
return this;\n  }\n  setupUV(builder, uvNode) {\n    const texture2 = \
this.value;\n    if (builder.isFlipY() && (texture2.isRenderTargetTexture === \
true || texture2.isFramebufferTexture === true || texture2.isDepthTexture === \
true)) {\n      if (this.sampler) {\n        uvNode = uvNode.flipY();\n      \
} else {\n        uvNode = uvNode.setY(int(textureSize(this, \
this.levelNode).y).sub(uvNode.y).sub(1));\n      }\n    }\n    return \
uvNode;\n  }\n  setup(builder) {\n    const properties = \
builder.getNodeProperties(this);\n    properties.referenceNode = \
this.referenceNode;\n    let uvNode = this.uvNode;\n    if ((uvNode === null \
|| builder.context.forceUVContext === true) && builder.context.getUV) {\n     \
 uvNode = builder.context.getUV(this);\n    }\n    if (!uvNode) uvNode = \
this.getDefaultUV();\n    if (this.updateMatrix === true) {\n      uvNode = \
this.getTransformedUV(uvNode);\n    }\n    uvNode = this.setupUV(builder, \
uvNode);\n    let levelNode = this.levelNode;\n    if (levelNode === null && \
builder.context.getTextureLevel) {\n      levelNode = \
builder.context.getTextureLevel(this);\n    }\n    properties.uvNode = \
uvNode;\n    properties.levelNode = levelNode;\n    properties.biasNode = \
this.biasNode;\n    properties.compareNode = this.compareNode;\n    \
properties.gradNode = this.gradNode;\n    properties.depthNode = \
this.depthNode;\n  }\n  generateUV(builder, uvNode) {\n    return \
uvNode.build(builder, this.sampler === true ? \"vec2\" : \"ivec2\");\n  }\n  \
generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, \
biasSnippet, depthSnippet, compareSnippet, gradSnippet) {\n    const texture2 \
= this.value;\n    let snippet;\n    if (levelSnippet) {\n      snippet = \
builder.generateTextureLevel(texture2, textureProperty, uvSnippet, \
levelSnippet, depthSnippet);\n    } else if (biasSnippet) {\n      snippet = \
builder.generateTextureBias(texture2, textureProperty, uvSnippet, \
biasSnippet, depthSnippet);\n    } else if (gradSnippet) {\n      snippet = \
builder.generateTextureGrad(texture2, textureProperty, uvSnippet, \
gradSnippet, depthSnippet);\n    } else if (compareSnippet) {\n      snippet \
= builder.generateTextureCompare(texture2, textureProperty, uvSnippet, \
compareSnippet, depthSnippet);\n    } else if (this.sampler === false) {\n    \
  snippet = builder.generateTextureLoad(texture2, textureProperty, uvSnippet, \
depthSnippet);\n    } else {\n      snippet = \
builder.generateTexture(texture2, textureProperty, uvSnippet, \
depthSnippet);\n    }\n    return snippet;\n  }\n  generate(builder, output2) \
{\n    const properties = builder.getNodeProperties(this);\n    const \
texture2 = this.value;\n    if (!texture2 || texture2.isTexture !== true) {\n \
     throw new Error(\"TextureNode: Need a three.js texture.\");\n    }\n    \
const textureProperty = super.generate(builder, \"property\");\n    if \
(output2 === \"sampler\") {\n      return textureProperty + \"_sampler\";\n   \
 } else if (builder.isReference(output2)) {\n      return textureProperty;\n  \
  } else {\n      const nodeData = builder.getDataFromNode(this);\n      let \
propertyName = nodeData.propertyName;\n      if (propertyName === void 0) {\n \
       const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode \
} = properties;\n        const uvSnippet = this.generateUV(builder, \
uvNode);\n        const levelSnippet = levelNode ? levelNode.build(builder, \
\"float\") : null;\n        const biasSnippet = biasNode ? \
biasNode.build(builder, \"float\") : null;\n        const depthSnippet = \
depthNode ? depthNode.build(builder, \"int\") : null;\n        const \
compareSnippet = compareNode ? compareNode.build(builder, \"float\") : \
null;\n        const gradSnippet = gradNode ? [gradNode[0].build(builder, \
\"vec2\"), gradNode[1].build(builder, \"vec2\")] : null;\n        const \
nodeVar = builder.getVarFromNode(this);\n        propertyName = \
builder.getPropertyName(nodeVar);\n        const snippet2 = \
this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, \
biasSnippet, depthSnippet, compareSnippet, gradSnippet);\n        \
builder.addLineFlowCode(`${propertyName} = ${snippet2}`, this);\n        \
nodeData.snippet = snippet2;\n        nodeData.propertyName = propertyName;\n \
     }\n      let snippet = propertyName;\n      const nodeType = \
this.getNodeType(builder);\n      if \
(builder.needsToWorkingColorSpace(texture2)) {\n        snippet = \
colorSpaceToWorking(expression(snippet, nodeType), \
texture2.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      \
return builder.format(snippet, nodeType, output2);\n    }\n  }\n  \
setSampler(value) {\n    this.sampler = value;\n    return this;\n  }\n  \
getSampler() {\n    return this.sampler;\n  }\n  // @TODO: Move to TSL\n  \
uv(uvNode) {\n    const textureNode = this.clone();\n    textureNode.uvNode = \
nodeObject(uvNode);\n    textureNode.referenceNode = this.getSelf();\n    \
return nodeObject(textureNode);\n  }\n  blur(amountNode) {\n    const \
textureNode = this.clone();\n    textureNode.biasNode = \
nodeObject(amountNode).mul(maxMipLevel(textureNode));\n    \
textureNode.referenceNode = this.getSelf();\n    return \
nodeObject(textureNode);\n  }\n  level(levelNode) {\n    const textureNode = \
this.clone();\n    textureNode.levelNode = nodeObject(levelNode);\n    \
textureNode.referenceNode = this.getSelf();\n    return \
nodeObject(textureNode);\n  }\n  size(levelNode) {\n    return \
textureSize(this, levelNode);\n  }\n  bias(biasNode) {\n    const textureNode \
= this.clone();\n    textureNode.biasNode = nodeObject(biasNode);\n    \
textureNode.referenceNode = this.getSelf();\n    return \
nodeObject(textureNode);\n  }\n  compare(compareNode) {\n    const \
textureNode = this.clone();\n    textureNode.compareNode = \
nodeObject(compareNode);\n    textureNode.referenceNode = this.getSelf();\n   \
 return nodeObject(textureNode);\n  }\n  grad(gradNodeX, gradNodeY) {\n    \
const textureNode = this.clone();\n    textureNode.gradNode = \
[nodeObject(gradNodeX), nodeObject(gradNodeY)];\n    \
textureNode.referenceNode = this.getSelf();\n    return \
nodeObject(textureNode);\n  }\n  depth(depthNode) {\n    const textureNode = \
this.clone();\n    textureNode.depthNode = nodeObject(depthNode);\n    \
textureNode.referenceNode = this.getSelf();\n    return \
nodeObject(textureNode);\n  }\n  // --\n  serialize(data) {\n    \
super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n \
   data.sampler = this.sampler;\n    data.updateMatrix = this.updateMatrix;\n \
   data.updateType = this.updateType;\n  }\n  deserialize(data) {\n    \
super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n  \
  this.sampler = data.sampler;\n    this.updateMatrix = data.updateMatrix;\n  \
  this.updateType = data.updateType;\n  }\n  update() {\n    const texture2 = \
this.value;\n    const matrixUniform = this._matrixUniform;\n    if \
(matrixUniform !== null) matrixUniform.value = texture2.matrix;\n    if \
(texture2.matrixAutoUpdate === true) {\n      texture2.updateMatrix();\n    \
}\n  }\n  clone() {\n    const newNode = new this.constructor(this.value, \
this.uvNode, this.levelNode, this.biasNode);\n    newNode.sampler = \
this.sampler;\n    return newNode;\n  }\n};\nvar texture = /* @__PURE__ */ \
nodeProxy(TextureNode);\nvar textureLoad = (...params) => \
texture(...params).setSampler(false);\nvar cameraNear = /* @__PURE__ */ \
uniform(\"float\").label(\"cameraNear\").setGroup(renderGroup).onRenderUpdate\
(({ camera: camera3 }) => camera3.near);\nvar cameraFar = /* @__PURE__ */ \
uniform(\"float\").label(\"cameraFar\").setGroup(renderGroup).onRenderUpdate(\
({ camera: camera3 }) => camera3.far);\nvar cameraProjectionMatrix = /* \
@__PURE__ */ \
uniform(\"mat4\").label(\"cameraProjectionMatrix\").setGroup(renderGroup).onR\
enderUpdate(({ camera: camera3 }) => camera3.projectionMatrix);\nvar \
cameraViewMatrix = /* @__PURE__ */ \
uniform(\"mat4\").label(\"cameraViewMatrix\").setGroup(renderGroup).onRenderU\
pdate(({ camera: camera3 }) => camera3.matrixWorldInverse);\nvar \
cameraPosition = /* @__PURE__ */ uniform(new \
Vector32()).label(\"cameraPosition\").setGroup(renderGroup).onRenderUpdate(({ \
camera: camera3 }, self2) => \
self2.value.setFromMatrixPosition(camera3.matrixWorld));\nvar Object3DNode = \
class _Object3DNode extends Node {\n  static get type() {\n    return \
\"Object3DNode\";\n  }\n  constructor(scope, object3d = null) {\n    \
super();\n    this.scope = scope;\n    this.object3d = object3d;\n    \
this.updateType = NodeUpdateType.OBJECT;\n    this._uniformNode = new \
UniformNode(null);\n  }\n  getNodeType() {\n    const scope = this.scope;\n   \
 if (scope === _Object3DNode.WORLD_MATRIX) {\n      return \"mat4\";\n    } \
else if (scope === _Object3DNode.POSITION || scope === \
_Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === \
_Object3DNode.SCALE) {\n      return \"vec3\";\n    }\n  }\n  update(frame2) \
{\n    const object = this.object3d;\n    const uniformNode = \
this._uniformNode;\n    const scope = this.scope;\n    if (scope === \
_Object3DNode.WORLD_MATRIX) {\n      uniformNode.value = \
object.matrixWorld;\n    } else if (scope === _Object3DNode.POSITION) {\n     \
 uniformNode.value = uniformNode.value || new Vector32();\n      \
uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n    } else if \
(scope === _Object3DNode.SCALE) {\n      uniformNode.value = \
uniformNode.value || new Vector32();\n      \
uniformNode.value.setFromMatrixScale(object.matrixWorld);\n    } else if \
(scope === _Object3DNode.DIRECTION) {\n      uniformNode.value = \
uniformNode.value || new Vector32();\n      \
object.getWorldDirection(uniformNode.value);\n    } else if (scope === \
_Object3DNode.VIEW_POSITION) {\n      const camera3 = frame2.camera;\n      \
uniformNode.value = uniformNode.value || new Vector32();\n      \
uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n      \
uniformNode.value.applyMatrix4(camera3.matrixWorldInverse);\n    }\n  }\n  \
generate(builder) {\n    const scope = this.scope;\n    if (scope === \
_Object3DNode.WORLD_MATRIX) {\n      this._uniformNode.nodeType = \"mat4\";\n \
   } else if (scope === _Object3DNode.POSITION || scope === \
_Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === \
_Object3DNode.SCALE) {\n      this._uniformNode.nodeType = \"vec3\";\n    }\n \
   return this._uniformNode.build(builder);\n  }\n  serialize(data) {\n    \
super.serialize(data);\n    data.scope = this.scope;\n  }\n  \
deserialize(data) {\n    super.deserialize(data);\n    this.scope = \
data.scope;\n  }\n};\nObject3DNode.WORLD_MATRIX = \
\"worldMatrix\";\nObject3DNode.POSITION = \"position\";\nObject3DNode.SCALE = \
\"scale\";\nObject3DNode.VIEW_POSITION = \
\"viewPosition\";\nObject3DNode.DIRECTION = \"direction\";\nvar \
objectDirection = /* @__PURE__ */ nodeProxy(Object3DNode, \
Object3DNode.DIRECTION);\nvar objectWorldMatrix = /* @__PURE__ */ \
nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);\nvar objectPosition = /* \
@__PURE__ */ nodeProxy(Object3DNode, Object3DNode.POSITION);\nvar objectScale \
= /* @__PURE__ */ nodeProxy(Object3DNode, Object3DNode.SCALE);\nvar \
objectViewPosition = /* @__PURE__ */ nodeProxy(Object3DNode, \
Object3DNode.VIEW_POSITION);\nvar ModelNode = class extends Object3DNode {\n  \
static get type() {\n    return \"ModelNode\";\n  }\n  constructor(scope) {\n \
   super(scope);\n  }\n  update(frame2) {\n    this.object3d = \
frame2.object;\n    super.update(frame2);\n  }\n};\nvar modelDirection = /* \
@__PURE__ */ nodeImmutable(ModelNode, ModelNode.DIRECTION);\nvar \
modelWorldMatrix = /* @__PURE__ */ nodeImmutable(ModelNode, \
ModelNode.WORLD_MATRIX);\nvar modelPosition = /* @__PURE__ */ \
nodeImmutable(ModelNode, ModelNode.POSITION);\nvar modelScale = /* @__PURE__ \
*/ nodeImmutable(ModelNode, ModelNode.SCALE);\nvar modelViewPosition = /* \
@__PURE__ */ nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);\nvar \
modelNormalMatrix = /* @__PURE__ */ uniform(new Matrix32()).onObjectUpdate(({ \
object }, self2) => self2.value.getNormalMatrix(object.matrixWorld));\nvar \
modelViewMatrix = /* @__PURE__ */ \
cameraViewMatrix.mul(modelWorldMatrix).toVar(\"modelViewMatrix\");\nvar \
positionGeometry = /* @__PURE__ */ attribute(\"position\", \"vec3\");\nvar \
positionLocal = /* @__PURE__ */ \
positionGeometry.varying(\"positionLocal\");\nvar positionPrevious = /* \
@__PURE__ */ positionGeometry.varying(\"positionPrevious\");\nvar \
positionWorld = /* @__PURE__ */ \
modelWorldMatrix.mul(positionLocal).xyz.varying(\"v_positionWorld\");\nvar \
positionWorldDirection = /* @__PURE__ */ \
positionLocal.transformDirection(modelWorldMatrix).varying(\"v_positionWorldD\
irection\").normalize().toVar(\"positionWorldDirection\");\nvar positionView \
= /* @__PURE__ */ \
modelViewMatrix.mul(positionLocal).xyz.varying(\"v_positionView\");\nvar \
positionViewDirection = /* @__PURE__ */ \
positionView.negate().varying(\"v_positionViewDirection\").normalize().toVar(\
\"positionViewDirection\");\nvar FrontFacingNode = class extends Node {\n  \
static get type() {\n    return \"FrontFacingNode\";\n  }\n  constructor() \
{\n    super(\"bool\");\n    this.isFrontFacingNode = true;\n  }\n  \
generate(builder) {\n    const { renderer: renderer3, material } = builder;\n \
   if (renderer3.coordinateSystem === WebGLCoordinateSystem2) {\n      if \
(material.side === BackSide2) {\n        return \"false\";\n      }\n    }\n  \
  return builder.getFrontFacing();\n  }\n};\nvar frontFacing = /* @__PURE__ \
*/ nodeImmutable(FrontFacingNode);\nvar faceDirection = /* @__PURE__ */ \
float(frontFacing).mul(2).sub(1);\nvar normalGeometry = /* @__PURE__ */ \
attribute(\"normal\", \"vec3\");\nvar normalLocal = /* @__PURE__ */ \
Fn((builder) => {\n  if (builder.geometry.hasAttribute(\"normal\") === false) \
{\n    console.warn('TSL.NormalNode: Vertex attribute \"normal\" not found on \
geometry.');\n    return vec3(0, 1, 0);\n  }\n  return normalGeometry;\n}, \
\"vec3\").once()().toVar(\"normalLocal\");\nvar normalFlat = /* @__PURE__ */ \
positionView.dFdx().cross(positionView.dFdy()).normalize().toVar(\"normalFlat\
\");\nvar normalView = /* @__PURE__ */ Fn((builder) => {\n  let node;\n  if \
(builder.material.flatShading === true) {\n    node = normalFlat;\n  } else \
{\n    node = varying(transformNormalToView(normalLocal), \
\"v_normalView\").normalize();\n  }\n  return node;\n}, \
\"vec3\").once()().toVar(\"normalView\");\nvar normalWorld = /* @__PURE__ */ \
varying(normalView.transformDirection(cameraViewMatrix), \
\"v_normalWorld\").normalize().toVar(\"normalWorld\");\nvar \
transformedNormalView = /* @__PURE__ */ Fn((builder) => {\n  return \
builder.context.setupNormal();\n}, \
\"vec3\").once()().mul(faceDirection).toVar(\"transformedNormalView\");\nvar \
transformedNormalWorld = /* @__PURE__ */ \
transformedNormalView.transformDirection(cameraViewMatrix).toVar(\"transforme\
dNormalWorld\");\nvar transformedClearcoatNormalView = /* @__PURE__ */ \
Fn((builder) => {\n  return builder.context.setupClearcoatNormal();\n}, \
\"vec3\").once()().mul(faceDirection).toVar(\"transformedClearcoatNormalView\
\");\nvar transformNormal = /* @__PURE__ */ Fn(([normal2, matrix = \
modelWorldMatrix]) => {\n  const m2 = mat3(matrix);\n  const \
transformedNormal = normal2.div(vec3(m2[0].dot(m2[0]), m2[1].dot(m2[1]), \
m2[2].dot(m2[2])));\n  return m2.mul(transformedNormal).xyz;\n});\nvar \
transformNormalToView = /* @__PURE__ */ Fn(([normal2], builder) => {\n  const \
modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;\n  if \
(modelNormalViewMatrix !== null) {\n    return \
modelNormalViewMatrix.transformDirection(normal2);\n  }\n  const \
transformedNormal = modelNormalMatrix.mul(normal2);\n  return \
cameraViewMatrix.transformDirection(transformedNormal);\n});\nvar \
materialRefractionRatio = /* @__PURE__ */ uniform(0).onReference(({ material \
}) => material).onRenderUpdate(({ material }) => \
material.refractionRatio);\nvar reflectView = /* @__PURE__ */ \
positionViewDirection.negate().reflect(transformedNormalView);\nvar \
refractView = /* @__PURE__ */ \
positionViewDirection.negate().refract(transformedNormalView, \
materialRefractionRatio);\nvar reflectVector = /* @__PURE__ */ \
reflectView.transformDirection(cameraViewMatrix).toVar(\"reflectVector\");\nv\
ar refractVector = /* @__PURE__ */ \
refractView.transformDirection(cameraViewMatrix).toVar(\"reflectVector\");\nv\
ar CubeTextureNode = class extends TextureNode {\n  static get type() {\n    \
return \"CubeTextureNode\";\n  }\n  constructor(value, uvNode = null, \
levelNode = null, biasNode = null) {\n    super(value, uvNode, levelNode, \
biasNode);\n    this.isCubeTextureNode = true;\n  }\n  getInputType() {\n    \
return \"cubeTexture\";\n  }\n  getDefaultUV() {\n    const texture2 = \
this.value;\n    if (texture2.mapping === CubeReflectionMapping2) {\n      \
return reflectVector;\n    } else if (texture2.mapping === \
CubeRefractionMapping2) {\n      return refractVector;\n    } else {\n      \
console.error('THREE.CubeTextureNode: Mapping \"%s\" not supported.', \
texture2.mapping);\n      return vec3(0, 0, 0);\n    }\n  }\n  \
setUpdateMatrix() {\n  }\n  // Ignore .updateMatrix for CubeTextureNode\n  \
setupUV(builder, uvNode) {\n    const texture2 = this.value;\n    if \
(builder.renderer.coordinateSystem === WebGPUCoordinateSystem2 || \
!texture2.isRenderTargetTexture) {\n      return vec3(uvNode.x.negate(), \
uvNode.yz);\n    } else {\n      return uvNode;\n    }\n  }\n  \
generateUV(builder, cubeUV) {\n    return cubeUV.build(builder, \"vec3\");\n  \
}\n};\nvar cubeTexture = /* @__PURE__ */ nodeProxy(CubeTextureNode);\nvar \
BufferNode = class extends UniformNode {\n  static get type() {\n    return \
\"BufferNode\";\n  }\n  constructor(value, bufferType, bufferCount = 0) {\n   \
 super(value, bufferType);\n    this.isBufferNode = true;\n    \
this.bufferType = bufferType;\n    this.bufferCount = bufferCount;\n  }\n  \
getElementType(builder) {\n    return this.getNodeType(builder);\n  }\n  \
getInputType() {\n    return \"buffer\";\n  }\n};\nvar buffer = (value, type, \
count) => nodeObject(new BufferNode(value, type, count));\nvar \
UniformArrayElementNode = class extends ArrayElementNode {\n  static get \
type() {\n    return \"UniformArrayElementNode\";\n  }\n  \
constructor(arrayBuffer, indexNode) {\n    super(arrayBuffer, indexNode);\n   \
 this.isArrayBufferElementNode = true;\n  }\n  generate(builder) {\n    const \
snippet = super.generate(builder);\n    const type = this.getNodeType();\n    \
return builder.format(snippet, \"vec4\", type);\n  }\n};\nvar \
UniformArrayNode = class extends BufferNode {\n  static get type() {\n    \
return \"UniformArrayNode\";\n  }\n  constructor(value, elementType = null) \
{\n    super(null, \"vec4\");\n    this.array = value;\n    this.elementType \
= elementType;\n    this._elementType = null;\n    this._elementLength = 0;\n \
   this.updateType = NodeUpdateType.RENDER;\n    this.isArrayBufferNode = \
true;\n  }\n  getElementType() {\n    return this.elementType || \
this._elementType;\n  }\n  getElementLength() {\n    return \
this._elementLength;\n  }\n  update() {\n    const { array, value } = this;\n \
   const elementLength = this.getElementLength();\n    const elementType = \
this.getElementType();\n    if (elementLength === 1) {\n      for (let i = 0; \
i < array.length; i++) {\n        const index5 = i * 4;\n        \
value[index5] = array[i];\n      }\n    } else if (elementType === \"color\") \
{\n      for (let i = 0; i < array.length; i++) {\n        const index5 = i * \
4;\n        const vector = array[i];\n        value[index5] = vector.r;\n     \
   value[index5 + 1] = vector.g;\n        value[index5 + 2] = vector.b || \
0;\n      }\n    } else {\n      for (let i = 0; i < array.length; i++) {\n   \
     const index5 = i * 4;\n        const vector = array[i];\n        \
value[index5] = vector.x;\n        value[index5 + 1] = vector.y;\n        \
value[index5 + 2] = vector.z || 0;\n        value[index5 + 3] = vector.w || \
0;\n      }\n    }\n  }\n  setup(builder) {\n    const length2 = \
this.array.length;\n    this._elementType = this.elementType === null ? \
getValueType(this.array[0]) : this.elementType;\n    this._elementLength = \
builder.getTypeLength(this._elementType);\n    let arrayType = \
Float32Array;\n    if (this._elementType.charAt(0) === \"i\") arrayType = \
Int32Array;\n    else if (this._elementType.charAt(0) === \"u\") arrayType = \
Uint32Array;\n    this.value = new arrayType(length2 * 4);\n    \
this.bufferCount = length2;\n    this.bufferType = \
builder.changeComponentType(\"vec4\", \
builder.getComponentType(this._elementType));\n    return \
super.setup(builder);\n  }\n  element(indexNode) {\n    return nodeObject(new \
UniformArrayElementNode(this, nodeObject(indexNode)));\n  }\n};\nvar \
uniformArray = (values, nodeType) => nodeObject(new UniformArrayNode(values, \
nodeType));\nvar ReferenceElementNode2 = class extends ArrayElementNode {\n  \
static get type() {\n    return \"ReferenceElementNode\";\n  }\n  \
constructor(referenceNode, indexNode) {\n    super(referenceNode, \
indexNode);\n    this.referenceNode = referenceNode;\n    \
this.isReferenceElementNode = true;\n  }\n  getNodeType() {\n    return \
this.referenceNode.uniformType;\n  }\n  generate(builder) {\n    const \
snippet = super.generate(builder);\n    const arrayType = \
this.referenceNode.getNodeType();\n    const elementType = \
this.getNodeType();\n    return builder.format(snippet, arrayType, \
elementType);\n  }\n};\nvar ReferenceNode = class extends Node {\n  static \
get type() {\n    return \"ReferenceNode\";\n  }\n  constructor(property2, \
uniformType, object = null, count = null) {\n    super();\n    this.property \
= property2;\n    this.uniformType = uniformType;\n    this.object = \
object;\n    this.count = count;\n    this.properties = \
property2.split(\".\");\n    this.reference = object;\n    this.node = \
null;\n    this.group = null;\n    this.name = null;\n    this.updateType = \
NodeUpdateType.OBJECT;\n  }\n  element(indexNode) {\n    return \
nodeObject(new ReferenceElementNode2(this, nodeObject(indexNode)));\n  }\n  \
setGroup(group) {\n    this.group = group;\n    return this;\n  }\n  \
label(name) {\n    this.name = name;\n    return this;\n  }\n  \
setNodeType(uniformType) {\n    let node = null;\n    if (this.count !== \
null) {\n      node = buffer(null, uniformType, this.count);\n    } else if \
(Array.isArray(this.getValueFromReference())) {\n      node = \
uniformArray(null, uniformType);\n    } else if (uniformType === \"texture\") \
{\n      node = texture(null);\n    } else if (uniformType === \
\"cubeTexture\") {\n      node = cubeTexture(null);\n    } else {\n      node \
= uniform(null, uniformType);\n    }\n    if (this.group !== null) {\n      \
node.setGroup(this.group);\n    }\n    if (this.name !== null) \
node.label(this.name);\n    this.node = node.getSelf();\n  }\n  \
getNodeType(builder) {\n    if (this.node === null) {\n      \
this.updateReference(builder);\n      this.updateValue();\n    }\n    return \
this.node.getNodeType(builder);\n  }\n  getValueFromReference(object = \
this.reference) {\n    const { properties } = this;\n    let value = \
object[properties[0]];\n    for (let i = 1; i < properties.length; i++) {\n   \
   value = value[properties[i]];\n    }\n    return value;\n  }\n  \
updateReference(state) {\n    this.reference = this.object !== null ? \
this.object : state.object;\n    return this.reference;\n  }\n  setup() {\n   \
 this.updateValue();\n    return this.node;\n  }\n  update() {\n    \
this.updateValue();\n  }\n  updateValue() {\n    if (this.node === null) \
this.setNodeType(this.uniformType);\n    const value = \
this.getValueFromReference();\n    if (Array.isArray(value)) {\n      \
this.node.array = value;\n    } else {\n      this.node.value = value;\n    \
}\n  }\n};\nvar reference = (name, type, object) => nodeObject(new \
ReferenceNode(name, type, object));\nvar referenceBuffer = (name, type, \
count, object) => nodeObject(new ReferenceNode(name, type, object, \
count));\nvar MaterialReferenceNode = class extends ReferenceNode {\n  static \
get type() {\n    return \"MaterialReferenceNode\";\n  }\n  \
constructor(property2, inputType, material = null) {\n    super(property2, \
inputType, material);\n    this.material = material;\n    \
this.isMaterialReferenceNode = true;\n  }\n  /*setNodeType( node ) {\n  \n  \
\t\tsuper.setNodeType( node );\n  \n  \t\tthis.node.groupNode = \
renderGroup;\n  \n  \t}*/\n  updateReference(state) {\n    this.reference = \
this.material !== null ? this.material : state.material;\n    return \
this.reference;\n  }\n};\nvar materialReference = (name, type, material) => \
nodeObject(new MaterialReferenceNode(name, type, material));\nvar \
tangentGeometry = /* @__PURE__ */ Fn((builder) => {\n  if \
(builder.geometry.hasAttribute(\"tangent\") === false) {\n    \
builder.geometry.computeTangents();\n  }\n  return attribute(\"tangent\", \
\"vec4\");\n})();\nvar tangentLocal = /* @__PURE__ */ \
tangentGeometry.xyz.toVar(\"tangentLocal\");\nvar tangentView = /* @__PURE__ \
*/ modelViewMatrix.mul(vec4(tangentLocal, \
0)).xyz.varying(\"v_tangentView\").normalize().toVar(\"tangentView\");\nvar \
getBitangent = (crossNormalTangent) => \
crossNormalTangent.mul(tangentGeometry.w).xyz;\nvar bitangentView = /* \
@__PURE__ */ varying(getBitangent(normalView.cross(tangentView)), \
\"v_bitangentView\").normalize().toVar(\"bitangentView\");\nvar TBNViewMatrix \
= /* @__PURE__ */ mat3(tangentView, bitangentView, normalView);\nvar \
transformedBentNormalView = /* @__PURE__ */ (() => {\n  let bentNormal = \
anisotropyB.cross(positionViewDirection);\n  bentNormal = \
bentNormal.cross(anisotropyB).normalize();\n  bentNormal = mix(bentNormal, \
transformedNormalView, \
anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();\n \
 return bentNormal;\n})();\nvar perturbNormal2Arb = /* @__PURE__ */ \
Fn((inputs) => {\n  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;\n  \
const q0 = eye_pos.dFdx();\n  const q1 = eye_pos.dFdy();\n  const st0 = \
uv2.dFdx();\n  const st1 = uv2.dFdy();\n  const N = surf_norm;\n  const \
q1perp = q1.cross(N);\n  const q0perp = N.cross(q0);\n  const T = \
q1perp.mul(st0.x).add(q0perp.mul(st1.x));\n  const B = \
q1perp.mul(st0.y).add(q0perp.mul(st1.y));\n  const det = \
T.dot(T).max(B.dot(B));\n  const scale = \
faceDirection.mul(det.inverseSqrt());\n  return add4(T.mul(mapN.x, scale), \
B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();\n});\nvar NormalMapNode = \
class extends TempNode {\n  static get type() {\n    return \
\"NormalMapNode\";\n  }\n  constructor(node, scaleNode = null) {\n    \
super(\"vec3\");\n    this.node = node;\n    this.scaleNode = scaleNode;\n    \
this.normalMapType = TangentSpaceNormalMap2;\n  }\n  setup(builder) {\n    \
const { normalMapType, scaleNode } = this;\n    let normalMap2 = \
this.node.mul(2).sub(1);\n    if (scaleNode !== null) {\n      normalMap2 = \
vec3(normalMap2.xy.mul(scaleNode), normalMap2.z);\n    }\n    let outputNode \
= null;\n    if (normalMapType === ObjectSpaceNormalMap2) {\n      outputNode \
= transformNormalToView(normalMap2);\n    } else if (normalMapType === \
TangentSpaceNormalMap2) {\n      const tangent = \
builder.hasGeometryAttribute(\"tangent\");\n      if (tangent === true) {\n   \
     outputNode = TBNViewMatrix.mul(normalMap2).normalize();\n      } else \
{\n        outputNode = perturbNormal2Arb({\n          eye_pos: \
positionView,\n          surf_norm: normalView,\n          mapN: \
normalMap2,\n          uv: uv()\n        });\n      }\n    }\n    return \
outputNode;\n  }\n};\nvar normalMap = /* @__PURE__ */ \
nodeProxy(NormalMapNode);\nvar dHdxy_fwd = Fn(({ textureNode, bumpScale }) => \
{\n  const sampleTexture = (callback) => textureNode.cache().context({ getUV: \
(texNode) => callback(texNode.uvNode || uv()), forceUVContext: true });\n  \
const Hll = float(sampleTexture((uvNode) => uvNode));\n  return vec2(\n    \
float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll),\n    \
float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)\n  \
).mul(bumpScale);\n});\nvar perturbNormalArb = Fn((inputs) => {\n  const { \
surf_pos, surf_norm, dHdxy } = inputs;\n  const vSigmaX = \
surf_pos.dFdx().normalize();\n  const vSigmaY = \
surf_pos.dFdy().normalize();\n  const vN = surf_norm;\n  const R1 = \
vSigmaY.cross(vN);\n  const R2 = vN.cross(vSigmaX);\n  const fDet = \
vSigmaX.dot(R1).mul(faceDirection);\n  const vGrad = \
fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));\n  return \
fDet.abs().mul(surf_norm).sub(vGrad).normalize();\n});\nvar BumpMapNode = \
class extends TempNode {\n  static get type() {\n    return \
\"BumpMapNode\";\n  }\n  constructor(textureNode, scaleNode = null) {\n    \
super(\"vec3\");\n    this.textureNode = textureNode;\n    this.scaleNode = \
scaleNode;\n  }\n  setup() {\n    const bumpScale = this.scaleNode !== null ? \
this.scaleNode : 1;\n    const dHdxy = dHdxy_fwd({ textureNode: \
this.textureNode, bumpScale });\n    return perturbNormalArb({\n      \
surf_pos: positionView,\n      surf_norm: normalView,\n      dHdxy\n    });\n \
 }\n};\nvar bumpMap = /* @__PURE__ */ nodeProxy(BumpMapNode);\nvar \
_propertyCache = /* @__PURE__ */ new Map();\nvar MaterialNode = class \
_MaterialNode extends Node {\n  static get type() {\n    return \
\"MaterialNode\";\n  }\n  constructor(scope) {\n    super();\n    this.scope \
= scope;\n  }\n  getCache(property2, type) {\n    let node = \
_propertyCache.get(property2);\n    if (node === void 0) {\n      node = \
materialReference(property2, type);\n      _propertyCache.set(property2, \
node);\n    }\n    return node;\n  }\n  getFloat(property2) {\n    return \
this.getCache(property2, \"float\");\n  }\n  getColor(property2) {\n    \
return this.getCache(property2, \"color\");\n  }\n  getTexture(property2) {\n \
   return this.getCache(property2 === \"map\" ? \"map\" : property2 + \
\"Map\", \"texture\");\n  }\n  setup(builder) {\n    const material = \
builder.context.material;\n    const scope = this.scope;\n    let node = \
null;\n    if (scope === _MaterialNode.COLOR) {\n      const colorNode = \
material.color !== void 0 ? this.getColor(scope) : vec3();\n      if \
(material.map && material.map.isTexture === true) {\n        node = \
colorNode.mul(this.getTexture(\"map\"));\n      } else {\n        node = \
colorNode;\n      }\n    } else if (scope === _MaterialNode.OPACITY) {\n      \
const opacityNode = this.getFloat(scope);\n      if (material.alphaMap && \
material.alphaMap.isTexture === true) {\n        node = \
opacityNode.mul(this.getTexture(\"alpha\"));\n      } else {\n        node = \
opacityNode;\n      }\n    } else if (scope === \
_MaterialNode.SPECULAR_STRENGTH) {\n      if (material.specularMap && \
material.specularMap.isTexture === true) {\n        node = \
this.getTexture(\"specular\").r;\n      } else {\n        node = float(1);\n  \
    }\n    } else if (scope === _MaterialNode.SPECULAR_INTENSITY) {\n      \
const specularIntensity = this.getFloat(scope);\n      if \
(material.specularMap) {\n        node = \
specularIntensity.mul(this.getTexture(scope).a);\n      } else {\n        \
node = specularIntensity;\n      }\n    } else if (scope === \
_MaterialNode.SPECULAR_COLOR) {\n      const specularColorNode = \
this.getColor(scope);\n      if (material.specularColorMap && \
material.specularColorMap.isTexture === true) {\n        node = \
specularColorNode.mul(this.getTexture(scope).rgb);\n      } else {\n        \
node = specularColorNode;\n      }\n    } else if (scope === \
_MaterialNode.ROUGHNESS) {\n      const roughnessNode = \
this.getFloat(scope);\n      if (material.roughnessMap && \
material.roughnessMap.isTexture === true) {\n        node = \
roughnessNode.mul(this.getTexture(scope).g);\n      } else {\n        node = \
roughnessNode;\n      }\n    } else if (scope === _MaterialNode.METALNESS) \
{\n      const metalnessNode = this.getFloat(scope);\n      if \
(material.metalnessMap && material.metalnessMap.isTexture === true) {\n       \
 node = metalnessNode.mul(this.getTexture(scope).b);\n      } else {\n        \
node = metalnessNode;\n      }\n    } else if (scope === \
_MaterialNode.EMISSIVE) {\n      const emissiveIntensityNode = \
this.getFloat(\"emissiveIntensity\");\n      const emissiveNode = \
this.getColor(scope).mul(emissiveIntensityNode);\n      if \
(material.emissiveMap && material.emissiveMap.isTexture === true) {\n        \
node = emissiveNode.mul(this.getTexture(scope));\n      } else {\n        \
node = emissiveNode;\n      }\n    } else if (scope === _MaterialNode.NORMAL) \
{\n      if (material.normalMap) {\n        node = \
normalMap(this.getTexture(\"normal\"), this.getCache(\"normalScale\", \
\"vec2\"));\n        node.normalMapType = material.normalMapType;\n      } \
else if (material.bumpMap) {\n        node = \
bumpMap(this.getTexture(\"bump\").r, this.getFloat(\"bumpScale\"));\n      } \
else {\n        node = normalView;\n      }\n    } else if (scope === \
_MaterialNode.CLEARCOAT) {\n      const clearcoatNode = \
this.getFloat(scope);\n      if (material.clearcoatMap && \
material.clearcoatMap.isTexture === true) {\n        node = \
clearcoatNode.mul(this.getTexture(scope).r);\n      } else {\n        node = \
clearcoatNode;\n      }\n    } else if (scope === \
_MaterialNode.CLEARCOAT_ROUGHNESS) {\n      const clearcoatRoughnessNode = \
this.getFloat(scope);\n      if (material.clearcoatRoughnessMap && \
material.clearcoatRoughnessMap.isTexture === true) {\n        node = \
clearcoatRoughnessNode.mul(this.getTexture(scope).r);\n      } else {\n       \
 node = clearcoatRoughnessNode;\n      }\n    } else if (scope === \
_MaterialNode.CLEARCOAT_NORMAL) {\n      if (material.clearcoatNormalMap) {\n \
       node = normalMap(this.getTexture(scope), this.getCache(scope + \
\"Scale\", \"vec2\"));\n      } else {\n        node = normalView;\n      }\n \
   } else if (scope === _MaterialNode.SHEEN) {\n      const sheenNode = \
this.getColor(\"sheenColor\").mul(this.getFloat(\"sheen\"));\n      if \
(material.sheenColorMap && material.sheenColorMap.isTexture === true) {\n     \
   node = sheenNode.mul(this.getTexture(\"sheenColor\").rgb);\n      } else \
{\n        node = sheenNode;\n      }\n    } else if (scope === \
_MaterialNode.SHEEN_ROUGHNESS) {\n      const sheenRoughnessNode = \
this.getFloat(scope);\n      if (material.sheenRoughnessMap && \
material.sheenRoughnessMap.isTexture === true) {\n        node = \
sheenRoughnessNode.mul(this.getTexture(scope).a);\n      } else {\n        \
node = sheenRoughnessNode;\n      }\n      node = node.clamp(0.07, 1);\n    } \
else if (scope === _MaterialNode.ANISOTROPY) {\n      if \
(material.anisotropyMap && material.anisotropyMap.isTexture === true) {\n     \
   const anisotropyPolar = this.getTexture(scope);\n        const \
anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, \
materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);\n        \
node = \
anisotropyMat.mul(anisotropyPolar.rg.mul(2).sub(vec2(1)).normalize().mul(anis\
otropyPolar.b));\n      } else {\n        node = materialAnisotropyVector;\n  \
    }\n    } else if (scope === _MaterialNode.IRIDESCENCE_THICKNESS) {\n      \
const iridescenceThicknessMaximum = reference(\"1\", \"float\", \
material.iridescenceThicknessRange);\n      if \
(material.iridescenceThicknessMap) {\n        const \
iridescenceThicknessMinimum = reference(\"0\", \"float\", \
material.iridescenceThicknessRange);\n        node = \
iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getText\
ure(scope).g).add(iridescenceThicknessMinimum);\n      } else {\n        node \
= iridescenceThicknessMaximum;\n      }\n    } else if (scope === \
_MaterialNode.TRANSMISSION) {\n      const transmissionNode = \
this.getFloat(scope);\n      if (material.transmissionMap) {\n        node = \
transmissionNode.mul(this.getTexture(scope).r);\n      } else {\n        node \
= transmissionNode;\n      }\n    } else if (scope === \
_MaterialNode.THICKNESS) {\n      const thicknessNode = \
this.getFloat(scope);\n      if (material.thicknessMap) {\n        node = \
thicknessNode.mul(this.getTexture(scope).g);\n      } else {\n        node = \
thicknessNode;\n      }\n    } else if (scope === _MaterialNode.IOR) {\n      \
node = this.getFloat(scope);\n    } else if (scope === \
_MaterialNode.LIGHT_MAP) {\n      node = \
this.getTexture(scope).rgb.mul(this.getFloat(\"lightMapIntensity\"));\n    } \
else if (scope === _MaterialNode.AO_MAP) {\n      node = \
this.getTexture(scope).r.sub(1).mul(this.getFloat(\"aoMapIntensity\")).add(1)\
;\n    } else {\n      const outputType = this.getNodeType(builder);\n      \
node = this.getCache(scope, outputType);\n    }\n    return node;\n  \
}\n};\nMaterialNode.ALPHA_TEST = \"alphaTest\";\nMaterialNode.COLOR = \
\"color\";\nMaterialNode.OPACITY = \"opacity\";\nMaterialNode.SHININESS = \
\"shininess\";\nMaterialNode.SPECULAR = \
\"specular\";\nMaterialNode.SPECULAR_STRENGTH = \
\"specularStrength\";\nMaterialNode.SPECULAR_INTENSITY = \
\"specularIntensity\";\nMaterialNode.SPECULAR_COLOR = \
\"specularColor\";\nMaterialNode.REFLECTIVITY = \
\"reflectivity\";\nMaterialNode.ROUGHNESS = \
\"roughness\";\nMaterialNode.METALNESS = \"metalness\";\nMaterialNode.NORMAL \
= \"normal\";\nMaterialNode.CLEARCOAT = \
\"clearcoat\";\nMaterialNode.CLEARCOAT_ROUGHNESS = \
\"clearcoatRoughness\";\nMaterialNode.CLEARCOAT_NORMAL = \
\"clearcoatNormal\";\nMaterialNode.EMISSIVE = \
\"emissive\";\nMaterialNode.ROTATION = \"rotation\";\nMaterialNode.SHEEN = \
\"sheen\";\nMaterialNode.SHEEN_ROUGHNESS = \
\"sheenRoughness\";\nMaterialNode.ANISOTROPY = \
\"anisotropy\";\nMaterialNode.IRIDESCENCE = \
\"iridescence\";\nMaterialNode.IRIDESCENCE_IOR = \
\"iridescenceIOR\";\nMaterialNode.IRIDESCENCE_THICKNESS = \
\"iridescenceThickness\";\nMaterialNode.IOR = \
\"ior\";\nMaterialNode.TRANSMISSION = \
\"transmission\";\nMaterialNode.THICKNESS = \
\"thickness\";\nMaterialNode.ATTENUATION_DISTANCE = \
\"attenuationDistance\";\nMaterialNode.ATTENUATION_COLOR = \
\"attenuationColor\";\nMaterialNode.LINE_SCALE = \
\"scale\";\nMaterialNode.LINE_DASH_SIZE = \
\"dashSize\";\nMaterialNode.LINE_GAP_SIZE = \
\"gapSize\";\nMaterialNode.LINE_WIDTH = \
\"linewidth\";\nMaterialNode.LINE_DASH_OFFSET = \
\"dashOffset\";\nMaterialNode.POINT_WIDTH = \
\"pointWidth\";\nMaterialNode.DISPERSION = \
\"dispersion\";\nMaterialNode.LIGHT_MAP = \"light\";\nMaterialNode.AO_MAP = \
\"ao\";\nvar materialAlphaTest = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.ALPHA_TEST);\nvar materialColor = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.COLOR);\nvar materialShininess = /* \
@__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.SHININESS);\nvar \
materialEmissive = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.EMISSIVE);\nvar materialOpacity = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.OPACITY);\nvar materialSpecular = /* \
@__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.SPECULAR);\nvar \
materialSpecularIntensity = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.SPECULAR_INTENSITY);\nvar materialSpecularColor = /* @__PURE__ \
*/ nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);\nvar \
materialSpecularStrength = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.SPECULAR_STRENGTH);\nvar materialReflectivity = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);\nvar \
materialRoughness = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.ROUGHNESS);\nvar materialMetalness = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.METALNESS);\nvar materialNormal = /* \
@__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.NORMAL).context({ \
getUV: null });\nvar materialClearcoat = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);\nvar \
materialClearcoatRoughness = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.CLEARCOAT_ROUGHNESS);\nvar materialClearcoatNormal = /* \
@__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.CLEARCOAT_NORMAL).context({ getUV: null });\nvar \
materialRotation = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.ROTATION);\nvar materialSheen = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.SHEEN);\nvar materialSheenRoughness \
= /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.SHEEN_ROUGHNESS);\nvar materialAnisotropy = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);\nvar \
materialIridescence = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.IRIDESCENCE);\nvar materialIridescenceIOR = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);\nvar \
materialIridescenceThickness = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.IRIDESCENCE_THICKNESS);\nvar materialTransmission = /* @__PURE__ \
*/ nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);\nvar \
materialThickness = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.THICKNESS);\nvar materialIOR = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.IOR);\nvar \
materialAttenuationDistance = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.ATTENUATION_DISTANCE);\nvar materialAttenuationColor = /* \
@__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.ATTENUATION_COLOR);\nvar materialLineScale = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);\nvar \
materialLineDashSize = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.LINE_DASH_SIZE);\nvar materialLineGapSize = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);\nvar \
materialLineWidth = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.LINE_WIDTH);\nvar materialLineDashOffset = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);\nvar \
materialPointWidth = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.POINT_WIDTH);\nvar materialDispersion = /* @__PURE__ */ \
nodeImmutable(MaterialNode, MaterialNode.DISPERSION);\nvar materialLightMap = \
/* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);\nvar \
materialAOMap = /* @__PURE__ */ nodeImmutable(MaterialNode, \
MaterialNode.AO_MAP);\nvar materialAnisotropyVector = /* @__PURE__ */ \
uniform(new Vector22()).onReference(function(frame2) {\n  return \
frame2.material;\n}).onRenderUpdate(function({ material }) {\n  \
this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), \
material.anisotropy * Math.sin(material.anisotropyRotation));\n});\nvar \
ModelViewProjectionNode = class extends TempNode {\n  static get type() {\n   \
 return \"ModelViewProjectionNode\";\n  }\n  constructor(positionNode = null) \
{\n    super(\"vec4\");\n    this.positionNode = positionNode;\n  }\n  \
setup(builder) {\n    if (builder.shaderStage === \"fragment\") {\n      \
return varying(builder.context.mvp);\n    }\n    const position = \
this.positionNode || positionLocal;\n    const viewMatrix = \
builder.renderer.nodes.modelViewMatrix || modelViewMatrix;\n    return \
cameraProjectionMatrix.mul(viewMatrix).mul(position);\n  }\n};\nvar \
modelViewProjection = /* @__PURE__ */ \
nodeProxy(ModelViewProjectionNode);\nvar IndexNode = class _IndexNode extends \
Node {\n  static get type() {\n    return \"IndexNode\";\n  }\n  \
constructor(scope) {\n    super(\"uint\");\n    this.scope = scope;\n    \
this.isInstanceIndexNode = true;\n  }\n  generate(builder) {\n    const \
nodeType = this.getNodeType(builder);\n    const scope = this.scope;\n    let \
propertyName;\n    if (scope === _IndexNode.VERTEX) {\n      propertyName = \
builder.getVertexIndex();\n    } else if (scope === _IndexNode.INSTANCE) {\n  \
    propertyName = builder.getInstanceIndex();\n    } else if (scope === \
_IndexNode.DRAW) {\n      propertyName = builder.getDrawIndex();\n    } else \
if (scope === _IndexNode.INVOCATION_LOCAL) {\n      propertyName = \
builder.getInvocationLocalIndex();\n    } else if (scope === \
_IndexNode.INVOCATION_SUBGROUP) {\n      propertyName = \
builder.getInvocationSubgroupIndex();\n    } else if (scope === \
_IndexNode.SUBGROUP) {\n      propertyName = builder.getSubgroupIndex();\n    \
} else {\n      throw new Error(\"THREE.IndexNode: Unknown scope: \" + \
scope);\n    }\n    let output2;\n    if (builder.shaderStage === \"vertex\" \
|| builder.shaderStage === \"compute\") {\n      output2 = propertyName;\n    \
} else {\n      const nodeVarying = varying(this);\n      output2 = \
nodeVarying.build(builder, nodeType);\n    }\n    return output2;\n  \
}\n};\nIndexNode.VERTEX = \"vertex\";\nIndexNode.INSTANCE = \
\"instance\";\nIndexNode.SUBGROUP = \"subgroup\";\nIndexNode.INVOCATION_LOCAL \
= \"invocationLocal\";\nIndexNode.INVOCATION_SUBGROUP = \
\"invocationSubgroup\";\nIndexNode.DRAW = \"draw\";\nvar vertexIndex = /* \
@__PURE__ */ nodeImmutable(IndexNode, IndexNode.VERTEX);\nvar instanceIndex = \
/* @__PURE__ */ nodeImmutable(IndexNode, IndexNode.INSTANCE);\nvar \
subgroupIndex = /* @__PURE__ */ nodeImmutable(IndexNode, \
IndexNode.SUBGROUP);\nvar invocationSubgroupIndex = /* @__PURE__ */ \
nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);\nvar \
invocationLocalIndex = /* @__PURE__ */ nodeImmutable(IndexNode, \
IndexNode.INVOCATION_LOCAL);\nvar drawIndex = /* @__PURE__ */ \
nodeImmutable(IndexNode, IndexNode.DRAW);\nvar InstanceNode = class extends \
Node {\n  static get type() {\n    return \"InstanceNode\";\n  }\n  \
constructor(instanceMesh) {\n    super(\"void\");\n    this.instanceMesh = \
instanceMesh;\n    this.instanceMatrixNode = null;\n    \
this.instanceColorNode = null;\n    this.updateType = NodeUpdateType.FRAME;\n \
   this.buffer = null;\n    this.bufferColor = null;\n  }\n  setup(builder) \
{\n    let instanceMatrixNode = this.instanceMatrixNode;\n    let \
instanceColorNode = this.instanceColorNode;\n    const instanceMesh = \
this.instanceMesh;\n    if (instanceMatrixNode === null) {\n      const \
instanceAttribute = instanceMesh.instanceMatrix;\n      if \
(instanceMesh.count <= 1e3) {\n        instanceMatrixNode = \
buffer(instanceAttribute.array, \"mat4\", Math.max(instanceMesh.count, \
1)).element(instanceIndex);\n      } else {\n        const buffer2 = new \
InstancedInterleavedBuffer(instanceAttribute.array, 16, 1);\n        \
this.buffer = buffer2;\n        const bufferFn = instanceAttribute.usage === \
DynamicDrawUsage ? instancedDynamicBufferAttribute : \
instancedBufferAttribute;\n        const instanceBuffers = [\n          // \
F.Signature -> bufferAttribute( array, type, stride, offset )\n          \
bufferFn(buffer2, \"vec4\", 16, 0),\n          bufferFn(buffer2, \"vec4\", \
16, 4),\n          bufferFn(buffer2, \"vec4\", 16, 8),\n          \
bufferFn(buffer2, \"vec4\", 16, 12)\n        ];\n        instanceMatrixNode = \
mat4(...instanceBuffers);\n      }\n      this.instanceMatrixNode = \
instanceMatrixNode;\n    }\n    const instanceColorAttribute = \
instanceMesh.instanceColor;\n    if (instanceColorAttribute && \
instanceColorNode === null) {\n      const buffer2 = new \
InstancedBufferAttribute(instanceColorAttribute.array, 3);\n      const \
bufferFn = instanceColorAttribute.usage === DynamicDrawUsage ? \
instancedDynamicBufferAttribute : instancedBufferAttribute;\n      \
this.bufferColor = buffer2;\n      instanceColorNode = vec3(bufferFn(buffer2, \
\"vec3\", 3, 0));\n      this.instanceColorNode = instanceColorNode;\n    }\n \
   const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;\n    \
positionLocal.assign(instancePosition);\n    if \
(builder.hasGeometryAttribute(\"normal\")) {\n      const instanceNormal = \
transformNormal(normalLocal, instanceMatrixNode);\n      \
normalLocal.assign(instanceNormal);\n    }\n    if (this.instanceColorNode \
!== null) {\n      varyingProperty(\"vec3\", \
\"vInstanceColor\").assign(this.instanceColorNode);\n    }\n  }\n  update() \
{\n    if (this.instanceMesh.instanceMatrix.usage !== DynamicDrawUsage && \
this.buffer != null && this.instanceMesh.instanceMatrix.version !== \
this.buffer.version) {\n      this.buffer.version = \
this.instanceMesh.instanceMatrix.version;\n    }\n    if \
(this.instanceMesh.instanceColor && this.instanceMesh.instanceColor.usage !== \
DynamicDrawUsage && this.bufferColor != null && \
this.instanceMesh.instanceColor.version !== this.bufferColor.version) {\n     \
 this.bufferColor.version = this.instanceMesh.instanceColor.version;\n    }\n \
 }\n};\nvar instance = /* @__PURE__ */ nodeProxy(InstanceNode);\nvar \
BatchNode = class extends Node {\n  static get type() {\n    return \
\"BatchNode\";\n  }\n  constructor(batchMesh) {\n    super(\"void\");\n    \
this.batchMesh = batchMesh;\n    this.batchingIdNode = null;\n  }\n  \
setup(builder) {\n    if (this.batchingIdNode === null) {\n      if \
(builder.getDrawIndex() === null) {\n        this.batchingIdNode = \
instanceIndex;\n      } else {\n        this.batchingIdNode = drawIndex;\n    \
  }\n    }\n    const getIndirectIndex = Fn(([id2]) => {\n      const size2 = \
textureSize(textureLoad(this.batchMesh._indirectTexture), 0);\n      const x3 \
= int(id2).modInt(int(size2));\n      const y3 = int(id2).div(int(size2));\n  \
    return textureLoad(this.batchMesh._indirectTexture, ivec2(x3, y3)).x;\n   \
 }).setLayout({\n      name: \"getIndirectIndex\",\n      type: \"uint\",\n   \
   inputs: [\n        { name: \"id\", type: \"int\" }\n      ]\n    });\n    \
const indirectId = getIndirectIndex(int(this.batchingIdNode));\n    const \
matricesTexture = this.batchMesh._matricesTexture;\n    const size = \
textureSize(textureLoad(matricesTexture), 0);\n    const j = \
float(indirectId).mul(4).toInt().toVar();\n    const x2 = j.modInt(size);\n   \
 const y2 = j.div(int(size));\n    const batchingMatrix = mat4(\n      \
textureLoad(matricesTexture, ivec2(x2, y2)),\n      \
textureLoad(matricesTexture, ivec2(x2.add(1), y2)),\n      \
textureLoad(matricesTexture, ivec2(x2.add(2), y2)),\n      \
textureLoad(matricesTexture, ivec2(x2.add(3), y2))\n    );\n    const \
colorsTexture = this.batchMesh._colorsTexture;\n    if (colorsTexture !== \
null) {\n      const getBatchingColor = Fn(([id2]) => {\n        const size2 \
= textureSize(textureLoad(colorsTexture), 0).x;\n        const j2 = id2;\n    \
    const x3 = j2.modInt(size2);\n        const y3 = j2.div(size2);\n        \
return textureLoad(colorsTexture, ivec2(x3, y3)).rgb;\n      }).setLayout({\n \
       name: \"getBatchingColor\",\n        type: \"vec3\",\n        inputs: \
[\n          { name: \"id\", type: \"int\" }\n        ]\n      });\n      \
const color2 = getBatchingColor(indirectId);\n      varyingProperty(\"vec3\", \
\"vBatchColor\").assign(color2);\n    }\n    const bm = \
mat3(batchingMatrix);\n    \
positionLocal.assign(batchingMatrix.mul(positionLocal));\n    const \
transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), \
bm[2].dot(bm[2])));\n    const batchingNormal = \
bm.mul(transformedNormal).xyz;\n    normalLocal.assign(batchingNormal);\n    \
if (builder.hasGeometryAttribute(\"tangent\")) {\n      \
tangentLocal.mulAssign(bm);\n    }\n  }\n};\nvar batch = /* @__PURE__ */ \
nodeProxy(BatchNode);\nvar _frameId = /* @__PURE__ */ new WeakMap();\nvar \
SkinningNode = class extends Node {\n  static get type() {\n    return \
\"SkinningNode\";\n  }\n  constructor(skinnedMesh, useReference = false) {\n  \
  super(\"void\");\n    this.skinnedMesh = skinnedMesh;\n    \
this.useReference = useReference;\n    this.updateType = \
NodeUpdateType.OBJECT;\n    this.skinIndexNode = attribute(\"skinIndex\", \
\"uvec4\");\n    this.skinWeightNode = attribute(\"skinWeight\", \"vec4\");\n \
   let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;\n    if \
(useReference) {\n      bindMatrixNode = reference(\"bindMatrix\", \
\"mat4\");\n      bindMatrixInverseNode = reference(\"bindMatrixInverse\", \
\"mat4\");\n      boneMatricesNode = \
referenceBuffer(\"skeleton.boneMatrices\", \"mat4\", \
skinnedMesh.skeleton.bones.length);\n    } else {\n      bindMatrixNode = \
uniform(skinnedMesh.bindMatrix, \"mat4\");\n      bindMatrixInverseNode = \
uniform(skinnedMesh.bindMatrixInverse, \"mat4\");\n      boneMatricesNode = \
buffer(skinnedMesh.skeleton.boneMatrices, \"mat4\", \
skinnedMesh.skeleton.bones.length);\n    }\n    this.bindMatrixNode = \
bindMatrixNode;\n    this.bindMatrixInverseNode = bindMatrixInverseNode;\n    \
this.boneMatricesNode = boneMatricesNode;\n    this.previousBoneMatricesNode \
= null;\n  }\n  getSkinnedPosition(boneMatrices = this.boneMatricesNode, \
position = positionLocal) {\n    const { skinIndexNode, skinWeightNode, \
bindMatrixNode, bindMatrixInverseNode } = this;\n    const boneMatX = \
boneMatrices.element(skinIndexNode.x);\n    const boneMatY = \
boneMatrices.element(skinIndexNode.y);\n    const boneMatZ = \
boneMatrices.element(skinIndexNode.z);\n    const boneMatW = \
boneMatrices.element(skinIndexNode.w);\n    const skinVertex = \
bindMatrixNode.mul(position);\n    const skinned = add4(\n      \
boneMatX.mul(skinWeightNode.x).mul(skinVertex),\n      \
boneMatY.mul(skinWeightNode.y).mul(skinVertex),\n      \
boneMatZ.mul(skinWeightNode.z).mul(skinVertex),\n      \
boneMatW.mul(skinWeightNode.w).mul(skinVertex)\n    );\n    return \
bindMatrixInverseNode.mul(skinned).xyz;\n  }\n  getSkinnedNormal(boneMatrices \
= this.boneMatricesNode, normal2 = normalLocal) {\n    const { skinIndexNode, \
skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n    const \
boneMatX = boneMatrices.element(skinIndexNode.x);\n    const boneMatY = \
boneMatrices.element(skinIndexNode.y);\n    const boneMatZ = \
boneMatrices.element(skinIndexNode.z);\n    const boneMatW = \
boneMatrices.element(skinIndexNode.w);\n    let skinMatrix = add4(\n      \
skinWeightNode.x.mul(boneMatX),\n      skinWeightNode.y.mul(boneMatY),\n      \
skinWeightNode.z.mul(boneMatZ),\n      skinWeightNode.w.mul(boneMatW)\n    \
);\n    skinMatrix = \
bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);\n    return \
skinMatrix.transformDirection(normal2).xyz;\n  }\n  \
getPreviousSkinnedPosition(builder) {\n    const skinnedMesh = \
builder.object;\n    if (this.previousBoneMatricesNode === null) {\n      \
skinnedMesh.skeleton.previousBoneMatrices = new \
Float32Array(skinnedMesh.skeleton.boneMatrices);\n      \
this.previousBoneMatricesNode = \
referenceBuffer(\"skeleton.previousBoneMatrices\", \"mat4\", \
skinnedMesh.skeleton.bones.length);\n    }\n    return \
this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);\n  \
}\n  needsPreviousBoneMatrices(builder) {\n    const mrt = \
builder.renderer.getMRT();\n    return mrt && mrt.has(\"velocity\");\n  }\n  \
setup(builder) {\n    if (this.needsPreviousBoneMatrices(builder)) {\n      \
positionPrevious.assign(this.getPreviousSkinnedPosition(builder));\n    }\n   \
 const skinPosition = this.getSkinnedPosition();\n    \
positionLocal.assign(skinPosition);\n    if \
(builder.hasGeometryAttribute(\"normal\")) {\n      const skinNormal = \
this.getSkinnedNormal();\n      normalLocal.assign(skinNormal);\n      if \
(builder.hasGeometryAttribute(\"tangent\")) {\n        \
tangentLocal.assign(skinNormal);\n      }\n    }\n  }\n  generate(builder, \
output2) {\n    if (output2 !== \"void\") {\n      return \
positionLocal.build(builder, output2);\n    }\n  }\n  update(frame2) {\n    \
const object = this.useReference ? frame2.object : this.skinnedMesh;\n    \
const skeleton = object.skeleton;\n    if (_frameId.get(skeleton) === \
frame2.frameId) return;\n    _frameId.set(skeleton, frame2.frameId);\n    if \
(this.previousBoneMatricesNode !== null) \
skeleton.previousBoneMatrices.set(skeleton.boneMatrices);\n    \
skeleton.update();\n  }\n};\nvar skinningReference = (skinnedMesh) => \
nodeObject(new SkinningNode(skinnedMesh, true));\nvar LoopNode = class \
extends Node {\n  static get type() {\n    return \"LoopNode\";\n  }\n  \
constructor(params = []) {\n    super();\n    this.params = params;\n  }\n  \
getVarName(index5) {\n    return String.fromCharCode(\"i\".charCodeAt() + \
index5);\n  }\n  getProperties(builder) {\n    const properties = \
builder.getNodeProperties(this);\n    if (properties.stackNode !== void 0) \
return properties;\n    const inputs = {};\n    for (let i = 0, l = \
this.params.length - 1; i < l; i++) {\n      const param = this.params[i];\n  \
    const name = param.isNode !== true && param.name || this.getVarName(i);\n \
     const type = param.isNode !== true && param.type || \"int\";\n      \
inputs[name] = expression(name, type);\n    }\n    const stack2 = \
builder.addStack();\n    properties.returnsNode = \
this.params[this.params.length - 1](inputs, stack2, builder);\n    \
properties.stackNode = stack2;\n    builder.removeStack();\n    return \
properties;\n  }\n  getNodeType(builder) {\n    const { returnsNode } = \
this.getProperties(builder);\n    return returnsNode ? \
returnsNode.getNodeType(builder) : \"void\";\n  }\n  setup(builder) {\n    \
this.getProperties(builder);\n  }\n  generate(builder) {\n    const \
properties = this.getProperties(builder);\n    const params = this.params;\n  \
  const stackNode = properties.stackNode;\n    for (let i = 0, l = \
params.length - 1; i < l; i++) {\n      const param = params[i];\n      let \
start = null, end = null, name = null, type = null, condition = null, update4 \
= null;\n      if (param.isNode) {\n        type = \"int\";\n        name = \
this.getVarName(i);\n        start = \"0\";\n        end = \
param.build(builder, type);\n        condition = \"<\";\n      } else {\n     \
   type = param.type || \"int\";\n        name = param.name || \
this.getVarName(i);\n        start = param.start;\n        end = param.end;\n \
       condition = param.condition;\n        update4 = param.update;\n        \
if (typeof start === \"number\") start = builder.generateConst(type, \
start);\n        else if (start && start.isNode) start = start.build(builder, \
type);\n        if (typeof end === \"number\") end = \
builder.generateConst(type, end);\n        else if (end && end.isNode) end = \
end.build(builder, type);\n        if (start !== void 0 && end === void 0) \
{\n          start = start + \" - 1\";\n          end = \"0\";\n          \
condition = \">=\";\n        } else if (end !== void 0 && start === void 0) \
{\n          start = \"0\";\n          condition = \"<\";\n        }\n        \
if (condition === void 0) {\n          if (Number(start) > Number(end)) {\n   \
         condition = \">=\";\n          } else {\n            condition = \
\"<\";\n          }\n        }\n      }\n      const internalParam = { start, \
end, condition };\n      const startSnippet = internalParam.start;\n      \
const endSnippet = internalParam.end;\n      let declarationSnippet = \"\";\n \
     let conditionalSnippet = \"\";\n      let updateSnippet = \"\";\n      \
if (!update4) {\n        if (type === \"int\" || type === \"uint\") {\n       \
   if (condition.includes(\"<\")) update4 = \"++\";\n          else update4 = \
\"--\";\n        } else {\n          if (condition.includes(\"<\")) update4 = \
\"+= 1.\";\n          else update4 = \"-= 1.\";\n        }\n      }\n      \
declarationSnippet += builder.getVar(type, name) + \" = \" + startSnippet;\n  \
    conditionalSnippet += name + \" \" + condition + \" \" + endSnippet;\n    \
  updateSnippet += name + \" \" + update4;\n      const forSnippet = `for ( \
${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;\n      \
builder.addFlowCode((i === 0 ? \"\\n\" : \"\") + builder.tab + forSnippet + \
\" {\\n\\n\").addFlowTab();\n    }\n    const stackSnippet = \
stackNode.build(builder, \"void\");\n    const returnsSnippet = \
properties.returnsNode ? properties.returnsNode.build(builder) : \"\";\n    \
builder.removeFlowTab().addFlowCode(\"\\n\" + builder.tab + stackSnippet);\n  \
  for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      \
builder.addFlowCode((i === 0 ? \"\" : builder.tab) + \
\"}\\n\\n\").removeFlowTab();\n    }\n    builder.addFlowTab();\n    return \
returnsSnippet;\n  }\n};\nvar Loop = (...params) => nodeObject(new \
LoopNode(nodeArray(params, \"int\"))).append();\nvar Break = () => \
expression(\"break\").append();\nvar _morphTextures = /* @__PURE__ */ new \
WeakMap();\nvar _morphVec4 = /* @__PURE__ */ new Vector42();\nvar getMorph = \
/* @__PURE__ */ Fn(({ bufferMap, influence, stride, width, depth: depth2, \
offset }) => {\n  const texelIndex = \
int(vertexIndex).mul(stride).add(offset);\n  const y2 = \
texelIndex.div(width);\n  const x2 = texelIndex.sub(y2.mul(width));\n  const \
bufferAttrib = textureLoad(bufferMap, ivec2(x2, y2)).depth(depth2);\n  return \
bufferAttrib.mul(influence);\n});\nfunction getEntry(geometry) {\n  const \
hasMorphPosition = geometry.morphAttributes.position !== void 0;\n  const \
hasMorphNormals = geometry.morphAttributes.normal !== void 0;\n  const \
hasMorphColors = geometry.morphAttributes.color !== void 0;\n  const \
morphAttribute = geometry.morphAttributes.position || \
geometry.morphAttributes.normal || geometry.morphAttributes.color;\n  const \
morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;\n  \
let entry = _morphTextures.get(geometry);\n  if (entry === void 0 || \
entry.count !== morphTargetsCount) {\n    let disposeTexture = function() {\n \
     bufferTexture.dispose();\n      _morphTextures.delete(geometry);\n      \
geometry.removeEventListener(\"dispose\", disposeTexture);\n    };\n    if \
(entry !== void 0) entry.texture.dispose();\n    const morphTargets = \
geometry.morphAttributes.position || [];\n    const morphNormals = \
geometry.morphAttributes.normal || [];\n    const morphColors = \
geometry.morphAttributes.color || [];\n    let vertexDataCount = 0;\n    if \
(hasMorphPosition === true) vertexDataCount = 1;\n    if (hasMorphNormals === \
true) vertexDataCount = 2;\n    if (hasMorphColors === true) vertexDataCount \
= 3;\n    let width = geometry.attributes.position.count * vertexDataCount;\n \
   let height = 1;\n    const maxTextureSize = 4096;\n    if (width > \
maxTextureSize) {\n      height = Math.ceil(width / maxTextureSize);\n      \
width = maxTextureSize;\n    }\n    const buffer2 = new Float32Array(width * \
height * 4 * morphTargetsCount);\n    const bufferTexture = new \
DataArrayTexture2(buffer2, width, height, morphTargetsCount);\n    \
bufferTexture.type = FloatType2;\n    bufferTexture.needsUpdate = true;\n    \
const vertexDataStride = vertexDataCount * 4;\n    for (let i = 0; i < \
morphTargetsCount; i++) {\n      const morphTarget = morphTargets[i];\n      \
const morphNormal = morphNormals[i];\n      const morphColor = \
morphColors[i];\n      const offset = width * height * 4 * i;\n      for (let \
j = 0; j < morphTarget.count; j++) {\n        const stride = j * \
vertexDataStride;\n        if (hasMorphPosition === true) {\n          \
_morphVec4.fromBufferAttribute(morphTarget, j);\n          buffer2[offset + \
stride + 0] = _morphVec4.x;\n          buffer2[offset + stride + 1] = \
_morphVec4.y;\n          buffer2[offset + stride + 2] = _morphVec4.z;\n       \
   buffer2[offset + stride + 3] = 0;\n        }\n        if (hasMorphNormals \
=== true) {\n          _morphVec4.fromBufferAttribute(morphNormal, j);\n      \
    buffer2[offset + stride + 4] = _morphVec4.x;\n          buffer2[offset + \
stride + 5] = _morphVec4.y;\n          buffer2[offset + stride + 6] = \
_morphVec4.z;\n          buffer2[offset + stride + 7] = 0;\n        }\n       \
 if (hasMorphColors === true) {\n          \
_morphVec4.fromBufferAttribute(morphColor, j);\n          buffer2[offset + \
stride + 8] = _morphVec4.x;\n          buffer2[offset + stride + 9] = \
_morphVec4.y;\n          buffer2[offset + stride + 10] = _morphVec4.z;\n      \
    buffer2[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w \
: 1;\n        }\n      }\n    }\n    entry = {\n      count: \
morphTargetsCount,\n      texture: bufferTexture,\n      stride: \
vertexDataCount,\n      size: new Vector22(width, height)\n    };\n    \
_morphTextures.set(geometry, entry);\n    \
geometry.addEventListener(\"dispose\", disposeTexture);\n  }\n  return \
entry;\n}\nvar MorphNode = class extends Node {\n  static get type() {\n    \
return \"MorphNode\";\n  }\n  constructor(mesh) {\n    super(\"void\");\n    \
this.mesh = mesh;\n    this.morphBaseInfluence = uniform(1);\n    \
this.updateType = NodeUpdateType.OBJECT;\n  }\n  setup(builder) {\n    const \
{ geometry } = builder;\n    const hasMorphPosition = \
geometry.morphAttributes.position !== void 0;\n    const hasMorphNormals = \
geometry.hasAttribute(\"normal\") && geometry.morphAttributes.normal !== void \
0;\n    const morphAttribute = geometry.morphAttributes.position || \
geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const \
morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;\n  \
  const { texture: bufferMap, stride, size } = getEntry(geometry);\n    if \
(hasMorphPosition === true) \
positionLocal.mulAssign(this.morphBaseInfluence);\n    if (hasMorphNormals \
=== true) normalLocal.mulAssign(this.morphBaseInfluence);\n    const width = \
int(size.width);\n    Loop(morphTargetsCount, ({ i }) => {\n      const \
influence = float(0).toVar();\n      if (this.mesh.count > 1 && \
(this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0)) {\n   \
     influence.assign(textureLoad(this.mesh.morphTexture, \
ivec2(int(i).add(1), int(instanceIndex))).r);\n      } else {\n        \
influence.assign(reference(\"morphTargetInfluences\", \
\"float\").element(i).toVar());\n      }\n      if (hasMorphPosition === \
true) {\n        positionLocal.addAssign(getMorph({\n          bufferMap,\n   \
       influence,\n          stride,\n          width,\n          depth: i,\n \
         offset: int(0)\n        }));\n      }\n      if (hasMorphNormals === \
true) {\n        normalLocal.addAssign(getMorph({\n          bufferMap,\n     \
     influence,\n          stride,\n          width,\n          depth: i,\n   \
       offset: int(1)\n        }));\n      }\n    });\n  }\n  update() {\n    \
const morphBaseInfluence = this.morphBaseInfluence;\n    if \
(this.mesh.geometry.morphTargetsRelative) {\n      morphBaseInfluence.value = \
1;\n    } else {\n      morphBaseInfluence.value = 1 - \
this.mesh.morphTargetInfluences.reduce((a2, b) => a2 + b, 0);\n    }\n  \
}\n};\nvar morphReference = /* @__PURE__ */ nodeProxy(MorphNode);\nvar \
LightingNode = class extends Node {\n  static get type() {\n    return \
\"LightingNode\";\n  }\n  constructor() {\n    super(\"vec3\");\n    \
this.isLightingNode = true;\n  }\n  generate() {\n    console.warn(\"Abstract \
function.\");\n  }\n};\nvar AONode = class extends LightingNode {\n  static \
get type() {\n    return \"AONode\";\n  }\n  constructor(aoNode = null) {\n   \
 super();\n    this.aoNode = aoNode;\n  }\n  setup(builder) {\n    \
builder.context.ambientOcclusion.mulAssign(this.aoNode);\n  }\n};\nvar \
LightingContextNode = class extends ContextNode {\n  static get type() {\n    \
return \"LightingContextNode\";\n  }\n  constructor(node, lightingModel = \
null, backdropNode = null, backdropAlphaNode = null) {\n    super(node);\n    \
this.lightingModel = lightingModel;\n    this.backdropNode = backdropNode;\n  \
  this.backdropAlphaNode = backdropAlphaNode;\n    this._value = null;\n  }\n \
 getContext() {\n    const { backdropNode, backdropAlphaNode } = this;\n    \
const directDiffuse = vec3().toVar(\"directDiffuse\"), directSpecular = \
vec3().toVar(\"directSpecular\"), indirectDiffuse = \
vec3().toVar(\"indirectDiffuse\"), indirectSpecular = \
vec3().toVar(\"indirectSpecular\");\n    const reflectedLight = {\n      \
directDiffuse,\n      directSpecular,\n      indirectDiffuse,\n      \
indirectSpecular\n    };\n    const context2 = {\n      radiance: \
vec3().toVar(\"radiance\"),\n      irradiance: \
vec3().toVar(\"irradiance\"),\n      iblIrradiance: \
vec3().toVar(\"iblIrradiance\"),\n      ambientOcclusion: \
float(1).toVar(\"ambientOcclusion\"),\n      reflectedLight,\n      backdrop: \
backdropNode,\n      backdropAlpha: backdropAlphaNode\n    };\n    return \
context2;\n  }\n  setup(builder) {\n    this.value = this._value || \
(this._value = this.getContext());\n    this.value.lightingModel = \
this.lightingModel || builder.context.lightingModel;\n    return \
super.setup(builder);\n  }\n};\nvar lightingContext = /* @__PURE__ */ \
nodeProxy(LightingContextNode);\nvar IrradianceNode = class extends \
LightingNode {\n  static get type() {\n    return \"IrradianceNode\";\n  }\n  \
constructor(node) {\n    super();\n    this.node = node;\n  }\n  \
setup(builder) {\n    builder.context.irradiance.addAssign(this.node);\n  \
}\n};\nvar screenSizeVec;\nvar viewportVec;\nvar ScreenNode = class \
_ScreenNode extends Node {\n  static get type() {\n    return \
\"ScreenNode\";\n  }\n  constructor(scope) {\n    super();\n    this.scope = \
scope;\n    this.isViewportNode = true;\n  }\n  getNodeType() {\n    if \
(this.scope === _ScreenNode.VIEWPORT) return \"vec4\";\n    else return \
\"vec2\";\n  }\n  getUpdateType() {\n    let updateType = \
NodeUpdateType.NONE;\n    if (this.scope === _ScreenNode.SIZE || this.scope \
=== _ScreenNode.VIEWPORT) {\n      updateType = NodeUpdateType.RENDER;\n    \
}\n    this.updateType = updateType;\n    return updateType;\n  }\n  update({ \
renderer: renderer3 }) {\n    const renderTarget = \
renderer3.getRenderTarget();\n    if (this.scope === _ScreenNode.VIEWPORT) \
{\n      if (renderTarget !== null) {\n        \
viewportVec.copy(renderTarget.viewport);\n      } else {\n        \
renderer3.getViewport(viewportVec);\n        \
viewportVec.multiplyScalar(renderer3.getPixelRatio());\n      }\n    } else \
{\n      if (renderTarget !== null) {\n        screenSizeVec.width = \
renderTarget.width;\n        screenSizeVec.height = renderTarget.height;\n    \
  } else {\n        renderer3.getDrawingBufferSize(screenSizeVec);\n      }\n \
   }\n  }\n  setup() {\n    const scope = this.scope;\n    let output2 = \
null;\n    if (scope === _ScreenNode.SIZE) {\n      output2 = \
uniform(screenSizeVec || (screenSizeVec = new Vector22()));\n    } else if \
(scope === _ScreenNode.VIEWPORT) {\n      output2 = uniform(viewportVec || \
(viewportVec = new Vector42()));\n    } else {\n      output2 = \
vec2(screenCoordinate.div(screenSize));\n    }\n    return output2;\n  }\n  \
generate(builder) {\n    if (this.scope === _ScreenNode.COORDINATE) {\n      \
let coord = builder.getFragCoord();\n      if (builder.isFlipY()) {\n        \
const size = \
builder.getNodeProperties(screenSize).outputNode.build(builder);\n        \
coord = `${builder.getType(\"vec2\")}( ${coord}.x, ${size}.y - ${coord}.y \
)`;\n      }\n      return coord;\n    }\n    return \
super.generate(builder);\n  }\n};\nScreenNode.COORDINATE = \
\"coordinate\";\nScreenNode.VIEWPORT = \"viewport\";\nScreenNode.SIZE = \
\"size\";\nScreenNode.UV = \"uv\";\nvar screenUV = /* @__PURE__ */ \
nodeImmutable(ScreenNode, ScreenNode.UV);\nvar screenSize = /* @__PURE__ */ \
nodeImmutable(ScreenNode, ScreenNode.SIZE);\nvar screenCoordinate = /* \
@__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.COORDINATE);\nvar viewport \
= /* @__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);\nvar \
viewportSize = viewport.zw;\nvar viewportCoordinate = /* @__PURE__ */ \
screenCoordinate.sub(viewport.xy);\nvar _size$4 = /* @__PURE__ */ new \
Vector22();\nvar ViewportTextureNode = class extends TextureNode {\n  static \
get type() {\n    return \"ViewportTextureNode\";\n  }\n  constructor(uvNode \
= screenUV, levelNode = null, framebufferTexture = null) {\n    if \
(framebufferTexture === null) {\n      framebufferTexture = new \
FramebufferTexture();\n      framebufferTexture.minFilter = \
LinearMipmapLinearFilter2;\n    }\n    super(framebufferTexture, uvNode, \
levelNode);\n    this.generateMipmaps = false;\n    this.isOutputTextureNode \
= true;\n    this.updateBeforeType = NodeUpdateType.FRAME;\n  }\n  \
updateBefore(frame2) {\n    const renderer3 = frame2.renderer;\n    \
renderer3.getDrawingBufferSize(_size$4);\n    const framebufferTexture = \
this.value;\n    if (framebufferTexture.image.width !== _size$4.width || \
framebufferTexture.image.height !== _size$4.height) {\n      \
framebufferTexture.image.width = _size$4.width;\n      \
framebufferTexture.image.height = _size$4.height;\n      \
framebufferTexture.needsUpdate = true;\n    }\n    const \
currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n    \
framebufferTexture.generateMipmaps = this.generateMipmaps;\n    \
renderer3.copyFramebufferToTexture(framebufferTexture);\n    \
framebufferTexture.generateMipmaps = currentGenerateMipmaps;\n  }\n  clone() \
{\n    const viewportTextureNode = new this.constructor(this.uvNode, \
this.levelNode, this.value);\n    viewportTextureNode.generateMipmaps = \
this.generateMipmaps;\n    return viewportTextureNode;\n  }\n};\nvar \
viewportMipTexture = /* @__PURE__ */ nodeProxy(ViewportTextureNode, null, \
null, { generateMipmaps: true });\nvar sharedDepthbuffer = null;\nvar \
ViewportDepthTextureNode = class extends ViewportTextureNode {\n  static get \
type() {\n    return \"ViewportDepthTextureNode\";\n  }\n  constructor(uvNode \
= screenUV, levelNode = null) {\n    if (sharedDepthbuffer === null) {\n      \
sharedDepthbuffer = new DepthTexture2();\n    }\n    super(uvNode, levelNode, \
sharedDepthbuffer);\n  }\n};\nvar viewportDepthTexture = /* @__PURE__ */ \
nodeProxy(ViewportDepthTextureNode);\nvar ViewportDepthNode = class \
_ViewportDepthNode extends Node {\n  static get type() {\n    return \
\"ViewportDepthNode\";\n  }\n  constructor(scope, valueNode = null) {\n    \
super(\"float\");\n    this.scope = scope;\n    this.valueNode = valueNode;\n \
   this.isViewportDepthNode = true;\n  }\n  generate(builder) {\n    const { \
scope } = this;\n    if (scope === _ViewportDepthNode.DEPTH_BASE) {\n      \
return builder.getFragDepth();\n    }\n    return super.generate(builder);\n  \
}\n  setup({ camera: camera3 }) {\n    const { scope } = this;\n    const \
value = this.valueNode;\n    let node = null;\n    if (scope === \
_ViewportDepthNode.DEPTH_BASE) {\n      if (value !== null) {\n        node = \
depthBase().assign(value);\n      }\n    } else if (scope === \
_ViewportDepthNode.DEPTH) {\n      if (camera3.isPerspectiveCamera) {\n       \
 node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);\n     \
 } else {\n        node = viewZToOrthographicDepth(positionView.z, \
cameraNear, cameraFar);\n      }\n    } else if (scope === \
_ViewportDepthNode.LINEAR_DEPTH) {\n      if (value !== null) {\n        if \
(camera3.isPerspectiveCamera) {\n          const viewZ = \
perspectiveDepthToViewZ(value, cameraNear, cameraFar);\n          node = \
viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n        } else {\n   \
       node = value;\n        }\n      } else {\n        node = \
viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n      }\n   \
 }\n    return node;\n  }\n};\nViewportDepthNode.DEPTH_BASE = \
\"depthBase\";\nViewportDepthNode.DEPTH = \
\"depth\";\nViewportDepthNode.LINEAR_DEPTH = \"linearDepth\";\nvar \
viewZToOrthographicDepth = (viewZ, near, far) => \
viewZ.add(near).div(near.sub(far));\nvar viewZToPerspectiveDepth = (viewZ, \
near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));\nvar \
perspectiveDepthToViewZ = (depth2, near, far) => \
near.mul(far).div(far.sub(near).mul(depth2).sub(far));\nvar \
perspectiveDepthToLogarithmicDepth = (perspectiveW, near, far) => {\n  near = \
near.max(1e-6).toVar();\n  const numerator = \
log2(perspectiveW.div(near).add(1));\n  const denominator = \
log2(far.div(near).add(1));\n  return numerator.div(denominator);\n};\nvar \
depthBase = /* @__PURE__ */ nodeProxy(ViewportDepthNode, \
ViewportDepthNode.DEPTH_BASE);\nvar depth = /* @__PURE__ */ \
nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);\nvar linearDepth = \
/* @__PURE__ */ nodeProxy(ViewportDepthNode, \
ViewportDepthNode.LINEAR_DEPTH);\nvar viewportLinearDepth = /* @__PURE__ */ \
linearDepth(viewportDepthTexture());\ndepth.assign = (value) => \
depthBase(value);\nvar ClippingNode = class _ClippingNode extends Node {\n  \
static get type() {\n    return \"ClippingNode\";\n  }\n  constructor(scope = \
_ClippingNode.DEFAULT) {\n    super();\n    this.scope = scope;\n  }\n  \
setup(builder) {\n    super.setup(builder);\n    const clippingContext = \
builder.clippingContext;\n    const { localClipIntersection, \
localClippingCount, globalClippingCount } = clippingContext;\n    const \
numClippingPlanes = globalClippingCount + localClippingCount;\n    const \
numUnionClippingPlanes = localClipIntersection ? numClippingPlanes - \
localClippingCount : numClippingPlanes;\n    if (this.scope === \
_ClippingNode.ALPHA_TO_COVERAGE) {\n      return \
this.setupAlphaToCoverage(clippingContext.planes, numClippingPlanes, \
numUnionClippingPlanes);\n    } else {\n      return \
this.setupDefault(clippingContext.planes, numClippingPlanes, \
numUnionClippingPlanes);\n    }\n  }\n  setupAlphaToCoverage(planes, \
numClippingPlanes, numUnionClippingPlanes) {\n    return Fn(() => {\n      \
const clippingPlanes = uniformArray(planes);\n      const distanceToPlane = \
property(\"float\", \"distanceToPlane\");\n      const distanceGradient = \
property(\"float\", \"distanceToGradient\");\n      const clipOpacity = \
property(\"float\", \"clipOpacity\");\n      clipOpacity.assign(1);\n      \
let plane;\n      Loop(numUnionClippingPlanes, ({ i }) => {\n        plane = \
clippingPlanes.element(i);\n        \
distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));\n  \
      distanceGradient.assign(distanceToPlane.fwidth().div(2));\n        \
clipOpacity.mulAssign(smoothstep2(distanceGradient.negate(), \
distanceGradient, distanceToPlane));\n        \
clipOpacity.equal(0).discard();\n      });\n      if (numUnionClippingPlanes \
< numClippingPlanes) {\n        const unionClipOpacity = property(\"float\", \
\"unionclipOpacity\");\n        unionClipOpacity.assign(1);\n        Loop({ \
start: numUnionClippingPlanes, end: numClippingPlanes }, ({ i }) => {\n       \
   plane = clippingPlanes.element(i);\n          \
distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));\n  \
        distanceGradient.assign(distanceToPlane.fwidth().div(2));\n          \
unionClipOpacity.mulAssign(smoothstep2(distanceGradient.negate(), \
distanceGradient, distanceToPlane).oneMinus());\n        });\n        \
clipOpacity.mulAssign(unionClipOpacity.oneMinus());\n      }\n      \
diffuseColor.a.mulAssign(clipOpacity);\n      \
diffuseColor.a.equal(0).discard();\n    })();\n  }\n  setupDefault(planes, \
numClippingPlanes, numUnionClippingPlanes) {\n    return Fn(() => {\n      \
const clippingPlanes = uniformArray(planes);\n      let plane;\n      \
Loop(numUnionClippingPlanes, ({ i }) => {\n        plane = \
clippingPlanes.element(i);\n        \
positionView.dot(plane.xyz).greaterThan(plane.w).discard();\n      });\n      \
if (numUnionClippingPlanes < numClippingPlanes) {\n        const clipped = \
property(\"bool\", \"clipped\");\n        clipped.assign(true);\n        \
Loop({ start: numUnionClippingPlanes, end: numClippingPlanes }, ({ i }) => \
{\n          plane = clippingPlanes.element(i);\n          \
clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped))\
;\n        });\n        clipped.discard();\n      }\n    })();\n  \
}\n};\nClippingNode.ALPHA_TO_COVERAGE = \
\"alphaToCoverage\";\nClippingNode.DEFAULT = \"default\";\nvar clipping = () \
=> nodeObject(new ClippingNode());\nvar clippingAlpha = () => nodeObject(new \
ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));\nvar ALPHA_HASH_SCALE = \
0.05;\nvar hash2D = /* @__PURE__ */ Fn(([value]) => {\n  return \
fract(mul(1e4, sin(mul(17, value.x).add(mul(0.1, value.y)))).mul(add4(0.1, \
abs(sin(mul(13, value.y).add(value.x))))));\n});\nvar hash3D = /* @__PURE__ \
*/ Fn(([value]) => {\n  return hash2D(vec2(hash2D(value.xy), \
value.z));\n});\nvar getAlphaHashThreshold = /* @__PURE__ */ Fn(([position]) \
=> {\n  const maxDeriv = max$1(\n    length(dFdx(position.xyz)),\n    \
length(dFdy(position.xyz))\n  ).toVar(\"maxDeriv\");\n  const pixScale = \
float(1).div(float(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar(\"pixScale\");\n  \
const pixScales = vec2(\n    exp2(floor(log2(pixScale))),\n    \
exp2(ceil(log2(pixScale)))\n  ).toVar(\"pixScales\");\n  const alpha = \
vec2(\n    hash3D(floor(pixScales.x.mul(position.xyz))),\n    \
hash3D(floor(pixScales.y.mul(position.xyz)))\n  ).toVar(\"alpha\");\n  const \
lerpFactor = fract(log2(pixScale)).toVar(\"lerpFactor\");\n  const x2 = \
add4(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, \
alpha.y)).toVar(\"x\");\n  const a2 = min$1(lerpFactor, \
lerpFactor.oneMinus()).toVar(\"a\");\n  const cases = vec3(\n    \
x2.mul(x2).div(mul(2, a2).mul(sub(1, a2))),\n    x2.sub(mul(0.5, \
a2)).div(sub(1, a2)),\n    sub(1, sub(1, x2).mul(sub(1, x2)).div(mul(2, \
a2).mul(sub(1, a2))))\n  ).toVar(\"cases\");\n  const threshold = \
x2.lessThan(a2.oneMinus()).select(x2.lessThan(a2).select(cases.x, cases.y), \
cases.z);\n  return clamp2(threshold, 1e-6, 1);\n});\nvar NodeMaterial = \
class extends Material2 {\n  static get type() {\n    return \
\"NodeMaterial\";\n  }\n  constructor() {\n    super();\n    \
this.isNodeMaterial = true;\n    this.type = this.constructor.type;\n    \
this.forceSinglePass = false;\n    this.fog = true;\n    this.lights = \
false;\n    this.lightsNode = null;\n    this.envNode = null;\n    \
this.aoNode = null;\n    this.colorNode = null;\n    this.normalNode = \
null;\n    this.opacityNode = null;\n    this.backdropNode = null;\n    \
this.backdropAlphaNode = null;\n    this.alphaTestNode = null;\n    \
this.positionNode = null;\n    this.geometryNode = null;\n    this.depthNode \
= null;\n    this.shadowNode = null;\n    this.shadowPositionNode = null;\n   \
 this.outputNode = null;\n    this.mrtNode = null;\n    this.fragmentNode = \
null;\n    this.vertexNode = null;\n  }\n  customProgramCacheKey() {\n    \
return this.type + getCacheKey$1(this);\n  }\n  build(builder) {\n    \
this.setup(builder);\n  }\n  setupObserver(builder) {\n    return new \
NodeMaterialObserver(builder);\n  }\n  setup(builder) {\n    \
builder.context.setupNormal = () => this.setupNormal(builder);\n    \
builder.addStack();\n    builder.stack.outputNode = this.vertexNode || \
this.setupPosition(builder);\n    if (this.geometryNode !== null) {\n      \
builder.stack.outputNode = \
builder.stack.outputNode.bypass(this.geometryNode);\n    }\n    \
builder.addFlow(\"vertex\", builder.removeStack());\n    \
builder.addStack();\n    let resultNode;\n    const clippingNode = \
this.setupClipping(builder);\n    if (this.depthWrite === true) \
this.setupDepth(builder);\n    if (this.fragmentNode === null) {\n      \
this.setupDiffuseColor(builder);\n      this.setupVariants(builder);\n      \
const outgoingLightNode = this.setupLighting(builder);\n      if \
(clippingNode !== null) builder.stack.add(clippingNode);\n      const \
basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);\n      \
resultNode = this.setupOutput(builder, basicOutput);\n      \
output.assign(resultNode);\n      if (this.outputNode !== null) resultNode = \
this.outputNode;\n      const renderTarget = \
builder.renderer.getRenderTarget();\n      if (renderTarget !== null) {\n     \
   const mrt = builder.renderer.getMRT();\n        const materialMRT = \
this.mrtNode;\n        if (mrt !== null) {\n          resultNode = mrt;\n     \
     if (materialMRT !== null) {\n            resultNode = \
mrt.merge(materialMRT);\n          }\n        } else if (materialMRT !== \
null) {\n          resultNode = materialMRT;\n        }\n      }\n    } else \
{\n      let fragmentNode = this.fragmentNode;\n      if \
(fragmentNode.isOutputStructNode !== true) {\n        fragmentNode = \
vec4(fragmentNode);\n      }\n      resultNode = this.setupOutput(builder, \
fragmentNode);\n    }\n    builder.stack.outputNode = resultNode;\n    \
builder.addFlow(\"fragment\", builder.removeStack());\n    builder.monitor = \
this.setupObserver(builder);\n  }\n  setupClipping(builder) {\n    if \
(builder.clippingContext === null) return null;\n    const { \
globalClippingCount, localClippingCount } = builder.clippingContext;\n    let \
result = null;\n    if (globalClippingCount || localClippingCount) {\n      \
const samples = builder.renderer.samples;\n      if (this.alphaToCoverage && \
samples > 1) {\n        result = clippingAlpha();\n      } else {\n        \
builder.stack.add(clipping());\n      }\n    }\n    return result;\n  }\n  \
setupDepth(builder) {\n    const { renderer: renderer3, camera: camera3 } = \
builder;\n    let depthNode = this.depthNode;\n    if (depthNode === null) \
{\n      const mrt = renderer3.getMRT();\n      if (mrt && \
mrt.has(\"depth\")) {\n        depthNode = mrt.get(\"depth\");\n      } else \
if (renderer3.logarithmicDepthBuffer === true) {\n        if \
(camera3.isPerspectiveCamera) {\n          depthNode = \
perspectiveDepthToLogarithmicDepth(modelViewProjection().w, cameraNear, \
cameraFar);\n        } else {\n          depthNode = \
viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n        }\n \
     }\n    }\n    if (depthNode !== null) {\n      \
depth.assign(depthNode).append();\n    }\n  }\n  setupPosition(builder) {\n   \
 const { object } = builder;\n    const geometry = object.geometry;\n    \
builder.addStack();\n    if (geometry.morphAttributes.position || \
geometry.morphAttributes.normal || geometry.morphAttributes.color) {\n      \
morphReference(object).append();\n    }\n    if (object.isSkinnedMesh === \
true) {\n      skinningReference(object).append();\n    }\n    if \
(this.displacementMap) {\n      const displacementMap = \
materialReference(\"displacementMap\", \"texture\");\n      const \
displacementScale = materialReference(\"displacementScale\", \"float\");\n    \
  const displacementBias = materialReference(\"displacementBias\", \
\"float\");\n      \
positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(dis\
placementScale).add(displacementBias)));\n    }\n    if \
(object.isBatchedMesh) {\n      batch(object).append();\n    }\n    if \
(object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute \
=== true) {\n      instance(object).append();\n    }\n    if \
(this.positionNode !== null) {\n      \
positionLocal.assign(this.positionNode);\n    }\n    const mvp = \
modelViewProjection();\n    builder.context.vertex = builder.removeStack();\n \
   builder.context.mvp = mvp;\n    return mvp;\n  }\n  setupDiffuseColor({ \
object, geometry }) {\n    let colorNode = this.colorNode ? \
vec4(this.colorNode) : materialColor;\n    if (this.vertexColors === true && \
geometry.hasAttribute(\"color\")) {\n      colorNode = \
vec4(colorNode.xyz.mul(attribute(\"color\", \"vec3\")), colorNode.a);\n    \
}\n    if (object.instanceColor) {\n      const instanceColor = \
varyingProperty(\"vec3\", \"vInstanceColor\");\n      colorNode = \
instanceColor.mul(colorNode);\n    }\n    if (object.isBatchedMesh && \
object._colorsTexture) {\n      const batchColor = varyingProperty(\"vec3\", \
\"vBatchColor\");\n      colorNode = batchColor.mul(colorNode);\n    }\n    \
diffuseColor.assign(colorNode);\n    const opacityNode = this.opacityNode ? \
float(this.opacityNode) : materialOpacity;\n    \
diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));\n    if \
(this.alphaTestNode !== null || this.alphaTest > 0) {\n      const \
alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : \
materialAlphaTest;\n      \
diffuseColor.a.lessThanEqual(alphaTestNode).discard();\n    }\n    if \
(this.alphaHash === true) {\n      \
diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();\n    \
}\n    if (this.transparent === false && this.blending === NormalBlending2 && \
this.alphaToCoverage === false) {\n      diffuseColor.a.assign(1);\n    }\n  \
}\n  setupVariants() {\n  }\n  setupOutgoingLight() {\n    return this.lights \
=== true ? vec3(0) : diffuseColor.rgb;\n  }\n  setupNormal() {\n    return \
this.normalNode ? vec3(this.normalNode) : materialNormal;\n  }\n  \
setupEnvironment() {\n    let node = null;\n    if (this.envNode) {\n      \
node = this.envNode;\n    } else if (this.envMap) {\n      node = \
this.envMap.isCubeTexture ? materialReference(\"envMap\", \"cubeTexture\") : \
materialReference(\"envMap\", \"texture\");\n    }\n    return node;\n  }\n  \
setupLightMap(builder) {\n    let node = null;\n    if \
(builder.material.lightMap) {\n      node = new \
IrradianceNode(materialLightMap);\n    }\n    return node;\n  }\n  \
setupLights(builder) {\n    const materialLightsNode = [];\n    const envNode \
= this.setupEnvironment(builder);\n    if (envNode && envNode.isLightingNode) \
{\n      materialLightsNode.push(envNode);\n    }\n    const lightMapNode = \
this.setupLightMap(builder);\n    if (lightMapNode && \
lightMapNode.isLightingNode) {\n      \
materialLightsNode.push(lightMapNode);\n    }\n    if (this.aoNode !== null \
|| builder.material.aoMap) {\n      const aoNode = this.aoNode !== null ? \
this.aoNode : materialAOMap;\n      materialLightsNode.push(new \
AONode(aoNode));\n    }\n    let lightsN = this.lightsNode || \
builder.lightsNode;\n    if (materialLightsNode.length > 0) {\n      lightsN \
= builder.renderer.lighting.createNode([...lightsN.getLights(), \
...materialLightsNode]);\n    }\n    return lightsN;\n  }\n  \
setupLightingModel() {\n  }\n  setupLighting(builder) {\n    const { material \
} = builder;\n    const { backdropNode, backdropAlphaNode, emissiveNode } = \
this;\n    const lights = this.lights === true || this.lightsNode !== null;\n \
   const lightsNode = lights ? this.setupLights(builder) : null;\n    let \
outgoingLightNode = this.setupOutgoingLight(builder);\n    if (lightsNode && \
lightsNode.getScope().hasLights) {\n      const lightingModel = \
this.setupLightingModel(builder);\n      outgoingLightNode = \
lightingContext(lightsNode, lightingModel, backdropNode, \
backdropAlphaNode);\n    } else if (backdropNode !== null) {\n      \
outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, \
backdropNode, backdropAlphaNode) : backdropNode);\n    }\n    if \
(emissiveNode && emissiveNode.isNode === true || material.emissive && \
material.emissive.isColor === true) {\n      \
emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));\n      \
outgoingLightNode = outgoingLightNode.add(emissive);\n    }\n    return \
outgoingLightNode;\n  }\n  setupOutput(builder, outputNode) {\n    if \
(this.fog === true) {\n      const fogNode = builder.fogNode;\n      if \
(fogNode) outputNode = vec4(fogNode.mix(outputNode.rgb, fogNode.colorNode), \
outputNode.a);\n    }\n    return outputNode;\n  }\n  \
setDefaultValues(material) {\n    for (const property2 in material) {\n      \
const value = material[property2];\n      if (this[property2] === void 0) {\n \
       this[property2] = value;\n        if (value && value.clone) \
this[property2] = value.clone();\n      }\n    }\n    const descriptors = \
Object.getOwnPropertyDescriptors(material.constructor.prototype);\n    for \
(const key in descriptors) {\n      if \
(Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 \
&& descriptors[key].get !== void 0) {\n        \
Object.defineProperty(this.constructor.prototype, key, descriptors[key]);\n   \
   }\n    }\n  }\n  toJSON(meta) {\n    const isRoot = meta === void 0 || \
typeof meta === \"string\";\n    if (isRoot) {\n      meta = {\n        \
textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    \
const data = Material2.prototype.toJSON.call(this, meta);\n    const \
nodeChildren = getNodeChildren(this);\n    data.inputNodes = {};\n    for \
(const { property: property2, childNode } of nodeChildren) {\n      \
data.inputNodes[property2] = childNode.toJSON(meta).uuid;\n    }\n    \
function extractFromCache(cache2) {\n      const values = [];\n      for \
(const key in cache2) {\n        const data2 = cache2[key];\n        delete \
data2.metadata;\n        values.push(data2);\n      }\n      return values;\n \
   }\n    if (isRoot) {\n      const textures = \
extractFromCache(meta.textures);\n      const images = \
extractFromCache(meta.images);\n      const nodes = \
extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = \
textures;\n      if (images.length > 0) data.images = images;\n      if \
(nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n  \
copy(source) {\n    this.lightsNode = source.lightsNode;\n    this.envNode = \
source.envNode;\n    this.colorNode = source.colorNode;\n    this.normalNode \
= source.normalNode;\n    this.opacityNode = source.opacityNode;\n    \
this.backdropNode = source.backdropNode;\n    this.backdropAlphaNode = \
source.backdropAlphaNode;\n    this.alphaTestNode = source.alphaTestNode;\n   \
 this.positionNode = source.positionNode;\n    this.geometryNode = \
source.geometryNode;\n    this.depthNode = source.depthNode;\n    \
this.shadowNode = source.shadowNode;\n    this.shadowPositionNode = \
source.shadowPositionNode;\n    this.outputNode = source.outputNode;\n    \
this.mrtNode = source.mrtNode;\n    this.fragmentNode = \
source.fragmentNode;\n    this.vertexNode = source.vertexNode;\n    return \
super.copy(source);\n  }\n};\nvar _defaultValues$d = /* @__PURE__ */ new \
LineBasicMaterial2();\nvar LineBasicNodeMaterial = class extends NodeMaterial \
{\n  static get type() {\n    return \"LineBasicNodeMaterial\";\n  }\n  \
constructor(parameters) {\n    super();\n    this.isLineBasicNodeMaterial = \
true;\n    this.lights = false;\n    \
this.setDefaultValues(_defaultValues$d);\n    this.setValues(parameters);\n  \
}\n};\nvar _defaultValues$c = /* @__PURE__ */ new LineDashedMaterial();\nvar \
LineDashedNodeMaterial = class extends NodeMaterial {\n  static get type() \
{\n    return \"LineDashedNodeMaterial\";\n  }\n  constructor(parameters) {\n \
   super();\n    this.isLineDashedNodeMaterial = true;\n    this.lights = \
false;\n    this.setDefaultValues(_defaultValues$c);\n    this.offsetNode = \
null;\n    this.dashScaleNode = null;\n    this.dashSizeNode = null;\n    \
this.gapSizeNode = null;\n    this.setValues(parameters);\n  }\n  \
setupVariants() {\n    const offsetNode = this.offsetNode;\n    const \
dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : \
materialLineScale;\n    const dashSizeNode = this.dashSizeNode ? \
float(this.dashSizeNode) : materialLineDashSize;\n    const gapSizeNode = \
this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;\n    \
dashSize.assign(dashSizeNode);\n    gapSize.assign(gapSizeNode);\n    const \
vLineDistance = varying(attribute(\"lineDistance\").mul(dashScaleNode));\n    \
const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : \
vLineDistance;\n    \
vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard(\
);\n  }\n};\nvar directionToColor = (node) => \
nodeObject(node).mul(0.5).add(0.5);\nvar _defaultValues$a = /* @__PURE__ */ \
new MeshNormalMaterial();\nvar MeshNormalNodeMaterial = class extends \
NodeMaterial {\n  static get type() {\n    return \
\"MeshNormalNodeMaterial\";\n  }\n  constructor(parameters) {\n    super();\n \
   this.lights = false;\n    this.isMeshNormalNodeMaterial = true;\n    \
this.setDefaultValues(_defaultValues$a);\n    this.setValues(parameters);\n  \
}\n  setupDiffuseColor() {\n    const opacityNode = this.opacityNode ? \
float(this.opacityNode) : materialOpacity;\n    \
diffuseColor.assign(vec4(directionToColor(transformedNormalView), \
opacityNode));\n  }\n};\nvar EquirectUVNode = class extends TempNode {\n  \
static get type() {\n    return \"EquirectUVNode\";\n  }\n  \
constructor(dirNode = positionWorldDirection) {\n    super(\"vec2\");\n    \
this.dirNode = dirNode;\n  }\n  setup() {\n    const dir = this.dirNode;\n    \
const u = dir.z.atan2(dir.x).mul(1 / (Math.PI * 2)).add(0.5);\n    const v = \
dir.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);\n    return vec2(u, \
v);\n  }\n};\nvar equirectUV = /* @__PURE__ */ \
nodeProxy(EquirectUVNode);\nvar CubeRenderTarget = class extends \
WebGLCubeRenderTarget2 {\n  constructor(size = 1, options = {}) {\n    \
super(size, options);\n    this.isCubeRenderTarget = true;\n  }\n  \
fromEquirectangularTexture(renderer3, texture$1) {\n    const \
currentMinFilter = texture$1.minFilter;\n    const currentGenerateMipmaps = \
texture$1.generateMipmaps;\n    texture$1.generateMipmaps = true;\n    \
this.texture.type = texture$1.type;\n    this.texture.colorSpace = \
texture$1.colorSpace;\n    this.texture.generateMipmaps = \
texture$1.generateMipmaps;\n    this.texture.minFilter = \
texture$1.minFilter;\n    this.texture.magFilter = texture$1.magFilter;\n    \
const geometry = new BoxGeometry2(5, 5, 5);\n    const uvNode = \
equirectUV(positionWorldDirection);\n    const material = new \
NodeMaterial();\n    material.colorNode = texture(texture$1, uvNode, 0);\n    \
material.side = BackSide2;\n    material.blending = NoBlending2;\n    const \
mesh = new Mesh2(geometry, material);\n    const scene3 = new Scene2();\n    \
scene3.add(mesh);\n    if (texture$1.minFilter === LinearMipmapLinearFilter2) \
texture$1.minFilter = LinearFilter2;\n    const camera3 = new CubeCamera2(1, \
10, this);\n    const currentMRT = renderer3.getMRT();\n    \
renderer3.setMRT(null);\n    camera3.update(renderer3, scene3);\n    \
renderer3.setMRT(currentMRT);\n    texture$1.minFilter = currentMinFilter;\n  \
  texture$1.currentGenerateMipmaps = currentGenerateMipmaps;\n    \
mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  \
}\n};\nvar _cache$1 = /* @__PURE__ */ new WeakMap();\nvar CubeMapNode = class \
extends TempNode {\n  static get type() {\n    return \"CubeMapNode\";\n  }\n \
 constructor(envNode) {\n    super(\"vec3\");\n    this.envNode = envNode;\n  \
  this._cubeTexture = null;\n    this._cubeTextureNode = cubeTexture();\n    \
const defaultTexture = new CubeTexture2();\n    \
defaultTexture.isRenderTargetTexture = true;\n    this._defaultTexture = \
defaultTexture;\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  \
updateBefore(frame2) {\n    const { renderer: renderer3, material } = \
frame2;\n    const envNode = this.envNode;\n    if (envNode.isTextureNode || \
envNode.isMaterialReferenceNode) {\n      const texture2 = \
envNode.isTextureNode ? envNode.value : material[envNode.property];\n      if \
(texture2 && texture2.isTexture) {\n        const mapping = \
texture2.mapping;\n        if (mapping === EquirectangularReflectionMapping2 \
|| mapping === EquirectangularRefractionMapping2) {\n          if \
(_cache$1.has(texture2)) {\n            const cubeMap = \
_cache$1.get(texture2);\n            mapTextureMapping(cubeMap, \
texture2.mapping);\n            this._cubeTexture = cubeMap;\n          } \
else {\n            const image = texture2.image;\n            if \
(isEquirectangularMapReady$1(image)) {\n              const renderTarget = \
new CubeRenderTarget(image.height);\n              \
renderTarget.fromEquirectangularTexture(renderer3, texture2);\n              \
mapTextureMapping(renderTarget.texture, texture2.mapping);\n              \
this._cubeTexture = renderTarget.texture;\n              \
_cache$1.set(texture2, renderTarget.texture);\n              \
texture2.addEventListener(\"dispose\", onTextureDispose);\n            } else \
{\n              this._cubeTexture = this._defaultTexture;\n            }\n   \
       }\n          this._cubeTextureNode.value = this._cubeTexture;\n        \
} else {\n          this._cubeTextureNode = this.envNode;\n        }\n      \
}\n    }\n  }\n  setup(builder) {\n    this.updateBefore(builder);\n    \
return this._cubeTextureNode;\n  }\n};\nfunction \
isEquirectangularMapReady$1(image) {\n  if (image === null || image === void \
0) return false;\n  return image.height > 0;\n}\nfunction \
onTextureDispose(event) {\n  const texture2 = event.target;\n  \
texture2.removeEventListener(\"dispose\", onTextureDispose);\n  const \
renderTarget = _cache$1.get(texture2);\n  if (renderTarget !== void 0) {\n    \
_cache$1.delete(texture2);\n    renderTarget.dispose();\n  }\n}\nfunction \
mapTextureMapping(texture2, mapping) {\n  if (mapping === \
EquirectangularReflectionMapping2) {\n    texture2.mapping = \
CubeReflectionMapping2;\n  } else if (mapping === \
EquirectangularRefractionMapping2) {\n    texture2.mapping = \
CubeRefractionMapping2;\n  }\n}\nvar cubeMapNode = /* @__PURE__ */ \
nodeProxy(CubeMapNode);\nvar BasicEnvironmentNode = class extends \
LightingNode {\n  static get type() {\n    return \"BasicEnvironmentNode\";\n \
 }\n  constructor(envNode = null) {\n    super();\n    this.envNode = \
envNode;\n  }\n  setup(builder) {\n    builder.context.environment = \
cubeMapNode(this.envNode);\n  }\n};\nvar BasicLightMapNode = class extends \
LightingNode {\n  static get type() {\n    return \"BasicLightMapNode\";\n  \
}\n  constructor(lightMapNode = null) {\n    super();\n    this.lightMapNode \
= lightMapNode;\n  }\n  setup(builder) {\n    const RECIPROCAL_PI2 = float(1 \
/ Math.PI);\n    builder.context.irradianceLightMap = \
this.lightMapNode.mul(RECIPROCAL_PI2);\n  }\n};\nvar LightingModel = class \
{\n  start() {\n  }\n  finish() {\n  }\n  direct() {\n  }\n  directRectArea() \
{\n  }\n  indirect() {\n  }\n  ambientOcclusion() {\n  }\n};\nvar \
BasicLightingModel = class extends LightingModel {\n  constructor() {\n    \
super();\n  }\n  indirect(context2, stack2, builder) {\n    const \
ambientOcclusion = context2.ambientOcclusion;\n    const reflectedLight = \
context2.reflectedLight;\n    const irradianceLightMap = \
builder.context.irradianceLightMap;\n    \
reflectedLight.indirectDiffuse.assign(vec4(0));\n    if (irradianceLightMap) \
{\n      reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);\n    } \
else {\n      reflectedLight.indirectDiffuse.addAssign(vec4(1, 1, 1, 0));\n   \
 }\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n    \
reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb);\n  }\n  \
finish(context2, stack2, builder) {\n    const material = builder.material;\n \
   const outgoingLight = context2.outgoingLight;\n    const envNode = \
builder.context.environment;\n    if (envNode) {\n      switch \
(material.combine) {\n        case MultiplyOperation2:\n          \
outgoingLight.rgb.assign(mix(outgoingLight.rgb, \
outgoingLight.rgb.mul(envNode.rgb), \
materialSpecularStrength.mul(materialReflectivity)));\n          break;\n     \
   case MixOperation2:\n          \
outgoingLight.rgb.assign(mix(outgoingLight.rgb, envNode.rgb, \
materialSpecularStrength.mul(materialReflectivity)));\n          break;\n     \
   case AddOperation2:\n          \
outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength.mul(mate\
rialReflectivity)));\n          break;\n        default:\n          \
console.warn(\"THREE.BasicLightingModel: Unsupported .combine value:\", \
material.combine);\n          break;\n      }\n    }\n  }\n};\nvar \
_defaultValues$9 = /* @__PURE__ */ new MeshBasicMaterial2();\nvar \
MeshBasicNodeMaterial = class extends NodeMaterial {\n  static get type() {\n \
   return \"MeshBasicNodeMaterial\";\n  }\n  constructor(parameters) {\n    \
super();\n    this.isMeshBasicNodeMaterial = true;\n    this.lights = true;\n \
   this.setDefaultValues(_defaultValues$9);\n    \
this.setValues(parameters);\n  }\n  setupNormal() {\n    return normalView;\n \
 }\n  setupEnvironment(builder) {\n    const envNode = \
super.setupEnvironment(builder);\n    return envNode ? new \
BasicEnvironmentNode(envNode) : null;\n  }\n  setupLightMap(builder) {\n    \
let node = null;\n    if (builder.material.lightMap) {\n      node = new \
BasicLightMapNode(materialLightMap);\n    }\n    return node;\n  }\n  \
setupOutgoingLight() {\n    return diffuseColor.rgb;\n  }\n  \
setupLightingModel() {\n    return new BasicLightingModel();\n  }\n};\nvar \
F_Schlick = /* @__PURE__ */ Fn(({ f0, f90, dotVH }) => {\n  const fresnel = \
dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();\n  return \
f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));\n});\nvar BRDF_Lambert = /* \
@__PURE__ */ Fn((inputs) => {\n  return inputs.diffuseColor.mul(1 / \
Math.PI);\n});\nvar G_BlinnPhong_Implicit = () => float(0.25);\nvar \
D_BlinnPhong = /* @__PURE__ */ Fn(({ dotNH }) => {\n  return \
shininess.mul(float(0.5)).add(1).mul(float(1 / \
Math.PI)).mul(dotNH.pow(shininess));\n});\nvar BRDF_BlinnPhong = /* @__PURE__ \
*/ Fn(({ lightDirection }) => {\n  const halfDir = \
lightDirection.add(positionViewDirection).normalize();\n  const dotNH = \
transformedNormalView.dot(halfDir).clamp();\n  const dotVH = \
positionViewDirection.dot(halfDir).clamp();\n  const F = F_Schlick({ f0: \
specularColor, f90: 1, dotVH });\n  const G = G_BlinnPhong_Implicit();\n  \
const D = D_BlinnPhong({ dotNH });\n  return F.mul(G).mul(D);\n});\nvar \
PhongLightingModel = class extends BasicLightingModel {\n  \
constructor(specular = true) {\n    super();\n    this.specular = specular;\n \
 }\n  direct({ lightDirection, lightColor, reflectedLight }) {\n    const \
dotNL = transformedNormalView.dot(lightDirection).clamp();\n    const \
irradiance = dotNL.mul(lightColor);\n    \
reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ \
diffuseColor: diffuseColor.rgb })));\n    if (this.specular === true) {\n     \
 reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({ \
lightDirection })).mul(materialSpecularStrength));\n    }\n  }\n  indirect({ \
ambientOcclusion, irradiance, reflectedLight }) {\n    \
reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ \
diffuseColor })));\n    \
reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n  }\n};\nvar \
_defaultValues$8 = /* @__PURE__ */ new MeshLambertMaterial2();\nvar \
MeshLambertNodeMaterial = class extends NodeMaterial {\n  static get type() \
{\n    return \"MeshLambertNodeMaterial\";\n  }\n  constructor(parameters) \
{\n    super();\n    this.isMeshLambertNodeMaterial = true;\n    this.lights \
= true;\n    this.setDefaultValues(_defaultValues$8);\n    \
this.setValues(parameters);\n  }\n  setupEnvironment(builder) {\n    const \
envNode = super.setupEnvironment(builder);\n    return envNode ? new \
BasicEnvironmentNode(envNode) : null;\n  }\n  setupLightingModel() {\n    \
return new PhongLightingModel(false);\n  }\n};\nvar _defaultValues$7 = /* \
@__PURE__ */ new MeshPhongMaterial();\nvar MeshPhongNodeMaterial = class \
extends NodeMaterial {\n  static get type() {\n    return \
\"MeshPhongNodeMaterial\";\n  }\n  constructor(parameters) {\n    super();\n  \
  this.isMeshPhongNodeMaterial = true;\n    this.lights = true;\n    \
this.shininessNode = null;\n    this.specularNode = null;\n    \
this.setDefaultValues(_defaultValues$7);\n    this.setValues(parameters);\n  \
}\n  setupEnvironment(builder) {\n    const envNode = \
super.setupEnvironment(builder);\n    return envNode ? new \
BasicEnvironmentNode(envNode) : null;\n  }\n  setupLightingModel() {\n    \
return new PhongLightingModel();\n  }\n  setupVariants() {\n    const \
shininessNode = (this.shininessNode ? float(this.shininessNode) : \
materialShininess).max(1e-4);\n    shininess.assign(shininessNode);\n    \
const specularNode = this.specularNode || materialSpecular;\n    \
specularColor.assign(specularNode);\n  }\n  copy(source) {\n    \
this.shininessNode = source.shininessNode;\n    this.specularNode = \
source.specularNode;\n    return super.copy(source);\n  }\n};\nvar \
getGeometryRoughness = /* @__PURE__ */ Fn((builder) => {\n  if \
(builder.geometry.hasAttribute(\"normal\") === false) {\n    return \
float(0);\n  }\n  const dxy = \
normalView.dFdx().abs().max(normalView.dFdy().abs());\n  const \
geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);\n  return \
geometryRoughness;\n});\nvar getRoughness = /* @__PURE__ */ Fn((inputs) => \
{\n  const { roughness: roughness2 } = inputs;\n  const geometryRoughness = \
getGeometryRoughness();\n  let roughnessFactor = roughness2.max(0.0525);\n  \
roughnessFactor = roughnessFactor.add(geometryRoughness);\n  roughnessFactor \
= roughnessFactor.min(1);\n  return roughnessFactor;\n});\nvar \
V_GGX_SmithCorrelated = /* @__PURE__ */ Fn(({ alpha, dotNL, dotNV }) => {\n  \
const a2 = alpha.pow2();\n  const gv = \
dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());\n  const gl = \
dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());\n  return div(0.5, \
gv.add(gl).max(EPSILON));\n}).setLayout({\n  name: \
\"V_GGX_SmithCorrelated\",\n  type: \"float\",\n  inputs: [\n    { name: \
\"alpha\", type: \"float\" },\n    { name: \"dotNL\", type: \"float\" },\n    \
{ name: \"dotNV\", type: \"float\" }\n  ]\n});\nvar \
V_GGX_SmithCorrelated_Anisotropic = /* @__PURE__ */ Fn(({ alphaT: alphaT2, \
alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {\n  const gv = \
dotNL.mul(vec3(alphaT2.mul(dotTV), alphaB.mul(dotBV), dotNV).length());\n  \
const gl = dotNV.mul(vec3(alphaT2.mul(dotTL), alphaB.mul(dotBL), \
dotNL).length());\n  const v = div(0.5, gv.add(gl));\n  return \
v.saturate();\n}).setLayout({\n  name: \
\"V_GGX_SmithCorrelated_Anisotropic\",\n  type: \"float\",\n  inputs: [\n    \
{ name: \"alphaT\", type: \"float\", qualifier: \"in\" },\n    { name: \
\"alphaB\", type: \"float\", qualifier: \"in\" },\n    { name: \"dotTV\", \
type: \"float\", qualifier: \"in\" },\n    { name: \"dotBV\", type: \
\"float\", qualifier: \"in\" },\n    { name: \"dotTL\", type: \"float\", \
qualifier: \"in\" },\n    { name: \"dotBL\", type: \"float\", qualifier: \
\"in\" },\n    { name: \"dotNV\", type: \"float\", qualifier: \"in\" },\n    \
{ name: \"dotNL\", type: \"float\", qualifier: \"in\" }\n  ]\n});\nvar D_GGX \
= /* @__PURE__ */ Fn(({ alpha, dotNH }) => {\n  const a2 = alpha.pow2();\n  \
const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();\n  return \
a2.div(denom.pow2()).mul(1 / Math.PI);\n}).setLayout({\n  name: \"D_GGX\",\n  \
type: \"float\",\n  inputs: [\n    { name: \"alpha\", type: \"float\" },\n    \
{ name: \"dotNH\", type: \"float\" }\n  ]\n});\nvar RECIPROCAL_PI = /* \
@__PURE__ */ float(1 / Math.PI);\nvar D_GGX_Anisotropic = /* @__PURE__ */ \
Fn(({ alphaT: alphaT2, alphaB, dotNH, dotTH, dotBH }) => {\n  const a2 = \
alphaT2.mul(alphaB);\n  const v = vec3(alphaB.mul(dotTH), alphaT2.mul(dotBH), \
a2.mul(dotNH));\n  const v2 = v.dot(v);\n  const w22 = a2.div(v2);\n  return \
RECIPROCAL_PI.mul(a2.mul(w22.pow2()));\n}).setLayout({\n  name: \
\"D_GGX_Anisotropic\",\n  type: \"float\",\n  inputs: [\n    { name: \
\"alphaT\", type: \"float\", qualifier: \"in\" },\n    { name: \"alphaB\", \
type: \"float\", qualifier: \"in\" },\n    { name: \"dotNH\", type: \
\"float\", qualifier: \"in\" },\n    { name: \"dotTH\", type: \"float\", \
qualifier: \"in\" },\n    { name: \"dotBH\", type: \"float\", qualifier: \
\"in\" }\n  ]\n});\nvar BRDF_GGX = /* @__PURE__ */ Fn((inputs) => {\n  const \
{ lightDirection, f0, f90, roughness: roughness2, f, USE_IRIDESCENCE, \
USE_ANISOTROPY } = inputs;\n  const normalView2 = inputs.normalView || \
transformedNormalView;\n  const alpha = roughness2.pow2();\n  const halfDir = \
lightDirection.add(positionViewDirection).normalize();\n  const dotNL = \
normalView2.dot(lightDirection).clamp();\n  const dotNV = \
normalView2.dot(positionViewDirection).clamp();\n  const dotNH = \
normalView2.dot(halfDir).clamp();\n  const dotVH = \
positionViewDirection.dot(halfDir).clamp();\n  let F = F_Schlick({ f0, f90, \
dotVH });\n  let V, D;\n  if (defined(USE_IRIDESCENCE)) {\n    F = \
iridescence.mix(F, f);\n  }\n  if (defined(USE_ANISOTROPY)) {\n    const \
dotTL = anisotropyT.dot(lightDirection);\n    const dotTV = \
anisotropyT.dot(positionViewDirection);\n    const dotTH = \
anisotropyT.dot(halfDir);\n    const dotBL = \
anisotropyB.dot(lightDirection);\n    const dotBV = \
anisotropyB.dot(positionViewDirection);\n    const dotBH = \
anisotropyB.dot(halfDir);\n    V = V_GGX_SmithCorrelated_Anisotropic({ \
alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL });\n    D = \
D_GGX_Anisotropic({ alphaT, alphaB: alpha, dotNH, dotTH, dotBH });\n  } else \
{\n    V = V_GGX_SmithCorrelated({ alpha, dotNL, dotNV });\n    D = D_GGX({ \
alpha, dotNH });\n  }\n  return F.mul(V).mul(D);\n});\nvar DFGApprox = /* \
@__PURE__ */ Fn(({ roughness: roughness2, dotNV }) => {\n  const c0 = \
vec4(-1, -0.0275, -0.572, 0.022);\n  const c1 = vec4(1, 0.0425, 1.04, \
-0.04);\n  const r = roughness2.mul(c0).add(c1);\n  const a004 = \
r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);\n  const fab = \
vec2(-1.04, 1.04).mul(a004).add(r.zw);\n  return fab;\n}).setLayout({\n  \
name: \"DFGApprox\",\n  type: \"vec2\",\n  inputs: [\n    { name: \
\"roughness\", type: \"float\" },\n    { name: \"dotNV\", type: \"vec3\" }\n  \
]\n});\nvar EnvironmentBRDF = /* @__PURE__ */ Fn((inputs) => {\n  const { \
dotNV, specularColor: specularColor2, specularF90: specularF902, roughness: \
roughness2 } = inputs;\n  const fab = DFGApprox({ dotNV, roughness: \
roughness2 });\n  return \
specularColor2.mul(fab.x).add(specularF902.mul(fab.y));\n});\nvar \
Schlick_to_F0 = /* @__PURE__ */ Fn(({ f, f90, dotVH }) => {\n  const x2 = \
dotVH.oneMinus().saturate();\n  const x22 = x2.mul(x2);\n  const x5 = \
x2.mul(x22, x22).clamp(0, 0.9999);\n  return \
f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());\n}).setLayout({\n  name: \
\"Schlick_to_F0\",\n  type: \"vec3\",\n  inputs: [\n    { name: \"f\", type: \
\"vec3\" },\n    { name: \"f90\", type: \"float\" },\n    { name: \"dotVH\", \
type: \"float\" }\n  ]\n});\nvar D_Charlie = /* @__PURE__ */ Fn(({ roughness: \
roughness2, dotNH }) => {\n  const alpha = roughness2.pow2();\n  const \
invAlpha = float(1).div(alpha);\n  const cos2h = dotNH.pow2();\n  const sin2h \
= cos2h.oneMinus().max(78125e-7);\n  return \
float(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2 * \
Math.PI);\n}).setLayout({\n  name: \"D_Charlie\",\n  type: \"float\",\n  \
inputs: [\n    { name: \"roughness\", type: \"float\" },\n    { name: \
\"dotNH\", type: \"float\" }\n  ]\n});\nvar V_Neubelt = /* @__PURE__ */ Fn(({ \
dotNV, dotNL }) => {\n  return \
float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));\n}).setLa\
yout({\n  name: \"V_Neubelt\",\n  type: \"float\",\n  inputs: [\n    { name: \
\"dotNV\", type: \"float\" },\n    { name: \"dotNL\", type: \"float\" }\n  \
]\n});\nvar BRDF_Sheen = /* @__PURE__ */ Fn(({ lightDirection }) => {\n  \
const halfDir = lightDirection.add(positionViewDirection).normalize();\n  \
const dotNL = transformedNormalView.dot(lightDirection).clamp();\n  const \
dotNV = transformedNormalView.dot(positionViewDirection).clamp();\n  const \
dotNH = transformedNormalView.dot(halfDir).clamp();\n  const D = D_Charlie({ \
roughness: sheenRoughness, dotNH });\n  const V = V_Neubelt({ dotNV, dotNL \
});\n  return sheen.mul(D).mul(V);\n});\nvar LTC_Uv = /* @__PURE__ */ Fn(({ \
N, V, roughness: roughness2 }) => {\n  const LUT_SIZE = 64;\n  const \
LUT_SCALE = (LUT_SIZE - 1) / LUT_SIZE;\n  const LUT_BIAS = 0.5 / LUT_SIZE;\n  \
const dotNV = N.dot(V).saturate();\n  const uv2 = vec2(roughness2, \
dotNV.oneMinus().sqrt());\n  uv2.assign(uv2.mul(LUT_SCALE).add(LUT_BIAS));\n  \
return uv2;\n}).setLayout({\n  name: \"LTC_Uv\",\n  type: \"vec2\",\n  \
inputs: [\n    { name: \"N\", type: \"vec3\" },\n    { name: \"V\", type: \
\"vec3\" },\n    { name: \"roughness\", type: \"float\" }\n  ]\n});\nvar \
LTC_ClippedSphereFormFactor = /* @__PURE__ */ Fn(({ f }) => {\n  const l = \
f.length();\n  return max$1(l.mul(l).add(f.z).div(l.add(1)), \
0);\n}).setLayout({\n  name: \"LTC_ClippedSphereFormFactor\",\n  type: \
\"float\",\n  inputs: [\n    { name: \"f\", type: \"vec3\" }\n  ]\n});\nvar \
LTC_EdgeVectorFormFactor = /* @__PURE__ */ Fn(({ v1, v2 }) => {\n  const x2 = \
v1.dot(v2);\n  const y2 = x2.abs().toVar();\n  const a2 = \
y2.mul(0.0145206).add(0.4965155).mul(y2).add(0.8543985).toVar();\n  const b = \
y2.add(4.1616724).mul(y2).add(3.417594).toVar();\n  const v = a2.div(b);\n  \
const theta_sintheta = x2.greaterThan(0).select(v, \
max$1(x2.mul(x2).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v));\n  return \
v1.cross(v2).mul(theta_sintheta);\n}).setLayout({\n  name: \
\"LTC_EdgeVectorFormFactor\",\n  type: \"vec3\",\n  inputs: [\n    { name: \
\"v1\", type: \"vec3\" },\n    { name: \"v2\", type: \"vec3\" }\n  \
]\n});\nvar LTC_Evaluate = /* @__PURE__ */ Fn(({ N, V, P, mInv, p0, p1, p2, \
p3 }) => {\n  const v1 = p1.sub(p0).toVar();\n  const v2 = \
p3.sub(p0).toVar();\n  const lightNormal = v1.cross(v2);\n  const result = \
vec3().toVar();\n  If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0), () => \
{\n    const T1 = V.sub(N.mul(V.dot(N))).normalize();\n    const T2 = \
N.cross(T1).negate();\n    const mat = mInv.mul(mat3(T1, T2, \
N).transpose()).toVar();\n    const coords0 = \
mat.mul(p0.sub(P)).normalize().toVar();\n    const coords1 = \
mat.mul(p1.sub(P)).normalize().toVar();\n    const coords2 = \
mat.mul(p2.sub(P)).normalize().toVar();\n    const coords3 = \
mat.mul(p3.sub(P)).normalize().toVar();\n    const vectorFormFactor = \
vec3(0).toVar();\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ \
v1: coords0, v2: coords1 }));\n    \
vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords1, v2: \
coords2 }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: \
coords2, v2: coords3 }));\n    \
vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords3, v2: \
coords0 }));\n    result.assign(vec3(LTC_ClippedSphereFormFactor({ f: \
vectorFormFactor })));\n  });\n  return result;\n}).setLayout({\n  name: \
\"LTC_Evaluate\",\n  type: \"vec3\",\n  inputs: [\n    { name: \"N\", type: \
\"vec3\" },\n    { name: \"V\", type: \"vec3\" },\n    { name: \"P\", type: \
\"vec3\" },\n    { name: \"mInv\", type: \"mat3\" },\n    { name: \"p0\", \
type: \"vec3\" },\n    { name: \"p1\", type: \"vec3\" },\n    { name: \"p2\", \
type: \"vec3\" },\n    { name: \"p3\", type: \"vec3\" }\n  ]\n});\nvar bC = 1 \
/ 6;\nvar w0 = (a2) => mul(bC, mul(a2, mul(a2, \
a2.negate().add(3)).sub(3)).add(1));\nvar w1 = (a2) => mul(bC, mul(a2, \
mul(a2, mul(3, a2).sub(6))).add(4));\nvar w2 = (a2) => mul(bC, mul(a2, \
mul(a2, mul(-3, a2).add(3)).add(3)).add(1));\nvar w3 = (a2) => mul(bC, \
pow(a2, 3));\nvar g0 = (a2) => w0(a2).add(w1(a2));\nvar g1 = (a2) => \
w2(a2).add(w3(a2));\nvar h0 = (a2) => add4(-1, \
w1(a2).div(w0(a2).add(w1(a2))));\nvar h1 = (a2) => add4(1, \
w3(a2).div(w2(a2).add(w3(a2))));\nvar bicubic = (textureNode, texelSize, lod) \
=> {\n  const uv2 = textureNode.uvNode;\n  const uvScaled = mul(uv2, \
texelSize.zw).add(0.5);\n  const iuv = floor(uvScaled);\n  const fuv = \
fract(uvScaled);\n  const g0x = g0(fuv.x);\n  const g1x = g1(fuv.x);\n  const \
h0x = h0(fuv.x);\n  const h1x = h1(fuv.x);\n  const h0y = h0(fuv.y);\n  const \
h1y = h1(fuv.y);\n  const p0 = vec2(iuv.x.add(h0x), \
iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);\n  const p1 = \
vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);\n  const p2 \
= vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);\n  const \
p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);\n  \
const a2 = g0(fuv.y).mul(add4(g0x.mul(textureNode.uv(p0).level(lod)), \
g1x.mul(textureNode.uv(p1).level(lod))));\n  const b = \
g1(fuv.y).mul(add4(g0x.mul(textureNode.uv(p2).level(lod)), \
g1x.mul(textureNode.uv(p3).level(lod))));\n  return a2.add(b);\n};\nvar \
textureBicubic = /* @__PURE__ */ Fn(([textureNode, lodNode = float(3)]) => \
{\n  const fLodSize = vec2(textureNode.size(int(lodNode)));\n  const cLodSize \
= vec2(textureNode.size(int(lodNode.add(1))));\n  const fLodSizeInv = div(1, \
fLodSize);\n  const cLodSizeInv = div(1, cLodSize);\n  const fSample = \
bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));\n  const \
cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));\n \
 return fract(lodNode).mix(fSample, cSample);\n});\nvar \
getVolumeTransmissionRay = /* @__PURE__ */ Fn(([n, v, thickness2, ior2, \
modelMatrix]) => {\n  const refractionVector = vec3(refract(v.negate(), \
normalize2(n), div(1, ior2)));\n  const modelScale2 = vec3(\n    \
length(modelMatrix[0].xyz),\n    length(modelMatrix[1].xyz),\n    \
length(modelMatrix[2].xyz)\n  );\n  return \
normalize2(refractionVector).mul(thickness2.mul(modelScale2));\n}).setLayout(\
{\n  name: \"getVolumeTransmissionRay\",\n  type: \"vec3\",\n  inputs: [\n    \
{ name: \"n\", type: \"vec3\" },\n    { name: \"v\", type: \"vec3\" },\n    { \
name: \"thickness\", type: \"float\" },\n    { name: \"ior\", type: \"float\" \
},\n    { name: \"modelMatrix\", type: \"mat4\" }\n  ]\n});\nvar \
applyIorToRoughness = /* @__PURE__ */ Fn(([roughness2, ior2]) => {\n  return \
roughness2.mul(clamp2(ior2.mul(2).sub(2), 0, 1));\n}).setLayout({\n  name: \
\"applyIorToRoughness\",\n  type: \"float\",\n  inputs: [\n    { name: \
\"roughness\", type: \"float\" },\n    { name: \"ior\", type: \"float\" }\n  \
]\n});\nvar viewportBackSideTexture = /* @__PURE__ */ \
viewportMipTexture();\nvar viewportFrontSideTexture = /* @__PURE__ */ \
viewportMipTexture();\nvar getTransmissionSample = /* @__PURE__ */ \
Fn(([fragCoord, roughness2, ior2], { material }) => {\n  const vTexture = \
material.side == BackSide2 ? viewportBackSideTexture : \
viewportFrontSideTexture;\n  const transmissionSample = \
vTexture.uv(fragCoord);\n  const lod = \
log2(screenSize.x).mul(applyIorToRoughness(roughness2, ior2));\n  return \
textureBicubic(transmissionSample, lod);\n});\nvar volumeAttenuation = /* \
@__PURE__ */ Fn(([transmissionDistance, attenuationColor2, \
attenuationDistance2]) => {\n  If(attenuationDistance2.notEqual(0), () => {\n \
   const attenuationCoefficient = \
log(attenuationColor2).negate().div(attenuationDistance2);\n    const \
transmittance = \
exp(attenuationCoefficient.negate().mul(transmissionDistance));\n    return \
transmittance;\n  });\n  return vec3(1);\n}).setLayout({\n  name: \
\"volumeAttenuation\",\n  type: \"vec3\",\n  inputs: [\n    { name: \
\"transmissionDistance\", type: \"float\" },\n    { name: \
\"attenuationColor\", type: \"vec3\" },\n    { name: \"attenuationDistance\", \
type: \"float\" }\n  ]\n});\nvar getIBLVolumeRefraction = /* @__PURE__ */ \
Fn(([n, v, roughness2, diffuseColor2, specularColor2, specularF902, position, \
modelMatrix, viewMatrix, projMatrix, ior2, thickness2, attenuationColor2, \
attenuationDistance2, dispersion2]) => {\n  let transmittedLight, \
transmittance;\n  if (dispersion2) {\n    transmittedLight = \
vec4().toVar();\n    transmittance = vec3().toVar();\n    const halfSpread = \
ior2.sub(1).mul(dispersion2.mul(0.025));\n    const iors = \
vec3(ior2.sub(halfSpread), ior2, ior2.add(halfSpread));\n    Loop({ start: 0, \
end: 3 }, ({ i }) => {\n      const ior3 = iors.element(i);\n      const \
transmissionRay = getVolumeTransmissionRay(n, v, thickness2, ior3, \
modelMatrix);\n      const refractedRayExit = \
position.add(transmissionRay);\n      const ndcPos = \
projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));\n      const \
refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();\n      \
refractionCoords.addAssign(1);\n      refractionCoords.divAssign(2);\n      \
refractionCoords.assign(vec2(refractionCoords.x, \
refractionCoords.y.oneMinus()));\n      const transmissionSample = \
getTransmissionSample(refractionCoords, roughness2, ior3);\n      \
transmittedLight.element(i).assign(transmissionSample.element(i));\n      \
transmittedLight.a.addAssign(transmissionSample.a);\n      \
transmittance.element(i).assign(diffuseColor2.element(i).mul(volumeAttenuatio\
n(length(transmissionRay), attenuationColor2, \
attenuationDistance2).element(i)));\n    });\n    \
transmittedLight.a.divAssign(3);\n  } else {\n    const transmissionRay = \
getVolumeTransmissionRay(n, v, thickness2, ior2, modelMatrix);\n    const \
refractedRayExit = position.add(transmissionRay);\n    const ndcPos = \
projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));\n    const \
refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();\n    \
refractionCoords.addAssign(1);\n    refractionCoords.divAssign(2);\n    \
refractionCoords.assign(vec2(refractionCoords.x, \
refractionCoords.y.oneMinus()));\n    transmittedLight = \
getTransmissionSample(refractionCoords, roughness2, ior2);\n    transmittance \
= diffuseColor2.mul(volumeAttenuation(length(transmissionRay), \
attenuationColor2, attenuationDistance2));\n  }\n  const attenuatedColor = \
transmittance.rgb.mul(transmittedLight.rgb);\n  const dotNV = \
n.dot(v).clamp();\n  const F = vec3(EnvironmentBRDF({\n    // n, v, \
specularColor, specularF90, roughness\n    dotNV,\n    specularColor: \
specularColor2,\n    specularF90: specularF902,\n    roughness: roughness2\n  \
}));\n  const transmittanceFactor = transmittance.r.add(transmittance.g, \
transmittance.b).div(3);\n  return vec4(F.oneMinus().mul(attenuatedColor), \
transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());\n});\nvar \
XYZ_TO_REC709 = /* @__PURE__ */ mat3(\n  3.2404542,\n  -0.969266,\n  \
0.0556434,\n  -1.5371385,\n  1.8760108,\n  -0.2040259,\n  -0.4985314,\n  \
0.041556,\n  1.0572252\n);\nvar Fresnel0ToIor = (fresnel0) => {\n  const \
sqrtF0 = fresnel0.sqrt();\n  return \
vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0));\n};\nvar IorToFresnel0 = \
(transmittedIor, incidentIor) => {\n  return \
transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();\
\n};\nvar evalSensitivity = (OPD, shift) => {\n  const phase = OPD.mul(2 * \
Math.PI * 1e-9);\n  const val = vec3(54856e-17, 44201e-17, 52481e-17);\n  \
const pos = vec3(1681e3, 1795300, 2208400);\n  const VAR = vec3(43278e5, \
93046e5, 66121e5);\n  const x2 = float(9747e-17 * Math.sqrt(2 * Math.PI * \
45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45\
282e5).exp());\n  let xyz = val.mul(VAR.mul(2 * \
Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate\
().mul(VAR).exp());\n  xyz = vec3(xyz.x.add(x2), xyz.y, \
xyz.z).div(10685e-11);\n  const rgb2 = XYZ_TO_REC709.mul(xyz);\n  return \
rgb2;\n};\nvar evalIridescence = /* @__PURE__ */ Fn(({ outsideIOR, eta2, \
cosTheta1, thinFilmThickness, baseF0 }) => {\n  const iridescenceIOR2 = \
mix(outsideIOR, eta2, smoothstep2(0, 0.03, thinFilmThickness));\n  const \
sinTheta2Sq = \
outsideIOR.div(iridescenceIOR2).pow2().mul(cosTheta1.pow2().oneMinus());\n  \
const cosTheta2Sq = sinTheta2Sq.oneMinus();\n  If(cosTheta2Sq.lessThan(0), () \
=> {\n    return vec3(1);\n  });\n  const cosTheta2 = cosTheta2Sq.sqrt();\n  \
const R0 = IorToFresnel0(iridescenceIOR2, outsideIOR);\n  const R12 = \
F_Schlick({ f0: R0, f90: 1, dotVH: cosTheta1 });\n  const T121 = \
R12.oneMinus();\n  const phi12 = \
iridescenceIOR2.lessThan(outsideIOR).select(Math.PI, 0);\n  const phi21 = \
float(Math.PI).sub(phi12);\n  const baseIOR = Fresnel0ToIor(baseF0.clamp(0, \
0.9999));\n  const R1 = IorToFresnel0(baseIOR, iridescenceIOR2.toVec3());\n  \
const R23 = F_Schlick({ f0: R1, f90: 1, dotVH: cosTheta2 });\n  const phi23 = \
vec3(\n    baseIOR.x.lessThan(iridescenceIOR2).select(Math.PI, 0),\n    \
baseIOR.y.lessThan(iridescenceIOR2).select(Math.PI, 0),\n    \
baseIOR.z.lessThan(iridescenceIOR2).select(Math.PI, 0)\n  );\n  const OPD = \
iridescenceIOR2.mul(thinFilmThickness, cosTheta2, 2);\n  const phi = \
vec3(phi21).add(phi23);\n  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);\n  \
const r123 = R123.sqrt();\n  const Rs = \
T121.pow2().mul(R23).div(vec3(1).sub(R123));\n  const C0 = R12.add(Rs);\n  \
const I = C0.toVar();\n  const Cm = Rs.sub(T121).toVar();\n  Loop({ start: 1, \
end: 2, condition: \"<=\", name: \"m\" }, ({ m: m2 }) => {\n    \
Cm.mulAssign(r123);\n    const Sm = evalSensitivity(float(m2).mul(OPD), \
float(m2).mul(phi)).mul(2);\n    I.addAssign(Cm.mul(Sm));\n  });\n  return \
I.max(vec3(0));\n}).setLayout({\n  name: \"evalIridescence\",\n  type: \
\"vec3\",\n  inputs: [\n    { name: \"outsideIOR\", type: \"float\" },\n    { \
name: \"eta2\", type: \"float\" },\n    { name: \"cosTheta1\", type: \
\"float\" },\n    { name: \"thinFilmThickness\", type: \"float\" },\n    { \
name: \"baseF0\", type: \"vec3\" }\n  ]\n});\nvar IBLSheenBRDF = /* @__PURE__ \
*/ Fn(({ normal: normal2, viewDir, roughness: roughness2 }) => {\n  const \
dotNV = normal2.dot(viewDir).saturate();\n  const r2 = roughness2.pow2();\n  \
const a2 = select(\n    roughness2.lessThan(0.25),\n    \
float(-339.2).mul(r2).add(float(161.4).mul(roughness2)).sub(25.9),\n    \
float(-8.48).mul(r2).add(float(14.3).mul(roughness2)).sub(9.95)\n  );\n  \
const b = select(\n    roughness2.lessThan(0.25),\n    \
float(44).mul(r2).sub(float(23.7).mul(roughness2)).add(3.26),\n    \
float(1.97).mul(r2).sub(float(3.27).mul(roughness2)).add(0.72)\n  );\n  const \
DG = select(roughness2.lessThan(0.25), 0, \
float(0.1).mul(roughness2).sub(0.025)).add(a2.mul(dotNV).add(b).exp());\n  \
return DG.mul(1 / Math.PI).saturate();\n});\nvar clearcoatF0 = \
vec3(0.04);\nvar clearcoatF90 = float(1);\nvar PhysicalLightingModel = class \
extends LightingModel {\n  constructor(clearcoat2 = false, sheen2 = false, \
iridescence2 = false, anisotropy2 = false, transmission2 = false, dispersion2 \
= false) {\n    super();\n    this.clearcoat = clearcoat2;\n    this.sheen = \
sheen2;\n    this.iridescence = iridescence2;\n    this.anisotropy = \
anisotropy2;\n    this.transmission = transmission2;\n    this.dispersion = \
dispersion2;\n    this.clearcoatRadiance = null;\n    \
this.clearcoatSpecularDirect = null;\n    this.clearcoatSpecularIndirect = \
null;\n    this.sheenSpecularDirect = null;\n    this.sheenSpecularIndirect = \
null;\n    this.iridescenceFresnel = null;\n    this.iridescenceF0 = null;\n  \
}\n  start(context2) {\n    if (this.clearcoat === true) {\n      \
this.clearcoatRadiance = vec3().toVar(\"clearcoatRadiance\");\n      \
this.clearcoatSpecularDirect = vec3().toVar(\"clearcoatSpecularDirect\");\n   \
   this.clearcoatSpecularIndirect = \
vec3().toVar(\"clearcoatSpecularIndirect\");\n    }\n    if (this.sheen === \
true) {\n      this.sheenSpecularDirect = \
vec3().toVar(\"sheenSpecularDirect\");\n      this.sheenSpecularIndirect = \
vec3().toVar(\"sheenSpecularIndirect\");\n    }\n    if (this.iridescence === \
true) {\n      const dotNVi = \
transformedNormalView.dot(positionViewDirection).clamp();\n      \
this.iridescenceFresnel = evalIridescence({\n        outsideIOR: float(1),\n  \
      eta2: iridescenceIOR,\n        cosTheta1: dotNVi,\n        \
thinFilmThickness: iridescenceThickness,\n        baseF0: specularColor\n     \
 });\n      this.iridescenceF0 = Schlick_to_F0({ f: this.iridescenceFresnel, \
f90: 1, dotVH: dotNVi });\n    }\n    if (this.transmission === true) {\n     \
 const position = positionWorld;\n      const v = \
cameraPosition.sub(positionWorld).normalize();\n      const n = \
transformedNormalWorld;\n      context2.backdrop = getIBLVolumeRefraction(\n  \
      n,\n        v,\n        roughness,\n        diffuseColor,\n        \
specularColor,\n        specularF90,\n        // specularF90\n        \
position,\n        // positionWorld\n        modelWorldMatrix,\n        // \
modelMatrix\n        cameraViewMatrix,\n        // viewMatrix\n        \
cameraProjectionMatrix,\n        // projMatrix\n        ior,\n        \
thickness,\n        attenuationColor,\n        attenuationDistance,\n        \
this.dispersion ? dispersion : null\n      );\n      context2.backdropAlpha = \
transmission;\n      diffuseColor.a.mulAssign(mix(1, context2.backdrop.a, \
transmission));\n    }\n  }\n  // Fdez-Ag\[CapitalATilde]\274era's \
\"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n \
 // Approximates multiscattering in order to preserve energy.\n  // \
http://www.jcgt.org/published/0008/01/03/\n  \
computeMultiscattering(singleScatter, multiScatter, specularF902) {\n    \
const dotNV = transformedNormalView.dot(positionViewDirection).clamp();\n    \
const fab = DFGApprox({ roughness, dotNV });\n    const Fr = \
this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : \
specularColor;\n    const FssEss = \
Fr.mul(fab.x).add(specularF902.mul(fab.y));\n    const Ess = \
fab.x.add(fab.y);\n    const Ems = Ess.oneMinus();\n    const Favg = \
specularColor.add(specularColor.oneMinus().mul(0.047619));\n    const Fms = \
FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());\n    \
singleScatter.addAssign(FssEss);\n    multiScatter.addAssign(Fms.mul(Ems));\n \
 }\n  direct({ lightDirection, lightColor, reflectedLight }) {\n    const \
dotNL = transformedNormalView.dot(lightDirection).clamp();\n    const \
irradiance = dotNL.mul(lightColor);\n    if (this.sheen === true) {\n      \
this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({ lightDirection \
})));\n    }\n    if (this.clearcoat === true) {\n      const dotNLcc = \
transformedClearcoatNormalView.dot(lightDirection).clamp();\n      const \
ccIrradiance = dotNLcc.mul(lightColor);\n      \
this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX({ \
lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: \
clearcoatRoughness, normalView: transformedClearcoatNormalView })));\n    }\n \
   reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ \
diffuseColor: diffuseColor.rgb })));\n    \
reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX({ \
lightDirection, f0: specularColor, f90: 1, roughness, iridescence: \
this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: \
this.iridescence, USE_ANISOTROPY: this.anisotropy })));\n  }\n  \
directRectArea({ lightColor, lightPosition: lightPosition2, halfWidth, \
halfHeight, reflectedLight, ltc_1, ltc_2 }) {\n    const p0 = \
lightPosition2.add(halfWidth).sub(halfHeight);\n    const p1 = \
lightPosition2.sub(halfWidth).sub(halfHeight);\n    const p2 = \
lightPosition2.sub(halfWidth).add(halfHeight);\n    const p3 = \
lightPosition2.add(halfWidth).add(halfHeight);\n    const N = \
transformedNormalView;\n    const V = positionViewDirection;\n    const P = \
positionView.toVar();\n    const uv2 = LTC_Uv({ N, V, roughness });\n    \
const t1 = ltc_1.uv(uv2).toVar();\n    const t2 = ltc_2.uv(uv2).toVar();\n    \
const mInv = mat3(\n      vec3(t1.x, 0, t1.y),\n      vec3(0, 1, 0),\n      \
vec3(t1.z, 0, t1.w)\n    ).toVar();\n    const fresnel = \
specularColor.mul(t2.x).add(specularColor.oneMinus().mul(t2.y)).toVar();\n    \
reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evalu\
ate({ N, V, P, mInv, p0, p1, p2, p3 })));\n    \
reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseColor).mul(LTC_E\
valuate({ N, V, P, mInv: mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p0, p1, p2, p3 \
})));\n  }\n  indirect(context2, stack2, builder) {\n    \
this.indirectDiffuse(context2, stack2, builder);\n    \
this.indirectSpecular(context2, stack2, builder);\n    \
this.ambientOcclusion(context2, stack2, builder);\n  }\n  indirectDiffuse({ \
irradiance, reflectedLight }) {\n    \
reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ \
diffuseColor })));\n  }\n  indirectSpecular({ radiance, iblIrradiance, \
reflectedLight }) {\n    if (this.sheen === true) {\n      \
this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(\n        sheen,\n     \
   IBLSheenBRDF({\n          normal: transformedNormalView,\n          \
viewDir: positionViewDirection,\n          roughness: sheenRoughness\n        \
})\n      ));\n    }\n    if (this.clearcoat === true) {\n      const dotNVcc \
= transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      \
const clearcoatEnv = EnvironmentBRDF({\n        dotNV: dotNVcc,\n        \
specularColor: clearcoatF0,\n        specularF90: clearcoatF90,\n        \
roughness: clearcoatRoughness\n      });\n      \
this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoat\
Env));\n    }\n    const singleScattering = \
vec3().toVar(\"singleScattering\");\n    const multiScattering = \
vec3().toVar(\"multiScattering\");\n    const cosineWeightedIrradiance = \
iblIrradiance.mul(1 / Math.PI);\n    \
this.computeMultiscattering(singleScattering, multiScattering, \
specularF90);\n    const totalScattering = \
singleScattering.add(multiScattering);\n    const diffuse = \
diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering\
.b).oneMinus());\n    \
reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));\n  \
  \
reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedI\
rradiance));\n    \
reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance\
));\n  }\n  ambientOcclusion({ ambientOcclusion, reflectedLight }) {\n    \
const dotNV = transformedNormalView.dot(positionViewDirection).clamp();\n    \
const aoNV = dotNV.add(ambientOcclusion);\n    const aoExp = \
roughness.mul(-16).oneMinus().negate().exp2();\n    const aoNode = \
ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();\n    if \
(this.clearcoat === true) {\n      \
this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);\n    }\n    if \
(this.sheen === true) {\n      \
this.sheenSpecularIndirect.mulAssign(ambientOcclusion);\n    }\n    \
reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n    \
reflectedLight.indirectSpecular.mulAssign(aoNode);\n  }\n  finish(context2) \
{\n    const { outgoingLight } = context2;\n    if (this.clearcoat === true) \
{\n      const dotNVcc = \
transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      \
const Fcc = F_Schlick({\n        dotVH: dotNVcc,\n        f0: clearcoatF0,\n  \
      f90: clearcoatF90\n      });\n      const clearcoatLight = \
outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDi\
rect.add(this.clearcoatSpecularIndirect).mul(clearcoat));\n      \
outgoingLight.assign(clearcoatLight);\n    }\n    if (this.sheen === true) \
{\n      const sheenEnergyComp = \
sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();\n      const \
sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, \
this.sheenSpecularIndirect);\n      outgoingLight.assign(sheenLight);\n    \
}\n  }\n};\nvar cubeUV_r0 = /* @__PURE__ */ float(1);\nvar cubeUV_m0 = /* \
@__PURE__ */ float(-2);\nvar cubeUV_r1 = /* @__PURE__ */ float(0.8);\nvar \
cubeUV_m1 = /* @__PURE__ */ float(-1);\nvar cubeUV_r4 = /* @__PURE__ */ \
float(0.4);\nvar cubeUV_m4 = /* @__PURE__ */ float(2);\nvar cubeUV_r5 = /* \
@__PURE__ */ float(0.305);\nvar cubeUV_m5 = /* @__PURE__ */ float(3);\nvar \
cubeUV_r6 = /* @__PURE__ */ float(0.21);\nvar cubeUV_m6 = /* @__PURE__ */ \
float(4);\nvar cubeUV_minMipLevel = /* @__PURE__ */ float(4);\nvar \
cubeUV_minTileSize = /* @__PURE__ */ float(16);\nvar getFace = /* @__PURE__ \
*/ Fn(([direction2]) => {\n  const absDirection = \
vec3(abs(direction2)).toVar();\n  const face = float(-1).toVar();\n  \
If(absDirection.x.greaterThan(absDirection.z), () => {\n    \
If(absDirection.x.greaterThan(absDirection.y), () => {\n      \
face.assign(select(direction2.x.greaterThan(0), 0, 3));\n    }).Else(() => \
{\n      face.assign(select(direction2.y.greaterThan(0), 1, 4));\n    });\n  \
}).Else(() => {\n    If(absDirection.z.greaterThan(absDirection.y), () => {\n \
     face.assign(select(direction2.z.greaterThan(0), 2, 5));\n    }).Else(() \
=> {\n      face.assign(select(direction2.y.greaterThan(0), 1, 4));\n    \
});\n  });\n  return face;\n}).setLayout({\n  name: \"getFace\",\n  type: \
\"float\",\n  inputs: [\n    { name: \"direction\", type: \"vec3\" }\n  \
]\n});\nvar getUV = /* @__PURE__ */ Fn(([direction2, face]) => {\n  const uv2 \
= vec2().toVar();\n  If(face.equal(0), () => {\n    \
uv2.assign(vec2(direction2.z, direction2.y).div(abs(direction2.x)));\n  \
}).ElseIf(face.equal(1), () => {\n    uv2.assign(vec2(direction2.x.negate(), \
direction2.z.negate()).div(abs(direction2.y)));\n  }).ElseIf(face.equal(2), \
() => {\n    uv2.assign(vec2(direction2.x.negate(), \
direction2.y).div(abs(direction2.z)));\n  }).ElseIf(face.equal(3), () => {\n  \
  uv2.assign(vec2(direction2.z.negate(), \
direction2.y).div(abs(direction2.x)));\n  }).ElseIf(face.equal(4), () => {\n  \
  uv2.assign(vec2(direction2.x.negate(), \
direction2.z).div(abs(direction2.y)));\n  }).Else(() => {\n    \
uv2.assign(vec2(direction2.x, direction2.y).div(abs(direction2.z)));\n  });\n \
 return mul(0.5, uv2.add(1));\n}).setLayout({\n  name: \"getUV\",\n  type: \
\"vec2\",\n  inputs: [\n    { name: \"direction\", type: \"vec3\" },\n    { \
name: \"face\", type: \"float\" }\n  ]\n});\nvar roughnessToMip = /* \
@__PURE__ */ Fn(([roughness2]) => {\n  const mip = float(0).toVar();\n  \
If(roughness2.greaterThanEqual(cubeUV_r1), () => {\n    \
mip.assign(cubeUV_r0.sub(roughness2).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV\
_r0.sub(cubeUV_r1)).add(cubeUV_m0));\n  \
}).ElseIf(roughness2.greaterThanEqual(cubeUV_r4), () => {\n    \
mip.assign(cubeUV_r1.sub(roughness2).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV\
_r1.sub(cubeUV_r4)).add(cubeUV_m1));\n  \
}).ElseIf(roughness2.greaterThanEqual(cubeUV_r5), () => {\n    \
mip.assign(cubeUV_r4.sub(roughness2).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV\
_r4.sub(cubeUV_r5)).add(cubeUV_m4));\n  \
}).ElseIf(roughness2.greaterThanEqual(cubeUV_r6), () => {\n    \
mip.assign(cubeUV_r5.sub(roughness2).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV\
_r5.sub(cubeUV_r6)).add(cubeUV_m5));\n  }).Else(() => {\n    \
mip.assign(float(-2).mul(log2(mul(1.16, roughness2))));\n  });\n  return \
mip;\n}).setLayout({\n  name: \"roughnessToMip\",\n  type: \"float\",\n  \
inputs: [\n    { name: \"roughness\", type: \"float\" }\n  ]\n});\nvar \
getDirection = /* @__PURE__ */ Fn(([uv_immutable, face]) => {\n  const uv2 = \
uv_immutable.toVar();\n  uv2.assign(mul(2, uv2).sub(1));\n  const direction2 \
= vec3(uv2, 1).toVar();\n  If(face.equal(0), () => {\n    \
direction2.assign(direction2.zyx);\n  }).ElseIf(face.equal(1), () => {\n    \
direction2.assign(direction2.xzy);\n    direction2.xz.mulAssign(-1);\n  \
}).ElseIf(face.equal(2), () => {\n    direction2.x.mulAssign(-1);\n  \
}).ElseIf(face.equal(3), () => {\n    direction2.assign(direction2.zyx);\n    \
direction2.xz.mulAssign(-1);\n  }).ElseIf(face.equal(4), () => {\n    \
direction2.assign(direction2.xzy);\n    direction2.xy.mulAssign(-1);\n  \
}).ElseIf(face.equal(5), () => {\n    direction2.z.mulAssign(-1);\n  });\n  \
return direction2;\n}).setLayout({\n  name: \"getDirection\",\n  type: \
\"vec3\",\n  inputs: [\n    { name: \"uv\", type: \"vec2\" },\n    { name: \
\"face\", type: \"float\" }\n  ]\n});\nvar textureCubeUV = /* @__PURE__ */ \
Fn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, \
CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {\n  const roughness2 = \
float(roughness_immutable);\n  const sampleDir = vec3(sampleDir_immutable);\n \
 const mip = clamp2(roughnessToMip(roughness2), cubeUV_m0, CUBEUV_MAX_MIP);\n \
 const mipF = fract(mip);\n  const mipInt = floor(mip);\n  const color0 = \
vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, \
CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n  If(mipF.notEqual(0), () => \
{\n    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1), \
CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n    \
color0.assign(mix(color0, color1, mipF));\n  });\n  return color0;\n});\nvar \
bilinearCubeUV = /* @__PURE__ */ Fn(([envMap, direction_immutable, \
mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) \
=> {\n  const mipInt = float(mipInt_immutable).toVar();\n  const direction2 = \
vec3(direction_immutable);\n  const face = \
float(getFace(direction2)).toVar();\n  const filterInt = \
float(max$1(cubeUV_minMipLevel.sub(mipInt), 0)).toVar();\n  \
mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));\n  const faceSize = \
float(exp2(mipInt)).toVar();\n  const uv2 = vec2(getUV(direction2, \
face).mul(faceSize.sub(2)).add(1)).toVar();\n  If(face.greaterThan(2), () => \
{\n    uv2.y.addAssign(faceSize);\n    face.subAssign(3);\n  });\n  \
uv2.x.addAssign(face.mul(faceSize));\n  uv2.x.addAssign(filterInt.mul(mul(3, \
cubeUV_minTileSize)));\n  uv2.y.addAssign(mul(4, \
exp2(CUBEUV_MAX_MIP).sub(faceSize)));\n  \
uv2.x.mulAssign(CUBEUV_TEXEL_WIDTH);\n  \
uv2.y.mulAssign(CUBEUV_TEXEL_HEIGHT);\n  return envMap.uv(uv2).grad(vec2(), \
vec2());\n});\nvar getSample = /* @__PURE__ */ Fn(({ envMap, mipInt, \
outputDirection: outputDirection2, theta, axis, CUBEUV_TEXEL_WIDTH, \
CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {\n  const cosTheta = cos(theta);\n \
 const sampleDirection = \
outputDirection2.mul(cosTheta).add(axis.cross(outputDirection2).mul(sin(theta\
))).add(axis.mul(axis.dot(outputDirection2).mul(cosTheta.oneMinus())));\n  \
return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, \
CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);\n});\nvar blur = /* @__PURE__ */ Fn(({ \
n, latitudinal, poleAxis, outputDirection: outputDirection2, weights, \
samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, \
CUBEUV_MAX_MIP }) => {\n  const axis = vec3(select(latitudinal, poleAxis, \
cross(poleAxis, outputDirection2))).toVar();\n  If(all(axis.equals(vec3(0))), \
() => {\n    axis.assign(vec3(outputDirection2.z, 0, \
outputDirection2.x.negate()));\n  });\n  axis.assign(normalize2(axis));\n  \
const gl_FragColor = vec3().toVar();\n  \
gl_FragColor.addAssign(weights.element(int(0)).mul(getSample({ theta: 0, \
axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, \
CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));\n  Loop({ start: int(1), end: n }, \
({ i }) => {\n    If(i.greaterThanEqual(samples), () => {\n      Break();\n   \
 });\n    const theta = float(dTheta.mul(float(i))).toVar();\n    \
gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta: \
theta.mul(-1), axis, outputDirection: outputDirection2, mipInt, envMap, \
CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));\n    \
gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta, axis, \
outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, \
CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));\n  });\n  return vec4(gl_FragColor, \
1);\n});\nvar _generator = null;\nvar _cache2 = /* @__PURE__ */ new \
WeakMap();\nfunction _generateCubeUVSize(imageHeight) {\n  const maxMip = \
Math.log2(imageHeight) - 2;\n  const texelHeight = 1 / imageHeight;\n  const \
texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n  return { \
texelWidth, texelHeight, maxMip };\n}\nfunction \
_getPMREMFromTexture(texture2) {\n  let cacheTexture = \
_cache2.get(texture2);\n  const pmremVersion = cacheTexture !== void 0 ? \
cacheTexture.pmremVersion : -1;\n  if (pmremVersion !== \
texture2.pmremVersion) {\n    const image = texture2.image;\n    if \
(texture2.isCubeTexture) {\n      if (isCubeMapReady(image)) {\n        \
cacheTexture = _generator.fromCubemap(texture2, cacheTexture);\n      } else \
{\n        return null;\n      }\n    } else {\n      if \
(isEquirectangularMapReady(image)) {\n        cacheTexture = \
_generator.fromEquirectangular(texture2, cacheTexture);\n      } else {\n     \
   return null;\n      }\n    }\n    cacheTexture.pmremVersion = \
texture2.pmremVersion;\n    _cache2.set(texture2, cacheTexture);\n  }\n  \
return cacheTexture.texture;\n}\nvar PMREMNode = class extends TempNode {\n  \
static get type() {\n    return \"PMREMNode\";\n  }\n  constructor(value, \
uvNode = null, levelNode = null) {\n    super(\"vec3\");\n    this._value = \
value;\n    this._pmrem = null;\n    this.uvNode = uvNode;\n    \
this.levelNode = levelNode;\n    this._generator = null;\n    const \
defaultTexture = new Texture2();\n    defaultTexture.isRenderTargetTexture = \
true;\n    this._texture = texture(defaultTexture);\n    this._width = \
uniform(0);\n    this._height = uniform(0);\n    this._maxMip = uniform(0);\n \
   this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  set value(value) \
{\n    this._value = value;\n    this._pmrem = null;\n  }\n  get value() {\n  \
  return this._value;\n  }\n  updateFromTexture(texture2) {\n    const \
cubeUVSize = _generateCubeUVSize(texture2.image.height);\n    \
this._texture.value = texture2;\n    this._width.value = \
cubeUVSize.texelWidth;\n    this._height.value = cubeUVSize.texelHeight;\n    \
this._maxMip.value = cubeUVSize.maxMip;\n  }\n  updateBefore() {\n    let \
pmrem = this._pmrem;\n    const pmremVersion = pmrem ? pmrem.pmremVersion : \
-1;\n    const texture2 = this._value;\n    if (pmremVersion !== \
texture2.pmremVersion) {\n      if (texture2.isPMREMTexture === true) {\n     \
   pmrem = texture2;\n      } else {\n        pmrem = \
_getPMREMFromTexture(texture2);\n      }\n      if (pmrem !== null) {\n       \
 this._pmrem = pmrem;\n        this.updateFromTexture(pmrem);\n      }\n    \
}\n  }\n  setup(builder) {\n    if (_generator === null) {\n      _generator \
= builder.createPMREMGenerator();\n    }\n    this.updateBefore(builder);\n   \
 let uvNode = this.uvNode;\n    if (uvNode === null && builder.context.getUV) \
{\n      uvNode = builder.context.getUV(this);\n    }\n    const texture2 = \
this.value;\n    if (builder.renderer.coordinateSystem === \
WebGLCoordinateSystem2 && texture2.isPMREMTexture !== true && \
texture2.isRenderTargetTexture === true) {\n      uvNode = \
vec3(uvNode.x.negate(), uvNode.yz);\n    }\n    let levelNode = \
this.levelNode;\n    if (levelNode === null && \
builder.context.getTextureLevel) {\n      levelNode = \
builder.context.getTextureLevel(this);\n    }\n    return \
textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, \
this._maxMip);\n  }\n};\nfunction isCubeMapReady(image) {\n  if (image === \
null || image === void 0) return false;\n  let count = 0;\n  const length2 = \
6;\n  for (let i = 0; i < length2; i++) {\n    if (image[i] !== void 0) \
count++;\n  }\n  return count === length2;\n}\nfunction \
isEquirectangularMapReady(image) {\n  if (image === null || image === void 0) \
return false;\n  return image.height > 0;\n}\nvar pmremTexture = /* @__PURE__ \
*/ nodeProxy(PMREMNode);\nvar _envNodeCache = /* @__PURE__ */ new \
WeakMap();\nvar EnvironmentNode = class extends LightingNode {\n  static get \
type() {\n    return \"EnvironmentNode\";\n  }\n  constructor(envNode = null) \
{\n    super();\n    this.envNode = envNode;\n  }\n  setup(builder) {\n    \
const { material } = builder;\n    let envNode = this.envNode;\n    if \
(envNode.isTextureNode || envNode.isMaterialReferenceNode) {\n      const \
value = envNode.isTextureNode ? envNode.value : material[envNode.property];\n \
     let cacheEnvNode = _envNodeCache.get(value);\n      if (cacheEnvNode === \
void 0) {\n        cacheEnvNode = pmremTexture(value);\n        \
_envNodeCache.set(value, cacheEnvNode);\n      }\n      envNode = \
cacheEnvNode;\n    }\n    const envMap = material.envMap;\n    const \
intensity = envMap ? reference(\"envMapIntensity\", \"float\", \
builder.material) : reference(\"environmentIntensity\", \"float\", \
builder.scene);\n    const useAnisotropy = material.useAnisotropy === true || \
material.anisotropy > 0;\n    const radianceNormalView = useAnisotropy ? \
transformedBentNormalView : transformedNormalView;\n    const radiance = \
envNode.context(createRadianceContext(roughness, \
radianceNormalView)).mul(intensity);\n    const irradiance = \
envNode.context(createIrradianceContext(transformedNormalWorld)).mul(Math.PI)\
.mul(intensity);\n    const isolateRadiance = cache(radiance);\n    const \
isolateIrradiance = cache(irradiance);\n    \
builder.context.radiance.addAssign(isolateRadiance);\n    \
builder.context.iblIrradiance.addAssign(isolateIrradiance);\n    const \
clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n    if \
(clearcoatRadiance) {\n      const clearcoatRadianceContext = \
envNode.context(createRadianceContext(clearcoatRoughness, \
transformedClearcoatNormalView)).mul(intensity);\n      const \
isolateClearcoatRadiance = cache(clearcoatRadianceContext);\n      \
clearcoatRadiance.addAssign(isolateClearcoatRadiance);\n    }\n  }\n};\nvar \
createRadianceContext = (roughnessNode, normalViewNode) => {\n  let \
reflectVec = null;\n  return {\n    getUV: () => {\n      if (reflectVec === \
null) {\n        reflectVec = \
positionViewDirection.negate().reflect(normalViewNode);\n        reflectVec = \
roughnessNode.mul(roughnessNode).mix(reflectVec, \
normalViewNode).normalize();\n        reflectVec = \
reflectVec.transformDirection(cameraViewMatrix);\n      }\n      return \
reflectVec;\n    },\n    getTextureLevel: () => {\n      return \
roughnessNode;\n    }\n  };\n};\nvar createIrradianceContext = \
(normalWorldNode) => {\n  return {\n    getUV: () => {\n      return \
normalWorldNode;\n    },\n    getTextureLevel: () => {\n      return \
float(1);\n    }\n  };\n};\nvar _defaultValues$6 = /* @__PURE__ */ new \
MeshStandardMaterial();\nvar MeshStandardNodeMaterial = class extends \
NodeMaterial {\n  static get type() {\n    return \
\"MeshStandardNodeMaterial\";\n  }\n  constructor(parameters) {\n    \
super();\n    this.isMeshStandardNodeMaterial = true;\n    this.lights = \
true;\n    this.emissiveNode = null;\n    this.metalnessNode = null;\n    \
this.roughnessNode = null;\n    this.setDefaultValues(_defaultValues$6);\n    \
this.setValues(parameters);\n  }\n  setupEnvironment(builder) {\n    let \
envNode = super.setupEnvironment(builder);\n    if (envNode === null && \
builder.environmentNode) {\n      envNode = builder.environmentNode;\n    }\n \
   return envNode ? new EnvironmentNode(envNode) : null;\n  }\n  \
setupLightingModel() {\n    return new PhysicalLightingModel();\n  }\n  \
setupSpecular() {\n    const specularColorNode = mix(vec3(0.04), \
diffuseColor.rgb, metalness);\n    specularColor.assign(specularColorNode);\n \
   specularF90.assign(1);\n  }\n  setupVariants() {\n    const metalnessNode \
= this.metalnessNode ? float(this.metalnessNode) : materialMetalness;\n    \
metalness.assign(metalnessNode);\n    let roughnessNode = this.roughnessNode \
? float(this.roughnessNode) : materialRoughness;\n    roughnessNode = \
getRoughness({ roughness: roughnessNode });\n    \
roughness.assign(roughnessNode);\n    this.setupSpecular();\n    \
diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), \
diffuseColor.a));\n  }\n  copy(source) {\n    this.emissiveNode = \
source.emissiveNode;\n    this.metalnessNode = source.metalnessNode;\n    \
this.roughnessNode = source.roughnessNode;\n    return super.copy(source);\n  \
}\n};\nvar _defaultValues$5 = /* @__PURE__ */ new \
MeshPhysicalMaterial();\nvar MeshPhysicalNodeMaterial = class extends \
MeshStandardNodeMaterial {\n  static get type() {\n    return \
\"MeshPhysicalNodeMaterial\";\n  }\n  constructor(parameters) {\n    \
super();\n    this.isMeshPhysicalNodeMaterial = true;\n    this.clearcoatNode \
= null;\n    this.clearcoatRoughnessNode = null;\n    \
this.clearcoatNormalNode = null;\n    this.sheenNode = null;\n    \
this.sheenRoughnessNode = null;\n    this.iridescenceNode = null;\n    \
this.iridescenceIORNode = null;\n    this.iridescenceThicknessNode = null;\n  \
  this.specularIntensityNode = null;\n    this.specularColorNode = null;\n    \
this.iorNode = null;\n    this.transmissionNode = null;\n    \
this.thicknessNode = null;\n    this.attenuationDistanceNode = null;\n    \
this.attenuationColorNode = null;\n    this.dispersionNode = null;\n    \
this.anisotropyNode = null;\n    this.setDefaultValues(_defaultValues$5);\n   \
 this.setValues(parameters);\n  }\n  get useClearcoat() {\n    return \
this.clearcoat > 0 || this.clearcoatNode !== null;\n  }\n  get \
useIridescence() {\n    return this.iridescence > 0 || this.iridescenceNode \
!== null;\n  }\n  get useSheen() {\n    return this.sheen > 0 || \
this.sheenNode !== null;\n  }\n  get useAnisotropy() {\n    return \
this.anisotropy > 0 || this.anisotropyNode !== null;\n  }\n  get \
useTransmission() {\n    return this.transmission > 0 || \
this.transmissionNode !== null;\n  }\n  get useDispersion() {\n    return \
this.dispersion > 0 || this.dispersionNode !== null;\n  }\n  setupSpecular() \
{\n    const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;\n    \
ior.assign(iorNode);\n    \
specularColor.assign(mix(min$1(pow2(ior.sub(1).div(ior.add(1))).mul(materialS\
pecularColor), vec3(1)).mul(materialSpecularIntensity), diffuseColor.rgb, \
metalness));\n    specularF90.assign(mix(materialSpecularIntensity, 1, \
metalness));\n  }\n  setupLightingModel() {\n    return new \
PhysicalLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, \
this.useAnisotropy, this.useTransmission, this.useDispersion);\n  }\n  \
setupVariants(builder) {\n    super.setupVariants(builder);\n    if \
(this.useClearcoat) {\n      const clearcoatNode = this.clearcoatNode ? \
float(this.clearcoatNode) : materialClearcoat;\n      const \
clearcoatRoughnessNode = this.clearcoatRoughnessNode ? \
float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;\n      \
clearcoat.assign(clearcoatNode);\n      \
clearcoatRoughness.assign(getRoughness({ roughness: clearcoatRoughnessNode \
}));\n    }\n    if (this.useSheen) {\n      const sheenNode = this.sheenNode \
? vec3(this.sheenNode) : materialSheen;\n      const sheenRoughnessNode = \
this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : \
materialSheenRoughness;\n      sheen.assign(sheenNode);\n      \
sheenRoughness.assign(sheenRoughnessNode);\n    }\n    if \
(this.useIridescence) {\n      const iridescenceNode = this.iridescenceNode ? \
float(this.iridescenceNode) : materialIridescence;\n      const \
iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) \
: materialIridescenceIOR;\n      const iridescenceThicknessNode = \
this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : \
materialIridescenceThickness;\n      iridescence.assign(iridescenceNode);\n   \
   iridescenceIOR.assign(iridescenceIORNode);\n      \
iridescenceThickness.assign(iridescenceThicknessNode);\n    }\n    if \
(this.useAnisotropy) {\n      const anisotropyV = (this.anisotropyNode ? \
vec2(this.anisotropyNode) : materialAnisotropy).toVar();\n      \
anisotropy.assign(anisotropyV.length());\n      If(anisotropy.equal(0), () => \
{\n        anisotropyV.assign(vec2(1, 0));\n      }).Else(() => {\n        \
anisotropyV.divAssign(vec2(anisotropy));\n        \
anisotropy.assign(anisotropy.saturate());\n      });\n      \
alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1));\n      \
anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].m\
ul(anisotropyV.y)));\n      \
anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].m\
ul(anisotropyV.y)));\n    }\n    if (this.useTransmission) {\n      const \
transmissionNode = this.transmissionNode ? float(this.transmissionNode) : \
materialTransmission;\n      const thicknessNode = this.thicknessNode ? \
float(this.thicknessNode) : materialThickness;\n      const \
attenuationDistanceNode = this.attenuationDistanceNode ? \
float(this.attenuationDistanceNode) : materialAttenuationDistance;\n      \
const attenuationColorNode = this.attenuationColorNode ? \
vec3(this.attenuationColorNode) : materialAttenuationColor;\n      \
transmission.assign(transmissionNode);\n      \
thickness.assign(thicknessNode);\n      \
attenuationDistance.assign(attenuationDistanceNode);\n      \
attenuationColor.assign(attenuationColorNode);\n      if (this.useDispersion) \
{\n        const dispersionNode = this.dispersionNode ? \
float(this.dispersionNode) : materialDispersion;\n        \
dispersion.assign(dispersionNode);\n      }\n    }\n  }\n  \
setupClearcoatNormal() {\n    return this.clearcoatNormalNode ? \
vec3(this.clearcoatNormalNode) : materialClearcoatNormal;\n  }\n  \
setup(builder) {\n    builder.context.setupClearcoatNormal = () => \
this.setupClearcoatNormal(builder);\n    super.setup(builder);\n  }\n  \
copy(source) {\n    this.clearcoatNode = source.clearcoatNode;\n    \
this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n    \
this.clearcoatNormalNode = source.clearcoatNormalNode;\n    this.sheenNode = \
source.sheenNode;\n    this.sheenRoughnessNode = source.sheenRoughnessNode;\n \
   this.iridescenceNode = source.iridescenceNode;\n    \
this.iridescenceIORNode = source.iridescenceIORNode;\n    \
this.iridescenceThicknessNode = source.iridescenceThicknessNode;\n    \
this.specularIntensityNode = source.specularIntensityNode;\n    \
this.specularColorNode = source.specularColorNode;\n    this.transmissionNode \
= source.transmissionNode;\n    this.thicknessNode = source.thicknessNode;\n  \
  this.attenuationDistanceNode = source.attenuationDistanceNode;\n    \
this.attenuationColorNode = source.attenuationColorNode;\n    \
this.dispersionNode = source.dispersionNode;\n    this.anisotropyNode = \
source.anisotropyNode;\n    return super.copy(source);\n  }\n};\nvar \
getGradientIrradiance = /* @__PURE__ */ Fn(({ normal: normal2, \
lightDirection, builder }) => {\n  const dotNL = \
normal2.dot(lightDirection);\n  const coord = vec2(dotNL.mul(0.5).add(0.5), \
0);\n  if (builder.material.gradientMap) {\n    const gradientMap = \
materialReference(\"gradientMap\", \"texture\").context({ getUV: () => coord \
});\n    return vec3(gradientMap.r);\n  } else {\n    const fw = \
coord.fwidth().mul(0.5);\n    return mix(vec3(0.7), vec3(1), \
smoothstep2(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));\n  \
}\n});\nvar ToonLightingModel = class extends LightingModel {\n  direct({ \
lightDirection, lightColor, reflectedLight }, stack2, builder) {\n    const \
irradiance = getGradientIrradiance({ normal: normalGeometry, lightDirection, \
builder }).mul(lightColor);\n    \
reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ \
diffuseColor: diffuseColor.rgb })));\n  }\n  indirect({ ambientOcclusion, \
irradiance, reflectedLight }) {\n    \
reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ \
diffuseColor })));\n    \
reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n  }\n};\nvar \
_defaultValues$4 = /* @__PURE__ */ new MeshToonMaterial();\nvar \
MeshToonNodeMaterial = class extends NodeMaterial {\n  static get type() {\n  \
  return \"MeshToonNodeMaterial\";\n  }\n  constructor(parameters) {\n    \
super();\n    this.isMeshToonNodeMaterial = true;\n    this.lights = true;\n  \
  this.setDefaultValues(_defaultValues$4);\n    this.setValues(parameters);\n \
 }\n  setupLightingModel() {\n    return new ToonLightingModel();\n  \
}\n};\nvar MatcapUVNode = class extends TempNode {\n  static get type() {\n   \
 return \"MatcapUVNode\";\n  }\n  constructor() {\n    super(\"vec2\");\n  \
}\n  setup() {\n    const x2 = vec3(positionViewDirection.z, 0, \
positionViewDirection.x.negate()).normalize();\n    const y2 = \
positionViewDirection.cross(x2);\n    return \
vec2(x2.dot(transformedNormalView), \
y2.dot(transformedNormalView)).mul(0.495).add(0.5);\n  }\n};\nvar matcapUV = \
/* @__PURE__ */ nodeImmutable(MatcapUVNode);\nvar _defaultValues$3 = /* \
@__PURE__ */ new MeshMatcapMaterial();\nvar MeshMatcapNodeMaterial = class \
extends NodeMaterial {\n  static get type() {\n    return \
\"MeshMatcapNodeMaterial\";\n  }\n  constructor(parameters) {\n    super();\n \
   this.lights = false;\n    this.isMeshMatcapNodeMaterial = true;\n    \
this.setDefaultValues(_defaultValues$3);\n    this.setValues(parameters);\n  \
}\n  setupVariants(builder) {\n    const uv2 = matcapUV;\n    let \
matcapColor;\n    if (builder.material.matcap) {\n      matcapColor = \
materialReference(\"matcap\", \"texture\").context({ getUV: () => uv2 });\n   \
 } else {\n      matcapColor = vec3(mix(0.2, 0.8, uv2.y));\n    }\n    \
diffuseColor.rgb.mulAssign(matcapColor.rgb);\n  }\n};\nvar _defaultValues$2 = \
/* @__PURE__ */ new PointsMaterial();\nvar PointsNodeMaterial = class extends \
NodeMaterial {\n  static get type() {\n    return \"PointsNodeMaterial\";\n  \
}\n  constructor(parameters) {\n    super();\n    this.isPointsNodeMaterial = \
true;\n    this.lights = false;\n    this.transparent = true;\n    \
this.sizeNode = null;\n    this.setDefaultValues(_defaultValues$2);\n    \
this.setValues(parameters);\n  }\n  copy(source) {\n    this.sizeNode = \
source.sizeNode;\n    return super.copy(source);\n  }\n};\nvar RotateNode = \
class extends TempNode {\n  static get type() {\n    return \"RotateNode\";\n \
 }\n  constructor(positionNode, rotationNode) {\n    super();\n    \
this.positionNode = positionNode;\n    this.rotationNode = rotationNode;\n  \
}\n  getNodeType(builder) {\n    return \
this.positionNode.getNodeType(builder);\n  }\n  setup(builder) {\n    const { \
rotationNode, positionNode } = this;\n    const nodeType = \
this.getNodeType(builder);\n    if (nodeType === \"vec2\") {\n      const \
cosAngle = rotationNode.cos();\n      const sinAngle = rotationNode.sin();\n  \
    const rotationMatrix = mat2(\n        cosAngle,\n        sinAngle,\n      \
  sinAngle.negate(),\n        cosAngle\n      );\n      return \
rotationMatrix.mul(positionNode);\n    } else {\n      const rotation = \
rotationNode;\n      const rotationXMatrix = mat4(vec4(1, 0, 0, 0), vec4(0, \
cos(rotation.x), sin(rotation.x).negate(), 0), vec4(0, sin(rotation.x), \
cos(rotation.x), 0), vec4(0, 0, 0, 1));\n      const rotationYMatrix = \
mat4(vec4(cos(rotation.y), 0, sin(rotation.y), 0), vec4(0, 1, 0, 0), \
vec4(sin(rotation.y).negate(), 0, cos(rotation.y), 0), vec4(0, 0, 0, 1));\n   \
   const rotationZMatrix = mat4(vec4(cos(rotation.z), \
sin(rotation.z).negate(), 0, 0), vec4(sin(rotation.z), cos(rotation.z), 0, \
0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1));\n      return \
rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNo\
de, 1)).xyz;\n    }\n  }\n};\nvar rotate = /* @__PURE__ */ \
nodeProxy(RotateNode);\nvar _defaultValues$1 = /* @__PURE__ */ new \
SpriteMaterial();\nvar SpriteNodeMaterial = class extends NodeMaterial {\n  \
static get type() {\n    return \"SpriteNodeMaterial\";\n  }\n  \
constructor(parameters) {\n    super();\n    this.isSpriteNodeMaterial = \
true;\n    this.lights = false;\n    this._useSizeAttenuation = true;\n    \
this.positionNode = null;\n    this.rotationNode = null;\n    this.scaleNode \
= null;\n    this.setDefaultValues(_defaultValues$1);\n    \
this.setValues(parameters);\n  }\n  setupPosition({ object, camera: camera3, \
context: context2 }) {\n    const sizeAttenuation = this.sizeAttenuation;\n   \
 const { positionNode, rotationNode, scaleNode } = this;\n    const vertex2 = \
positionLocal;\n    let mvPosition = modelViewMatrix.mul(vec3(positionNode || \
0));\n    let scale = vec2(modelWorldMatrix[0].xyz.length(), \
modelWorldMatrix[1].xyz.length());\n    if (scaleNode !== null) {\n      \
scale = scale.mul(scaleNode);\n    }\n    if (!sizeAttenuation) {\n      if \
(camera3.isPerspectiveCamera) {\n        scale = \
scale.mul(mvPosition.z.negate());\n      } else {\n        const orthoScale = \
float(2).div(cameraProjectionMatrix.element(1).element(1));\n        scale = \
scale.mul(orthoScale.mul(2));\n      }\n    }\n    let alignedPosition = \
vertex2.xy;\n    if (object.center && object.center.isVector2 === true) {\n   \
   const center = reference$1(\"center\", \"vec2\");\n      alignedPosition = \
alignedPosition.sub(center.sub(0.5));\n    }\n    alignedPosition = \
alignedPosition.mul(scale);\n    const rotation = float(rotationNode || \
materialRotation);\n    const rotatedPosition = rotate(alignedPosition, \
rotation);\n    mvPosition = vec4(mvPosition.xy.add(rotatedPosition), \
mvPosition.zw);\n    const modelViewProjection2 = \
cameraProjectionMatrix.mul(mvPosition);\n    context2.vertex = vertex2;\n    \
return modelViewProjection2;\n  }\n  copy(source) {\n    this.positionNode = \
source.positionNode;\n    this.rotationNode = source.rotationNode;\n    \
this.scaleNode = source.scaleNode;\n    return super.copy(source);\n  }\n  \
get sizeAttenuation() {\n    return this._useSizeAttenuation;\n  }\n  set \
sizeAttenuation(value) {\n    if (this._useSizeAttenuation !== value) {\n     \
 this._useSizeAttenuation = value;\n      this.needsUpdate = true;\n    }\n  \
}\n};\nvar ShadowMaskModel = class extends LightingModel {\n  constructor() \
{\n    super();\n    this.shadowNode = float(1).toVar(\"shadowMask\");\n  }\n \
 direct({ shadowMask }) {\n    this.shadowNode.mulAssign(shadowMask);\n  }\n  \
finish(context2) {\n    \
diffuseColor.a.mulAssign(this.shadowNode.oneMinus());\n    \
context2.outgoingLight.rgb.assign(diffuseColor.rgb);\n  }\n};\nvar \
_defaultValues = /* @__PURE__ */ new ShadowMaterial();\nvar \
ShadowNodeMaterial = class extends NodeMaterial {\n  static get type() {\n    \
return \"ShadowNodeMaterial\";\n  }\n  constructor(parameters) {\n    \
super();\n    this.isShadowNodeMaterial = true;\n    this.lights = true;\n    \
this.setDefaultValues(_defaultValues);\n    this.setValues(parameters);\n  \
}\n  setupLightingModel() {\n    return new ShadowMaskModel();\n  }\n};\nvar \
normal = Fn(({ texture: texture2, uv: uv2 }) => {\n  const epsilon = 1e-4;\n  \
const ret = vec3().toVar();\n  If(uv2.x.lessThan(epsilon), () => {\n    \
ret.assign(vec3(1, 0, 0));\n  }).ElseIf(uv2.y.lessThan(epsilon), () => {\n    \
ret.assign(vec3(0, 1, 0));\n  }).ElseIf(uv2.z.lessThan(epsilon), () => {\n    \
ret.assign(vec3(0, 0, 1));\n  }).ElseIf(uv2.x.greaterThan(1 - epsilon), () => \
{\n    ret.assign(vec3(-1, 0, 0));\n  }).ElseIf(uv2.y.greaterThan(1 - \
epsilon), () => {\n    ret.assign(vec3(0, -1, 0));\n  \
}).ElseIf(uv2.z.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(0, 0, \
-1));\n  }).Else(() => {\n    const step2 = 0.01;\n    const x2 = \
texture2.uv(uv2.add(vec3(-step2, 0, \
0))).r.sub(texture2.uv(uv2.add(vec3(step2, 0, 0))).r);\n    const y2 = \
texture2.uv(uv2.add(vec3(0, -step2, 0))).r.sub(texture2.uv(uv2.add(vec3(0, \
step2, 0))).r);\n    const z2 = texture2.uv(uv2.add(vec3(0, 0, \
-step2))).r.sub(texture2.uv(uv2.add(vec3(0, 0, step2))).r);\n    \
ret.assign(vec3(x2, y2, z2));\n  });\n  return ret.normalize();\n});\nvar \
Animation = class {\n  constructor(nodes, info) {\n    this.nodes = nodes;\n  \
  this.info = info;\n    this.animationLoop = null;\n    this.requestId = \
null;\n    this._init();\n  }\n  _init() {\n    const update4 = (time, \
frame2) => {\n      this.requestId = self.requestAnimationFrame(update4);\n   \
   if (this.info.autoReset === true) this.info.reset();\n      \
this.nodes.nodeFrame.update();\n      this.info.frame = \
this.nodes.nodeFrame.frameId;\n      if (this.animationLoop !== null) \
this.animationLoop(time, frame2);\n    };\n    update4();\n  }\n  dispose() \
{\n    self.cancelAnimationFrame(this.requestId);\n    this.requestId = \
null;\n  }\n  setAnimationLoop(callback) {\n    this.animationLoop = \
callback;\n  }\n};\nvar ChainMap = class {\n  constructor() {\n    \
this.weakMap = /* @__PURE__ */ new WeakMap();\n  }\n  get(keys) {\n    let \
map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      map = \
map.get(keys[i]);\n      if (map === void 0) return void 0;\n    }\n    \
return map.get(keys[keys.length - 1]);\n  }\n  set(keys, value) {\n    let \
map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      const \
key = keys[i];\n      if (map.has(key) === false) map.set(key, /* @__PURE__ \
*/ new WeakMap());\n      map = map.get(key);\n    }\n    return \
map.set(keys[keys.length - 1], value);\n  }\n  delete(keys) {\n    let map = \
this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      map = \
map.get(keys[i]);\n      if (map === void 0) return false;\n    }\n    return \
map.delete(keys[keys.length - 1]);\n  }\n};\nvar _plane2 = /* @__PURE__ */ \
new Plane2();\nvar ClippingContext = class {\n  constructor() {\n    \
this.version = 0;\n    this.globalClippingCount = 0;\n    \
this.localClippingCount = 0;\n    this.localClippingEnabled = false;\n    \
this.localClipIntersection = false;\n    this.planes = [];\n    \
this.parentVersion = 0;\n    this.viewNormalMatrix = new Matrix32();\n    \
this.cacheKey = 0;\n  }\n  projectPlanes(source, offset) {\n    const l = \
source.length;\n    const planes = this.planes;\n    for (let i = 0; i < l; \
i++) {\n      _plane2.copy(source[i]).applyMatrix4(this.viewMatrix, \
this.viewNormalMatrix);\n      const v = planes[offset + i];\n      const \
normal2 = _plane2.normal;\n      v.x = -normal2.x;\n      v.y = -normal2.y;\n \
     v.z = -normal2.z;\n      v.w = _plane2.constant;\n    }\n  }\n  \
updateGlobal(renderer3, camera3) {\n    const rendererClippingPlanes = \
renderer3.clippingPlanes;\n    this.viewMatrix = \
camera3.matrixWorldInverse;\n    \
this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);\n    let update4 = \
false;\n    if (Array.isArray(rendererClippingPlanes) && \
rendererClippingPlanes.length !== 0) {\n      const l = \
rendererClippingPlanes.length;\n      if (l !== this.globalClippingCount) {\n \
       const planes = [];\n        for (let i = 0; i < l; i++) {\n          \
planes.push(new Vector42());\n        }\n        this.globalClippingCount = \
l;\n        this.planes = planes;\n        update4 = true;\n      }\n      \
this.projectPlanes(rendererClippingPlanes, 0);\n    } else if \
(this.globalClippingCount !== 0) {\n      this.globalClippingCount = 0;\n     \
 this.planes = [];\n      update4 = true;\n    }\n    if \
(renderer3.localClippingEnabled !== this.localClippingEnabled) {\n      \
this.localClippingEnabled = renderer3.localClippingEnabled;\n      update4 = \
true;\n    }\n    if (update4) {\n      this.version++;\n      this.cacheKey \
= hash$1(this.globalClippingCount, this.localClippingEnabled === true ? 1 : \
0);\n    }\n  }\n  update(parent, material) {\n    let update4 = false;\n    \
if (this !== parent && parent.version !== this.parentVersion) {\n      \
this.globalClippingCount = material.isShadowNodeMaterial ? 0 : \
parent.globalClippingCount;\n      this.localClippingEnabled = \
parent.localClippingEnabled;\n      this.planes = \
Array.from(parent.planes);\n      this.parentVersion = parent.version;\n      \
this.viewMatrix = parent.viewMatrix;\n      this.viewNormalMatrix = \
parent.viewNormalMatrix;\n      update4 = true;\n    }\n    if \
(this.localClippingEnabled) {\n      const localClippingPlanes = \
material.clippingPlanes;\n      if (Array.isArray(localClippingPlanes) && \
localClippingPlanes.length !== 0) {\n        const l = \
localClippingPlanes.length;\n        const planes = this.planes;\n        \
const offset = this.globalClippingCount;\n        if (update4 || l !== \
this.localClippingCount) {\n          planes.length = offset + l;\n          \
for (let i = 0; i < l; i++) {\n            planes[offset + i] = new \
Vector42();\n          }\n          this.localClippingCount = l;\n          \
update4 = true;\n        }\n        this.projectPlanes(localClippingPlanes, \
offset);\n      } else if (this.localClippingCount !== 0) {\n        \
this.localClippingCount = 0;\n        update4 = true;\n      }\n      if \
(this.localClipIntersection !== material.clipIntersection) {\n        \
this.localClipIntersection = material.clipIntersection;\n        update4 = \
true;\n      }\n    }\n    if (update4) {\n      this.version += \
parent.version;\n      this.cacheKey = hash$1(parent.cacheKey, \
this.localClippingCount, this.localClipIntersection === true ? 1 : 0);\n    \
}\n  }\n};\nvar _id$7 = 0;\nfunction getKeys(obj) {\n  const keys = \
Object.keys(obj);\n  let proto = Object.getPrototypeOf(obj);\n  while (proto) \
{\n    const descriptors = Object.getOwnPropertyDescriptors(proto);\n    for \
(const key in descriptors) {\n      if (descriptors[key] !== void 0) {\n      \
  const descriptor = descriptors[key];\n        if (descriptor && typeof \
descriptor.get === \"function\") {\n          keys.push(key);\n        }\n    \
  }\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return \
keys;\n}\nvar RenderObject = class {\n  constructor(nodes, geometries, \
renderer3, object, material, scene3, camera3, lightsNode, renderContext) {\n  \
  this._nodes = nodes;\n    this._geometries = geometries;\n    this.id = \
_id$7++;\n    this.renderer = renderer3;\n    this.object = object;\n    \
this.material = material;\n    this.scene = scene3;\n    this.camera = \
camera3;\n    this.lightsNode = lightsNode;\n    this.context = \
renderContext;\n    this.geometry = object.geometry;\n    this.version = \
material.version;\n    this.drawRange = null;\n    this.attributes = null;\n  \
  this.pipeline = null;\n    this.vertexBuffers = null;\n    this.drawParams \
= null;\n    this.bundle = null;\n    \
this.updateClipping(renderContext.clippingContext);\n    \
this.clippingContextVersion = this.clippingContext.version;\n    \
this.initialNodesCacheKey = this.getDynamicCacheKey();\n    \
this.initialCacheKey = this.getCacheKey();\n    this._nodeBuilderState = \
null;\n    this._bindings = null;\n    this._monitor = null;\n    \
this.onDispose = null;\n    this.isRenderObject = true;\n    \
this.onMaterialDispose = () => {\n      this.dispose();\n    };\n    \
this.material.addEventListener(\"dispose\", this.onMaterialDispose);\n  }\n  \
updateClipping(parent) {\n    const material = this.material;\n    let \
clippingContext = this.clippingContext;\n    if \
(Array.isArray(material.clippingPlanes)) {\n      if (clippingContext === \
parent || !clippingContext) {\n        clippingContext = new \
ClippingContext();\n        this.clippingContext = clippingContext;\n      \
}\n      clippingContext.update(parent, material);\n    } else if \
(this.clippingContext !== parent) {\n      this.clippingContext = parent;\n   \
 }\n  }\n  get clippingNeedsUpdate() {\n    if (this.clippingContext.version \
=== this.clippingContextVersion) return false;\n    \
this.clippingContextVersion = this.clippingContext.version;\n    return \
true;\n  }\n  getNodeBuilderState() {\n    return this._nodeBuilderState || \
(this._nodeBuilderState = this._nodes.getForRender(this));\n  }\n  \
getMonitor() {\n    return this._monitor || (this._monitor = \
this.getNodeBuilderState().monitor);\n  }\n  getBindings() {\n    return \
this._bindings || (this._bindings = \
this.getNodeBuilderState().createBindings());\n  }\n  getIndex() {\n    \
return this._geometries.getIndex(this);\n  }\n  getIndirect() {\n    return \
this._geometries.getIndirect(this);\n  }\n  getChainArray() {\n    return \
[this.object, this.material, this.context, this.lightsNode];\n  }\n  \
getAttributes() {\n    if (this.attributes !== null) return \
this.attributes;\n    const nodeAttributes = \
this.getNodeBuilderState().nodeAttributes;\n    const geometry = \
this.geometry;\n    const attributes = [];\n    const vertexBuffers = /* \
@__PURE__ */ new Set();\n    for (const nodeAttribute of nodeAttributes) {\n  \
    const attribute2 = nodeAttribute.node && nodeAttribute.node.attribute ? \
nodeAttribute.node.attribute : geometry.getAttribute(nodeAttribute.name);\n   \
   if (attribute2 === void 0) continue;\n      attributes.push(attribute2);\n \
     const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? \
attribute2.data : attribute2;\n      vertexBuffers.add(bufferAttribute2);\n   \
 }\n    this.attributes = attributes;\n    this.vertexBuffers = \
Array.from(vertexBuffers.values());\n    return attributes;\n  }\n  \
getVertexBuffers() {\n    if (this.vertexBuffers === null) \
this.getAttributes();\n    return this.vertexBuffers;\n  }\n  \
getDrawParameters() {\n    const { object, material, geometry, group, \
drawRange } = this;\n    const drawParams = this.drawParams || \
(this.drawParams = {\n      vertexCount: 0,\n      firstVertex: 0,\n      \
instanceCount: 0,\n      firstInstance: 0\n    });\n    const index5 = \
this.getIndex();\n    const hasIndex = index5 !== null;\n    const \
instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : \
object.count > 1 ? object.count : 1;\n    if (instanceCount === 0) return \
null;\n    drawParams.instanceCount = instanceCount;\n    if \
(object.isBatchedMesh === true) return drawParams;\n    let rangeFactor = \
1;\n    if (material.wireframe === true && !object.isPoints && \
!object.isLineSegments && !object.isLine && !object.isLineLoop) {\n      \
rangeFactor = 2;\n    }\n    let firstVertex = drawRange.start * \
rangeFactor;\n    let lastVertex = (drawRange.start + drawRange.count) * \
rangeFactor;\n    if (group !== null) {\n      firstVertex = \
Math.max(firstVertex, group.start * rangeFactor);\n      lastVertex = \
Math.min(lastVertex, (group.start + group.count) * rangeFactor);\n    }\n    \
const position = geometry.attributes.position;\n    let itemCount = \
Infinity;\n    if (hasIndex) {\n      itemCount = index5.count;\n    } else \
if (position !== void 0 && position !== null) {\n      itemCount = \
position.count;\n    }\n    firstVertex = Math.max(firstVertex, 0);\n    \
lastVertex = Math.min(lastVertex, itemCount);\n    const count = lastVertex - \
firstVertex;\n    if (count < 0 || count === Infinity) return null;\n    \
drawParams.vertexCount = count;\n    drawParams.firstVertex = firstVertex;\n  \
  return drawParams;\n  }\n  getGeometryCacheKey() {\n    const { geometry } \
= this;\n    let cacheKey = \"\";\n    for (const name of \
Object.keys(geometry.attributes).sort()) {\n      const attribute2 = \
geometry.attributes[name];\n      cacheKey += name + \",\";\n      if \
(attribute2.data) cacheKey += attribute2.data.stride + \",\";\n      if \
(attribute2.offset) cacheKey += attribute2.offset + \",\";\n      if \
(attribute2.itemSize) cacheKey += attribute2.itemSize + \",\";\n      if \
(attribute2.normalized) cacheKey += \"n,\";\n    }\n    if (geometry.index) \
{\n      cacheKey += \"index,\";\n    }\n    return cacheKey;\n  }\n  \
getMaterialCacheKey() {\n    const { object, material } = this;\n    let \
cacheKey = material.customProgramCacheKey();\n    for (const property2 of \
getKeys(material)) {\n      if \
(/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property2\
)) continue;\n      const value = material[property2];\n      let valueKey;\n \
     if (value !== null) {\n        const type = typeof value;\n        if \
(type === \"number\") {\n          valueKey = value !== 0 ? \"1\" : \"0\";\n  \
      } else if (type === \"object\") {\n          valueKey = \"{\";\n        \
  if (value.isTexture) {\n            valueKey += value.mapping;\n          \
}\n          valueKey += \"}\";\n        } else {\n          valueKey = \
String(value);\n        }\n      } else {\n        valueKey = \
String(value);\n      }\n      cacheKey += /*property + ':' +*/\n      \
valueKey + \",\";\n    }\n    cacheKey += this.clippingContext.cacheKey + \
\",\";\n    if (object.geometry) {\n      cacheKey += \
this.getGeometryCacheKey();\n    }\n    if (object.skeleton) {\n      \
cacheKey += object.skeleton.bones.length + \",\";\n    }\n    if \
(object.morphTargetInfluences) {\n      cacheKey += \
object.morphTargetInfluences.length + \",\";\n    }\n    if \
(object.isBatchedMesh) {\n      cacheKey += object._matricesTexture.uuid + \
\",\";\n      if (object._colorsTexture !== null) {\n        cacheKey += \
object._colorsTexture.uuid + \",\";\n      }\n    }\n    if (object.count > \
1) {\n      cacheKey += object.uuid + \",\";\n    }\n    return \
hashString(cacheKey);\n  }\n  get needsUpdate() {\n    return (\n      \
/*this.object.static !== true &&*/\n      this.initialNodesCacheKey !== \
this.getDynamicCacheKey() || this.clippingNeedsUpdate\n    );\n  }\n  \
getDynamicCacheKey() {\n    let cacheKey = \
this._nodes.getCacheKey(this.scene, this.lightsNode);\n    if \
(this.object.receiveShadow) {\n      cacheKey += 1;\n    }\n    return \
cacheKey;\n  }\n  getCacheKey() {\n    return this.getMaterialCacheKey() + \
this.getDynamicCacheKey();\n  }\n  dispose() {\n    \
this.material.removeEventListener(\"dispose\", this.onMaterialDispose);\n    \
this.onDispose();\n  }\n};\nvar chainArray = [];\nvar RenderObjects = class \
{\n  constructor(renderer3, nodes, geometries, pipelines, bindings, info) {\n \
   this.renderer = renderer3;\n    this.nodes = nodes;\n    this.geometries = \
geometries;\n    this.pipelines = pipelines;\n    this.bindings = bindings;\n \
   this.info = info;\n    this.chainMaps = {};\n  }\n  get(object, material, \
scene3, camera3, lightsNode, renderContext, passId) {\n    const chainMap = \
this.getChainMap(passId);\n    chainArray[0] = object;\n    chainArray[1] = \
material;\n    chainArray[2] = renderContext;\n    chainArray[3] = \
lightsNode;\n    let renderObject = chainMap.get(chainArray);\n    if \
(renderObject === void 0) {\n      renderObject = \
this.createRenderObject(this.nodes, this.geometries, this.renderer, object, \
material, scene3, camera3, lightsNode, renderContext, passId);\n      \
chainMap.set(chainArray, renderObject);\n    } else {\n      \
renderObject.updateClipping(renderContext.clippingContext);\n      if \
(renderObject.version !== material.version || renderObject.needsUpdate) {\n   \
     if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {\n     \
     renderObject.dispose();\n          renderObject = this.get(object, \
material, scene3, camera3, lightsNode, renderContext, passId);\n        } \
else {\n          renderObject.version = material.version;\n        }\n      \
}\n    }\n    return renderObject;\n  }\n  getChainMap(passId = \"default\") \
{\n    return this.chainMaps[passId] || (this.chainMaps[passId] = new \
ChainMap());\n  }\n  dispose() {\n    this.chainMaps = {};\n  }\n  \
createRenderObject(nodes, geometries, renderer3, object, material, scene3, \
camera3, lightsNode, renderContext, passId) {\n    const chainMap = \
this.getChainMap(passId);\n    const renderObject = new RenderObject(nodes, \
geometries, renderer3, object, material, scene3, camera3, lightsNode, \
renderContext);\n    renderObject.onDispose = () => {\n      \
this.pipelines.delete(renderObject);\n      \
this.bindings.delete(renderObject);\n      this.nodes.delete(renderObject);\n \
     chainMap.delete(renderObject.getChainArray());\n    };\n    return \
renderObject;\n  }\n};\nvar DataMap = class {\n  constructor() {\n    \
this.data = /* @__PURE__ */ new WeakMap();\n  }\n  get(object) {\n    let map \
= this.data.get(object);\n    if (map === void 0) {\n      map = {};\n      \
this.data.set(object, map);\n    }\n    return map;\n  }\n  delete(object) \
{\n    let map;\n    if (this.data.has(object)) {\n      map = \
this.data.get(object);\n      this.data.delete(object);\n    }\n    return \
map;\n  }\n  has(object) {\n    return this.data.has(object);\n  }\n  \
dispose() {\n    this.data = /* @__PURE__ */ new WeakMap();\n  }\n};\nvar \
AttributeType = {\n  VERTEX: 1,\n  INDEX: 2,\n  STORAGE: 3,\n  INDIRECT: \
4\n};\nvar GPU_CHUNK_BYTES = 16;\nvar BlendColorFactor = 211;\nvar \
OneMinusBlendColorFactor = 212;\nvar Attributes = class extends DataMap {\n  \
constructor(backend) {\n    super();\n    this.backend = backend;\n  }\n  \
delete(attribute2) {\n    const attributeData = super.delete(attribute2);\n   \
 if (attributeData !== void 0) {\n      \
this.backend.destroyAttribute(attribute2);\n    }\n    return \
attributeData;\n  }\n  update(attribute2, type) {\n    const data = \
this.get(attribute2);\n    if (data.version === void 0) {\n      if (type === \
AttributeType.VERTEX) {\n        this.backend.createAttribute(attribute2);\n  \
    } else if (type === AttributeType.INDEX) {\n        \
this.backend.createIndexAttribute(attribute2);\n      } else if (type === \
AttributeType.STORAGE) {\n        \
this.backend.createStorageAttribute(attribute2);\n      } else if (type === \
AttributeType.INDIRECT) {\n        \
this.backend.createIndirectStorageAttribute(attribute2);\n      }\n      \
data.version = this._getBufferAttribute(attribute2).version;\n    } else {\n  \
    const bufferAttribute2 = this._getBufferAttribute(attribute2);\n      if \
(data.version < bufferAttribute2.version || bufferAttribute2.usage === \
DynamicDrawUsage) {\n        this.backend.updateAttribute(attribute2);\n      \
  data.version = bufferAttribute2.version;\n      }\n    }\n  }\n  \
_getBufferAttribute(attribute2) {\n    if \
(attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;\n    \
return attribute2;\n  }\n};\nfunction arrayNeedsUint322(array) {\n  for (let \
i = array.length - 1; i >= 0; --i) {\n    if (array[i] >= 65535) return \
true;\n  }\n  return false;\n}\nfunction getWireframeVersion(geometry) {\n  \
return geometry.index !== null ? geometry.index.version : \
geometry.attributes.position.version;\n}\nfunction \
getWireframeIndex(geometry) {\n  const indices = [];\n  const geometryIndex = \
geometry.index;\n  const geometryPosition = geometry.attributes.position;\n  \
if (geometryIndex !== null) {\n    const array = geometryIndex.array;\n    \
for (let i = 0, l = array.length; i < l; i += 3) {\n      const a2 = array[i \
+ 0];\n      const b = array[i + 1];\n      const c2 = array[i + 2];\n      \
indices.push(a2, b, b, c2, c2, a2);\n    }\n  } else {\n    const array = \
geometryPosition.array;\n    for (let i = 0, l = array.length / 3 - 1; i < l; \
i += 3) {\n      const a2 = i + 0;\n      const b = i + 1;\n      const c2 = \
i + 2;\n      indices.push(a2, b, b, c2, c2, a2);\n    }\n  }\n  const \
attribute2 = new (arrayNeedsUint322(indices) ? Uint32BufferAttribute2 : \
Uint16BufferAttribute2)(indices, 1);\n  attribute2.version = \
getWireframeVersion(geometry);\n  return attribute2;\n}\nvar Geometries = \
class extends DataMap {\n  constructor(attributes, info) {\n    super();\n    \
this.attributes = attributes;\n    this.info = info;\n    this.wireframes = \
/* @__PURE__ */ new WeakMap();\n    this.attributeCall = /* @__PURE__ */ new \
WeakMap();\n  }\n  has(renderObject) {\n    const geometry = \
renderObject.geometry;\n    return super.has(geometry) && \
this.get(geometry).initialized === true;\n  }\n  \
updateForRender(renderObject) {\n    if (this.has(renderObject) === false) \
this.initGeometry(renderObject);\n    this.updateAttributes(renderObject);\n  \
}\n  initGeometry(renderObject) {\n    const geometry = \
renderObject.geometry;\n    const geometryData = this.get(geometry);\n    \
geometryData.initialized = true;\n    this.info.memory.geometries++;\n    \
const onDispose = () => {\n      this.info.memory.geometries--;\n      const \
index5 = geometry.index;\n      const geometryAttributes = \
renderObject.getAttributes();\n      if (index5 !== null) {\n        \
this.attributes.delete(index5);\n      }\n      for (const geometryAttribute \
of geometryAttributes) {\n        \
this.attributes.delete(geometryAttribute);\n      }\n      const \
wireframeAttribute = this.wireframes.get(geometry);\n      if \
(wireframeAttribute !== void 0) {\n        \
this.attributes.delete(wireframeAttribute);\n      }\n      \
geometry.removeEventListener(\"dispose\", onDispose);\n    };\n    \
geometry.addEventListener(\"dispose\", onDispose);\n  }\n  \
updateAttributes(renderObject) {\n    const attributes = \
renderObject.getAttributes();\n    for (const attribute2 of attributes) {\n   \
   if (attribute2.isStorageBufferAttribute || \
attribute2.isStorageInstancedBufferAttribute) {\n        \
this.updateAttribute(attribute2, AttributeType.STORAGE);\n      } else {\n    \
    this.updateAttribute(attribute2, AttributeType.VERTEX);\n      }\n    }\n \
   const index5 = this.getIndex(renderObject);\n    if (index5 !== null) {\n  \
    this.updateAttribute(index5, AttributeType.INDEX);\n    }\n    const \
indirect = renderObject.geometry.indirect;\n    if (indirect !== null) {\n    \
  this.updateAttribute(indirect, AttributeType.INDIRECT);\n    }\n  }\n  \
updateAttribute(attribute2, type) {\n    const callId = \
this.info.render.calls;\n    if (!attribute2.isInterleavedBufferAttribute) \
{\n      if (this.attributeCall.get(attribute2) !== callId) {\n        \
this.attributes.update(attribute2, type);\n        \
this.attributeCall.set(attribute2, callId);\n      }\n    } else {\n      if \
(this.attributeCall.get(attribute2) === void 0) {\n        \
this.attributes.update(attribute2, type);\n        \
this.attributeCall.set(attribute2, callId);\n      } else if \
(this.attributeCall.get(attribute2.data) !== callId) {\n        \
this.attributes.update(attribute2, type);\n        \
this.attributeCall.set(attribute2.data, callId);\n        \
this.attributeCall.set(attribute2, callId);\n      }\n    }\n  }\n  \
getIndirect(renderObject) {\n    return renderObject.geometry.indirect;\n  \
}\n  getIndex(renderObject) {\n    const { geometry, material } = \
renderObject;\n    let index5 = geometry.index;\n    if (material.wireframe \
=== true) {\n      const wireframes = this.wireframes;\n      let \
wireframeAttribute = wireframes.get(geometry);\n      if (wireframeAttribute \
=== void 0) {\n        wireframeAttribute = getWireframeIndex(geometry);\n    \
    wireframes.set(geometry, wireframeAttribute);\n      } else if \
(wireframeAttribute.version !== getWireframeVersion(geometry)) {\n        \
this.attributes.delete(wireframeAttribute);\n        wireframeAttribute = \
getWireframeIndex(geometry);\n        wireframes.set(geometry, \
wireframeAttribute);\n      }\n      index5 = wireframeAttribute;\n    }\n    \
return index5;\n  }\n};\nvar Info = class {\n  constructor() {\n    \
this.autoReset = true;\n    this.frame = 0;\n    this.calls = 0;\n    \
this.render = {\n      calls: 0,\n      frameCalls: 0,\n      drawCalls: 0,\n \
     triangles: 0,\n      points: 0,\n      lines: 0,\n      timestamp: 0,\n  \
    previousFrameCalls: 0,\n      timestampCalls: 0\n    };\n    this.compute \
= {\n      calls: 0,\n      frameCalls: 0,\n      timestamp: 0,\n      \
previousFrameCalls: 0,\n      timestampCalls: 0\n    };\n    this.memory = \
{\n      geometries: 0,\n      textures: 0\n    };\n  }\n  update(object, \
count, instanceCount) {\n    this.render.drawCalls++;\n    if (object.isMesh \
|| object.isSprite) {\n      this.render.triangles += instanceCount * (count \
/ 3);\n    } else if (object.isPoints) {\n      this.render.points += \
instanceCount * count;\n    } else if (object.isLineSegments) {\n      \
this.render.lines += instanceCount * (count / 2);\n    } else if \
(object.isLine) {\n      this.render.lines += instanceCount * (count - 1);\n  \
  } else {\n      console.error(\"THREE.WebGPUInfo: Unknown object \
type.\");\n    }\n  }\n  updateTimestamp(type, time) {\n    if \
(this[type].timestampCalls === 0) {\n      this[type].timestamp = 0;\n    }\n \
   this[type].timestamp += time;\n    this[type].timestampCalls++;\n    if \
(this[type].timestampCalls >= this[type].previousFrameCalls) {\n      \
this[type].timestampCalls = 0;\n    }\n  }\n  reset() {\n    const \
previousRenderFrameCalls = this.render.frameCalls;\n    \
this.render.previousFrameCalls = previousRenderFrameCalls;\n    const \
previousComputeFrameCalls = this.compute.frameCalls;\n    \
this.compute.previousFrameCalls = previousComputeFrameCalls;\n    \
this.render.drawCalls = 0;\n    this.render.frameCalls = 0;\n    \
this.compute.frameCalls = 0;\n    this.render.triangles = 0;\n    \
this.render.points = 0;\n    this.render.lines = 0;\n  }\n  dispose() {\n    \
this.reset();\n    this.calls = 0;\n    this.render.calls = 0;\n    \
this.compute.calls = 0;\n    this.render.timestamp = 0;\n    \
this.compute.timestamp = 0;\n    this.memory.geometries = 0;\n    \
this.memory.textures = 0;\n  }\n};\nvar Pipeline = class {\n  \
constructor(cacheKey) {\n    this.cacheKey = cacheKey;\n    this.usedTimes = \
0;\n  }\n};\nvar RenderPipeline = class extends Pipeline {\n  \
constructor(cacheKey, vertexProgram, fragmentProgram) {\n    \
super(cacheKey);\n    this.vertexProgram = vertexProgram;\n    \
this.fragmentProgram = fragmentProgram;\n  }\n};\nvar ComputePipeline = class \
extends Pipeline {\n  constructor(cacheKey, computeProgram) {\n    \
super(cacheKey);\n    this.computeProgram = computeProgram;\n    \
this.isComputePipeline = true;\n  }\n};\nvar _id$6 = 0;\nvar \
ProgrammableStage = class {\n  constructor(code, type, transforms = null, \
attributes = null) {\n    this.id = _id$6++;\n    this.code = code;\n    \
this.stage = type;\n    this.transforms = transforms;\n    this.attributes = \
attributes;\n    this.usedTimes = 0;\n  }\n};\nvar Pipelines = class extends \
DataMap {\n  constructor(backend, nodes) {\n    super();\n    this.backend = \
backend;\n    this.nodes = nodes;\n    this.bindings = null;\n    this.caches \
= /* @__PURE__ */ new Map();\n    this.programs = {\n      vertex: /* \
@__PURE__ */ new Map(),\n      fragment: /* @__PURE__ */ new Map(),\n      \
compute: /* @__PURE__ */ new Map()\n    };\n  }\n  getForCompute(computeNode, \
bindings) {\n    const { backend } = this;\n    const data = \
this.get(computeNode);\n    if (this._needsComputeUpdate(computeNode)) {\n    \
  const previousPipeline = data.pipeline;\n      if (previousPipeline) {\n    \
    previousPipeline.usedTimes--;\n        \
previousPipeline.computeProgram.usedTimes--;\n      }\n      const \
nodeBuilderState = this.nodes.getForCompute(computeNode);\n      let \
stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);\n   \
   if (stageCompute === void 0) {\n        if (previousPipeline && \
previousPipeline.computeProgram.usedTimes === 0) \
this._releaseProgram(previousPipeline.computeProgram);\n        stageCompute \
= new ProgrammableStage(nodeBuilderState.computeShader, \"compute\", \
nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);\n        \
this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);\n    \
    backend.createProgram(stageCompute);\n      }\n      const cacheKey = \
this._getComputeCacheKey(computeNode, stageCompute);\n      let pipeline = \
this.caches.get(cacheKey);\n      if (pipeline === void 0) {\n        if \
(previousPipeline && previousPipeline.usedTimes === 0) \
this._releasePipeline(previousPipeline);\n        pipeline = \
this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);\n    \
  }\n      pipeline.usedTimes++;\n      stageCompute.usedTimes++;\n      \
data.version = computeNode.version;\n      data.pipeline = pipeline;\n    }\n \
   return data.pipeline;\n  }\n  getForRender(renderObject, promises = null) \
{\n    const { backend } = this;\n    const data = this.get(renderObject);\n  \
  if (this._needsRenderUpdate(renderObject)) {\n      const previousPipeline \
= data.pipeline;\n      if (previousPipeline) {\n        \
previousPipeline.usedTimes--;\n        \
previousPipeline.vertexProgram.usedTimes--;\n        \
previousPipeline.fragmentProgram.usedTimes--;\n      }\n      const \
nodeBuilderState = renderObject.getNodeBuilderState();\n      let stageVertex \
= this.programs.vertex.get(nodeBuilderState.vertexShader);\n      if \
(stageVertex === void 0) {\n        if (previousPipeline && \
previousPipeline.vertexProgram.usedTimes === 0) \
this._releaseProgram(previousPipeline.vertexProgram);\n        stageVertex = \
new ProgrammableStage(nodeBuilderState.vertexShader, \"vertex\");\n        \
this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);\n       \
 backend.createProgram(stageVertex);\n      }\n      let stageFragment = \
this.programs.fragment.get(nodeBuilderState.fragmentShader);\n      if \
(stageFragment === void 0) {\n        if (previousPipeline && \
previousPipeline.fragmentProgram.usedTimes === 0) \
this._releaseProgram(previousPipeline.fragmentProgram);\n        \
stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, \
\"fragment\");\n        \
this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);\n \
       backend.createProgram(stageFragment);\n      }\n      const cacheKey = \
this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n      let \
pipeline = this.caches.get(cacheKey);\n      if (pipeline === void 0) {\n     \
   if (previousPipeline && previousPipeline.usedTimes === 0) \
this._releasePipeline(previousPipeline);\n        pipeline = \
this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, \
promises);\n      } else {\n        renderObject.pipeline = pipeline;\n      \
}\n      pipeline.usedTimes++;\n      stageVertex.usedTimes++;\n      \
stageFragment.usedTimes++;\n      data.pipeline = pipeline;\n    }\n    \
return data.pipeline;\n  }\n  delete(object) {\n    const pipeline = \
this.get(object).pipeline;\n    if (pipeline) {\n      \
pipeline.usedTimes--;\n      if (pipeline.usedTimes === 0) \
this._releasePipeline(pipeline);\n      if (pipeline.isComputePipeline) {\n   \
     pipeline.computeProgram.usedTimes--;\n        if \
(pipeline.computeProgram.usedTimes === 0) \
this._releaseProgram(pipeline.computeProgram);\n      } else {\n        \
pipeline.fragmentProgram.usedTimes--;\n        \
pipeline.vertexProgram.usedTimes--;\n        if \
(pipeline.vertexProgram.usedTimes === 0) \
this._releaseProgram(pipeline.vertexProgram);\n        if \
(pipeline.fragmentProgram.usedTimes === 0) \
this._releaseProgram(pipeline.fragmentProgram);\n      }\n    }\n    return \
super.delete(object);\n  }\n  dispose() {\n    super.dispose();\n    \
this.caches = /* @__PURE__ */ new Map();\n    this.programs = {\n      \
vertex: /* @__PURE__ */ new Map(),\n      fragment: /* @__PURE__ */ new \
Map(),\n      compute: /* @__PURE__ */ new Map()\n    };\n  }\n  \
updateForRender(renderObject) {\n    this.getForRender(renderObject);\n  }\n  \
_getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {\n    \
cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);\n \
   let pipeline = this.caches.get(cacheKey);\n    if (pipeline === void 0) \
{\n      pipeline = new ComputePipeline(cacheKey, stageCompute);\n      \
this.caches.set(cacheKey, pipeline);\n      \
this.backend.createComputePipeline(pipeline, bindings);\n    }\n    return \
pipeline;\n  }\n  _getRenderPipeline(renderObject, stageVertex, \
stageFragment, cacheKey, promises) {\n    cacheKey = cacheKey || \
this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n    let \
pipeline = this.caches.get(cacheKey);\n    if (pipeline === void 0) {\n      \
pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);\n      \
this.caches.set(cacheKey, pipeline);\n      renderObject.pipeline = \
pipeline;\n      this.backend.createRenderPipeline(renderObject, promises);\n \
   }\n    return pipeline;\n  }\n  _getComputeCacheKey(computeNode, \
stageCompute) {\n    return computeNode.id + \",\" + stageCompute.id;\n  }\n  \
_getRenderCacheKey(renderObject, stageVertex, stageFragment) {\n    return \
stageVertex.id + \",\" + stageFragment.id + \",\" + \
this.backend.getRenderCacheKey(renderObject);\n  }\n  \
_releasePipeline(pipeline) {\n    this.caches.delete(pipeline.cacheKey);\n  \
}\n  _releaseProgram(program) {\n    const code = program.code;\n    const \
stage = program.stage;\n    this.programs[stage].delete(code);\n  }\n  \
_needsComputeUpdate(computeNode) {\n    const data = this.get(computeNode);\n \
   return data.pipeline === void 0 || data.version !== computeNode.version;\n \
 }\n  _needsRenderUpdate(renderObject) {\n    const data = \
this.get(renderObject);\n    return data.pipeline === void 0 || \
this.backend.needsRenderUpdate(renderObject);\n  }\n};\nvar Bindings = class \
extends DataMap {\n  constructor(backend, nodes, textures, attributes, \
pipelines, info) {\n    super();\n    this.backend = backend;\n    \
this.textures = textures;\n    this.pipelines = pipelines;\n    \
this.attributes = attributes;\n    this.nodes = nodes;\n    this.info = \
info;\n    this.pipelines.bindings = this;\n  }\n  getForRender(renderObject) \
{\n    const bindings = renderObject.getBindings();\n    for (const bindGroup \
of bindings) {\n      const groupData = this.get(bindGroup);\n      if \
(groupData.bindGroup === void 0) {\n        this._init(bindGroup);\n        \
this.backend.createBindings(bindGroup, bindings);\n        \
groupData.bindGroup = bindGroup;\n      }\n    }\n    return bindings;\n  }\n \
 getForCompute(computeNode) {\n    const bindings = \
this.nodes.getForCompute(computeNode).bindings;\n    for (const bindGroup of \
bindings) {\n      const groupData = this.get(bindGroup);\n      if \
(groupData.bindGroup === void 0) {\n        this._init(bindGroup);\n        \
this.backend.createBindings(bindGroup, bindings);\n        \
groupData.bindGroup = bindGroup;\n      }\n    }\n    return bindings;\n  }\n \
 updateForCompute(computeNode) {\n    \
this._updateBindings(this.getForCompute(computeNode));\n  }\n  \
updateForRender(renderObject) {\n    \
this._updateBindings(this.getForRender(renderObject));\n  }\n  \
_updateBindings(bindings) {\n    for (const bindGroup of bindings) {\n      \
this._update(bindGroup, bindings);\n    }\n  }\n  _init(bindGroup) {\n    for \
(const binding of bindGroup.bindings) {\n      if (binding.isSampledTexture) \
{\n        this.textures.updateTexture(binding.texture);\n      } else if \
(binding.isStorageBuffer) {\n        const attribute2 = binding.attribute;\n  \
      const attributeType = attribute2.isIndirectStorageBufferAttribute ? \
AttributeType.INDIRECT : AttributeType.STORAGE;\n        \
this.attributes.update(attribute2, attributeType);\n      }\n    }\n  }\n  \
_update(bindGroup, bindings) {\n    const { backend } = this;\n    let \
needsBindingsUpdate = false;\n    for (const binding of bindGroup.bindings) \
{\n      if (binding.isNodeUniformsGroup) {\n        const updated = \
this.nodes.updateGroup(binding);\n        if (!updated) continue;\n      }\n  \
    if (binding.isUniformBuffer) {\n        const updated = \
binding.update();\n        if (updated) {\n          \
backend.updateBinding(binding);\n        }\n      } else if \
(binding.isSampler) {\n        binding.update();\n      } else if \
(binding.isSampledTexture) {\n        if \
(binding.needsBindingsUpdate(this.textures.get(binding.texture).generation)) \
needsBindingsUpdate = true;\n        const updated = binding.update();\n      \
  const texture2 = binding.texture;\n        if (updated) {\n          \
this.textures.updateTexture(texture2);\n        }\n        const textureData \
= backend.get(texture2);\n        if (backend.isWebGPUBackend === true && \
textureData.texture === void 0 && textureData.externalTexture === void 0) {\n \
         console.error(\"Bindings._update: binding should be available:\", \
binding, updated, texture2, binding.textureNode.value, \
needsBindingsUpdate);\n          this.textures.updateTexture(texture2);\n     \
     needsBindingsUpdate = true;\n        }\n        if \
(texture2.isStorageTexture === true) {\n          const textureData2 = \
this.get(texture2);\n          if (binding.store === true) {\n            \
textureData2.needsMipmap = true;\n          } else if \
(this.textures.needsMipmaps(texture2) && textureData2.needsMipmap === true) \
{\n            this.backend.generateMipmaps(texture2);\n            \
textureData2.needsMipmap = false;\n          }\n        }\n      }\n    }\n   \
 if (needsBindingsUpdate === true) {\n      \
this.backend.updateBindings(bindGroup, bindings);\n    }\n  }\n};\nfunction \
painterSortStable2(a2, b) {\n  if (a2.groupOrder !== b.groupOrder) {\n    \
return a2.groupOrder - b.groupOrder;\n  } else if (a2.renderOrder !== \
b.renderOrder) {\n    return a2.renderOrder - b.renderOrder;\n  } else if \
(a2.material.id !== b.material.id) {\n    return a2.material.id - \
b.material.id;\n  } else if (a2.z !== b.z) {\n    return a2.z - b.z;\n  } \
else {\n    return a2.id - b.id;\n  }\n}\nfunction \
reversePainterSortStable2(a2, b) {\n  if (a2.groupOrder !== b.groupOrder) {\n \
   return a2.groupOrder - b.groupOrder;\n  } else if (a2.renderOrder !== \
b.renderOrder) {\n    return a2.renderOrder - b.renderOrder;\n  } else if \
(a2.z !== b.z) {\n    return b.z - a2.z;\n  } else {\n    return a2.id - \
b.id;\n  }\n}\nfunction needsDoublePass(material) {\n  const hasTransmission \
= material.transmission > 0 || material.transmissionNode;\n  return \
hasTransmission && material.side === DoubleSide2 && material.forceSinglePass \
=== false;\n}\nvar RenderList = class {\n  constructor(lighting, scene3, \
camera3) {\n    this.renderItems = [];\n    this.renderItemsIndex = 0;\n    \
this.opaque = [];\n    this.transparentDoublePass = [];\n    this.transparent \
= [];\n    this.bundles = [];\n    this.lightsNode = lighting.getNode(scene3, \
camera3);\n    this.lightsArray = [];\n    this.scene = scene3;\n    \
this.camera = camera3;\n    this.occlusionQueryCount = 0;\n  }\n  begin() {\n \
   this.renderItemsIndex = 0;\n    this.opaque.length = 0;\n    \
this.transparentDoublePass.length = 0;\n    this.transparent.length = 0;\n    \
this.bundles.length = 0;\n    this.lightsArray.length = 0;\n    \
this.occlusionQueryCount = 0;\n    return this;\n  }\n  \
getNextRenderItem(object, geometry, material, groupOrder, z2, group) {\n    \
let renderItem = this.renderItems[this.renderItemsIndex];\n    if (renderItem \
=== void 0) {\n      renderItem = {\n        id: object.id,\n        \
object,\n        geometry,\n        material,\n        groupOrder,\n        \
renderOrder: object.renderOrder,\n        z: z2,\n        group\n      };\n   \
   this.renderItems[this.renderItemsIndex] = renderItem;\n    } else {\n      \
renderItem.id = object.id;\n      renderItem.object = object;\n      \
renderItem.geometry = geometry;\n      renderItem.material = material;\n      \
renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = \
object.renderOrder;\n      renderItem.z = z2;\n      renderItem.group = \
group;\n    }\n    this.renderItemsIndex++;\n    return renderItem;\n  }\n  \
push(object, geometry, material, groupOrder, z2, group) {\n    const \
renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, \
z2, group);\n    if (object.occlusionTest === true) \
this.occlusionQueryCount++;\n    if (material.transparent === true || \
material.transmission > 0) {\n      if (needsDoublePass(material)) \
this.transparentDoublePass.push(renderItem);\n      \
this.transparent.push(renderItem);\n    } else {\n      \
this.opaque.push(renderItem);\n    }\n  }\n  unshift(object, geometry, \
material, groupOrder, z2, group) {\n    const renderItem = \
this.getNextRenderItem(object, geometry, material, groupOrder, z2, group);\n  \
  if (material.transparent === true || material.transmission > 0) {\n      if \
(needsDoublePass(material)) this.transparentDoublePass.unshift(renderItem);\n \
     this.transparent.unshift(renderItem);\n    } else {\n      \
this.opaque.unshift(renderItem);\n    }\n  }\n  pushBundle(group) {\n    \
this.bundles.push(group);\n  }\n  pushLight(light) {\n    \
this.lightsArray.push(light);\n  }\n  sort(customOpaqueSort, \
customTransparentSort) {\n    if (this.opaque.length > 1) \
this.opaque.sort(customOpaqueSort || painterSortStable2);\n    if \
(this.transparentDoublePass.length > 1) \
this.transparentDoublePass.sort(customTransparentSort || \
reversePainterSortStable2);\n    if (this.transparent.length > 1) \
this.transparent.sort(customTransparentSort || reversePainterSortStable2);\n  \
}\n  finish() {\n    this.lightsNode.setLights(this.lightsArray);\n    for \
(let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) \
{\n      const renderItem = this.renderItems[i];\n      if (renderItem.id === \
null) break;\n      renderItem.id = null;\n      renderItem.object = null;\n  \
    renderItem.geometry = null;\n      renderItem.material = null;\n      \
renderItem.groupOrder = null;\n      renderItem.renderOrder = null;\n      \
renderItem.z = null;\n      renderItem.group = null;\n    }\n  }\n};\nvar \
RenderLists = class {\n  constructor(lighting) {\n    this.lighting = \
lighting;\n    this.lists = new ChainMap();\n  }\n  get(scene3, camera3) {\n  \
  const lists = this.lists;\n    const keys = [scene3, camera3];\n    let \
list = lists.get(keys);\n    if (list === void 0) {\n      list = new \
RenderList(this.lighting, scene3, camera3);\n      lists.set(keys, list);\n   \
 }\n    return list;\n  }\n  dispose() {\n    this.lists = new ChainMap();\n  \
}\n};\nvar id$1 = 0;\nvar RenderContext = class {\n  constructor() {\n    \
this.id = id$1++;\n    this.color = true;\n    this.clearColor = true;\n    \
this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };\n    this.depth = true;\n  \
  this.clearDepth = true;\n    this.clearDepthValue = 1;\n    this.stencil = \
false;\n    this.clearStencil = true;\n    this.clearStencilValue = 1;\n    \
this.viewport = false;\n    this.viewportValue = new Vector42();\n    \
this.scissor = false;\n    this.scissorValue = new Vector42();\n    \
this.textures = null;\n    this.depthTexture = null;\n    this.activeCubeFace \
= 0;\n    this.sampleCount = 1;\n    this.width = 0;\n    this.height = 0;\n  \
  this.isRenderContext = true;\n  }\n  getCacheKey() {\n    return \
getCacheKey(this);\n  }\n};\nfunction getCacheKey(renderContext) {\n  const { \
textures, activeCubeFace } = renderContext;\n  const values = \
[activeCubeFace];\n  for (const texture2 of textures) {\n    \
values.push(texture2.id);\n  }\n  return hashArray(values);\n}\nvar \
RenderContexts = class {\n  constructor() {\n    this.chainMaps = {};\n  }\n  \
get(scene3, camera3, renderTarget = null) {\n    const chainKey = [scene3, \
camera3];\n    let attachmentState;\n    if (renderTarget === null) {\n      \
attachmentState = \"default\";\n    } else {\n      const format2 = \
renderTarget.texture.format;\n      const count = \
renderTarget.textures.length;\n      attachmentState = \
`${count}:${format2}:${renderTarget.samples}:${renderTarget.depthBuffer}:${re\
nderTarget.stencilBuffer}`;\n    }\n    const chainMap = \
this.getChainMap(attachmentState);\n    let renderState = \
chainMap.get(chainKey);\n    if (renderState === void 0) {\n      renderState \
= new RenderContext();\n      chainMap.set(chainKey, renderState);\n    }\n   \
 if (renderTarget !== null) renderState.sampleCount = renderTarget.samples \
=== 0 ? 1 : renderTarget.samples;\n    return renderState;\n  }\n  \
getChainMap(attachmentState) {\n    return this.chainMaps[attachmentState] || \
(this.chainMaps[attachmentState] = new ChainMap());\n  }\n  dispose() {\n    \
this.chainMaps = {};\n  }\n};\nvar _size$3 = /* @__PURE__ */ new \
Vector32();\nvar Textures = class extends DataMap {\n  constructor(renderer3, \
backend, info) {\n    super();\n    this.renderer = renderer3;\n    \
this.backend = backend;\n    this.info = info;\n  }\n  \
updateRenderTarget(renderTarget, activeMipmapLevel = 0) {\n    const \
renderTargetData = this.get(renderTarget);\n    const sampleCount = \
renderTarget.samples === 0 ? 1 : renderTarget.samples;\n    const \
depthTextureMips = renderTargetData.depthTextureMips || \
(renderTargetData.depthTextureMips = {});\n    const textures = \
renderTarget.textures;\n    const size = this.getSize(textures[0]);\n    \
const mipWidth = size.width >> activeMipmapLevel;\n    const mipHeight = \
size.height >> activeMipmapLevel;\n    let depthTexture = \
renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];\n    const \
useDepthTexture = renderTarget.depthBuffer === true || \
renderTarget.stencilBuffer === true;\n    let textureNeedsUpdate = false;\n   \
 if (depthTexture === void 0 && useDepthTexture) {\n      depthTexture = new \
DepthTexture2();\n      depthTexture.format = renderTarget.stencilBuffer ? \
DepthStencilFormat2 : DepthFormat2;\n      depthTexture.type = \
renderTarget.stencilBuffer ? UnsignedInt248Type2 : UnsignedIntType2;\n      \
depthTexture.image.width = mipWidth;\n      depthTexture.image.height = \
mipHeight;\n      depthTextureMips[activeMipmapLevel] = depthTexture;\n    \
}\n    if (renderTargetData.width !== size.width || size.height !== \
renderTargetData.height) {\n      textureNeedsUpdate = true;\n      if \
(depthTexture) {\n        depthTexture.needsUpdate = true;\n        \
depthTexture.image.width = mipWidth;\n        depthTexture.image.height = \
mipHeight;\n      }\n    }\n    renderTargetData.width = size.width;\n    \
renderTargetData.height = size.height;\n    renderTargetData.textures = \
textures;\n    renderTargetData.depthTexture = depthTexture || null;\n    \
renderTargetData.depth = renderTarget.depthBuffer;\n    \
renderTargetData.stencil = renderTarget.stencilBuffer;\n    \
renderTargetData.renderTarget = renderTarget;\n    if \
(renderTargetData.sampleCount !== sampleCount) {\n      textureNeedsUpdate = \
true;\n      if (depthTexture) {\n        depthTexture.needsUpdate = true;\n  \
    }\n      renderTargetData.sampleCount = sampleCount;\n    }\n    const \
options = { sampleCount };\n    for (let i = 0; i < textures.length; i++) {\n \
     const texture2 = textures[i];\n      if (textureNeedsUpdate) \
texture2.needsUpdate = true;\n      this.updateTexture(texture2, options);\n  \
  }\n    if (depthTexture) {\n      this.updateTexture(depthTexture, \
options);\n    }\n    if (renderTargetData.initialized !== true) {\n      \
renderTargetData.initialized = true;\n      const onDispose = () => {\n       \
 renderTarget.removeEventListener(\"dispose\", onDispose);\n        for (let \
i = 0; i < textures.length; i++) {\n          \
this._destroyTexture(textures[i]);\n        }\n        if (depthTexture) {\n  \
        this._destroyTexture(depthTexture);\n        }\n        \
this.delete(renderTarget);\n      };\n      \
renderTarget.addEventListener(\"dispose\", onDispose);\n    }\n  }\n  \
updateTexture(texture2, options = {}) {\n    const textureData = \
this.get(texture2);\n    if (textureData.initialized === true && \
textureData.version === texture2.version) return;\n    const isRenderTarget = \
texture2.isRenderTargetTexture || texture2.isDepthTexture || \
texture2.isFramebufferTexture;\n    const backend = this.backend;\n    if \
(isRenderTarget && textureData.initialized === true) {\n      \
backend.destroySampler(texture2);\n      backend.destroyTexture(texture2);\n  \
  }\n    if (texture2.isFramebufferTexture) {\n      const renderTarget = \
this.renderer.getRenderTarget();\n      if (renderTarget) {\n        \
texture2.type = renderTarget.texture.type;\n      } else {\n        \
texture2.type = UnsignedByteType2;\n      }\n    }\n    const { width, \
height, depth: depth2 } = this.getSize(texture2);\n    options.width = \
width;\n    options.height = height;\n    options.depth = depth2;\n    \
options.needsMipmaps = this.needsMipmaps(texture2);\n    options.levels = \
options.needsMipmaps ? this.getMipLevels(texture2, width, height) : 1;\n    \
if (isRenderTarget || texture2.isStorageTexture === true) {\n      \
backend.createSampler(texture2);\n      backend.createTexture(texture2, \
options);\n      textureData.generation = texture2.version;\n    } else {\n   \
   const needsCreate = textureData.initialized !== true;\n      if \
(needsCreate) backend.createSampler(texture2);\n      if (texture2.version > \
0) {\n        const image = texture2.image;\n        if (image === void 0) \
{\n          console.warn(\"THREE.Renderer: Texture marked for update but \
image is undefined.\");\n        } else if (image.complete === false) {\n     \
     console.warn(\"THREE.Renderer: Texture marked for update but image is \
incomplete.\");\n        } else {\n          if (texture2.images) {\n         \
   const images = [];\n            for (const image2 of texture2.images) {\n  \
            images.push(image2);\n            }\n            options.images = \
images;\n          } else {\n            options.image = image;\n          \
}\n          if (textureData.isDefaultTexture === void 0 || \
textureData.isDefaultTexture === true) {\n            \
backend.createTexture(texture2, options);\n            \
textureData.isDefaultTexture = false;\n            textureData.generation = \
texture2.version;\n          }\n          if (texture2.source.dataReady === \
true) backend.updateTexture(texture2, options);\n          if \
(options.needsMipmaps && texture2.mipmaps.length === 0) \
backend.generateMipmaps(texture2);\n        }\n      } else {\n        \
backend.createDefaultTexture(texture2);\n        textureData.isDefaultTexture \
= true;\n        textureData.generation = texture2.version;\n      }\n    }\n \
   if (textureData.initialized !== true) {\n      textureData.initialized = \
true;\n      textureData.generation = texture2.version;\n      \
this.info.memory.textures++;\n      const onDispose = () => {\n        \
texture2.removeEventListener(\"dispose\", onDispose);\n        \
this._destroyTexture(texture2);\n        this.info.memory.textures--;\n      \
};\n      texture2.addEventListener(\"dispose\", onDispose);\n    }\n    \
textureData.version = texture2.version;\n  }\n  getSize(texture2, target = \
_size$3) {\n    let image = texture2.images ? texture2.images[0] : \
texture2.image;\n    if (image) {\n      if (image.image !== void 0) image = \
image.image;\n      target.width = image.width;\n      target.height = \
image.height;\n      target.depth = texture2.isCubeTexture ? 6 : image.depth \
|| 1;\n    } else {\n      target.width = target.height = target.depth = 1;\n \
   }\n    return target;\n  }\n  getMipLevels(texture2, width, height) {\n    \
let mipLevelCount;\n    if (texture2.isCompressedTexture) {\n      \
mipLevelCount = texture2.mipmaps.length;\n    } else {\n      mipLevelCount = \
Math.floor(Math.log2(Math.max(width, height))) + 1;\n    }\n    return \
mipLevelCount;\n  }\n  needsMipmaps(texture2) {\n    return \
this.isEnvironmentTexture(texture2) || texture2.isCompressedTexture === true \
|| texture2.generateMipmaps;\n  }\n  isEnvironmentTexture(texture2) {\n    \
const mapping = texture2.mapping;\n    return mapping === \
EquirectangularReflectionMapping2 || mapping === \
EquirectangularRefractionMapping2 || (mapping === CubeReflectionMapping2 || \
mapping === CubeRefractionMapping2);\n  }\n  _destroyTexture(texture2) {\n    \
this.backend.destroySampler(texture2);\n    \
this.backend.destroyTexture(texture2);\n    this.delete(texture2);\n  \
}\n};\nvar Color4 = class extends Color2 {\n  constructor(r, g, b, a2 = 1) \
{\n    super(r, g, b);\n    this.a = a2;\n  }\n  set(r, g, b, a2 = 1) {\n    \
this.a = a2;\n    return super.set(r, g, b);\n  }\n  copy(color2) {\n    if \
(color2.a !== void 0) this.a = color2.a;\n    return super.copy(color2);\n  \
}\n  clone() {\n    return new this.constructor(this.r, this.g, this.b, \
this.a);\n  }\n};\nvar ParameterNode = class extends PropertyNode {\n  static \
get type() {\n    return \"ParameterNode\";\n  }\n  constructor(nodeType, \
name = null) {\n    super(nodeType, name);\n    this.isParameterNode = \
true;\n  }\n  getHash() {\n    return this.uuid;\n  }\n  generate() {\n    \
return this.name;\n  }\n};\nvar StackNode = class extends Node {\n  static \
get type() {\n    return \"StackNode\";\n  }\n  constructor(parent = null) \
{\n    super();\n    this.nodes = [];\n    this.outputNode = null;\n    \
this.parent = parent;\n    this._currentCond = null;\n    this.isStackNode = \
true;\n  }\n  getNodeType(builder) {\n    return this.outputNode ? \
this.outputNode.getNodeType(builder) : \"void\";\n  }\n  add(node) {\n    \
this.nodes.push(node);\n    return this;\n  }\n  If(boolNode, method) {\n    \
const methodNode = new ShaderNode(method);\n    this._currentCond = \
select(boolNode, methodNode);\n    return this.add(this._currentCond);\n  }\n \
 ElseIf(boolNode, method) {\n    const methodNode = new ShaderNode(method);\n \
   const ifNode = select(boolNode, methodNode);\n    \
this._currentCond.elseNode = ifNode;\n    this._currentCond = ifNode;\n    \
return this;\n  }\n  Else(method) {\n    this._currentCond.elseNode = new \
ShaderNode(method);\n    return this;\n  }\n  build(builder, ...params) {\n   \
 const previousStack = getCurrentStack();\n    setCurrentStack(this);\n    \
for (const node of this.nodes) {\n      node.build(builder, \"void\");\n    \
}\n    setCurrentStack(previousStack);\n    return this.outputNode ? \
this.outputNode.build(builder, ...params) : super.build(builder, \
...params);\n  }\n  //\n  else(...params) {\n    \
console.warn(\"TSL.StackNode: .else() has been renamed to .Else().\");\n    \
return this.Else(...params);\n  }\n  elseif(...params) {\n    \
console.warn(\"TSL.StackNode: .elseif() has been renamed to .ElseIf().\");\n  \
  return this.ElseIf(...params);\n  }\n};\nvar stack = /* @__PURE__ */ \
nodeProxy(StackNode);\nvar _reflectorPlane = new Plane2();\nvar _normal = new \
Vector32();\nvar _reflectorWorldPosition = new Vector32();\nvar \
_cameraWorldPosition = new Vector32();\nvar _rotationMatrix = new \
Matrix42();\nvar _lookAtPosition = new Vector32(0, 0, -1);\nvar clipPlane = \
new Vector42();\nvar _view = new Vector32();\nvar _target2 = new \
Vector32();\nvar _q = new Vector42();\nvar _size$2 = new Vector22();\nvar \
_defaultRT = new RenderTarget2();\nvar _defaultUV = \
screenUV.flipX();\n_defaultRT.depthTexture = new DepthTexture2(1, 1);\nvar \
_camera = /* @__PURE__ */ new OrthographicCamera2(-1, 1, 1, -1, 0, 1);\nvar \
QuadGeometry = class extends BufferGeometry2 {\n  constructor(flipY = false) \
{\n    super();\n    const uv2 = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, \
2, 0, 0, 2, 0];\n    this.setAttribute(\"position\", new \
Float32BufferAttribute2([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));\n    \
this.setAttribute(\"uv\", new Float32BufferAttribute2(uv2, 2));\n  }\n};\nvar \
_geometry = /* @__PURE__ */ new QuadGeometry();\nvar QuadMesh = class extends \
Mesh2 {\n  constructor(material = null) {\n    super(_geometry, material);\n  \
  this.camera = _camera;\n    this.isQuadMesh = true;\n  }\n  \
renderAsync(renderer3) {\n    return renderer3.renderAsync(this, _camera);\n  \
}\n  render(renderer3) {\n    renderer3.render(this, _camera);\n  }\n};\nvar \
_e12 = /* @__PURE__ */ new Euler2();\nvar _m12 = /* @__PURE__ */ new \
Matrix42();\nvar SceneNode = class _SceneNode extends Node {\n  static get \
type() {\n    return \"SceneNode\";\n  }\n  constructor(scope = \
_SceneNode.BACKGROUND_BLURRINESS, scene3 = null) {\n    super();\n    \
this.scope = scope;\n    this.scene = scene3;\n  }\n  setup(builder) {\n    \
const scope = this.scope;\n    const scene3 = this.scene !== null ? \
this.scene : builder.scene;\n    let output2;\n    if (scope === \
_SceneNode.BACKGROUND_BLURRINESS) {\n      output2 = \
reference(\"backgroundBlurriness\", \"float\", scene3);\n    } else if (scope \
=== _SceneNode.BACKGROUND_INTENSITY) {\n      output2 = \
reference(\"backgroundIntensity\", \"float\", scene3);\n    } else if (scope \
=== _SceneNode.BACKGROUND_ROTATION) {\n      output2 = \
uniform(\"mat4\").label(\"backgroundRotation\").setGroup(renderGroup).onRende\
rUpdate(() => {\n        const background = scene3.background;\n        if \
(background !== null && background.isTexture && background.mapping !== \
UVMapping2) {\n          _e12.copy(scene3.backgroundRotation);\n          \
_e12.x *= -1;\n          _e12.y *= -1;\n          _e12.z *= -1;\n          \
_m12.makeRotationFromEuler(_e12);\n        } else {\n          \
_m12.identity();\n        }\n        return _m12;\n      });\n    } else {\n  \
    console.error(\"THREE.SceneNode: Unknown scope:\", scope);\n    }\n    \
return output2;\n  }\n};\nSceneNode.BACKGROUND_BLURRINESS = \
\"backgroundBlurriness\";\nSceneNode.BACKGROUND_INTENSITY = \
\"backgroundIntensity\";\nSceneNode.BACKGROUND_ROTATION = \
\"backgroundRotation\";\nvar backgroundBlurriness = /* @__PURE__ */ \
nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);\nvar \
backgroundIntensity = /* @__PURE__ */ nodeImmutable(SceneNode, \
SceneNode.BACKGROUND_INTENSITY);\nvar backgroundRotation = /* @__PURE__ */ \
nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);\nvar \
GPUPrimitiveTopology = {\n  PointList: \"point-list\",\n  LineList: \
\"line-list\",\n  LineStrip: \"line-strip\",\n  TriangleList: \
\"triangle-list\",\n  TriangleStrip: \"triangle-strip\"\n};\nvar \
GPUCompareFunction = {\n  Never: \"never\",\n  Less: \"less\",\n  Equal: \
\"equal\",\n  LessEqual: \"less-equal\",\n  Greater: \"greater\",\n  \
NotEqual: \"not-equal\",\n  GreaterEqual: \"greater-equal\",\n  Always: \
\"always\"\n};\nvar GPUStoreOp = {\n  Store: \"store\",\n  Discard: \
\"discard\"\n};\nvar GPULoadOp = {\n  Load: \"load\",\n  Clear: \
\"clear\"\n};\nvar GPUFrontFace = {\n  CCW: \"ccw\",\n  CW: \"cw\"\n};\nvar \
GPUCullMode = {\n  None: \"none\",\n  Front: \"front\",\n  Back: \
\"back\"\n};\nvar GPUIndexFormat = {\n  Uint16: \"uint16\",\n  Uint32: \
\"uint32\"\n};\nvar GPUTextureFormat = {\n  // 8-bit formats\n  R8Unorm: \
\"r8unorm\",\n  R8Snorm: \"r8snorm\",\n  R8Uint: \"r8uint\",\n  R8Sint: \
\"r8sint\",\n  // 16-bit formats\n  R16Uint: \"r16uint\",\n  R16Sint: \
\"r16sint\",\n  R16Float: \"r16float\",\n  RG8Unorm: \"rg8unorm\",\n  \
RG8Snorm: \"rg8snorm\",\n  RG8Uint: \"rg8uint\",\n  RG8Sint: \"rg8sint\",\n  \
// 32-bit formats\n  R32Uint: \"r32uint\",\n  R32Sint: \"r32sint\",\n  \
R32Float: \"r32float\",\n  RG16Uint: \"rg16uint\",\n  RG16Sint: \
\"rg16sint\",\n  RG16Float: \"rg16float\",\n  RGBA8Unorm: \"rgba8unorm\",\n  \
RGBA8UnormSRGB: \"rgba8unorm-srgb\",\n  RGBA8Snorm: \"rgba8snorm\",\n  \
RGBA8Uint: \"rgba8uint\",\n  RGBA8Sint: \"rgba8sint\",\n  BGRA8Unorm: \
\"bgra8unorm\",\n  BGRA8UnormSRGB: \"bgra8unorm-srgb\",\n  // Packed 32-bit \
formats\n  RGB9E5UFloat: \"rgb9e5ufloat\",\n  RGB10A2Unorm: \
\"rgb10a2unorm\",\n  RG11B10uFloat: \"rgb10a2unorm\",\n  // 64-bit formats\n  \
RG32Uint: \"rg32uint\",\n  RG32Sint: \"rg32sint\",\n  RG32Float: \
\"rg32float\",\n  RGBA16Uint: \"rgba16uint\",\n  RGBA16Sint: \
\"rgba16sint\",\n  RGBA16Float: \"rgba16float\",\n  // 128-bit formats\n  \
RGBA32Uint: \"rgba32uint\",\n  RGBA32Sint: \"rgba32sint\",\n  RGBA32Float: \
\"rgba32float\",\n  // Depth and stencil formats\n  Stencil8: \"stencil8\",\n \
 Depth16Unorm: \"depth16unorm\",\n  Depth24Plus: \"depth24plus\",\n  \
Depth24PlusStencil8: \"depth24plus-stencil8\",\n  Depth32Float: \
\"depth32float\",\n  // 'depth32float-stencil8' extension\n  \
Depth32FloatStencil8: \"depth32float-stencil8\",\n  // BC compressed formats \
usable if 'texture-compression-bc' is both\n  // supported by the device/user \
agent and enabled in requestDevice.\n  BC1RGBAUnorm: \"bc1-rgba-unorm\",\n  \
BC1RGBAUnormSRGB: \"bc1-rgba-unorm-srgb\",\n  BC2RGBAUnorm: \
\"bc2-rgba-unorm\",\n  BC2RGBAUnormSRGB: \"bc2-rgba-unorm-srgb\",\n  \
BC3RGBAUnorm: \"bc3-rgba-unorm\",\n  BC3RGBAUnormSRGB: \
\"bc3-rgba-unorm-srgb\",\n  BC4RUnorm: \"bc4-r-unorm\",\n  BC4RSnorm: \
\"bc4-r-snorm\",\n  BC5RGUnorm: \"bc5-rg-unorm\",\n  BC5RGSnorm: \
\"bc5-rg-snorm\",\n  BC6HRGBUFloat: \"bc6h-rgb-ufloat\",\n  BC6HRGBFloat: \
\"bc6h-rgb-float\",\n  BC7RGBAUnorm: \"bc7-rgba-unorm\",\n  BC7RGBAUnormSRGB: \
\"bc7-rgba-srgb\",\n  // ETC2 compressed formats usable if \
'texture-compression-etc2' is both\n  // supported by the device/user agent \
and enabled in requestDevice.\n  ETC2RGB8Unorm: \"etc2-rgb8unorm\",\n  \
ETC2RGB8UnormSRGB: \"etc2-rgb8unorm-srgb\",\n  ETC2RGB8A1Unorm: \
\"etc2-rgb8a1unorm\",\n  ETC2RGB8A1UnormSRGB: \"etc2-rgb8a1unorm-srgb\",\n  \
ETC2RGBA8Unorm: \"etc2-rgba8unorm\",\n  ETC2RGBA8UnormSRGB: \
\"etc2-rgba8unorm-srgb\",\n  EACR11Unorm: \"eac-r11unorm\",\n  EACR11Snorm: \
\"eac-r11snorm\",\n  EACRG11Unorm: \"eac-rg11unorm\",\n  EACRG11Snorm: \
\"eac-rg11snorm\",\n  // ASTC compressed formats usable if \
'texture-compression-astc' is both\n  // supported by the device/user agent \
and enabled in requestDevice.\n  ASTC4x4Unorm: \"astc-4x4-unorm\",\n  \
ASTC4x4UnormSRGB: \"astc-4x4-unorm-srgb\",\n  ASTC5x4Unorm: \
\"astc-5x4-unorm\",\n  ASTC5x4UnormSRGB: \"astc-5x4-unorm-srgb\",\n  \
ASTC5x5Unorm: \"astc-5x5-unorm\",\n  ASTC5x5UnormSRGB: \
\"astc-5x5-unorm-srgb\",\n  ASTC6x5Unorm: \"astc-6x5-unorm\",\n  \
ASTC6x5UnormSRGB: \"astc-6x5-unorm-srgb\",\n  ASTC6x6Unorm: \
\"astc-6x6-unorm\",\n  ASTC6x6UnormSRGB: \"astc-6x6-unorm-srgb\",\n  \
ASTC8x5Unorm: \"astc-8x5-unorm\",\n  ASTC8x5UnormSRGB: \
\"astc-8x5-unorm-srgb\",\n  ASTC8x6Unorm: \"astc-8x6-unorm\",\n  \
ASTC8x6UnormSRGB: \"astc-8x6-unorm-srgb\",\n  ASTC8x8Unorm: \
\"astc-8x8-unorm\",\n  ASTC8x8UnormSRGB: \"astc-8x8-unorm-srgb\",\n  \
ASTC10x5Unorm: \"astc-10x5-unorm\",\n  ASTC10x5UnormSRGB: \
\"astc-10x5-unorm-srgb\",\n  ASTC10x6Unorm: \"astc-10x6-unorm\",\n  \
ASTC10x6UnormSRGB: \"astc-10x6-unorm-srgb\",\n  ASTC10x8Unorm: \
\"astc-10x8-unorm\",\n  ASTC10x8UnormSRGB: \"astc-10x8-unorm-srgb\",\n  \
ASTC10x10Unorm: \"astc-10x10-unorm\",\n  ASTC10x10UnormSRGB: \
\"astc-10x10-unorm-srgb\",\n  ASTC12x10Unorm: \"astc-12x10-unorm\",\n  \
ASTC12x10UnormSRGB: \"astc-12x10-unorm-srgb\",\n  ASTC12x12Unorm: \
\"astc-12x12-unorm\",\n  ASTC12x12UnormSRGB: \
\"astc-12x12-unorm-srgb\"\n};\nvar GPUAddressMode = {\n  ClampToEdge: \
\"clamp-to-edge\",\n  Repeat: \"repeat\",\n  MirrorRepeat: \
\"mirror-repeat\"\n};\nvar GPUFilterMode = {\n  Linear: \"linear\",\n  \
Nearest: \"nearest\"\n};\nvar GPUBlendFactor = {\n  Zero: \"zero\",\n  One: \
\"one\",\n  Src: \"src\",\n  OneMinusSrc: \"one-minus-src\",\n  SrcAlpha: \
\"src-alpha\",\n  OneMinusSrcAlpha: \"one-minus-src-alpha\",\n  Dst: \
\"dst\",\n  OneMinusDstColor: \"one-minus-dst\",\n  DstAlpha: \
\"dst-alpha\",\n  OneMinusDstAlpha: \"one-minus-dst-alpha\",\n  \
SrcAlphaSaturated: \"src-alpha-saturated\",\n  Constant: \"constant\",\n  \
OneMinusConstant: \"one-minus-constant\"\n};\nvar GPUBlendOperation = {\n  \
Add: \"add\",\n  Subtract: \"subtract\",\n  ReverseSubtract: \
\"reverse-subtract\",\n  Min: \"min\",\n  Max: \"max\"\n};\nvar \
GPUColorWriteFlags = {\n  None: 0,\n  Red: 1,\n  Green: 2,\n  Blue: 4,\n  \
Alpha: 8,\n  All: 15\n};\nvar GPUStencilOperation = {\n  Keep: \"keep\",\n  \
Zero: \"zero\",\n  Replace: \"replace\",\n  Invert: \"invert\",\n  \
IncrementClamp: \"increment-clamp\",\n  DecrementClamp: \
\"decrement-clamp\",\n  IncrementWrap: \"increment-wrap\",\n  DecrementWrap: \
\"decrement-wrap\"\n};\nvar GPUBufferBindingType = {\n  Uniform: \
\"uniform\",\n  Storage: \"storage\",\n  ReadOnlyStorage: \
\"read-only-storage\"\n};\nvar GPUStorageTextureAccess = {\n  WriteOnly: \
\"write-only\",\n  ReadOnly: \"read-only\",\n  ReadWrite: \
\"read-write\"\n};\nvar GPUTextureSampleType = {\n  Float: \"float\",\n  \
UnfilterableFloat: \"unfilterable-float\",\n  Depth: \"depth\",\n  SInt: \
\"sint\",\n  UInt: \"uint\"\n};\nvar GPUTextureDimension = {\n  OneD: \
\"1d\",\n  TwoD: \"2d\",\n  ThreeD: \"3d\"\n};\nvar GPUTextureViewDimension = \
{\n  OneD: \"1d\",\n  TwoD: \"2d\",\n  TwoDArray: \"2d-array\",\n  Cube: \
\"cube\",\n  CubeArray: \"cube-array\",\n  ThreeD: \"3d\"\n};\nvar \
GPUTextureAspect = {\n  All: \"all\",\n  StencilOnly: \"stencil-only\",\n  \
DepthOnly: \"depth-only\"\n};\nvar GPUInputStepMode = {\n  Vertex: \
\"vertex\",\n  Instance: \"instance\"\n};\nvar GPUFeatureName = {\n  \
DepthClipControl: \"depth-clip-control\",\n  Depth32FloatStencil8: \
\"depth32float-stencil8\",\n  TextureCompressionBC: \
\"texture-compression-bc\",\n  TextureCompressionETC2: \
\"texture-compression-etc2\",\n  TextureCompressionASTC: \
\"texture-compression-astc\",\n  TimestampQuery: \"timestamp-query\",\n  \
IndirectFirstInstance: \"indirect-first-instance\",\n  ShaderF16: \
\"shader-f16\",\n  RG11B10UFloat: \"rg11b10ufloat-renderable\",\n  \
BGRA8UNormStorage: \"bgra8unorm-storage\",\n  Float32Filterable: \
\"float32-filterable\",\n  ClipDistances: \"clip-distances\",\n  \
DualSourceBlending: \"dual-source-blending\",\n  Subgroups: \
\"subgroups\"\n};\nvar _size = /* @__PURE__ */ new Vector22();\nvar \
PassTextureNode = class extends TextureNode {\n  static get type() {\n    \
return \"PassTextureNode\";\n  }\n  constructor(passNode, texture2) {\n    \
super(texture2);\n    this.passNode = passNode;\n    \
this.setUpdateMatrix(false);\n  }\n  setup(builder) {\n    if \
(builder.object.isQuadMesh) this.passNode.build(builder);\n    return \
super.setup(builder);\n  }\n  clone() {\n    return new \
this.constructor(this.passNode, this.value);\n  }\n};\nvar \
PassMultipleTextureNode = class extends PassTextureNode {\n  static get \
type() {\n    return \"PassMultipleTextureNode\";\n  }\n  \
constructor(passNode, textureName, previousTexture = false) {\n    \
super(passNode, null);\n    this.textureName = textureName;\n    \
this.previousTexture = previousTexture;\n  }\n  updateTexture() {\n    \
this.value = this.previousTexture ? \
this.passNode.getPreviousTexture(this.textureName) : \
this.passNode.getTexture(this.textureName);\n  }\n  setup(builder) {\n    \
this.updateTexture();\n    return super.setup(builder);\n  }\n  clone() {\n   \
 return new this.constructor(this.passNode, this.textureName, \
this.previousTexture);\n  }\n};\nvar PassNode = class _PassNode extends \
TempNode {\n  static get type() {\n    return \"PassNode\";\n  }\n  \
constructor(scope, scene3, camera3, options = {}) {\n    super(\"vec4\");\n   \
 this.scope = scope;\n    this.scene = scene3;\n    this.camera = camera3;\n  \
  this.options = options;\n    this._pixelRatio = 1;\n    this._width = 1;\n  \
  this._height = 1;\n    const depthTexture = new DepthTexture2();\n    \
depthTexture.isRenderTargetTexture = true;\n    depthTexture.name = \
\"depth\";\n    const renderTarget = new RenderTarget2(this._width * \
this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType2, \
...options });\n    renderTarget.texture.name = \"output\";\n    \
renderTarget.depthTexture = depthTexture;\n    this.renderTarget = \
renderTarget;\n    this.updateBeforeType = NodeUpdateType.FRAME;\n    \
this._textures = {\n      output: renderTarget.texture,\n      depth: \
depthTexture\n    };\n    this._textureNodes = {};\n    \
this._linearDepthNodes = {};\n    this._viewZNodes = {};\n    \
this._previousTextures = {};\n    this._previousTextureNodes = {};\n    \
this._cameraNear = uniform(0);\n    this._cameraFar = uniform(0);\n    \
this._mrt = null;\n    this.isPassNode = true;\n  }\n  setMRT(mrt) {\n    \
this._mrt = mrt;\n    return this;\n  }\n  getMRT() {\n    return \
this._mrt;\n  }\n  isGlobal() {\n    return true;\n  }\n  getTexture(name) \
{\n    let texture2 = this._textures[name];\n    if (texture2 === void 0) {\n \
     const refTexture = this.renderTarget.texture;\n      texture2 = \
refTexture.clone();\n      texture2.isRenderTargetTexture = true;\n      \
texture2.name = name;\n      this._textures[name] = texture2;\n      \
this.renderTarget.textures.push(texture2);\n    }\n    return texture2;\n  \
}\n  getPreviousTexture(name) {\n    let texture2 = \
this._previousTextures[name];\n    if (texture2 === void 0) {\n      texture2 \
= this.getTexture(name).clone();\n      texture2.isRenderTargetTexture = \
true;\n      this._previousTextures[name] = texture2;\n    }\n    return \
texture2;\n  }\n  toggleTexture(name) {\n    const prevTexture = \
this._previousTextures[name];\n    if (prevTexture !== void 0) {\n      const \
texture2 = this._textures[name];\n      const index5 = \
this.renderTarget.textures.indexOf(texture2);\n      \
this.renderTarget.textures[index5] = prevTexture;\n      this._textures[name] \
= prevTexture;\n      this._previousTextures[name] = texture2;\n      \
this._textureNodes[name].updateTexture();\n      \
this._previousTextureNodes[name].updateTexture();\n    }\n  }\n  \
getTextureNode(name = \"output\") {\n    let textureNode = \
this._textureNodes[name];\n    if (textureNode === void 0) {\n      \
textureNode = nodeObject(new PassMultipleTextureNode(this, name));\n      \
textureNode.updateTexture();\n      this._textureNodes[name] = textureNode;\n \
   }\n    return textureNode;\n  }\n  getPreviousTextureNode(name = \
\"output\") {\n    let textureNode = this._previousTextureNodes[name];\n    \
if (textureNode === void 0) {\n      if (this._textureNodes[name] === void 0) \
this.getTextureNode(name);\n      textureNode = nodeObject(new \
PassMultipleTextureNode(this, name, true));\n      \
textureNode.updateTexture();\n      this._previousTextureNodes[name] = \
textureNode;\n    }\n    return textureNode;\n  }\n  getViewZNode(name = \
\"depth\") {\n    let viewZNode = this._viewZNodes[name];\n    if (viewZNode \
=== void 0) {\n      const cameraNear2 = this._cameraNear;\n      const \
cameraFar2 = this._cameraFar;\n      this._viewZNodes[name] = viewZNode = \
perspectiveDepthToViewZ(this.getTextureNode(name), cameraNear2, \
cameraFar2);\n    }\n    return viewZNode;\n  }\n  getLinearDepthNode(name = \
\"depth\") {\n    let linearDepthNode = this._linearDepthNodes[name];\n    if \
(linearDepthNode === void 0) {\n      const cameraNear2 = this._cameraNear;\n \
     const cameraFar2 = this._cameraFar;\n      const viewZNode = \
this.getViewZNode(name);\n      this._linearDepthNodes[name] = \
linearDepthNode = viewZToOrthographicDepth(viewZNode, cameraNear2, \
cameraFar2);\n    }\n    return linearDepthNode;\n  }\n  setup({ renderer: \
renderer3 }) {\n    this.renderTarget.samples = this.options.samples === void \
0 ? renderer3.samples : this.options.samples;\n    if \
(renderer3.backend.isWebGLBackend === true) {\n      \
this.renderTarget.samples = 0;\n    }\n    \
this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = \
this.renderTarget.samples > 1;\n    return this.scope === _PassNode.COLOR ? \
this.getTextureNode() : this.getLinearDepthNode();\n  }\n  \
updateBefore(frame2) {\n    const { renderer: renderer3 } = frame2;\n    \
const { scene: scene3, camera: camera3 } = this;\n    this._pixelRatio = \
renderer3.getPixelRatio();\n    const size = renderer3.getSize(_size);\n    \
this.setSize(size.width, size.height);\n    const currentRenderTarget = \
renderer3.getRenderTarget();\n    const currentMRT = renderer3.getMRT();\n    \
this._cameraNear.value = camera3.near;\n    this._cameraFar.value = \
camera3.far;\n    for (const name in this._previousTextures) {\n      \
this.toggleTexture(name);\n    }\n    \
renderer3.setRenderTarget(this.renderTarget);\n    \
renderer3.setMRT(this._mrt);\n    renderer3.render(scene3, camera3);\n    \
renderer3.setRenderTarget(currentRenderTarget);\n    \
renderer3.setMRT(currentMRT);\n  }\n  setSize(width, height) {\n    \
this._width = width;\n    this._height = height;\n    const effectiveWidth = \
this._width * this._pixelRatio;\n    const effectiveHeight = this._height * \
this._pixelRatio;\n    this.renderTarget.setSize(effectiveWidth, \
effectiveHeight);\n  }\n  setPixelRatio(pixelRatio) {\n    this._pixelRatio = \
pixelRatio;\n    this.setSize(this._width, this._height);\n  }\n  dispose() \
{\n    this.renderTarget.dispose();\n  }\n};\nPassNode.COLOR = \
\"color\";\nPassNode.DEPTH = \"depth\";\nvar linearToneMapping = /* @__PURE__ \
*/ Fn(([color2, exposure]) => {\n  return \
color2.mul(exposure).clamp();\n}).setLayout({\n  name: \
\"linearToneMapping\",\n  type: \"vec3\",\n  inputs: [\n    { name: \
\"color\", type: \"vec3\" },\n    { name: \"exposure\", type: \"float\" }\n  \
]\n});\nvar reinhardToneMapping = /* @__PURE__ */ Fn(([color2, exposure]) => \
{\n  color2 = color2.mul(exposure);\n  return \
color2.div(color2.add(1)).clamp();\n}).setLayout({\n  name: \
\"reinhardToneMapping\",\n  type: \"vec3\",\n  inputs: [\n    { name: \
\"color\", type: \"vec3\" },\n    { name: \"exposure\", type: \"float\" }\n  \
]\n});\nvar cineonToneMapping = /* @__PURE__ */ Fn(([color2, exposure]) => \
{\n  color2 = color2.mul(exposure);\n  color2 = color2.sub(4e-3).max(0);\n  \
const a2 = color2.mul(color2.mul(6.2).add(0.5));\n  const b = \
color2.mul(color2.mul(6.2).add(1.7)).add(0.06);\n  return \
a2.div(b).pow(2.2);\n}).setLayout({\n  name: \"cineonToneMapping\",\n  type: \
\"vec3\",\n  inputs: [\n    { name: \"color\", type: \"vec3\" },\n    { name: \
\"exposure\", type: \"float\" }\n  ]\n});\nvar RRTAndODTFit = /* @__PURE__ */ \
Fn(([color2]) => {\n  const a2 = \
color2.mul(color2.add(0.0245786)).sub(90537e-9);\n  const b = \
color2.mul(color2.add(0.432951).mul(0.983729)).add(0.238081);\n  return \
a2.div(b);\n});\nvar acesFilmicToneMapping = /* @__PURE__ */ Fn(([color2, \
exposure]) => {\n  const ACESInputMat = mat3(\n    0.59719,\n    0.35458,\n   \
 0.04823,\n    0.076,\n    0.90834,\n    0.01566,\n    0.0284,\n    \
0.13383,\n    0.83777\n  );\n  const ACESOutputMat = mat3(\n    1.60475,\n    \
-0.53108,\n    -0.07367,\n    -0.10208,\n    1.10813,\n    -605e-5,\n    \
-327e-5,\n    -0.07276,\n    1.07602\n  );\n  color2 = \
color2.mul(exposure).div(0.6);\n  color2 = ACESInputMat.mul(color2);\n  \
color2 = RRTAndODTFit(color2);\n  color2 = ACESOutputMat.mul(color2);\n  \
return color2.clamp();\n}).setLayout({\n  name: \"acesFilmicToneMapping\",\n  \
type: \"vec3\",\n  inputs: [\n    { name: \"color\", type: \"vec3\" },\n    { \
name: \"exposure\", type: \"float\" }\n  ]\n});\nvar \
LINEAR_REC2020_TO_LINEAR_SRGB = /* @__PURE__ */ mat3(vec3(1.6605, -0.1246, \
-0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -83e-4, \
1.1187));\nvar LINEAR_SRGB_TO_LINEAR_REC2020 = /* @__PURE__ */ \
mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.088), vec3(0.0433, \
0.0113, 0.8956));\nvar agxDefaultContrastApprox = /* @__PURE__ */ \
Fn(([x_immutable]) => {\n  const x2 = vec3(x_immutable).toVar();\n  const x22 \
= vec3(x2.mul(x2)).toVar();\n  const x4 = vec3(x22.mul(x22)).toVar();\n  \
return float(15.5).mul(x4.mul(x22)).sub(mul(40.14, \
x4.mul(x2))).add(mul(31.96, x4).sub(mul(6.868, x22.mul(x2))).add(mul(0.4298, \
x22).add(mul(0.1191, x2).sub(232e-5))));\n});\nvar agxToneMapping = /* \
@__PURE__ */ Fn(([color2, exposure]) => {\n  const colortone = \
vec3(color2).toVar();\n  const AgXInsetMatrix = mat3(vec3(0.856627153315983, \
0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, \
0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, \
0.101439036467562, 0.811302368396859));\n  const AgXOutsetMatrix = \
mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), \
vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), \
vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));\n  \
const AgxMinEv = float(-12.47393);\n  const AgxMaxEv = float(4.026069);\n  \
colortone.mulAssign(exposure);\n  \
colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));\n  \
colortone.assign(AgXInsetMatrix.mul(colortone));\n  \
colortone.assign(max$1(colortone, 1e-10));\n  \
colortone.assign(log2(colortone));\n  \
colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));\n  \
colortone.assign(clamp2(colortone, 0, 1));\n  \
colortone.assign(agxDefaultContrastApprox(colortone));\n  \
colortone.assign(AgXOutsetMatrix.mul(colortone));\n  \
colortone.assign(pow(max$1(vec3(0), colortone), vec3(2.2)));\n  \
colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));\n  \
colortone.assign(clamp2(colortone, 0, 1));\n  return \
colortone;\n}).setLayout({\n  name: \"agxToneMapping\",\n  type: \"vec3\",\n  \
inputs: [\n    { name: \"color\", type: \"vec3\" },\n    { name: \
\"exposure\", type: \"float\" }\n  ]\n});\nvar neutralToneMapping = /* \
@__PURE__ */ Fn(([color2, exposure]) => {\n  const StartCompression = \
float(0.8 - 0.04);\n  const Desaturation = float(0.15);\n  color2 = \
color2.mul(exposure);\n  const x2 = min$1(color2.r, min$1(color2.g, \
color2.b));\n  const offset = select(x2.lessThan(0.08), x2.sub(mul(6.25, \
x2.mul(x2))), 0.04);\n  color2.subAssign(offset);\n  const peak = \
max$1(color2.r, max$1(color2.g, color2.b));\n  \
If(peak.lessThan(StartCompression), () => {\n    return color2;\n  });\n  \
const d = sub(1, StartCompression);\n  const newPeak = sub(1, \
d.mul(d).div(peak.add(d.sub(StartCompression))));\n  \
color2.mulAssign(newPeak.div(peak));\n  const g = sub(1, div(1, \
Desaturation.mul(peak.sub(newPeak)).add(1)));\n  return mix(color2, \
vec3(newPeak), g);\n}).setLayout({\n  name: \"neutralToneMapping\",\n  type: \
\"vec3\",\n  inputs: [\n    { name: \"color\", type: \"vec3\" },\n    { name: \
\"exposure\", type: \"float\" }\n  ]\n});\nvar CodeNode = class extends Node \
{\n  static get type() {\n    return \"CodeNode\";\n  }\n  constructor(code = \
\"\", includes = [], language = \"\") {\n    super(\"code\");\n    \
this.isCodeNode = true;\n    this.code = code;\n    this.language = \
language;\n    this.includes = includes;\n  }\n  isGlobal() {\n    return \
true;\n  }\n  setIncludes(includes) {\n    this.includes = includes;\n    \
return this;\n  }\n  getIncludes() {\n    return this.includes;\n  }\n  \
generate(builder) {\n    const includes = this.getIncludes(builder);\n    for \
(const include of includes) {\n      include.build(builder);\n    }\n    \
const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));\n  \
  nodeCode.code = this.code;\n    return nodeCode.code;\n  }\n  \
serialize(data) {\n    super.serialize(data);\n    data.code = this.code;\n   \
 data.language = this.language;\n  }\n  deserialize(data) {\n    \
super.deserialize(data);\n    this.code = data.code;\n    this.language = \
data.language;\n  }\n};\nvar FunctionNode = class extends CodeNode {\n  \
static get type() {\n    return \"FunctionNode\";\n  }\n  constructor(code = \
\"\", includes = [], language = \"\") {\n    super(code, includes, \
language);\n  }\n  getNodeType(builder) {\n    return \
this.getNodeFunction(builder).type;\n  }\n  getInputs(builder) {\n    return \
this.getNodeFunction(builder).inputs;\n  }\n  getNodeFunction(builder) {\n    \
const nodeData = builder.getDataFromNode(this);\n    let nodeFunction = \
nodeData.nodeFunction;\n    if (nodeFunction === void 0) {\n      \
nodeFunction = builder.parser.parseFunction(this.code);\n      \
nodeData.nodeFunction = nodeFunction;\n    }\n    return nodeFunction;\n  }\n \
 generate(builder, output2) {\n    super.generate(builder);\n    const \
nodeFunction = this.getNodeFunction(builder);\n    const name = \
nodeFunction.name;\n    const type = nodeFunction.type;\n    const nodeCode = \
builder.getCodeFromNode(this, type);\n    if (name !== \"\") {\n      \
nodeCode.name = name;\n    }\n    const propertyName = \
builder.getPropertyName(nodeCode);\n    const code = \
this.getNodeFunction(builder).getCode(propertyName);\n    nodeCode.code = \
code + \"\\n\";\n    if (output2 === \"property\") {\n      return \
propertyName;\n    } else {\n      return builder.format(`${propertyName}()`, \
type, output2);\n    }\n  }\n};\nvar Resources = class extends Map {\n  \
get(key, callback = null, ...params) {\n    if (this.has(key)) return \
super.get(key);\n    if (callback !== null) {\n      const value = \
callback(...params);\n      this.set(key, value);\n      return value;\n    \
}\n  }\n};\nvar ScriptableNodeResources = new Resources();\nvar FogNode = \
class extends Node {\n  static get type() {\n    return \"FogNode\";\n  }\n  \
constructor(colorNode, factorNode) {\n    super(\"float\");\n    \
this.isFogNode = true;\n    this.colorNode = colorNode;\n    this.factorNode \
= factorNode;\n  }\n  getViewZNode(builder) {\n    let viewZ;\n    const \
getViewZ = builder.context.getViewZ;\n    if (getViewZ !== void 0) {\n      \
viewZ = getViewZ(this);\n    }\n    return (viewZ || \
positionView.z).negate();\n  }\n  setup() {\n    return this.factorNode;\n  \
}\n};\nvar FogRangeNode = class extends FogNode {\n  static get type() {\n    \
return \"FogRangeNode\";\n  }\n  constructor(colorNode, nearNode, farNode) \
{\n    super(colorNode);\n    this.isFogRangeNode = true;\n    this.nearNode \
= nearNode;\n    this.farNode = farNode;\n  }\n  setup(builder) {\n    const \
viewZ = this.getViewZNode(builder);\n    return smoothstep2(this.nearNode, \
this.farNode, viewZ);\n  }\n};\nvar rangeFog = /* @__PURE__ */ \
nodeProxy(FogRangeNode);\nvar FogExp2Node = class extends FogNode {\n  static \
get type() {\n    return \"FogExp2Node\";\n  }\n  constructor(colorNode, \
densityNode) {\n    super(colorNode);\n    this.isFogExp2Node = true;\n    \
this.densityNode = densityNode;\n  }\n  setup(builder) {\n    const viewZ = \
this.getViewZNode(builder);\n    const density = this.densityNode;\n    \
return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();\n  \
}\n};\nvar densityFog = /* @__PURE__ */ nodeProxy(FogExp2Node);\nvar \
BarrierNode = class extends Node {\n  constructor(scope) {\n    super();\n    \
this.scope = scope;\n  }\n  generate(builder) {\n    const { scope } = \
this;\n    const { renderer: renderer3 } = builder;\n    if \
(renderer3.backend.isWebGLBackend === true) {\n      \
builder.addFlowCode(`\t// ${scope}Barrier \n`);\n    } else {\n      \
builder.addLineFlowCode(`${scope}Barrier()`, this);\n    }\n  }\n};\nvar \
barrier = nodeProxy(BarrierNode);\nvar AtomicFunctionNode = class extends \
TempNode {\n  static get type() {\n    return \"AtomicFunctionNode\";\n  }\n  \
constructor(method, pointerNode, valueNode, storeNode = null) {\n    \
super(\"uint\");\n    this.method = method;\n    this.pointerNode = \
pointerNode;\n    this.valueNode = valueNode;\n    this.storeNode = \
storeNode;\n  }\n  getInputType(builder) {\n    return \
this.pointerNode.getNodeType(builder);\n  }\n  getNodeType(builder) {\n    \
return this.getInputType(builder);\n  }\n  generate(builder) {\n    const \
method = this.method;\n    const type = this.getNodeType(builder);\n    const \
inputType = this.getInputType(builder);\n    const a2 = this.pointerNode;\n   \
 const b = this.valueNode;\n    const params = [];\n    \
params.push(`&${a2.build(builder, inputType)}`);\n    \
params.push(b.build(builder, inputType));\n    const methodSnippet = \
`${builder.getMethod(method, type)}( ${params.join(\", \")} )`;\n    if \
(this.storeNode !== null) {\n      const varSnippet = \
this.storeNode.build(builder, inputType);\n      \
builder.addLineFlowCode(`${varSnippet} = ${methodSnippet}`, this);\n    } \
else {\n      builder.addLineFlowCode(methodSnippet, this);\n    }\n  \
}\n};\nAtomicFunctionNode.ATOMIC_LOAD = \
\"atomicLoad\";\nAtomicFunctionNode.ATOMIC_STORE = \
\"atomicStore\";\nAtomicFunctionNode.ATOMIC_ADD = \
\"atomicAdd\";\nAtomicFunctionNode.ATOMIC_SUB = \
\"atomicSub\";\nAtomicFunctionNode.ATOMIC_MAX = \
\"atomicMax\";\nAtomicFunctionNode.ATOMIC_MIN = \
\"atomicMin\";\nAtomicFunctionNode.ATOMIC_AND = \
\"atomicAnd\";\nAtomicFunctionNode.ATOMIC_OR = \
\"atomicOr\";\nAtomicFunctionNode.ATOMIC_XOR = \"atomicXor\";\nvar atomicNode \
= nodeProxy(AtomicFunctionNode);\nvar uniformsLib;\nfunction \
getLightData(light) {\n  uniformsLib = uniformsLib || /* @__PURE__ */ new \
WeakMap();\n  let uniforms = uniformsLib.get(light);\n  if (uniforms === void \
0) uniformsLib.set(light, uniforms = {});\n  return uniforms;\n}\nfunction \
lightPosition(light) {\n  const data = getLightData(light);\n  return \
data.position || (data.position = uniform(new \
Vector32()).setGroup(renderGroup).onRenderUpdate((_, self2) => \
self2.value.setFromMatrixPosition(light.matrixWorld)));\n}\nfunction \
lightTargetPosition(light) {\n  const data = getLightData(light);\n  return \
data.targetPosition || (data.targetPosition = uniform(new \
Vector32()).setGroup(renderGroup).onRenderUpdate((_, self2) => \
self2.value.setFromMatrixPosition(light.target.matrixWorld)));\n}\nfunction \
lightViewPosition(light) {\n  const data = getLightData(light);\n  return \
data.viewPosition || (data.viewPosition = uniform(new \
Vector32()).setGroup(renderGroup).onRenderUpdate(({ camera: camera3 }, self2) \
=> {\n    self2.value = self2.value || new Vector32();\n    \
self2.value.setFromMatrixPosition(light.matrixWorld);\n    \
self2.value.applyMatrix4(camera3.matrixWorldInverse);\n  }));\n}\nvar \
lightTargetDirection = (light) => \
cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosit\
ion(light)));\nvar sortLights = (lights) => {\n  return lights.sort((a2, b) \
=> a2.id - b.id);\n};\nvar getLightNodeById = (id2, lightNodes) => {\n  for \
(const lightNode of lightNodes) {\n    if (lightNode.isAnalyticLightNode && \
lightNode.light.id === id2) {\n      return lightNode;\n    }\n  }\n  return \
null;\n};\nvar _lightsNodeRef = /* @__PURE__ */ new WeakMap();\nvar \
LightsNode = class extends Node {\n  static get type() {\n    return \
\"LightsNode\";\n  }\n  constructor() {\n    super(\"vec3\");\n    \
this.totalDiffuseNode = vec3().toVar(\"totalDiffuse\");\n    \
this.totalSpecularNode = vec3().toVar(\"totalSpecular\");\n    \
this.outgoingLightNode = vec3().toVar(\"outgoingLight\");\n    this._lights = \
[];\n    this._lightNodes = null;\n    this._lightNodesHash = null;\n    \
this.global = true;\n  }\n  getHash(builder) {\n    if (this._lightNodesHash \
=== null) {\n      if (this._lightNodes === null) \
this.setupLightsNode(builder);\n      const hash = [];\n      for (const \
lightNode of this._lightNodes) {\n        \
hash.push(lightNode.getSelf().getHash());\n      }\n      \
this._lightNodesHash = \"lights-\" + hash.join(\",\");\n    }\n    return \
this._lightNodesHash;\n  }\n  analyze(builder) {\n    const properties = \
builder.getDataFromNode(this);\n    for (const node of properties.nodes) {\n  \
    node.build(builder);\n    }\n  }\n  setupLightsNode(builder) {\n    const \
lightNodes = [];\n    const previousLightNodes = this._lightNodes;\n    const \
lights = sortLights(this._lights);\n    const nodeLibrary = \
builder.renderer.library;\n    for (const light of lights) {\n      if \
(light.isNode) {\n        lightNodes.push(nodeObject(light));\n      } else \
{\n        let lightNode = null;\n        if (previousLightNodes !== null) \
{\n          lightNode = getLightNodeById(light.id, previousLightNodes);\n    \
    }\n        if (lightNode === null) {\n          const lightNodeClass = \
nodeLibrary.getLightNodeClass(light.constructor);\n          if \
(lightNodeClass === null) {\n            \
console.warn(`LightsNode.setupNodeLights: Light node not found for \
${light.constructor.name}`);\n            continue;\n          }\n          \
let lightNode2 = null;\n          if (!_lightsNodeRef.has(light)) {\n         \
   lightNode2 = nodeObject(new lightNodeClass(light));\n            \
_lightsNodeRef.set(light, lightNode2);\n          } else {\n            \
lightNode2 = _lightsNodeRef.get(light);\n          }\n          \
lightNodes.push(lightNode2);\n        }\n      }\n    }\n    this._lightNodes \
= lightNodes;\n  }\n  setupLights(builder, lightNodes) {\n    for (const \
lightNode of lightNodes) {\n      lightNode.build(builder);\n    }\n  }\n  \
setup(builder) {\n    if (this._lightNodes === null) \
this.setupLightsNode(builder);\n    const context2 = builder.context;\n    \
const lightingModel = context2.lightingModel;\n    let outgoingLightNode = \
this.outgoingLightNode;\n    if (lightingModel) {\n      const { _lightNodes, \
totalDiffuseNode, totalSpecularNode } = this;\n      context2.outgoingLight = \
outgoingLightNode;\n      const stack2 = builder.addStack();\n      const \
properties = builder.getDataFromNode(this);\n      properties.nodes = \
stack2.nodes;\n      lightingModel.start(context2, stack2, builder);\n      \
this.setupLights(builder, _lightNodes);\n      \
lightingModel.indirect(context2, stack2, builder);\n      const { backdrop, \
backdropAlpha } = context2;\n      const { directDiffuse, directSpecular, \
indirectDiffuse, indirectSpecular } = context2.reflectedLight;\n      let \
totalDiffuse = directDiffuse.add(indirectDiffuse);\n      if (backdrop !== \
null) {\n        if (backdropAlpha !== null) {\n          totalDiffuse = \
vec3(backdropAlpha.mix(totalDiffuse, backdrop));\n        } else {\n          \
totalDiffuse = vec3(backdrop);\n        }\n        \
context2.material.transparent = true;\n      }\n      \
totalDiffuseNode.assign(totalDiffuse);\n      \
totalSpecularNode.assign(directSpecular.add(indirectSpecular));\n      \
outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));\n      \
lightingModel.finish(context2, stack2, builder);\n      outgoingLightNode = \
outgoingLightNode.bypass(builder.removeStack());\n    }\n    return \
outgoingLightNode;\n  }\n  setLights(lights) {\n    this._lights = lights;\n  \
  this._lightNodes = null;\n    this._lightNodesHash = null;\n    return \
this;\n  }\n  getLights() {\n    return this._lights;\n  }\n  get hasLights() \
{\n    return this._lights.length > 0;\n  }\n};\nvar BasicShadowMap = Fn(({ \
depthTexture, shadowCoord }) => {\n  return texture(depthTexture, \
shadowCoord.xy).compare(shadowCoord.z);\n});\nvar PCFShadowMap2 = Fn(({ \
depthTexture, shadowCoord, shadow: shadow2 }) => {\n  const depthCompare = \
(uv2, compare) => texture(depthTexture, uv2).compare(compare);\n  const \
mapSize = reference(\"mapSize\", \"vec2\", shadow2).setGroup(renderGroup);\n  \
const radius = reference(\"radius\", \"float\", \
shadow2).setGroup(renderGroup);\n  const texelSize = vec2(1).div(mapSize);\n  \
const dx0 = texelSize.x.negate().mul(radius);\n  const dy0 = \
texelSize.y.negate().mul(radius);\n  const dx1 = texelSize.x.mul(radius);\n  \
const dy1 = texelSize.y.mul(radius);\n  const dx2 = dx0.div(2);\n  const dy2 \
= dy0.div(2);\n  const dx3 = dx1.div(2);\n  const dy3 = dy1.div(2);\n  return \
add4(\n    depthCompare(shadowCoord.xy.add(vec2(dx0, dy0)), shadowCoord.z),\n \
   depthCompare(shadowCoord.xy.add(vec2(0, dy0)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx1, dy0)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx2, dy2)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(0, dy2)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx3, dy2)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx0, 0)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx2, 0)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy, shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx3, 0)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx1, 0)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx2, dy3)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(0, dy3)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx3, dy3)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx0, dy1)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(0, dy1)), shadowCoord.z),\n    \
depthCompare(shadowCoord.xy.add(vec2(dx1, dy1)), shadowCoord.z)\n  ).mul(1 / \
17);\n});\nvar PCFSoftShadowMap2 = Fn(({ depthTexture, shadowCoord, shadow: \
shadow2 }) => {\n  const depthCompare = (uv3, compare) => \
texture(depthTexture, uv3).compare(compare);\n  const mapSize = \
reference(\"mapSize\", \"vec2\", shadow2).setGroup(renderGroup);\n  const \
texelSize = vec2(1).div(mapSize);\n  const dx = texelSize.x;\n  const dy = \
texelSize.y;\n  const uv2 = shadowCoord.xy;\n  const f = \
fract(uv2.mul(mapSize).add(0.5));\n  uv2.subAssign(f.mul(texelSize));\n  \
return add4(\n    depthCompare(uv2, shadowCoord.z),\n    \
depthCompare(uv2.add(vec2(dx, 0)), shadowCoord.z),\n    \
depthCompare(uv2.add(vec2(0, dy)), shadowCoord.z),\n    \
depthCompare(uv2.add(texelSize), shadowCoord.z),\n    mix(\n      \
depthCompare(uv2.add(vec2(dx.negate(), 0)), shadowCoord.z),\n      \
depthCompare(uv2.add(vec2(dx.mul(2), 0)), shadowCoord.z),\n      f.x\n    \
),\n    mix(\n      depthCompare(uv2.add(vec2(dx.negate(), dy)), \
shadowCoord.z),\n      depthCompare(uv2.add(vec2(dx.mul(2), dy)), \
shadowCoord.z),\n      f.x\n    ),\n    mix(\n      \
depthCompare(uv2.add(vec2(0, dy.negate())), shadowCoord.z),\n      \
depthCompare(uv2.add(vec2(0, dy.mul(2))), shadowCoord.z),\n      f.y\n    \
),\n    mix(\n      depthCompare(uv2.add(vec2(dx, dy.negate())), \
shadowCoord.z),\n      depthCompare(uv2.add(vec2(dx, dy.mul(2))), \
shadowCoord.z),\n      f.y\n    ),\n    mix(\n      mix(\n        \
depthCompare(uv2.add(vec2(dx.negate(), dy.negate())), shadowCoord.z),\n       \
 depthCompare(uv2.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z),\n        \
f.x\n      ),\n      mix(\n        depthCompare(uv2.add(vec2(dx.negate(), \
dy.mul(2))), shadowCoord.z),\n        depthCompare(uv2.add(vec2(dx.mul(2), \
dy.mul(2))), shadowCoord.z),\n        f.x\n      ),\n      f.y\n    )\n  \
).mul(1 / 9);\n});\nvar VSMShadowMapNode = Fn(({ depthTexture, shadowCoord }) \
=> {\n  const occlusion = float(1).toVar();\n  const distribution = \
texture(depthTexture).uv(shadowCoord.xy).rg;\n  const hardShadow = \
step(shadowCoord.z, distribution.x);\n  If(hardShadow.notEqual(float(1)), () \
=> {\n    const distance2 = shadowCoord.z.sub(distribution.x);\n    const \
variance = max$1(0, distribution.y.mul(distribution.y));\n    let \
softnessProbability = variance.div(variance.add(distance2.mul(distance2)));\n \
   softnessProbability = clamp2(sub(softnessProbability, 0.3).div(0.95 - \
0.3));\n    occlusion.assign(clamp2(max$1(hardShadow, \
softnessProbability)));\n  });\n  return occlusion;\n});\nvar VSMPassVertical \
= Fn(({ samples, radius, size, shadowPass }) => {\n  const mean = \
float(0).toVar();\n  const squaredMean = float(0).toVar();\n  const uvStride \
= samples.lessThanEqual(float(1)).select(float(0), \
float(2).div(samples.sub(1)));\n  const uvStart = \
samples.lessThanEqual(float(1)).select(float(0), float(-1));\n  Loop({ start: \
int(0), end: int(samples), type: \"int\", condition: \"<\" }, ({ i }) => {\n  \
  const uvOffset = uvStart.add(float(i).mul(uvStride));\n    const depth2 = \
shadowPass.uv(add4(screenCoordinate.xy, vec2(0, \
uvOffset).mul(radius)).div(size)).x;\n    mean.addAssign(depth2);\n    \
squaredMean.addAssign(depth2.mul(depth2));\n  });\n  \
mean.divAssign(samples);\n  squaredMean.divAssign(samples);\n  const std_dev \
= sqrt(squaredMean.sub(mean.mul(mean)));\n  return vec2(mean, \
std_dev);\n});\nvar VSMPassHorizontal = Fn(({ samples, radius, size, \
shadowPass }) => {\n  const mean = float(0).toVar();\n  const squaredMean = \
float(0).toVar();\n  const uvStride = \
samples.lessThanEqual(float(1)).select(float(0), \
float(2).div(samples.sub(1)));\n  const uvStart = \
samples.lessThanEqual(float(1)).select(float(0), float(-1));\n  Loop({ start: \
int(0), end: int(samples), type: \"int\", condition: \"<\" }, ({ i }) => {\n  \
  const uvOffset = uvStart.add(float(i).mul(uvStride));\n    const \
distribution = shadowPass.uv(add4(screenCoordinate.xy, vec2(uvOffset, \
0).mul(radius)).div(size));\n    mean.addAssign(distribution.x);\n    \
squaredMean.addAssign(add4(distribution.y.mul(distribution.y), \
distribution.x.mul(distribution.x)));\n  });\n  mean.divAssign(samples);\n  \
squaredMean.divAssign(samples);\n  const std_dev = \
sqrt(squaredMean.sub(mean.mul(mean)));\n  return vec2(mean, \
std_dev);\n});\nvar _shadowFilterLib = [BasicShadowMap, PCFShadowMap2, \
PCFSoftShadowMap2, VSMShadowMapNode];\nvar _overrideMaterial = null;\nvar \
_quadMesh$1 = /* @__PURE__ */ new QuadMesh();\nvar ShadowNode = class extends \
Node {\n  static get type() {\n    return \"ShadowNode\";\n  }\n  \
constructor(light, shadow2 = null) {\n    super();\n    this.light = light;\n \
   this.shadow = shadow2 || light.shadow;\n    this.shadowMap = null;\n    \
this.vsmShadowMapVertical = null;\n    this.vsmShadowMapHorizontal = null;\n  \
  this.vsmMaterialVertical = null;\n    this.vsmMaterialHorizontal = null;\n  \
  this.updateBeforeType = NodeUpdateType.RENDER;\n    this._node = null;\n    \
this.isShadowNode = true;\n  }\n  setupShadow(builder) {\n    const { object, \
renderer: renderer3 } = builder;\n    if (_overrideMaterial === null) {\n     \
 _overrideMaterial = new NodeMaterial();\n      \
_overrideMaterial.fragmentNode = vec4(0, 0, 0, 1);\n      \
_overrideMaterial.isShadowNodeMaterial = true;\n      _overrideMaterial.name \
= \"ShadowMaterial\";\n    }\n    const shadow2 = this.shadow;\n    const \
shadowMapType = renderer3.shadowMap.type;\n    const depthTexture = new \
DepthTexture2(shadow2.mapSize.width, shadow2.mapSize.height);\n    \
depthTexture.compareFunction = LessCompare2;\n    const shadowMap = \
builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height);\n  \
  shadowMap.depthTexture = depthTexture;\n    \
shadow2.camera.updateProjectionMatrix();\n    if (shadowMapType === \
VSMShadowMap2) {\n      depthTexture.compareFunction = null;\n      \
this.vsmShadowMapVertical = builder.createRenderTarget(shadow2.mapSize.width, \
shadow2.mapSize.height, { format: RGFormat2, type: HalfFloatType2 });\n      \
this.vsmShadowMapHorizontal = \
builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height, { \
format: RGFormat2, type: HalfFloatType2 });\n      const shadowPassVertical = \
texture(depthTexture);\n      const shadowPassHorizontal = \
texture(this.vsmShadowMapVertical.texture);\n      const samples = \
reference(\"blurSamples\", \"float\", shadow2).setGroup(renderGroup);\n      \
const radius = reference(\"radius\", \"float\", \
shadow2).setGroup(renderGroup);\n      const size = reference(\"mapSize\", \
\"vec2\", shadow2).setGroup(renderGroup);\n      let material = \
this.vsmMaterialVertical || (this.vsmMaterialVertical = new \
NodeMaterial());\n      material.fragmentNode = VSMPassVertical({ samples, \
radius, size, shadowPass: shadowPassVertical \
}).context(builder.getSharedContext());\n      material.name = \
\"VSMVertical\";\n      material = this.vsmMaterialHorizontal || \
(this.vsmMaterialHorizontal = new NodeMaterial());\n      \
material.fragmentNode = VSMPassHorizontal({ samples, radius, size, \
shadowPass: shadowPassHorizontal }).context(builder.getSharedContext());\n    \
  material.name = \"VSMHorizontal\";\n    }\n    const shadowIntensity = \
reference(\"intensity\", \"float\", shadow2).setGroup(renderGroup);\n    \
const bias = reference(\"bias\", \"float\", shadow2).setGroup(renderGroup);\n \
   const normalBias = reference(\"normalBias\", \"float\", \
shadow2).setGroup(renderGroup);\n    const position = \
object.material.shadowPositionNode || positionWorld;\n    let shadowCoord = \
uniform(shadow2.matrix).setGroup(renderGroup).mul(position.add(transformedNor\
malWorld.mul(normalBias)));\n    let coordZ;\n    if \
(shadow2.camera.isOrthographicCamera || renderer3.logarithmicDepthBuffer !== \
true) {\n      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n      \
coordZ = shadowCoord.z;\n      if (renderer3.coordinateSystem === \
WebGPUCoordinateSystem2) {\n        coordZ = coordZ.mul(2).sub(1);\n      }\n \
   } else {\n      const w = shadowCoord.w;\n      shadowCoord = \
shadowCoord.xy.div(w);\n      const cameraNearLocal = \
uniform(\"float\").onRenderUpdate(() => shadow2.camera.near);\n      const \
cameraFarLocal = uniform(\"float\").onRenderUpdate(() => \
shadow2.camera.far);\n      coordZ = perspectiveDepthToLogarithmicDepth(w, \
cameraNearLocal, cameraFarLocal);\n    }\n    shadowCoord = vec3(\n      \
shadowCoord.x,\n      shadowCoord.y.oneMinus(),\n      // follow webgpu \
standards\n      coordZ.add(bias)\n    );\n    const frustumTest = \
shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(sha\
dowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shado\
wCoord.z.lessThanEqual(1));\n    const filterFn = shadow2.filterNode || \
_shadowFilterLib[renderer3.shadowMap.type] || null;\n    if (filterFn === \
null) {\n      throw new Error(\"THREE.WebGPURenderer: Shadow map type not \
supported yet.\");\n    }\n    const shadowColor = texture(shadowMap.texture, \
shadowCoord);\n    const shadowNode = frustumTest.select(filterFn({ \
depthTexture: shadowMapType === VSMShadowMap2 ? \
this.vsmShadowMapHorizontal.texture : depthTexture, shadowCoord, shadow: \
shadow2 }), float(1));\n    this.shadowMap = shadowMap;\n    this.shadow.map \
= shadowMap;\n    return mix(1, shadowNode.rgb.mix(shadowColor, 1), \
shadowIntensity.mul(shadowColor.a));\n  }\n  setup(builder) {\n    if \
(builder.renderer.shadowMap.enabled === false) return;\n    return this._node \
!== null ? this._node : this._node = this.setupShadow(builder);\n  }\n  \
updateShadow(frame2) {\n    const { shadowMap, light, shadow: shadow2 } = \
this;\n    const { renderer: renderer3, scene: scene3, camera: camera3 } = \
frame2;\n    const shadowType = renderer3.shadowMap.type;\n    const \
depthVersion = shadowMap.depthTexture.version;\n    this._depthVersionCached \
= depthVersion;\n    const currentOverrideMaterial = \
scene3.overrideMaterial;\n    scene3.overrideMaterial = _overrideMaterial;\n  \
  shadowMap.setSize(shadow2.mapSize.width, shadow2.mapSize.height);\n    \
shadow2.updateMatrices(light);\n    shadow2.camera.layers.mask = \
camera3.layers.mask;\n    const currentRenderTarget = \
renderer3.getRenderTarget();\n    const currentRenderObjectFunction = \
renderer3.getRenderObjectFunction();\n    \
renderer3.setRenderObjectFunction((object, ...params) => {\n      if \
(object.castShadow === true || object.receiveShadow && shadowType === \
VSMShadowMap2) {\n        renderer3.renderObject(object, ...params);\n      \
}\n    });\n    renderer3.setRenderTarget(shadowMap);\n    \
renderer3.render(scene3, shadow2.camera);\n    \
renderer3.setRenderObjectFunction(currentRenderObjectFunction);\n    if \
(light.isPointLight !== true && shadowType === VSMShadowMap2) {\n      \
this.vsmPass(renderer3);\n    }\n    \
renderer3.setRenderTarget(currentRenderTarget);\n    scene3.overrideMaterial \
= currentOverrideMaterial;\n  }\n  vsmPass(renderer3) {\n    const { shadow: \
shadow2 } = this;\n    \
this.vsmShadowMapVertical.setSize(shadow2.mapSize.width, \
shadow2.mapSize.height);\n    \
this.vsmShadowMapHorizontal.setSize(shadow2.mapSize.width, \
shadow2.mapSize.height);\n    \
renderer3.setRenderTarget(this.vsmShadowMapVertical);\n    \
_quadMesh$1.material = this.vsmMaterialVertical;\n    \
_quadMesh$1.render(renderer3);\n    \
renderer3.setRenderTarget(this.vsmShadowMapHorizontal);\n    \
_quadMesh$1.material = this.vsmMaterialHorizontal;\n    \
_quadMesh$1.render(renderer3);\n  }\n  dispose() {\n    \
this.shadowMap.dispose();\n    this.shadowMap = null;\n    if \
(this.vsmShadowMapVertical !== null) {\n      \
this.vsmShadowMapVertical.dispose();\n      this.vsmShadowMapVertical = \
null;\n      this.vsmMaterialVertical.dispose();\n      \
this.vsmMaterialVertical = null;\n    }\n    if (this.vsmShadowMapHorizontal \
!== null) {\n      this.vsmShadowMapHorizontal.dispose();\n      \
this.vsmShadowMapHorizontal = null;\n      \
this.vsmMaterialHorizontal.dispose();\n      this.vsmMaterialHorizontal = \
null;\n    }\n    this.updateBeforeType = NodeUpdateType.NONE;\n  }\n  \
updateBefore(frame2) {\n    const { shadow: shadow2 } = this;\n    const \
needsUpdate = shadow2.needsUpdate || shadow2.autoUpdate;\n    if \
(needsUpdate) {\n      this.updateShadow(frame2);\n      if \
(this.shadowMap.depthTexture.version === this._depthVersionCached) {\n        \
shadow2.needsUpdate = false;\n      }\n    }\n  }\n};\nvar shadow = (light, \
shadow2) => nodeObject(new ShadowNode(light, shadow2));\nvar \
AnalyticLightNode = class extends LightingNode {\n  static get type() {\n    \
return \"AnalyticLightNode\";\n  }\n  constructor(light = null) {\n    \
super();\n    this.updateType = NodeUpdateType.FRAME;\n    this.light = \
light;\n    this.color = new Color2();\n    this.colorNode = \
uniform(this.color).setGroup(renderGroup);\n    this.baseColorNode = null;\n  \
  this.shadowNode = null;\n    this.shadowColorNode = null;\n    \
this.isAnalyticLightNode = true;\n  }\n  getCacheKey() {\n    return \
hash$1(super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0);\n  \
}\n  getHash() {\n    return this.light.uuid;\n  }\n  setupShadow(builder) \
{\n    const { renderer: renderer3 } = builder;\n    if \
(renderer3.shadowMap.enabled === false) return;\n    let shadowColorNode = \
this.shadowColorNode;\n    if (shadowColorNode === null) {\n      const \
customShadowNode = this.light.shadow.shadowNode;\n      let shadowNode;\n     \
 if (customShadowNode !== void 0) {\n        shadowNode = \
nodeObject(customShadowNode);\n      } else {\n        shadowNode = \
shadow(this.light);\n      }\n      this.shadowNode = shadowNode;\n      \
this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);\n    \
  this.baseColorNode = this.colorNode;\n    }\n    this.colorNode = \
shadowColorNode;\n  }\n  setup(builder) {\n    this.colorNode = \
this.baseColorNode || this.colorNode;\n    if (this.light.castShadow) {\n     \
 if (builder.object.receiveShadow) {\n        this.setupShadow(builder);\n    \
  }\n    } else if (this.shadowNode !== null) {\n      \
this.shadowNode.dispose();\n    }\n  }\n  update() {\n    const { light } = \
this;\n    this.color.copy(light.color).multiplyScalar(light.intensity);\n  \
}\n};\nvar getDistanceAttenuation = /* @__PURE__ */ Fn((inputs) => {\n  const \
{ lightDistance, cutoffDistance, decayExponent } = inputs;\n  const \
distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();\n  \
return cutoffDistance.greaterThan(0).select(\n    \
distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp\
().pow2()),\n    distanceFalloff\n  );\n});\nvar directPointLight = Fn(({ \
color: color2, lightViewPosition: lightViewPosition2, cutoffDistance, \
decayExponent }, builder) => {\n  const lightingModel = \
builder.context.lightingModel;\n  const lVector = \
lightViewPosition2.sub(positionView);\n  const lightDirection = \
lVector.normalize();\n  const lightDistance = lVector.length();\n  const \
lightAttenuation = getDistanceAttenuation({\n    lightDistance,\n    \
cutoffDistance,\n    decayExponent\n  });\n  const lightColor = \
color2.mul(lightAttenuation);\n  const reflectedLight = \
builder.context.reflectedLight;\n  lightingModel.direct({\n    \
lightDirection,\n    lightColor,\n    reflectedLight\n  }, builder.stack, \
builder);\n});\nvar PointLightNode = class extends AnalyticLightNode {\n  \
static get type() {\n    return \"PointLightNode\";\n  }\n  constructor(light \
= null) {\n    super(light);\n    this.cutoffDistanceNode = \
uniform(0).setGroup(renderGroup);\n    this.decayExponentNode = \
uniform(0).setGroup(renderGroup);\n  }\n  update(frame2) {\n    const { light \
} = this;\n    super.update(frame2);\n    this.cutoffDistanceNode.value = \
light.distance;\n    this.decayExponentNode.value = light.decay;\n  }\n  \
setup() {\n    directPointLight({\n      color: this.colorNode,\n      \
lightViewPosition: lightViewPosition(this.light),\n      cutoffDistance: \
this.cutoffDistanceNode,\n      decayExponent: this.decayExponentNode\n    \
}).append();\n  }\n};\nvar getShIrradianceAt = /* @__PURE__ */ Fn(([normal2, \
shCoefficients]) => {\n  const x2 = normal2.x, y2 = normal2.y, z2 = \
normal2.z;\n  let result = shCoefficients.element(0).mul(0.886227);\n  result \
= result.add(shCoefficients.element(1).mul(2 * 0.511664).mul(y2));\n  result \
= result.add(shCoefficients.element(2).mul(2 * 0.511664).mul(z2));\n  result \
= result.add(shCoefficients.element(3).mul(2 * 0.511664).mul(x2));\n  result \
= result.add(shCoefficients.element(4).mul(2 * 0.429043).mul(x2).mul(y2));\n  \
result = result.add(shCoefficients.element(5).mul(2 * \
0.429043).mul(y2).mul(z2));\n  result = \
result.add(shCoefficients.element(6).mul(z2.mul(z2).mul(0.743125).sub(0.24770\
8)));\n  result = result.add(shCoefficients.element(7).mul(2 * \
0.429043).mul(x2).mul(z2));\n  result = \
result.add(shCoefficients.element(8).mul(0.429043).mul(mul(x2, \
x2).sub(mul(y2, y2))));\n  return result;\n});\nvar _clearColor$1 = /* \
@__PURE__ */ new Color4();\nvar Background = class extends DataMap {\n  \
constructor(renderer3, nodes) {\n    super();\n    this.renderer = \
renderer3;\n    this.nodes = nodes;\n  }\n  update(scene3, renderList, \
renderContext) {\n    const renderer3 = this.renderer;\n    const background \
= this.nodes.getBackgroundNode(scene3) || scene3.background;\n    let \
forceClear = false;\n    if (background === null) {\n      \
renderer3._clearColor.getRGB(_clearColor$1, LinearSRGBColorSpace2);\n      \
_clearColor$1.a = renderer3._clearColor.a;\n    } else if (background.isColor \
=== true) {\n      background.getRGB(_clearColor$1, LinearSRGBColorSpace2);\n \
     _clearColor$1.a = 1;\n      forceClear = true;\n    } else if \
(background.isNode === true) {\n      const sceneData = this.get(scene3);\n   \
   const backgroundNode = background;\n      \
_clearColor$1.copy(renderer3._clearColor);\n      let backgroundMesh = \
sceneData.backgroundMesh;\n      if (backgroundMesh === void 0) {\n        \
const backgroundMeshNode = \
context(vec4(backgroundNode).mul(backgroundIntensity), {\n          // @TODO: \
Add Texture2D support using node context\n          getUV: () => \
backgroundRotation.mul(normalWorld),\n          getTextureLevel: () => \
backgroundBlurriness\n        });\n        let viewProj = \
modelViewProjection();\n        viewProj = viewProj.setZ(viewProj.w);\n       \
 const nodeMaterial = new NodeMaterial();\n        nodeMaterial.name = \
\"Background.material\";\n        nodeMaterial.side = BackSide2;\n        \
nodeMaterial.depthTest = false;\n        nodeMaterial.depthWrite = false;\n   \
     nodeMaterial.fog = false;\n        nodeMaterial.lights = false;\n        \
nodeMaterial.vertexNode = viewProj;\n        nodeMaterial.colorNode = \
backgroundMeshNode;\n        sceneData.backgroundMeshNode = \
backgroundMeshNode;\n        sceneData.backgroundMesh = backgroundMesh = new \
Mesh2(new SphereGeometry2(1, 32, 32), nodeMaterial);\n        \
backgroundMesh.frustumCulled = false;\n        backgroundMesh.name = \
\"Background.mesh\";\n        backgroundMesh.onBeforeRender = \
function(renderer4, scene4, camera3) {\n          \
this.matrixWorld.copyPosition(camera3.matrixWorld);\n        };\n      }\n    \
  const backgroundCacheKey = backgroundNode.getCacheKey();\n      if \
(sceneData.backgroundCacheKey !== backgroundCacheKey) {\n        \
sceneData.backgroundMeshNode.node = \
vec4(backgroundNode).mul(backgroundIntensity);\n        \
sceneData.backgroundMeshNode.needsUpdate = true;\n        \
backgroundMesh.material.needsUpdate = true;\n        \
sceneData.backgroundCacheKey = backgroundCacheKey;\n      }\n      \
renderList.unshift(backgroundMesh, backgroundMesh.geometry, \
backgroundMesh.material, 0, 0, null);\n    } else {\n      \
console.error(\"THREE.Renderer: Unsupported background configuration.\", \
background);\n    }\n    if (renderer3.autoClear === true || forceClear === \
true) {\n      const clearColorValue = renderContext.clearColorValue;\n      \
clearColorValue.r = _clearColor$1.r;\n      clearColorValue.g = \
_clearColor$1.g;\n      clearColorValue.b = _clearColor$1.b;\n      \
clearColorValue.a = _clearColor$1.a;\n      if \
(renderer3.backend.isWebGLBackend === true || renderer3.alpha === true) {\n   \
     clearColorValue.r *= clearColorValue.a;\n        clearColorValue.g *= \
clearColorValue.a;\n        clearColorValue.b *= clearColorValue.a;\n      \
}\n      renderContext.depthClearValue = renderer3._clearDepth;\n      \
renderContext.stencilClearValue = renderer3._clearStencil;\n      \
renderContext.clearColor = renderer3.autoClearColor === true;\n      \
renderContext.clearDepth = renderer3.autoClearDepth === true;\n      \
renderContext.clearStencil = renderer3.autoClearStencil === true;\n    } else \
{\n      renderContext.clearColor = false;\n      renderContext.clearDepth = \
false;\n      renderContext.clearStencil = false;\n    }\n  }\n};\nvar _id$5 \
= 0;\nvar BindGroup = class {\n  constructor(name = \"\", bindings = [], \
index5 = 0, bindingsReference = []) {\n    this.name = name;\n    \
this.bindings = bindings;\n    this.index = index5;\n    \
this.bindingsReference = bindingsReference;\n    this.id = _id$5++;\n  \
}\n};\nvar NodeBuilderState = class {\n  constructor(vertexShader, \
fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, \
updateBeforeNodes, updateAfterNodes, monitor, transforms = []) {\n    \
this.vertexShader = vertexShader;\n    this.fragmentShader = \
fragmentShader;\n    this.computeShader = computeShader;\n    this.transforms \
= transforms;\n    this.nodeAttributes = nodeAttributes;\n    this.bindings = \
bindings;\n    this.updateNodes = updateNodes;\n    this.updateBeforeNodes = \
updateBeforeNodes;\n    this.updateAfterNodes = updateAfterNodes;\n    \
this.monitor = monitor;\n    this.usedTimes = 0;\n  }\n  createBindings() {\n \
   const bindings = [];\n    for (const instanceGroup of this.bindings) {\n   \
   const shared = instanceGroup.bindings[0].groupNode.shared;\n      if \
(shared !== true) {\n        const bindingsGroup = new \
BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup);\n      \
  bindings.push(bindingsGroup);\n        for (const instanceBinding of \
instanceGroup.bindings) {\n          \
bindingsGroup.bindings.push(instanceBinding.clone());\n        }\n      } \
else {\n        bindings.push(instanceGroup);\n      }\n    }\n    return \
bindings;\n  }\n};\nvar NodeAttribute = class {\n  constructor(name, type, \
node = null) {\n    this.isNodeAttribute = true;\n    this.name = name;\n    \
this.type = type;\n    this.node = node;\n  }\n};\nvar NodeUniform = class \
{\n  constructor(name, type, node) {\n    this.isNodeUniform = true;\n    \
this.name = name;\n    this.type = type;\n    this.node = node.getSelf();\n  \
}\n  get value() {\n    return this.node.value;\n  }\n  set value(val) {\n    \
this.node.value = val;\n  }\n  get id() {\n    return this.node.id;\n  }\n  \
get groupNode() {\n    return this.node.groupNode;\n  }\n};\nvar NodeVar = \
class {\n  constructor(name, type) {\n    this.isNodeVar = true;\n    \
this.name = name;\n    this.type = type;\n  }\n};\nvar NodeVarying = class \
extends NodeVar {\n  constructor(name, type) {\n    super(name, type);\n    \
this.needsInterpolation = false;\n    this.isNodeVarying = true;\n  \
}\n};\nvar NodeCode = class {\n  constructor(name, type, code = \"\") {\n    \
this.name = name;\n    this.type = type;\n    this.code = code;\n    \
Object.defineProperty(this, \"isNodeCode\", { value: true });\n  }\n};\nvar \
id = 0;\nvar NodeCache = class {\n  constructor(parent = null) {\n    this.id \
= id++;\n    this.nodesData = /* @__PURE__ */ new WeakMap();\n    this.parent \
= parent;\n  }\n  getData(node) {\n    let data = this.nodesData.get(node);\n \
   if (data === void 0 && this.parent !== null) {\n      data = \
this.parent.getData(node);\n    }\n    return data;\n  }\n  setData(node, \
data) {\n    this.nodesData.set(node, data);\n  }\n};\nvar Uniform = class \
{\n  constructor(name, value) {\n    this.name = name;\n    this.value = \
value;\n    this.boundary = 0;\n    this.itemSize = 0;\n    this.offset = \
0;\n  }\n  setValue(value) {\n    this.value = value;\n  }\n  getValue() {\n  \
  return this.value;\n  }\n};\nvar NumberUniform = class extends Uniform {\n  \
constructor(name, value = 0) {\n    super(name, value);\n    \
this.isNumberUniform = true;\n    this.boundary = 4;\n    this.itemSize = \
1;\n  }\n};\nvar Vector2Uniform = class extends Uniform {\n  \
constructor(name, value = new Vector22()) {\n    super(name, value);\n    \
this.isVector2Uniform = true;\n    this.boundary = 8;\n    this.itemSize = \
2;\n  }\n};\nvar Vector3Uniform = class extends Uniform {\n  \
constructor(name, value = new Vector32()) {\n    super(name, value);\n    \
this.isVector3Uniform = true;\n    this.boundary = 16;\n    this.itemSize = \
3;\n  }\n};\nvar Vector4Uniform = class extends Uniform {\n  \
constructor(name, value = new Vector42()) {\n    super(name, value);\n    \
this.isVector4Uniform = true;\n    this.boundary = 16;\n    this.itemSize = \
4;\n  }\n};\nvar ColorUniform = class extends Uniform {\n  constructor(name, \
value = new Color2()) {\n    super(name, value);\n    this.isColorUniform = \
true;\n    this.boundary = 16;\n    this.itemSize = 3;\n  }\n};\nvar \
Matrix3Uniform = class extends Uniform {\n  constructor(name, value = new \
Matrix32()) {\n    super(name, value);\n    this.isMatrix3Uniform = true;\n   \
 this.boundary = 48;\n    this.itemSize = 12;\n  }\n};\nvar Matrix4Uniform = \
class extends Uniform {\n  constructor(name, value = new Matrix42()) {\n    \
super(name, value);\n    this.isMatrix4Uniform = true;\n    this.boundary = \
64;\n    this.itemSize = 16;\n  }\n};\nvar NumberNodeUniform = class extends \
NumberUniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, \
nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() \
{\n    return this.nodeUniform.value;\n  }\n};\nvar Vector2NodeUniform = \
class extends Vector2Uniform {\n  constructor(nodeUniform) {\n    \
super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = \
nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  \
}\n};\nvar Vector3NodeUniform = class extends Vector3Uniform {\n  \
constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n \
   this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return \
this.nodeUniform.value;\n  }\n};\nvar Vector4NodeUniform = class extends \
Vector4Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, \
nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() \
{\n    return this.nodeUniform.value;\n  }\n};\nvar ColorNodeUniform = class \
extends ColorUniform {\n  constructor(nodeUniform) {\n    \
super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = \
nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  \
}\n};\nvar Matrix3NodeUniform = class extends Matrix3Uniform {\n  \
constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n \
   this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return \
this.nodeUniform.value;\n  }\n};\nvar Matrix4NodeUniform = class extends \
Matrix4Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, \
nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() \
{\n    return this.nodeUniform.value;\n  }\n};\nvar LOD_MIN2 = 4;\nvar \
EXTRA_LOD_SIGMA2 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nvar \
MAX_SAMPLES2 = 20;\nvar _flatCamera2 = /* @__PURE__ */ new \
OrthographicCamera2(-1, 1, 1, -1, 0, 1);\nvar _cubeCamera = /* @__PURE__ */ \
new PerspectiveCamera2(90, 1);\nvar _clearColor2 = /* @__PURE__ */ new \
Color2();\nvar _oldTarget2 = null;\nvar _oldActiveCubeFace2 = 0;\nvar \
_oldActiveMipmapLevel2 = 0;\nvar PHI2 = (1 + Math.sqrt(5)) / 2;\nvar INV_PHI2 \
= 1 / PHI2;\nvar _axisDirections2 = [\n  /* @__PURE__ */ new Vector32(-PHI2, \
INV_PHI2, 0),\n  /* @__PURE__ */ new Vector32(PHI2, INV_PHI2, 0),\n  /* \
@__PURE__ */ new Vector32(-INV_PHI2, 0, PHI2),\n  /* @__PURE__ */ new \
Vector32(INV_PHI2, 0, PHI2),\n  /* @__PURE__ */ new Vector32(0, PHI2, \
-INV_PHI2),\n  /* @__PURE__ */ new Vector32(0, PHI2, INV_PHI2),\n  /* \
@__PURE__ */ new Vector32(-1, 1, -1),\n  /* @__PURE__ */ new Vector32(1, 1, \
-1),\n  /* @__PURE__ */ new Vector32(-1, 1, 1),\n  /* @__PURE__ */ new \
Vector32(1, 1, 1)\n];\nvar _faceLib = [\n  3,\n  1,\n  5,\n  0,\n  4,\n  \
2\n];\nvar direction = getDirection(uv(), \
attribute(\"faceIndex\")).normalize();\nvar outputDirection = \
vec3(direction.x, direction.y.negate(), direction.z);\nvar PMREMGenerator2 = \
class {\n  constructor(renderer3) {\n    this._renderer = renderer3;\n    \
this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize \
= 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = \
[];\n    this._lodMeshes = [];\n    this._blurMaterial = null;\n    \
this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n    \
this._backgroundBox = null;\n  }\n  /**\n   * Generates a PMREM from a \
supplied Scene, which can be faster than using an\n   * image if networking \
bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to \
be applied to the scene before PMREM generation. Optional near\n   * and far \
planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is \
placed at the origin).\n   */\n  fromScene(scene3, sigma = 0, near = 0.1, far \
= 100) {\n    _oldTarget2 = this._renderer.getRenderTarget();\n    \
_oldActiveCubeFace2 = this._renderer.getActiveCubeFace();\n    \
_oldActiveMipmapLevel2 = this._renderer.getActiveMipmapLevel();\n    \
this._setSize(256);\n    const cubeUVRenderTarget = \
this._allocateTargets();\n    cubeUVRenderTarget.depthBuffer = true;\n    \
this._sceneToCubeUV(scene3, near, far, cubeUVRenderTarget);\n    if (sigma > \
0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n    \
this._applyPMREM(cubeUVRenderTarget);\n    \
this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  \
/**\n   * Generates a PMREM from an equirectangular texture, which can be \
either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * \
as this matches best with the 256 x 256 cubemap output.\n   */\n  \
fromEquirectangular(equirectangular, renderTarget = null) {\n    return \
this._fromTexture(equirectangular, renderTarget);\n  }\n  /**\n   * Generates \
a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The \
ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x \
256 cubemap output.\n   */\n  fromCubemap(cubemap, renderTarget = null) {\n   \
 return this._fromTexture(cubemap, renderTarget);\n  }\n  /**\n   * \
Pre-compiles the cubemap shader. You can get faster start-up by invoking this \
method during\n   * your texture's network fetch for increased concurrency.\n \
  */\n  async compileCubemapShader() {\n    if (this._cubemapMaterial === \
null) {\n      this._cubemapMaterial = _getCubemapMaterial2();\n      await \
this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n  /**\n   * \
Pre-compiles the equirectangular shader. You can get faster start-up by \
invoking this method during\n   * your texture's network fetch for increased \
concurrency.\n   */\n  async compileEquirectangularShader() {\n    if \
(this._equirectMaterial === null) {\n      this._equirectMaterial = \
_getEquirectMaterial2();\n      await \
this._compileMaterial(this._equirectMaterial);\n    }\n  }\n  /**\n   * \
Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is \
a static class,\n   * so you should not need more than one PMREMGenerator \
object. If you do, calling dispose() on\n   * one of them will cause any \
others to also become unusable.\n   */\n  dispose() {\n    this._dispose();\n \
   if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    \
if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n    \
if (this._backgroundBox !== null) {\n      \
this._backgroundBox.geometry.dispose();\n      \
this._backgroundBox.material.dispose();\n    }\n  }\n  // private interface\n \
 _setSize(cubeSize) {\n    this._lodMax = Math.floor(Math.log2(cubeSize));\n  \
  this._cubeSize = Math.pow(2, this._lodMax);\n  }\n  _dispose() {\n    if \
(this._blurMaterial !== null) this._blurMaterial.dispose();\n    if \
(this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n \
   for (let i = 0; i < this._lodPlanes.length; i++) {\n      \
this._lodPlanes[i].dispose();\n    }\n  }\n  _cleanup(outputTarget) {\n    \
this._renderer.setRenderTarget(_oldTarget2, _oldActiveCubeFace2, \
_oldActiveMipmapLevel2);\n    outputTarget.scissorTest = false;\n    \
_setViewport2(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n \
 }\n  _fromTexture(texture2, renderTarget) {\n    if (texture2.mapping === \
CubeReflectionMapping2 || texture2.mapping === CubeRefractionMapping2) {\n    \
  this._setSize(texture2.image.length === 0 ? 16 : texture2.image[0].width || \
texture2.image[0].image.width);\n    } else {\n      \
this._setSize(texture2.image.width / 4);\n    }\n    _oldTarget2 = \
this._renderer.getRenderTarget();\n    _oldActiveCubeFace2 = \
this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel2 = \
this._renderer.getActiveMipmapLevel();\n    const cubeUVRenderTarget = \
renderTarget || this._allocateTargets();\n    this._textureToCubeUV(texture2, \
cubeUVRenderTarget);\n    this._applyPMREM(cubeUVRenderTarget);\n    \
this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  \
_allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * \
7);\n    const height = 4 * this._cubeSize;\n    const params = {\n      \
magFilter: LinearFilter2,\n      minFilter: LinearFilter2,\n      \
generateMipmaps: false,\n      type: HalfFloatType2,\n      format: \
RGBAFormat2,\n      colorSpace: LinearSRGBColorSpace2\n      //depthBuffer: \
false\n    };\n    const cubeUVRenderTarget = _createRenderTarget2(width, \
height, params);\n    if (this._pingPongRenderTarget === null || \
this._pingPongRenderTarget.width !== width || \
this._pingPongRenderTarget.height !== height) {\n      if \
(this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n  \
    this._pingPongRenderTarget = _createRenderTarget2(width, height, \
params);\n      const { _lodMax } = this;\n      ({ sizeLods: this._sizeLods, \
lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes \
} = _createPlanes2(_lodMax));\n      this._blurMaterial = \
_getBlurShader2(_lodMax, width, height);\n    }\n    return \
cubeUVRenderTarget;\n  }\n  async _compileMaterial(material) {\n    const \
tmpMesh = new Mesh2(this._lodPlanes[0], material);\n    await \
this._renderer.compile(tmpMesh, _flatCamera2);\n  }\n  _sceneToCubeUV(scene3, \
near, far, cubeUVRenderTarget) {\n    const cubeCamera = _cubeCamera;\n    \
cubeCamera.near = near;\n    cubeCamera.far = far;\n    const upSign = [-1, \
1, -1, -1, -1, -1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    \
const renderer3 = this._renderer;\n    const originalAutoClear = \
renderer3.autoClear;\n    renderer3.getClearColor(_clearColor2);\n    \
renderer3.autoClear = false;\n    let backgroundBox = this._backgroundBox;\n  \
  if (backgroundBox === null) {\n      const backgroundMaterial = new \
MeshBasicMaterial2({\n        name: \"PMREM.Background\",\n        side: \
BackSide2,\n        depthWrite: false,\n        depthTest: false\n      });\n \
     backgroundBox = new Mesh2(new BoxGeometry2(), backgroundMaterial);\n    \
}\n    let useSolidColor = false;\n    const background = \
scene3.background;\n    if (background) {\n      if (background.isColor) {\n  \
      backgroundBox.material.color.copy(background);\n        \
scene3.background = null;\n        useSolidColor = true;\n      }\n    } else \
{\n      backgroundBox.material.color.copy(_clearColor2);\n      \
useSolidColor = true;\n    }\n    \
renderer3.setRenderTarget(cubeUVRenderTarget);\n    renderer3.clear();\n    \
if (useSolidColor) {\n      renderer3.render(backgroundBox, cubeCamera);\n    \
}\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n      if (col \
=== 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        \
cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n     \
   cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, \
forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], \
0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n      const \
size = this._cubeSize;\n      _setViewport2(cubeUVRenderTarget, col * size, i \
> 2 ? size : 0, size, size);\n      renderer3.render(scene3, cubeCamera);\n   \
 }\n    renderer3.autoClear = originalAutoClear;\n    scene3.background = \
background;\n  }\n  _textureToCubeUV(texture2, cubeUVRenderTarget) {\n    \
const renderer3 = this._renderer;\n    const isCubeTexture = texture2.mapping \
=== CubeReflectionMapping2 || texture2.mapping === CubeRefractionMapping2;\n  \
  if (isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        \
this._cubemapMaterial = _getCubemapMaterial2(texture2);\n      }\n    } else \
{\n      if (this._equirectMaterial === null) {\n        \
this._equirectMaterial = _getEquirectMaterial2(texture2);\n      }\n    }\n   \
 const material = isCubeTexture ? this._cubemapMaterial : \
this._equirectMaterial;\n    material.fragmentNode.value = texture2;\n    \
const mesh = this._lodMeshes[0];\n    mesh.material = material;\n    const \
size = this._cubeSize;\n    _setViewport2(cubeUVRenderTarget, 0, 0, 3 * size, \
2 * size);\n    renderer3.setRenderTarget(cubeUVRenderTarget);\n    \
renderer3.render(mesh, _flatCamera2);\n  }\n  _applyPMREM(cubeUVRenderTarget) \
{\n    const renderer3 = this._renderer;\n    const autoClear = \
renderer3.autoClear;\n    renderer3.autoClear = false;\n    const n = \
this._lodPlanes.length;\n    for (let i = 1; i < n; i++) {\n      const sigma \
= Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * \
this._sigmas[i - 1]);\n      const poleAxis = _axisDirections2[(n - i - 1) % \
_axisDirections2.length];\n      this._blur(cubeUVRenderTarget, i - 1, i, \
sigma, poleAxis);\n    }\n    renderer3.autoClear = autoClear;\n  }\n  /**\n  \
 * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   \
* vertically and horizontally, but this breaks down on a cube. Here we \
apply\n   * the blur latitudinally (around the poles), and then \
longitudinally (towards\n   * the poles) to approximate the \
orthogonally-separable blur. It is least\n   * accurate at the poles, but \
still does a decent job.\n   */\n  _blur(cubeUVRenderTarget, lodIn, lodOut, \
sigma, poleAxis) {\n    const pingPongRenderTarget = \
this._pingPongRenderTarget;\n    this._halfBlur(\n      cubeUVRenderTarget,\n \
     pingPongRenderTarget,\n      lodIn,\n      lodOut,\n      sigma,\n      \
\"latitudinal\",\n      poleAxis\n    );\n    this._halfBlur(\n      \
pingPongRenderTarget,\n      cubeUVRenderTarget,\n      lodOut,\n      \
lodOut,\n      sigma,\n      \"longitudinal\",\n      poleAxis\n    );\n  }\n \
 _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction2, \
poleAxis) {\n    const renderer3 = this._renderer;\n    const blurMaterial = \
this._blurMaterial;\n    if (direction2 !== \"latitudinal\" && direction2 !== \
\"longitudinal\") {\n      console.error(\"blur direction must be either \
latitudinal or longitudinal!\");\n    }\n    const STANDARD_DEVIATIONS = 3;\n \
   const blurMesh = this._lodMeshes[lodOut];\n    blurMesh.material = \
blurMaterial;\n    const blurUniforms = blurMaterial.uniforms;\n    const \
pixels = this._sizeLods[lodIn] - 1;\n    const radiansPerPixel = \
isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * \
MAX_SAMPLES2 - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n \
   const samples = isFinite(sigmaRadians) ? 1 + \
Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES2;\n    if \
(samples > MAX_SAMPLES2) {\n      console.warn(`sigmaRadians, \
${sigmaRadians}, is too large and will clip, as it requested ${samples} \
samples when the maximum is set to ${MAX_SAMPLES2}`);\n    }\n    const \
weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES2; ++i) \
{\n      const x3 = i / sigmaPixels;\n      const weight = Math.exp(-x3 * x3 \
/ 2);\n      weights.push(weight);\n      if (i === 0) {\n        sum += \
weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      \
}\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = \
weights[i] / sum;\n    }\n    targetIn.texture.frame = \
(targetIn.texture.frame || 0) + 1;\n    blurUniforms.envMap.value = \
targetIn.texture;\n    blurUniforms.samples.value = samples;\n    \
blurUniforms.weights.array = weights;\n    blurUniforms.latitudinal.value = \
direction2 === \"latitudinal\" ? 1 : 0;\n    if (poleAxis) {\n      \
blurUniforms.poleAxis.value = poleAxis;\n    }\n    const { _lodMax } = \
this;\n    blurUniforms.dTheta.value = radiansPerPixel;\n    \
blurUniforms.mipInt.value = _lodMax - lodIn;\n    const outputSize = \
this._sizeLods[lodOut];\n    const x2 = 3 * outputSize * (lodOut > _lodMax - \
LOD_MIN2 ? lodOut - _lodMax + LOD_MIN2 : 0);\n    const y2 = 4 * \
(this._cubeSize - outputSize);\n    _setViewport2(targetOut, x2, y2, 3 * \
outputSize, 2 * outputSize);\n    renderer3.setRenderTarget(targetOut);\n    \
renderer3.render(blurMesh, _flatCamera2);\n  }\n};\nfunction \
_createPlanes2(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  \
const sigmas = [];\n  const lodMeshes = [];\n  let lod = lodMax;\n  const \
totalLods = lodMax - LOD_MIN2 + 1 + EXTRA_LOD_SIGMA2.length;\n  for (let i = \
0; i < totalLods; i++) {\n    const sizeLod = Math.pow(2, lod);\n    \
sizeLods.push(sizeLod);\n    let sigma = 1 / sizeLod;\n    if (i > lodMax - \
LOD_MIN2) {\n      sigma = EXTRA_LOD_SIGMA2[i - lodMax + LOD_MIN2 - 1];\n    \
} else if (i === 0) {\n      sigma = 0;\n    }\n    sigmas.push(sigma);\n    \
const texelSize = 1 / (sizeLod - 2);\n    const min2 = -texelSize;\n    const \
max2 = 1 + texelSize;\n    const uv1 = [min2, min2, max2, min2, max2, max2, \
min2, min2, max2, max2, min2, max2];\n    const cubeFaces = 6;\n    const \
vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const \
faceIndexSize = 1;\n    const position = new Float32Array(positionSize * \
vertices * cubeFaces);\n    const uv2 = new Float32Array(uvSize * vertices * \
cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices \
* cubeFaces);\n    for (let face = 0; face < cubeFaces; face++) {\n      \
const x2 = face % 3 * 2 / 3 - 1;\n      const y2 = face > 2 ? 0 : -1;\n      \
const coordinates = [\n        x2,\n        y2,\n        0,\n        x2 + 2 / \
3,\n        y2,\n        0,\n        x2 + 2 / 3,\n        y2 + 1,\n        \
0,\n        x2,\n        y2,\n        0,\n        x2 + 2 / 3,\n        y2 + \
1,\n        0,\n        x2,\n        y2 + 1,\n        0\n      ];\n      \
const faceIdx = _faceLib[face];\n      position.set(coordinates, positionSize \
* vertices * faceIdx);\n      uv2.set(uv1, uvSize * vertices * faceIdx);\n    \
  const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];\n      \
faceIndex.set(fill, faceIndexSize * vertices * faceIdx);\n    }\n    const \
planes = new BufferGeometry2();\n    planes.setAttribute(\"position\", new \
BufferAttribute2(position, positionSize));\n    planes.setAttribute(\"uv\", \
new BufferAttribute2(uv2, uvSize));\n    planes.setAttribute(\"faceIndex\", \
new BufferAttribute2(faceIndex, faceIndexSize));\n    \
lodPlanes.push(planes);\n    lodMeshes.push(new Mesh2(planes, null));\n    if \
(lod > LOD_MIN2) {\n      lod--;\n    }\n  }\n  return { lodPlanes, sizeLods, \
sigmas, lodMeshes };\n}\nfunction _createRenderTarget2(width, height, params) \
{\n  const cubeUVRenderTarget = new RenderTarget2(width, height, params);\n  \
cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping2;\n  \
cubeUVRenderTarget.texture.name = \"PMREM.cubeUv\";\n  \
cubeUVRenderTarget.texture.isPMREMTexture = true;\n  \
cubeUVRenderTarget.scissorTest = true;\n  return \
cubeUVRenderTarget;\n}\nfunction _setViewport2(target, x2, y2, width, height) \
{\n  target.viewport.set(x2, y2, width, height);\n  target.scissor.set(x2, \
y2, width, height);\n}\nfunction _getMaterial(type) {\n  const material = new \
NodeMaterial();\n  material.depthTest = false;\n  material.depthWrite = \
false;\n  material.blending = NoBlending2;\n  material.name = \
`PMREM_${type}`;\n  return material;\n}\nfunction _getBlurShader2(lodMax, \
width, height) {\n  const weights = uniformArray(new \
Array(MAX_SAMPLES2).fill(0));\n  const poleAxis = uniform(new Vector32(0, 1, \
0));\n  const dTheta = uniform(0);\n  const n = float(MAX_SAMPLES2);\n  const \
latitudinal = uniform(0);\n  const samples = uniform(1);\n  const envMap = \
texture(null);\n  const mipInt = uniform(0);\n  const CUBEUV_TEXEL_WIDTH = \
float(1 / width);\n  const CUBEUV_TEXEL_HEIGHT = float(1 / height);\n  const \
CUBEUV_MAX_MIP = float(lodMax);\n  const materialUniforms = {\n    n,\n    \
latitudinal,\n    weights,\n    poleAxis,\n    outputDirection,\n    \
dTheta,\n    samples,\n    envMap,\n    mipInt,\n    CUBEUV_TEXEL_WIDTH,\n    \
CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  };\n  const material = \
_getMaterial(\"blur\");\n  material.uniforms = materialUniforms;\n  \
material.fragmentNode = blur({ ...materialUniforms, latitudinal: \
latitudinal.equal(1) });\n  return material;\n}\nfunction \
_getCubemapMaterial2(envTexture) {\n  const material = \
_getMaterial(\"cubemap\");\n  material.fragmentNode = cubeTexture(envTexture, \
outputDirection);\n  return material;\n}\nfunction \
_getEquirectMaterial2(envTexture) {\n  const material = \
_getMaterial(\"equirect\");\n  material.fragmentNode = texture(envTexture, \
equirectUV(outputDirection), 0);\n  return material;\n}\nvar rendererCache = \
/* @__PURE__ */ new WeakMap();\nvar typeFromLength = /* @__PURE__ */ new \
Map([\n  [2, \"vec2\"],\n  [3, \"vec3\"],\n  [4, \"vec4\"],\n  [9, \
\"mat3\"],\n  [16, \"mat4\"]\n]);\nvar typeFromArray = /* @__PURE__ */ new \
Map([\n  [Int8Array, \"int\"],\n  [Int16Array, \"int\"],\n  [Int32Array, \
\"int\"],\n  [Uint8Array, \"uint\"],\n  [Uint16Array, \"uint\"],\n  \
[Uint32Array, \"uint\"],\n  [Float32Array, \"float\"]\n]);\nvar toFloat = \
(value) => {\n  if (/e/g.test(value)) {\n    return \
String(value).replace(/\\+/g, \"\");\n  } else {\n    value = \
Number(value);\n    return value + (value % 1 ? \"\" : \".0\");\n  }\n};\nvar \
NodeBuilder = class {\n  constructor(object, renderer3, parser) {\n    \
this.object = object;\n    this.material = object && object.material || \
null;\n    this.geometry = object && object.geometry || null;\n    \
this.renderer = renderer3;\n    this.parser = parser;\n    this.scene = \
null;\n    this.camera = null;\n    this.nodes = [];\n    \
this.sequentialNodes = [];\n    this.updateNodes = [];\n    \
this.updateBeforeNodes = [];\n    this.updateAfterNodes = [];\n    \
this.hashNodes = {};\n    this.monitor = null;\n    this.lightsNode = null;\n \
   this.environmentNode = null;\n    this.fogNode = null;\n    \
this.clippingContext = null;\n    this.vertexShader = null;\n    \
this.fragmentShader = null;\n    this.computeShader = null;\n    \
this.flowNodes = { vertex: [], fragment: [], compute: [] };\n    \
this.flowCode = { vertex: \"\", fragment: \"\", compute: \"\" };\n    \
this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n    \
this.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n    \
this.bindings = { vertex: {}, fragment: {}, compute: {} };\n    \
this.bindingsIndexes = {};\n    this.bindGroups = null;\n    this.attributes \
= [];\n    this.bufferAttributes = [];\n    this.varyings = [];\n    \
this.codes = {};\n    this.vars = {};\n    this.flow = { code: \"\" };\n    \
this.chaining = [];\n    this.stack = stack();\n    this.stacks = [];\n    \
this.tab = \"\t\";\n    this.currentFunctionNode = null;\n    this.context = \
{\n      material: this.material\n    };\n    this.cache = new NodeCache();\n \
   this.globalCache = this.cache;\n    this.flowsData = /* @__PURE__ */ new \
WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n    \
this.useComparisonMethod = false;\n  }\n  getBindGroupsCache() {\n    let \
bindGroupsCache = rendererCache.get(this.renderer);\n    if (bindGroupsCache \
=== void 0) {\n      bindGroupsCache = new ChainMap();\n      \
rendererCache.set(this.renderer, bindGroupsCache);\n    }\n    return \
bindGroupsCache;\n  }\n  createRenderTarget(width, height, options) {\n    \
return new RenderTarget2(width, height, options);\n  }\n  \
createCubeRenderTarget(size, options) {\n    return new \
CubeRenderTarget(size, options);\n  }\n  createPMREMGenerator() {\n    return \
new PMREMGenerator2(this.renderer);\n  }\n  includes(node) {\n    return \
this.nodes.includes(node);\n  }\n  _getBindGroup(groupName, bindings) {\n    \
const bindGroupsCache = this.getBindGroupsCache();\n    const bindingsArray = \
[];\n    let sharedGroup = true;\n    for (const binding of bindings) {\n     \
 bindingsArray.push(binding);\n      sharedGroup = sharedGroup && \
binding.groupNode.shared !== true;\n    }\n    let bindGroup;\n    if \
(sharedGroup) {\n      bindGroup = bindGroupsCache.get(bindingsArray);\n      \
if (bindGroup === void 0) {\n        bindGroup = new BindGroup(groupName, \
bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);\n       \
 bindGroupsCache.set(bindingsArray, bindGroup);\n      }\n    } else {\n      \
bindGroup = new BindGroup(groupName, bindingsArray, \
this.bindingsIndexes[groupName].group, bindingsArray);\n    }\n    return \
bindGroup;\n  }\n  getBindGroupArray(groupName, shaderStage) {\n    const \
bindings = this.bindings[shaderStage];\n    let bindGroup = \
bindings[groupName];\n    if (bindGroup === void 0) {\n      if \
(this.bindingsIndexes[groupName] === void 0) {\n        \
this.bindingsIndexes[groupName] = { binding: 0, group: \
Object.keys(this.bindingsIndexes).length };\n      }\n      \
bindings[groupName] = bindGroup = [];\n    }\n    return bindGroup;\n  }\n  \
getBindings() {\n    let bindingsGroups = this.bindGroups;\n    if \
(bindingsGroups === null) {\n      const groups = {};\n      const bindings = \
this.bindings;\n      for (const shaderStage of shaderStages) {\n        for \
(const groupName in bindings[shaderStage]) {\n          const uniforms = \
bindings[shaderStage][groupName];\n          const groupUniforms = \
groups[groupName] || (groups[groupName] = []);\n          \
groupUniforms.push(...uniforms);\n        }\n      }\n      bindingsGroups = \
[];\n      for (const groupName in groups) {\n        const group = \
groups[groupName];\n        const bindingsGroup = \
this._getBindGroup(groupName, group);\n        \
bindingsGroups.push(bindingsGroup);\n      }\n      this.bindGroups = \
bindingsGroups;\n    }\n    return bindingsGroups;\n  }\n  \
sortBindingGroups() {\n    const bindingsGroups = this.getBindings();\n    \
bindingsGroups.sort((a2, b) => a2.bindings[0].groupNode.order - \
b.bindings[0].groupNode.order);\n    for (let i = 0; i < \
bindingsGroups.length; i++) {\n      const bindingGroup = \
bindingsGroups[i];\n      this.bindingsIndexes[bindingGroup.name].group = \
i;\n      bindingGroup.index = i;\n    }\n  }\n  setHashNode(node, hash) {\n  \
  this.hashNodes[hash] = node;\n  }\n  addNode(node) {\n    if \
(this.nodes.includes(node) === false) {\n      this.nodes.push(node);\n      \
this.setHashNode(node, node.getHash(this));\n    }\n  }\n  \
addSequentialNode(node) {\n    if (this.sequentialNodes.includes(node) === \
false) {\n      this.sequentialNodes.push(node);\n    }\n  }\n  \
buildUpdateNodes() {\n    for (const node of this.nodes) {\n      const \
updateType = node.getUpdateType();\n      if (updateType !== \
NodeUpdateType.NONE) {\n        this.updateNodes.push(node.getSelf());\n      \
}\n    }\n    for (const node of this.sequentialNodes) {\n      const \
updateBeforeType = node.getUpdateBeforeType();\n      const updateAfterType = \
node.getUpdateAfterType();\n      if (updateBeforeType !== \
NodeUpdateType.NONE) {\n        \
this.updateBeforeNodes.push(node.getSelf());\n      }\n      if \
(updateAfterType !== NodeUpdateType.NONE) {\n        \
this.updateAfterNodes.push(node.getSelf());\n      }\n    }\n  }\n  get \
currentNode() {\n    return this.chaining[this.chaining.length - 1];\n  }\n  \
isFilteredTexture(texture2) {\n    return texture2.magFilter === \
LinearFilter2 || texture2.magFilter === LinearMipmapNearestFilter2 || \
texture2.magFilter === NearestMipmapLinearFilter2 || texture2.magFilter === \
LinearMipmapLinearFilter2 || texture2.minFilter === LinearFilter2 || \
texture2.minFilter === LinearMipmapNearestFilter2 || texture2.minFilter === \
NearestMipmapLinearFilter2 || texture2.minFilter === \
LinearMipmapLinearFilter2;\n  }\n  addChain(node) {\n    \
this.chaining.push(node);\n  }\n  removeChain(node) {\n    const lastChain = \
this.chaining.pop();\n    if (lastChain !== node) {\n      throw new \
Error(\"NodeBuilder: Invalid node chaining!\");\n    }\n  }\n  \
getMethod(method) {\n    return method;\n  }\n  getNodeFromHash(hash) {\n    \
return this.hashNodes[hash];\n  }\n  addFlow(shaderStage, node) {\n    \
this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n  \
setContext(context2) {\n    this.context = context2;\n  }\n  getContext() {\n \
   return this.context;\n  }\n  getSharedContext() {\n    ({ ...this.context \
});\n    return this.context;\n  }\n  setCache(cache2) {\n    this.cache = \
cache2;\n  }\n  getCache() {\n    return this.cache;\n  }\n  \
getCacheFromNode(node, parent = true) {\n    const data = \
this.getDataFromNode(node);\n    if (data.cache === void 0) data.cache = new \
NodeCache(parent ? this.getCache() : null);\n    return data.cache;\n  }\n  \
isAvailable() {\n    return false;\n  }\n  getVertexIndex() {\n    \
console.warn(\"Abstract function.\");\n  }\n  getInstanceIndex() {\n    \
console.warn(\"Abstract function.\");\n  }\n  getDrawIndex() {\n    \
console.warn(\"Abstract function.\");\n  }\n  getFrontFacing() {\n    \
console.warn(\"Abstract function.\");\n  }\n  getFragCoord() {\n    \
console.warn(\"Abstract function.\");\n  }\n  isFlipY() {\n    return \
false;\n  }\n  increaseUsage(node) {\n    const nodeData = \
this.getDataFromNode(node);\n    nodeData.usageCount = nodeData.usageCount \
=== void 0 ? 1 : nodeData.usageCount + 1;\n    return nodeData.usageCount;\n  \
}\n  generateTexture() {\n    console.warn(\"Abstract function.\");\n  }\n  \
generateTextureLod() {\n    console.warn(\"Abstract function.\");\n  }\n  \
generateConst(type, value = null) {\n    if (value === null) {\n      if \
(type === \"float\" || type === \"int\" || type === \"uint\") value = 0;\n    \
  else if (type === \"bool\") value = false;\n      else if (type === \
\"color\") value = new Color2();\n      else if (type === \"vec2\") value = \
new Vector22();\n      else if (type === \"vec3\") value = new Vector32();\n  \
    else if (type === \"vec4\") value = new Vector42();\n    }\n    if (type \
=== \"float\") return toFloat(value);\n    if (type === \"int\") return \
`${Math.round(value)}`;\n    if (type === \"uint\") return value >= 0 ? \
`${Math.round(value)}u` : \"0u\";\n    if (type === \"bool\") return value ? \
\"true\" : \"false\";\n    if (type === \"color\") return \
`${this.getType(\"vec3\")}( ${toFloat(value.r)}, ${toFloat(value.g)}, \
${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n   \
 const componentType = this.getComponentType(type);\n    const generateConst \
= (value2) => this.generateConst(componentType, value2);\n    if (typeLength \
=== 2) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, \
${generateConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      \
return `${this.getType(type)}( ${generateConst(value.x)}, \
${generateConst(value.y)}, ${generateConst(value.z)} )`;\n    } else if \
(typeLength === 4) {\n      return `${this.getType(type)}( \
${generateConst(value.x)}, ${generateConst(value.y)}, \
${generateConst(value.z)}, ${generateConst(value.w)} )`;\n    } else if \
(typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n      \
return `${this.getType(type)}( ${value.elements.map(generateConst).join(\", \
\")} )`;\n    } else if (typeLength > 4) {\n      return \
`${this.getType(type)}()`;\n    }\n    throw new Error(`NodeBuilder: Type \
'${type}' not found in generate constant attempt.`);\n  }\n  getType(type) \
{\n    if (type === \"color\") return \"vec3\";\n    return type;\n  }\n  \
hasGeometryAttribute(name) {\n    return this.geometry && \
this.geometry.getAttribute(name) !== void 0;\n  }\n  getAttribute(name, type) \
{\n    const attributes = this.attributes;\n    for (const attribute3 of \
attributes) {\n      if (attribute3.name === name) {\n        return \
attribute3;\n      }\n    }\n    const attribute2 = new NodeAttribute(name, \
type);\n    attributes.push(attribute2);\n    return attribute2;\n  }\n  \
getPropertyName(node) {\n    return node.name;\n  }\n  isVector(type) {\n    \
return /vec\\d/.test(type);\n  }\n  isMatrix(type) {\n    return \
/mat\\d/.test(type);\n  }\n  isReference(type) {\n    return type === \
\"void\" || type === \"property\" || type === \"sampler\" || type === \
\"texture\" || type === \"cubeTexture\" || type === \"storageTexture\" || \
type === \"depthTexture\" || type === \"texture3D\";\n  }\n  \
needsToWorkingColorSpace() {\n    return false;\n  }\n  \
getComponentTypeFromTexture(texture2) {\n    const type = texture2.type;\n    \
if (texture2.isDataTexture) {\n      if (type === IntType2) return \"int\";\n \
     if (type === UnsignedIntType2) return \"uint\";\n    }\n    return \
\"float\";\n  }\n  getElementType(type) {\n    if (type === \"mat2\") return \
\"vec2\";\n    if (type === \"mat3\") return \"vec3\";\n    if (type === \
\"mat4\") return \"vec4\";\n    return this.getComponentType(type);\n  }\n  \
getComponentType(type) {\n    type = this.getVectorType(type);\n    if (type \
=== \"float\" || type === \"bool\" || type === \"int\" || type === \"uint\") \
return type;\n    const componentType = \
/(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) \
return null;\n    if (componentType[1] === \"b\") return \"bool\";\n    if \
(componentType[1] === \"i\") return \"int\";\n    if (componentType[1] === \
\"u\") return \"uint\";\n    return \"float\";\n  }\n  getVectorType(type) \
{\n    if (type === \"color\") return \"vec3\";\n    if (type === \"texture\" \
|| type === \"cubeTexture\" || type === \"storageTexture\" || type === \
\"texture3D\") return \"vec4\";\n    return type;\n  }\n  \
getTypeFromLength(length2, componentType = \"float\") {\n    if (length2 === \
1) return componentType;\n    const baseType = typeFromLength.get(length2);\n \
   const prefix = componentType === \"float\" ? \"\" : componentType[0];\n    \
return prefix + baseType;\n  }\n  getTypeFromArray(array) {\n    return \
typeFromArray.get(array.constructor);\n  }\n  \
getTypeFromAttribute(attribute2) {\n    let dataAttribute = attribute2;\n    \
if (attribute2.isInterleavedBufferAttribute) dataAttribute = \
attribute2.data;\n    const array = dataAttribute.array;\n    const itemSize \
= attribute2.itemSize;\n    const normalized = attribute2.normalized;\n    \
let arrayType;\n    if (!(attribute2 instanceof Float16BufferAttribute) && \
normalized !== true) {\n      arrayType = this.getTypeFromArray(array);\n    \
}\n    return this.getTypeFromLength(itemSize, arrayType);\n  }\n  \
getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    \
const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return \
Number(vecNum[1]);\n    if (vecType === \"float\" || vecType === \"bool\" || \
vecType === \"int\" || vecType === \"uint\") return 1;\n    if \
(/mat2/.test(type) === true) return 4;\n    if (/mat3/.test(type) === true) \
return 9;\n    if (/mat4/.test(type) === true) return 16;\n    return 0;\n  \
}\n  getVectorFromMatrix(type) {\n    return type.replace(\"mat\", \
\"vec\");\n  }\n  changeComponentType(type, newComponentType) {\n    return \
this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n  }\n  \
getIntegerType(type) {\n    const componentType = \
this.getComponentType(type);\n    if (componentType === \"int\" || \
componentType === \"uint\") return type;\n    return \
this.changeComponentType(type, \"int\");\n  }\n  addStack() {\n    this.stack \
= stack(this.stack);\n    this.stacks.push(getCurrentStack() || \
this.stack);\n    setCurrentStack(this.stack);\n    return this.stack;\n  }\n \
 removeStack() {\n    const lastStack = this.stack;\n    this.stack = \
lastStack.parent;\n    setCurrentStack(this.stacks.pop());\n    return \
lastStack;\n  }\n  getDataFromNode(node, shaderStage = this.shaderStage, \
cache2 = null) {\n    cache2 = cache2 === null ? node.isGlobal(this) ? \
this.globalCache : this.cache : cache2;\n    let nodeData = \
cache2.getData(node);\n    if (nodeData === void 0) {\n      nodeData = {};\n \
     cache2.setData(node, nodeData);\n    }\n    if (nodeData[shaderStage] \
=== void 0) nodeData[shaderStage] = {};\n    return nodeData[shaderStage];\n  \
}\n  getNodeProperties(node, shaderStage = \"any\") {\n    const nodeData = \
this.getDataFromNode(node, shaderStage);\n    return nodeData.properties || \
(nodeData.properties = { outputNode: null });\n  }\n  \
getBufferAttributeFromNode(node, type) {\n    const nodeData = \
this.getDataFromNode(node);\n    let bufferAttribute2 = \
nodeData.bufferAttribute;\n    if (bufferAttribute2 === void 0) {\n      \
const index5 = this.uniforms.index++;\n      bufferAttribute2 = new \
NodeAttribute(\"nodeAttribute\" + index5, type, node);\n      \
this.bufferAttributes.push(bufferAttribute2);\n      nodeData.bufferAttribute \
= bufferAttribute2;\n    }\n    return bufferAttribute2;\n  }\n  \
getStructTypeFromNode(node, shaderStage = this.shaderStage) {\n    const \
nodeData = this.getDataFromNode(node, shaderStage);\n    if \
(nodeData.structType === void 0) {\n      const index5 = \
this.structs.index++;\n      node.name = `StructType${index5}`;\n      \
this.structs[shaderStage].push(node);\n      nodeData.structType = node;\n    \
}\n    return node;\n  }\n  getUniformFromNode(node, type, shaderStage = \
this.shaderStage, name = null) {\n    const nodeData = \
this.getDataFromNode(node, shaderStage, this.globalCache);\n    let \
nodeUniform = nodeData.uniform;\n    if (nodeUniform === void 0) {\n      \
const index5 = this.uniforms.index++;\n      nodeUniform = new \
NodeUniform(name || \"nodeUniform\" + index5, type, node);\n      \
this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = \
nodeUniform;\n    }\n    return nodeUniform;\n  }\n  getVarFromNode(node, \
name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) \
{\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let \
nodeVar = nodeData.variable;\n    if (nodeVar === void 0) {\n      const vars \
= this.vars[shaderStage] || (this.vars[shaderStage] = []);\n      if (name \
=== null) name = \"nodeVar\" + vars.length;\n      nodeVar = new \
NodeVar(name, type);\n      vars.push(nodeVar);\n      nodeData.variable = \
nodeVar;\n    }\n    return nodeVar;\n  }\n  getVaryingFromNode(node, name = \
null, type = node.getNodeType(this)) {\n    const nodeData = \
this.getDataFromNode(node, \"any\");\n    let nodeVarying = \
nodeData.varying;\n    if (nodeVarying === void 0) {\n      const varyings = \
this.varyings;\n      const index5 = varyings.length;\n      if (name === \
null) name = \"nodeVarying\" + index5;\n      nodeVarying = new \
NodeVarying(name, type);\n      varyings.push(nodeVarying);\n      \
nodeData.varying = nodeVarying;\n    }\n    return nodeVarying;\n  }\n  \
getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const \
nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n   \
 if (nodeCode === void 0) {\n      const codes = this.codes[shaderStage] || \
(this.codes[shaderStage] = []);\n      const index5 = codes.length;\n      \
nodeCode = new NodeCode(\"nodeCode\" + index5, type);\n      \
codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return \
nodeCode;\n  }\n  addFlowCodeHierarchy(node, nodeBlock) {\n    const { \
flowCodes, flowCodeBlock } = this.getDataFromNode(node);\n    let \
needsFlowCode = true;\n    let nodeBlockHierarchy = nodeBlock;\n    while \
(nodeBlockHierarchy) {\n      if (flowCodeBlock.get(nodeBlockHierarchy) === \
true) {\n        needsFlowCode = false;\n        break;\n      }\n      \
nodeBlockHierarchy = \
this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;\n    }\n    if \
(needsFlowCode) {\n      for (const flowCode of flowCodes) {\n        \
this.addLineFlowCode(flowCode);\n      }\n    }\n  }\n  \
addLineFlowCodeBlock(node, code, nodeBlock) {\n    const nodeData = \
this.getDataFromNode(node);\n    const flowCodes = nodeData.flowCodes || \
(nodeData.flowCodes = []);\n    const codeBlock = nodeData.flowCodeBlock || \
(nodeData.flowCodeBlock = /* @__PURE__ */ new WeakMap());\n    \
flowCodes.push(code);\n    codeBlock.set(nodeBlock, true);\n  }\n  \
addLineFlowCode(code, node = null) {\n    if (code === \"\") return this;\n   \
 if (node !== null && this.context.nodeBlock) {\n      \
this.addLineFlowCodeBlock(node, code, this.context.nodeBlock);\n    }\n    \
code = this.tab + code;\n    if (!/;\\s*$/.test(code)) {\n      code = code + \
\";\\n\";\n    }\n    this.flow.code += code;\n    return this;\n  }\n  \
addFlowCode(code) {\n    this.flow.code += code;\n    return this;\n  }\n  \
addFlowTab() {\n    this.tab += \"\t\";\n    return this;\n  }\n  \
removeFlowTab() {\n    this.tab = this.tab.slice(0, -1);\n    return this;\n  \
}\n  getFlowData(node) {\n    return this.flowsData.get(node);\n  }\n  \
flowNode(node) {\n    const output2 = node.getNodeType(this);\n    const \
flowData = this.flowChildNode(node, output2);\n    this.flowsData.set(node, \
flowData);\n    return flowData;\n  }\n  buildFunctionNode(shaderNode) {\n    \
const fn = new FunctionNode();\n    const previous = \
this.currentFunctionNode;\n    this.currentFunctionNode = fn;\n    fn.code = \
this.buildFunctionCode(shaderNode);\n    this.currentFunctionNode = \
previous;\n    return fn;\n  }\n  flowShaderNode(shaderNode) {\n    const \
layout = shaderNode.layout;\n    const inputs = {\n      [Symbol.iterator]() \
{\n        let index5 = 0;\n        const values = Object.values(this);\n     \
   return {\n          next: () => ({\n            value: values[index5],\n   \
         done: index5++ >= values.length\n          })\n        };\n      }\n \
   };\n    for (const input of layout.inputs) {\n      inputs[input.name] = \
new ParameterNode(input.type, input.name);\n    }\n    shaderNode.layout = \
null;\n    const callNode = shaderNode.call(inputs);\n    const flowData = \
this.flowStagesNode(callNode, layout.type);\n    shaderNode.layout = \
layout;\n    return flowData;\n  }\n  flowStagesNode(node, output2 = null) \
{\n    const previousFlow = this.flow;\n    const previousVars = this.vars;\n \
   const previousCache = this.cache;\n    const previousBuildStage = \
this.buildStage;\n    const previousStack = this.stack;\n    const flow = {\n \
     code: \"\"\n    };\n    this.flow = flow;\n    this.vars = {};\n    \
this.cache = new NodeCache();\n    this.stack = stack();\n    for (const \
buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n  \
    flow.result = node.build(this, output2);\n    }\n    flow.vars = \
this.getVars(this.shaderStage);\n    this.flow = previousFlow;\n    this.vars \
= previousVars;\n    this.cache = previousCache;\n    this.stack = \
previousStack;\n    this.setBuildStage(previousBuildStage);\n    return \
flow;\n  }\n  getFunctionOperator() {\n    return null;\n  }\n  \
flowChildNode(node, output2 = null) {\n    const previousFlow = this.flow;\n  \
  const flow = {\n      code: \"\"\n    };\n    this.flow = flow;\n    \
flow.result = node.build(this, output2);\n    this.flow = previousFlow;\n    \
return flow;\n  }\n  flowNodeFromShaderStage(shaderStage, node, output2 = \
null, propertyName = null) {\n    const previousShaderStage = \
this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData \
= this.flowChildNode(node, output2);\n    if (propertyName !== null) {\n      \
flowData.code += `${this.tab + propertyName} = ${flowData.result};\n`;\n    \
}\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + \
flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return \
flowData;\n  }\n  getAttributesArray() {\n    return \
this.attributes.concat(this.bufferAttributes);\n  }\n  getAttributes() {\n    \
console.warn(\"Abstract function.\");\n  }\n  getVaryings() {\n    \
console.warn(\"Abstract function.\");\n  }\n  getVar(type, name) {\n    \
return `${this.getType(type)} ${name}`;\n  }\n  getVars(shaderStage) {\n    \
let snippet = \"\";\n    const vars = this.vars[shaderStage];\n    if (vars \
!== void 0) {\n      for (const variable of vars) {\n        snippet += \
`${this.getVar(variable.type, variable.name)}; `;\n      }\n    }\n    return \
snippet;\n  }\n  getUniforms() {\n    console.warn(\"Abstract function.\");\n \
 }\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n   \
 let code = \"\";\n    if (codes !== void 0) {\n      for (const nodeCode of \
codes) {\n        code += nodeCode.code + \"\\n\";\n      }\n    }\n    \
return code;\n  }\n  getHash() {\n    return this.vertexShader + \
this.fragmentShader + this.computeShader;\n  }\n  setShaderStage(shaderStage) \
{\n    this.shaderStage = shaderStage;\n  }\n  getShaderStage() {\n    return \
this.shaderStage;\n  }\n  setBuildStage(buildStage) {\n    this.buildStage = \
buildStage;\n  }\n  getBuildStage() {\n    return this.buildStage;\n  }\n  \
buildCode() {\n    console.warn(\"Abstract function.\");\n  }\n  build() {\n  \
  const { object, material, renderer: renderer3 } = this;\n    if (material \
!== null) {\n      let nodeMaterial = \
renderer3.library.fromMaterial(material);\n      if (nodeMaterial === null) \
{\n        console.error(`NodeMaterial: Material \"${material.type}\" is not \
compatible.`);\n        nodeMaterial = new NodeMaterial();\n      }\n      \
nodeMaterial.build(this);\n    } else {\n      this.addFlow(\"compute\", \
object);\n    }\n    for (const buildStage of defaultBuildStages) {\n      \
this.setBuildStage(buildStage);\n      if (this.context.vertex && \
this.context.vertex.isNode) {\n        \
this.flowNodeFromShaderStage(\"vertex\", this.context.vertex);\n      }\n     \
 for (const shaderStage of shaderStages) {\n        \
this.setShaderStage(shaderStage);\n        const flowNodes = \
this.flowNodes[shaderStage];\n        for (const node of flowNodes) {\n       \
   if (buildStage === \"generate\") {\n            this.flowNode(node);\n     \
     } else {\n            node.build(this);\n          }\n        }\n      \
}\n    }\n    this.setBuildStage(null);\n    this.setShaderStage(null);\n    \
this.buildCode();\n    this.buildUpdateNodes();\n    return this;\n  }\n  \
getNodeUniform(uniformNode, type) {\n    if (type === \"float\" || type === \
\"int\" || type === \"uint\") return new NumberNodeUniform(uniformNode);\n    \
if (type === \"vec2\" || type === \"ivec2\" || type === \"uvec2\") return new \
Vector2NodeUniform(uniformNode);\n    if (type === \"vec3\" || type === \
\"ivec3\" || type === \"uvec3\") return new \
Vector3NodeUniform(uniformNode);\n    if (type === \"vec4\" || type === \
\"ivec4\" || type === \"uvec4\") return new \
Vector4NodeUniform(uniformNode);\n    if (type === \"color\") return new \
ColorNodeUniform(uniformNode);\n    if (type === \"mat3\") return new \
Matrix3NodeUniform(uniformNode);\n    if (type === \"mat4\") return new \
Matrix4NodeUniform(uniformNode);\n    throw new Error(`Uniform \"${type}\" \
not declared.`);\n  }\n  createNodeMaterial(type = \"NodeMaterial\") {\n    \
throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use \
new ${type}() instead.`);\n  }\n  format(snippet, fromType, toType) {\n    \
fromType = this.getVectorType(fromType);\n    toType = \
this.getVectorType(toType);\n    if (fromType === toType || toType === null \
|| this.isReference(toType)) {\n      return snippet;\n    }\n    const \
fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = \
this.getTypeLength(toType);\n    if (fromTypeLength === 16 && toTypeLength \
=== 9) {\n      return `${this.getType(toType)}(${snippet}[0].xyz, \
${snippet}[1].xyz, ${snippet}[2].xyz)`;\n    }\n    if (fromTypeLength === 9 \
&& toTypeLength === 4) {\n      return \
`${this.getType(toType)}(${snippet}[0].xy, ${snippet}[1].xy)`;\n    }\n    if \
(fromTypeLength > 4) {\n      return snippet;\n    }\n    if (toTypeLength > \
4 || toTypeLength === 0) {\n      return snippet;\n    }\n    if \
(fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( \
${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return \
this.format(`${snippet}.${\"xyz\".slice(0, toTypeLength)}`, \
this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), \
toType);\n    }\n    if (toTypeLength === 4 && fromTypeLength > 1) {\n      \
return `${this.getType(toType)}( ${this.format(snippet, fromType, \"vec3\")}, \
1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      return \
`${this.getType(toType)}( ${this.format(snippet, fromType, \"vec2\")}, 0.0 \
)`;\n    }\n    if (fromTypeLength === 1 && toTypeLength > 1 && fromType !== \
this.getComponentType(toType)) {\n      snippet = \
`${this.getType(this.getComponentType(toType))}( ${snippet} )`;\n    }\n    \
return `${this.getType(toType)}( ${snippet} )`;\n  }\n  getSignature() {\n    \
return `// Three.js r${REVISION2} - Node System\n`;\n  }\n};\nvar NodeFrame = \
class {\n  constructor() {\n    this.time = 0;\n    this.deltaTime = 0;\n    \
this.frameId = 0;\n    this.renderId = 0;\n    this.startTime = null;\n    \
this.updateMap = /* @__PURE__ */ new WeakMap();\n    this.updateBeforeMap = \
/* @__PURE__ */ new WeakMap();\n    this.updateAfterMap = /* @__PURE__ */ new \
WeakMap();\n    this.renderer = null;\n    this.material = null;\n    \
this.camera = null;\n    this.object = null;\n    this.scene = null;\n  }\n  \
_getMaps(referenceMap, nodeRef) {\n    let maps = \
referenceMap.get(nodeRef);\n    if (maps === void 0) {\n      maps = {\n      \
  renderMap: /* @__PURE__ */ new WeakMap(),\n        frameMap: /* @__PURE__ \
*/ new WeakMap()\n      };\n      referenceMap.set(nodeRef, maps);\n    }\n   \
 return maps;\n  }\n  updateBeforeNode(node) {\n    const updateType = \
node.getUpdateBeforeType();\n    const reference2 = \
node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n \
     const { frameMap } = this._getMaps(this.updateBeforeMap, reference2);\n  \
    if (frameMap.get(reference2) !== this.frameId) {\n        if \
(node.updateBefore(this) !== false) {\n          frameMap.set(reference2, \
this.frameId);\n        }\n      }\n    } else if (updateType === \
NodeUpdateType.RENDER) {\n      const { renderMap } = \
this._getMaps(this.updateBeforeMap, reference2);\n      if \
(renderMap.get(reference2) !== this.renderId) {\n        if \
(node.updateBefore(this) !== false) {\n          renderMap.set(reference2, \
this.renderId);\n        }\n      }\n    } else if (updateType === \
NodeUpdateType.OBJECT) {\n      node.updateBefore(this);\n    }\n  }\n  \
updateAfterNode(node) {\n    const updateType = node.getUpdateAfterType();\n  \
  const reference2 = node.updateReference(this);\n    if (updateType === \
NodeUpdateType.FRAME) {\n      const { frameMap } = \
this._getMaps(this.updateAfterMap, reference2);\n      if \
(frameMap.get(reference2) !== this.frameId) {\n        if \
(node.updateAfter(this) !== false) {\n          frameMap.set(reference2, \
this.frameId);\n        }\n      }\n    } else if (updateType === \
NodeUpdateType.RENDER) {\n      const { renderMap } = \
this._getMaps(this.updateAfterMap, reference2);\n      if \
(renderMap.get(reference2) !== this.renderId) {\n        if \
(node.updateAfter(this) !== false) {\n          renderMap.set(reference2, \
this.renderId);\n        }\n      }\n    } else if (updateType === \
NodeUpdateType.OBJECT) {\n      node.updateAfter(this);\n    }\n  }\n  \
updateNode(node) {\n    const updateType = node.getUpdateType();\n    const \
reference2 = node.updateReference(this);\n    if (updateType === \
NodeUpdateType.FRAME) {\n      const { frameMap } = \
this._getMaps(this.updateMap, reference2);\n      if \
(frameMap.get(reference2) !== this.frameId) {\n        if (node.update(this) \
!== false) {\n          frameMap.set(reference2, this.frameId);\n        }\n  \
    }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const { \
renderMap } = this._getMaps(this.updateMap, reference2);\n      if \
(renderMap.get(reference2) !== this.renderId) {\n        if \
(node.update(this) !== false) {\n          renderMap.set(reference2, \
this.renderId);\n        }\n      }\n    } else if (updateType === \
NodeUpdateType.OBJECT) {\n      node.update(this);\n    }\n  }\n  update() \
{\n    this.frameId++;\n    if (this.lastTime === void 0) this.lastTime = \
performance.now();\n    this.deltaTime = (performance.now() - this.lastTime) \
/ 1e3;\n    this.lastTime = performance.now();\n    this.time += \
this.deltaTime;\n  }\n};\nvar NodeFunctionInput = class {\n  \
constructor(type, name, count = null, qualifier = \"\", isConst = false) {\n  \
  this.type = type;\n    this.name = name;\n    this.count = count;\n    \
this.qualifier = qualifier;\n    this.isConst = isConst;\n  \
}\n};\nNodeFunctionInput.isNodeFunctionInput = true;\nvar \
DirectionalLightNode = class extends AnalyticLightNode {\n  static get type() \
{\n    return \"DirectionalLightNode\";\n  }\n  constructor(light = null) {\n \
   super(light);\n  }\n  setup(builder) {\n    super.setup(builder);\n    \
const lightingModel = builder.context.lightingModel;\n    const lightColor = \
this.colorNode;\n    const lightDirection = \
lightTargetDirection(this.light);\n    const reflectedLight = \
builder.context.reflectedLight;\n    lightingModel.direct({\n      \
lightDirection,\n      lightColor,\n      reflectedLight\n    }, \
builder.stack, builder);\n  }\n};\nvar _matrix41 = /* @__PURE__ */ new \
Matrix42();\nvar _matrix42 = /* @__PURE__ */ new Matrix42();\nvar ltcLib = \
null;\nvar RectAreaLightNode = class extends AnalyticLightNode {\n  static \
get type() {\n    return \"RectAreaLightNode\";\n  }\n  constructor(light = \
null) {\n    super(light);\n    this.halfHeight = uniform(new \
Vector32()).setGroup(renderGroup);\n    this.halfWidth = uniform(new \
Vector32()).setGroup(renderGroup);\n    this.updateType = \
NodeUpdateType.RENDER;\n  }\n  update(frame2) {\n    super.update(frame2);\n  \
  const { light } = this;\n    const viewMatrix = \
frame2.camera.matrixWorldInverse;\n    _matrix42.identity();\n    \
_matrix41.copy(light.matrixWorld);\n    _matrix41.premultiply(viewMatrix);\n  \
  _matrix42.extractRotation(_matrix41);\n    \
this.halfWidth.value.set(light.width * 0.5, 0, 0);\n    \
this.halfHeight.value.set(0, light.height * 0.5, 0);\n    \
this.halfWidth.value.applyMatrix4(_matrix42);\n    \
this.halfHeight.value.applyMatrix4(_matrix42);\n  }\n  setup(builder) {\n    \
super.setup(builder);\n    let ltc_1, ltc_2;\n    if \
(builder.isAvailable(\"float32Filterable\")) {\n      ltc_1 = \
texture(ltcLib.LTC_FLOAT_1);\n      ltc_2 = texture(ltcLib.LTC_FLOAT_2);\n    \
} else {\n      ltc_1 = texture(ltcLib.LTC_HALF_1);\n      ltc_2 = \
texture(ltcLib.LTC_HALF_2);\n    }\n    const { colorNode, light } = this;\n  \
  const lightingModel = builder.context.lightingModel;\n    const \
lightPosition2 = lightViewPosition(light);\n    const reflectedLight = \
builder.context.reflectedLight;\n    lightingModel.directRectArea({\n      \
lightColor: colorNode,\n      lightPosition: lightPosition2,\n      \
halfWidth: this.halfWidth,\n      halfHeight: this.halfHeight,\n      \
reflectedLight,\n      ltc_1,\n      ltc_2\n    }, builder.stack, builder);\n \
 }\n  static setLTC(ltc) {\n    ltcLib = ltc;\n  }\n};\nvar SpotLightNode = \
class extends AnalyticLightNode {\n  static get type() {\n    return \
\"SpotLightNode\";\n  }\n  constructor(light = null) {\n    super(light);\n   \
 this.coneCosNode = uniform(0).setGroup(renderGroup);\n    \
this.penumbraCosNode = uniform(0).setGroup(renderGroup);\n    \
this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);\n    \
this.decayExponentNode = uniform(0).setGroup(renderGroup);\n  }\n  \
update(frame2) {\n    super.update(frame2);\n    const { light } = this;\n    \
this.coneCosNode.value = Math.cos(light.angle);\n    \
this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));\n  \
  this.cutoffDistanceNode.value = light.distance;\n    \
this.decayExponentNode.value = light.decay;\n  }\n  \
getSpotAttenuation(angleCosine) {\n    const { coneCosNode, penumbraCosNode } \
= this;\n    return smoothstep2(coneCosNode, penumbraCosNode, angleCosine);\n \
 }\n  setup(builder) {\n    super.setup(builder);\n    const lightingModel = \
builder.context.lightingModel;\n    const { colorNode, cutoffDistanceNode, \
decayExponentNode, light } = this;\n    const lVector = \
lightViewPosition(light).sub(positionView);\n    const lightDirection = \
lVector.normalize();\n    const angleCos = \
lightDirection.dot(lightTargetDirection(light));\n    const spotAttenuation = \
this.getSpotAttenuation(angleCos);\n    const lightDistance = \
lVector.length();\n    const lightAttenuation = getDistanceAttenuation({\n    \
  lightDistance,\n      cutoffDistance: cutoffDistanceNode,\n      \
decayExponent: decayExponentNode\n    });\n    const lightColor = \
colorNode.mul(spotAttenuation).mul(lightAttenuation);\n    const \
reflectedLight = builder.context.reflectedLight;\n    \
lightingModel.direct({\n      lightDirection,\n      lightColor,\n      \
reflectedLight\n    }, builder.stack, builder);\n  }\n};\nvar \
IESSpotLightNode = class extends SpotLightNode {\n  static get type() {\n    \
return \"IESSpotLightNode\";\n  }\n  getSpotAttenuation(angleCosine) {\n    \
const iesMap = this.light.iesMap;\n    let spotAttenuation = null;\n    if \
(iesMap && iesMap.isTexture === true) {\n      const angle = \
angleCosine.acos().mul(1 / Math.PI);\n      spotAttenuation = texture(iesMap, \
vec2(angle, 0), 0).r;\n    } else {\n      spotAttenuation = \
super.getSpotAttenuation(angleCosine);\n    }\n    return spotAttenuation;\n  \
}\n};\nvar AmbientLightNode = class extends AnalyticLightNode {\n  static get \
type() {\n    return \"AmbientLightNode\";\n  }\n  constructor(light = null) \
{\n    super(light);\n  }\n  setup({ context: context2 }) {\n    \
context2.irradiance.addAssign(this.colorNode);\n  }\n};\nvar \
HemisphereLightNode = class extends AnalyticLightNode {\n  static get type() \
{\n    return \"HemisphereLightNode\";\n  }\n  constructor(light = null) {\n  \
  super(light);\n    this.lightPositionNode = lightPosition(light);\n    \
this.lightDirectionNode = this.lightPositionNode.normalize();\n    \
this.groundColorNode = uniform(new Color2()).setGroup(renderGroup);\n  }\n  \
update(frame2) {\n    const { light } = this;\n    super.update(frame2);\n    \
this.lightPositionNode.object3d = light;\n    \
this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.inten\
sity);\n  }\n  setup(builder) {\n    const { colorNode, groundColorNode, \
lightDirectionNode } = this;\n    const dotNL = \
normalView.dot(lightDirectionNode);\n    const hemiDiffuseWeight = \
dotNL.mul(0.5).add(0.5);\n    const irradiance = mix(groundColorNode, \
colorNode, hemiDiffuseWeight);\n    \
builder.context.irradiance.addAssign(irradiance);\n  }\n};\nvar \
LightProbeNode = class extends AnalyticLightNode {\n  static get type() {\n   \
 return \"LightProbeNode\";\n  }\n  constructor(light = null) {\n    \
super(light);\n    const array = [];\n    for (let i = 0; i < 9; i++) \
array.push(new Vector32());\n    this.lightProbe = uniformArray(array);\n  \
}\n  update(frame2) {\n    const { light } = this;\n    \
super.update(frame2);\n    for (let i = 0; i < 9; i++) {\n      \
this.lightProbe.array[i].copy(light.sh.coefficients[i]).multiplyScalar(light.\
intensity);\n    }\n  }\n  setup(builder) {\n    const irradiance = \
getShIrradianceAt(normalWorld, this.lightProbe);\n    \
builder.context.irradiance.addAssign(irradiance);\n  }\n};\nvar NodeParser = \
class {\n  parseFunction() {\n    console.warn(\"Abstract function.\");\n  \
}\n};\nvar NodeFunction = class {\n  constructor(type, inputs, name = \"\", \
precision = \"\") {\n    this.type = type;\n    this.inputs = inputs;\n    \
this.name = name;\n    this.precision = precision;\n  }\n  getCode() {\n    \
console.warn(\"Abstract function.\");\n  }\n};\nNodeFunction.isNodeFunction = \
true;\nvar declarationRegexp$1 = \
/^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*\
?)\\)/i;\nvar propertiesRegexp$1 = /[a-z_0-9]+/ig;\nvar pragmaMain = \
\"#pragma main\";\nvar parse$1 = (source) => {\n  source = source.trim();\n  \
const pragmaMainIndex = source.indexOf(pragmaMain);\n  const mainCode = \
pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : \
source;\n  const declaration = mainCode.match(declarationRegexp$1);\n  if \
(declaration !== null && declaration.length === 5) {\n    const inputsCode = \
declaration[4];\n    const propsMatches = [];\n    let nameMatch = null;\n    \
while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) {\n      \
propsMatches.push(nameMatch);\n    }\n    const inputs = [];\n    let i = \
0;\n    while (i < propsMatches.length) {\n      const isConst = \
propsMatches[i][0] === \"const\";\n      if (isConst === true) {\n        \
i++;\n      }\n      let qualifier = propsMatches[i][0];\n      if (qualifier \
=== \"in\" || qualifier === \"out\" || qualifier === \"inout\") {\n        \
i++;\n      } else {\n        qualifier = \"\";\n      }\n      const type2 = \
propsMatches[i++][0];\n      let count = \
Number.parseInt(propsMatches[i][0]);\n      if (Number.isNaN(count) === \
false) i++;\n      else count = null;\n      const name2 = \
propsMatches[i++][0];\n      inputs.push(new NodeFunctionInput(type2, name2, \
count, qualifier, isConst));\n    }\n    const blockCode = \
mainCode.substring(declaration[0].length);\n    const name = declaration[3] \
!== void 0 ? declaration[3] : \"\";\n    const type = declaration[2];\n    \
const precision = declaration[1] !== void 0 ? declaration[1] : \"\";\n    \
const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) \
: \"\";\n    return {\n      type,\n      inputs,\n      name,\n      \
precision,\n      inputsCode,\n      blockCode,\n      headerCode\n    };\n  \
} else {\n    throw new Error(\"FunctionNode: Function is not a GLSL \
code.\");\n  }\n};\nvar GLSLNodeFunction = class extends NodeFunction {\n  \
constructor(source) {\n    const { type, inputs, name, precision, inputsCode, \
blockCode, headerCode } = parse$1(source);\n    super(type, inputs, name, \
precision);\n    this.inputsCode = inputsCode;\n    this.blockCode = \
blockCode;\n    this.headerCode = headerCode;\n  }\n  getCode(name = \
this.name) {\n    let code;\n    const blockCode = this.blockCode;\n    if \
(blockCode !== \"\") {\n      const { type, inputsCode, headerCode, precision \
} = this;\n      let declarationCode = `${type} ${name} ( \
${inputsCode.trim()} )`;\n      if (precision !== \"\") {\n        \
declarationCode = `${precision} ${declarationCode}`;\n      }\n      code = \
headerCode + declarationCode + blockCode;\n    } else {\n      code = \"\";\n \
   }\n    return code;\n  }\n};\nvar GLSLNodeParser = class extends \
NodeParser {\n  parseFunction(source) {\n    return new \
GLSLNodeFunction(source);\n  }\n};\nvar outputNodeMap = /* @__PURE__ */ new \
WeakMap();\nvar Nodes = class extends DataMap {\n  constructor(renderer3, \
backend) {\n    super();\n    this.renderer = renderer3;\n    this.backend = \
backend;\n    this.nodeFrame = new NodeFrame();\n    this.nodeBuilderCache = \
/* @__PURE__ */ new Map();\n    this.callHashCache = new ChainMap();\n    \
this.groupsData = new ChainMap();\n  }\n  updateGroup(nodeUniformsGroup) {\n  \
  const groupNode = nodeUniformsGroup.groupNode;\n    const name = \
groupNode.name;\n    if (name === objectGroup.name) return true;\n    if \
(name === renderGroup.name) {\n      const uniformsGroupData = \
this.get(nodeUniformsGroup);\n      const renderId = \
this.nodeFrame.renderId;\n      if (uniformsGroupData.renderId !== renderId) \
{\n        uniformsGroupData.renderId = renderId;\n        return true;\n     \
 }\n      return false;\n    }\n    if (name === frameGroup.name) {\n      \
const uniformsGroupData = this.get(nodeUniformsGroup);\n      const frameId = \
this.nodeFrame.frameId;\n      if (uniformsGroupData.frameId !== frameId) {\n \
       uniformsGroupData.frameId = frameId;\n        return true;\n      }\n  \
    return false;\n    }\n    const groupChain = [groupNode, \
nodeUniformsGroup];\n    let groupData = this.groupsData.get(groupChain);\n   \
 if (groupData === void 0) this.groupsData.set(groupChain, groupData = {});\n \
   if (groupData.version !== groupNode.version) {\n      groupData.version = \
groupNode.version;\n      return true;\n    }\n    return false;\n  }\n  \
getForRenderCacheKey(renderObject) {\n    return \
renderObject.initialCacheKey;\n  }\n  getForRender(renderObject) {\n    const \
renderObjectData = this.get(renderObject);\n    let nodeBuilderState = \
renderObjectData.nodeBuilderState;\n    if (nodeBuilderState === void 0) {\n  \
    const { nodeBuilderCache } = this;\n      const cacheKey = \
this.getForRenderCacheKey(renderObject);\n      nodeBuilderState = \
nodeBuilderCache.get(cacheKey);\n      if (nodeBuilderState === void 0) {\n   \
     const nodeBuilder = this.backend.createNodeBuilder(renderObject.object, \
this.renderer);\n        nodeBuilder.scene = renderObject.scene;\n        \
nodeBuilder.material = renderObject.material;\n        nodeBuilder.camera = \
renderObject.camera;\n        nodeBuilder.context.material = \
renderObject.material;\n        nodeBuilder.lightsNode = \
renderObject.lightsNode;\n        nodeBuilder.environmentNode = \
this.getEnvironmentNode(renderObject.scene);\n        nodeBuilder.fogNode = \
this.getFogNode(renderObject.scene);\n        nodeBuilder.clippingContext = \
renderObject.clippingContext;\n        nodeBuilder.build();\n        \
nodeBuilderState = this._createNodeBuilderState(nodeBuilder);\n        \
nodeBuilderCache.set(cacheKey, nodeBuilderState);\n      }\n      \
nodeBuilderState.usedTimes++;\n      renderObjectData.nodeBuilderState = \
nodeBuilderState;\n    }\n    return nodeBuilderState;\n  }\n  delete(object) \
{\n    if (object.isRenderObject) {\n      const nodeBuilderState = \
this.get(object).nodeBuilderState;\n      nodeBuilderState.usedTimes--;\n     \
 if (nodeBuilderState.usedTimes === 0) {\n        \
this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));\n      }\n   \
 }\n    return super.delete(object);\n  }\n  getForCompute(computeNode) {\n   \
 const computeData = this.get(computeNode);\n    let nodeBuilderState = \
computeData.nodeBuilderState;\n    if (nodeBuilderState === void 0) {\n      \
const nodeBuilder = this.backend.createNodeBuilder(computeNode, \
this.renderer);\n      nodeBuilder.build();\n      nodeBuilderState = \
this._createNodeBuilderState(nodeBuilder);\n      \
computeData.nodeBuilderState = nodeBuilderState;\n    }\n    return \
nodeBuilderState;\n  }\n  _createNodeBuilderState(nodeBuilder) {\n    return \
new NodeBuilderState(\n      nodeBuilder.vertexShader,\n      \
nodeBuilder.fragmentShader,\n      nodeBuilder.computeShader,\n      \
nodeBuilder.getAttributesArray(),\n      nodeBuilder.getBindings(),\n      \
nodeBuilder.updateNodes,\n      nodeBuilder.updateBeforeNodes,\n      \
nodeBuilder.updateAfterNodes,\n      nodeBuilder.monitor,\n      \
nodeBuilder.transforms\n    );\n  }\n  getEnvironmentNode(scene3) {\n    \
return scene3.environmentNode || this.get(scene3).environmentNode || null;\n  \
}\n  getBackgroundNode(scene3) {\n    return scene3.backgroundNode || \
this.get(scene3).backgroundNode || null;\n  }\n  getFogNode(scene3) {\n    \
return scene3.fogNode || this.get(scene3).fogNode || null;\n  }\n  \
getCacheKey(scene3, lightsNode) {\n    const chain = [scene3, lightsNode];\n  \
  const callId = this.renderer.info.calls;\n    let cacheKeyData = \
this.callHashCache.get(chain);\n    if (cacheKeyData === void 0 || \
cacheKeyData.callId !== callId) {\n      const environmentNode = \
this.getEnvironmentNode(scene3);\n      const fogNode = \
this.getFogNode(scene3);\n      const values = [];\n      if (lightsNode) \
values.push(lightsNode.getCacheKey(true));\n      if (environmentNode) \
values.push(environmentNode.getCacheKey());\n      if (fogNode) \
values.push(fogNode.getCacheKey());\n      \
values.push(this.renderer.shadowMap.enabled ? 1 : 0);\n      cacheKeyData = \
{\n        callId,\n        cacheKey: hashArray(values)\n      };\n      \
this.callHashCache.set(chain, cacheKeyData);\n    }\n    return \
cacheKeyData.cacheKey;\n  }\n  updateScene(scene3) {\n    \
this.updateEnvironment(scene3);\n    this.updateFog(scene3);\n    \
this.updateBackground(scene3);\n  }\n  get isToneMappingState() {\n    return \
this.renderer.getRenderTarget() ? false : true;\n  }\n  \
updateBackground(scene3) {\n    const sceneData = this.get(scene3);\n    \
const background = scene3.background;\n    if (background) {\n      const \
forceUpdate = scene3.backgroundBlurriness === 0 && \
sceneData.backgroundBlurriness > 0 || scene3.backgroundBlurriness > 0 && \
sceneData.backgroundBlurriness === 0;\n      if (sceneData.background !== \
background || forceUpdate) {\n        let backgroundNode = null;\n        if \
(background.isCubeTexture === true || (background.mapping === \
EquirectangularReflectionMapping2 || background.mapping === \
EquirectangularRefractionMapping2 || background.mapping === \
CubeUVReflectionMapping2)) {\n          if (scene3.backgroundBlurriness > 0 \
|| background.mapping === CubeUVReflectionMapping2) {\n            \
backgroundNode = pmremTexture(background);\n          } else {\n            \
let envMap;\n            if (background.isCubeTexture === true) {\n           \
   envMap = cubeTexture(background);\n            } else {\n              \
envMap = texture(background);\n            }\n            backgroundNode = \
cubeMapNode(envMap);\n          }\n        } else if (background.isTexture \
=== true) {\n          backgroundNode = texture(background, \
screenUV.flipY()).setUpdateMatrix(true);\n        } else if \
(background.isColor !== true) {\n          console.error(\"WebGPUNodes: \
Unsupported background configuration.\", background);\n        }\n        \
sceneData.backgroundNode = backgroundNode;\n        sceneData.background = \
background;\n        sceneData.backgroundBlurriness = \
scene3.backgroundBlurriness;\n      }\n    } else if \
(sceneData.backgroundNode) {\n      delete sceneData.backgroundNode;\n      \
delete sceneData.background;\n    }\n  }\n  updateFog(scene3) {\n    const \
sceneData = this.get(scene3);\n    const fog = scene3.fog;\n    if (fog) {\n  \
    if (sceneData.fog !== fog) {\n        let fogNode = null;\n        if \
(fog.isFogExp2) {\n          const color2 = reference(\"color\", \"color\", \
fog).setGroup(renderGroup);\n          const density = reference(\"density\", \
\"float\", fog).setGroup(renderGroup);\n          fogNode = \
densityFog(color2, density);\n        } else if (fog.isFog) {\n          \
const color2 = reference(\"color\", \"color\", fog).setGroup(renderGroup);\n  \
        const near = reference(\"near\", \"float\", \
fog).setGroup(renderGroup);\n          const far = reference(\"far\", \
\"float\", fog).setGroup(renderGroup);\n          fogNode = rangeFog(color2, \
near, far);\n        } else {\n          console.error(\"WebGPUNodes: \
Unsupported fog configuration.\", fog);\n        }\n        sceneData.fogNode \
= fogNode;\n        sceneData.fog = fog;\n      }\n    } else {\n      delete \
sceneData.fogNode;\n      delete sceneData.fog;\n    }\n  }\n  \
updateEnvironment(scene3) {\n    const sceneData = this.get(scene3);\n    \
const environment = scene3.environment;\n    if (environment) {\n      if \
(sceneData.environment !== environment) {\n        let environmentNode = \
null;\n        if (environment.isCubeTexture === true) {\n          \
environmentNode = cubeTexture(environment);\n        } else if \
(environment.isTexture === true) {\n          environmentNode = \
texture(environment);\n        } else {\n          console.error(\"Nodes: \
Unsupported environment configuration.\", environment);\n        }\n        \
sceneData.environmentNode = environmentNode;\n        sceneData.environment = \
environment;\n      }\n    } else if (sceneData.environmentNode) {\n      \
delete sceneData.environmentNode;\n      delete sceneData.environment;\n    \
}\n  }\n  getNodeFrame(renderer3 = this.renderer, scene3 = null, object = \
null, camera3 = null, material = null) {\n    const nodeFrame = \
this.nodeFrame;\n    nodeFrame.renderer = renderer3;\n    nodeFrame.scene = \
scene3;\n    nodeFrame.object = object;\n    nodeFrame.camera = camera3;\n    \
nodeFrame.material = material;\n    return nodeFrame;\n  }\n  \
getNodeFrameForRender(renderObject) {\n    return \
this.getNodeFrame(renderObject.renderer, renderObject.scene, \
renderObject.object, renderObject.camera, renderObject.material);\n  }\n  \
getOutputCacheKey() {\n    const renderer3 = this.renderer;\n    return \
renderer3.toneMapping + \",\" + renderer3.currentColorSpace;\n  }\n  \
hasOutputChange(outputTarget) {\n    const cacheKey = \
outputNodeMap.get(outputTarget);\n    return cacheKey !== \
this.getOutputCacheKey();\n  }\n  getOutputNode(outputTexture) {\n    const \
renderer3 = this.renderer;\n    const cacheKey = this.getOutputCacheKey();\n  \
  const output2 = texture(outputTexture, \
screenUV).renderOutput(renderer3.toneMapping, renderer3.currentColorSpace);\n \
   outputNodeMap.set(outputTexture, cacheKey);\n    return output2;\n  }\n  \
updateBefore(renderObject) {\n    const nodeBuilder = \
renderObject.getNodeBuilderState();\n    for (const node of \
nodeBuilder.updateBeforeNodes) {\n      \
this.getNodeFrameForRender(renderObject).updateBeforeNode(node);\n    }\n  \
}\n  updateAfter(renderObject) {\n    const nodeBuilder = \
renderObject.getNodeBuilderState();\n    for (const node of \
nodeBuilder.updateAfterNodes) {\n      \
this.getNodeFrameForRender(renderObject).updateAfterNode(node);\n    }\n  }\n \
 updateForCompute(computeNode) {\n    const nodeFrame = \
this.getNodeFrame();\n    const nodeBuilder = \
this.getForCompute(computeNode);\n    for (const node of \
nodeBuilder.updateNodes) {\n      nodeFrame.updateNode(node);\n    }\n  }\n  \
updateForRender(renderObject) {\n    const nodeFrame = \
this.getNodeFrameForRender(renderObject);\n    const nodeBuilder = \
renderObject.getNodeBuilderState();\n    for (const node of \
nodeBuilder.updateNodes) {\n      nodeFrame.updateNode(node);\n    }\n  }\n  \
needsRefresh(renderObject) {\n    const nodeFrame = \
this.getNodeFrameForRender(renderObject);\n    const monitor = \
renderObject.getMonitor();\n    return monitor.needsRefresh(renderObject, \
nodeFrame);\n  }\n  dispose() {\n    super.dispose();\n    this.nodeFrame = \
new NodeFrame();\n    this.nodeBuilderCache = /* @__PURE__ */ new Map();\n  \
}\n};\nvar RenderBundle = class {\n  constructor(scene3, camera3) {\n    \
this.scene = scene3;\n    this.camera = camera3;\n  }\n  clone() {\n    \
return Object.assign(new this.constructor(), this);\n  }\n};\nvar \
RenderBundles = class {\n  constructor() {\n    this.lists = new \
ChainMap();\n  }\n  get(scene3, camera3) {\n    const lists = this.lists;\n   \
 const keys = [scene3, camera3];\n    let list = lists.get(keys);\n    if \
(list === void 0) {\n      list = new RenderBundle(scene3, camera3);\n      \
lists.set(keys, list);\n    }\n    return list;\n  }\n  dispose() {\n    \
this.lists = new ChainMap();\n  }\n};\nvar NodeLibrary = class {\n  \
constructor() {\n    this.lightNodes = /* @__PURE__ */ new WeakMap();\n    \
this.materialNodes = /* @__PURE__ */ new Map();\n    this.toneMappingNodes = \
/* @__PURE__ */ new Map();\n  }\n  fromMaterial(material) {\n    if \
(material.isNodeMaterial) return material;\n    let nodeMaterial = null;\n    \
const nodeMaterialClass = this.getMaterialNodeClass(material.type);\n    if \
(nodeMaterialClass !== null) {\n      nodeMaterial = new \
nodeMaterialClass();\n      for (const key in material) {\n        \
nodeMaterial[key] = material[key];\n      }\n    }\n    return \
nodeMaterial;\n  }\n  addToneMapping(toneMappingNode, toneMapping2) {\n    \
this.addType(toneMappingNode, toneMapping2, this.toneMappingNodes);\n  }\n  \
getToneMappingFunction(toneMapping2) {\n    return \
this.toneMappingNodes.get(toneMapping2) || null;\n  }\n  \
getMaterialNodeClass(materialType) {\n    return \
this.materialNodes.get(materialType) || null;\n  }\n  \
addMaterial(materialNodeClass, materialClass) {\n    \
this.addType(materialNodeClass, materialClass.type, this.materialNodes);\n  \
}\n  getLightNodeClass(light) {\n    return this.lightNodes.get(light) || \
null;\n  }\n  addLight(lightNodeClass, lightClass) {\n    \
this.addClass(lightNodeClass, lightClass, this.lightNodes);\n  }\n  \
addType(nodeClass, type, library) {\n    if (library.has(type)) {\n      \
console.warn(`Redefinition of node ${type}`);\n      return;\n    }\n    if \
(typeof nodeClass !== \"function\") throw new Error(`Node class \
${nodeClass.name} is not a class.`);\n    if (typeof type === \"function\" || \
typeof type === \"object\") throw new Error(`Base class ${type} is not a \
class.`);\n    library.set(type, nodeClass);\n  }\n  addClass(nodeClass, \
baseClass, library) {\n    if (library.has(baseClass)) {\n      \
console.warn(`Redefinition of node ${baseClass.name}`);\n      return;\n    \
}\n    if (typeof nodeClass !== \"function\") throw new Error(`Node class \
${nodeClass.name} is not a class.`);\n    if (typeof baseClass !== \
\"function\") throw new Error(`Base class ${baseClass.name} is not a \
class.`);\n    library.set(baseClass, nodeClass);\n  }\n};\nvar \
_defaultLights = /* @__PURE__ */ new LightsNode();\nvar Lighting = class \
extends ChainMap {\n  constructor() {\n    super();\n  }\n  createNode(lights \
= []) {\n    return new LightsNode().setLights(lights);\n  }\n  \
getNode(scene3, camera3) {\n    if (scene3.isQuadMesh) return \
_defaultLights;\n    const keys = [scene3, camera3];\n    let node = \
this.get(keys);\n    if (node === void 0) {\n      node = \
this.createNode();\n      this.set(keys, node);\n    }\n    return node;\n  \
}\n};\nvar _scene = /* @__PURE__ */ new Scene2();\nvar _drawingBufferSize = \
/* @__PURE__ */ new Vector22();\nvar _screen = /* @__PURE__ */ new \
Vector42();\nvar _frustum = /* @__PURE__ */ new Frustum2();\nvar \
_projScreenMatrix = /* @__PURE__ */ new Matrix42();\nvar _vector4 = /* \
@__PURE__ */ new Vector42();\nvar Renderer = class {\n  constructor(backend, \
parameters = {}) {\n    this.isRenderer = true;\n    const {\n      \
logarithmicDepthBuffer = false,\n      alpha = true,\n      depth: depth2 = \
true,\n      stencil = false,\n      antialias = false,\n      samples = 0,\n \
     getFallback = null\n    } = parameters;\n    this.domElement = \
backend.getDomElement();\n    this.backend = backend;\n    this.samples = \
samples || antialias === true ? 4 : 0;\n    this.autoClear = true;\n    \
this.autoClearColor = true;\n    this.autoClearDepth = true;\n    \
this.autoClearStencil = true;\n    this.alpha = alpha;\n    \
this.logarithmicDepthBuffer = logarithmicDepthBuffer;\n    \
this.outputColorSpace = SRGBColorSpace2;\n    this.toneMapping = \
NoToneMapping2;\n    this.toneMappingExposure = 1;\n    this.sortObjects = \
true;\n    this.depth = depth2;\n    this.stencil = stencil;\n    \
this.clippingPlanes = [];\n    this.info = new Info();\n    this.nodes = {\n  \
    modelViewMatrix: null,\n      modelNormalViewMatrix: null\n    };\n    \
this.library = new NodeLibrary();\n    this.lighting = new Lighting();\n    \
this._getFallback = getFallback;\n    this._pixelRatio = 1;\n    this._width \
= this.domElement.width;\n    this._height = this.domElement.height;\n    \
this._viewport = new Vector42(0, 0, this._width, this._height);\n    \
this._scissor = new Vector42(0, 0, this._width, this._height);\n    \
this._scissorTest = false;\n    this._attributes = null;\n    \
this._geometries = null;\n    this._nodes = null;\n    this._animation = \
null;\n    this._bindings = null;\n    this._objects = null;\n    \
this._pipelines = null;\n    this._bundles = null;\n    this._renderLists = \
null;\n    this._renderContexts = null;\n    this._textures = null;\n    \
this._background = null;\n    this._quad = new QuadMesh(new \
NodeMaterial());\n    this._quad.material.type = \"Renderer_output\";\n    \
this._currentRenderContext = null;\n    this._opaqueSort = null;\n    \
this._transparentSort = null;\n    this._frameBufferTarget = null;\n    const \
alphaClear = this.alpha === true ? 0 : 1;\n    this._clearColor = new \
Color4(0, 0, 0, alphaClear);\n    this._clearDepth = 1;\n    \
this._clearStencil = 0;\n    this._renderTarget = null;\n    \
this._activeCubeFace = 0;\n    this._activeMipmapLevel = 0;\n    this._mrt = \
null;\n    this._renderObjectFunction = null;\n    \
this._currentRenderObjectFunction = null;\n    this._currentRenderBundle = \
null;\n    this._handleObjectFunction = this._renderObjectDirect;\n    \
this._isDeviceLost = false;\n    this.onDeviceLost = this._onDeviceLost;\n    \
this._initialized = false;\n    this._initPromise = null;\n    \
this._compilationPromises = null;\n    this.transparent = true;\n    \
this.opaque = true;\n    this.shadowMap = {\n      enabled: false,\n      \
type: PCFShadowMap$1\n    };\n    this.xr = {\n      enabled: false\n    };\n \
   this.debug = {\n      checkShaderErrors: true,\n      onShaderError: \
null,\n      getShaderAsync: async (scene3, camera3, object) => {\n        \
await this.compileAsync(scene3, camera3);\n        const renderList = \
this._renderLists.get(scene3, camera3);\n        const renderContext = \
this._renderContexts.get(scene3, camera3, this._renderTarget);\n        const \
material = scene3.overrideMaterial || object.material;\n        const \
renderObject = this._objects.get(object, material, scene3, camera3, \
renderList.lightsNode, renderContext);\n        const { fragmentShader, \
vertexShader } = renderObject.getNodeBuilderState();\n        return { \
fragmentShader, vertexShader };\n      }\n    };\n  }\n  async init() {\n    \
if (this._initialized) {\n      throw new Error(\"Renderer: Backend has \
already been initialized.\");\n    }\n    if (this._initPromise !== null) {\n \
     return this._initPromise;\n    }\n    this._initPromise = new \
Promise(async (resolve, reject) => {\n      let backend = this.backend;\n     \
 try {\n        await backend.init(this);\n      } catch (error) {\n        \
if (this._getFallback !== null) {\n          try {\n            this.backend \
= backend = this._getFallback(error);\n            await \
backend.init(this);\n          } catch (error2) {\n            \
reject(error2);\n            return;\n          }\n        } else {\n         \
 reject(error);\n          return;\n        }\n      }\n      this._nodes = \
new Nodes(this, backend);\n      this._animation = new Animation(this._nodes, \
this.info);\n      this._attributes = new Attributes(backend);\n      \
this._background = new Background(this, this._nodes);\n      this._geometries \
= new Geometries(this._attributes, this.info);\n      this._textures = new \
Textures(this, backend, this.info);\n      this._pipelines = new \
Pipelines(backend, this._nodes);\n      this._bindings = new \
Bindings(backend, this._nodes, this._textures, this._attributes, \
this._pipelines, this.info);\n      this._objects = new RenderObjects(this, \
this._nodes, this._geometries, this._pipelines, this._bindings, this.info);\n \
     this._renderLists = new RenderLists(this.lighting);\n      this._bundles \
= new RenderBundles();\n      this._renderContexts = new RenderContexts();\n  \
    this._initialized = true;\n      resolve();\n    });\n    return \
this._initPromise;\n  }\n  get coordinateSystem() {\n    return \
this.backend.coordinateSystem;\n  }\n  async compileAsync(scene3, camera3, \
targetScene = null) {\n    if (this._isDeviceLost === true) return;\n    if \
(this._initialized === false) await this.init();\n    const nodeFrame = \
this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n    \
const previousRenderContext = this._currentRenderContext;\n    const \
previousRenderObjectFunction = this._currentRenderObjectFunction;\n    const \
previousCompilationPromises = this._compilationPromises;\n    const sceneRef \
= scene3.isScene === true ? scene3 : _scene;\n    if (targetScene === null) \
targetScene = scene3;\n    const renderTarget = this._renderTarget;\n    \
const renderContext = this._renderContexts.get(targetScene, camera3, \
renderTarget);\n    const activeMipmapLevel = this._activeMipmapLevel;\n    \
const compilationPromises = [];\n    this._currentRenderContext = \
renderContext;\n    this._currentRenderObjectFunction = this.renderObject;\n  \
  this._handleObjectFunction = this._createObjectPipeline;\n    \
this._compilationPromises = compilationPromises;\n    nodeFrame.renderId++;\n \
   nodeFrame.update();\n    renderContext.depth = this.depth;\n    \
renderContext.stencil = this.stencil;\n    if \
(!renderContext.clippingContext) renderContext.clippingContext = new \
ClippingContext();\n    renderContext.clippingContext.updateGlobal(this, \
camera3);\n    sceneRef.onBeforeRender(this, scene3, camera3, \
renderTarget);\n    const renderList = this._renderLists.get(scene3, \
camera3);\n    renderList.begin();\n    this._projectObject(scene3, camera3, \
0, renderList);\n    if (targetScene !== scene3) {\n      \
targetScene.traverseVisible(function(object) {\n        if (object.isLight && \
object.layers.test(camera3.layers)) {\n          \
renderList.pushLight(object);\n        }\n      });\n    }\n    \
renderList.finish();\n    if (renderTarget !== null) {\n      \
this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);\n      \
const renderTargetData = this._textures.get(renderTarget);\n      \
renderContext.textures = renderTargetData.textures;\n      \
renderContext.depthTexture = renderTargetData.depthTexture;\n    } else {\n   \
   renderContext.textures = null;\n      renderContext.depthTexture = null;\n \
   }\n    this._nodes.updateScene(sceneRef);\n    \
this._background.update(sceneRef, renderList, renderContext);\n    const \
opaqueObjects = renderList.opaque;\n    const transparentObjects = \
renderList.transparent;\n    const lightsNode = renderList.lightsNode;\n    \
if (this.opaque === true && opaqueObjects.length > 0) \
this._renderObjects(opaqueObjects, camera3, sceneRef, lightsNode);\n    if \
(this.transparent === true && transparentObjects.length > 0) \
this._renderTransparents(transparentObjects, camera3, sceneRef, \
lightsNode);\n    nodeFrame.renderId = previousRenderId;\n    \
this._currentRenderContext = previousRenderContext;\n    \
this._currentRenderObjectFunction = previousRenderObjectFunction;\n    \
this._compilationPromises = previousCompilationPromises;\n    \
this._handleObjectFunction = this._renderObjectDirect;\n    await \
Promise.all(compilationPromises);\n  }\n  async renderAsync(scene3, camera3) \
{\n    if (this._initialized === false) await this.init();\n    const \
renderContext = this._renderScene(scene3, camera3);\n    await \
this.backend.resolveTimestampAsync(renderContext, \"render\");\n  }\n  async \
waitForGPU() {\n    await this.backend.waitForGPU();\n  }\n  setMRT(mrt) {\n  \
  this._mrt = mrt;\n    return this;\n  }\n  getMRT() {\n    return \
this._mrt;\n  }\n  _onDeviceLost(info) {\n    let errorMessage = \
`THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: \
${info.message}`;\n    if (info.reason) {\n      errorMessage += `\nReason: \
${info.reason}`;\n    }\n    console.error(errorMessage);\n    \
this._isDeviceLost = true;\n  }\n  _renderBundle(bundle, sceneRef, \
lightsNode) {\n    const { bundleGroup, camera: camera3, renderList } = \
bundle;\n    const renderContext = this._currentRenderContext;\n    const \
renderBundle = this._bundles.get(bundleGroup, camera3);\n    const \
renderBundleData = this.backend.get(renderBundle);\n    if \
(renderBundleData.renderContexts === void 0) renderBundleData.renderContexts \
= /* @__PURE__ */ new Set();\n    const needsUpdate = bundleGroup.version !== \
renderBundleData.version;\n    const renderBundleNeedsUpdate = \
renderBundleData.renderContexts.has(renderContext) === false || \
needsUpdate;\n    renderBundleData.renderContexts.add(renderContext);\n    if \
(renderBundleNeedsUpdate) {\n      this.backend.beginBundle(renderContext);\n \
     if (renderBundleData.renderObjects === void 0 || needsUpdate) {\n        \
renderBundleData.renderObjects = [];\n      }\n      \
this._currentRenderBundle = renderBundle;\n      const opaqueObjects = \
renderList.opaque;\n      if (this.opaque === true && opaqueObjects.length > \
0) this._renderObjects(opaqueObjects, camera3, sceneRef, lightsNode);\n      \
this._currentRenderBundle = null;\n      \
this.backend.finishBundle(renderContext, renderBundle);\n      \
renderBundleData.version = bundleGroup.version;\n    } else {\n      const { \
renderObjects } = renderBundleData;\n      for (let i = 0, l = \
renderObjects.length; i < l; i++) {\n        const renderObject = \
renderObjects[i];\n        if (this._nodes.needsRefresh(renderObject)) {\n    \
      this._nodes.updateBefore(renderObject);\n          \
this._nodes.updateForRender(renderObject);\n          \
this._bindings.updateForRender(renderObject);\n          \
this._nodes.updateAfter(renderObject);\n        }\n      }\n    }\n    \
this.backend.addBundle(renderContext, renderBundle);\n  }\n  render(scene3, \
camera3) {\n    if (this._initialized === false) {\n      \
console.warn(\"THREE.Renderer: .render() called before the backend is \
initialized. Try using .renderAsync() instead.\");\n      return \
this.renderAsync(scene3, camera3);\n    }\n    this._renderScene(scene3, \
camera3);\n  }\n  _getFrameBufferTarget() {\n    const { currentToneMapping, \
currentColorSpace } = this;\n    const useToneMapping = currentToneMapping \
!== NoToneMapping2;\n    const useColorSpace = currentColorSpace !== \
LinearSRGBColorSpace2;\n    if (useToneMapping === false && useColorSpace === \
false) return null;\n    const { width, height } = \
this.getDrawingBufferSize(_drawingBufferSize);\n    const { depth: depth2, \
stencil } = this;\n    let frameBufferTarget = this._frameBufferTarget;\n    \
if (frameBufferTarget === null) {\n      frameBufferTarget = new \
RenderTarget2(width, height, {\n        depthBuffer: depth2,\n        \
stencilBuffer: stencil,\n        type: HalfFloatType2,\n        // \
FloatType\n        format: RGBAFormat2,\n        colorSpace: \
LinearSRGBColorSpace2,\n        generateMipmaps: false,\n        minFilter: \
LinearFilter2,\n        magFilter: LinearFilter2,\n        samples: \
this.samples\n      });\n      frameBufferTarget.isPostProcessingRenderTarget \
= true;\n      this._frameBufferTarget = frameBufferTarget;\n    }\n    \
frameBufferTarget.depthBuffer = depth2;\n    frameBufferTarget.stencilBuffer \
= stencil;\n    frameBufferTarget.setSize(width, height);\n    \
frameBufferTarget.viewport.copy(this._viewport);\n    \
frameBufferTarget.scissor.copy(this._scissor);\n    \
frameBufferTarget.viewport.multiplyScalar(this._pixelRatio);\n    \
frameBufferTarget.scissor.multiplyScalar(this._pixelRatio);\n    \
frameBufferTarget.scissorTest = this._scissorTest;\n    return \
frameBufferTarget;\n  }\n  _renderScene(scene3, camera3, useFrameBufferTarget \
= true) {\n    if (this._isDeviceLost === true) return;\n    const \
frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : \
null;\n    const nodeFrame = this._nodes.nodeFrame;\n    const \
previousRenderId = nodeFrame.renderId;\n    const previousRenderContext = \
this._currentRenderContext;\n    const previousRenderObjectFunction = \
this._currentRenderObjectFunction;\n    const sceneRef = scene3.isScene === \
true ? scene3 : _scene;\n    const outputRenderTarget = this._renderTarget;\n \
   const activeCubeFace = this._activeCubeFace;\n    const activeMipmapLevel \
= this._activeMipmapLevel;\n    let renderTarget;\n    if (frameBufferTarget \
!== null) {\n      renderTarget = frameBufferTarget;\n      \
this.setRenderTarget(renderTarget);\n    } else {\n      renderTarget = \
outputRenderTarget;\n    }\n    const renderContext = \
this._renderContexts.get(scene3, camera3, renderTarget);\n    \
this._currentRenderContext = renderContext;\n    \
this._currentRenderObjectFunction = this._renderObjectFunction || \
this.renderObject;\n    this.info.calls++;\n    this.info.render.calls++;\n   \
 this.info.render.frameCalls++;\n    nodeFrame.renderId = this.info.calls;\n  \
  const coordinateSystem = this.coordinateSystem;\n    if \
(camera3.coordinateSystem !== coordinateSystem) {\n      \
camera3.coordinateSystem = coordinateSystem;\n      \
camera3.updateProjectionMatrix();\n    }\n    if \
(scene3.matrixWorldAutoUpdate === true) scene3.updateMatrixWorld();\n    if \
(camera3.parent === null && camera3.matrixWorldAutoUpdate === true) \
camera3.updateMatrixWorld();\n    let viewport2 = this._viewport;\n    let \
scissor = this._scissor;\n    let pixelRatio = this._pixelRatio;\n    if \
(renderTarget !== null) {\n      viewport2 = renderTarget.viewport;\n      \
scissor = renderTarget.scissor;\n      pixelRatio = 1;\n    }\n    \
this.getDrawingBufferSize(_drawingBufferSize);\n    _screen.set(0, 0, \
_drawingBufferSize.width, _drawingBufferSize.height);\n    const minDepth = \
viewport2.minDepth === void 0 ? 0 : viewport2.minDepth;\n    const maxDepth = \
viewport2.maxDepth === void 0 ? 1 : viewport2.maxDepth;\n    \
renderContext.viewportValue.copy(viewport2).multiplyScalar(pixelRatio).floor(\
);\n    renderContext.viewportValue.width >>= activeMipmapLevel;\n    \
renderContext.viewportValue.height >>= activeMipmapLevel;\n    \
renderContext.viewportValue.minDepth = minDepth;\n    \
renderContext.viewportValue.maxDepth = maxDepth;\n    renderContext.viewport \
= renderContext.viewportValue.equals(_screen) === false;\n    \
renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();\
\n    renderContext.scissor = this._scissorTest && \
renderContext.scissorValue.equals(_screen) === false;\n    \
renderContext.scissorValue.width >>= activeMipmapLevel;\n    \
renderContext.scissorValue.height >>= activeMipmapLevel;\n    if \
(!renderContext.clippingContext) renderContext.clippingContext = new \
ClippingContext();\n    renderContext.clippingContext.updateGlobal(this, \
camera3);\n    sceneRef.onBeforeRender(this, scene3, camera3, \
renderTarget);\n    \
_projScreenMatrix.multiplyMatrices(camera3.projectionMatrix, \
camera3.matrixWorldInverse);\n    \
_frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);\n    \
const renderList = this._renderLists.get(scene3, camera3);\n    \
renderList.begin();\n    this._projectObject(scene3, camera3, 0, \
renderList);\n    renderList.finish();\n    if (this.sortObjects === true) \
{\n      renderList.sort(this._opaqueSort, this._transparentSort);\n    }\n   \
 if (renderTarget !== null) {\n      \
this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);\n      \
const renderTargetData = this._textures.get(renderTarget);\n      \
renderContext.textures = renderTargetData.textures;\n      \
renderContext.depthTexture = renderTargetData.depthTexture;\n      \
renderContext.width = renderTargetData.width;\n      renderContext.height = \
renderTargetData.height;\n      renderContext.renderTarget = renderTarget;\n  \
    renderContext.depth = renderTarget.depthBuffer;\n      \
renderContext.stencil = renderTarget.stencilBuffer;\n    } else {\n      \
renderContext.textures = null;\n      renderContext.depthTexture = null;\n    \
  renderContext.width = this.domElement.width;\n      renderContext.height = \
this.domElement.height;\n      renderContext.depth = this.depth;\n      \
renderContext.stencil = this.stencil;\n    }\n    renderContext.width >>= \
activeMipmapLevel;\n    renderContext.height >>= activeMipmapLevel;\n    \
renderContext.activeCubeFace = activeCubeFace;\n    \
renderContext.activeMipmapLevel = activeMipmapLevel;\n    \
renderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n    \
this._nodes.updateScene(sceneRef);\n    this._background.update(sceneRef, \
renderList, renderContext);\n    this.backend.beginRender(renderContext);\n   \
 const {\n      bundles,\n      lightsNode,\n      transparentDoublePass: \
transparentDoublePassObjects,\n      transparent: transparentObjects,\n      \
opaque: opaqueObjects\n    } = renderList;\n    if (bundles.length > 0) \
this._renderBundles(bundles, sceneRef, lightsNode);\n    if (this.opaque === \
true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera3, \
sceneRef, lightsNode);\n    if (this.transparent === true && \
transparentObjects.length > 0) this._renderTransparents(transparentObjects, \
transparentDoublePassObjects, camera3, sceneRef, lightsNode);\n    \
this.backend.finishRender(renderContext);\n    nodeFrame.renderId = \
previousRenderId;\n    this._currentRenderContext = previousRenderContext;\n  \
  this._currentRenderObjectFunction = previousRenderObjectFunction;\n    if \
(frameBufferTarget !== null) {\n      \
this.setRenderTarget(outputRenderTarget, activeCubeFace, \
activeMipmapLevel);\n      const quad = this._quad;\n      if \
(this._nodes.hasOutputChange(renderTarget.texture)) {\n        \
quad.material.fragmentNode = \
this._nodes.getOutputNode(renderTarget.texture);\n        \
quad.material.needsUpdate = true;\n      }\n      this._renderScene(quad, \
quad.camera, false);\n    }\n    sceneRef.onAfterRender(this, scene3, \
camera3, renderTarget);\n    return renderContext;\n  }\n  getMaxAnisotropy() \
{\n    return this.backend.getMaxAnisotropy();\n  }\n  getActiveCubeFace() \
{\n    return this._activeCubeFace;\n  }\n  getActiveMipmapLevel() {\n    \
return this._activeMipmapLevel;\n  }\n  async setAnimationLoop(callback) {\n  \
  if (this._initialized === false) await this.init();\n    \
this._animation.setAnimationLoop(callback);\n  }\n  async \
getArrayBufferAsync(attribute2) {\n    return await \
this.backend.getArrayBufferAsync(attribute2);\n  }\n  getContext() {\n    \
return this.backend.getContext();\n  }\n  getPixelRatio() {\n    return \
this._pixelRatio;\n  }\n  getDrawingBufferSize(target) {\n    return \
target.set(this._width * this._pixelRatio, this._height * \
this._pixelRatio).floor();\n  }\n  getSize(target) {\n    return \
target.set(this._width, this._height);\n  }\n  setPixelRatio(value = 1) {\n   \
 if (this._pixelRatio === value) return;\n    this._pixelRatio = value;\n    \
this.setSize(this._width, this._height, false);\n  }\n  \
setDrawingBufferSize(width, height, pixelRatio) {\n    this._width = width;\n \
   this._height = height;\n    this._pixelRatio = pixelRatio;\n    \
this.domElement.width = Math.floor(width * pixelRatio);\n    \
this.domElement.height = Math.floor(height * pixelRatio);\n    \
this.setViewport(0, 0, width, height);\n    if (this._initialized) \
this.backend.updateSize();\n  }\n  setSize(width, height, updateStyle = true) \
{\n    this._width = width;\n    this._height = height;\n    \
this.domElement.width = Math.floor(width * this._pixelRatio);\n    \
this.domElement.height = Math.floor(height * this._pixelRatio);\n    if \
(updateStyle === true) {\n      this.domElement.style.width = width + \
\"px\";\n      this.domElement.style.height = height + \"px\";\n    }\n    \
this.setViewport(0, 0, width, height);\n    if (this._initialized) \
this.backend.updateSize();\n  }\n  setOpaqueSort(method) {\n    \
this._opaqueSort = method;\n  }\n  setTransparentSort(method) {\n    \
this._transparentSort = method;\n  }\n  getScissor(target) {\n    const \
scissor = this._scissor;\n    target.x = scissor.x;\n    target.y = \
scissor.y;\n    target.width = scissor.width;\n    target.height = \
scissor.height;\n    return target;\n  }\n  setScissor(x2, y2, width, height) \
{\n    const scissor = this._scissor;\n    if (x2.isVector4) {\n      \
scissor.copy(x2);\n    } else {\n      scissor.set(x2, y2, width, height);\n  \
  }\n  }\n  getScissorTest() {\n    return this._scissorTest;\n  }\n  \
setScissorTest(boolean) {\n    this._scissorTest = boolean;\n    \
this.backend.setScissorTest(boolean);\n  }\n  getViewport(target) {\n    \
return target.copy(this._viewport);\n  }\n  setViewport(x2, y2, width, \
height, minDepth = 0, maxDepth = 1) {\n    const viewport2 = \
this._viewport;\n    if (x2.isVector4) {\n      viewport2.copy(x2);\n    } \
else {\n      viewport2.set(x2, y2, width, height);\n    }\n    \
viewport2.minDepth = minDepth;\n    viewport2.maxDepth = maxDepth;\n  }\n  \
getClearColor(target) {\n    return target.copy(this._clearColor);\n  }\n  \
setClearColor(color2, alpha = 1) {\n    this._clearColor.set(color2);\n    \
this._clearColor.a = alpha;\n  }\n  getClearAlpha() {\n    return \
this._clearColor.a;\n  }\n  setClearAlpha(alpha) {\n    this._clearColor.a = \
alpha;\n  }\n  getClearDepth() {\n    return this._clearDepth;\n  }\n  \
setClearDepth(depth2) {\n    this._clearDepth = depth2;\n  }\n  \
getClearStencil() {\n    return this._clearStencil;\n  }\n  \
setClearStencil(stencil) {\n    this._clearStencil = stencil;\n  }\n  \
isOccluded(object) {\n    const renderContext = this._currentRenderContext;\n \
   return renderContext && this.backend.isOccluded(renderContext, object);\n  \
}\n  clear(color2 = true, depth2 = true, stencil = true) {\n    if \
(this._initialized === false) {\n      console.warn(\"THREE.Renderer: \
.clear() called before the backend is initialized. Try using .clearAsync() \
instead.\");\n      return this.clearAsync(color2, depth2, stencil);\n    }\n \
   const renderTarget = this._renderTarget || this._getFrameBufferTarget();\n \
   let renderTargetData = null;\n    if (renderTarget !== null) {\n      \
this._textures.updateRenderTarget(renderTarget);\n      renderTargetData = \
this._textures.get(renderTarget);\n    }\n    this.backend.clear(color2, \
depth2, stencil, renderTargetData);\n    if (renderTarget !== null && \
this._renderTarget === null) {\n      const quad = this._quad;\n      if \
(this._nodes.hasOutputChange(renderTarget.texture)) {\n        \
quad.material.fragmentNode = \
this._nodes.getOutputNode(renderTarget.texture);\n        \
quad.material.needsUpdate = true;\n      }\n      this._renderScene(quad, \
quad.camera, false);\n    }\n  }\n  clearColor() {\n    return \
this.clear(true, false, false);\n  }\n  clearDepth() {\n    return \
this.clear(false, true, false);\n  }\n  clearStencil() {\n    return \
this.clear(false, false, true);\n  }\n  async clearAsync(color2 = true, \
depth2 = true, stencil = true) {\n    if (this._initialized === false) await \
this.init();\n    this.clear(color2, depth2, stencil);\n  }\n  \
clearColorAsync() {\n    return this.clearAsync(true, false, false);\n  }\n  \
clearDepthAsync() {\n    return this.clearAsync(false, true, false);\n  }\n  \
clearStencilAsync() {\n    return this.clearAsync(false, false, true);\n  }\n \
 get currentToneMapping() {\n    return this._renderTarget !== null ? \
NoToneMapping2 : this.toneMapping;\n  }\n  get currentColorSpace() {\n    \
return this._renderTarget !== null ? LinearSRGBColorSpace2 : \
this.outputColorSpace;\n  }\n  dispose() {\n    this.info.dispose();\n    \
this.backend.dispose();\n    this._animation.dispose();\n    \
this._objects.dispose();\n    this._pipelines.dispose();\n    \
this._nodes.dispose();\n    this._bindings.dispose();\n    \
this._renderLists.dispose();\n    this._renderContexts.dispose();\n    \
this._textures.dispose();\n    this.setRenderTarget(null);\n    \
this.setAnimationLoop(null);\n  }\n  setRenderTarget(renderTarget, \
activeCubeFace = 0, activeMipmapLevel = 0) {\n    this._renderTarget = \
renderTarget;\n    this._activeCubeFace = activeCubeFace;\n    \
this._activeMipmapLevel = activeMipmapLevel;\n  }\n  getRenderTarget() {\n    \
return this._renderTarget;\n  }\n  \
setRenderObjectFunction(renderObjectFunction) {\n    \
this._renderObjectFunction = renderObjectFunction;\n  }\n  \
getRenderObjectFunction() {\n    return this._renderObjectFunction;\n  }\n  \
compute(computeNodes) {\n    if (this.isDeviceLost === true) return;\n    if \
(this._initialized === false) {\n      console.warn(\"THREE.Renderer: \
.compute() called before the backend is initialized. Try using \
.computeAsync() instead.\");\n      return this.computeAsync(computeNodes);\n \
   }\n    const nodeFrame = this._nodes.nodeFrame;\n    const \
previousRenderId = nodeFrame.renderId;\n    this.info.calls++;\n    \
this.info.compute.calls++;\n    this.info.compute.frameCalls++;\n    \
nodeFrame.renderId = this.info.calls;\n    const backend = this.backend;\n    \
const pipelines = this._pipelines;\n    const bindings = this._bindings;\n    \
const nodes = this._nodes;\n    const computeList = \
Array.isArray(computeNodes) ? computeNodes : [computeNodes];\n    if \
(computeList[0] === void 0 || computeList[0].isComputeNode !== true) {\n      \
throw new Error(\"THREE.Renderer: .compute() expects a ComputeNode.\");\n    \
}\n    backend.beginCompute(computeNodes);\n    for (const computeNode of \
computeList) {\n      if (pipelines.has(computeNode) === false) {\n        \
const dispose = () => {\n          \
computeNode.removeEventListener(\"dispose\", dispose);\n          \
pipelines.delete(computeNode);\n          bindings.delete(computeNode);\n     \
     nodes.delete(computeNode);\n        };\n        \
computeNode.addEventListener(\"dispose\", dispose);\n        const onInitFn = \
computeNode.onInitFunction;\n        if (onInitFn !== null) {\n          \
onInitFn.call(computeNode, { renderer: this });\n        }\n      }\n      \
nodes.updateForCompute(computeNode);\n      \
bindings.updateForCompute(computeNode);\n      const computeBindings = \
bindings.getForCompute(computeNode);\n      const computePipeline = \
pipelines.getForCompute(computeNode, computeBindings);\n      \
backend.compute(computeNodes, computeNode, computeBindings, \
computePipeline);\n    }\n    backend.finishCompute(computeNodes);\n    \
nodeFrame.renderId = previousRenderId;\n  }\n  async \
computeAsync(computeNodes) {\n    if (this._initialized === false) await \
this.init();\n    this.compute(computeNodes);\n    await \
this.backend.resolveTimestampAsync(computeNodes, \"compute\");\n  }\n  async \
hasFeatureAsync(name) {\n    if (this._initialized === false) await \
this.init();\n    return this.backend.hasFeature(name);\n  }\n  \
hasFeature(name) {\n    if (this._initialized === false) {\n      \
console.warn(\"THREE.Renderer: .hasFeature() called before the backend is \
initialized. Try using .hasFeatureAsync() instead.\");\n      return false;\n \
   }\n    return this.backend.hasFeature(name);\n  }\n  \
copyFramebufferToTexture(framebufferTexture, rectangle = null) {\n    if \
(rectangle !== null) {\n      if (rectangle.isVector2) {\n        rectangle = \
_vector4.set(rectangle.x, rectangle.y, framebufferTexture.image.width, \
framebufferTexture.image.height).floor();\n      } else if \
(rectangle.isVector4) {\n        rectangle = \
_vector4.copy(rectangle).floor();\n      } else {\n        \
console.error(\"THREE.Renderer.copyFramebufferToTexture: Invalid \
rectangle.\");\n        return;\n      }\n    } else {\n      rectangle = \
_vector4.set(0, 0, framebufferTexture.image.width, \
framebufferTexture.image.height);\n    }\n    let renderContext = \
this._currentRenderContext;\n    let renderTarget;\n    if (renderContext !== \
null) {\n      renderTarget = renderContext.renderTarget;\n    } else {\n     \
 renderTarget = this._renderTarget || this._getFrameBufferTarget();\n      if \
(renderTarget !== null) {\n        \
this._textures.updateRenderTarget(renderTarget);\n        renderContext = \
this._textures.get(renderTarget);\n      }\n    }\n    \
this._textures.updateTexture(framebufferTexture, { renderTarget });\n    \
this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, \
rectangle);\n  }\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion = \
null, dstPosition = null, level = 0) {\n    \
this._textures.updateTexture(srcTexture);\n    \
this._textures.updateTexture(dstTexture);\n    \
this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, \
dstPosition, level);\n  }\n  readRenderTargetPixelsAsync(renderTarget, x2, \
y2, width, height, index5 = 0, faceIndex = 0) {\n    return \
this.backend.copyTextureToBuffer(renderTarget.textures[index5], x2, y2, \
width, height, faceIndex);\n  }\n  _projectObject(object, camera3, \
groupOrder, renderList) {\n    if (object.visible === false) return;\n    \
const visible = object.layers.test(camera3.layers);\n    if (visible) {\n     \
 if (object.isGroup) {\n        groupOrder = object.renderOrder;\n      } \
else if (object.isLOD) {\n        if (object.autoUpdate === true) \
object.update(camera3);\n      } else if (object.isLight) {\n        \
renderList.pushLight(object);\n      } else if (object.isSprite) {\n        \
if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          \
if (this.sortObjects === true) {\n            \
_vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMa\
trix);\n          }\n          const { geometry, material } = object;\n       \
   if (material.visible) {\n            renderList.push(object, geometry, \
material, groupOrder, _vector4.z, null);\n          }\n        }\n      } \
else if (object.isLineLoop) {\n        console.error(\"THREE.Renderer: \
Objects of type THREE.LineLoop are not supported. Please use THREE.Line or \
THREE.LineSegments.\");\n      } else if (object.isMesh || object.isLine || \
object.isPoints) {\n        if (!object.frustumCulled || \
_frustum.intersectsObject(object)) {\n          const { geometry, material } \
= object;\n          if (this.sortObjects === true) {\n            if \
(geometry.boundingSphere === null) geometry.computeBoundingSphere();\n        \
    \
_vector4.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld\
).applyMatrix4(_projScreenMatrix);\n          }\n          if \
(Array.isArray(material)) {\n            const groups = geometry.groups;\n    \
        for (let i = 0, l = groups.length; i < l; i++) {\n              const \
group = groups[i];\n              const groupMaterial = \
material[group.materialIndex];\n              if (groupMaterial && \
groupMaterial.visible) {\n                renderList.push(object, geometry, \
groupMaterial, groupOrder, _vector4.z, group);\n              }\n            \
}\n          } else if (material.visible) {\n            \
renderList.push(object, geometry, material, groupOrder, _vector4.z, null);\n  \
        }\n        }\n      }\n    }\n    if (object.isBundleGroup === true \
&& this.backend.beginBundle !== void 0) {\n      const baseRenderList = \
renderList;\n      renderList = this._renderLists.get(object, camera3);\n     \
 renderList.begin();\n      baseRenderList.pushBundle({\n        bundleGroup: \
object,\n        camera: camera3,\n        renderList\n      });\n      \
renderList.finish();\n    }\n    const children = object.children;\n    for \
(let i = 0, l = children.length; i < l; i++) {\n      \
this._projectObject(children[i], camera3, groupOrder, renderList);\n    }\n  \
}\n  _renderBundles(bundles, sceneRef, lightsNode) {\n    for (const bundle \
of bundles) {\n      this._renderBundle(bundle, sceneRef, lightsNode);\n    \
}\n  }\n  _renderTransparents(renderList, doublePassList, camera3, scene3, \
lightsNode) {\n    if (doublePassList.length > 0) {\n      for (const { \
material } of doublePassList) {\n        material.side = BackSide2;\n      \
}\n      this._renderObjects(doublePassList, camera3, scene3, lightsNode, \
\"backSide\");\n      for (const { material } of doublePassList) {\n        \
material.side = FrontSide2;\n      }\n      this._renderObjects(renderList, \
camera3, scene3, lightsNode);\n      for (const { material } of \
doublePassList) {\n        material.side = DoubleSide2;\n      }\n    } else \
{\n      this._renderObjects(renderList, camera3, scene3, lightsNode);\n    \
}\n  }\n  _renderObjects(renderList, camera3, scene3, lightsNode, passId = \
null) {\n    for (let i = 0, il = renderList.length; i < il; i++) {\n      \
const renderItem = renderList[i];\n      const { object, geometry, material, \
group } = renderItem;\n      if (camera3.isArrayCamera) {\n        const \
cameras = camera3.cameras;\n        for (let j = 0, jl = cameras.length; j < \
jl; j++) {\n          const camera22 = cameras[j];\n          if \
(object.layers.test(camera22.layers)) {\n            const vp = \
camera22.viewport;\n            const minDepth = vp.minDepth === void 0 ? 0 : \
vp.minDepth;\n            const maxDepth = vp.maxDepth === void 0 ? 1 : \
vp.maxDepth;\n            const viewportValue = \
this._currentRenderContext.viewportValue;\n            \
viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();\n            \
viewportValue.minDepth = minDepth;\n            viewportValue.maxDepth = \
maxDepth;\n            \
this.backend.updateViewport(this._currentRenderContext);\n            \
this._currentRenderObjectFunction(object, scene3, camera22, geometry, \
material, group, lightsNode, passId);\n          }\n        }\n      } else \
{\n        this._currentRenderObjectFunction(object, scene3, camera3, \
geometry, material, group, lightsNode, passId);\n      }\n    }\n  }\n  \
renderObject(object, scene3, camera3, geometry, material, group, lightsNode, \
passId = null) {\n    let overridePositionNode;\n    let \
overrideFragmentNode;\n    let overrideDepthNode;\n    \
object.onBeforeRender(this, scene3, camera3, geometry, material, group);\n    \
if (scene3.overrideMaterial !== null) {\n      const overrideMaterial = \
scene3.overrideMaterial;\n      if (material.positionNode && \
material.positionNode.isNode) {\n        overridePositionNode = \
overrideMaterial.positionNode;\n        overrideMaterial.positionNode = \
material.positionNode;\n      }\n      if \
(overrideMaterial.isShadowNodeMaterial) {\n        overrideMaterial.side = \
material.shadowSide === null ? material.side : material.shadowSide;\n        \
if (material.depthNode && material.depthNode.isNode) {\n          \
overrideDepthNode = overrideMaterial.depthNode;\n          \
overrideMaterial.depthNode = material.depthNode;\n        }\n        if \
(material.shadowNode && material.shadowNode.isNode) {\n          \
overrideFragmentNode = overrideMaterial.fragmentNode;\n          \
overrideMaterial.fragmentNode = material.shadowNode;\n        }\n        if \
(this.localClippingEnabled) {\n          if (material.clipShadows) {\n        \
    if (overrideMaterial.clippingPlanes !== material.clippingPlanes) {\n      \
        overrideMaterial.clippingPlanes = material.clippingPlanes;\n          \
    overrideMaterial.needsUpdate = true;\n            }\n            if \
(overrideMaterial.clipIntersection !== material.clipIntersection) {\n         \
     overrideMaterial.clipIntersection = material.clipIntersection;\n         \
   }\n          } else if (Array.isArray(overrideMaterial.clippingPlanes)) \
{\n            overrideMaterial.clippingPlanes = null;\n            \
overrideMaterial.needsUpdate = true;\n          }\n        }\n      }\n      \
material = overrideMaterial;\n    }\n    if (material.transparent === true && \
material.side === DoubleSide2 && material.forceSinglePass === false) {\n      \
material.side = BackSide2;\n      this._handleObjectFunction(object, \
material, scene3, camera3, lightsNode, group, \"backSide\");\n      \
material.side = FrontSide2;\n      this._handleObjectFunction(object, \
material, scene3, camera3, lightsNode, group, passId);\n      material.side = \
DoubleSide2;\n    } else {\n      this._handleObjectFunction(object, \
material, scene3, camera3, lightsNode, group, passId);\n    }\n    if \
(overridePositionNode !== void 0) {\n      \
scene3.overrideMaterial.positionNode = overridePositionNode;\n    }\n    if \
(overrideDepthNode !== void 0) {\n      scene3.overrideMaterial.depthNode = \
overrideDepthNode;\n    }\n    if (overrideFragmentNode !== void 0) {\n      \
scene3.overrideMaterial.fragmentNode = overrideFragmentNode;\n    }\n    \
object.onAfterRender(this, scene3, camera3, geometry, material, group);\n  \
}\n  _renderObjectDirect(object, material, scene3, camera3, lightsNode, \
group, passId) {\n    const renderObject = this._objects.get(object, \
material, scene3, camera3, lightsNode, this._currentRenderContext, passId);\n \
   renderObject.drawRange = object.geometry.drawRange;\n    \
renderObject.group = group;\n    const needsRefresh = \
this._nodes.needsRefresh(renderObject);\n    if (needsRefresh) {\n      \
this._nodes.updateBefore(renderObject);\n      \
this._geometries.updateForRender(renderObject);\n      \
this._nodes.updateForRender(renderObject);\n      \
this._bindings.updateForRender(renderObject);\n    }\n    \
this._pipelines.updateForRender(renderObject);\n    if \
(this._currentRenderBundle !== null) {\n      const renderBundleData = \
this.backend.get(this._currentRenderBundle);\n      \
renderBundleData.renderObjects.push(renderObject);\n      renderObject.bundle \
= this._currentRenderBundle.scene;\n    }\n    \
this.backend.draw(renderObject, this.info);\n    if (needsRefresh) \
this._nodes.updateAfter(renderObject);\n  }\n  _createObjectPipeline(object, \
material, scene3, camera3, lightsNode, passId) {\n    const renderObject = \
this._objects.get(object, material, scene3, camera3, lightsNode, \
this._currentRenderContext, passId);\n    \
this._nodes.updateBefore(renderObject);\n    \
this._geometries.updateForRender(renderObject);\n    \
this._nodes.updateForRender(renderObject);\n    \
this._bindings.updateForRender(renderObject);\n    \
this._pipelines.getForRender(renderObject, this._compilationPromises);\n    \
this._nodes.updateAfter(renderObject);\n  }\n  get compile() {\n    return \
this.compileAsync;\n  }\n};\nvar Binding = class {\n  constructor(name = \
\"\") {\n    this.name = name;\n    this.visibility = 0;\n  }\n  \
setVisibility(visibility) {\n    this.visibility |= visibility;\n  }\n  \
clone() {\n    return Object.assign(new this.constructor(), this);\n  \
}\n};\nfunction getFloatLength(floatLength) {\n  return floatLength + \
(GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;\n}\nvar \
Buffer2 = class extends Binding {\n  constructor(name, buffer2 = null) {\n    \
super(name);\n    this.isBuffer = true;\n    this.bytesPerElement = \
Float32Array.BYTES_PER_ELEMENT;\n    this._buffer = buffer2;\n  }\n  get \
byteLength() {\n    return getFloatLength(this._buffer.byteLength);\n  }\n  \
get buffer() {\n    return this._buffer;\n  }\n  update() {\n    return \
true;\n  }\n};\nvar UniformBuffer = class extends Buffer2 {\n  \
constructor(name, buffer2 = null) {\n    super(name, buffer2);\n    \
this.isUniformBuffer = true;\n  }\n};\nvar _id$4 = 0;\nvar NodeUniformBuffer \
= class extends UniformBuffer {\n  constructor(nodeUniform, groupNode) {\n    \
super(\"UniformBuffer_\" + _id$4++, nodeUniform ? nodeUniform.value : \
null);\n    this.nodeUniform = nodeUniform;\n    this.groupNode = \
groupNode;\n  }\n  get buffer() {\n    return this.nodeUniform.value;\n  \
}\n};\nvar UniformsGroup = class extends UniformBuffer {\n  constructor(name) \
{\n    super(name);\n    this.isUniformsGroup = true;\n    this._values = \
null;\n    this.uniforms = [];\n  }\n  addUniform(uniform2) {\n    \
this.uniforms.push(uniform2);\n    return this;\n  }\n  \
removeUniform(uniform2) {\n    const index5 = \
this.uniforms.indexOf(uniform2);\n    if (index5 !== -1) {\n      \
this.uniforms.splice(index5, 1);\n    }\n    return this;\n  }\n  get \
values() {\n    if (this._values === null) {\n      this._values = \
Array.from(this.buffer);\n    }\n    return this._values;\n  }\n  get \
buffer() {\n    let buffer2 = this._buffer;\n    if (buffer2 === null) {\n    \
  const byteLength = this.byteLength;\n      buffer2 = new Float32Array(new \
ArrayBuffer(byteLength));\n      this._buffer = buffer2;\n    }\n    return \
buffer2;\n  }\n  get byteLength() {\n    let offset = 0;\n    for (let i = 0, \
l = this.uniforms.length; i < l; i++) {\n      const uniform2 = \
this.uniforms[i];\n      const { boundary, itemSize } = uniform2;\n      \
const chunkOffset = offset % GPU_CHUNK_BYTES;\n      const \
remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n      if (chunkOffset \
!== 0 && remainingSizeInChunk - boundary < 0) {\n        offset += \
GPU_CHUNK_BYTES - chunkOffset;\n      } else if (chunkOffset % boundary !== \
0) {\n        offset += chunkOffset % boundary;\n      }\n      \
uniform2.offset = offset / this.bytesPerElement;\n      offset += itemSize * \
this.bytesPerElement;\n    }\n    return Math.ceil(offset / GPU_CHUNK_BYTES) \
* GPU_CHUNK_BYTES;\n  }\n  update() {\n    let updated = false;\n    for \
(const uniform2 of this.uniforms) {\n      if (this.updateByType(uniform2) \
=== true) {\n        updated = true;\n      }\n    }\n    return updated;\n  \
}\n  updateByType(uniform2) {\n    if (uniform2.isNumberUniform) return \
this.updateNumber(uniform2);\n    if (uniform2.isVector2Uniform) return \
this.updateVector2(uniform2);\n    if (uniform2.isVector3Uniform) return \
this.updateVector3(uniform2);\n    if (uniform2.isVector4Uniform) return \
this.updateVector4(uniform2);\n    if (uniform2.isColorUniform) return \
this.updateColor(uniform2);\n    if (uniform2.isMatrix3Uniform) return \
this.updateMatrix3(uniform2);\n    if (uniform2.isMatrix4Uniform) return \
this.updateMatrix4(uniform2);\n    console.error(\"THREE.WebGPUUniformsGroup: \
Unsupported uniform type.\", uniform2);\n  }\n  updateNumber(uniform2) {\n    \
let updated = false;\n    const a2 = this.values;\n    const v = \
uniform2.getValue();\n    const offset = uniform2.offset;\n    if (a2[offset] \
!== v) {\n      const b = this.buffer;\n      b[offset] = a2[offset] = v;\n   \
   updated = true;\n    }\n    return updated;\n  }\n  \
updateVector2(uniform2) {\n    let updated = false;\n    const a2 = \
this.values;\n    const v = uniform2.getValue();\n    const offset = \
uniform2.offset;\n    if (a2[offset + 0] !== v.x || a2[offset + 1] !== v.y) \
{\n      const b = this.buffer;\n      b[offset + 0] = a2[offset + 0] = \
v.x;\n      b[offset + 1] = a2[offset + 1] = v.y;\n      updated = true;\n    \
}\n    return updated;\n  }\n  updateVector3(uniform2) {\n    let updated = \
false;\n    const a2 = this.values;\n    const v = uniform2.getValue();\n    \
const offset = uniform2.offset;\n    if (a2[offset + 0] !== v.x || a2[offset \
+ 1] !== v.y || a2[offset + 2] !== v.z) {\n      const b = this.buffer;\n     \
 b[offset + 0] = a2[offset + 0] = v.x;\n      b[offset + 1] = a2[offset + 1] \
= v.y;\n      b[offset + 2] = a2[offset + 2] = v.z;\n      updated = true;\n  \
  }\n    return updated;\n  }\n  updateVector4(uniform2) {\n    let updated = \
false;\n    const a2 = this.values;\n    const v = uniform2.getValue();\n    \
const offset = uniform2.offset;\n    if (a2[offset + 0] !== v.x || a2[offset \
+ 1] !== v.y || a2[offset + 2] !== v.z || a2[offset + 4] !== v.w) {\n      \
const b = this.buffer;\n      b[offset + 0] = a2[offset + 0] = v.x;\n      \
b[offset + 1] = a2[offset + 1] = v.y;\n      b[offset + 2] = a2[offset + 2] = \
v.z;\n      b[offset + 3] = a2[offset + 3] = v.w;\n      updated = true;\n    \
}\n    return updated;\n  }\n  updateColor(uniform2) {\n    let updated = \
false;\n    const a2 = this.values;\n    const c2 = uniform2.getValue();\n    \
const offset = uniform2.offset;\n    if (a2[offset + 0] !== c2.r || a2[offset \
+ 1] !== c2.g || a2[offset + 2] !== c2.b) {\n      const b = this.buffer;\n   \
   b[offset + 0] = a2[offset + 0] = c2.r;\n      b[offset + 1] = a2[offset + \
1] = c2.g;\n      b[offset + 2] = a2[offset + 2] = c2.b;\n      updated = \
true;\n    }\n    return updated;\n  }\n  updateMatrix3(uniform2) {\n    let \
updated = false;\n    const a2 = this.values;\n    const e = \
uniform2.getValue().elements;\n    const offset = uniform2.offset;\n    if \
(a2[offset + 0] !== e[0] || a2[offset + 1] !== e[1] || a2[offset + 2] !== \
e[2] || a2[offset + 4] !== e[3] || a2[offset + 5] !== e[4] || a2[offset + 6] \
!== e[5] || a2[offset + 8] !== e[6] || a2[offset + 9] !== e[7] || a2[offset + \
10] !== e[8]) {\n      const b = this.buffer;\n      b[offset + 0] = \
a2[offset + 0] = e[0];\n      b[offset + 1] = a2[offset + 1] = e[1];\n      \
b[offset + 2] = a2[offset + 2] = e[2];\n      b[offset + 4] = a2[offset + 4] \
= e[3];\n      b[offset + 5] = a2[offset + 5] = e[4];\n      b[offset + 6] = \
a2[offset + 6] = e[5];\n      b[offset + 8] = a2[offset + 8] = e[6];\n      \
b[offset + 9] = a2[offset + 9] = e[7];\n      b[offset + 10] = a2[offset + \
10] = e[8];\n      updated = true;\n    }\n    return updated;\n  }\n  \
updateMatrix4(uniform2) {\n    let updated = false;\n    const a2 = \
this.values;\n    const e = uniform2.getValue().elements;\n    const offset = \
uniform2.offset;\n    if (arraysEqual2(a2, e, offset) === false) {\n      \
const b = this.buffer;\n      b.set(e, offset);\n      setArray(a2, e, \
offset);\n      updated = true;\n    }\n    return updated;\n  \
}\n};\nfunction setArray(a2, b, offset) {\n  for (let i = 0, l = b.length; i \
< l; i++) {\n    a2[offset + i] = b[i];\n  }\n}\nfunction arraysEqual2(a2, b, \
offset) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    if (a2[offset + \
i] !== b[i]) return false;\n  }\n  return true;\n}\nvar _id$3 = 0;\nvar \
NodeUniformsGroup = class extends UniformsGroup {\n  constructor(name, \
groupNode) {\n    super(name);\n    this.id = _id$3++;\n    this.groupNode = \
groupNode;\n    this.isNodeUniformsGroup = true;\n  }\n  getNodes() {\n    \
const nodes = [];\n    for (const uniform2 of this.uniforms) {\n      const \
node = uniform2.nodeUniform.node;\n      if (!node) throw new \
Error(\"NodeUniformsGroup: Uniform has no node.\");\n      \
nodes.push(node);\n    }\n    return nodes;\n  }\n};\nvar _id$22 = 0;\nvar \
SampledTexture = class extends Binding {\n  constructor(name, texture2) {\n   \
 super(name);\n    this.id = _id$22++;\n    this.texture = texture2;\n    \
this.version = texture2 ? texture2.version : 0;\n    this.store = false;\n    \
this.generation = null;\n    this.isSampledTexture = true;\n  }\n  \
needsBindingsUpdate(generation) {\n    const { texture: texture2 } = this;\n  \
  if (generation !== this.generation) {\n      this.generation = \
generation;\n      return true;\n    }\n    return texture2.isVideoTexture;\n \
 }\n  update() {\n    const { texture: texture2, version } = this;\n    if \
(version !== texture2.version) {\n      this.version = texture2.version;\n    \
  return true;\n    }\n    return false;\n  }\n};\nvar NodeSampledTexture = \
class extends SampledTexture {\n  constructor(name, textureNode, groupNode, \
access = null) {\n    super(name, textureNode ? textureNode.value : null);\n  \
  this.textureNode = textureNode;\n    this.groupNode = groupNode;\n    \
this.access = access;\n  }\n  needsBindingsUpdate(generation) {\n    return \
this.textureNode.value !== this.texture || \
super.needsBindingsUpdate(generation);\n  }\n  update() {\n    const { \
textureNode } = this;\n    if (this.texture !== textureNode.value) {\n      \
this.texture = textureNode.value;\n      return true;\n    }\n    return \
super.update();\n  }\n};\nvar NodeSampledCubeTexture = class extends \
NodeSampledTexture {\n  constructor(name, textureNode, groupNode, access) {\n \
   super(name, textureNode, groupNode, access);\n    \
this.isSampledCubeTexture = true;\n  }\n};\nvar NodeSampledTexture3D = class \
extends NodeSampledTexture {\n  constructor(name, textureNode, groupNode, \
access) {\n    super(name, textureNode, groupNode, access);\n    \
this.isSampledTexture3D = true;\n  }\n};\nvar glslMethods = {\n  atan2: \
\"atan\",\n  textureDimensions: \"textureSize\",\n  equals: \
\"equal\"\n};\nvar precisionLib = {\n  low: \"lowp\",\n  medium: \
\"mediump\",\n  high: \"highp\"\n};\nvar supports$1 = {\n  swizzleAssign: \
true,\n  storageBuffer: false\n};\nvar defaultPrecisions = `\nprecision highp \
float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp \
sampler3D;\nprecision highp samplerCube;\nprecision highp \
sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp \
usampler3D;\nprecision highp usamplerCube;\nprecision highp \
usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp \
isampler3D;\nprecision highp isamplerCube;\nprecision highp \
isampler2DArray;\n\nprecision lowp sampler2DShadow;\n`;\nvar GLSLNodeBuilder \
= class extends NodeBuilder {\n  constructor(object, renderer3) {\n    \
super(object, renderer3, new GLSLNodeParser());\n    this.uniformGroups = \
{};\n    this.transforms = [];\n    this.extensions = {};\n    \
this.useComparisonMethod = true;\n  }\n  \
needsColorSpaceToLinearSRGB(texture2) {\n    return texture2.isVideoTexture \
=== true && texture2.colorSpace !== NoColorSpace2;\n  }\n  getMethod(method) \
{\n    return glslMethods[method] || method;\n  }\n  getOutputStructName() \
{\n    return \"\";\n  }\n  buildFunctionCode(shaderNode) {\n    const layout \
= shaderNode.layout;\n    const flowData = this.flowShaderNode(shaderNode);\n \
   const parameters = [];\n    for (const input of layout.inputs) {\n      \
parameters.push(this.getType(input.type) + \" \" + input.name);\n    }\n    \
const code = `${this.getType(layout.type)} ${layout.name}( \
${parameters.join(\", \")} ) \
{\n\n\t${flowData.vars}\n\n${flowData.code}\n\treturn \
${flowData.result};\n\n}`;\n    return code;\n  }\n  \
setupPBO(storageBufferNode) {\n    const attribute2 = \
storageBufferNode.value;\n    if (attribute2.pbo === void 0) {\n      const \
originalArray = attribute2.array;\n      const numElements = attribute2.count \
* attribute2.itemSize;\n      const { itemSize } = attribute2;\n      const \
isInteger = \
attribute2.array.constructor.name.toLowerCase().includes(\"int\");\n      let \
format2 = isInteger ? RedIntegerFormat2 : RedFormat2;\n      if (itemSize === \
2) {\n        format2 = isInteger ? RGIntegerFormat2 : RGFormat2;\n      } \
else if (itemSize === 3) {\n        format2 = isInteger ? RGBIntegerFormat : \
RGBFormat2;\n      } else if (itemSize === 4) {\n        format2 = isInteger \
? RGBAIntegerFormat2 : RGBAFormat2;\n      }\n      const typeMap = {\n       \
 Float32Array: FloatType2,\n        Uint8Array: UnsignedByteType2,\n        \
Uint16Array: UnsignedShortType2,\n        Uint32Array: UnsignedIntType2,\n    \
    Int8Array: ByteType2,\n        Int16Array: ShortType2,\n        \
Int32Array: IntType2,\n        Uint8ClampedArray: UnsignedByteType2\n      \
};\n      const width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements \
/ itemSize))));\n      let height = Math.ceil(numElements / itemSize / \
width);\n      if (width * height * itemSize < numElements) height++;\n      \
const newSize = width * height * itemSize;\n      const newArray = new \
originalArray.constructor(newSize);\n      newArray.set(originalArray, 0);\n  \
    attribute2.array = newArray;\n      const pboTexture = new \
DataTexture(attribute2.array, width, height, format2, \
typeMap[attribute2.array.constructor.name] || FloatType2);\n      \
pboTexture.needsUpdate = true;\n      pboTexture.isPBOTexture = true;\n      \
const pbo = new TextureNode(pboTexture, null, null);\n      \
pbo.setPrecision(\"high\");\n      attribute2.pboNode = pbo;\n      \
attribute2.pbo = pbo.value;\n      \
this.getUniformFromNode(attribute2.pboNode, \"texture\", this.shaderStage, \
this.context.label);\n    }\n  }\n  getPropertyName(node, shaderStage = \
this.shaderStage) {\n    if (node.isNodeUniform && node.node.isTextureNode \
!== true && node.node.isBufferNode !== true) {\n      return \
shaderStage.charAt(0) + \"_\" + node.name;\n    }\n    return \
super.getPropertyName(node, shaderStage);\n  }\n  \
generatePBO(storageArrayElementNode) {\n    const { node, indexNode } = \
storageArrayElementNode;\n    const attribute2 = node.value;\n    if \
(this.renderer.backend.has(attribute2)) {\n      const attributeData = \
this.renderer.backend.get(attribute2);\n      attributeData.pbo = \
attribute2.pbo;\n    }\n    const nodeUniform = \
this.getUniformFromNode(attribute2.pboNode, \"texture\", this.shaderStage, \
this.context.label);\n    const textureName = \
this.getPropertyName(nodeUniform);\n    this.increaseUsage(indexNode);\n    \
const indexSnippet = indexNode.build(this, \"uint\");\n    const \
elementNodeData = this.getDataFromNode(storageArrayElementNode);\n    let \
propertyName = elementNodeData.propertyName;\n    if (propertyName === void \
0) {\n      const nodeVar = this.getVarFromNode(storageArrayElementNode);\n   \
   propertyName = this.getPropertyName(nodeVar);\n      const bufferNodeData \
= this.getDataFromNode(node);\n      let propertySizeName = \
bufferNodeData.propertySizeName;\n      if (propertySizeName === void 0) {\n  \
      propertySizeName = propertyName + \"Size\";\n        \
this.getVarFromNode(node, propertySizeName, \"uint\");\n        \
this.addLineFlowCode(`${propertySizeName} = uint( textureSize( \
${textureName}, 0 ).x )`, storageArrayElementNode);\n        \
bufferNodeData.propertySizeName = propertySizeName;\n      }\n      const { \
itemSize } = attribute2;\n      const channel = \".\" + \
vectorComponents.join(\"\").slice(0, itemSize);\n      const uvSnippet = \
`ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / \
${propertySizeName})`;\n      const snippet = this.generateTextureLoad(null, \
textureName, uvSnippet, null, \"0\");\n      let prefix = \"vec4\";\n      if \
(attribute2.pbo.type === UnsignedIntType2) {\n        prefix = \"uvec4\";\n   \
   } else if (attribute2.pbo.type === IntType2) {\n        prefix = \
\"ivec4\";\n      }\n      this.addLineFlowCode(`${propertyName} = \
${prefix}(${snippet})${channel}`, storageArrayElementNode);\n      \
elementNodeData.propertyName = propertyName;\n    }\n    return \
propertyName;\n  }\n  generateTextureLoad(texture2, textureProperty, \
uvIndexSnippet, depthSnippet, levelSnippet = \"0\") {\n    if (depthSnippet) \
{\n      return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, \
${depthSnippet} ), ${levelSnippet} )`;\n    } else {\n      return \
`texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;\n    \
}\n  }\n  generateTexture(texture2, textureProperty, uvSnippet, depthSnippet) \
{\n    if (texture2.isDepthTexture) {\n      return `texture( \
${textureProperty}, ${uvSnippet} ).x`;\n    } else {\n      if (depthSnippet) \
uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;\n      return `texture( \
${textureProperty}, ${uvSnippet} )`;\n    }\n  }\n  \
generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet) {\n  \
  return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;\n \
 }\n  generateTextureBias(texture2, textureProperty, uvSnippet, biasSnippet) \
{\n    return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} \
)`;\n  }\n  generateTextureGrad(texture2, textureProperty, uvSnippet, \
gradSnippet) {\n    return `textureGrad( ${textureProperty}, ${uvSnippet}, \
${gradSnippet[0]}, ${gradSnippet[1]} )`;\n  }\n  \
generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, \
depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === \
\"fragment\") {\n      return `texture( ${textureProperty}, vec3( \
${uvSnippet}, ${compareSnippet} ) )`;\n    } else {\n      \
console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not \
support ${shaderStage} shader.`);\n    }\n  }\n  getVars(shaderStage) {\n    \
const snippets = [];\n    const vars = this.vars[shaderStage];\n    if (vars \
!== void 0) {\n      for (const variable of vars) {\n        \
snippets.push(`${this.getVar(variable.type, variable.name)};`);\n      }\n    \
}\n    return snippets.join(\"\\n\t\");\n  }\n  getUniforms(shaderStage) {\n  \
  const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = \
[];\n    const uniformGroups = {};\n    for (const uniform2 of uniforms) {\n  \
    let snippet = null;\n      let group = false;\n      if (uniform2.type \
=== \"texture\") {\n        const texture2 = uniform2.node.value;\n        \
let typePrefix = \"\";\n        if (texture2.isDataTexture === true) {\n      \
    if (texture2.type === UnsignedIntType2) {\n            typePrefix = \
\"u\";\n          } else if (texture2.type === IntType2) {\n            \
typePrefix = \"i\";\n          }\n        }\n        if \
(texture2.compareFunction) {\n          snippet = `sampler2DShadow \
${uniform2.name};`;\n        } else if (texture2.isDataArrayTexture === true \
|| texture2.isCompressedArrayTexture === true) {\n          snippet = \
`${typePrefix}sampler2DArray ${uniform2.name};`;\n        } else {\n          \
snippet = `${typePrefix}sampler2D ${uniform2.name};`;\n        }\n      } \
else if (uniform2.type === \"cubeTexture\") {\n        snippet = `samplerCube \
${uniform2.name};`;\n      } else if (uniform2.type === \"texture3D\") {\n    \
    snippet = `sampler3D ${uniform2.name};`;\n      } else if (uniform2.type \
=== \"buffer\") {\n        const bufferNode = uniform2.node;\n        const \
bufferType = this.getType(bufferNode.bufferType);\n        const bufferCount \
= bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 \
? bufferCount : \"\";\n        snippet = `${bufferNode.name} \
{\n\t${bufferType} ${uniform2.name}[${bufferCountSnippet}];\n};\n`;\n      } \
else {\n        const vectorType = this.getVectorType(uniform2.type);\n       \
 snippet = `${vectorType} ${this.getPropertyName(uniform2, shaderStage)};`;\n \
       group = true;\n      }\n      const precision = \
uniform2.node.precision;\n      if (precision !== null) {\n        snippet = \
precisionLib[precision] + \" \" + snippet;\n      }\n      if (group) {\n     \
   snippet = \"\t\" + snippet;\n        const groupName = \
uniform2.groupNode.name;\n        const groupSnippets = \
uniformGroups[groupName] || (uniformGroups[groupName] = []);\n        \
groupSnippets.push(snippet);\n      } else {\n        snippet = \"uniform \" \
+ snippet;\n        bindingSnippets.push(snippet);\n      }\n    }\n    let \
output2 = \"\";\n    for (const name in uniformGroups) {\n      const \
groupSnippets = uniformGroups[name];\n      output2 += \
this._getGLSLUniformStruct(shaderStage + \"_\" + name, \
groupSnippets.join(\"\\n\")) + \"\\n\";\n    }\n    output2 += \
bindingSnippets.join(\"\\n\");\n    return output2;\n  }\n  \
getTypeFromAttribute(attribute2) {\n    let nodeType = \
super.getTypeFromAttribute(attribute2);\n    if (/^[iu]/.test(nodeType) && \
attribute2.gpuType !== IntType2) {\n      let dataAttribute = attribute2;\n   \
   if (attribute2.isInterleavedBufferAttribute) dataAttribute = \
attribute2.data;\n      const array = dataAttribute.array;\n      if ((array \
instanceof Uint32Array || array instanceof Int32Array) === false) {\n        \
nodeType = nodeType.slice(1);\n      }\n    }\n    return nodeType;\n  }\n  \
getAttributes(shaderStage) {\n    let snippet = \"\";\n    if (shaderStage \
=== \"vertex\" || shaderStage === \"compute\") {\n      const attributes = \
this.getAttributesArray();\n      let location = 0;\n      for (const \
attribute2 of attributes) {\n        snippet += `layout( location = \
${location++} ) in ${attribute2.type} ${attribute2.name};\n`;\n      }\n    \
}\n    return snippet;\n  }\n  getStructMembers(struct) {\n    const snippets \
= [];\n    const members = struct.getMemberTypes();\n    for (let i = 0; i < \
members.length; i++) {\n      const member = members[i];\n      \
snippets.push(`layout( location = ${i} ) out ${member} m${i};`);\n    }\n    \
return snippets.join(\"\\n\");\n  }\n  getStructs(shaderStage) {\n    const \
snippets = [];\n    const structs = this.structs[shaderStage];\n    if \
(structs.length === 0) {\n      return \"layout( location = 0 ) out vec4 \
fragColor;\\n\";\n    }\n    for (let index5 = 0, length2 = structs.length; \
index5 < length2; index5++) {\n      const struct = structs[index5];\n      \
let snippet = \"\\n\";\n      snippet += this.getStructMembers(struct);\n     \
 snippet += \"\\n\";\n      snippets.push(snippet);\n    }\n    return \
snippets.join(\"\\n\\n\");\n  }\n  getVaryings(shaderStage) {\n    let \
snippet = \"\";\n    const varyings = this.varyings;\n    if (shaderStage === \
\"vertex\" || shaderStage === \"compute\") {\n      for (const varying2 of \
varyings) {\n        if (shaderStage === \"compute\") \
varying2.needsInterpolation = true;\n        const type = varying2.type;\n    \
    const flat = type.includes(\"int\") || type.includes(\"uv\") || \
type.includes(\"iv\") ? \"flat \" : \"\";\n        snippet += \
`${flat}${varying2.needsInterpolation ? \"out\" : \"/*out*/\"} ${type} \
${varying2.name};\n`;\n      }\n    } else if (shaderStage === \"fragment\") \
{\n      for (const varying2 of varyings) {\n        if \
(varying2.needsInterpolation) {\n          const type = varying2.type;\n      \
    const flat = type.includes(\"int\") || type.includes(\"uv\") || \
type.includes(\"iv\") ? \"flat \" : \"\";\n          snippet += `${flat}in \
${type} ${varying2.name};\n`;\n        }\n      }\n    }\n    return \
snippet;\n  }\n  getVertexIndex() {\n    return \"uint( gl_VertexID )\";\n  \
}\n  getInstanceIndex() {\n    return \"uint( gl_InstanceID )\";\n  }\n  \
getInvocationLocalIndex() {\n    const workgroupSize = \
this.object.workgroupSize;\n    const size = workgroupSize.reduce((acc, curr) \
=> acc * curr, 1);\n    return `uint( gl_InstanceID ) % ${size}u`;\n  }\n  \
getDrawIndex() {\n    const extensions = this.renderer.backend.extensions;\n  \
  if (extensions.has(\"WEBGL_multi_draw\")) {\n      return \"uint( gl_DrawID \
)\";\n    }\n    return null;\n  }\n  getFrontFacing() {\n    return \
\"gl_FrontFacing\";\n  }\n  getFragCoord() {\n    return \
\"gl_FragCoord.xy\";\n  }\n  getFragDepth() {\n    return \"gl_FragDepth\";\n \
 }\n  enableExtension(name, behavior, shaderStage = this.shaderStage) {\n    \
const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = \
/* @__PURE__ */ new Map());\n    if (map.has(name) === false) {\n      \
map.set(name, {\n        name,\n        behavior\n      });\n    }\n  }\n  \
getExtensions(shaderStage) {\n    const snippets = [];\n    if (shaderStage \
=== \"vertex\") {\n      const ext = this.renderer.backend.extensions;\n      \
const isBatchedMesh = this.object.isBatchedMesh;\n      if (isBatchedMesh && \
ext.has(\"WEBGL_multi_draw\")) {\n        \
this.enableExtension(\"GL_ANGLE_multi_draw\", \"require\", shaderStage);\n    \
  }\n    }\n    const extensions = this.extensions[shaderStage];\n    if \
(extensions !== void 0) {\n      for (const { name, behavior } of \
extensions.values()) {\n        snippets.push(`#extension ${name} : \
${behavior}`);\n      }\n    }\n    return snippets.join(\"\\n\");\n  }\n  \
isAvailable(name) {\n    let result = supports$1[name];\n    if (result === \
void 0) {\n      if (name === \"float32Filterable\") {\n        const \
extensions = this.renderer.backend.extensions;\n        if \
(extensions.has(\"OES_texture_float_linear\")) {\n          \
extensions.get(\"OES_texture_float_linear\");\n          result = true;\n     \
   } else {\n          result = false;\n        }\n      }\n      \
supports$1[name] = result;\n    }\n    return result;\n  }\n  isFlipY() {\n   \
 return true;\n  }\n  registerTransform(varyingName, attributeNode) {\n    \
this.transforms.push({ varyingName, attributeNode });\n  }\n  getTransforms() \
{\n    const transforms = this.transforms;\n    let snippet = \"\";\n    for \
(let i = 0; i < transforms.length; i++) {\n      const transform = \
transforms[i];\n      const attributeName = \
this.getPropertyName(transform.attributeNode);\n      snippet += \
`${transform.varyingName} = ${attributeName};\n\t`;\n    }\n    return \
snippet;\n  }\n  _getGLSLUniformStruct(name, vars) {\n    return `\nlayout( \
std140 ) uniform ${name} {\n${vars}\n};`;\n  }\n  \
_getGLSLVertexCode(shaderData) {\n    return `#version 300 \
es\n\n${this.getSignature()}\n\n// extensions \
\n${shaderData.extensions}\n\n// precision\n${defaultPrecisions}\n\n// \
uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// \
attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid \
main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// \
transforms\n\t${shaderData.transforms}\n\n\t// \
flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n  }\n  \
_getGLSLFragmentCode(shaderData) {\n    return `#version 300 \
es\n\n${this.getSignature()}\n\n// precision\n${defaultPrecisions}\n\n// \
uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// \
codes\n${shaderData.codes}\n\n${shaderData.structs}\n\nvoid main() {\n\n\t// \
vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n \
 buildCode() {\n    const shadersData = this.material !== null ? { fragment: \
{}, vertex: {} } : { compute: {} };\n    this.sortBindingGroups();\n    for \
(const shaderStage in shadersData) {\n      let flow = \"// code\\n\\n\";\n   \
   flow += this.flowCode[shaderStage];\n      const flowNodes = \
this.flowNodes[shaderStage];\n      const mainNode = \
flowNodes[flowNodes.length - 1];\n      for (const node of flowNodes) {\n     \
   const flowSlotData = this.getFlowData(\n          node\n          /*, \
shaderStage*/\n        );\n        const slotName = node.name;\n        if \
(slotName) {\n          if (flow.length > 0) flow += \"\\n\";\n          flow \
+= `\t// flow -> ${slotName}\n\t`;\n        }\n        flow += \
`${flowSlotData.code}\n\t`;\n        if (node === mainNode && shaderStage !== \
\"compute\") {\n          flow += \"// result\\n\t\";\n          if \
(shaderStage === \"vertex\") {\n            flow += \"gl_Position = \";\n     \
       flow += `${flowSlotData.result};`;\n          } else if (shaderStage \
=== \"fragment\") {\n            if (!node.outputNode.isOutputStructNode) {\n \
             flow += \"fragColor = \";\n              flow += \
`${flowSlotData.result};`;\n            }\n          }\n        }\n      }\n  \
    const stageData = shadersData[shaderStage];\n      stageData.extensions = \
this.getExtensions(shaderStage);\n      stageData.uniforms = \
this.getUniforms(shaderStage);\n      stageData.attributes = \
this.getAttributes(shaderStage);\n      stageData.varyings = \
this.getVaryings(shaderStage);\n      stageData.vars = \
this.getVars(shaderStage);\n      stageData.structs = \
this.getStructs(shaderStage);\n      stageData.codes = \
this.getCodes(shaderStage);\n      stageData.transforms = \
this.getTransforms(shaderStage);\n      stageData.flow = flow;\n    }\n    if \
(this.material !== null) {\n      this.vertexShader = \
this._getGLSLVertexCode(shadersData.vertex);\n      this.fragmentShader = \
this._getGLSLFragmentCode(shadersData.fragment);\n    } else {\n      \
this.computeShader = this._getGLSLVertexCode(shadersData.compute);\n    }\n  \
}\n  getUniformFromNode(node, type, shaderStage, name = null) {\n    const \
uniformNode = super.getUniformFromNode(node, type, shaderStage, name);\n    \
const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n \
   let uniformGPU = nodeData.uniformGPU;\n    if (uniformGPU === void 0) {\n  \
    const group = node.groupNode;\n      const groupName = group.name;\n      \
const bindings = this.getBindGroupArray(groupName, shaderStage);\n      if \
(type === \"texture\") {\n        uniformGPU = new \
NodeSampledTexture(uniformNode.name, uniformNode.node, group);\n        \
bindings.push(uniformGPU);\n      } else if (type === \"cubeTexture\") {\n    \
    uniformGPU = new NodeSampledCubeTexture(uniformNode.name, \
uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else \
if (type === \"texture3D\") {\n        uniformGPU = new \
NodeSampledTexture3D(uniformNode.name, uniformNode.node, group);\n        \
bindings.push(uniformGPU);\n      } else if (type === \"buffer\") {\n        \
node.name = `NodeBuffer_${node.id}`;\n        uniformNode.name = \
`buffer${node.id}`;\n        const buffer2 = new NodeUniformBuffer(node, \
group);\n        buffer2.name = node.name;\n        bindings.push(buffer2);\n \
       uniformGPU = buffer2;\n      } else {\n        const uniformsStage = \
this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});\n  \
      let uniformsGroup = uniformsStage[groupName];\n        if \
(uniformsGroup === void 0) {\n          uniformsGroup = new \
NodeUniformsGroup(shaderStage + \"_\" + groupName, group);\n          \
uniformsStage[groupName] = uniformsGroup;\n          \
bindings.push(uniformsGroup);\n        }\n        uniformGPU = \
this.getNodeUniform(uniformNode, type);\n        \
uniformsGroup.addUniform(uniformGPU);\n      }\n      nodeData.uniformGPU = \
uniformGPU;\n    }\n    return uniformNode;\n  }\n};\nvar vector2 = \
null;\nvar vector4 = null;\nvar color4 = null;\nvar Backend = class {\n  \
constructor(parameters = {}) {\n    this.parameters = Object.assign({}, \
parameters);\n    this.data = /* @__PURE__ */ new WeakMap();\n    \
this.renderer = null;\n    this.domElement = null;\n  }\n  async \
init(renderer3) {\n    this.renderer = renderer3;\n  }\n  // render context\n \
 begin() {\n  }\n  finish() {\n  }\n  // render object\n  draw() {\n  }\n  // \
program\n  createProgram() {\n  }\n  destroyProgram() {\n  }\n  // bindings\n \
 createBindings() {\n  }\n  updateBindings() {\n  }\n  // pipeline\n  \
createRenderPipeline() {\n  }\n  createComputePipeline() {\n  }\n  \
destroyPipeline() {\n  }\n  // cache key\n  needsRenderUpdate() {\n  }\n  // \
return Boolean ( fast test )\n  getRenderCacheKey() {\n  }\n  // return \
String\n  // node builder\n  createNodeBuilder() {\n  }\n  // return \
NodeBuilder (ADD IT)\n  // textures\n  createSampler() {\n  }\n  \
createDefaultTexture() {\n  }\n  createTexture() {\n  }\n  \
copyTextureToBuffer() {\n  }\n  // attributes\n  createAttribute() {\n  }\n  \
createIndexAttribute() {\n  }\n  updateAttribute() {\n  }\n  \
destroyAttribute() {\n  }\n  // canvas\n  getContext() {\n  }\n  updateSize() \
{\n  }\n  // utils\n  resolveTimestampAsync() {\n  }\n  hasFeatureAsync() {\n \
 }\n  // return Boolean\n  hasFeature() {\n  }\n  // return Boolean\n  \
getInstanceCount(renderObject) {\n    const { object, geometry } = \
renderObject;\n    return geometry.isInstancedBufferGeometry ? \
geometry.instanceCount : object.count > 1 ? object.count : 1;\n  }\n  \
getDrawingBufferSize() {\n    vector2 = vector2 || new Vector22();\n    \
return this.renderer.getDrawingBufferSize(vector2);\n  }\n  getScissor() {\n  \
  vector4 = vector4 || new Vector42();\n    return \
this.renderer.getScissor(vector4);\n  }\n  setScissorTest() {\n  }\n  \
getClearColor() {\n    const renderer3 = this.renderer;\n    color4 = color4 \
|| new Color4();\n    renderer3.getClearColor(color4);\n    \
color4.getRGB(color4, this.renderer.currentColorSpace);\n    return color4;\n \
 }\n  getDomElement() {\n    let domElement = this.domElement;\n    if \
(domElement === null) {\n      domElement = this.parameters.canvas !== void 0 \
? this.parameters.canvas : createCanvasElement2();\n      if \
(\"setAttribute\" in domElement) domElement.setAttribute(\"data-engine\", \
`three.js r${REVISION2} webgpu`);\n      this.domElement = domElement;\n    \
}\n    return domElement;\n  }\n  // resource properties\n  set(object, \
value) {\n    this.data.set(object, value);\n  }\n  get(object) {\n    let \
map = this.data.get(object);\n    if (map === void 0) {\n      map = {};\n    \
  this.data.set(object, map);\n    }\n    return map;\n  }\n  has(object) {\n \
   return this.data.has(object);\n  }\n  delete(object) {\n    \
this.data.delete(object);\n  }\n  dispose() {\n  }\n};\nvar _id$12 = 0;\nvar \
DualAttributeData = class {\n  constructor(attributeData, dualBuffer) {\n    \
this.buffers = [attributeData.bufferGPU, dualBuffer];\n    this.type = \
attributeData.type;\n    this.bufferType = attributeData.bufferType;\n    \
this.pbo = attributeData.pbo;\n    this.byteLength = \
attributeData.byteLength;\n    this.bytesPerElement = \
attributeData.BYTES_PER_ELEMENT;\n    this.version = attributeData.version;\n \
   this.isInteger = attributeData.isInteger;\n    this.activeBufferIndex = \
0;\n    this.baseId = attributeData.id;\n  }\n  get id() {\n    return \
`${this.baseId}|${this.activeBufferIndex}`;\n  }\n  get bufferGPU() {\n    \
return this.buffers[this.activeBufferIndex];\n  }\n  get transformBuffer() \
{\n    return this.buffers[this.activeBufferIndex ^ 1];\n  }\n  \
switchBuffers() {\n    this.activeBufferIndex ^= 1;\n  }\n};\nvar \
WebGLAttributeUtils = class {\n  constructor(backend) {\n    this.backend = \
backend;\n  }\n  createAttribute(attribute2, bufferType) {\n    const backend \
= this.backend;\n    const { gl } = backend;\n    const array = \
attribute2.array;\n    const usage = attribute2.usage || gl.STATIC_DRAW;\n    \
const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? \
attribute2.data : attribute2;\n    const bufferData = \
backend.get(bufferAttribute2);\n    let bufferGPU = bufferData.bufferGPU;\n   \
 if (bufferGPU === void 0) {\n      bufferGPU = this._createBuffer(gl, \
bufferType, array, usage);\n      bufferData.bufferGPU = bufferGPU;\n      \
bufferData.bufferType = bufferType;\n      bufferData.version = \
bufferAttribute2.version;\n    }\n    let type;\n    if (array instanceof \
Float32Array) {\n      type = gl.FLOAT;\n    } else if (array instanceof \
Uint16Array) {\n      if (attribute2.isFloat16BufferAttribute) {\n        \
type = gl.HALF_FLOAT;\n      } else {\n        type = gl.UNSIGNED_SHORT;\n    \
  }\n    } else if (array instanceof Int16Array) {\n      type = gl.SHORT;\n  \
  } else if (array instanceof Uint32Array) {\n      type = gl.UNSIGNED_INT;\n \
   } else if (array instanceof Int32Array) {\n      type = gl.INT;\n    } \
else if (array instanceof Int8Array) {\n      type = gl.BYTE;\n    } else if \
(array instanceof Uint8Array) {\n      type = gl.UNSIGNED_BYTE;\n    } else \
if (array instanceof Uint8ClampedArray) {\n      type = gl.UNSIGNED_BYTE;\n   \
 } else {\n      throw new Error(\"THREE.WebGLBackend: Unsupported buffer \
data format: \" + array);\n    }\n    let attributeData = {\n      \
bufferGPU,\n      bufferType,\n      type,\n      byteLength: \
array.byteLength,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      \
version: attribute2.version,\n      pbo: attribute2.pbo,\n      isInteger: \
type === gl.INT || type === gl.UNSIGNED_INT || attribute2.gpuType === \
IntType2,\n      id: _id$12++\n    };\n    if \
(attribute2.isStorageBufferAttribute || \
attribute2.isStorageInstancedBufferAttribute) {\n      const bufferGPUDual = \
this._createBuffer(gl, bufferType, array, usage);\n      attributeData = new \
DualAttributeData(attributeData, bufferGPUDual);\n    }\n    \
backend.set(attribute2, attributeData);\n  }\n  updateAttribute(attribute2) \
{\n    const backend = this.backend;\n    const { gl } = backend;\n    const \
array = attribute2.array;\n    const bufferAttribute2 = \
attribute2.isInterleavedBufferAttribute ? attribute2.data : attribute2;\n    \
const bufferData = backend.get(bufferAttribute2);\n    const bufferType = \
bufferData.bufferType;\n    const updateRanges = \
attribute2.isInterleavedBufferAttribute ? attribute2.data.updateRanges : \
attribute2.updateRanges;\n    gl.bindBuffer(bufferType, \
bufferData.bufferGPU);\n    if (updateRanges.length === 0) {\n      \
gl.bufferSubData(bufferType, 0, array);\n    } else {\n      for (let i = 0, \
l = updateRanges.length; i < l; i++) {\n        const range = \
updateRanges[i];\n        gl.bufferSubData(\n          bufferType,\n          \
range.start * array.BYTES_PER_ELEMENT,\n          array,\n          \
range.start,\n          range.count\n        );\n      }\n      \
bufferAttribute2.clearUpdateRanges();\n    }\n    gl.bindBuffer(bufferType, \
null);\n    bufferData.version = bufferAttribute2.version;\n  }\n  \
destroyAttribute(attribute2) {\n    const backend = this.backend;\n    const \
{ gl } = backend;\n    if (attribute2.isInterleavedBufferAttribute) {\n      \
backend.delete(attribute2.data);\n    }\n    const attributeData = \
backend.get(attribute2);\n    gl.deleteBuffer(attributeData.bufferGPU);\n    \
backend.delete(attribute2);\n  }\n  async getArrayBufferAsync(attribute2) {\n \
   const backend = this.backend;\n    const { gl } = backend;\n    const \
bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? attribute2.data \
: attribute2;\n    const { bufferGPU } = backend.get(bufferAttribute2);\n    \
const array = attribute2.array;\n    const byteLength = array.byteLength;\n   \
 gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);\n    const writeBuffer = \
gl.createBuffer();\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);\n   \
 gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);\n    \
gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, \
byteLength);\n    await backend.utils._clientWaitAsync();\n    const \
dstBuffer = new attribute2.array.constructor(array.length);\n    \
gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);\n    \
gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);\n    \
gl.deleteBuffer(writeBuffer);\n    gl.bindBuffer(gl.COPY_READ_BUFFER, \
null);\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);\n    return \
dstBuffer.buffer;\n  }\n  _createBuffer(gl, bufferType, array, usage) {\n    \
const bufferGPU = gl.createBuffer();\n    gl.bindBuffer(bufferType, \
bufferGPU);\n    gl.bufferData(bufferType, array, usage);\n    \
gl.bindBuffer(bufferType, null);\n    return bufferGPU;\n  }\n};\nvar \
initialized$1 = false;\nvar equationToGL;\nvar factorToGL;\nvar WebGLState2 = \
class {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = \
this.backend.gl;\n    this.enabled = {};\n    this.currentFlipSided = null;\n \
   this.currentCullFace = null;\n    this.currentProgram = null;\n    \
this.currentBlendingEnabled = false;\n    this.currentBlending = null;\n    \
this.currentBlendSrc = null;\n    this.currentBlendDst = null;\n    \
this.currentBlendSrcAlpha = null;\n    this.currentBlendDstAlpha = null;\n    \
this.currentPremultipledAlpha = null;\n    this.currentPolygonOffsetFactor = \
null;\n    this.currentPolygonOffsetUnits = null;\n    this.currentColorMask \
= null;\n    this.currentDepthFunc = null;\n    this.currentDepthMask = \
null;\n    this.currentStencilFunc = null;\n    this.currentStencilRef = \
null;\n    this.currentStencilFuncMask = null;\n    this.currentStencilFail = \
null;\n    this.currentStencilZFail = null;\n    this.currentStencilZPass = \
null;\n    this.currentStencilMask = null;\n    this.currentLineWidth = \
null;\n    this.currentBoundFramebuffers = {};\n    this.currentDrawbuffers = \
/* @__PURE__ */ new WeakMap();\n    this.maxTextures = \
this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);\n    \
this.currentTextureSlot = null;\n    this.currentBoundTextures = {};\n    \
this.currentBoundBufferBases = {};\n    if (initialized$1 === false) {\n      \
this._init(this.gl);\n      initialized$1 = true;\n    }\n  }\n  _init(gl) \
{\n    equationToGL = {\n      [AddEquation2]: gl.FUNC_ADD,\n      \
[SubtractEquation2]: gl.FUNC_SUBTRACT,\n      [ReverseSubtractEquation2]: \
gl.FUNC_REVERSE_SUBTRACT\n    };\n    factorToGL = {\n      [ZeroFactor2]: \
gl.ZERO,\n      [OneFactor2]: gl.ONE,\n      [SrcColorFactor2]: \
gl.SRC_COLOR,\n      [SrcAlphaFactor2]: gl.SRC_ALPHA,\n      \
[SrcAlphaSaturateFactor2]: gl.SRC_ALPHA_SATURATE,\n      [DstColorFactor2]: \
gl.DST_COLOR,\n      [DstAlphaFactor2]: gl.DST_ALPHA,\n      \
[OneMinusSrcColorFactor2]: gl.ONE_MINUS_SRC_COLOR,\n      \
[OneMinusSrcAlphaFactor2]: gl.ONE_MINUS_SRC_ALPHA,\n      \
[OneMinusDstColorFactor2]: gl.ONE_MINUS_DST_COLOR,\n      \
[OneMinusDstAlphaFactor2]: gl.ONE_MINUS_DST_ALPHA\n    };\n  }\n  enable(id2) \
{\n    const { enabled } = this;\n    if (enabled[id2] !== true) {\n      \
this.gl.enable(id2);\n      enabled[id2] = true;\n    }\n  }\n  disable(id2) \
{\n    const { enabled } = this;\n    if (enabled[id2] !== false) {\n      \
this.gl.disable(id2);\n      enabled[id2] = false;\n    }\n  }\n  \
setFlipSided(flipSided) {\n    if (this.currentFlipSided !== flipSided) {\n   \
   const { gl } = this;\n      if (flipSided) {\n        \
gl.frontFace(gl.CW);\n      } else {\n        gl.frontFace(gl.CCW);\n      \
}\n      this.currentFlipSided = flipSided;\n    }\n  }\n  \
setCullFace(cullFace) {\n    const { gl } = this;\n    if (cullFace !== \
CullFaceNone2) {\n      this.enable(gl.CULL_FACE);\n      if (cullFace !== \
this.currentCullFace) {\n        if (cullFace === CullFaceBack2) {\n          \
gl.cullFace(gl.BACK);\n        } else if (cullFace === CullFaceFront2) {\n    \
      gl.cullFace(gl.FRONT);\n        } else {\n          \
gl.cullFace(gl.FRONT_AND_BACK);\n        }\n      }\n    } else {\n      \
this.disable(gl.CULL_FACE);\n    }\n    this.currentCullFace = cullFace;\n  \
}\n  setLineWidth(width) {\n    const { currentLineWidth, gl } = this;\n    \
if (width !== currentLineWidth) {\n      gl.lineWidth(width);\n      \
this.currentLineWidth = width;\n    }\n  }\n  setBlending(blending, \
blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, \
blendDstAlpha, premultipliedAlpha) {\n    const { gl } = this;\n    if \
(blending === NoBlending2) {\n      if (this.currentBlendingEnabled === true) \
{\n        this.disable(gl.BLEND);\n        this.currentBlendingEnabled = \
false;\n      }\n      return;\n    }\n    if (this.currentBlendingEnabled \
=== false) {\n      this.enable(gl.BLEND);\n      this.currentBlendingEnabled \
= true;\n    }\n    if (blending !== CustomBlending2) {\n      if (blending \
!== this.currentBlending || premultipliedAlpha !== \
this.currentPremultipledAlpha) {\n        if (this.currentBlendEquation !== \
AddEquation2 || this.currentBlendEquationAlpha !== AddEquation2) {\n          \
gl.blendEquation(gl.FUNC_ADD);\n          this.currentBlendEquation = \
AddEquation2;\n          this.currentBlendEquationAlpha = AddEquation2;\n     \
   }\n        if (premultipliedAlpha) {\n          switch (blending) {\n      \
      case NormalBlending2:\n              gl.blendFuncSeparate(gl.ONE, \
gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              \
break;\n            case AdditiveBlending2:\n              \
gl.blendFunc(gl.ONE, gl.ONE);\n              break;\n            case \
SubtractiveBlending2:\n              gl.blendFuncSeparate(gl.ZERO, \
gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            \
case MultiplyBlending2:\n              gl.blendFuncSeparate(gl.ZERO, \
gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n              break;\n            \
default:\n              console.error(\"THREE.WebGLState: Invalid blending: \
\", blending);\n              break;\n          }\n        } else {\n         \
 switch (blending) {\n            case NormalBlending2:\n              \
gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, \
gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case \
AdditiveBlending2:\n              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n       \
       break;\n            case SubtractiveBlending2:\n              \
gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n     \
         break;\n            case MultiplyBlending2:\n              \
gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n              break;\n            \
default:\n              console.error(\"THREE.WebGLState: Invalid blending: \
\", blending);\n              break;\n          }\n        }\n        \
this.currentBlendSrc = null;\n        this.currentBlendDst = null;\n        \
this.currentBlendSrcAlpha = null;\n        this.currentBlendDstAlpha = \
null;\n        this.currentBlending = blending;\n        \
this.currentPremultipledAlpha = premultipliedAlpha;\n      }\n      return;\n \
   }\n    blendEquationAlpha = blendEquationAlpha || blendEquation;\n    \
blendSrcAlpha = blendSrcAlpha || blendSrc;\n    blendDstAlpha = blendDstAlpha \
|| blendDst;\n    if (blendEquation !== this.currentBlendEquation || \
blendEquationAlpha !== this.currentBlendEquationAlpha) {\n      \
gl.blendEquationSeparate(equationToGL[blendEquation], \
equationToGL[blendEquationAlpha]);\n      this.currentBlendEquation = \
blendEquation;\n      this.currentBlendEquationAlpha = blendEquationAlpha;\n  \
  }\n    if (blendSrc !== this.currentBlendSrc || blendDst !== \
this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || \
blendDstAlpha !== this.currentBlendDstAlpha) {\n      \
gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], \
factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n      \
this.currentBlendSrc = blendSrc;\n      this.currentBlendDst = blendDst;\n    \
  this.currentBlendSrcAlpha = blendSrcAlpha;\n      this.currentBlendDstAlpha \
= blendDstAlpha;\n    }\n    this.currentBlending = blending;\n    \
this.currentPremultipledAlpha = false;\n  }\n  setColorMask(colorMask) {\n    \
if (this.currentColorMask !== colorMask) {\n      \
this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n      \
this.currentColorMask = colorMask;\n    }\n  }\n  setDepthTest(depthTest) {\n \
   const { gl } = this;\n    if (depthTest) {\n      \
this.enable(gl.DEPTH_TEST);\n    } else {\n      \
this.disable(gl.DEPTH_TEST);\n    }\n  }\n  setDepthMask(depthMask) {\n    if \
(this.currentDepthMask !== depthMask) {\n      \
this.gl.depthMask(depthMask);\n      this.currentDepthMask = depthMask;\n    \
}\n  }\n  setDepthFunc(depthFunc) {\n    if (this.currentDepthFunc !== \
depthFunc) {\n      const { gl } = this;\n      switch (depthFunc) {\n        \
case NeverDepth2:\n          gl.depthFunc(gl.NEVER);\n          break;\n      \
  case AlwaysDepth2:\n          gl.depthFunc(gl.ALWAYS);\n          break;\n  \
      case LessDepth2:\n          gl.depthFunc(gl.LESS);\n          break;\n  \
      case LessEqualDepth2:\n          gl.depthFunc(gl.LEQUAL);\n          \
break;\n        case EqualDepth2:\n          gl.depthFunc(gl.EQUAL);\n        \
  break;\n        case GreaterEqualDepth2:\n          \
gl.depthFunc(gl.GEQUAL);\n          break;\n        case GreaterDepth2:\n     \
     gl.depthFunc(gl.GREATER);\n          break;\n        case \
NotEqualDepth2:\n          gl.depthFunc(gl.NOTEQUAL);\n          break;\n     \
   default:\n          gl.depthFunc(gl.LEQUAL);\n      }\n      \
this.currentDepthFunc = depthFunc;\n    }\n  }\n  setStencilTest(stencilTest) \
{\n    const { gl } = this;\n    if (stencilTest) {\n      \
this.enable(gl.STENCIL_TEST);\n    } else {\n      \
this.disable(gl.STENCIL_TEST);\n    }\n  }\n  setStencilMask(stencilMask) {\n \
   if (this.currentStencilMask !== stencilMask) {\n      \
this.gl.stencilMask(stencilMask);\n      this.currentStencilMask = \
stencilMask;\n    }\n  }\n  setStencilFunc(stencilFunc, stencilRef, \
stencilMask) {\n    if (this.currentStencilFunc !== stencilFunc || \
this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== \
stencilMask) {\n      this.gl.stencilFunc(stencilFunc, stencilRef, \
stencilMask);\n      this.currentStencilFunc = stencilFunc;\n      \
this.currentStencilRef = stencilRef;\n      this.currentStencilFuncMask = \
stencilMask;\n    }\n  }\n  setStencilOp(stencilFail, stencilZFail, \
stencilZPass) {\n    if (this.currentStencilFail !== stencilFail || \
this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== \
stencilZPass) {\n      this.gl.stencilOp(stencilFail, stencilZFail, \
stencilZPass);\n      this.currentStencilFail = stencilFail;\n      \
this.currentStencilZFail = stencilZFail;\n      this.currentStencilZPass = \
stencilZPass;\n    }\n  }\n  setMaterial(material, frontFaceCW) {\n    const \
{ gl } = this;\n    material.side === DoubleSide2 ? \
this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);\n    let flipSided = \
material.side === BackSide2;\n    if (frontFaceCW) flipSided = !flipSided;\n  \
  this.setFlipSided(flipSided);\n    material.blending === NormalBlending2 && \
material.transparent === false ? this.setBlending(NoBlending2) : \
this.setBlending(material.blending, material.blendEquation, \
material.blendSrc, material.blendDst, material.blendEquationAlpha, \
material.blendSrcAlpha, material.blendDstAlpha, \
material.premultipliedAlpha);\n    this.setDepthFunc(material.depthFunc);\n   \
 this.setDepthTest(material.depthTest);\n    \
this.setDepthMask(material.depthWrite);\n    \
this.setColorMask(material.colorWrite);\n    const stencilWrite = \
material.stencilWrite;\n    this.setStencilTest(stencilWrite);\n    if \
(stencilWrite) {\n      this.setStencilMask(material.stencilWriteMask);\n     \
 this.setStencilFunc(material.stencilFunc, material.stencilRef, \
material.stencilFuncMask);\n      this.setStencilOp(material.stencilFail, \
material.stencilZFail, material.stencilZPass);\n    }\n    \
this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, \
material.polygonOffsetUnits);\n    material.alphaToCoverage === true && \
this.backend.renderer.samples > 1 ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) \
: this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n  }\n  \
setPolygonOffset(polygonOffset, factor, units) {\n    const { gl } = this;\n  \
  if (polygonOffset) {\n      this.enable(gl.POLYGON_OFFSET_FILL);\n      if \
(this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits \
!== units) {\n        gl.polygonOffset(factor, units);\n        \
this.currentPolygonOffsetFactor = factor;\n        \
this.currentPolygonOffsetUnits = units;\n      }\n    } else {\n      \
this.disable(gl.POLYGON_OFFSET_FILL);\n    }\n  }\n  useProgram(program) {\n  \
  if (this.currentProgram !== program) {\n      \
this.gl.useProgram(program);\n      this.currentProgram = program;\n      \
return true;\n    }\n    return false;\n  }\n  // framebuffer\n  \
bindFramebuffer(target, framebuffer) {\n    const { gl, \
currentBoundFramebuffers } = this;\n    if (currentBoundFramebuffers[target] \
!== framebuffer) {\n      gl.bindFramebuffer(target, framebuffer);\n      \
currentBoundFramebuffers[target] = framebuffer;\n      if (target === \
gl.DRAW_FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.FRAMEBUFFER] = \
framebuffer;\n      }\n      if (target === gl.FRAMEBUFFER) {\n        \
currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;\n      }\n      \
return true;\n    }\n    return false;\n  }\n  drawBuffers(renderContext, \
framebuffer) {\n    const { gl } = this;\n    let drawBuffers = [];\n    let \
needsUpdate = false;\n    if (renderContext.textures !== null) {\n      \
drawBuffers = this.currentDrawbuffers.get(framebuffer);\n      if \
(drawBuffers === void 0) {\n        drawBuffers = [];\n        \
this.currentDrawbuffers.set(framebuffer, drawBuffers);\n      }\n      const \
textures = renderContext.textures;\n      if (drawBuffers.length !== \
textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {\n        for \
(let i = 0, il = textures.length; i < il; i++) {\n          drawBuffers[i] = \
gl.COLOR_ATTACHMENT0 + i;\n        }\n        drawBuffers.length = \
textures.length;\n        needsUpdate = true;\n      }\n    } else {\n      \
if (drawBuffers[0] !== gl.BACK) {\n        drawBuffers[0] = gl.BACK;\n        \
needsUpdate = true;\n      }\n    }\n    if (needsUpdate) {\n      \
gl.drawBuffers(drawBuffers);\n    }\n  }\n  // texture\n  \
activeTexture(webglSlot) {\n    const { gl, currentTextureSlot, maxTextures } \
= this;\n    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures \
- 1;\n    if (currentTextureSlot !== webglSlot) {\n      \
gl.activeTexture(webglSlot);\n      this.currentTextureSlot = webglSlot;\n    \
}\n  }\n  bindTexture(webglType, webglTexture, webglSlot) {\n    const { gl, \
currentTextureSlot, currentBoundTextures, maxTextures } = this;\n    if \
(webglSlot === void 0) {\n      if (currentTextureSlot === null) {\n        \
webglSlot = gl.TEXTURE0 + maxTextures - 1;\n      } else {\n        webglSlot \
= currentTextureSlot;\n      }\n    }\n    let boundTexture = \
currentBoundTextures[webglSlot];\n    if (boundTexture === void 0) {\n      \
boundTexture = { type: void 0, texture: void 0 };\n      \
currentBoundTextures[webglSlot] = boundTexture;\n    }\n    if \
(boundTexture.type !== webglType || boundTexture.texture !== webglTexture) \
{\n      if (currentTextureSlot !== webglSlot) {\n        \
gl.activeTexture(webglSlot);\n        this.currentTextureSlot = webglSlot;\n  \
    }\n      gl.bindTexture(webglType, webglTexture);\n      \
boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n  \
  }\n  }\n  bindBufferBase(target, index5, buffer2) {\n    const { gl } = \
this;\n    const key = `${target}-${index5}`;\n    if \
(this.currentBoundBufferBases[key] !== buffer2) {\n      \
gl.bindBufferBase(target, index5, buffer2);\n      \
this.currentBoundBufferBases[key] = buffer2;\n      return true;\n    }\n    \
return false;\n  }\n  unbindTexture() {\n    const { gl, currentTextureSlot, \
currentBoundTextures } = this;\n    const boundTexture = \
currentBoundTextures[currentTextureSlot];\n    if (boundTexture !== void 0 && \
boundTexture.type !== void 0) {\n      gl.bindTexture(boundTexture.type, \
null);\n      boundTexture.type = void 0;\n      boundTexture.texture = void \
0;\n    }\n  }\n};\nvar WebGLUtils2 = class {\n  constructor(backend) {\n    \
this.backend = backend;\n    this.gl = this.backend.gl;\n    this.extensions \
= backend.extensions;\n  }\n  convert(p, colorSpace = NoColorSpace2) {\n    \
const { gl, extensions } = this;\n    let extension;\n    if (p === \
UnsignedByteType2) return gl.UNSIGNED_BYTE;\n    if (p === \
UnsignedShort4444Type2) return gl.UNSIGNED_SHORT_4_4_4_4;\n    if (p === \
UnsignedShort5551Type2) return gl.UNSIGNED_SHORT_5_5_5_1;\n    if (p === \
UnsignedInt5999Type2) return gl.UNSIGNED_INT_5_9_9_9_REV;\n    if (p === \
ByteType2) return gl.BYTE;\n    if (p === ShortType2) return gl.SHORT;\n    \
if (p === UnsignedShortType2) return gl.UNSIGNED_SHORT;\n    if (p === \
IntType2) return gl.INT;\n    if (p === UnsignedIntType2) return \
gl.UNSIGNED_INT;\n    if (p === FloatType2) return gl.FLOAT;\n    if (p === \
HalfFloatType2) {\n      return gl.HALF_FLOAT;\n    }\n    if (p === \
AlphaFormat2) return gl.ALPHA;\n    if (p === RGBFormat2) return gl.RGB;\n    \
if (p === RGBAFormat2) return gl.RGBA;\n    if (p === LuminanceFormat2) \
return gl.LUMINANCE;\n    if (p === LuminanceAlphaFormat2) return \
gl.LUMINANCE_ALPHA;\n    if (p === DepthFormat2) return gl.DEPTH_COMPONENT;\n \
   if (p === DepthStencilFormat2) return gl.DEPTH_STENCIL;\n    if (p === \
RedFormat2) return gl.RED;\n    if (p === RedIntegerFormat2) return \
gl.RED_INTEGER;\n    if (p === RGFormat2) return gl.RG;\n    if (p === \
RGIntegerFormat2) return gl.RG_INTEGER;\n    if (p === RGBAIntegerFormat2) \
return gl.RGBA_INTEGER;\n    if (p === RGB_S3TC_DXT1_Format2 || p === \
RGBA_S3TC_DXT1_Format2 || p === RGBA_S3TC_DXT3_Format2 || p === \
RGBA_S3TC_DXT5_Format2) {\n      if (colorSpace === SRGBColorSpace2) {\n      \
  extension = extensions.get(\"WEBGL_compressed_texture_s3tc_srgb\");\n       \
 if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format2) return \
extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n          if (p === \
RGBA_S3TC_DXT1_Format2) return \
extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n          if (p === \
RGBA_S3TC_DXT3_Format2) return \
extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n          if (p === \
RGBA_S3TC_DXT5_Format2) return \
extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n        } else {\n          \
return null;\n        }\n      } else {\n        extension = \
extensions.get(\"WEBGL_compressed_texture_s3tc\");\n        if (extension !== \
null) {\n          if (p === RGB_S3TC_DXT1_Format2) return \
extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n          if (p === \
RGBA_S3TC_DXT1_Format2) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n     \
     if (p === RGBA_S3TC_DXT3_Format2) return \
extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          if (p === \
RGBA_S3TC_DXT5_Format2) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n     \
   } else {\n          return null;\n        }\n      }\n    }\n    if (p === \
RGB_PVRTC_4BPPV1_Format2 || p === RGB_PVRTC_2BPPV1_Format2 || p === \
RGBA_PVRTC_4BPPV1_Format2 || p === RGBA_PVRTC_2BPPV1_Format2) {\n      \
extension = extensions.get(\"WEBGL_compressed_texture_pvrtc\");\n      if \
(extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format2) return \
extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === \
RGB_PVRTC_2BPPV1_Format2) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n \
       if (p === RGBA_PVRTC_4BPPV1_Format2) return \
extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === \
RGBA_PVRTC_2BPPV1_Format2) return \
extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return \
null;\n      }\n    }\n    if (p === RGB_ETC1_Format2 || p === \
RGB_ETC2_Format2 || p === RGBA_ETC2_EAC_Format2) {\n      extension = \
extensions.get(\"WEBGL_compressed_texture_etc\");\n      if (extension !== \
null) {\n        if (p === RGB_ETC1_Format2 || p === RGB_ETC2_Format2) return \
colorSpace === SRGBColorSpace2 ? extension.COMPRESSED_SRGB8_ETC2 : \
extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format2) \
return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : \
extension.COMPRESSED_RGBA8_ETC2_EAC;\n      } else {\n        return null;\n  \
    }\n    }\n    if (p === RGBA_ASTC_4x4_Format2 || p === \
RGBA_ASTC_5x4_Format2 || p === RGBA_ASTC_5x5_Format2 || p === \
RGBA_ASTC_6x5_Format2 || p === RGBA_ASTC_6x6_Format2 || p === \
RGBA_ASTC_8x5_Format2 || p === RGBA_ASTC_8x6_Format2 || p === \
RGBA_ASTC_8x8_Format2 || p === RGBA_ASTC_10x5_Format2 || p === \
RGBA_ASTC_10x6_Format2 || p === RGBA_ASTC_10x8_Format2 || p === \
RGBA_ASTC_10x10_Format2 || p === RGBA_ASTC_12x10_Format2 || p === \
RGBA_ASTC_12x12_Format2) {\n      extension = \
extensions.get(\"WEBGL_compressed_texture_astc\");\n      if (extension !== \
null) {\n        if (p === RGBA_ASTC_4x4_Format2) return colorSpace === \
SRGBColorSpace2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : \
extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n        if (p === \
RGBA_ASTC_5x4_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : \
extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n        if (p === \
RGBA_ASTC_5x5_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : \
extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n        if (p === \
RGBA_ASTC_6x5_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : \
extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n        if (p === \
RGBA_ASTC_6x6_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : \
extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n        if (p === \
RGBA_ASTC_8x5_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : \
extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n        if (p === \
RGBA_ASTC_8x6_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : \
extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n        if (p === \
RGBA_ASTC_8x8_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : \
extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n        if (p === \
RGBA_ASTC_10x5_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : \
extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n        if (p === \
RGBA_ASTC_10x6_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : \
extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n        if (p === \
RGBA_ASTC_10x8_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : \
extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n        if (p === \
RGBA_ASTC_10x10_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : \
extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n        if (p === \
RGBA_ASTC_12x10_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : \
extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n        if (p === \
RGBA_ASTC_12x12_Format2) return colorSpace === SRGBColorSpace2 ? \
extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : \
extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n      } else {\n        return \
null;\n      }\n    }\n    if (p === RGBA_BPTC_Format2) {\n      extension = \
extensions.get(\"EXT_texture_compression_bptc\");\n      if (extension !== \
null) {\n        if (p === RGBA_BPTC_Format2) return colorSpace === \
SRGBColorSpace2 ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : \
extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n      } else {\n        return \
null;\n      }\n    }\n    if (p === RED_RGTC1_Format2 || p === \
SIGNED_RED_RGTC1_Format2 || p === RED_GREEN_RGTC2_Format2 || p === \
SIGNED_RED_GREEN_RGTC2_Format2) {\n      extension = \
extensions.get(\"EXT_texture_compression_rgtc\");\n      if (extension !== \
null) {\n        if (p === RGBA_BPTC_Format2) return \
extension.COMPRESSED_RED_RGTC1_EXT;\n        if (p === \
SIGNED_RED_RGTC1_Format2) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n \
       if (p === RED_GREEN_RGTC2_Format2) return \
extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n        if (p === \
SIGNED_RED_GREEN_RGTC2_Format2) return \
extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n      } else {\n        \
return null;\n      }\n    }\n    if (p === UnsignedInt248Type2) {\n      \
return gl.UNSIGNED_INT_24_8;\n    }\n    return gl[p] !== void 0 ? gl[p] : \
null;\n  }\n  _clientWaitAsync() {\n    const { gl } = this;\n    const sync \
= gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    \
return new Promise((resolve, reject) => {\n      function test() {\n        \
const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);\n        \
if (res === gl.WAIT_FAILED) {\n          gl.deleteSync(sync);\n          \
reject();\n          return;\n        }\n        if (res === \
gl.TIMEOUT_EXPIRED) {\n          requestAnimationFrame(test);\n          \
return;\n        }\n        gl.deleteSync(sync);\n        resolve();\n      \
}\n      test();\n    });\n  }\n};\nvar initialized = false;\nvar \
wrappingToGL;\nvar filterToGL;\nvar compareToGL;\nvar WebGLTextureUtils = \
class {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = \
backend.gl;\n    this.extensions = backend.extensions;\n    \
this.defaultTextures = {};\n    if (initialized === false) {\n      \
this._init(this.gl);\n      initialized = true;\n    }\n  }\n  _init(gl) {\n  \
  wrappingToGL = {\n      [RepeatWrapping2]: gl.REPEAT,\n      \
[ClampToEdgeWrapping2]: gl.CLAMP_TO_EDGE,\n      [MirroredRepeatWrapping2]: \
gl.MIRRORED_REPEAT\n    };\n    filterToGL = {\n      [NearestFilter2]: \
gl.NEAREST,\n      [NearestMipmapNearestFilter2]: \
gl.NEAREST_MIPMAP_NEAREST,\n      [NearestMipmapLinearFilter2]: \
gl.NEAREST_MIPMAP_LINEAR,\n      [LinearFilter2]: gl.LINEAR,\n      \
[LinearMipmapNearestFilter2]: gl.LINEAR_MIPMAP_NEAREST,\n      \
[LinearMipmapLinearFilter2]: gl.LINEAR_MIPMAP_LINEAR\n    };\n    compareToGL \
= {\n      [NeverCompare2]: gl.NEVER,\n      [AlwaysCompare2]: gl.ALWAYS,\n   \
   [LessCompare2]: gl.LESS,\n      [LessEqualCompare2]: gl.LEQUAL,\n      \
[EqualCompare2]: gl.EQUAL,\n      [GreaterEqualCompare2]: gl.GEQUAL,\n      \
[GreaterCompare2]: gl.GREATER,\n      [NotEqualCompare2]: gl.NOTEQUAL\n    \
};\n  }\n  filterFallback(f) {\n    const { gl } = this;\n    if (f === \
NearestFilter2 || f === NearestMipmapNearestFilter2 || f === \
NearestMipmapLinearFilter2) {\n      return gl.NEAREST;\n    }\n    return \
gl.LINEAR;\n  }\n  getGLTextureType(texture2) {\n    const { gl } = this;\n   \
 let glTextureType;\n    if (texture2.isCubeTexture === true) {\n      \
glTextureType = gl.TEXTURE_CUBE_MAP;\n    } else if \
(texture2.isDataArrayTexture === true || texture2.isCompressedArrayTexture \
=== true) {\n      glTextureType = gl.TEXTURE_2D_ARRAY;\n    } else if \
(texture2.isData3DTexture === true) {\n      glTextureType = gl.TEXTURE_3D;\n \
   } else {\n      glTextureType = gl.TEXTURE_2D;\n    }\n    return \
glTextureType;\n  }\n  getInternalFormat(internalFormatName, glFormat, \
glType, colorSpace, forceLinearTransfer = false) {\n    const { gl, \
extensions } = this;\n    if (internalFormatName !== null) {\n      if \
(gl[internalFormatName] !== void 0) return gl[internalFormatName];\n      \
console.warn(\"THREE.WebGLRenderer: Attempt to use non-existing WebGL \
internal format '\" + internalFormatName + \"'\");\n    }\n    let \
internalFormat = glFormat;\n    if (glFormat === gl.RED) {\n      if (glType \
=== gl.FLOAT) internalFormat = gl.R32F;\n      if (glType === gl.HALF_FLOAT) \
internalFormat = gl.R16F;\n      if (glType === gl.UNSIGNED_BYTE) \
internalFormat = gl.R8;\n      if (glType === gl.UNSIGNED_SHORT) \
internalFormat = gl.R16;\n      if (glType === gl.UNSIGNED_INT) \
internalFormat = gl.R32UI;\n      if (glType === gl.BYTE) internalFormat = \
gl.R8I;\n      if (glType === gl.SHORT) internalFormat = gl.R16I;\n      if \
(glType === gl.INT) internalFormat = gl.R32I;\n    }\n    if (glFormat === \
gl.RED_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = \
gl.R8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = \
gl.R16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;\n \
     if (glType === gl.BYTE) internalFormat = gl.R8I;\n      if (glType === \
gl.SHORT) internalFormat = gl.R16I;\n      if (glType === gl.INT) \
internalFormat = gl.R32I;\n    }\n    if (glFormat === gl.RG) {\n      if \
(glType === gl.FLOAT) internalFormat = gl.RG32F;\n      if (glType === \
gl.HALF_FLOAT) internalFormat = gl.RG16F;\n      if (glType === \
gl.UNSIGNED_BYTE) internalFormat = gl.RG8;\n      if (glType === \
gl.UNSIGNED_SHORT) internalFormat = gl.RG16;\n      if (glType === \
gl.UNSIGNED_INT) internalFormat = gl.RG32UI;\n      if (glType === gl.BYTE) \
internalFormat = gl.RG8I;\n      if (glType === gl.SHORT) internalFormat = \
gl.RG16I;\n      if (glType === gl.INT) internalFormat = gl.RG32I;\n    }\n   \
 if (glFormat === gl.RG_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) \
internalFormat = gl.RG8UI;\n      if (glType === gl.UNSIGNED_SHORT) \
internalFormat = gl.RG16UI;\n      if (glType === gl.UNSIGNED_INT) \
internalFormat = gl.RG32UI;\n      if (glType === gl.BYTE) internalFormat = \
gl.RG8I;\n      if (glType === gl.SHORT) internalFormat = gl.RG16I;\n      if \
(glType === gl.INT) internalFormat = gl.RG32I;\n    }\n    if (glFormat === \
gl.RGB) {\n      if (glType === gl.FLOAT) internalFormat = gl.RGB32F;\n      \
if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;\n      if (glType \
=== gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;\n      if (glType === \
gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;\n      if (glType === \
gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;\n      if (glType === gl.BYTE) \
internalFormat = gl.RGB8I;\n      if (glType === gl.SHORT) internalFormat = \
gl.RGB16I;\n      if (glType === gl.INT) internalFormat = gl.RGB32I;\n      \
if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === \
SRGBColorSpace2 && forceLinearTransfer === false ? gl.SRGB8 : gl.RGB8;\n      \
if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;\n      if \
(glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;\n      if \
(glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;\n      if \
(glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;\n    \
}\n    if (glFormat === gl.RGB_INTEGER) {\n      if (glType === \
gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;\n      if (glType === \
gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;\n      if (glType === \
gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;\n      if (glType === gl.BYTE) \
internalFormat = gl.RGB8I;\n      if (glType === gl.SHORT) internalFormat = \
gl.RGB16I;\n      if (glType === gl.INT) internalFormat = gl.RGB32I;\n    }\n \
   if (glFormat === gl.RGBA) {\n      if (glType === gl.FLOAT) internalFormat \
= gl.RGBA32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = \
gl.RGBA16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = \
gl.RGBA8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = \
gl.RGBA16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = \
gl.RGBA32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;\n     \
 if (glType === gl.SHORT) internalFormat = gl.RGBA16I;\n      if (glType === \
gl.INT) internalFormat = gl.RGBA32I;\n      if (glType === gl.UNSIGNED_BYTE) \
internalFormat = colorSpace === SRGBColorSpace2 && forceLinearTransfer === \
false ? gl.SRGB8_ALPHA8 : gl.RGBA8;\n      if (glType === \
gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;\n      if (glType === \
gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;\n    }\n    if \
(glFormat === gl.RGBA_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) \
internalFormat = gl.RGBA8UI;\n      if (glType === gl.UNSIGNED_SHORT) \
internalFormat = gl.RGBA16UI;\n      if (glType === gl.UNSIGNED_INT) \
internalFormat = gl.RGBA32UI;\n      if (glType === gl.BYTE) internalFormat = \
gl.RGBA8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;\n     \
 if (glType === gl.INT) internalFormat = gl.RGBA32I;\n    }\n    if (glFormat \
=== gl.DEPTH_COMPONENT) {\n      if (glType === gl.UNSIGNED_INT) \
internalFormat = gl.DEPTH24_STENCIL8;\n      if (glType === gl.FLOAT) \
internalFormat = gl.DEPTH_COMPONENT32F;\n    }\n    if (glFormat === \
gl.DEPTH_STENCIL) {\n      if (glType === gl.UNSIGNED_INT_24_8) \
internalFormat = gl.DEPTH24_STENCIL8;\n    }\n    if (internalFormat === \
gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || \
internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || \
internalFormat === gl.RGBA32F) {\n      \
extensions.get(\"EXT_color_buffer_float\");\n    }\n    return \
internalFormat;\n  }\n  setTextureParameters(textureType, texture2) {\n    \
const { gl, extensions, backend } = this;\n    \
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture2.flipY);\n    \
gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, \
texture2.premultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, \
texture2.unpackAlignment);\n    \
gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    \
gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, \
wrappingToGL[texture2.wrapS]);\n    gl.texParameteri(textureType, \
gl.TEXTURE_WRAP_T, wrappingToGL[texture2.wrapT]);\n    if (textureType === \
gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {\n      \
gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, \
wrappingToGL[texture2.wrapR]);\n    }\n    gl.texParameteri(textureType, \
gl.TEXTURE_MAG_FILTER, filterToGL[texture2.magFilter]);\n    const hasMipmaps \
= texture2.mipmaps !== void 0 && texture2.mipmaps.length > 0;\n    const \
minFilter = texture2.minFilter === LinearFilter2 && hasMipmaps ? \
LinearMipmapLinearFilter2 : texture2.minFilter;\n    \
gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, \
filterToGL[minFilter]);\n    if (texture2.compareFunction) {\n      \
gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, \
gl.COMPARE_REF_TO_TEXTURE);\n      gl.texParameteri(textureType, \
gl.TEXTURE_COMPARE_FUNC, compareToGL[texture2.compareFunction]);\n    }\n    \
if (extensions.has(\"EXT_texture_filter_anisotropic\") === true) {\n      if \
(texture2.magFilter === NearestFilter2) return;\n      if (texture2.minFilter \
!== NearestMipmapLinearFilter2 && texture2.minFilter !== \
LinearMipmapLinearFilter2) return;\n      if (texture2.type === FloatType2 && \
extensions.has(\"OES_texture_float_linear\") === false) return;\n      if \
(texture2.anisotropy > 1) {\n        const extension = \
extensions.get(\"EXT_texture_filter_anisotropic\");\n        \
gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, \
Math.min(texture2.anisotropy, backend.getMaxAnisotropy()));\n      }\n    }\n \
 }\n  createDefaultTexture(texture2) {\n    const { gl, backend, \
defaultTextures } = this;\n    const glTextureType = \
this.getGLTextureType(texture2);\n    let textureGPU = \
defaultTextures[glTextureType];\n    if (textureGPU === void 0) {\n      \
textureGPU = gl.createTexture();\n      \
backend.state.bindTexture(glTextureType, textureGPU);\n      \
gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      \
gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      \
defaultTextures[glTextureType] = textureGPU;\n    }\n    \
backend.set(texture2, {\n      textureGPU,\n      glTextureType,\n      \
isDefault: true\n    });\n  }\n  createTexture(texture2, options) {\n    \
const { gl, backend } = this;\n    const { levels, width, height, depth: \
depth2 } = options;\n    const glFormat = \
backend.utils.convert(texture2.format, texture2.colorSpace);\n    const \
glType = backend.utils.convert(texture2.type);\n    const glInternalFormat = \
this.getInternalFormat(texture2.internalFormat, glFormat, glType, \
texture2.colorSpace, texture2.isVideoTexture);\n    const textureGPU = \
gl.createTexture();\n    const glTextureType = \
this.getGLTextureType(texture2);\n    \
backend.state.bindTexture(glTextureType, textureGPU);\n    \
this.setTextureParameters(glTextureType, texture2);\n    if \
(texture2.isDataArrayTexture || texture2.isCompressedArrayTexture) {\n      \
gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, \
depth2);\n    } else if (texture2.isData3DTexture) {\n      \
gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, \
depth2);\n    } else if (!texture2.isVideoTexture) {\n      \
gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);\n    \
}\n    backend.set(texture2, {\n      textureGPU,\n      glTextureType,\n     \
 glFormat,\n      glType,\n      glInternalFormat\n    });\n  }\n  \
copyBufferToTexture(buffer2, texture2) {\n    const { gl, backend } = this;\n \
   const { textureGPU, glTextureType, glFormat, glType } = \
backend.get(texture2);\n    const { width, height } = texture2.source.data;\n \
   gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer2);\n    \
backend.state.bindTexture(glTextureType, textureGPU);\n    \
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    \
gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    \
gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, \
0);\n    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);\n    \
backend.state.unbindTexture();\n  }\n  updateTexture(texture2, options) {\n   \
 const { gl } = this;\n    const { width, height } = options;\n    const { \
textureGPU, glTextureType, glFormat, glType, glInternalFormat } = \
this.backend.get(texture2);\n    if (texture2.isRenderTargetTexture || \
textureGPU === void 0)\n      return;\n    const getImage = (source) => {\n   \
   if (source.isDataTexture) {\n        return source.image.data;\n      } \
else if (source instanceof ImageBitmap || source instanceof OffscreenCanvas \
|| source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) \
{\n        return source;\n      }\n      return source.data;\n    };\n    \
this.backend.state.bindTexture(glTextureType, textureGPU);\n    \
this.setTextureParameters(glTextureType, texture2);\n    if \
(texture2.isCompressedTexture) {\n      const mipmaps = texture2.mipmaps;\n   \
   const image = options.image;\n      for (let i = 0; i < mipmaps.length; \
i++) {\n        const mipmap = mipmaps[i];\n        if \
(texture2.isCompressedArrayTexture) {\n          if (texture2.format !== \
gl.RGBA) {\n            if (glFormat !== null) {\n              \
gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, \
mipmap.height, image.depth, glFormat, mipmap.data);\n            } else {\n   \
           console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported \
compressed texture format in .uploadTexture()\");\n            }\n          } \
else {\n            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, \
mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);\n   \
       }\n        } else {\n          if (glFormat !== null) {\n            \
gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, \
mipmap.height, glFormat, mipmap.data);\n          } else {\n            \
console.warn(\"Unsupported compressed texture format\");\n          }\n       \
 }\n      }\n    } else if (texture2.isCubeTexture) {\n      const images = \
options.images;\n      for (let i = 0; i < 6; i++) {\n        const image = \
getImage(images[i]);\n        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X \
+ i, 0, 0, 0, width, height, glFormat, glType, image);\n      }\n    } else \
if (texture2.isDataArrayTexture) {\n      const image = options.image;\n      \
gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, \
image.depth, glFormat, glType, image.data);\n    } else if \
(texture2.isData3DTexture) {\n      const image = options.image;\n      \
gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, \
image.depth, glFormat, glType, image.data);\n    } else if \
(texture2.isVideoTexture) {\n      texture2.update();\n      \
gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, \
options.image);\n    } else {\n      const image = getImage(options.image);\n \
     gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, \
glType, image);\n    }\n  }\n  generateMipmaps(texture2) {\n    const { gl, \
backend } = this;\n    const { textureGPU, glTextureType } = \
backend.get(texture2);\n    backend.state.bindTexture(glTextureType, \
textureGPU);\n    gl.generateMipmap(glTextureType);\n  }\n  \
deallocateRenderBuffers(renderTarget) {\n    const { gl, backend } = this;\n  \
  if (renderTarget) {\n      const renderContextData = \
backend.get(renderTarget);\n      renderContextData.renderBufferStorageSetup \
= void 0;\n      if (renderContextData.framebuffers) {\n        for (const \
cacheKey in renderContextData.framebuffers) {\n          \
gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);\n        }\n  \
      delete renderContextData.framebuffers;\n      }\n      if \
(renderContextData.depthRenderbuffer) {\n        \
gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);\n        delete \
renderContextData.depthRenderbuffer;\n      }\n      if \
(renderContextData.stencilRenderbuffer) {\n        \
gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);\n        delete \
renderContextData.stencilRenderbuffer;\n      }\n      if \
(renderContextData.msaaFrameBuffer) {\n        \
gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);\n        delete \
renderContextData.msaaFrameBuffer;\n      }\n      if \
(renderContextData.msaaRenderbuffers) {\n        for (let i = 0; i < \
renderContextData.msaaRenderbuffers.length; i++) {\n          \
gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);\n        }\n   \
     delete renderContextData.msaaRenderbuffers;\n      }\n    }\n  }\n  \
destroyTexture(texture2) {\n    const { gl, backend } = this;\n    const { \
textureGPU, renderTarget } = backend.get(texture2);\n    \
this.deallocateRenderBuffers(renderTarget);\n    \
gl.deleteTexture(textureGPU);\n    backend.delete(texture2);\n  }\n  \
copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = \
null, level = 0) {\n    const { gl, backend } = this;\n    const { state } = \
this.backend;\n    const { textureGPU: dstTextureGPU, glTextureType, glType, \
glFormat } = backend.get(dstTexture);\n    let width, height, minX, minY;\n   \
 let dstX, dstY;\n    if (srcRegion !== null) {\n      width = \
srcRegion.max.x - srcRegion.min.x;\n      height = srcRegion.max.y - \
srcRegion.min.y;\n      minX = srcRegion.min.x;\n      minY = \
srcRegion.min.y;\n    } else {\n      width = srcTexture.image.width;\n      \
height = srcTexture.image.height;\n      minX = 0;\n      minY = 0;\n    }\n  \
  if (dstPosition !== null) {\n      dstX = dstPosition.x;\n      dstY = \
dstPosition.y;\n    } else {\n      dstX = 0;\n      dstY = 0;\n    }\n    \
state.bindTexture(glTextureType, dstTextureGPU);\n    \
gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n    \
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n    \
gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, \
dstTexture.premultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, \
dstTexture.unpackAlignment);\n    const currentUnpackRowLen = \
gl.getParameter(gl.UNPACK_ROW_LENGTH);\n    const currentUnpackImageHeight = \
gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);\n    const currentUnpackSkipPixels = \
gl.getParameter(gl.UNPACK_SKIP_PIXELS);\n    const currentUnpackSkipRows = \
gl.getParameter(gl.UNPACK_SKIP_ROWS);\n    const currentUnpackSkipImages = \
gl.getParameter(gl.UNPACK_SKIP_IMAGES);\n    const image = \
srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : \
srcTexture.image;\n    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);\n   \
 gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);\n    \
gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);\n    \
gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);\n    if \
(srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {\n      \
const srcTextureData = backend.get(srcTexture);\n      const dstTextureData = \
backend.get(dstTexture);\n      const srcRenderContextData = \
backend.get(srcTextureData.renderTarget);\n      const dstRenderContextData = \
backend.get(dstTextureData.renderTarget);\n      const srcFramebuffer = \
srcRenderContextData.framebuffers[srcTextureData.cacheKey];\n      const \
dstFramebuffer = \
dstRenderContextData.framebuffers[dstTextureData.cacheKey];\n      \
state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);\n      \
state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);\n      let mask = \
gl.COLOR_BUFFER_BIT;\n      if (srcTexture.isDepthTexture) mask = \
gl.DEPTH_BUFFER_BIT;\n      gl.blitFramebuffer(minX, minY, width, height, \
dstX, dstY, width, height, mask, gl.NEAREST);\n      \
state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n      \
state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n    } else {\n      if \
(srcTexture.isDataTexture) {\n        gl.texSubImage2D(gl.TEXTURE_2D, level, \
dstX, dstY, width, height, glFormat, glType, image.data);\n      } else {\n   \
     if (srcTexture.isCompressedTexture) {\n          \
gl.compressedTexSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, image.width, \
image.height, glFormat, image.data);\n        } else {\n          \
gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, \
glType, image);\n        }\n      }\n    }\n    \
gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);\n    \
gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);\n    \
gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);\n    \
gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);\n    \
gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);\n    if \
(level === 0 && dstTexture.generateMipmaps) \
gl.generateMipmap(gl.TEXTURE_2D);\n    state.unbindTexture();\n  }\n  \
copyFramebufferToTexture(texture2, renderContext, rectangle) {\n    const { \
gl } = this;\n    const { state } = this.backend;\n    const { textureGPU } = \
this.backend.get(texture2);\n    const { x: x2, y: y2, z: width, w: height } \
= rectangle;\n    const requireDrawFrameBuffer = texture2.isDepthTexture === \
true || renderContext.renderTarget && renderContext.renderTarget.samples > \
0;\n    const srcHeight = renderContext.renderTarget ? \
renderContext.renderTarget.height : this.backend.gerDrawingBufferSize().y;\n  \
  if (requireDrawFrameBuffer) {\n      const partial = x2 !== 0 || y2 !== \
0;\n      let mask;\n      let attachment;\n      if (texture2.isDepthTexture \
=== true) {\n        mask = gl.DEPTH_BUFFER_BIT;\n        attachment = \
gl.DEPTH_ATTACHMENT;\n        if (renderContext.stencil) {\n          mask |= \
gl.STENCIL_BUFFER_BIT;\n        }\n      } else {\n        mask = \
gl.COLOR_BUFFER_BIT;\n        attachment = gl.COLOR_ATTACHMENT0;\n      }\n   \
   if (partial) {\n        const renderTargetContextData = \
this.backend.get(renderContext.renderTarget);\n        const fb = \
renderTargetContextData.framebuffers[renderContext.getCacheKey()];\n        \
const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n        \
state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        \
state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);\n        const \
flippedY = srcHeight - y2 - height;\n        gl.blitFramebuffer(x2, flippedY, \
x2 + width, flippedY + height, x2, flippedY, x2 + width, flippedY + height, \
mask, gl.NEAREST);\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);\n \
       state.bindTexture(gl.TEXTURE_2D, textureGPU);\n        \
gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x2, flippedY, width, height);\n  \
      state.unbindTexture();\n      } else {\n        const fb = \
gl.createFramebuffer();\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, \
fb);\n        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, \
gl.TEXTURE_2D, textureGPU, 0);\n        gl.blitFramebuffer(0, 0, width, \
height, 0, 0, width, height, mask, gl.NEAREST);\n        \
gl.deleteFramebuffer(fb);\n      }\n    } else {\n      \
state.bindTexture(gl.TEXTURE_2D, textureGPU);\n      \
gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x2, srcHeight - height - y2, \
width, height);\n      state.unbindTexture();\n    }\n    if \
(texture2.generateMipmaps) this.generateMipmaps(texture2);\n    \
this.backend._setFramebuffer(renderContext);\n  }\n  // Setup storage for \
internal depth/stencil buffers and bind to correct framebuffer\n  \
setupRenderBufferStorage(renderbuffer, renderContext) {\n    const { gl } = \
this;\n    const renderTarget = renderContext.renderTarget;\n    const { \
samples, depthTexture, depthBuffer, stencilBuffer, width, height } = \
renderTarget;\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n    \
if (depthBuffer && !stencilBuffer) {\n      let glInternalFormat = \
gl.DEPTH_COMPONENT24;\n      if (samples > 0) {\n        if (depthTexture && \
depthTexture.isDepthTexture) {\n          if (depthTexture.type === gl.FLOAT) \
{\n            glInternalFormat = gl.DEPTH_COMPONENT32F;\n          }\n       \
 }\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, \
glInternalFormat, width, height);\n      } else {\n        \
gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);\n   \
   }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, \
gl.RENDERBUFFER, renderbuffer);\n    } else if (depthBuffer && stencilBuffer) \
{\n      if (samples > 0) {\n        \
gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, \
gl.DEPTH24_STENCIL8, width, height);\n      } else {\n        \
gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n   \
   }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, \
gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n    }\n  }\n  \
async copyTextureToBuffer(texture2, x2, y2, width, height, faceIndex) {\n    \
const { backend, gl } = this;\n    const { textureGPU, glFormat, glType } = \
this.backend.get(texture2);\n    const fb = gl.createFramebuffer();\n    \
gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);\n    const target = \
texture2.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : \
gl.TEXTURE_2D;\n    gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, \
gl.COLOR_ATTACHMENT0, target, textureGPU, 0);\n    const typedArrayType = \
this._getTypedArrayType(glType);\n    const bytesPerTexel = \
this._getBytesPerTexel(glType, glFormat);\n    const elementCount = width * \
height;\n    const byteLength = elementCount * bytesPerTexel;\n    const \
buffer2 = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, \
buffer2);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, \
gl.STREAM_READ);\n    gl.readPixels(x2, y2, width, height, glFormat, glType, \
0);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    await \
backend.utils._clientWaitAsync();\n    const dstBuffer = new \
typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);\n    \
gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer2);\n    \
gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);\n    \
gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    gl.deleteFramebuffer(fb);\n   \
 return dstBuffer;\n  }\n  _getTypedArrayType(glType) {\n    const { gl } = \
this;\n    if (glType === gl.UNSIGNED_BYTE) return Uint8Array;\n    if \
(glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;\n    if (glType \
=== gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;\n    if (glType === \
gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;\n    if (glType === \
gl.UNSIGNED_SHORT) return Uint16Array;\n    if (glType === gl.UNSIGNED_INT) \
return Uint32Array;\n    if (glType === gl.HALF_FLOAT) return Uint16Array;\n  \
  if (glType === gl.FLOAT) return Float32Array;\n    throw new \
Error(`Unsupported WebGL type: ${glType}`);\n  }\n  _getBytesPerTexel(glType, \
glFormat) {\n    const { gl } = this;\n    let bytesPerComponent = 0;\n    if \
(glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;\n    if (glType === \
gl.UNSIGNED_SHORT_4_4_4_4 || glType === gl.UNSIGNED_SHORT_5_5_5_1 || glType \
=== gl.UNSIGNED_SHORT_5_6_5 || glType === gl.UNSIGNED_SHORT || glType === \
gl.HALF_FLOAT) bytesPerComponent = 2;\n    if (glType === gl.UNSIGNED_INT || \
glType === gl.FLOAT) bytesPerComponent = 4;\n    if (glFormat === gl.RGBA) \
return bytesPerComponent * 4;\n    if (glFormat === gl.RGB) return \
bytesPerComponent * 3;\n    if (glFormat === gl.ALPHA) return \
bytesPerComponent;\n  }\n};\nvar WebGLExtensions2 = class {\n  \
constructor(backend) {\n    this.backend = backend;\n    this.gl = \
this.backend.gl;\n    this.availableExtensions = \
this.gl.getSupportedExtensions();\n    this.extensions = {};\n  }\n  \
get(name) {\n    let extension = this.extensions[name];\n    if (extension \
=== void 0) {\n      extension = this.gl.getExtension(name);\n      \
this.extensions[name] = extension;\n    }\n    return extension;\n  }\n  \
has(name) {\n    return this.availableExtensions.includes(name);\n  \
}\n};\nvar WebGLCapabilities2 = class {\n  constructor(backend) {\n    \
this.backend = backend;\n    this.maxAnisotropy = null;\n  }\n  \
getMaxAnisotropy() {\n    if (this.maxAnisotropy !== null) return \
this.maxAnisotropy;\n    const gl = this.backend.gl;\n    const extensions = \
this.backend.extensions;\n    if \
(extensions.has(\"EXT_texture_filter_anisotropic\") === true) {\n      const \
extension = extensions.get(\"EXT_texture_filter_anisotropic\");\n      \
this.maxAnisotropy = \
gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n    \
  this.maxAnisotropy = 0;\n    }\n    return this.maxAnisotropy;\n  \
}\n};\nvar GLFeatureName = {\n  \"WEBGL_multi_draw\": \"WEBGL_multi_draw\",\n \
 \"WEBGL_compressed_texture_astc\": \"texture-compression-astc\",\n  \
\"WEBGL_compressed_texture_etc\": \"texture-compression-etc2\",\n  \
\"WEBGL_compressed_texture_etc1\": \"texture-compression-etc1\",\n  \
\"WEBGL_compressed_texture_pvrtc\": \"texture-compression-pvrtc\",\n  \
\"WEBKIT_WEBGL_compressed_texture_pvrtc\": \"texture-compression-pvrtc\",\n  \
\"WEBGL_compressed_texture_s3tc\": \"texture-compression-bc\",\n  \
\"EXT_texture_compression_bptc\": \"texture-compression-bptc\",\n  \
\"EXT_disjoint_timer_query_webgl2\": \"timestamp-query\"\n};\nvar \
WebGLBufferRenderer2 = class {\n  constructor(backend) {\n    this.gl = \
backend.gl;\n    this.extensions = backend.extensions;\n    this.info = \
backend.renderer.info;\n    this.mode = null;\n    this.index = 0;\n    \
this.type = null;\n    this.object = null;\n  }\n  render(start, count) {\n   \
 const { gl, mode, object, type, info, index: index5 } = this;\n    if \
(index5 !== 0) {\n      gl.drawElements(mode, count, type, start);\n    } \
else {\n      gl.drawArrays(mode, start, count);\n    }\n    \
info.update(object, count, mode, 1);\n  }\n  renderInstances(start, count, \
primcount) {\n    const { gl, mode, type, index: index5, object, info } = \
this;\n    if (primcount === 0) return;\n    if (index5 !== 0) {\n      \
gl.drawElementsInstanced(mode, count, type, start, primcount);\n    } else \
{\n      gl.drawArraysInstanced(mode, start, count, primcount);\n    }\n    \
info.update(object, count, mode, primcount);\n  }\n  renderMultiDraw(starts, \
counts, drawCount) {\n    const { extensions, mode, object, info } = this;\n  \
  if (drawCount === 0) return;\n    const extension = \
extensions.get(\"WEBGL_multi_draw\");\n    if (extension === null) {\n      \
for (let i = 0; i < drawCount; i++) {\n        this.render(starts[i], \
counts[i]);\n      }\n    } else {\n      if (this.index !== 0) {\n        \
extension.multiDrawElementsWEBGL(mode, counts, 0, this.type, starts, 0, \
drawCount);\n      } else {\n        extension.multiDrawArraysWEBGL(mode, \
starts, 0, counts, 0, drawCount);\n      }\n      let elementCount = 0;\n     \
 for (let i = 0; i < drawCount; i++) {\n        elementCount += counts[i];\n  \
    }\n      info.update(object, elementCount, mode, 1);\n    }\n  }\n  \
renderMultiDrawInstances(starts, counts, drawCount, primcount) {\n    const { \
extensions, mode, object, info } = this;\n    if (drawCount === 0) return;\n  \
  const extension = extensions.get(\"WEBGL_multi_draw\");\n    if (extension \
=== null) {\n      for (let i = 0; i < drawCount; i++) {\n        \
this.renderInstances(starts[i], counts[i], primcount[i]);\n      }\n    } \
else {\n      if (this.index !== 0) {\n        \
extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, this.type, starts, \
0, primcount, 0, drawCount);\n      } else {\n        \
extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, \
primcount, 0, drawCount);\n      }\n      let elementCount = 0;\n      for \
(let i = 0; i < drawCount; i++) {\n        elementCount += counts[i] * \
primcount[i];\n      }\n      info.update(object, elementCount, mode, 1);\n   \
 }\n  }\n  //\n};\nvar WebGLBackend = class extends Backend {\n  \
constructor(parameters = {}) {\n    super(parameters);\n    \
this.isWebGLBackend = true;\n  }\n  init(renderer3) {\n    \
super.init(renderer3);\n    const parameters = this.parameters;\n    const \
glContext = parameters.context !== void 0 ? parameters.context : \
renderer3.domElement.getContext(\"webgl2\");\n    function \
onContextLost(event) {\n      event.preventDefault();\n      const \
contextLossInfo = {\n        api: \"WebGL\",\n        message: \
event.statusMessage || \"Unknown reason\",\n        reason: null,\n        \
originalEvent: event\n      };\n      \
renderer3.onDeviceLost(contextLossInfo);\n    }\n    this._onContextLost = \
onContextLost;\n    \
renderer3.domElement.addEventListener(\"webglcontextlost\", onContextLost, \
false);\n    this.gl = glContext;\n    this.extensions = new \
WebGLExtensions2(this);\n    this.capabilities = new \
WebGLCapabilities2(this);\n    this.attributeUtils = new \
WebGLAttributeUtils(this);\n    this.textureUtils = new \
WebGLTextureUtils(this);\n    this.bufferRenderer = new \
WebGLBufferRenderer2(this);\n    this.state = new WebGLState2(this);\n    \
this.utils = new WebGLUtils2(this);\n    this.vaoCache = {};\n    \
this.transformFeedbackCache = {};\n    this.discard = false;\n    \
this.trackTimestamp = parameters.trackTimestamp === true;\n    \
this.extensions.get(\"EXT_color_buffer_float\");\n    \
this.extensions.get(\"WEBGL_clip_cull_distance\");\n    \
this.extensions.get(\"OES_texture_float_linear\");\n    \
this.extensions.get(\"EXT_color_buffer_half_float\");\n    \
this.extensions.get(\"WEBGL_multisampled_render_to_texture\");\n    \
this.extensions.get(\"WEBGL_render_shared_exponent\");\n    \
this.extensions.get(\"WEBGL_multi_draw\");\n    this.disjoint = \
this.extensions.get(\"EXT_disjoint_timer_query_webgl2\");\n    this.parallel \
= this.extensions.get(\"KHR_parallel_shader_compile\");\n    \
this._knownBindings = /* @__PURE__ */ new WeakSet();\n    \
this._currentContext = null;\n  }\n  get coordinateSystem() {\n    return \
WebGLCoordinateSystem2;\n  }\n  async getArrayBufferAsync(attribute2) {\n    \
return await this.attributeUtils.getArrayBufferAsync(attribute2);\n  }\n  \
async waitForGPU() {\n    await this.utils._clientWaitAsync();\n  }\n  \
initTimestampQuery(renderContext) {\n    if (!this.disjoint || \
!this.trackTimestamp) return;\n    const renderContextData = \
this.get(renderContext);\n    if (this.queryRunning) {\n      if \
(!renderContextData.queryQueue) renderContextData.queryQueue = [];\n      \
renderContextData.queryQueue.push(renderContext);\n      return;\n    }\n    \
if (renderContextData.activeQuery) {\n      \
this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);\n      \
renderContextData.activeQuery = null;\n    }\n    \
renderContextData.activeQuery = this.gl.createQuery();\n    if \
(renderContextData.activeQuery !== null) {\n      \
this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, \
renderContextData.activeQuery);\n      this.queryRunning = true;\n    }\n  \
}\n  // timestamp utils\n  prepareTimestampBuffer(renderContext) {\n    if \
(!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData \
= this.get(renderContext);\n    if (renderContextData.activeQuery) {\n      \
this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);\n      if \
(!renderContextData.gpuQueries) renderContextData.gpuQueries = [];\n      \
renderContextData.gpuQueries.push({ query: renderContextData.activeQuery \
});\n      renderContextData.activeQuery = null;\n      this.queryRunning = \
false;\n      if (renderContextData.queryQueue && \
renderContextData.queryQueue.length > 0) {\n        const nextRenderContext = \
renderContextData.queryQueue.shift();\n        \
this.initTimestampQuery(nextRenderContext);\n      }\n    }\n  }\n  async \
resolveTimestampAsync(renderContext, type = \"render\") {\n    if \
(!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData \
= this.get(renderContext);\n    if (!renderContextData.gpuQueries) \
renderContextData.gpuQueries = [];\n    for (let i = 0; i < \
renderContextData.gpuQueries.length; i++) {\n      const queryInfo = \
renderContextData.gpuQueries[i];\n      const available = \
this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);\n \
     const disjoint = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);\n \
     if (available && !disjoint) {\n        const elapsed = \
this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);\n        \
const duration = Number(elapsed) / 1e6;\n        \
this.gl.deleteQuery(queryInfo.query);\n        \
renderContextData.gpuQueries.splice(i, 1);\n        i--;\n        \
this.renderer.info.updateTimestamp(type, duration);\n      }\n    }\n  }\n  \
getContext() {\n    return this.gl;\n  }\n  beginRender(renderContext) {\n    \
const { gl } = this;\n    const renderContextData = \
this.get(renderContext);\n    this.initTimestampQuery(renderContext);\n    \
renderContextData.previousContext = this._currentContext;\n    \
this._currentContext = renderContext;\n    \
this._setFramebuffer(renderContext);\n    \
this.clear(renderContext.clearColor, renderContext.clearDepth, \
renderContext.clearStencil, renderContext, false);\n    if \
(renderContext.viewport) {\n      this.updateViewport(renderContext);\n    } \
else {\n      gl.viewport(0, 0, gl.drawingBufferWidth, \
gl.drawingBufferHeight);\n    }\n    if (renderContext.scissor) {\n      \
const { x: x2, y: y2, width, height } = renderContext.scissorValue;\n      \
gl.scissor(x2, renderContext.height - height - y2, width, height);\n    }\n   \
 const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if \
(occlusionQueryCount > 0) {\n      renderContextData.currentOcclusionQueries \
= renderContextData.occlusionQueries;\n      \
renderContextData.currentOcclusionQueryObjects = \
renderContextData.occlusionQueryObjects;\n      \
renderContextData.lastOcclusionObject = null;\n      \
renderContextData.occlusionQueries = new Array(occlusionQueryCount);\n      \
renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);\n   \
   renderContextData.occlusionQueryIndex = 0;\n    }\n  }\n  \
finishRender(renderContext) {\n    const { gl, state } = this;\n    const \
renderContextData = this.get(renderContext);\n    const previousContext = \
renderContextData.previousContext;\n    const occlusionQueryCount = \
renderContext.occlusionQueryCount;\n    if (occlusionQueryCount > 0) {\n      \
if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {\n        \
gl.endQuery(gl.ANY_SAMPLES_PASSED);\n      }\n      \
this.resolveOccludedAsync(renderContext);\n    }\n    const textures = \
renderContext.textures;\n    if (textures !== null) {\n      for (let i = 0; \
i < textures.length; i++) {\n        const texture2 = textures[i];\n        \
if (texture2.generateMipmaps) {\n          this.generateMipmaps(texture2);\n  \
      }\n      }\n    }\n    this._currentContext = previousContext;\n    if \
(renderContext.textures !== null && renderContext.renderTarget) {\n      \
const renderTargetContextData = this.get(renderContext.renderTarget);\n      \
const { samples } = renderContext.renderTarget;\n      if (samples > 0) {\n   \
     const fb = \
renderTargetContextData.framebuffers[renderContext.getCacheKey()];\n        \
const mask = gl.COLOR_BUFFER_BIT;\n        const msaaFrameBuffer = \
renderTargetContextData.msaaFrameBuffer;\n        const textures2 = \
renderContext.textures;\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, \
msaaFrameBuffer);\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n  \
      for (let i = 0; i < textures2.length; i++) {\n          if \
(renderContext.scissor) {\n            const { x: x2, y: y2, width, height } \
= renderContext.scissorValue;\n            const viewY = renderContext.height \
- height - y2;\n            gl.blitFramebuffer(x2, viewY, x2 + width, viewY + \
height, x2, viewY, x2 + width, viewY + height, mask, gl.NEAREST);\n           \
 gl.invalidateSubFramebuffer(gl.READ_FRAMEBUFFER, \
renderTargetContextData.invalidationArray, x2, viewY, width, height);\n       \
   } else {\n            gl.blitFramebuffer(0, 0, renderContext.width, \
renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, \
gl.NEAREST);\n            gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, \
renderTargetContextData.invalidationArray);\n          }\n        }\n      \
}\n    }\n    if (previousContext !== null) {\n      \
this._setFramebuffer(previousContext);\n      if (previousContext.viewport) \
{\n        this.updateViewport(previousContext);\n      } else {\n        \
gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      }\n  \
  }\n    this.prepareTimestampBuffer(renderContext);\n  }\n  \
resolveOccludedAsync(renderContext) {\n    const renderContextData = \
this.get(renderContext);\n    const { currentOcclusionQueries, \
currentOcclusionQueryObjects } = renderContextData;\n    if \
(currentOcclusionQueries && currentOcclusionQueryObjects) {\n      const \
occluded = /* @__PURE__ */ new WeakSet();\n      const { gl } = this;\n      \
renderContextData.currentOcclusionQueryObjects = null;\n      \
renderContextData.currentOcclusionQueries = null;\n      const check = () => \
{\n        let completed = 0;\n        for (let i = 0; i < \
currentOcclusionQueries.length; i++) {\n          const query = \
currentOcclusionQueries[i];\n          if (query === null) continue;\n        \
  if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {\n            \
if (gl.getQueryParameter(query, gl.QUERY_RESULT) > 0) \
occluded.add(currentOcclusionQueryObjects[i]);\n            \
currentOcclusionQueries[i] = null;\n            gl.deleteQuery(query);\n      \
      completed++;\n          }\n        }\n        if (completed < \
currentOcclusionQueries.length) {\n          requestAnimationFrame(check);\n  \
      } else {\n          renderContextData.occluded = occluded;\n        }\n \
     };\n      check();\n    }\n  }\n  isOccluded(renderContext, object) {\n  \
  const renderContextData = this.get(renderContext);\n    return \
renderContextData.occluded && renderContextData.occluded.has(object);\n  }\n  \
updateViewport(renderContext) {\n    const gl = this.gl;\n    const { x: x2, \
y: y2, width, height } = renderContext.viewportValue;\n    gl.viewport(x2, \
renderContext.height - height - y2, width, height);\n  }\n  \
setScissorTest(boolean) {\n    const gl = this.gl;\n    if (boolean) {\n      \
gl.enable(gl.SCISSOR_TEST);\n    } else {\n      \
gl.disable(gl.SCISSOR_TEST);\n    }\n  }\n  clear(color2, depth2, stencil, \
descriptor = null, setFrameBuffer = true) {\n    const { gl } = this;\n    if \
(descriptor === null) {\n      const clearColor = this.getClearColor();\n     \
 clearColor.r *= clearColor.a;\n      clearColor.g *= clearColor.a;\n      \
clearColor.b *= clearColor.a;\n      descriptor = {\n        textures: \
null,\n        clearColorValue: clearColor\n      };\n    }\n    let clear = \
0;\n    if (color2) clear |= gl.COLOR_BUFFER_BIT;\n    if (depth2) clear |= \
gl.DEPTH_BUFFER_BIT;\n    if (stencil) clear |= gl.STENCIL_BUFFER_BIT;\n    \
if (clear !== 0) {\n      let clearColor;\n      if \
(descriptor.clearColorValue) {\n        clearColor = \
descriptor.clearColorValue;\n      } else {\n        clearColor = \
this.getClearColor();\n        clearColor.r *= clearColor.a;\n        \
clearColor.g *= clearColor.a;\n        clearColor.b *= clearColor.a;\n      \
}\n      if (depth2) this.state.setDepthMask(true);\n      if \
(descriptor.textures === null) {\n        gl.clearColor(clearColor.r, \
clearColor.g, clearColor.b, clearColor.a);\n        gl.clear(clear);\n      } \
else {\n        if (setFrameBuffer) this._setFramebuffer(descriptor);\n       \
 if (color2) {\n          for (let i = 0; i < descriptor.textures.length; \
i++) {\n            gl.clearBufferfv(gl.COLOR, i, [clearColor.r, \
clearColor.g, clearColor.b, clearColor.a]);\n          }\n        }\n        \
if (depth2 && stencil) {\n          gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, \
0);\n        } else if (depth2) {\n          gl.clearBufferfv(gl.DEPTH, 0, \
[1]);\n        } else if (stencil) {\n          gl.clearBufferiv(gl.STENCIL, \
0, [0]);\n        }\n      }\n    }\n  }\n  beginCompute(computeGroup) {\n    \
const { state, gl } = this;\n    state.bindFramebuffer(gl.FRAMEBUFFER, \
null);\n    this.initTimestampQuery(computeGroup);\n  }\n  \
compute(computeGroup, computeNode, bindings, pipeline) {\n    const { state, \
gl } = this;\n    if (!this.discard) {\n      \
gl.enable(gl.RASTERIZER_DISCARD);\n      this.discard = true;\n    }\n    \
const { programGPU, transformBuffers, attributes } = this.get(pipeline);\n    \
const vaoKey = this._getVaoKey(null, attributes);\n    const vaoGPU = \
this.vaoCache[vaoKey];\n    if (vaoGPU === void 0) {\n      \
this._createVao(null, attributes);\n    } else {\n      \
gl.bindVertexArray(vaoGPU);\n    }\n    state.useProgram(programGPU);\n    \
this._bindUniforms(bindings);\n    const transformFeedbackGPU = \
this._getTransformFeedback(transformBuffers);\n    \
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);\n    \
gl.beginTransformFeedback(gl.POINTS);\n    if \
(attributes[0].isStorageInstancedBufferAttribute) {\n      \
gl.drawArraysInstanced(gl.POINTS, 0, 1, computeNode.count);\n    } else {\n   \
   gl.drawArrays(gl.POINTS, 0, computeNode.count);\n    }\n    \
gl.endTransformFeedback();\n    \
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n    for (let i = 0; i \
< transformBuffers.length; i++) {\n      const dualAttributeData = \
transformBuffers[i];\n      if (dualAttributeData.pbo) {\n        \
this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, \
dualAttributeData.pbo);\n      }\n      dualAttributeData.switchBuffers();\n  \
  }\n  }\n  finishCompute(computeGroup) {\n    const gl = this.gl;\n    \
this.discard = false;\n    gl.disable(gl.RASTERIZER_DISCARD);\n    \
this.prepareTimestampBuffer(computeGroup);\n    if (this._currentContext) {\n \
     this._setFramebuffer(this._currentContext);\n    }\n  }\n  \
draw(renderObject) {\n    const { object, pipeline, material, context: \
context2 } = renderObject;\n    const { programGPU } = this.get(pipeline);\n  \
  const { gl, state } = this;\n    const contextData = this.get(context2);\n  \
  const drawParams = renderObject.getDrawParameters();\n    if (drawParams \
=== null) return;\n    this._bindUniforms(renderObject.getBindings());\n    \
const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n  \
  state.setMaterial(material, frontFaceCW);\n    \
state.useProgram(programGPU);\n    let vaoGPU = renderObject.staticVao;\n    \
if (vaoGPU === void 0) {\n      const vaoKey = \
this._getVaoKey(renderObject.getIndex(), renderObject.getAttributes());\n     \
 vaoGPU = this.vaoCache[vaoKey];\n      if (vaoGPU === void 0) {\n        let \
staticVao;\n        ({ vaoGPU, staticVao } = \
this._createVao(renderObject.getIndex(), renderObject.getAttributes()));\n    \
    if (staticVao) renderObject.staticVao = vaoGPU;\n      }\n    }\n    \
gl.bindVertexArray(vaoGPU);\n    const index5 = renderObject.getIndex();\n    \
const lastObject = contextData.lastOcclusionObject;\n    if (lastObject !== \
object && lastObject !== void 0) {\n      if (lastObject !== null && \
lastObject.occlusionTest === true) {\n        \
gl.endQuery(gl.ANY_SAMPLES_PASSED);\n        \
contextData.occlusionQueryIndex++;\n      }\n      if (object.occlusionTest \
=== true) {\n        const query = gl.createQuery();\n        \
gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);\n        \
contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;\n      \
  contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = \
object;\n      }\n      contextData.lastOcclusionObject = object;\n    }\n    \
const renderer3 = this.bufferRenderer;\n    if (object.isPoints) \
renderer3.mode = gl.POINTS;\n    else if (object.isLineSegments) \
renderer3.mode = gl.LINES;\n    else if (object.isLine) renderer3.mode = \
gl.LINE_STRIP;\n    else if (object.isLineLoop) renderer3.mode = \
gl.LINE_LOOP;\n    else {\n      if (material.wireframe === true) {\n        \
state.setLineWidth(material.wireframeLinewidth * \
this.renderer.getPixelRatio());\n        renderer3.mode = gl.LINES;\n      } \
else {\n        renderer3.mode = gl.TRIANGLES;\n      }\n    }\n    const { \
vertexCount, instanceCount } = drawParams;\n    let { firstVertex } = \
drawParams;\n    renderer3.object = object;\n    if (index5 !== null) {\n     \
 firstVertex *= index5.array.BYTES_PER_ELEMENT;\n      const indexData = \
this.get(index5);\n      renderer3.index = index5.count;\n      \
renderer3.type = indexData.type;\n    } else {\n      renderer3.index = 0;\n  \
  }\n    if (object.isBatchedMesh) {\n      if (object._multiDrawInstances \
!== null) {\n        \
renderer3.renderMultiDrawInstances(object._multiDrawStarts, \
object._multiDrawCounts, object._multiDrawCount, \
object._multiDrawInstances);\n      } else if \
(!this.hasFeature(\"WEBGL_multi_draw\")) {\n        \
warnOnce2(\"THREE.WebGLRenderer: WEBGL_multi_draw not supported.\");\n      } \
else {\n        renderer3.renderMultiDraw(object._multiDrawStarts, \
object._multiDrawCounts, object._multiDrawCount);\n      }\n    } else if \
(instanceCount > 1) {\n      renderer3.renderInstances(firstVertex, \
vertexCount, instanceCount);\n    } else {\n      \
renderer3.render(firstVertex, vertexCount);\n    }\n    \
gl.bindVertexArray(null);\n  }\n  needsRenderUpdate() {\n    return false;\n  \
}\n  getRenderCacheKey() {\n    return \"\";\n  }\n  // textures\n  \
createDefaultTexture(texture2) {\n    \
this.textureUtils.createDefaultTexture(texture2);\n  }\n  \
createTexture(texture2, options) {\n    \
this.textureUtils.createTexture(texture2, options);\n  }\n  \
updateTexture(texture2, options) {\n    \
this.textureUtils.updateTexture(texture2, options);\n  }\n  \
generateMipmaps(texture2) {\n    \
this.textureUtils.generateMipmaps(texture2);\n  }\n  destroyTexture(texture2) \
{\n    this.textureUtils.destroyTexture(texture2);\n  }\n  \
copyTextureToBuffer(texture2, x2, y2, width, height, faceIndex) {\n    return \
this.textureUtils.copyTextureToBuffer(texture2, x2, y2, width, height, \
faceIndex);\n  }\n  createSampler() {\n  }\n  destroySampler() {\n  }\n  // \
node builder\n  createNodeBuilder(object, renderer3) {\n    return new \
GLSLNodeBuilder(object, renderer3);\n  }\n  // program\n  \
createProgram(program) {\n    const gl = this.gl;\n    const { stage, code } \
= program;\n    const shader = stage === \"fragment\" ? \
gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);\n    \
gl.shaderSource(shader, code);\n    gl.compileShader(shader);\n    \
this.set(program, {\n      shaderGPU: shader\n    });\n  }\n  \
destroyProgram() {\n    console.warn(\"Abstract class.\");\n  }\n  \
createRenderPipeline(renderObject, promises) {\n    const gl = this.gl;\n    \
const pipeline = renderObject.pipeline;\n    const { fragmentProgram, \
vertexProgram } = pipeline;\n    const programGPU = gl.createProgram();\n    \
const fragmentShader = this.get(fragmentProgram).shaderGPU;\n    const \
vertexShader = this.get(vertexProgram).shaderGPU;\n    \
gl.attachShader(programGPU, fragmentShader);\n    gl.attachShader(programGPU, \
vertexShader);\n    gl.linkProgram(programGPU);\n    this.set(pipeline, {\n   \
   programGPU,\n      fragmentShader,\n      vertexShader\n    });\n    if \
(promises !== null && this.parallel) {\n      const p = new Promise((resolve) \
=> {\n        const parallel = this.parallel;\n        const checkStatus = () \
=> {\n          if (gl.getProgramParameter(programGPU, \
parallel.COMPLETION_STATUS_KHR)) {\n            \
this._completeCompile(renderObject, pipeline);\n            resolve();\n      \
    } else {\n            requestAnimationFrame(checkStatus);\n          }\n  \
      };\n        checkStatus();\n      });\n      promises.push(p);\n      \
return;\n    }\n    this._completeCompile(renderObject, pipeline);\n  }\n  \
_handleSource(string, errorLine) {\n    const lines = \
string.split(\"\\n\");\n    const lines2 = [];\n    const from = \
Math.max(errorLine - 6, 0);\n    const to = Math.min(errorLine + 6, \
lines.length);\n    for (let i = from; i < to; i++) {\n      const line = i + \
1;\n      lines2.push(`${line === errorLine ? \">\" : \" \"} ${line}: \
${lines[i]}`);\n    }\n    return lines2.join(\"\\n\");\n  }\n  \
_getShaderErrors(gl, shader, type) {\n    const status = \
gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    const errors = \
gl.getShaderInfoLog(shader).trim();\n    if (status && errors === \"\") \
return \"\";\n    const errorMatches = /ERROR: 0:(\\d+)/.exec(errors);\n    \
if (errorMatches) {\n      const errorLine = parseInt(errorMatches[1]);\n     \
 return type.toUpperCase() + \"\\n\\n\" + errors + \"\\n\\n\" + \
this._handleSource(gl.getShaderSource(shader), errorLine);\n    } else {\n    \
  return errors;\n    }\n  }\n  _logProgramError(programGPU, \
glFragmentShader, glVertexShader) {\n    if \
(this.renderer.debug.checkShaderErrors) {\n      const gl = this.gl;\n      \
const programLog = gl.getProgramInfoLog(programGPU).trim();\n      if \
(gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n        if \
(typeof this.renderer.debug.onShaderError === \"function\") {\n          \
this.renderer.debug.onShaderError(gl, programGPU, glVertexShader, \
glFragmentShader);\n        } else {\n          const vertexErrors = \
this._getShaderErrors(gl, glVertexShader, \"vertex\");\n          const \
fragmentErrors = this._getShaderErrors(gl, glFragmentShader, \"fragment\");\n \
         console.error(\n            \"THREE.WebGLProgram: Shader Error \" + \
gl.getError() + \" - VALIDATE_STATUS \" + gl.getProgramParameter(programGPU, \
gl.VALIDATE_STATUS) + \"\\n\\nProgram Info Log: \" + programLog + \"\\n\" + \
vertexErrors + \"\\n\" + fragmentErrors\n          );\n        }\n      } \
else if (programLog !== \"\") {\n        console.warn(\"THREE.WebGLProgram: \
Program Info Log:\", programLog);\n      }\n    }\n  }\n  \
_completeCompile(renderObject, pipeline) {\n    const { state, gl } = this;\n \
   const pipelineData = this.get(pipeline);\n    const { programGPU, \
fragmentShader, vertexShader } = pipelineData;\n    if \
(gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n      \
this._logProgramError(programGPU, fragmentShader, vertexShader);\n    }\n    \
state.useProgram(programGPU);\n    const bindings = \
renderObject.getBindings();\n    this._setupBindings(bindings, programGPU);\n \
   this.set(pipeline, {\n      programGPU\n    });\n  }\n  \
createComputePipeline(computePipeline, bindings) {\n    const { state, gl } = \
this;\n    const fragmentProgram = {\n      stage: \"fragment\",\n      code: \
\"#version 300 es\\nprecision highp float;\\nvoid main() {}\"\n    };\n    \
this.createProgram(fragmentProgram);\n    const { computeProgram } = \
computePipeline;\n    const programGPU = gl.createProgram();\n    const \
fragmentShader = this.get(fragmentProgram).shaderGPU;\n    const vertexShader \
= this.get(computeProgram).shaderGPU;\n    const transforms = \
computeProgram.transforms;\n    const transformVaryingNames = [];\n    const \
transformAttributeNodes = [];\n    for (let i = 0; i < transforms.length; \
i++) {\n      const transform = transforms[i];\n      \
transformVaryingNames.push(transform.varyingName);\n      \
transformAttributeNodes.push(transform.attributeNode);\n    }\n    \
gl.attachShader(programGPU, fragmentShader);\n    gl.attachShader(programGPU, \
vertexShader);\n    gl.transformFeedbackVaryings(\n      programGPU,\n      \
transformVaryingNames,\n      gl.SEPARATE_ATTRIBS\n    );\n    \
gl.linkProgram(programGPU);\n    if (gl.getProgramParameter(programGPU, \
gl.LINK_STATUS) === false) {\n      this._logProgramError(programGPU, \
fragmentShader, vertexShader);\n    }\n    state.useProgram(programGPU);\n    \
this._setupBindings(bindings, programGPU);\n    const attributeNodes = \
computeProgram.attributes;\n    const attributes = [];\n    const \
transformBuffers = [];\n    for (let i = 0; i < attributeNodes.length; i++) \
{\n      const attribute2 = attributeNodes[i].node.attribute;\n      \
attributes.push(attribute2);\n      if (!this.has(attribute2)) \
this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);\n    }\n    \
for (let i = 0; i < transformAttributeNodes.length; i++) {\n      const \
attribute2 = transformAttributeNodes[i].attribute;\n      if \
(!this.has(attribute2)) this.attributeUtils.createAttribute(attribute2, \
gl.ARRAY_BUFFER);\n      const attributeData = this.get(attribute2);\n      \
transformBuffers.push(attributeData);\n    }\n    this.set(computePipeline, \
{\n      programGPU,\n      transformBuffers,\n      attributes\n    });\n  \
}\n  createBindings(bindGroup, bindings) {\n    if \
(this._knownBindings.has(bindings) === false) {\n      \
this._knownBindings.add(bindings);\n      let uniformBuffers = 0;\n      let \
textures = 0;\n      for (const bindGroup2 of bindings) {\n        \
this.set(bindGroup2, {\n          textures,\n          uniformBuffers\n       \
 });\n        for (const binding of bindGroup2.bindings) {\n          if \
(binding.isUniformBuffer) uniformBuffers++;\n          if \
(binding.isSampledTexture) textures++;\n        }\n      }\n    }\n    \
this.updateBindings(bindGroup, bindings);\n  }\n  updateBindings(bindGroup) \
{\n    const { gl } = this;\n    const bindGroupData = this.get(bindGroup);\n \
   let i = bindGroupData.uniformBuffers;\n    let t = \
bindGroupData.textures;\n    for (const binding of bindGroup.bindings) {\n    \
  if (binding.isUniformsGroup || binding.isUniformBuffer) {\n        const \
data = binding.buffer;\n        const bufferGPU = gl.createBuffer();\n        \
gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);\n        \
gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);\n        \
this.set(binding, {\n          index: i++,\n          bufferGPU\n        \
});\n      } else if (binding.isSampledTexture) {\n        const { \
textureGPU, glTextureType } = this.get(binding.texture);\n        \
this.set(binding, {\n          index: t++,\n          textureGPU,\n          \
glTextureType\n        });\n      }\n    }\n  }\n  updateBinding(binding) {\n \
   const gl = this.gl;\n    if (binding.isUniformsGroup || \
binding.isUniformBuffer) {\n      const bindingData = this.get(binding);\n    \
  const bufferGPU = bindingData.bufferGPU;\n      const data = \
binding.buffer;\n      gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);\n      \
gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);\n    }\n  }\n  // \
attributes\n  createIndexAttribute(attribute2) {\n    const gl = this.gl;\n   \
 this.attributeUtils.createAttribute(attribute2, gl.ELEMENT_ARRAY_BUFFER);\n  \
}\n  createAttribute(attribute2) {\n    if (this.has(attribute2)) return;\n   \
 const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute2, \
gl.ARRAY_BUFFER);\n  }\n  createStorageAttribute(attribute2) {\n    if \
(this.has(attribute2)) return;\n    const gl = this.gl;\n    \
this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);\n  }\n  \
updateAttribute(attribute2) {\n    \
this.attributeUtils.updateAttribute(attribute2);\n  }\n  \
destroyAttribute(attribute2) {\n    \
this.attributeUtils.destroyAttribute(attribute2);\n  }\n  updateSize() {\n  \
}\n  hasFeature(name) {\n    const keysMatching = \
Object.keys(GLFeatureName).filter((key) => GLFeatureName[key] === name);\n    \
const extensions = this.extensions;\n    for (let i = 0; i < \
keysMatching.length; i++) {\n      if (extensions.has(keysMatching[i])) \
return true;\n    }\n    return false;\n  }\n  getMaxAnisotropy() {\n    \
return this.capabilities.getMaxAnisotropy();\n  }\n  \
copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level) \
{\n    this.textureUtils.copyTextureToTexture(srcTexture, dstTexture, \
srcRegion, dstPosition, level);\n  }\n  copyFramebufferToTexture(texture2, \
renderContext, rectangle) {\n    \
this.textureUtils.copyFramebufferToTexture(texture2, renderContext, \
rectangle);\n  }\n  _setFramebuffer(descriptor) {\n    const { gl, state } = \
this;\n    let currentFrameBuffer = null;\n    if (descriptor.textures !== \
null) {\n      const renderTarget = descriptor.renderTarget;\n      const \
renderTargetContextData = this.get(renderTarget);\n      const { samples, \
depthBuffer, stencilBuffer } = renderTarget;\n      const isCube = \
renderTarget.isWebGLCubeRenderTarget === true;\n      let msaaFb = \
renderTargetContextData.msaaFrameBuffer;\n      let depthRenderbuffer = \
renderTargetContextData.depthRenderbuffer;\n      const cacheKey = \
getCacheKey(descriptor);\n      let fb;\n      if (isCube) {\n        \
renderTargetContextData.cubeFramebuffers || \
(renderTargetContextData.cubeFramebuffers = {});\n        fb = \
renderTargetContextData.cubeFramebuffers[cacheKey];\n      } else {\n        \
renderTargetContextData.framebuffers || (renderTargetContextData.framebuffers \
= {});\n        fb = renderTargetContextData.framebuffers[cacheKey];\n      \
}\n      if (fb === void 0) {\n        fb = gl.createFramebuffer();\n        \
state.bindFramebuffer(gl.FRAMEBUFFER, fb);\n        const textures = \
descriptor.textures;\n        if (isCube) {\n          \
renderTargetContextData.cubeFramebuffers[cacheKey] = fb;\n          const { \
textureGPU } = this.get(textures[0]);\n          const cubeFace = \
this.renderer._activeCubeFace;\n          \
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, \
gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0);\n        } else \
{\n          renderTargetContextData.framebuffers[cacheKey] = fb;\n          \
for (let i = 0; i < textures.length; i++) {\n            const texture2 = \
textures[i];\n            const textureData = this.get(texture2);\n           \
 textureData.renderTarget = descriptor.renderTarget;\n            \
textureData.cacheKey = cacheKey;\n            const attachment = \
gl.COLOR_ATTACHMENT0 + i;\n            \
gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, \
textureData.textureGPU, 0);\n          }\n          \
state.drawBuffers(descriptor, fb);\n        }\n        if \
(descriptor.depthTexture !== null) {\n          const textureData = \
this.get(descriptor.depthTexture);\n          const depthStyle = \
stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n          \
textureData.renderTarget = descriptor.renderTarget;\n          \
textureData.cacheKey = cacheKey;\n          \
gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, \
textureData.textureGPU, 0);\n        }\n      }\n      if (samples > 0) {\n   \
     if (msaaFb === void 0) {\n          const invalidationArray = [];\n      \
    msaaFb = gl.createFramebuffer();\n          \
state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);\n          const \
msaaRenderbuffers = [];\n          const textures = descriptor.textures;\n    \
      for (let i = 0; i < textures.length; i++) {\n            \
msaaRenderbuffers[i] = gl.createRenderbuffer();\n            \
gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i]);\n            \
invalidationArray.push(gl.COLOR_ATTACHMENT0 + i);\n            if \
(depthBuffer) {\n              const depthStyle = stencilBuffer ? \
gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n              \
invalidationArray.push(depthStyle);\n            }\n            const \
texture2 = descriptor.textures[i];\n            const textureData = \
this.get(texture2);\n            \
gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, \
textureData.glInternalFormat, descriptor.width, descriptor.height);\n         \
   gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, \
gl.RENDERBUFFER, msaaRenderbuffers[i]);\n          }\n          \
renderTargetContextData.msaaFrameBuffer = msaaFb;\n          \
renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n          if \
(depthRenderbuffer === void 0) {\n            depthRenderbuffer = \
gl.createRenderbuffer();\n            \
this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, descriptor);\n  \
          renderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n    \
        const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : \
gl.DEPTH_ATTACHMENT;\n            invalidationArray.push(depthStyle);\n       \
   }\n          renderTargetContextData.invalidationArray = \
invalidationArray;\n        }\n        currentFrameBuffer = \
renderTargetContextData.msaaFrameBuffer;\n      } else {\n        \
currentFrameBuffer = fb;\n      }\n    }\n    \
state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);\n  }\n  \
_getVaoKey(index5, attributes) {\n    let key = [];\n    if (index5 !== null) \
{\n      const indexData = this.get(index5);\n      key += \":\" + \
indexData.id;\n    }\n    for (let i = 0; i < attributes.length; i++) {\n     \
 const attributeData = this.get(attributes[i]);\n      key += \":\" + \
attributeData.id;\n    }\n    return key;\n  }\n  _createVao(index5, \
attributes) {\n    const { gl } = this;\n    const vaoGPU = \
gl.createVertexArray();\n    let key = \"\";\n    let staticVao = true;\n    \
gl.bindVertexArray(vaoGPU);\n    if (index5 !== null) {\n      const \
indexData = this.get(index5);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, \
indexData.bufferGPU);\n      key += \":\" + indexData.id;\n    }\n    for \
(let i = 0; i < attributes.length; i++) {\n      const attribute2 = \
attributes[i];\n      const attributeData = this.get(attribute2);\n      key \
+= \":\" + attributeData.id;\n      gl.bindBuffer(gl.ARRAY_BUFFER, \
attributeData.bufferGPU);\n      gl.enableVertexAttribArray(i);\n      if \
(attribute2.isStorageBufferAttribute || \
attribute2.isStorageInstancedBufferAttribute) staticVao = false;\n      let \
stride, offset;\n      if (attribute2.isInterleavedBufferAttribute === true) \
{\n        stride = attribute2.data.stride * attributeData.bytesPerElement;\n \
       offset = attribute2.offset * attributeData.bytesPerElement;\n      } \
else {\n        stride = 0;\n        offset = 0;\n      }\n      if \
(attributeData.isInteger) {\n        gl.vertexAttribIPointer(i, \
attribute2.itemSize, attributeData.type, stride, offset);\n      } else {\n   \
     gl.vertexAttribPointer(i, attribute2.itemSize, attributeData.type, \
attribute2.normalized, stride, offset);\n      }\n      if \
(attribute2.isInstancedBufferAttribute && \
!attribute2.isInterleavedBufferAttribute) {\n        \
gl.vertexAttribDivisor(i, attribute2.meshPerAttribute);\n      } else if \
(attribute2.isInterleavedBufferAttribute && \
attribute2.data.isInstancedInterleavedBuffer) {\n        \
gl.vertexAttribDivisor(i, attribute2.data.meshPerAttribute);\n      }\n    \
}\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    this.vaoCache[key] = \
vaoGPU;\n    return { vaoGPU, staticVao };\n  }\n  \
_getTransformFeedback(transformBuffers) {\n    let key = \"\";\n    for (let \
i = 0; i < transformBuffers.length; i++) {\n      key += \":\" + \
transformBuffers[i].id;\n    }\n    let transformFeedbackGPU = \
this.transformFeedbackCache[key];\n    if (transformFeedbackGPU !== void 0) \
{\n      return transformFeedbackGPU;\n    }\n    const { gl } = this;\n    \
transformFeedbackGPU = gl.createTransformFeedback();\n    \
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);\n    \
for (let i = 0; i < transformBuffers.length; i++) {\n      const \
attributeData = transformBuffers[i];\n      \
gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, \
attributeData.transformBuffer);\n    }\n    \
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n    \
this.transformFeedbackCache[key] = transformFeedbackGPU;\n    return \
transformFeedbackGPU;\n  }\n  _setupBindings(bindings, programGPU) {\n    \
const gl = this.gl;\n    for (const bindGroup of bindings) {\n      for \
(const binding of bindGroup.bindings) {\n        const bindingData = \
this.get(binding);\n        const index5 = bindingData.index;\n        if \
(binding.isUniformsGroup || binding.isUniformBuffer) {\n          const \
location = gl.getUniformBlockIndex(programGPU, binding.name);\n          \
gl.uniformBlockBinding(programGPU, location, index5);\n        } else if \
(binding.isSampledTexture) {\n          const location = \
gl.getUniformLocation(programGPU, binding.name);\n          \
gl.uniform1i(location, index5);\n        }\n      }\n    }\n  }\n  \
_bindUniforms(bindings) {\n    const { gl, state } = this;\n    for (const \
bindGroup of bindings) {\n      for (const binding of bindGroup.bindings) {\n \
       const bindingData = this.get(binding);\n        const index5 = \
bindingData.index;\n        if (binding.isUniformsGroup || \
binding.isUniformBuffer) {\n          state.bindBufferBase(gl.UNIFORM_BUFFER, \
index5, bindingData.bufferGPU);\n        } else if (binding.isSampledTexture) \
{\n          state.bindTexture(bindingData.glTextureType, \
bindingData.textureGPU, gl.TEXTURE0 + index5);\n        }\n      }\n    }\n  \
}\n  dispose() {\n    \
this.renderer.domElement.removeEventListener(\"webglcontextlost\", \
this._onContextLost);\n  }\n};\nvar Sampler = class extends Binding {\n  \
constructor(name, texture2) {\n    super(name);\n    this.texture = \
texture2;\n    this.version = texture2 ? texture2.version : 0;\n    \
this.isSampler = true;\n  }\n};\nvar NodeSampler = class extends Sampler {\n  \
constructor(name, textureNode, groupNode) {\n    super(name, textureNode ? \
textureNode.value : null);\n    this.textureNode = textureNode;\n    \
this.groupNode = groupNode;\n  }\n  update() {\n    this.texture = \
this.textureNode.value;\n  }\n};\nvar StorageBuffer = class extends Buffer2 \
{\n  constructor(name, attribute2) {\n    super(name, attribute2 ? \
attribute2.array : null);\n    this.attribute = attribute2;\n    \
this.isStorageBuffer = true;\n  }\n};\nvar _id = 0;\nvar NodeStorageBuffer = \
class extends StorageBuffer {\n  constructor(nodeUniform, groupNode) {\n    \
super(\"StorageBuffer_\" + _id++, nodeUniform ? nodeUniform.value : null);\n  \
  this.nodeUniform = nodeUniform;\n    this.access = nodeUniform ? \
nodeUniform.access : GPUBufferBindingType.Storage;\n    this.groupNode = \
groupNode;\n  }\n  get buffer() {\n    return this.nodeUniform.value;\n  \
}\n};\nvar WebGPUTexturePassUtils = class extends DataMap {\n  \
constructor(device) {\n    super();\n    this.device = device;\n    const \
mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) \
Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn \
main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar \
Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( \
-1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 \
),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 \
>(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( \
0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ \
vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 \
);\n\n\treturn Varys;\n\n}\n`;\n    const mipmapFragmentSource = `\n@group( 0 \
) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar \
img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> \
) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, \
vTex );\n\n}\n`;\n    const flipYFragmentSource = `\n@group( 0 ) @binding( 0 \
)\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : \
texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> \
@location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( \
vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n    this.mipmapSampler = \
device.createSampler({ minFilter: GPUFilterMode.Linear });\n    \
this.flipYSampler = device.createSampler({ minFilter: GPUFilterMode.Nearest \
});\n    this.transferPipelines = {};\n    this.flipYPipelines = {};\n    \
this.mipmapVertexShaderModule = device.createShaderModule({\n      label: \
\"mipmapVertex\",\n      code: mipmapVertexSource\n    });\n    \
this.mipmapFragmentShaderModule = device.createShaderModule({\n      label: \
\"mipmapFragment\",\n      code: mipmapFragmentSource\n    });\n    \
this.flipYFragmentShaderModule = device.createShaderModule({\n      label: \
\"flipYFragment\",\n      code: flipYFragmentSource\n    });\n  }\n  \
getTransferPipeline(format2) {\n    let pipeline = \
this.transferPipelines[format2];\n    if (pipeline === void 0) {\n      \
pipeline = this.device.createRenderPipeline({\n        label: \
`mipmap-${format2}`,\n        vertex: {\n          module: \
this.mipmapVertexShaderModule,\n          entryPoint: \"main\"\n        },\n  \
      fragment: {\n          module: this.mipmapFragmentShaderModule,\n       \
   entryPoint: \"main\",\n          targets: [{ format: format2 }]\n        \
},\n        primitive: {\n          topology: \
GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: \
GPUIndexFormat.Uint32\n        },\n        layout: \"auto\"\n      });\n      \
this.transferPipelines[format2] = pipeline;\n    }\n    return pipeline;\n  \
}\n  getFlipYPipeline(format2) {\n    let pipeline = \
this.flipYPipelines[format2];\n    if (pipeline === void 0) {\n      pipeline \
= this.device.createRenderPipeline({\n        label: `flipY-${format2}`,\n    \
    vertex: {\n          module: this.mipmapVertexShaderModule,\n          \
entryPoint: \"main\"\n        },\n        fragment: {\n          module: \
this.flipYFragmentShaderModule,\n          entryPoint: \"main\",\n          \
targets: [{ format: format2 }]\n        },\n        primitive: {\n          \
topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: \
GPUIndexFormat.Uint32\n        },\n        layout: \"auto\"\n      });\n      \
this.flipYPipelines[format2] = pipeline;\n    }\n    return pipeline;\n  }\n  \
flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {\n    const \
format2 = textureGPUDescriptor.format;\n    const { width, height } = \
textureGPUDescriptor.size;\n    const transferPipeline = \
this.getTransferPipeline(format2);\n    const flipYPipeline = \
this.getFlipYPipeline(format2);\n    const tempTexture = \
this.device.createTexture({\n      size: { width, height, depthOrArrayLayers: \
1 },\n      format: format2,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT \
| GPUTextureUsage.TEXTURE_BINDING\n    });\n    const srcView = \
textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n    \
  dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n   \
 const dstView = tempTexture.createView({\n      baseMipLevel: 0,\n      \
mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      \
baseArrayLayer: 0\n    });\n    const commandEncoder = \
this.device.createCommandEncoder({});\n    const pass = (pipeline, \
sourceView, destinationView) => {\n      const bindGroupLayout = \
pipeline.getBindGroupLayout(0);\n      const bindGroup = \
this.device.createBindGroup({\n        layout: bindGroupLayout,\n        \
entries: [{\n          binding: 0,\n          resource: this.flipYSampler\n   \
     }, {\n          binding: 1,\n          resource: sourceView\n        \
}]\n      });\n      const passEncoder = commandEncoder.beginRenderPass({\n   \
     colorAttachments: [{\n          view: destinationView,\n          \
loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          \
clearValue: [0, 0, 0, 0]\n        }]\n      });\n      \
passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, \
bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passEncoder.end();\n  \
  };\n    pass(transferPipeline, srcView, dstView);\n    pass(flipYPipeline, \
dstView, srcView);\n    \
this.device.queue.submit([commandEncoder.finish()]);\n    \
tempTexture.destroy();\n  }\n  generateMipmaps(textureGPU, \
textureGPUDescriptor, baseArrayLayer = 0) {\n    const textureData = \
this.get(textureGPU);\n    if (textureData.useCount === void 0) {\n      \
textureData.useCount = 0;\n      textureData.layers = [];\n    }\n    const \
passes = textureData.layers[baseArrayLayer] || \
this._mipmapCreateBundles(textureGPU, textureGPUDescriptor, \
baseArrayLayer);\n    const commandEncoder = \
this.device.createCommandEncoder({});\n    \
this._mipmapRunBundles(commandEncoder, passes);\n    \
this.device.queue.submit([commandEncoder.finish()]);\n    if \
(textureData.useCount !== 0) textureData.layers[baseArrayLayer] = passes;\n   \
 textureData.useCount++;\n  }\n  _mipmapCreateBundles(textureGPU, \
textureGPUDescriptor, baseArrayLayer) {\n    const pipeline = \
this.getTransferPipeline(textureGPUDescriptor.format);\n    const \
bindGroupLayout = pipeline.getBindGroupLayout(0);\n    let srcView = \
textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n    \
  dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n   \
 const passes = [];\n    for (let i = 1; i < \
textureGPUDescriptor.mipLevelCount; i++) {\n      const bindGroup = \
this.device.createBindGroup({\n        layout: bindGroupLayout,\n        \
entries: [{\n          binding: 0,\n          resource: this.mipmapSampler\n  \
      }, {\n          binding: 1,\n          resource: srcView\n        }]\n  \
    });\n      const dstView = textureGPU.createView({\n        baseMipLevel: \
i,\n        mipLevelCount: 1,\n        dimension: \
GPUTextureViewDimension.TwoD,\n        baseArrayLayer\n      });\n      const \
passDescriptor = {\n        colorAttachments: [{\n          view: dstView,\n  \
        loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n      \
    clearValue: [0, 0, 0, 0]\n        }]\n      };\n      const passEncoder = \
this.device.createRenderBundleEncoder({\n        colorFormats: \
[textureGPUDescriptor.format]\n      });\n      \
passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, \
bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passes.push({\n       \
 renderBundles: [passEncoder.finish()],\n        passDescriptor\n      });\n  \
    srcView = dstView;\n    }\n    return passes;\n  }\n  \
_mipmapRunBundles(commandEncoder, passes) {\n    const levels = \
passes.length;\n    for (let i = 0; i < levels; i++) {\n      const pass = \
passes[i];\n      const passEncoder = \
commandEncoder.beginRenderPass(pass.passDescriptor);\n      \
passEncoder.executeBundles(pass.renderBundles);\n      passEncoder.end();\n   \
 }\n  }\n};\nvar _compareToWebGPU = {\n  [NeverCompare2]: \"never\",\n  \
[LessCompare2]: \"less\",\n  [EqualCompare2]: \"equal\",\n  \
[LessEqualCompare2]: \"less-equal\",\n  [GreaterCompare2]: \"greater\",\n  \
[GreaterEqualCompare2]: \"greater-equal\",\n  [AlwaysCompare2]: \"always\",\n \
 [NotEqualCompare2]: \"not-equal\"\n};\nvar _flipMap = [0, 1, 3, 2, 4, \
5];\nvar WebGPUTextureUtils = class {\n  constructor(backend) {\n    \
this.backend = backend;\n    this._passUtils = null;\n    this.defaultTexture \
= {};\n    this.defaultCubeTexture = {};\n    this.defaultVideoFrame = \
null;\n    this.colorBuffer = null;\n    this.depthTexture = new \
DepthTexture2();\n    this.depthTexture.name = \"depthBuffer\";\n  }\n  \
createSampler(texture2) {\n    const backend = this.backend;\n    const \
device = backend.device;\n    const textureGPU = backend.get(texture2);\n    \
const samplerDescriptorGPU = {\n      addressModeU: \
this._convertAddressMode(texture2.wrapS),\n      addressModeV: \
this._convertAddressMode(texture2.wrapT),\n      addressModeW: \
this._convertAddressMode(texture2.wrapR),\n      magFilter: \
this._convertFilterMode(texture2.magFilter),\n      minFilter: \
this._convertFilterMode(texture2.minFilter),\n      mipmapFilter: \
this._convertFilterMode(texture2.minFilter),\n      maxAnisotropy: 1\n    \
};\n    if (samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && \
samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && \
samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear) {\n      \
samplerDescriptorGPU.maxAnisotropy = texture2.anisotropy;\n    }\n    if \
(texture2.isDepthTexture && texture2.compareFunction !== null) {\n      \
samplerDescriptorGPU.compare = _compareToWebGPU[texture2.compareFunction];\n  \
  }\n    textureGPU.sampler = device.createSampler(samplerDescriptorGPU);\n  \
}\n  createDefaultTexture(texture2) {\n    let textureGPU;\n    const format2 \
= getFormat2(texture2);\n    if (texture2.isCubeTexture) {\n      textureGPU \
= this._getDefaultCubeTextureGPU(format2);\n    } else if \
(texture2.isVideoTexture) {\n      this.backend.get(texture2).externalTexture \
= this._getDefaultVideoFrame();\n    } else {\n      textureGPU = \
this._getDefaultTextureGPU(format2);\n    }\n    \
this.backend.get(texture2).texture = textureGPU;\n  }\n  \
createTexture(texture2, options = {}) {\n    const backend = this.backend;\n  \
  const textureData = backend.get(texture2);\n    if \
(textureData.initialized) {\n      throw new Error(\"WebGPUTextureUtils: \
Texture already initialized.\");\n    }\n    if (options.needsMipmaps === \
void 0) options.needsMipmaps = false;\n    if (options.levels === void 0) \
options.levels = 1;\n    if (options.depth === void 0) options.depth = 1;\n   \
 const { width, height, depth: depth2, levels } = options;\n    if \
(texture2.isFramebufferTexture) {\n      if (options.renderTarget) {\n        \
options.format = \
this.backend.utils.getCurrentColorFormat(options.renderTarget);\n      } else \
{\n        options.format = this.backend.utils.getPreferredCanvasFormat();\n  \
    }\n    }\n    const dimension = this._getDimension(texture2);\n    const \
format2 = texture2.internalFormat || options.format || getFormat2(texture2, \
backend.device);\n    textureData.format = format2;\n    let sampleCount = \
options.sampleCount !== void 0 ? options.sampleCount : 1;\n    sampleCount = \
backend.utils.getSampleCount(sampleCount);\n    const primarySampleCount = \
texture2.isRenderTargetTexture && !texture2.isMultisampleRenderTargetTexture \
? 1 : sampleCount;\n    let usage = GPUTextureUsage.TEXTURE_BINDING | \
GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n    if \
(texture2.isStorageTexture === true) {\n      usage |= \
GPUTextureUsage.STORAGE_BINDING;\n    }\n    if (texture2.isCompressedTexture \
!== true && texture2.isCompressedArrayTexture !== true) {\n      usage |= \
GPUTextureUsage.RENDER_ATTACHMENT;\n    }\n    const textureDescriptorGPU = \
{\n      label: texture2.name,\n      size: {\n        width,\n        \
height,\n        depthOrArrayLayers: depth2\n      },\n      mipLevelCount: \
levels,\n      sampleCount: primarySampleCount,\n      dimension,\n      \
format: format2,\n      usage\n    };\n    if (texture2.isVideoTexture) {\n   \
   const video = texture2.source.data;\n      const videoFrame = new \
VideoFrame(video);\n      textureDescriptorGPU.size.width = \
videoFrame.displayWidth;\n      textureDescriptorGPU.size.height = \
videoFrame.displayHeight;\n      videoFrame.close();\n      \
textureData.externalTexture = video;\n    } else {\n      if (format2 === \
void 0) {\n        console.warn(\"WebGPURenderer: Texture format not \
supported.\");\n        return this.createDefaultTexture(texture2);\n      \
}\n      textureData.texture = \
backend.device.createTexture(textureDescriptorGPU);\n    }\n    if \
(texture2.isRenderTargetTexture && sampleCount > 1 && \
!texture2.isMultisampleRenderTargetTexture) {\n      const \
msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);\n      \
msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + \
\"-msaa\";\n      msaaTextureDescriptorGPU.sampleCount = sampleCount;\n      \
textureData.msaaTexture = \
backend.device.createTexture(msaaTextureDescriptorGPU);\n    }\n    \
textureData.initialized = true;\n    textureData.textureDescriptorGPU = \
textureDescriptorGPU;\n  }\n  destroyTexture(texture2) {\n    const backend = \
this.backend;\n    const textureData = backend.get(texture2);\n    \
textureData.texture.destroy();\n    if (textureData.msaaTexture !== void 0) \
textureData.msaaTexture.destroy();\n    backend.delete(texture2);\n  }\n  \
destroySampler(texture2) {\n    const backend = this.backend;\n    const \
textureData = backend.get(texture2);\n    delete textureData.sampler;\n  }\n  \
generateMipmaps(texture2) {\n    const textureData = \
this.backend.get(texture2);\n    if (texture2.isCubeTexture) {\n      for \
(let i = 0; i < 6; i++) {\n        this._generateMipmaps(textureData.texture, \
textureData.textureDescriptorGPU, i);\n      }\n    } else {\n      const \
depth2 = texture2.image.depth || 1;\n      for (let i = 0; i < depth2; i++) \
{\n        this._generateMipmaps(textureData.texture, \
textureData.textureDescriptorGPU, i);\n      }\n    }\n  }\n  \
getColorBuffer() {\n    if (this.colorBuffer) this.colorBuffer.destroy();\n   \
 const backend = this.backend;\n    const { width, height } = \
backend.getDrawingBufferSize();\n    this.colorBuffer = \
backend.device.createTexture({\n      label: \"colorBuffer\",\n      size: \
{\n        width,\n        height,\n        depthOrArrayLayers: 1\n      },\n \
     sampleCount: backend.utils.getSampleCount(backend.renderer.samples),\n   \
   format: backend.utils.getPreferredCanvasFormat(),\n      usage: \
GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n    \
return this.colorBuffer;\n  }\n  getDepthBuffer(depth2 = true, stencil = \
false) {\n    const backend = this.backend;\n    const { width, height } = \
backend.getDrawingBufferSize();\n    const depthTexture = \
this.depthTexture;\n    const depthTextureGPU = \
backend.get(depthTexture).texture;\n    let format2, type;\n    if (stencil) \
{\n      format2 = DepthStencilFormat2;\n      type = UnsignedInt248Type2;\n  \
  } else if (depth2) {\n      format2 = DepthFormat2;\n      type = \
UnsignedIntType2;\n    }\n    if (depthTextureGPU !== void 0) {\n      if \
(depthTexture.image.width === width && depthTexture.image.height === height \
&& depthTexture.format === format2 && depthTexture.type === type) {\n        \
return depthTextureGPU;\n      }\n      this.destroyTexture(depthTexture);\n  \
  }\n    depthTexture.name = \"depthBuffer\";\n    depthTexture.format = \
format2;\n    depthTexture.type = type;\n    depthTexture.image.width = \
width;\n    depthTexture.image.height = height;\n    \
this.createTexture(depthTexture, { sampleCount: \
backend.utils.getSampleCount(backend.renderer.samples), width, height });\n   \
 return backend.get(depthTexture).texture;\n  }\n  updateTexture(texture2, \
options) {\n    const textureData = this.backend.get(texture2);\n    const { \
textureDescriptorGPU } = textureData;\n    if (texture2.isRenderTargetTexture \
|| textureDescriptorGPU === void 0)\n      return;\n    if \
(texture2.isDataTexture) {\n      this._copyBufferToTexture(options.image, \
textureData.texture, textureDescriptorGPU, 0, texture2.flipY);\n    } else if \
(texture2.isDataArrayTexture || texture2.isData3DTexture) {\n      for (let i \
= 0; i < options.image.depth; i++) {\n        \
this._copyBufferToTexture(options.image, textureData.texture, \
textureDescriptorGPU, i, texture2.flipY, i);\n      }\n    } else if \
(texture2.isCompressedTexture || texture2.isCompressedArrayTexture) {\n      \
this._copyCompressedBufferToTexture(texture2.mipmaps, textureData.texture, \
textureDescriptorGPU);\n    } else if (texture2.isCubeTexture) {\n      \
this._copyCubeMapToTexture(options.images, textureData.texture, \
textureDescriptorGPU, texture2.flipY);\n    } else if \
(texture2.isVideoTexture) {\n      const video = texture2.source.data;\n      \
textureData.externalTexture = video;\n    } else {\n      \
this._copyImageToTexture(options.image, textureData.texture, \
textureDescriptorGPU, 0, texture2.flipY);\n    }\n    textureData.version = \
texture2.version;\n    if (texture2.onUpdate) texture2.onUpdate(texture2);\n  \
}\n  async copyTextureToBuffer(texture2, x2, y2, width, height, faceIndex) \
{\n    const device = this.backend.device;\n    const textureData = \
this.backend.get(texture2);\n    const textureGPU = textureData.texture;\n    \
const format2 = textureData.textureDescriptorGPU.format;\n    const \
bytesPerTexel = this._getBytesPerTexel(format2);\n    let bytesPerRow = width \
* bytesPerTexel;\n    bytesPerRow = Math.ceil(bytesPerRow / 256) * 256;\n    \
const readBuffer = device.createBuffer(\n      {\n        size: width * \
height * bytesPerTexel,\n        usage: GPUBufferUsage.COPY_DST | \
GPUBufferUsage.MAP_READ\n      }\n    );\n    const encoder = \
device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      {\n   \
     texture: textureGPU,\n        origin: { x: x2, y: y2, z: faceIndex }\n   \
   },\n      {\n        buffer: readBuffer,\n        bytesPerRow\n      },\n  \
    {\n        width,\n        height\n      }\n    );\n    const \
typedArrayType = this._getTypedArrayType(format2);\n    \
device.queue.submit([encoder.finish()]);\n    await \
readBuffer.mapAsync(GPUMapMode.READ);\n    const buffer2 = \
readBuffer.getMappedRange();\n    return new typedArrayType(buffer2);\n  }\n  \
_isEnvironmentTexture(texture2) {\n    const mapping = texture2.mapping;\n    \
return mapping === EquirectangularReflectionMapping2 || mapping === \
EquirectangularRefractionMapping2 || (mapping === CubeReflectionMapping2 || \
mapping === CubeRefractionMapping2);\n  }\n  _getDefaultTextureGPU(format2) \
{\n    let defaultTexture = this.defaultTexture[format2];\n    if \
(defaultTexture === void 0) {\n      const texture2 = new Texture2();\n      \
texture2.minFilter = NearestFilter2;\n      texture2.magFilter = \
NearestFilter2;\n      this.createTexture(texture2, { width: 1, height: 1, \
format: format2 });\n      this.defaultTexture[format2] = defaultTexture = \
texture2;\n    }\n    return this.backend.get(defaultTexture).texture;\n  }\n \
 _getDefaultCubeTextureGPU(format2) {\n    let defaultCubeTexture = \
this.defaultTexture[format2];\n    if (defaultCubeTexture === void 0) {\n     \
 const texture2 = new CubeTexture2();\n      texture2.minFilter = \
NearestFilter2;\n      texture2.magFilter = NearestFilter2;\n      \
this.createTexture(texture2, { width: 1, height: 1, depth: 6 });\n      \
this.defaultCubeTexture[format2] = defaultCubeTexture = texture2;\n    }\n    \
return this.backend.get(defaultCubeTexture).texture;\n  }\n  \
_getDefaultVideoFrame() {\n    let defaultVideoFrame = \
this.defaultVideoFrame;\n    if (defaultVideoFrame === null) {\n      const \
init4 = {\n        timestamp: 0,\n        codedWidth: 1,\n        \
codedHeight: 1,\n        format: \"RGBA\"\n      };\n      \
this.defaultVideoFrame = defaultVideoFrame = new VideoFrame(new \
Uint8Array([0, 0, 0, 255]), init4);\n    }\n    return defaultVideoFrame;\n  \
}\n  _copyCubeMapToTexture(images, textureGPU, textureDescriptorGPU, flipY) \
{\n    for (let i = 0; i < 6; i++) {\n      const image = images[i];\n      \
const flipIndex = flipY === true ? _flipMap[i] : i;\n      if \
(image.isDataTexture) {\n        this._copyBufferToTexture(image.image, \
textureGPU, textureDescriptorGPU, flipIndex, flipY);\n      } else {\n        \
this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, \
flipY);\n      }\n    }\n  }\n  _copyImageToTexture(image, textureGPU, \
textureDescriptorGPU, originDepth, flipY) {\n    const device = \
this.backend.device;\n    device.queue.copyExternalImageToTexture(\n      {\n \
       source: image\n      },\n      {\n        texture: textureGPU,\n       \
 mipLevel: 0,\n        origin: { x: 0, y: 0, z: originDepth }\n      },\n     \
 {\n        width: image.width,\n        height: image.height,\n        \
depthOrArrayLayers: 1\n      }\n    );\n    if (flipY === true) {\n      \
this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  \
_getPassUtils() {\n    let passUtils = this._passUtils;\n    if (passUtils \
=== null) {\n      this._passUtils = passUtils = new \
WebGPUTexturePassUtils(this.backend.device);\n    }\n    return passUtils;\n  \
}\n  _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0) \
{\n    this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, \
baseArrayLayer);\n  }\n  _flipY(textureGPU, textureDescriptorGPU, originDepth \
= 0) {\n    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, \
originDepth);\n  }\n  _copyBufferToTexture(image, textureGPU, \
textureDescriptorGPU, originDepth, flipY, depth2 = 0) {\n    const device = \
this.backend.device;\n    const data = image.data;\n    const bytesPerTexel = \
this._getBytesPerTexel(textureDescriptorGPU.format);\n    const bytesPerRow = \
image.width * bytesPerTexel;\n    device.queue.writeTexture(\n      {\n       \
 texture: textureGPU,\n        mipLevel: 0,\n        origin: { x: 0, y: 0, z: \
originDepth }\n      },\n      data,\n      {\n        offset: image.width * \
image.height * bytesPerTexel * depth2,\n        bytesPerRow\n      },\n      \
{\n        width: image.width,\n        height: image.height,\n        \
depthOrArrayLayers: 1\n      }\n    );\n    if (flipY === true) {\n      \
this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  \
_copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {\n \
   const device = this.backend.device;\n    const blockData = \
this._getBlockData(textureDescriptorGPU.format);\n    const isTextureArray = \
textureDescriptorGPU.size.depthOrArrayLayers > 1;\n    for (let i = 0; i < \
mipmaps.length; i++) {\n      const mipmap = mipmaps[i];\n      const width = \
mipmap.width;\n      const height = mipmap.height;\n      const depth2 = \
isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n      \
const bytesPerRow = Math.ceil(width / blockData.width) * \
blockData.byteLength;\n      const bytesPerImage = bytesPerRow * \
Math.ceil(height / blockData.height);\n      for (let j = 0; j < depth2; j++) \
{\n        device.queue.writeTexture(\n          {\n            texture: \
textureGPU,\n            mipLevel: i,\n            origin: { x: 0, y: 0, z: j \
}\n          },\n          mipmap.data,\n          {\n            offset: j * \
bytesPerImage,\n            bytesPerRow,\n            rowsPerImage: \
Math.ceil(height / blockData.height)\n          },\n          {\n            \
width: Math.ceil(width / blockData.width) * blockData.width,\n            \
height: Math.ceil(height / blockData.height) * blockData.height,\n            \
depthOrArrayLayers: 1\n          }\n        );\n      }\n    }\n  }\n  \
_getBlockData(format2) {\n    if (format2 === GPUTextureFormat.BC1RGBAUnorm \
|| format2 === GPUTextureFormat.BC1RGBAUnormSRGB) return { byteLength: 8, \
width: 4, height: 4 };\n    if (format2 === GPUTextureFormat.BC2RGBAUnorm || \
format2 === GPUTextureFormat.BC2RGBAUnormSRGB) return { byteLength: 16, \
width: 4, height: 4 };\n    if (format2 === GPUTextureFormat.BC3RGBAUnorm || \
format2 === GPUTextureFormat.BC3RGBAUnormSRGB) return { byteLength: 16, \
width: 4, height: 4 };\n    if (format2 === GPUTextureFormat.BC4RUnorm || \
format2 === GPUTextureFormat.BC4RSNorm) return { byteLength: 8, width: 4, \
height: 4 };\n    if (format2 === GPUTextureFormat.BC5RGUnorm || format2 === \
GPUTextureFormat.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 \
};\n    if (format2 === GPUTextureFormat.BC6HRGBUFloat || format2 === \
GPUTextureFormat.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 \
};\n    if (format2 === GPUTextureFormat.BC7RGBAUnorm || format2 === \
GPUTextureFormat.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: \
4 };\n    if (format2 === GPUTextureFormat.ETC2RGB8Unorm || format2 === \
GPUTextureFormat.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: \
4 };\n    if (format2 === GPUTextureFormat.ETC2RGB8A1Unorm || format2 === \
GPUTextureFormat.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, \
height: 4 };\n    if (format2 === GPUTextureFormat.ETC2RGBA8Unorm || format2 \
=== GPUTextureFormat.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, \
height: 4 };\n    if (format2 === GPUTextureFormat.EACR11Unorm) return { \
byteLength: 8, width: 4, height: 4 };\n    if (format2 === \
GPUTextureFormat.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 \
};\n    if (format2 === GPUTextureFormat.EACRG11Unorm) return { byteLength: \
16, width: 4, height: 4 };\n    if (format2 === \
GPUTextureFormat.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 \
};\n    if (format2 === GPUTextureFormat.ASTC4x4Unorm || format2 === \
GPUTextureFormat.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: \
4 };\n    if (format2 === GPUTextureFormat.ASTC5x4Unorm || format2 === \
GPUTextureFormat.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: \
4 };\n    if (format2 === GPUTextureFormat.ASTC5x5Unorm || format2 === \
GPUTextureFormat.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: \
5 };\n    if (format2 === GPUTextureFormat.ASTC6x5Unorm || format2 === \
GPUTextureFormat.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: \
5 };\n    if (format2 === GPUTextureFormat.ASTC6x6Unorm || format2 === \
GPUTextureFormat.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: \
6 };\n    if (format2 === GPUTextureFormat.ASTC8x5Unorm || format2 === \
GPUTextureFormat.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: \
5 };\n    if (format2 === GPUTextureFormat.ASTC8x6Unorm || format2 === \
GPUTextureFormat.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: \
6 };\n    if (format2 === GPUTextureFormat.ASTC8x8Unorm || format2 === \
GPUTextureFormat.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: \
8 };\n    if (format2 === GPUTextureFormat.ASTC10x5Unorm || format2 === \
GPUTextureFormat.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, \
height: 5 };\n    if (format2 === GPUTextureFormat.ASTC10x6Unorm || format2 \
=== GPUTextureFormat.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, \
height: 6 };\n    if (format2 === GPUTextureFormat.ASTC10x8Unorm || format2 \
=== GPUTextureFormat.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, \
height: 8 };\n    if (format2 === GPUTextureFormat.ASTC10x10Unorm || format2 \
=== GPUTextureFormat.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, \
height: 10 };\n    if (format2 === GPUTextureFormat.ASTC12x10Unorm || format2 \
=== GPUTextureFormat.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, \
height: 10 };\n    if (format2 === GPUTextureFormat.ASTC12x12Unorm || format2 \
=== GPUTextureFormat.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, \
height: 12 };\n  }\n  _convertAddressMode(value) {\n    let addressMode = \
GPUAddressMode.ClampToEdge;\n    if (value === RepeatWrapping2) {\n      \
addressMode = GPUAddressMode.Repeat;\n    } else if (value === \
MirroredRepeatWrapping2) {\n      addressMode = \
GPUAddressMode.MirrorRepeat;\n    }\n    return addressMode;\n  }\n  \
_convertFilterMode(value) {\n    let filterMode = GPUFilterMode.Linear;\n    \
if (value === NearestFilter2 || value === NearestMipmapNearestFilter2 || \
value === NearestMipmapLinearFilter2) {\n      filterMode = \
GPUFilterMode.Nearest;\n    }\n    return filterMode;\n  }\n  \
_getBytesPerTexel(format2) {\n    if (format2 === GPUTextureFormat.R8Unorm || \
format2 === GPUTextureFormat.R8Snorm || format2 === GPUTextureFormat.R8Uint \
|| format2 === GPUTextureFormat.R8Sint) return 1;\n    if (format2 === \
GPUTextureFormat.R16Uint || format2 === GPUTextureFormat.R16Sint || format2 \
=== GPUTextureFormat.R16Float || format2 === GPUTextureFormat.RG8Unorm || \
format2 === GPUTextureFormat.RG8Snorm || format2 === GPUTextureFormat.RG8Uint \
|| format2 === GPUTextureFormat.RG8Sint) return 2;\n    if (format2 === \
GPUTextureFormat.R32Uint || format2 === GPUTextureFormat.R32Sint || format2 \
=== GPUTextureFormat.R32Float || format2 === GPUTextureFormat.RG16Uint || \
format2 === GPUTextureFormat.RG16Sint || format2 === \
GPUTextureFormat.RG16Float || format2 === GPUTextureFormat.RGBA8Unorm || \
format2 === GPUTextureFormat.RGBA8UnormSRGB || format2 === \
GPUTextureFormat.RGBA8Snorm || format2 === GPUTextureFormat.RGBA8Uint || \
format2 === GPUTextureFormat.RGBA8Sint || format2 === \
GPUTextureFormat.BGRA8Unorm || format2 === GPUTextureFormat.BGRA8UnormSRGB || \
// Packed 32-bit formats\n    format2 === GPUTextureFormat.RGB9E5UFloat || \
format2 === GPUTextureFormat.RGB10A2Unorm || format2 === \
GPUTextureFormat.RG11B10UFloat || format2 === GPUTextureFormat.Depth32Float \
|| format2 === GPUTextureFormat.Depth24Plus || format2 === \
GPUTextureFormat.Depth24PlusStencil8 || format2 === \
GPUTextureFormat.Depth32FloatStencil8) return 4;\n    if (format2 === \
GPUTextureFormat.RG32Uint || format2 === GPUTextureFormat.RG32Sint || format2 \
=== GPUTextureFormat.RG32Float || format2 === GPUTextureFormat.RGBA16Uint || \
format2 === GPUTextureFormat.RGBA16Sint || format2 === \
GPUTextureFormat.RGBA16Float) return 8;\n    if (format2 === \
GPUTextureFormat.RGBA32Uint || format2 === GPUTextureFormat.RGBA32Sint || \
format2 === GPUTextureFormat.RGBA32Float) return 16;\n  }\n  \
_getTypedArrayType(format2) {\n    if (format2 === GPUTextureFormat.R8Uint) \
return Uint8Array;\n    if (format2 === GPUTextureFormat.R8Sint) return \
Int8Array;\n    if (format2 === GPUTextureFormat.R8Unorm) return \
Uint8Array;\n    if (format2 === GPUTextureFormat.R8Snorm) return \
Int8Array;\n    if (format2 === GPUTextureFormat.RG8Uint) return \
Uint8Array;\n    if (format2 === GPUTextureFormat.RG8Sint) return \
Int8Array;\n    if (format2 === GPUTextureFormat.RG8Unorm) return \
Uint8Array;\n    if (format2 === GPUTextureFormat.RG8Snorm) return \
Int8Array;\n    if (format2 === GPUTextureFormat.RGBA8Uint) return \
Uint8Array;\n    if (format2 === GPUTextureFormat.RGBA8Sint) return \
Int8Array;\n    if (format2 === GPUTextureFormat.RGBA8Unorm) return \
Uint8Array;\n    if (format2 === GPUTextureFormat.RGBA8Snorm) return \
Int8Array;\n    if (format2 === GPUTextureFormat.R16Uint) return \
Uint16Array;\n    if (format2 === GPUTextureFormat.R16Sint) return \
Int16Array;\n    if (format2 === GPUTextureFormat.RG16Uint) return \
Uint16Array;\n    if (format2 === GPUTextureFormat.RG16Sint) return \
Int16Array;\n    if (format2 === GPUTextureFormat.RGBA16Uint) return \
Uint16Array;\n    if (format2 === GPUTextureFormat.RGBA16Sint) return \
Int16Array;\n    if (format2 === GPUTextureFormat.R16Float) return \
Uint16Array;\n    if (format2 === GPUTextureFormat.RG16Float) return \
Uint16Array;\n    if (format2 === GPUTextureFormat.RGBA16Float) return \
Uint16Array;\n    if (format2 === GPUTextureFormat.R32Uint) return \
Uint32Array;\n    if (format2 === GPUTextureFormat.R32Sint) return \
Int32Array;\n    if (format2 === GPUTextureFormat.R32Float) return \
Float32Array;\n    if (format2 === GPUTextureFormat.RG32Uint) return \
Uint32Array;\n    if (format2 === GPUTextureFormat.RG32Sint) return \
Int32Array;\n    if (format2 === GPUTextureFormat.RG32Float) return \
Float32Array;\n    if (format2 === GPUTextureFormat.RGBA32Uint) return \
Uint32Array;\n    if (format2 === GPUTextureFormat.RGBA32Sint) return \
Int32Array;\n    if (format2 === GPUTextureFormat.RGBA32Float) return \
Float32Array;\n    if (format2 === GPUTextureFormat.BGRA8Unorm) return \
Uint8Array;\n    if (format2 === GPUTextureFormat.BGRA8UnormSRGB) return \
Uint8Array;\n    if (format2 === GPUTextureFormat.RGB10A2Unorm) return \
Uint32Array;\n    if (format2 === GPUTextureFormat.RGB9E5UFloat) return \
Uint32Array;\n    if (format2 === GPUTextureFormat.RG11B10UFloat) return \
Uint32Array;\n    if (format2 === GPUTextureFormat.Depth32Float) return \
Float32Array;\n    if (format2 === GPUTextureFormat.Depth24Plus) return \
Uint32Array;\n    if (format2 === GPUTextureFormat.Depth24PlusStencil8) \
return Uint32Array;\n    if (format2 === \
GPUTextureFormat.Depth32FloatStencil8) return Float32Array;\n  }\n  \
_getDimension(texture2) {\n    let dimension;\n    if \
(texture2.isData3DTexture) {\n      dimension = GPUTextureDimension.ThreeD;\n \
   } else {\n      dimension = GPUTextureDimension.TwoD;\n    }\n    return \
dimension;\n  }\n};\nfunction getFormat2(texture2, device = null) {\n  const \
format2 = texture2.format;\n  const type = texture2.type;\n  const colorSpace \
= texture2.colorSpace;\n  let formatGPU;\n  if (texture2.isCompressedTexture \
=== true || texture2.isCompressedArrayTexture === true) {\n    switch \
(format2) {\n      case RGBA_S3TC_DXT1_Format2:\n        formatGPU = \
colorSpace === SRGBColorSpace2 ? GPUTextureFormat.BC1RGBAUnormSRGB : \
GPUTextureFormat.BC1RGBAUnorm;\n        break;\n      case \
RGBA_S3TC_DXT3_Format2:\n        formatGPU = colorSpace === SRGBColorSpace2 ? \
GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n        \
break;\n      case RGBA_S3TC_DXT5_Format2:\n        formatGPU = colorSpace \
=== SRGBColorSpace2 ? GPUTextureFormat.BC3RGBAUnormSRGB : \
GPUTextureFormat.BC3RGBAUnorm;\n        break;\n      case \
RGB_ETC2_Format2:\n        formatGPU = colorSpace === SRGBColorSpace2 ? \
GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n        \
break;\n      case RGBA_ETC2_EAC_Format2:\n        formatGPU = colorSpace === \
SRGBColorSpace2 ? GPUTextureFormat.ETC2RGBA8UnormSRGB : \
GPUTextureFormat.ETC2RGBA8Unorm;\n        break;\n      case \
RGBA_ASTC_4x4_Format2:\n        formatGPU = colorSpace === SRGBColorSpace2 ? \
GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n        \
break;\n      case RGBA_ASTC_5x4_Format2:\n        formatGPU = colorSpace === \
SRGBColorSpace2 ? GPUTextureFormat.ASTC5x4UnormSRGB : \
GPUTextureFormat.ASTC5x4Unorm;\n        break;\n      case \
RGBA_ASTC_5x5_Format2:\n        formatGPU = colorSpace === SRGBColorSpace2 ? \
GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n        \
break;\n      case RGBA_ASTC_6x5_Format2:\n        formatGPU = colorSpace === \
SRGBColorSpace2 ? GPUTextureFormat.ASTC6x5UnormSRGB : \
GPUTextureFormat.ASTC6x5Unorm;\n        break;\n      case \
RGBA_ASTC_6x6_Format2:\n        formatGPU = colorSpace === SRGBColorSpace2 ? \
GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n        \
break;\n      case RGBA_ASTC_8x5_Format2:\n        formatGPU = colorSpace === \
SRGBColorSpace2 ? GPUTextureFormat.ASTC8x5UnormSRGB : \
GPUTextureFormat.ASTC8x5Unorm;\n        break;\n      case \
RGBA_ASTC_8x6_Format2:\n        formatGPU = colorSpace === SRGBColorSpace2 ? \
GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n        \
break;\n      case RGBA_ASTC_8x8_Format2:\n        formatGPU = colorSpace === \
SRGBColorSpace2 ? GPUTextureFormat.ASTC8x8UnormSRGB : \
GPUTextureFormat.ASTC8x8Unorm;\n        break;\n      case \
RGBA_ASTC_10x5_Format2:\n        formatGPU = colorSpace === SRGBColorSpace2 ? \
GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n        \
break;\n      case RGBA_ASTC_10x6_Format2:\n        formatGPU = colorSpace \
=== SRGBColorSpace2 ? GPUTextureFormat.ASTC10x6UnormSRGB : \
GPUTextureFormat.ASTC10x6Unorm;\n        break;\n      case \
RGBA_ASTC_10x8_Format2:\n        formatGPU = colorSpace === SRGBColorSpace2 ? \
GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n        \
break;\n      case RGBA_ASTC_10x10_Format2:\n        formatGPU = colorSpace \
=== SRGBColorSpace2 ? GPUTextureFormat.ASTC10x10UnormSRGB : \
GPUTextureFormat.ASTC10x10Unorm;\n        break;\n      case \
RGBA_ASTC_12x10_Format2:\n        formatGPU = colorSpace === SRGBColorSpace2 \
? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n    \
    break;\n      case RGBA_ASTC_12x12_Format2:\n        formatGPU = \
colorSpace === SRGBColorSpace2 ? GPUTextureFormat.ASTC12x12UnormSRGB : \
GPUTextureFormat.ASTC12x12Unorm;\n        break;\n      default:\n        \
console.error(\"WebGPURenderer: Unsupported texture format.\", format2);\n    \
}\n  } else {\n    switch (format2) {\n      case RGBAFormat2:\n        \
switch (type) {\n          case ByteType2:\n            formatGPU = \
GPUTextureFormat.RGBA8Snorm;\n            break;\n          case \
ShortType2:\n            formatGPU = GPUTextureFormat.RGBA16Sint;\n           \
 break;\n          case UnsignedShortType2:\n            formatGPU = \
GPUTextureFormat.RGBA16Uint;\n            break;\n          case \
UnsignedIntType2:\n            formatGPU = GPUTextureFormat.RGBA32Uint;\n     \
       break;\n          case IntType2:\n            formatGPU = \
GPUTextureFormat.RGBA32Sint;\n            break;\n          case \
UnsignedByteType2:\n            formatGPU = colorSpace === SRGBColorSpace2 ? \
GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n            \
break;\n          case HalfFloatType2:\n            formatGPU = \
GPUTextureFormat.RGBA16Float;\n            break;\n          case \
FloatType2:\n            formatGPU = GPUTextureFormat.RGBA32Float;\n          \
  break;\n          default:\n            console.error(\"WebGPURenderer: \
Unsupported texture type with RGBAFormat.\", type);\n        }\n        \
break;\n      case RGBFormat2:\n        switch (type) {\n          case \
UnsignedInt5999Type2:\n            formatGPU = \
GPUTextureFormat.RGB9E5UFloat;\n            break;\n          default:\n      \
      console.error(\"WebGPURenderer: Unsupported texture type with \
RGBFormat.\", type);\n        }\n        break;\n      case RedFormat2:\n     \
   switch (type) {\n          case ByteType2:\n            formatGPU = \
GPUTextureFormat.R8Snorm;\n            break;\n          case ShortType2:\n   \
         formatGPU = GPUTextureFormat.R16Sint;\n            break;\n          \
case UnsignedShortType2:\n            formatGPU = GPUTextureFormat.R16Uint;\n \
           break;\n          case UnsignedIntType2:\n            formatGPU = \
GPUTextureFormat.R32Uint;\n            break;\n          case IntType2:\n     \
       formatGPU = GPUTextureFormat.R32Sint;\n            break;\n          \
case UnsignedByteType2:\n            formatGPU = GPUTextureFormat.R8Unorm;\n  \
          break;\n          case HalfFloatType2:\n            formatGPU = \
GPUTextureFormat.R16Float;\n            break;\n          case FloatType2:\n  \
          formatGPU = GPUTextureFormat.R32Float;\n            break;\n        \
  default:\n            console.error(\"WebGPURenderer: Unsupported texture \
type with RedFormat.\", type);\n        }\n        break;\n      case \
RGFormat2:\n        switch (type) {\n          case ByteType2:\n            \
formatGPU = GPUTextureFormat.RG8Snorm;\n            break;\n          case \
ShortType2:\n            formatGPU = GPUTextureFormat.RG16Sint;\n            \
break;\n          case UnsignedShortType2:\n            formatGPU = \
GPUTextureFormat.RG16Uint;\n            break;\n          case \
UnsignedIntType2:\n            formatGPU = GPUTextureFormat.RG32Uint;\n       \
     break;\n          case IntType2:\n            formatGPU = \
GPUTextureFormat.RG32Sint;\n            break;\n          case \
UnsignedByteType2:\n            formatGPU = GPUTextureFormat.RG8Unorm;\n      \
      break;\n          case HalfFloatType2:\n            formatGPU = \
GPUTextureFormat.RG16Float;\n            break;\n          case FloatType2:\n \
           formatGPU = GPUTextureFormat.RG32Float;\n            break;\n      \
    default:\n            console.error(\"WebGPURenderer: Unsupported texture \
type with RGFormat.\", type);\n        }\n        break;\n      case \
DepthFormat2:\n        switch (type) {\n          case UnsignedShortType2:\n  \
          formatGPU = GPUTextureFormat.Depth16Unorm;\n            break;\n    \
      case UnsignedIntType2:\n            formatGPU = \
GPUTextureFormat.Depth24Plus;\n            break;\n          case \
FloatType2:\n            formatGPU = GPUTextureFormat.Depth32Float;\n         \
   break;\n          default:\n            console.error(\"WebGPURenderer: \
Unsupported texture type with DepthFormat.\", type);\n        }\n        \
break;\n      case DepthStencilFormat2:\n        switch (type) {\n          \
case UnsignedInt248Type2:\n            formatGPU = \
GPUTextureFormat.Depth24PlusStencil8;\n            break;\n          case \
FloatType2:\n            if (device && \
device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {\n       \
       console.error('WebGPURenderer: Depth textures with DepthStencilFormat \
+ FloatType can only be used with the \"depth32float-stencil8\" GPU \
feature.');\n            }\n            formatGPU = \
GPUTextureFormat.Depth32FloatStencil8;\n            break;\n          \
default:\n            console.error(\"WebGPURenderer: Unsupported texture \
type with DepthStencilFormat.\", type);\n        }\n        break;\n      \
case RedIntegerFormat2:\n        switch (type) {\n          case IntType2:\n  \
          formatGPU = GPUTextureFormat.R32Sint;\n            break;\n         \
 case UnsignedIntType2:\n            formatGPU = GPUTextureFormat.R32Uint;\n  \
          break;\n          default:\n            \
console.error(\"WebGPURenderer: Unsupported texture type with \
RedIntegerFormat.\", type);\n        }\n        break;\n      case \
RGIntegerFormat2:\n        switch (type) {\n          case IntType2:\n        \
    formatGPU = GPUTextureFormat.RG32Sint;\n            break;\n          \
case UnsignedIntType2:\n            formatGPU = GPUTextureFormat.RG32Uint;\n  \
          break;\n          default:\n            \
console.error(\"WebGPURenderer: Unsupported texture type with \
RGIntegerFormat.\", type);\n        }\n        break;\n      case \
RGBAIntegerFormat2:\n        switch (type) {\n          case IntType2:\n      \
      formatGPU = GPUTextureFormat.RGBA32Sint;\n            break;\n          \
case UnsignedIntType2:\n            formatGPU = \
GPUTextureFormat.RGBA32Uint;\n            break;\n          default:\n        \
    console.error(\"WebGPURenderer: Unsupported texture type with \
RGBAIntegerFormat.\", type);\n        }\n        break;\n      default:\n     \
   console.error(\"WebGPURenderer: Unsupported texture format.\", format2);\n \
   }\n  }\n  return formatGPU;\n}\nvar declarationRegexp = \
/^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:\
<[\\s\\S]+?>)?)/i;\nvar propertiesRegexp = \
/([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\nvar wgslTypeLib$1 = \
{\n  \"f32\": \"float\",\n  \"i32\": \"int\",\n  \"u32\": \"uint\",\n  \
\"bool\": \"bool\",\n  \"vec2<f32>\": \"vec2\",\n  \"vec2<i32>\": \
\"ivec2\",\n  \"vec2<u32>\": \"uvec2\",\n  \"vec2<bool>\": \"bvec2\",\n  \
\"vec2f\": \"vec2\",\n  \"vec2i\": \"ivec2\",\n  \"vec2u\": \"uvec2\",\n  \
\"vec2b\": \"bvec2\",\n  \"vec3<f32>\": \"vec3\",\n  \"vec3<i32>\": \
\"ivec3\",\n  \"vec3<u32>\": \"uvec3\",\n  \"vec3<bool>\": \"bvec3\",\n  \
\"vec3f\": \"vec3\",\n  \"vec3i\": \"ivec3\",\n  \"vec3u\": \"uvec3\",\n  \
\"vec3b\": \"bvec3\",\n  \"vec4<f32>\": \"vec4\",\n  \"vec4<i32>\": \
\"ivec4\",\n  \"vec4<u32>\": \"uvec4\",\n  \"vec4<bool>\": \"bvec4\",\n  \
\"vec4f\": \"vec4\",\n  \"vec4i\": \"ivec4\",\n  \"vec4u\": \"uvec4\",\n  \
\"vec4b\": \"bvec4\",\n  \"mat2x2<f32>\": \"mat2\",\n  \"mat2x2f\": \
\"mat2\",\n  \"mat3x3<f32>\": \"mat3\",\n  \"mat3x3f\": \"mat3\",\n  \
\"mat4x4<f32>\": \"mat4\",\n  \"mat4x4f\": \"mat4\",\n  \"sampler\": \
\"sampler\",\n  \"texture_1d\": \"texture\",\n  \"texture_2d\": \
\"texture\",\n  \"texture_2d_array\": \"texture\",\n  \
\"texture_multisampled_2d\": \"cubeTexture\",\n  \"texture_depth_2d\": \
\"depthTexture\",\n  \"texture_3d\": \"texture3D\",\n  \"texture_cube\": \
\"cubeTexture\",\n  \"texture_cube_array\": \"cubeTexture\",\n  \
\"texture_storage_1d\": \"storageTexture\",\n  \"texture_storage_2d\": \
\"storageTexture\",\n  \"texture_storage_2d_array\": \"storageTexture\",\n  \
\"texture_storage_3d\": \"storageTexture\"\n};\nvar parse = (source) => {\n  \
source = source.trim();\n  const declaration = \
source.match(declarationRegexp);\n  if (declaration !== null && \
declaration.length === 4) {\n    const inputsCode = declaration[2];\n    \
const propsMatches = [];\n    let match = null;\n    while ((match = \
propertiesRegexp.exec(inputsCode)) !== null) {\n      propsMatches.push({ \
name: match[1], type: match[2] });\n    }\n    const inputs = [];\n    for \
(let i = 0; i < propsMatches.length; i++) {\n      const { name: name2, type: \
type2 } = propsMatches[i];\n      let resolvedType = type2;\n      if \
(resolvedType.startsWith(\"ptr\")) {\n        resolvedType = \"pointer\";\n   \
   } else {\n        if (resolvedType.startsWith(\"texture\")) {\n          \
resolvedType = type2.split(\"<\")[0];\n        }\n        resolvedType = \
wgslTypeLib$1[resolvedType];\n      }\n      inputs.push(new \
NodeFunctionInput(resolvedType, name2));\n    }\n    const blockCode = \
source.substring(declaration[0].length);\n    const outputType = \
declaration[3] || \"void\";\n    const name = declaration[1] !== void 0 ? \
declaration[1] : \"\";\n    const type = wgslTypeLib$1[outputType] || \
outputType;\n    return {\n      type,\n      inputs,\n      name,\n      \
inputsCode,\n      blockCode,\n      outputType\n    };\n  } else {\n    \
throw new Error(\"FunctionNode: Function is not a WGSL code.\");\n  \
}\n};\nvar WGSLNodeFunction = class extends NodeFunction {\n  \
constructor(source) {\n    const { type, inputs, name, inputsCode, blockCode, \
outputType } = parse(source);\n    super(type, inputs, name);\n    \
this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n    \
this.outputType = outputType;\n  }\n  getCode(name = this.name) {\n    const \
outputType = this.outputType !== \"void\" ? \"-> \" + this.outputType : \
\"\";\n    return `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + \
this.blockCode;\n  }\n};\nvar WGSLNodeParser = class extends NodeParser {\n  \
parseFunction(source) {\n    return new WGSLNodeFunction(source);\n  \
}\n};\nvar GPUShaderStage = self.GPUShaderStage;\nvar gpuShaderStageLib = {\n \
 \"vertex\": GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n  \"fragment\": \
GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n  \"compute\": GPUShaderStage \
? GPUShaderStage.COMPUTE : 4\n};\nvar supports = {\n  instance: true,\n  \
swizzleAssign: false,\n  storageBuffer: true\n};\nvar wgslFnOpLib = {\n  \
\"^^\": \"tsl_xor\"\n};\nvar wgslTypeLib = {\n  float: \"f32\",\n  int: \
\"i32\",\n  uint: \"u32\",\n  bool: \"bool\",\n  color: \"vec3<f32>\",\n  \
vec2: \"vec2<f32>\",\n  ivec2: \"vec2<i32>\",\n  uvec2: \"vec2<u32>\",\n  \
bvec2: \"vec2<bool>\",\n  vec3: \"vec3<f32>\",\n  ivec3: \"vec3<i32>\",\n  \
uvec3: \"vec3<u32>\",\n  bvec3: \"vec3<bool>\",\n  vec4: \"vec4<f32>\",\n  \
ivec4: \"vec4<i32>\",\n  uvec4: \"vec4<u32>\",\n  bvec4: \"vec4<bool>\",\n  \
mat2: \"mat2x2<f32>\",\n  mat3: \"mat3x3<f32>\",\n  mat4: \
\"mat4x4<f32>\"\n};\nvar wgslPolyfill = {\n  tsl_xor: new CodeNode(\"fn \
tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); \
}\"),\n  mod_float: new CodeNode(\"fn tsl_mod_float( x : f32, y : f32 ) -> \
f32 { return x - y * floor( x / y ); }\"),\n  mod_vec2: new CodeNode(\"fn \
tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y \
); }\"),\n  mod_vec3: new CodeNode(\"fn tsl_mod_vec3( x : vec3f, y : vec3f ) \
-> vec3f { return x - y * floor( x / y ); }\"),\n  mod_vec4: new \
CodeNode(\"fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * \
floor( x / y ); }\"),\n  equals_bool: new CodeNode(\"fn tsl_equals_bool( a : \
bool, b : bool ) -> bool { return a == b; }\"),\n  equals_bvec2: new \
CodeNode(\"fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return \
vec2<bool>( a.x == b.x, a.y == b.y ); }\"),\n  equals_bvec3: new \
CodeNode(\"fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return \
vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }\"),\n  equals_bvec4: new \
CodeNode(\"fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return \
vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }\"),\n  \
repeatWrapping: new CodeNode(\n    /* wgsl */\n    `\nfn tsl_repeatWrapping( \
uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = \
vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % \
dimension ) + dimension ) % dimension;\n\n}\n`\n  ),\n  biquadraticTexture: \
new CodeNode(\n    /* wgsl */\n    `\nfn tsl_biquadraticTexture( map : \
texture_2d<f32>, coord : vec2f, level : i32 ) -> vec4f {\n\n\tlet iRes = \
vec2i( textureDimensions( map, level ) );\n\tlet res = vec2f( iRes \
);\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) \
+ res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = \
uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet \
rg1 = textureLoad( map, vec2i( iuv + vec2( 0.5, 0.5 ) ) % iRes, level \
);\n\tlet rg2 = textureLoad( map, vec2i( iuv + vec2( 1.5, 0.5 ) ) % iRes, \
level );\n\tlet rg3 = textureLoad( map, vec2i( iuv + vec2( 0.5, 1.5 ) ) % \
iRes, level );\n\tlet rg4 = textureLoad( map, vec2i( iuv + vec2( 1.5, 1.5 ) ) \
% iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), \
f.y );\n\n}\n`\n  )\n};\nvar wgslMethods = {\n  dFdx: \"dpdx\",\n  dFdy: \"- \
dpdy\",\n  mod_float: \"tsl_mod_float\",\n  mod_vec2: \"tsl_mod_vec2\",\n  \
mod_vec3: \"tsl_mod_vec3\",\n  mod_vec4: \"tsl_mod_vec4\",\n  equals_bool: \
\"tsl_equals_bool\",\n  equals_bvec2: \"tsl_equals_bvec2\",\n  equals_bvec3: \
\"tsl_equals_bvec3\",\n  equals_bvec4: \"tsl_equals_bvec4\",\n  inversesqrt: \
\"inverseSqrt\",\n  bitcast: \"bitcast<f32>\"\n};\nif \
(/Windows/g.test(navigator.userAgent)) {\n  wgslPolyfill.pow_float = new \
CodeNode(\"fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( \
-a, b ), pow( a, b ), a > 0.0 ); }\");\n  wgslPolyfill.pow_vec2 = new \
CodeNode(\"fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( \
tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }\", \
[wgslPolyfill.pow_float]);\n  wgslPolyfill.pow_vec3 = new CodeNode(\"fn \
tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( \
a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }\", \
[wgslPolyfill.pow_float]);\n  wgslPolyfill.pow_vec4 = new CodeNode(\"fn \
tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( \
a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), \
tsl_pow_float( a.w, b.w ) ); }\", [wgslPolyfill.pow_float]);\n  \
wgslMethods.pow_float = \"tsl_pow_float\";\n  wgslMethods.pow_vec2 = \
\"tsl_pow_vec2\";\n  wgslMethods.pow_vec3 = \"tsl_pow_vec3\";\n  \
wgslMethods.pow_vec4 = \"tsl_pow_vec4\";\n}\nvar diagnostics = \"\";\nif \
(/Firefox|Deno/g.test(navigator.userAgent) !== true) {\n  diagnostics += \
\"diagnostic( off, derivative_uniformity );\\n\";\n}\nvar WGSLNodeBuilder = \
class extends NodeBuilder {\n  constructor(object, renderer3) {\n    \
super(object, renderer3, new WGSLNodeParser());\n    this.uniformGroups = \
{};\n    this.builtins = {};\n    this.directives = {};\n    \
this.scopedArrays = /* @__PURE__ */ new Map();\n  }\n  \
needsToWorkingColorSpace(texture2) {\n    return texture2.isVideoTexture === \
true && texture2.colorSpace !== NoColorSpace2;\n  }\n  \
_generateTextureSample(texture2, textureProperty, uvSnippet, depthSnippet, \
shaderStage = this.shaderStage) {\n    if (shaderStage === \"fragment\") {\n  \
    if (depthSnippet) {\n        return `textureSample( ${textureProperty}, \
${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;\n      } else \
{\n        return `textureSample( ${textureProperty}, \
${textureProperty}_sampler, ${uvSnippet} )`;\n      }\n    } else if \
(this.isFilteredTexture(texture2)) {\n      return \
this.generateFilteredTexture(texture2, textureProperty, uvSnippet);\n    } \
else {\n      return this.generateTextureLod(texture2, textureProperty, \
uvSnippet, \"0\");\n    }\n  }\n  _generateVideoSample(textureProperty, \
uvSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === \
\"fragment\") {\n      return `textureSampleBaseClampToEdge( \
${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, \
1.0 - ${uvSnippet}.y ) )`;\n    } else {\n      \
console.error(`WebGPURenderer: THREE.VideoTexture does not support \
${shaderStage} shader.`);\n    }\n  }\n  \
_generateTextureSampleLevel(texture2, textureProperty, uvSnippet, \
levelSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if \
(shaderStage === \"fragment\" && this.isUnfilterable(texture2) === false) {\n \
     return `textureSampleLevel( ${textureProperty}, \
${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;\n    } else if \
(this.isFilteredTexture(texture2)) {\n      return \
this.generateFilteredTexture(texture2, textureProperty, uvSnippet, \
levelSnippet);\n    } else {\n      return this.generateTextureLod(texture2, \
textureProperty, uvSnippet, levelSnippet);\n    }\n  }\n  \
generateFilteredTexture(texture2, textureProperty, uvSnippet, levelSnippet = \
\"0\") {\n    this._include(\"biquadraticTexture\");\n    return \
`tsl_biquadraticTexture( ${textureProperty}, ${uvSnippet}, i32( \
${levelSnippet} ) )`;\n  }\n  generateTextureLod(texture2, textureProperty, \
uvSnippet, levelSnippet = \"0\") {\n    this._include(\"repeatWrapping\");\n  \
  const dimension = texture2.isMultisampleRenderTargetTexture === true ? \
`textureDimensions( ${textureProperty} )` : `textureDimensions( \
${textureProperty}, 0 )`;\n    return `textureLoad( ${textureProperty}, \
tsl_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${levelSnippet} ) \
)`;\n  }\n  generateTextureLoad(texture2, textureProperty, uvIndexSnippet, \
depthSnippet, levelSnippet = \"0u\") {\n    if (depthSnippet) {\n      return \
`textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, \
${levelSnippet} )`;\n    } else {\n      return `textureLoad( \
${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;\n    }\n  }\n  \
generateTextureStore(texture2, textureProperty, uvIndexSnippet, valueSnippet) \
{\n    return `textureStore( ${textureProperty}, ${uvIndexSnippet}, \
${valueSnippet} )`;\n  }\n  isUnfilterable(texture2) {\n    return \
this.getComponentTypeFromTexture(texture2) !== \"float\" || \
!this.isAvailable(\"float32Filterable\") && texture2.isDataTexture === true \
&& texture2.type === FloatType2 || texture2.isMultisampleRenderTargetTexture \
=== true;\n  }\n  generateTexture(texture2, textureProperty, uvSnippet, \
depthSnippet, shaderStage = this.shaderStage) {\n    let snippet = null;\n    \
if (texture2.isVideoTexture === true) {\n      snippet = \
this._generateVideoSample(textureProperty, uvSnippet, shaderStage);\n    } \
else if (this.isUnfilterable(texture2)) {\n      snippet = \
this.generateTextureLod(texture2, textureProperty, uvSnippet, \"0\", \
depthSnippet, shaderStage);\n    } else {\n      snippet = \
this._generateTextureSample(texture2, textureProperty, uvSnippet, \
depthSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  \
generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet, \
depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === \
\"fragment\") {\n      return `textureSampleGrad( ${textureProperty}, \
${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, \
${gradSnippet[1]} )`;\n    } else {\n      console.error(`WebGPURenderer: \
THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);\n    \
}\n  }\n  generateTextureCompare(texture2, textureProperty, uvSnippet, \
compareSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if \
(shaderStage === \"fragment\") {\n      return `textureSampleCompare( \
${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, \
${compareSnippet} )`;\n    } else {\n      console.error(`WebGPURenderer: \
THREE.DepthTexture.compareFunction() does not support ${shaderStage} \
shader.`);\n    }\n  }\n  generateTextureLevel(texture2, textureProperty, \
uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    \
let snippet = null;\n    if (texture2.isVideoTexture === true) {\n      \
snippet = this._generateVideoSample(textureProperty, uvSnippet, \
shaderStage);\n    } else {\n      snippet = \
this._generateTextureSampleLevel(texture2, textureProperty, uvSnippet, \
levelSnippet, depthSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  \
generateTextureBias(texture2, textureProperty, uvSnippet, biasSnippet, \
depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === \
\"fragment\") {\n      return `textureSampleBias( ${textureProperty}, \
${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;\n    } else {\n  \
    console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not \
support ${shaderStage} shader.`);\n    }\n  }\n  getPropertyName(node, \
shaderStage = this.shaderStage) {\n    if (node.isNodeVarying === true && \
node.needsInterpolation === true) {\n      if (shaderStage === \"vertex\") \
{\n        return `varyings.${node.name}`;\n      }\n    } else if \
(node.isNodeUniform === true) {\n      const name = node.name;\n      const \
type = node.type;\n      if (type === \"texture\" || type === \"cubeTexture\" \
|| type === \"storageTexture\" || type === \"texture3D\") {\n        return \
name;\n      } else if (type === \"buffer\" || type === \"storageBuffer\" || \
type === \"indirectStorageBuffer\") {\n        return \
`NodeBuffer_${node.id}.${name}`;\n      } else {\n        return \
node.groupNode.name + \".\" + name;\n      }\n    }\n    return \
super.getPropertyName(node);\n  }\n  getOutputStructName() {\n    return \
\"output\";\n  }\n  _getUniformGroupCount(shaderStage) {\n    return \
Object.keys(this.uniforms[shaderStage]).length;\n  }\n  \
getFunctionOperator(op) {\n    const fnOp = wgslFnOpLib[op];\n    if (fnOp \
!== void 0) {\n      this._include(fnOp);\n      return fnOp;\n    }\n    \
return null;\n  }\n  getStorageAccess(node) {\n    if \
(node.isStorageTextureNode) {\n      switch (node.access) {\n        case \
GPUStorageTextureAccess.ReadOnly:\n          return \"read\";\n        case \
GPUStorageTextureAccess.WriteOnly:\n          return \"write\";\n        \
default:\n          return \"read_write\";\n      }\n    } else {\n      \
switch (node.access) {\n        case GPUBufferBindingType.Storage:\n          \
return \"read_write\";\n        case GPUBufferBindingType.ReadOnlyStorage:\n  \
        return \"read\";\n        default:\n          return \"write\";\n     \
 }\n    }\n  }\n  getUniformFromNode(node, type, shaderStage, name = null) \
{\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage, \
name);\n    const nodeData = this.getDataFromNode(node, shaderStage, \
this.globalCache);\n    if (nodeData.uniformGPU === void 0) {\n      let \
uniformGPU;\n      const group = node.groupNode;\n      const groupName = \
group.name;\n      const bindings = this.getBindGroupArray(groupName, \
shaderStage);\n      if (type === \"texture\" || type === \"cubeTexture\" || \
type === \"storageTexture\" || type === \"texture3D\") {\n        let \
texture2 = null;\n        if (type === \"texture\" || type === \
\"storageTexture\") {\n          texture2 = new \
NodeSampledTexture(uniformNode.name, uniformNode.node, group, node.access ? \
node.access : null);\n        } else if (type === \"cubeTexture\") {\n        \
  texture2 = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, \
group, node.access ? node.access : null);\n        } else if (type === \
\"texture3D\") {\n          texture2 = new \
NodeSampledTexture3D(uniformNode.name, uniformNode.node, group, node.access ? \
node.access : null);\n        }\n        texture2.store = \
node.isStorageTextureNode === true;\n        \
texture2.setVisibility(gpuShaderStageLib[shaderStage]);\n        if \
(shaderStage === \"fragment\" && this.isUnfilterable(node.value) === false && \
texture2.store === false) {\n          const sampler = new \
NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node, group);\n        \
  sampler.setVisibility(gpuShaderStageLib[shaderStage]);\n          \
bindings.push(sampler, texture2);\n          uniformGPU = [sampler, \
texture2];\n        } else {\n          bindings.push(texture2);\n          \
uniformGPU = [texture2];\n        }\n      } else if (type === \"buffer\" || \
type === \"storageBuffer\" || type === \"indirectStorageBuffer\") {\n        \
const bufferClass = type === \"buffer\" ? NodeUniformBuffer : \
NodeStorageBuffer;\n        const buffer2 = new bufferClass(node, group);\n   \
     buffer2.setVisibility(gpuShaderStageLib[shaderStage]);\n        \
bindings.push(buffer2);\n        uniformGPU = buffer2;\n      } else {\n      \
  const uniformsStage = this.uniformGroups[shaderStage] || \
(this.uniformGroups[shaderStage] = {});\n        let uniformsGroup = \
uniformsStage[groupName];\n        if (uniformsGroup === void 0) {\n          \
uniformsGroup = new NodeUniformsGroup(groupName, group);\n          \
uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);\n          \
uniformsStage[groupName] = uniformsGroup;\n          \
bindings.push(uniformsGroup);\n        }\n        uniformGPU = \
this.getNodeUniform(uniformNode, type);\n        \
uniformsGroup.addUniform(uniformGPU);\n      }\n      nodeData.uniformGPU = \
uniformGPU;\n    }\n    return uniformNode;\n  }\n  getBuiltin(name, \
property2, type, shaderStage = this.shaderStage) {\n    const map = \
this.builtins[shaderStage] || (this.builtins[shaderStage] = /* @__PURE__ */ \
new Map());\n    if (map.has(name) === false) {\n      map.set(name, {\n      \
  name,\n        property: property2,\n        type\n      });\n    }\n    \
return property2;\n  }\n  hasBuiltin(name, shaderStage = this.shaderStage) \
{\n    return this.builtins[shaderStage] !== void 0 && \
this.builtins[shaderStage].has(name);\n  }\n  getVertexIndex() {\n    if \
(this.shaderStage === \"vertex\") {\n      return \
this.getBuiltin(\"vertex_index\", \"vertexIndex\", \"u32\", \"attribute\");\n \
   }\n    return \"vertexIndex\";\n  }\n  buildFunctionCode(shaderNode) {\n   \
 const layout = shaderNode.layout;\n    const flowData = \
this.flowShaderNode(shaderNode);\n    const parameters = [];\n    for (const \
input of layout.inputs) {\n      parameters.push(input.name + \" : \" + \
this.getType(input.type));\n    }\n    let code = `fn ${layout.name}( \
${parameters.join(\", \")} ) -> ${this.getType(layout.type)} \
{\n${flowData.vars}\n${flowData.code}\n`;\n    if (flowData.result) {\n      \
code += `\treturn ${flowData.result};\n`;\n    }\n    code += \"\\n}\\n\";\n  \
  return code;\n  }\n  getInstanceIndex() {\n    if (this.shaderStage === \
\"vertex\") {\n      return this.getBuiltin(\"instance_index\", \
\"instanceIndex\", \"u32\", \"attribute\");\n    }\n    return \
\"instanceIndex\";\n  }\n  getInvocationLocalIndex() {\n    return \
this.getBuiltin(\"local_invocation_index\", \"invocationLocalIndex\", \
\"u32\", \"attribute\");\n  }\n  getSubgroupSize() {\n    \
this.enableSubGroups();\n    return this.getBuiltin(\"subgroup_size\", \
\"subgroupSize\", \"u32\", \"attribute\");\n  }\n  \
getInvocationSubgroupIndex() {\n    this.enableSubGroups();\n    return \
this.getBuiltin(\"subgroup_invocation_id\", \"invocationSubgroupIndex\", \
\"u32\", \"attribute\");\n  }\n  getSubgroupIndex() {\n    \
this.enableSubGroups();\n    return this.getBuiltin(\"subgroup_id\", \
\"subgroupIndex\", \"u32\", \"attribute\");\n  }\n  getDrawIndex() {\n    \
return null;\n  }\n  getFrontFacing() {\n    return \
this.getBuiltin(\"front_facing\", \"isFront\", \"bool\");\n  }\n  \
getFragCoord() {\n    return this.getBuiltin(\"position\", \"fragCoord\", \
\"vec4<f32>\") + \".xy\";\n  }\n  getFragDepth() {\n    return \"output.\" + \
this.getBuiltin(\"frag_depth\", \"depth\", \"f32\", \"output\");\n  }\n  \
isFlipY() {\n    return false;\n  }\n  enableDirective(name, shaderStage = \
this.shaderStage) {\n    const stage = this.directives[shaderStage] || \
(this.directives[shaderStage] = /* @__PURE__ */ new Set());\n    \
stage.add(name);\n  }\n  getDirectives(shaderStage) {\n    const snippets = \
[];\n    const directives = this.directives[shaderStage];\n    if (directives \
!== void 0) {\n      for (const directive of directives) {\n        \
snippets.push(`enable ${directive};`);\n      }\n    }\n    return \
snippets.join(\"\\n\");\n  }\n  enableSubGroups() {\n    \
this.enableDirective(\"subgroups\");\n  }\n  enableSubgroupsF16() {\n    \
this.enableDirective(\"subgroups-f16\");\n  }\n  enableClipDistances() {\n    \
this.enableDirective(\"clip_distances\");\n  }\n  enableShaderF16() {\n    \
this.enableDirective(\"f16\");\n  }\n  enableDualSourceBlending() {\n    \
this.enableDirective(\"dual_source_blending\");\n  }\n  \
getBuiltins(shaderStage) {\n    const snippets = [];\n    const builtins = \
this.builtins[shaderStage];\n    if (builtins !== void 0) {\n      for (const \
{ name, property: property2, type } of builtins.values()) {\n        \
snippets.push(`@builtin( ${name} ) ${property2} : ${type}`);\n      }\n    \
}\n    return snippets.join(\",\\n\t\");\n  }\n  getScopedArray(name, scope, \
bufferType, bufferCount) {\n    if (this.scopedArrays.has(name) === false) \
{\n      this.scopedArrays.set(name, {\n        name,\n        scope,\n       \
 bufferType,\n        bufferCount\n      });\n    }\n    return name;\n  }\n  \
getScopedArrays(shaderStage) {\n    if (shaderStage !== \"compute\") {\n      \
return;\n    }\n    const snippets = [];\n    for (const { name, scope, \
bufferType, bufferCount } of this.scopedArrays.values()) {\n      const type \
= this.getType(bufferType);\n      snippets.push(`var<${scope}> ${name}: \
array< ${type}, ${bufferCount} >;`);\n    }\n    return \
snippets.join(\"\\n\");\n  }\n  getAttributes(shaderStage) {\n    const \
snippets = [];\n    if (shaderStage === \"compute\") {\n      \
this.getBuiltin(\"global_invocation_id\", \"id\", \"vec3<u32>\", \
\"attribute\");\n      this.getBuiltin(\"workgroup_id\", \"workgroupId\", \
\"vec3<u32>\", \"attribute\");\n      \
this.getBuiltin(\"local_invocation_id\", \"localId\", \"vec3<u32>\", \
\"attribute\");\n      this.getBuiltin(\"num_workgroups\", \"numWorkgroups\", \
\"vec3<u32>\", \"attribute\");\n      if \
(this.renderer.hasFeature(\"subgroups\")) {\n        \
this.enableDirective(\"subgroups\", shaderStage);\n        \
this.getBuiltin(\"subgroup_size\", \"subgroupSize\", \"u32\", \
\"attribute\");\n      }\n    }\n    if (shaderStage === \"vertex\" || \
shaderStage === \"compute\") {\n      const builtins = \
this.getBuiltins(\"attribute\");\n      if (builtins) \
snippets.push(builtins);\n      const attributes = \
this.getAttributesArray();\n      for (let index5 = 0, length2 = \
attributes.length; index5 < length2; index5++) {\n        const attribute2 = \
attributes[index5];\n        const name = attribute2.name;\n        const \
type = this.getType(attribute2.type);\n        snippets.push(`@location( \
${index5} ) ${name} : ${type}`);\n      }\n    }\n    return \
snippets.join(\",\\n\t\");\n  }\n  getStructMembers(struct) {\n    const \
snippets = [];\n    const members = struct.getMemberTypes();\n    for (let i \
= 0; i < members.length; i++) {\n      const member = members[i];\n      \
snippets.push(`\t@location( ${i} ) m${i} : ${member}<f32>`);\n    }\n    \
const builtins = this.getBuiltins(\"output\");\n    if (builtins) \
snippets.push(\"\t\" + builtins);\n    return snippets.join(\",\\n\");\n  }\n \
 getStructs(shaderStage) {\n    const snippets = [];\n    const structs = \
this.structs[shaderStage];\n    for (let index5 = 0, length2 = \
structs.length; index5 < length2; index5++) {\n      const struct = \
structs[index5];\n      const name = struct.name;\n      let snippet = \
`struct ${name} {\n`;\n      snippet += this.getStructMembers(struct);\n      \
snippet += \"\\n}\";\n      snippets.push(snippet);\n      \
snippets.push(`\nvar<private> output : ${name};\n\n`);\n    }\n    return \
snippets.join(\"\\n\\n\");\n  }\n  getVar(type, name) {\n    return `var \
${name} : ${this.getType(type)}`;\n  }\n  getVars(shaderStage) {\n    const \
snippets = [];\n    const vars = this.vars[shaderStage];\n    if (vars !== \
void 0) {\n      for (const variable of vars) {\n        \
snippets.push(`\t${this.getVar(variable.type, variable.name)};`);\n      }\n  \
  }\n    return `\n${snippets.join(\"\\n\")}\n`;\n  }\n  \
getVaryings(shaderStage) {\n    const snippets = [];\n    if (shaderStage === \
\"vertex\") {\n      this.getBuiltin(\"position\", \"Vertex\", \"vec4<f32>\", \
\"vertex\");\n    }\n    if (shaderStage === \"vertex\" || shaderStage === \
\"fragment\") {\n      const varyings = this.varyings;\n      const vars = \
this.vars[shaderStage];\n      for (let index5 = 0; index5 < varyings.length; \
index5++) {\n        const varying2 = varyings[index5];\n        if \
(varying2.needsInterpolation) {\n          let attributesSnippet = \
`@location( ${index5} )`;\n          if \
(/^(int|uint|ivec|uvec)/.test(varying2.type)) {\n            \
attributesSnippet += \" @interpolate( flat )\";\n          }\n          \
snippets.push(`${attributesSnippet} ${varying2.name} : \
${this.getType(varying2.type)}`);\n        } else if (shaderStage === \
\"vertex\" && vars.includes(varying2) === false) {\n          \
vars.push(varying2);\n        }\n      }\n    }\n    const builtins = \
this.getBuiltins(shaderStage);\n    if (builtins) snippets.push(builtins);\n  \
  const code = snippets.join(\",\\n\t\");\n    return shaderStage === \
\"vertex\" ? this._getWGSLStruct(\"VaryingsStruct\", \"\t\" + code) : code;\n \
 }\n  getUniforms(shaderStage) {\n    const uniforms = \
this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const \
bufferSnippets = [];\n    const structSnippets = [];\n    const uniformGroups \
= {};\n    for (const uniform2 of uniforms) {\n      const groupName = \
uniform2.groupNode.name;\n      const uniformIndexes = \
this.bindingsIndexes[groupName];\n      if (uniform2.type === \"texture\" || \
uniform2.type === \"cubeTexture\" || uniform2.type === \"storageTexture\" || \
uniform2.type === \"texture3D\") {\n        const texture2 = \
uniform2.node.value;\n        if (shaderStage === \"fragment\" && \
this.isUnfilterable(texture2) === false && uniform2.node.isStorageTextureNode \
!== true) {\n          if (texture2.isDepthTexture === true && \
texture2.compareFunction !== null) {\n            \
bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( \
${uniformIndexes.group} ) var ${uniform2.name}_sampler : \
sampler_comparison;`);\n          } else {\n            \
bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( \
${uniformIndexes.group} ) var ${uniform2.name}_sampler : sampler;`);\n        \
  }\n        }\n        let textureType;\n        let multisampled = \"\";\n  \
      if (texture2.isMultisampleRenderTargetTexture === true) {\n          \
multisampled = \"_multisampled\";\n        }\n        if \
(texture2.isCubeTexture === true) {\n          textureType = \
\"texture_cube<f32>\";\n        } else if (texture2.isDataArrayTexture === \
true || texture2.isCompressedArrayTexture === true) {\n          textureType \
= \"texture_2d_array<f32>\";\n        } else if (texture2.isDepthTexture === \
true) {\n          textureType = `texture_depth${multisampled}_2d`;\n        \
} else if (texture2.isVideoTexture === true) {\n          textureType = \
\"texture_external\";\n        } else if (texture2.isData3DTexture === true) \
{\n          textureType = \"texture_3d<f32>\";\n        } else if \
(uniform2.node.isStorageTextureNode === true) {\n          const format2 = \
getFormat2(texture2);\n          const access = \
this.getStorageAccess(uniform2.node);\n          textureType = \
`texture_storage_2d<${format2}, ${access}>`;\n        } else {\n          \
const componentPrefix = \
this.getComponentTypeFromTexture(texture2).charAt(0);\n          textureType \
= `texture${multisampled}_2d<${componentPrefix}32>`;\n        }\n        \
bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( \
${uniformIndexes.group} ) var ${uniform2.name} : ${textureType};`);\n      } \
else if (uniform2.type === \"buffer\" || uniform2.type === \"storageBuffer\" \
|| uniform2.type === \"indirectStorageBuffer\") {\n        const bufferNode = \
uniform2.node;\n        const bufferType = \
this.getType(bufferNode.bufferType);\n        const bufferCount = \
bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 \
&& uniform2.type === \"buffer\" ? \", \" + bufferCount : \"\";\n        const \
bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : \
`${bufferType}`;\n        const bufferSnippet = `\t${uniform2.name} : array< \
${bufferTypeSnippet}${bufferCountSnippet} >\n`;\n        const \
bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, \
${this.getStorageAccess(bufferNode)}` : \"uniform\";\n        \
bufferSnippets.push(this._getWGSLStructBinding(\"NodeBuffer_\" + \
bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding++, \
uniformIndexes.group));\n      } else {\n        const vectorType = \
this.getType(this.getVectorType(uniform2.type));\n        const groupName2 = \
uniform2.groupNode.name;\n        const group = uniformGroups[groupName2] || \
(uniformGroups[groupName2] = {\n          index: uniformIndexes.binding++,\n  \
        id: uniformIndexes.group,\n          snippets: []\n        });\n      \
  group.snippets.push(`\t${uniform2.name} : ${vectorType}`);\n      }\n    \
}\n    for (const name in uniformGroups) {\n      const group = \
uniformGroups[name];\n      \
structSnippets.push(this._getWGSLStructBinding(name, \
group.snippets.join(\",\\n\"), \"uniform\", group.index, group.id));\n    }\n \
   let code = bindingSnippets.join(\"\\n\");\n    code += \
bufferSnippets.join(\"\\n\");\n    code += structSnippets.join(\"\\n\");\n    \
return code;\n  }\n  buildCode() {\n    const shadersData = this.material !== \
null ? { fragment: {}, vertex: {} } : { compute: {} };\n    \
this.sortBindingGroups();\n    for (const shaderStage in shadersData) {\n     \
 const stageData = shadersData[shaderStage];\n      stageData.uniforms = \
this.getUniforms(shaderStage);\n      stageData.attributes = \
this.getAttributes(shaderStage);\n      stageData.varyings = \
this.getVaryings(shaderStage);\n      stageData.structs = \
this.getStructs(shaderStage);\n      stageData.vars = \
this.getVars(shaderStage);\n      stageData.codes = \
this.getCodes(shaderStage);\n      stageData.directives = \
this.getDirectives(shaderStage);\n      stageData.scopedArrays = \
this.getScopedArrays(shaderStage);\n      let flow = \"// code\\n\\n\";\n     \
 flow += this.flowCode[shaderStage];\n      const flowNodes = \
this.flowNodes[shaderStage];\n      const mainNode = \
flowNodes[flowNodes.length - 1];\n      const outputNode = \
mainNode.outputNode;\n      const isOutputStruct = outputNode !== void 0 && \
outputNode.isOutputStructNode === true;\n      for (const node of flowNodes) \
{\n        const flowSlotData = this.getFlowData(\n          node\n          \
/*, shaderStage*/\n        );\n        const slotName = node.name;\n        \
if (slotName) {\n          if (flow.length > 0) flow += \"\\n\";\n          \
flow += `\t// flow -> ${slotName}\n\t`;\n        }\n        flow += \
`${flowSlotData.code}\n\t`;\n        if (node === mainNode && shaderStage !== \
\"compute\") {\n          flow += \"// result\\n\\n\t\";\n          if \
(shaderStage === \"vertex\") {\n            flow += `varyings.Vertex = \
${flowSlotData.result};`;\n          } else if (shaderStage === \"fragment\") \
{\n            if (isOutputStruct) {\n              stageData.returnType = \
outputNode.nodeType;\n              flow += `return \
${flowSlotData.result};`;\n            } else {\n              let \
structSnippet = \"\t@location(0) color: vec4<f32>\";\n              const \
builtins = this.getBuiltins(\"output\");\n              if (builtins) \
structSnippet += \",\\n\t\" + builtins;\n              stageData.returnType = \
\"OutputStruct\";\n              stageData.structs += \
this._getWGSLStruct(\"OutputStruct\", structSnippet);\n              \
stageData.structs += \"\\nvar<private> output : OutputStruct;\\n\\n\";\n      \
        flow += `output.color = ${flowSlotData.result};\n\n\treturn \
output;`;\n            }\n          }\n        }\n      }\n      \
stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      \
this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);\n      \
this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);\n    } \
else {\n      this.computeShader = \
this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || \
[64]).join(\", \"));\n    }\n  }\n  getMethod(method, output2 = null) {\n    \
let wgslMethod;\n    if (output2 !== null) {\n      wgslMethod = \
this._getWGSLMethod(method + \"_\" + output2);\n    }\n    if (wgslMethod === \
void 0) {\n      wgslMethod = this._getWGSLMethod(method);\n    }\n    return \
wgslMethod || method;\n  }\n  getType(type) {\n    return wgslTypeLib[type] \
|| type;\n  }\n  isAvailable(name) {\n    let result = supports[name];\n    \
if (result === void 0) {\n      if (name === \"float32Filterable\") {\n       \
 result = this.renderer.hasFeature(\"float32-filterable\");\n      }\n      \
supports[name] = result;\n    }\n    return result;\n  }\n  \
_getWGSLMethod(method) {\n    if (wgslPolyfill[method] !== void 0) {\n      \
this._include(method);\n    }\n    return wgslMethods[method];\n  }\n  \
_include(name) {\n    const codeNode = wgslPolyfill[name];\n    \
codeNode.build(this);\n    if (this.currentFunctionNode !== null) {\n      \
this.currentFunctionNode.includes.push(codeNode);\n    }\n    return \
codeNode;\n  }\n  _getWGSLVertexCode(shaderData) {\n    return \
`${this.getSignature()}\n// directives\n${shaderData.directives}\n\n// \
uniforms\n${shaderData.uniforms}\n\n// \
varyings\n${shaderData.varyings}\nvar<private> varyings : \
VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( \
${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// \
vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn \
varyings;\n\n}\n`;\n  }\n  _getWGSLFragmentCode(shaderData) {\n    return \
`${this.getSignature()}\n// global\n${diagnostics}\n\n// \
uniforms\n${shaderData.uniforms}\n\n// structs\n${shaderData.structs}\n\n// \
codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> \
${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// \
flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLComputeCode(shaderData, \
workgroupSize) {\n    return `${this.getSignature()}\n// \
directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex \
: u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// \
uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute \
@workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) \
{\n\n\t// system\n\tinstanceIndex = id.x + id.y * numWorkgroups.x * \
u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * \
u32(${workgroupSize});\n\n\t// vars\n\t${shaderData.vars}\n\n\t// \
flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLStruct(name, vars) {\n    \
return `\nstruct ${name} {\n${vars}\n};`;\n  }\n  _getWGSLStructBinding(name, \
vars, access, binding = 0, group = 0) {\n    const structName = name + \
\"Struct\";\n    const structSnippet = this._getWGSLStruct(structName, \
vars);\n    return `${structSnippet}\n@binding( ${binding} ) @group( ${group} \
)\nvar<${access}> ${name} : ${structName};`;\n  }\n};\nvar WebGPUUtils = \
class {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  \
getCurrentDepthStencilFormat(renderContext) {\n    let format2;\n    if \
(renderContext.depthTexture !== null) {\n      format2 = \
this.getTextureFormatGPU(renderContext.depthTexture);\n    } else if \
(renderContext.depth && renderContext.stencil) {\n      format2 = \
GPUTextureFormat.Depth24PlusStencil8;\n    } else if (renderContext.depth) \
{\n      format2 = GPUTextureFormat.Depth24Plus;\n    }\n    return \
format2;\n  }\n  getTextureFormatGPU(texture2) {\n    return \
this.backend.get(texture2).format;\n  }\n  \
getCurrentColorFormat(renderContext) {\n    let format2;\n    if \
(renderContext.textures !== null) {\n      format2 = \
this.getTextureFormatGPU(renderContext.textures[0]);\n    } else {\n      \
format2 = this.getPreferredCanvasFormat();\n    }\n    return format2;\n  }\n \
 getCurrentColorSpace(renderContext) {\n    if (renderContext.textures !== \
null) {\n      return renderContext.textures[0].colorSpace;\n    }\n    \
return this.backend.renderer.outputColorSpace;\n  }\n  \
getPrimitiveTopology(object, material) {\n    if (object.isPoints) return \
GPUPrimitiveTopology.PointList;\n    else if (object.isLineSegments || \
object.isMesh && material.wireframe === true) return \
GPUPrimitiveTopology.LineList;\n    else if (object.isLine) return \
GPUPrimitiveTopology.LineStrip;\n    else if (object.isMesh) return \
GPUPrimitiveTopology.TriangleList;\n  }\n  getSampleCount(sampleCount) {\n    \
let count = 1;\n    if (sampleCount > 1) {\n      count = Math.pow(2, \
Math.floor(Math.log2(sampleCount)));\n      if (count === 2) {\n        count \
= 4;\n      }\n    }\n    return count;\n  }\n  \
getSampleCountRenderContext(renderContext) {\n    if (renderContext.textures \
!== null) {\n      return this.getSampleCount(renderContext.sampleCount);\n   \
 }\n    return this.getSampleCount(this.backend.renderer.samples);\n  }\n  \
getPreferredCanvasFormat() {\n    if \
(navigator.userAgent.includes(\"Quest\")) {\n      return \
GPUTextureFormat.BGRA8Unorm;\n    } else {\n      return \
navigator.gpu.getPreferredCanvasFormat();\n    }\n  }\n};\nvar \
typedArraysToVertexFormatPrefix = /* @__PURE__ */ new Map([\n  [Int8Array, \
[\"sint8\", \"snorm8\"]],\n  [Uint8Array, [\"uint8\", \"unorm8\"]],\n  \
[Int16Array, [\"sint16\", \"snorm16\"]],\n  [Uint16Array, [\"uint16\", \
\"unorm16\"]],\n  [Int32Array, [\"sint32\", \"snorm32\"]],\n  [Uint32Array, \
[\"uint32\", \"unorm32\"]],\n  [Float32Array, [\"float32\"]]\n]);\nvar \
typedAttributeToVertexFormatPrefix = /* @__PURE__ */ new Map([\n  \
[Float16BufferAttribute, [\"float16\"]]\n]);\nvar \
typeArraysToVertexFormatPrefixForItemSize1 = /* @__PURE__ */ new Map([\n  \
[Int32Array, \"sint32\"],\n  [Int16Array, \"sint32\"],\n  // patch for \
INT16\n  [Uint32Array, \"uint32\"],\n  [Uint16Array, \"uint32\"],\n  // patch \
for UINT16\n  [Float32Array, \"float32\"]\n]);\nvar WebGPUAttributeUtils = \
class {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  \
createAttribute(attribute2, usage) {\n    const bufferAttribute2 = \
this._getBufferAttribute(attribute2);\n    const backend = this.backend;\n    \
const bufferData = backend.get(bufferAttribute2);\n    let buffer2 = \
bufferData.buffer;\n    if (buffer2 === void 0) {\n      const device = \
backend.device;\n      let array = bufferAttribute2.array;\n      if \
(attribute2.normalized === false && (array.constructor === Int16Array || \
array.constructor === Uint16Array)) {\n        const tempArray = new \
Uint32Array(array.length);\n        for (let i = 0; i < array.length; i++) \
{\n          tempArray[i] = array[i];\n        }\n        array = \
tempArray;\n      }\n      bufferAttribute2.array = array;\n      if \
((bufferAttribute2.isStorageBufferAttribute || \
bufferAttribute2.isStorageInstancedBufferAttribute) && \
bufferAttribute2.itemSize === 3) {\n        array = new \
array.constructor(bufferAttribute2.count * 4);\n        for (let i = 0; i < \
bufferAttribute2.count; i++) {\n          \
array.set(bufferAttribute2.array.subarray(i * 3, i * 3 + 3), i * 4);\n        \
}\n        bufferAttribute2.itemSize = 4;\n        bufferAttribute2.array = \
array;\n      }\n      const size = array.byteLength + (4 - array.byteLength \
% 4) % 4;\n      buffer2 = device.createBuffer({\n        label: \
bufferAttribute2.name,\n        size,\n        usage,\n        \
mappedAtCreation: true\n      });\n      new \
array.constructor(buffer2.getMappedRange()).set(array);\n      \
buffer2.unmap();\n      bufferData.buffer = buffer2;\n    }\n  }\n  \
updateAttribute(attribute2) {\n    const bufferAttribute2 = \
this._getBufferAttribute(attribute2);\n    const backend = this.backend;\n    \
const device = backend.device;\n    const buffer2 = \
backend.get(bufferAttribute2).buffer;\n    const array = \
bufferAttribute2.array;\n    const updateRanges = \
bufferAttribute2.updateRanges;\n    if (updateRanges.length === 0) {\n      \
device.queue.writeBuffer(\n        buffer2,\n        0,\n        array,\n     \
   0\n      );\n    } else {\n      for (let i = 0, l = updateRanges.length; \
i < l; i++) {\n        const range = updateRanges[i];\n        \
device.queue.writeBuffer(\n          buffer2,\n          0,\n          \
array,\n          range.start * array.BYTES_PER_ELEMENT,\n          \
range.count * array.BYTES_PER_ELEMENT\n        );\n      }\n      \
bufferAttribute2.clearUpdateRanges();\n    }\n  }\n  \
createShaderVertexBuffers(renderObject) {\n    const attributes = \
renderObject.getAttributes();\n    const vertexBuffers = /* @__PURE__ */ new \
Map();\n    for (let slot = 0; slot < attributes.length; slot++) {\n      \
const geometryAttribute = attributes[slot];\n      const bytesPerElement = \
geometryAttribute.array.BYTES_PER_ELEMENT;\n      const bufferAttribute2 = \
this._getBufferAttribute(geometryAttribute);\n      let vertexBufferLayout = \
vertexBuffers.get(bufferAttribute2);\n      if (vertexBufferLayout === void \
0) {\n        let arrayStride, stepMode;\n        if \
(geometryAttribute.isInterleavedBufferAttribute === true) {\n          \
arrayStride = geometryAttribute.data.stride * bytesPerElement;\n          \
stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? \
GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        } else {\n      \
    arrayStride = geometryAttribute.itemSize * bytesPerElement;\n          \
stepMode = geometryAttribute.isInstancedBufferAttribute ? \
GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        }\n        if \
(geometryAttribute.normalized === false && \
(geometryAttribute.array.constructor === Int16Array || \
geometryAttribute.array.constructor === Uint16Array)) {\n          \
arrayStride = 4;\n        }\n        vertexBufferLayout = {\n          \
arrayStride,\n          attributes: [],\n          stepMode\n        };\n     \
   vertexBuffers.set(bufferAttribute2, vertexBufferLayout);\n      }\n      \
const format2 = this._getVertexFormat(geometryAttribute);\n      const offset \
= geometryAttribute.isInterleavedBufferAttribute === true ? \
geometryAttribute.offset * bytesPerElement : 0;\n      \
vertexBufferLayout.attributes.push({\n        shaderLocation: slot,\n        \
offset,\n        format: format2\n      });\n    }\n    return \
Array.from(vertexBuffers.values());\n  }\n  destroyAttribute(attribute2) {\n  \
  const backend = this.backend;\n    const data = \
backend.get(this._getBufferAttribute(attribute2));\n    \
data.buffer.destroy();\n    backend.delete(attribute2);\n  }\n  async \
getArrayBufferAsync(attribute2) {\n    const backend = this.backend;\n    \
const device = backend.device;\n    const data = \
backend.get(this._getBufferAttribute(attribute2));\n    const bufferGPU = \
data.buffer;\n    const size = bufferGPU.size;\n    const readBufferGPU = \
device.createBuffer({\n      label: attribute2.name,\n      size,\n      \
usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n    const \
cmdEncoder = device.createCommandEncoder({});\n    \
cmdEncoder.copyBufferToBuffer(\n      bufferGPU,\n      0,\n      \
readBufferGPU,\n      0,\n      size\n    );\n    readBufferGPU.unmap();\n    \
const gpuCommands = cmdEncoder.finish();\n    \
device.queue.submit([gpuCommands]);\n    await \
readBufferGPU.mapAsync(GPUMapMode.READ);\n    const arrayBuffer = \
readBufferGPU.getMappedRange();\n    return arrayBuffer;\n  }\n  \
_getVertexFormat(geometryAttribute) {\n    const { itemSize, normalized } = \
geometryAttribute;\n    const ArrayType = \
geometryAttribute.array.constructor;\n    const AttributeType2 = \
geometryAttribute.constructor;\n    let format2;\n    if (itemSize == 1) {\n  \
    format2 = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);\n    \
} else {\n      const prefixOptions = \
typedAttributeToVertexFormatPrefix.get(AttributeType2) || \
typedArraysToVertexFormatPrefix.get(ArrayType);\n      const prefix = \
prefixOptions[normalized ? 1 : 0];\n      if (prefix) {\n        const \
bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n        const \
paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;\n        const \
paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n        \
if (paddedItemSize % 1) {\n          throw new \
Error(\"THREE.WebGPUAttributeUtils: Bad vertex format item size.\");\n        \
}\n        format2 = `${prefix}x${paddedItemSize}`;\n      }\n    }\n    if \
(!format2) {\n      console.error(\"THREE.WebGPUAttributeUtils: Vertex format \
not supported yet.\");\n    }\n    return format2;\n  }\n  \
_getBufferAttribute(attribute2) {\n    if \
(attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;\n    \
return attribute2;\n  }\n};\nvar WebGPUBindingUtils = class {\n  \
constructor(backend) {\n    this.backend = backend;\n    \
this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();\n  }\n  \
createBindingsLayout(bindGroup) {\n    const backend = this.backend;\n    \
const device = backend.device;\n    const entries = [];\n    let index5 = \
0;\n    for (const binding of bindGroup.bindings) {\n      const bindingGPU = \
{\n        binding: index5++,\n        visibility: binding.visibility\n      \
};\n      if (binding.isUniformBuffer || binding.isStorageBuffer) {\n        \
const buffer2 = {};\n        if (binding.isStorageBuffer) {\n          \
buffer2.type = binding.access;\n        }\n        bindingGPU.buffer = \
buffer2;\n      } else if (binding.isSampler) {\n        const sampler = \
{};\n        if (binding.texture.isDepthTexture) {\n          if \
(binding.texture.compareFunction !== null) {\n            sampler.type = \
\"comparison\";\n          }\n        }\n        bindingGPU.sampler = \
sampler;\n      } else if (binding.isSampledTexture && \
binding.texture.isVideoTexture) {\n        bindingGPU.externalTexture = {};\n \
     } else if (binding.isSampledTexture && binding.store) {\n        const \
format2 = this.backend.get(binding.texture).texture.format;\n        const \
access = binding.access;\n        bindingGPU.storageTexture = { format: \
format2, access };\n      } else if (binding.isSampledTexture) {\n        \
const texture2 = {};\n        if \
(binding.texture.isMultisampleRenderTargetTexture === true) {\n          \
texture2.multisampled = true;\n        }\n        if \
(binding.texture.isDepthTexture) {\n          texture2.sampleType = \
GPUTextureSampleType.Depth;\n        } else if (binding.texture.isDataTexture \
|| binding.texture.isDataArrayTexture || binding.texture.isData3DTexture) {\n \
         const type = binding.texture.type;\n          if (type === IntType2) \
{\n            texture2.sampleType = GPUTextureSampleType.SInt;\n          } \
else if (type === UnsignedIntType2) {\n            texture2.sampleType = \
GPUTextureSampleType.UInt;\n          } else if (type === FloatType2) {\n     \
       if (this.backend.hasFeature(\"float32-filterable\")) {\n              \
texture2.sampleType = GPUTextureSampleType.Float;\n            } else {\n     \
         texture2.sampleType = GPUTextureSampleType.UnfilterableFloat;\n      \
      }\n          }\n        }\n        if (binding.isSampledCubeTexture) \
{\n          texture2.viewDimension = GPUTextureViewDimension.Cube;\n        \
} else if (binding.texture.isDataArrayTexture || \
binding.texture.isCompressedArrayTexture) {\n          texture2.viewDimension \
= GPUTextureViewDimension.TwoDArray;\n        } else if \
(binding.isSampledTexture3D) {\n          texture2.viewDimension = \
GPUTextureViewDimension.ThreeD;\n        }\n        bindingGPU.texture = \
texture2;\n      } else {\n        console.error(`WebGPUBindingUtils: \
Unsupported binding \"${binding}\".`);\n      }\n      \
entries.push(bindingGPU);\n    }\n    return device.createBindGroupLayout({ \
entries });\n  }\n  createBindings(bindGroup) {\n    const { backend, \
bindGroupLayoutCache } = this;\n    const bindingsData = \
backend.get(bindGroup);\n    let bindLayoutGPU = \
bindGroupLayoutCache.get(bindGroup.bindingsReference);\n    if (bindLayoutGPU \
=== void 0) {\n      bindLayoutGPU = this.createBindingsLayout(bindGroup);\n  \
    bindGroupLayoutCache.set(bindGroup.bindingsReference, bindLayoutGPU);\n   \
 }\n    const bindGroupGPU = this.createBindGroup(bindGroup, \
bindLayoutGPU);\n    bindingsData.layout = bindLayoutGPU;\n    \
bindingsData.group = bindGroupGPU;\n  }\n  updateBinding(binding) {\n    \
const backend = this.backend;\n    const device = backend.device;\n    const \
buffer2 = binding.buffer;\n    const bufferGPU = \
backend.get(binding).buffer;\n    device.queue.writeBuffer(bufferGPU, 0, \
buffer2, 0);\n  }\n  createBindGroup(bindGroup, layoutGPU) {\n    const \
backend = this.backend;\n    const device = backend.device;\n    let \
bindingPoint = 0;\n    const entriesGPU = [];\n    for (const binding of \
bindGroup.bindings) {\n      if (binding.isUniformBuffer) {\n        const \
bindingData = backend.get(binding);\n        if (bindingData.buffer === void \
0) {\n          const byteLength = binding.byteLength;\n          const usage \
= GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n          const \
bufferGPU = device.createBuffer({\n            label: \"bindingBuffer_\" + \
binding.name,\n            size: byteLength,\n            usage\n          \
});\n          bindingData.buffer = bufferGPU;\n        }\n        \
entriesGPU.push({ binding: bindingPoint, resource: { buffer: \
bindingData.buffer } });\n      } else if (binding.isStorageBuffer) {\n       \
 const bindingData = backend.get(binding);\n        if (bindingData.buffer \
=== void 0) {\n          const attribute2 = binding.attribute;\n          \
bindingData.buffer = backend.get(attribute2).buffer;\n        }\n        \
entriesGPU.push({ binding: bindingPoint, resource: { buffer: \
bindingData.buffer } });\n      } else if (binding.isSampler) {\n        \
const textureGPU = backend.get(binding.texture);\n        entriesGPU.push({ \
binding: bindingPoint, resource: textureGPU.sampler });\n      } else if \
(binding.isSampledTexture) {\n        const textureData = \
backend.get(binding.texture);\n        let resourceGPU;\n        if \
(textureData.externalTexture !== void 0) {\n          resourceGPU = \
device.importExternalTexture({ source: textureData.externalTexture });\n      \
  } else {\n          const mipLevelCount = binding.store ? 1 : \
textureData.texture.mipLevelCount;\n          const propertyName = \
`view-${textureData.texture.width}-${textureData.texture.height}-${mipLevelCo\
unt}`;\n          resourceGPU = textureData[propertyName];\n          if \
(resourceGPU === void 0) {\n            const aspectGPU = \
GPUTextureAspect.All;\n            let dimensionViewGPU;\n            if \
(binding.isSampledCubeTexture) {\n              dimensionViewGPU = \
GPUTextureViewDimension.Cube;\n            } else if \
(binding.isSampledTexture3D) {\n              dimensionViewGPU = \
GPUTextureViewDimension.ThreeD;\n            } else if \
(binding.texture.isDataArrayTexture || \
binding.texture.isCompressedArrayTexture) {\n              dimensionViewGPU = \
GPUTextureViewDimension.TwoDArray;\n            } else {\n              \
dimensionViewGPU = GPUTextureViewDimension.TwoD;\n            }\n            \
resourceGPU = textureData[propertyName] = textureData.texture.createView({ \
aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount });\n          \
}\n        }\n        entriesGPU.push({ binding: bindingPoint, resource: \
resourceGPU });\n      }\n      bindingPoint++;\n    }\n    return \
device.createBindGroup({\n      label: \"bindGroup_\" + bindGroup.name,\n     \
 layout: layoutGPU,\n      entries: entriesGPU\n    });\n  }\n};\nvar \
WebGPUPipelineUtils = class {\n  constructor(backend) {\n    this.backend = \
backend;\n  }\n  _getSampleCount(renderObjectContext) {\n    return \
this.backend.utils.getSampleCountRenderContext(renderObjectContext);\n  }\n  \
createRenderPipeline(renderObject, promises) {\n    const { object, material, \
geometry, pipeline } = renderObject;\n    const { vertexProgram, \
fragmentProgram } = pipeline;\n    const backend = this.backend;\n    const \
device = backend.device;\n    const utils = backend.utils;\n    const \
pipelineData = backend.get(pipeline);\n    const bindGroupLayouts = [];\n    \
for (const bindGroup of renderObject.getBindings()) {\n      const \
bindingsData = backend.get(bindGroup);\n      \
bindGroupLayouts.push(bindingsData.layout);\n    }\n    const vertexBuffers = \
backend.attributeUtils.createShaderVertexBuffers(renderObject);\n    let \
blending;\n    if (material.transparent === true && material.blending !== \
NoBlending2) {\n      blending = this._getBlending(material);\n    }\n    let \
stencilFront = {};\n    if (material.stencilWrite === true) {\n      \
stencilFront = {\n        compare: this._getStencilCompare(material),\n       \
 failOp: this._getStencilOperation(material.stencilFail),\n        \
depthFailOp: this._getStencilOperation(material.stencilZFail),\n        \
passOp: this._getStencilOperation(material.stencilZPass)\n      };\n    }\n   \
 const colorWriteMask = this._getColorWriteMask(material);\n    const targets \
= [];\n    if (renderObject.context.textures !== null) {\n      const \
textures = renderObject.context.textures;\n      for (let i = 0; i < \
textures.length; i++) {\n        const colorFormat = \
utils.getTextureFormatGPU(textures[i]);\n        targets.push({\n          \
format: colorFormat,\n          blend: blending,\n          writeMask: \
colorWriteMask\n        });\n      }\n    } else {\n      const colorFormat = \
utils.getCurrentColorFormat(renderObject.context);\n      targets.push({\n    \
    format: colorFormat,\n        blend: blending,\n        writeMask: \
colorWriteMask\n      });\n    }\n    const vertexModule = \
backend.get(vertexProgram).module;\n    const fragmentModule = \
backend.get(fragmentProgram).module;\n    const primitiveState = \
this._getPrimitiveState(object, geometry, material);\n    const depthCompare \
= this._getDepthCompare(material);\n    const depthStencilFormat = \
utils.getCurrentDepthStencilFormat(renderObject.context);\n    const \
sampleCount = this._getSampleCount(renderObject.context);\n    const \
pipelineDescriptor = {\n      label: `renderPipeline_${material.name || \
material.type}_${material.id}`,\n      vertex: Object.assign({}, \
vertexModule, { buffers: vertexBuffers }),\n      fragment: Object.assign({}, \
fragmentModule, { targets }),\n      primitive: primitiveState,\n      \
multisample: {\n        count: sampleCount,\n        alphaToCoverageEnabled: \
material.alphaToCoverage && sampleCount > 1\n      },\n      layout: \
device.createPipelineLayout({\n        bindGroupLayouts\n      })\n    };\n   \
 const depthStencil = {};\n    const renderDepth = \
renderObject.context.depth;\n    const renderStencil = \
renderObject.context.stencil;\n    if (renderDepth === true || renderStencil \
=== true) {\n      if (renderDepth === true) {\n        depthStencil.format = \
depthStencilFormat;\n        depthStencil.depthWriteEnabled = \
material.depthWrite;\n        depthStencil.depthCompare = depthCompare;\n     \
 }\n      if (renderStencil === true) {\n        depthStencil.stencilFront = \
stencilFront;\n        depthStencil.stencilBack = {};\n        \
depthStencil.stencilReadMask = material.stencilFuncMask;\n        \
depthStencil.stencilWriteMask = material.stencilWriteMask;\n      }\n      \
pipelineDescriptor.depthStencil = depthStencil;\n    }\n    if (promises === \
null) {\n      pipelineData.pipeline = \
device.createRenderPipeline(pipelineDescriptor);\n    } else {\n      const p \
= new Promise((resolve) => {\n        \
device.createRenderPipelineAsync(pipelineDescriptor).then((pipeline2) => {\n  \
        pipelineData.pipeline = pipeline2;\n          resolve();\n        \
});\n      });\n      promises.push(p);\n    }\n  }\n  \
createBundleEncoder(renderContext) {\n    const backend = this.backend;\n    \
const { utils, device } = backend;\n    const depthStencilFormat = \
utils.getCurrentDepthStencilFormat(renderContext);\n    const colorFormat = \
utils.getCurrentColorFormat(renderContext);\n    const sampleCount = \
this._getSampleCount(renderContext);\n    const descriptor = {\n      label: \
\"renderBundleEncoder\",\n      colorFormats: [colorFormat],\n      \
depthStencilFormat,\n      sampleCount\n    };\n    return \
device.createRenderBundleEncoder(descriptor);\n  }\n  \
createComputePipeline(pipeline, bindings) {\n    const backend = \
this.backend;\n    const device = backend.device;\n    const computeProgram = \
backend.get(pipeline.computeProgram).module;\n    const pipelineGPU = \
backend.get(pipeline);\n    const bindGroupLayouts = [];\n    for (const \
bindingsGroup of bindings) {\n      const bindingsData = \
backend.get(bindingsGroup);\n      \
bindGroupLayouts.push(bindingsData.layout);\n    }\n    pipelineGPU.pipeline \
= device.createComputePipeline({\n      compute: computeProgram,\n      \
layout: device.createPipelineLayout({\n        bindGroupLayouts\n      })\n   \
 });\n  }\n  _getBlending(material) {\n    let color2, alpha;\n    const \
blending = material.blending;\n    const blendSrc = material.blendSrc;\n    \
const blendDst = material.blendDst;\n    const blendEquation = \
material.blendEquation;\n    if (blending === CustomBlending2) {\n      const \
blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : \
blendSrc;\n      const blendDstAlpha = material.blendDstAlpha !== null ? \
material.blendDstAlpha : blendDst;\n      const blendEquationAlpha = \
material.blendEquationAlpha !== null ? material.blendEquationAlpha : \
blendEquation;\n      color2 = {\n        srcFactor: \
this._getBlendFactor(blendSrc),\n        dstFactor: \
this._getBlendFactor(blendDst),\n        operation: \
this._getBlendOperation(blendEquation)\n      };\n      alpha = {\n        \
srcFactor: this._getBlendFactor(blendSrcAlpha),\n        dstFactor: \
this._getBlendFactor(blendDstAlpha),\n        operation: \
this._getBlendOperation(blendEquationAlpha)\n      };\n    } else {\n      \
const premultipliedAlpha = material.premultipliedAlpha;\n      const setBlend \
= (srcRGB, dstRGB, srcAlpha, dstAlpha) => {\n        color2 = {\n          \
srcFactor: srcRGB,\n          dstFactor: dstRGB,\n          operation: \
GPUBlendOperation.Add\n        };\n        alpha = {\n          srcFactor: \
srcAlpha,\n          dstFactor: dstAlpha,\n          operation: \
GPUBlendOperation.Add\n        };\n      };\n      if (premultipliedAlpha) \
{\n        switch (blending) {\n          case NormalBlending2:\n            \
setBlend(GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, \
GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);\n            break;\n   \
       case AdditiveBlending2:\n            setBlend(GPUBlendFactor.One, \
GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);\n            \
break;\n          case SubtractiveBlending2:\n            \
setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, \
GPUBlendFactor.Zero, GPUBlendFactor.One);\n            break;\n          case \
MultiplyBlending2:\n            setBlend(GPUBlendFactor.Zero, \
GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha);\n          \
  break;\n        }\n      } else {\n        switch (blending) {\n          \
case NormalBlending2:\n            setBlend(GPUBlendFactor.SrcAlpha, \
GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, \
GPUBlendFactor.OneMinusSrcAlpha);\n            break;\n          case \
AdditiveBlending2:\n            setBlend(GPUBlendFactor.SrcAlpha, \
GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One);\n           \
 break;\n          case SubtractiveBlending2:\n            \
setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, \
GPUBlendFactor.Zero, GPUBlendFactor.One);\n            break;\n          case \
MultiplyBlending2:\n            setBlend(GPUBlendFactor.Zero, \
GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src);\n            \
break;\n        }\n      }\n    }\n    if (color2 !== void 0 && alpha !== \
void 0) {\n      return { color: color2, alpha };\n    } else {\n      \
console.error(\"THREE.WebGPURenderer: Invalid blending: \", blending);\n    \
}\n  }\n  _getBlendFactor(blend) {\n    let blendFactor;\n    switch (blend) \
{\n      case ZeroFactor2:\n        blendFactor = GPUBlendFactor.Zero;\n      \
  break;\n      case OneFactor2:\n        blendFactor = GPUBlendFactor.One;\n \
       break;\n      case SrcColorFactor2:\n        blendFactor = \
GPUBlendFactor.Src;\n        break;\n      case OneMinusSrcColorFactor2:\n    \
    blendFactor = GPUBlendFactor.OneMinusSrc;\n        break;\n      case \
SrcAlphaFactor2:\n        blendFactor = GPUBlendFactor.SrcAlpha;\n        \
break;\n      case OneMinusSrcAlphaFactor2:\n        blendFactor = \
GPUBlendFactor.OneMinusSrcAlpha;\n        break;\n      case \
DstColorFactor2:\n        blendFactor = GPUBlendFactor.Dst;\n        break;\n \
     case OneMinusDstColorFactor2:\n        blendFactor = \
GPUBlendFactor.OneMinusDstColor;\n        break;\n      case \
DstAlphaFactor2:\n        blendFactor = GPUBlendFactor.DstAlpha;\n        \
break;\n      case OneMinusDstAlphaFactor2:\n        blendFactor = \
GPUBlendFactor.OneMinusDstAlpha;\n        break;\n      case \
SrcAlphaSaturateFactor2:\n        blendFactor = \
GPUBlendFactor.SrcAlphaSaturated;\n        break;\n      case \
BlendColorFactor:\n        blendFactor = GPUBlendFactor.Constant;\n        \
break;\n      case OneMinusBlendColorFactor:\n        blendFactor = \
GPUBlendFactor.OneMinusConstant;\n        break;\n      default:\n        \
console.error(\"THREE.WebGPURenderer: Blend factor not supported.\", \
blend);\n    }\n    return blendFactor;\n  }\n  _getStencilCompare(material) \
{\n    let stencilCompare;\n    const stencilFunc = material.stencilFunc;\n   \
 switch (stencilFunc) {\n      case NeverStencilFunc:\n        stencilCompare \
= GPUCompareFunction.Never;\n        break;\n      case AlwaysStencilFunc2:\n \
       stencilCompare = GPUCompareFunction.Always;\n        break;\n      \
case LessStencilFunc:\n        stencilCompare = GPUCompareFunction.Less;\n    \
    break;\n      case LessEqualStencilFunc:\n        stencilCompare = \
GPUCompareFunction.LessEqual;\n        break;\n      case EqualStencilFunc:\n \
       stencilCompare = GPUCompareFunction.Equal;\n        break;\n      case \
GreaterEqualStencilFunc:\n        stencilCompare = \
GPUCompareFunction.GreaterEqual;\n        break;\n      case \
GreaterStencilFunc:\n        stencilCompare = GPUCompareFunction.Greater;\n   \
     break;\n      case NotEqualStencilFunc:\n        stencilCompare = \
GPUCompareFunction.NotEqual;\n        break;\n      default:\n        \
console.error(\"THREE.WebGPURenderer: Invalid stencil function.\", \
stencilFunc);\n    }\n    return stencilCompare;\n  }\n  \
_getStencilOperation(op) {\n    let stencilOperation;\n    switch (op) {\n    \
  case KeepStencilOp2:\n        stencilOperation = \
GPUStencilOperation.Keep;\n        break;\n      case ZeroStencilOp:\n        \
stencilOperation = GPUStencilOperation.Zero;\n        break;\n      case \
ReplaceStencilOp:\n        stencilOperation = GPUStencilOperation.Replace;\n  \
      break;\n      case InvertStencilOp:\n        stencilOperation = \
GPUStencilOperation.Invert;\n        break;\n      case IncrementStencilOp:\n \
       stencilOperation = GPUStencilOperation.IncrementClamp;\n        \
break;\n      case DecrementStencilOp:\n        stencilOperation = \
GPUStencilOperation.DecrementClamp;\n        break;\n      case \
IncrementWrapStencilOp:\n        stencilOperation = \
GPUStencilOperation.IncrementWrap;\n        break;\n      case \
DecrementWrapStencilOp:\n        stencilOperation = \
GPUStencilOperation.DecrementWrap;\n        break;\n      default:\n        \
console.error(\"THREE.WebGPURenderer: Invalid stencil operation.\", \
stencilOperation);\n    }\n    return stencilOperation;\n  }\n  \
_getBlendOperation(blendEquation) {\n    let blendOperation;\n    switch \
(blendEquation) {\n      case AddEquation2:\n        blendOperation = \
GPUBlendOperation.Add;\n        break;\n      case SubtractEquation2:\n       \
 blendOperation = GPUBlendOperation.Subtract;\n        break;\n      case \
ReverseSubtractEquation2:\n        blendOperation = \
GPUBlendOperation.ReverseSubtract;\n        break;\n      case \
MinEquation2:\n        blendOperation = GPUBlendOperation.Min;\n        \
break;\n      case MaxEquation2:\n        blendOperation = \
GPUBlendOperation.Max;\n        break;\n      default:\n        \
console.error(\"THREE.WebGPUPipelineUtils: Blend equation not supported.\", \
blendEquation);\n    }\n    return blendOperation;\n  }\n  \
_getPrimitiveState(object, geometry, material) {\n    const descriptor = \
{};\n    const utils = this.backend.utils;\n    descriptor.topology = \
utils.getPrimitiveTopology(object, material);\n    if (geometry.index !== \
null && object.isLine === true && object.isLineSegments !== true) {\n      \
descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? \
GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n    }\n    switch \
(material.side) {\n      case FrontSide2:\n        descriptor.frontFace = \
GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.Back;\n        \
break;\n      case BackSide2:\n        descriptor.frontFace = \
GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.Front;\n        \
break;\n      case DoubleSide2:\n        descriptor.frontFace = \
GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.None;\n        \
break;\n      default:\n        console.error(\"THREE.WebGPUPipelineUtils: \
Unknown material.side value.\", material.side);\n        break;\n    }\n    \
return descriptor;\n  }\n  _getColorWriteMask(material) {\n    return \
material.colorWrite === true ? GPUColorWriteFlags.All : \
GPUColorWriteFlags.None;\n  }\n  _getDepthCompare(material) {\n    let \
depthCompare;\n    if (material.depthTest === false) {\n      depthCompare = \
GPUCompareFunction.Always;\n    } else {\n      const depthFunc = \
material.depthFunc;\n      switch (depthFunc) {\n        case NeverDepth2:\n  \
        depthCompare = GPUCompareFunction.Never;\n          break;\n        \
case AlwaysDepth2:\n          depthCompare = GPUCompareFunction.Always;\n     \
     break;\n        case LessDepth2:\n          depthCompare = \
GPUCompareFunction.Less;\n          break;\n        case LessEqualDepth2:\n   \
       depthCompare = GPUCompareFunction.LessEqual;\n          break;\n       \
 case EqualDepth2:\n          depthCompare = GPUCompareFunction.Equal;\n      \
    break;\n        case GreaterEqualDepth2:\n          depthCompare = \
GPUCompareFunction.GreaterEqual;\n          break;\n        case \
GreaterDepth2:\n          depthCompare = GPUCompareFunction.Greater;\n        \
  break;\n        case NotEqualDepth2:\n          depthCompare = \
GPUCompareFunction.NotEqual;\n          break;\n        default:\n          \
console.error(\"THREE.WebGPUPipelineUtils: Invalid depth function.\", \
depthFunc);\n      }\n    }\n    return depthCompare;\n  }\n};\nvar \
WebGPUBackend = class extends Backend {\n  constructor(parameters = {}) {\n   \
 super(parameters);\n    this.isWebGPUBackend = true;\n    \
this.parameters.alpha = parameters.alpha === void 0 ? true : \
parameters.alpha;\n    this.parameters.requiredLimits = \
parameters.requiredLimits === void 0 ? {} : parameters.requiredLimits;\n    \
this.trackTimestamp = parameters.trackTimestamp === true;\n    this.device = \
null;\n    this.context = null;\n    this.colorBuffer = null;\n    \
this.defaultRenderPassdescriptor = null;\n    this.utils = new \
WebGPUUtils(this);\n    this.attributeUtils = new \
WebGPUAttributeUtils(this);\n    this.bindingUtils = new \
WebGPUBindingUtils(this);\n    this.pipelineUtils = new \
WebGPUPipelineUtils(this);\n    this.textureUtils = new \
WebGPUTextureUtils(this);\n    this.occludedResolveCache = /* @__PURE__ */ \
new Map();\n  }\n  async init(renderer3) {\n    await \
super.init(renderer3);\n    const parameters = this.parameters;\n    let \
device;\n    if (parameters.device === void 0) {\n      const adapterOptions \
= {\n        powerPreference: parameters.powerPreference\n      };\n      \
const adapter = await navigator.gpu.requestAdapter(adapterOptions);\n      if \
(adapter === null) {\n        throw new Error(\"WebGPUBackend: Unable to \
create WebGPU adapter.\");\n      }\n      const features = \
Object.values(GPUFeatureName);\n      const supportedFeatures = [];\n      \
for (const name of features) {\n        if (adapter.features.has(name)) {\n   \
       supportedFeatures.push(name);\n        }\n      }\n      const \
deviceDescriptor = {\n        requiredFeatures: supportedFeatures,\n        \
requiredLimits: parameters.requiredLimits\n      };\n      device = await \
adapter.requestDevice(deviceDescriptor);\n    } else {\n      device = \
parameters.device;\n    }\n    device.lost.then((info) => {\n      const \
deviceLossInfo = {\n        api: \"WebGPU\",\n        message: info.message \
|| \"Unknown reason\",\n        reason: info.reason || null,\n        \
originalEvent: info\n      };\n      \
renderer3.onDeviceLost(deviceLossInfo);\n    });\n    const context2 = \
parameters.context !== void 0 ? parameters.context : \
renderer3.domElement.getContext(\"webgpu\");\n    this.device = device;\n    \
this.context = context2;\n    const alphaMode = parameters.alpha ? \
\"premultiplied\" : \"opaque\";\n    this.trackTimestamp = \
this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);\n    \
this.context.configure({\n      device: this.device,\n      format: \
this.utils.getPreferredCanvasFormat(),\n      usage: \
GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      \
alphaMode\n    });\n    this.updateSize();\n  }\n  get coordinateSystem() {\n \
   return WebGPUCoordinateSystem2;\n  }\n  async \
getArrayBufferAsync(attribute2) {\n    return await \
this.attributeUtils.getArrayBufferAsync(attribute2);\n  }\n  getContext() {\n \
   return this.context;\n  }\n  _getDefaultRenderPassDescriptor() {\n    let \
descriptor = this.defaultRenderPassdescriptor;\n    if (descriptor === null) \
{\n      const renderer3 = this.renderer;\n      descriptor = {\n        \
colorAttachments: [{\n          view: null\n        }]\n      };\n      if \
(this.renderer.depth === true || this.renderer.stencil === true) {\n        \
descriptor.depthStencilAttachment = {\n          view: \
this.textureUtils.getDepthBuffer(renderer3.depth, \
renderer3.stencil).createView()\n        };\n      }\n      const \
colorAttachment2 = descriptor.colorAttachments[0];\n      if \
(this.renderer.samples > 0) {\n        colorAttachment2.view = \
this.colorBuffer.createView();\n      } else {\n        \
colorAttachment2.resolveTarget = void 0;\n      }\n      \
this.defaultRenderPassdescriptor = descriptor;\n    }\n    const \
colorAttachment = descriptor.colorAttachments[0];\n    if \
(this.renderer.samples > 0) {\n      colorAttachment.resolveTarget = \
this.context.getCurrentTexture().createView();\n    } else {\n      \
colorAttachment.view = this.context.getCurrentTexture().createView();\n    \
}\n    return descriptor;\n  }\n  _getRenderPassDescriptor(renderContext) {\n \
   const renderTarget = renderContext.renderTarget;\n    const \
renderTargetData = this.get(renderTarget);\n    let descriptors = \
renderTargetData.descriptors;\n    if (descriptors === void 0 || \
renderTargetData.width !== renderTarget.width || renderTargetData.height !== \
renderTarget.height || renderTargetData.activeMipmapLevel !== \
renderTarget.activeMipmapLevel || renderTargetData.samples !== \
renderTarget.samples) {\n      descriptors = {};\n      \
renderTargetData.descriptors = descriptors;\n      const onDispose = () => \
{\n        renderTarget.removeEventListener(\"dispose\", onDispose);\n        \
this.delete(renderTarget);\n      };\n      \
renderTarget.addEventListener(\"dispose\", onDispose);\n    }\n    const \
cacheKey = renderContext.getCacheKey();\n    let descriptor = \
descriptors[cacheKey];\n    if (descriptor === void 0) {\n      const \
textures = renderContext.textures;\n      const colorAttachments = [];\n      \
for (let i = 0; i < textures.length; i++) {\n        const textureData = \
this.get(textures[i]);\n        const textureView = \
textureData.texture.createView({\n          baseMipLevel: \
renderContext.activeMipmapLevel,\n          mipLevelCount: 1,\n          \
baseArrayLayer: renderContext.activeCubeFace,\n          dimension: \
GPUTextureViewDimension.TwoD\n        });\n        let view, resolveTarget;\n \
       if (textureData.msaaTexture !== void 0) {\n          view = \
textureData.msaaTexture.createView();\n          resolveTarget = \
textureView;\n        } else {\n          view = textureView;\n          \
resolveTarget = void 0;\n        }\n        colorAttachments.push({\n         \
 view,\n          resolveTarget,\n          loadOp: GPULoadOp.Load,\n         \
 storeOp: GPUStoreOp.Store\n        });\n      }\n      descriptor = {\n      \
  colorAttachments\n      };\n      if (renderContext.depth) {\n        const \
depthTextureData = this.get(renderContext.depthTexture);\n        const \
depthStencilAttachment = {\n          view: \
depthTextureData.texture.createView()\n        };\n        \
descriptor.depthStencilAttachment = depthStencilAttachment;\n      }\n      \
descriptors[cacheKey] = descriptor;\n      renderTargetData.width = \
renderTarget.width;\n      renderTargetData.height = renderTarget.height;\n   \
   renderTargetData.samples = renderTarget.samples;\n      \
renderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;\n    }\n \
   return descriptor;\n  }\n  beginRender(renderContext) {\n    const \
renderContextData = this.get(renderContext);\n    const device = \
this.device;\n    const occlusionQueryCount = \
renderContext.occlusionQueryCount;\n    let occlusionQuerySet;\n    if \
(occlusionQueryCount > 0) {\n      if \
(renderContextData.currentOcclusionQuerySet) \
renderContextData.currentOcclusionQuerySet.destroy();\n      if \
(renderContextData.currentOcclusionQueryBuffer) \
renderContextData.currentOcclusionQueryBuffer.destroy();\n      \
renderContextData.currentOcclusionQuerySet = \
renderContextData.occlusionQuerySet;\n      \
renderContextData.currentOcclusionQueryBuffer = \
renderContextData.occlusionQueryBuffer;\n      \
renderContextData.currentOcclusionQueryObjects = \
renderContextData.occlusionQueryObjects;\n      occlusionQuerySet = \
device.createQuerySet({ type: \"occlusion\", count: occlusionQueryCount });\n \
     renderContextData.occlusionQuerySet = occlusionQuerySet;\n      \
renderContextData.occlusionQueryIndex = 0;\n      \
renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);\n   \
   renderContextData.lastOcclusionObject = null;\n    }\n    let \
descriptor;\n    if (renderContext.textures === null) {\n      descriptor = \
this._getDefaultRenderPassDescriptor();\n    } else {\n      descriptor = \
this._getRenderPassDescriptor(renderContext);\n    }\n    \
this.initTimestampQuery(renderContext, descriptor);\n    \
descriptor.occlusionQuerySet = occlusionQuerySet;\n    const \
depthStencilAttachment = descriptor.depthStencilAttachment;\n    if \
(renderContext.textures !== null) {\n      const colorAttachments = \
descriptor.colorAttachments;\n      for (let i = 0; i < \
colorAttachments.length; i++) {\n        const colorAttachment = \
colorAttachments[i];\n        if (renderContext.clearColor) {\n          \
colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: \
0, g: 0, b: 0, a: 1 };\n          colorAttachment.loadOp = GPULoadOp.Clear;\n \
         colorAttachment.storeOp = GPUStoreOp.Store;\n        } else {\n      \
    colorAttachment.loadOp = GPULoadOp.Load;\n          \
colorAttachment.storeOp = GPUStoreOp.Store;\n        }\n      }\n    } else \
{\n      const colorAttachment = descriptor.colorAttachments[0];\n      if \
(renderContext.clearColor) {\n        colorAttachment.clearValue = \
renderContext.clearColorValue;\n        colorAttachment.loadOp = \
GPULoadOp.Clear;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      \
} else {\n        colorAttachment.loadOp = GPULoadOp.Load;\n        \
colorAttachment.storeOp = GPUStoreOp.Store;\n      }\n    }\n    if \
(renderContext.depth) {\n      if (renderContext.clearDepth) {\n        \
depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n     \
   depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        \
depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n     \
   depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        \
depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n    \
if (renderContext.stencil) {\n      if (renderContext.clearStencil) {\n       \
 depthStencilAttachment.stencilClearValue = \
renderContext.clearStencilValue;\n        \
depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        \
depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else {\n   \
     depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        \
depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n   \
 const encoder = device.createCommandEncoder({ label: \"renderContext_\" + \
renderContext.id });\n    const currentPass = \
encoder.beginRenderPass(descriptor);\n    renderContextData.descriptor = \
descriptor;\n    renderContextData.encoder = encoder;\n    \
renderContextData.currentPass = currentPass;\n    \
renderContextData.currentSets = { attributes: {}, bindingGroups: [], \
pipeline: null, index: null };\n    renderContextData.renderBundles = [];\n   \
 if (renderContext.viewport) {\n      this.updateViewport(renderContext);\n   \
 }\n    if (renderContext.scissor) {\n      const { x: x2, y: y2, width, \
height } = renderContext.scissorValue;\n      currentPass.setScissorRect(x2, \
y2, width, height);\n    }\n  }\n  finishRender(renderContext) {\n    const \
renderContextData = this.get(renderContext);\n    const occlusionQueryCount = \
renderContext.occlusionQueryCount;\n    if \
(renderContextData.renderBundles.length > 0) {\n      \
renderContextData.currentPass.executeBundles(renderContextData.renderBundles)\
;\n    }\n    if (occlusionQueryCount > \
renderContextData.occlusionQueryIndex) {\n      \
renderContextData.currentPass.endOcclusionQuery();\n    }\n    \
renderContextData.currentPass.end();\n    if (occlusionQueryCount > 0) {\n    \
  const bufferSize = occlusionQueryCount * 8;\n      let queryResolveBuffer = \
this.occludedResolveCache.get(bufferSize);\n      if (queryResolveBuffer === \
void 0) {\n        queryResolveBuffer = this.device.createBuffer(\n          \
{\n            size: bufferSize,\n            usage: \
GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n          }\n        \
);\n        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);\n  \
    }\n      const readBuffer = this.device.createBuffer(\n        {\n        \
  size: bufferSize,\n          usage: GPUBufferUsage.COPY_DST | \
GPUBufferUsage.MAP_READ\n        }\n      );\n      \
renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet\
, 0, occlusionQueryCount, queryResolveBuffer, 0);\n      \
renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, \
readBuffer, 0, bufferSize);\n      renderContextData.occlusionQueryBuffer = \
readBuffer;\n      this.resolveOccludedAsync(renderContext);\n    }\n    \
this.prepareTimestampBuffer(renderContext, renderContextData.encoder);\n    \
this.device.queue.submit([renderContextData.encoder.finish()]);\n    if \
(renderContext.textures !== null) {\n      const textures = \
renderContext.textures;\n      for (let i = 0; i < textures.length; i++) {\n  \
      const texture2 = textures[i];\n        if (texture2.generateMipmaps === \
true) {\n          this.textureUtils.generateMipmaps(texture2);\n        }\n  \
    }\n    }\n  }\n  isOccluded(renderContext, object) {\n    const \
renderContextData = this.get(renderContext);\n    return \
renderContextData.occluded && renderContextData.occluded.has(object);\n  }\n  \
async resolveOccludedAsync(renderContext) {\n    const renderContextData = \
this.get(renderContext);\n    const { currentOcclusionQueryBuffer, \
currentOcclusionQueryObjects } = renderContextData;\n    if \
(currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {\n      const \
occluded = /* @__PURE__ */ new WeakSet();\n      \
renderContextData.currentOcclusionQueryObjects = null;\n      \
renderContextData.currentOcclusionQueryBuffer = null;\n      await \
currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);\n      const buffer2 = \
currentOcclusionQueryBuffer.getMappedRange();\n      const results = new \
BigUint64Array(buffer2);\n      for (let i = 0; i < \
currentOcclusionQueryObjects.length; i++) {\n        if (results[i] !== \
BigInt(0)) {\n          occluded.add(currentOcclusionQueryObjects[i]);\n      \
  }\n      }\n      currentOcclusionQueryBuffer.destroy();\n      \
renderContextData.occluded = occluded;\n    }\n  }\n  \
updateViewport(renderContext) {\n    const { currentPass } = \
this.get(renderContext);\n    const { x: x2, y: y2, width, height, minDepth, \
maxDepth } = renderContext.viewportValue;\n    currentPass.setViewport(x2, \
y2, width, height, minDepth, maxDepth);\n  }\n  clear(color2, depth2, \
stencil, renderTargetData = null) {\n    const device = this.device;\n    \
const renderer3 = this.renderer;\n    let colorAttachments = [];\n    let \
depthStencilAttachment;\n    let clearValue;\n    let supportsDepth;\n    let \
supportsStencil;\n    if (color2) {\n      const clearColor = \
this.getClearColor();\n      if (this.renderer.alpha === true) {\n        \
const a2 = clearColor.a;\n        clearValue = { r: clearColor.r * a2, g: \
clearColor.g * a2, b: clearColor.b * a2, a: a2 };\n      } else {\n        \
clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: \
clearColor.a };\n      }\n    }\n    if (renderTargetData === null) {\n      \
supportsDepth = renderer3.depth;\n      supportsStencil = \
renderer3.stencil;\n      const descriptor = \
this._getDefaultRenderPassDescriptor();\n      if (color2) {\n        \
colorAttachments = descriptor.colorAttachments;\n        const \
colorAttachment = colorAttachments[0];\n        colorAttachment.clearValue = \
clearValue;\n        colorAttachment.loadOp = GPULoadOp.Clear;\n        \
colorAttachment.storeOp = GPUStoreOp.Store;\n      }\n      if (supportsDepth \
|| supportsStencil) {\n        depthStencilAttachment = \
descriptor.depthStencilAttachment;\n      }\n    } else {\n      \
supportsDepth = renderTargetData.depth;\n      supportsStencil = \
renderTargetData.stencil;\n      if (color2) {\n        for (const texture2 \
of renderTargetData.textures) {\n          const textureData = \
this.get(texture2);\n          const textureView = \
textureData.texture.createView();\n          let view, resolveTarget;\n       \
   if (textureData.msaaTexture !== void 0) {\n            view = \
textureData.msaaTexture.createView();\n            resolveTarget = \
textureView;\n          } else {\n            view = textureView;\n           \
 resolveTarget = void 0;\n          }\n          colorAttachments.push({\n    \
        view,\n            resolveTarget,\n            clearValue,\n          \
  loadOp: GPULoadOp.Clear,\n            storeOp: GPUStoreOp.Store\n          \
});\n        }\n      }\n      if (supportsDepth || supportsStencil) {\n      \
  const depthTextureData = this.get(renderTargetData.depthTexture);\n        \
depthStencilAttachment = {\n          view: \
depthTextureData.texture.createView()\n        };\n      }\n    }\n    if \
(supportsDepth) {\n      if (depth2) {\n        \
depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        \
depthStencilAttachment.depthClearValue = renderer3.getClearDepth();\n        \
depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n     \
   depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        \
depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n    \
if (supportsStencil) {\n      if (stencil) {\n        \
depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        \
depthStencilAttachment.stencilClearValue = renderer3.getClearStencil();\n     \
   depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else \
{\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        \
depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n   \
 const encoder = device.createCommandEncoder({});\n    const currentPass = \
encoder.beginRenderPass({\n      colorAttachments,\n      \
depthStencilAttachment\n    });\n    currentPass.end();\n    \
device.queue.submit([encoder.finish()]);\n  }\n  // compute\n  \
beginCompute(computeGroup) {\n    const groupGPU = this.get(computeGroup);\n  \
  const descriptor = {};\n    this.initTimestampQuery(computeGroup, \
descriptor);\n    groupGPU.cmdEncoderGPU = \
this.device.createCommandEncoder();\n    groupGPU.passEncoderGPU = \
groupGPU.cmdEncoderGPU.beginComputePass(descriptor);\n  }\n  \
compute(computeGroup, computeNode, bindings, pipeline) {\n    const { \
passEncoderGPU } = this.get(computeGroup);\n    const pipelineGPU = \
this.get(pipeline).pipeline;\n    passEncoderGPU.setPipeline(pipelineGPU);\n  \
  for (let i = 0, l = bindings.length; i < l; i++) {\n      const bindGroup = \
bindings[i];\n      const bindingsData = this.get(bindGroup);\n      \
passEncoderGPU.setBindGroup(i, bindingsData.group);\n    }\n    const \
maxComputeWorkgroupsPerDimension = \
this.device.limits.maxComputeWorkgroupsPerDimension;\n    const \
computeNodeData = this.get(computeNode);\n    if \
(computeNodeData.dispatchSize === void 0) computeNodeData.dispatchSize = { x: \
0, y: 1, z: 1 };\n    const { dispatchSize } = computeNodeData;\n    if \
(computeNode.dispatchCount > maxComputeWorkgroupsPerDimension) {\n      \
dispatchSize.x = Math.min(computeNode.dispatchCount, \
maxComputeWorkgroupsPerDimension);\n      dispatchSize.y = \
Math.ceil(computeNode.dispatchCount / maxComputeWorkgroupsPerDimension);\n    \
} else {\n      dispatchSize.x = computeNode.dispatchCount;\n    }\n    \
passEncoderGPU.dispatchWorkgroups(\n      dispatchSize.x,\n      \
dispatchSize.y,\n      dispatchSize.z\n    );\n  }\n  \
finishCompute(computeGroup) {\n    const groupData = \
this.get(computeGroup);\n    groupData.passEncoderGPU.end();\n    \
this.prepareTimestampBuffer(computeGroup, groupData.cmdEncoderGPU);\n    \
this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);\n  }\n  async \
waitForGPU() {\n    await this.device.queue.onSubmittedWorkDone();\n  }\n  // \
render object\n  draw(renderObject, info) {\n    const { object, context: \
context2, pipeline } = renderObject;\n    const bindings = \
renderObject.getBindings();\n    const renderContextData = \
this.get(context2);\n    const pipelineGPU = this.get(pipeline).pipeline;\n   \
 const currentSets = renderContextData.currentSets;\n    const passEncoderGPU \
= renderContextData.currentPass;\n    const drawParams = \
renderObject.getDrawParameters();\n    if (drawParams === null) return;\n    \
if (currentSets.pipeline !== pipelineGPU) {\n      \
passEncoderGPU.setPipeline(pipelineGPU);\n      currentSets.pipeline = \
pipelineGPU;\n    }\n    const currentBindingGroups = \
currentSets.bindingGroups;\n    for (let i = 0, l = bindings.length; i < l; \
i++) {\n      const bindGroup = bindings[i];\n      const bindingsData = \
this.get(bindGroup);\n      if (currentBindingGroups[bindGroup.index] !== \
bindGroup.id) {\n        passEncoderGPU.setBindGroup(bindGroup.index, \
bindingsData.group);\n        currentBindingGroups[bindGroup.index] = \
bindGroup.id;\n      }\n    }\n    const index5 = renderObject.getIndex();\n  \
  const hasIndex = index5 !== null;\n    if (hasIndex === true) {\n      if \
(currentSets.index !== index5) {\n        const buffer2 = \
this.get(index5).buffer;\n        const indexFormat = index5.array instanceof \
Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n        \
passEncoderGPU.setIndexBuffer(buffer2, indexFormat);\n        \
currentSets.index = index5;\n      }\n    }\n    const vertexBuffers = \
renderObject.getVertexBuffers();\n    for (let i = 0, l = \
vertexBuffers.length; i < l; i++) {\n      const vertexBuffer = \
vertexBuffers[i];\n      if (currentSets.attributes[i] !== vertexBuffer) {\n  \
      const buffer2 = this.get(vertexBuffer).buffer;\n        \
passEncoderGPU.setVertexBuffer(i, buffer2);\n        \
currentSets.attributes[i] = vertexBuffer;\n      }\n    }\n    if \
(renderContextData.occlusionQuerySet !== void 0) {\n      const lastObject = \
renderContextData.lastOcclusionObject;\n      if (lastObject !== object) {\n  \
      if (lastObject !== null && lastObject.occlusionTest === true) {\n       \
   passEncoderGPU.endOcclusionQuery();\n          \
renderContextData.occlusionQueryIndex++;\n        }\n        if \
(object.occlusionTest === true) {\n          \
passEncoderGPU.beginOcclusionQuery(renderContextData.occlusionQueryIndex);\n  \
        \
renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex\
] = object;\n        }\n        renderContextData.lastOcclusionObject = \
object;\n      }\n    }\n    if (object.isBatchedMesh === true) {\n      \
const starts = object._multiDrawStarts;\n      const counts = \
object._multiDrawCounts;\n      const drawCount = object._multiDrawCount;\n   \
   const drawInstances = object._multiDrawInstances;\n      const \
bytesPerElement = hasIndex ? index5.array.BYTES_PER_ELEMENT : 1;\n      for \
(let i = 0; i < drawCount; i++) {\n        const count = drawInstances ? \
drawInstances[i] : 1;\n        const firstInstance = count > 1 ? 0 : i;\n     \
   passEncoderGPU.drawIndexed(counts[i], count, starts[i] / bytesPerElement, \
0, firstInstance);\n      }\n    } else if (hasIndex === true) {\n      const \
{ vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = \
drawParams;\n      const indirect = renderObject.getIndirect();\n      if \
(indirect !== null) {\n        const buffer2 = this.get(indirect).buffer;\n   \
     passEncoderGPU.drawIndexedIndirect(buffer2, 0);\n      } else {\n        \
passEncoderGPU.drawIndexed(indexCount, instanceCount, firstIndex, 0, 0);\n    \
  }\n      info.update(object, indexCount, instanceCount);\n    } else {\n    \
  const { vertexCount, instanceCount, firstVertex } = drawParams;\n      \
const indirect = renderObject.getIndirect();\n      if (indirect !== null) \
{\n        const buffer2 = this.get(indirect).buffer;\n        \
passEncoderGPU.drawIndirect(buffer2, 0);\n      } else {\n        \
passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);\n      }\n   \
   info.update(object, vertexCount, instanceCount);\n    }\n  }\n  // cache \
key\n  needsRenderUpdate(renderObject) {\n    const data = \
this.get(renderObject);\n    const { object, material } = renderObject;\n    \
const utils = this.utils;\n    const sampleCount = \
utils.getSampleCountRenderContext(renderObject.context);\n    const \
colorSpace = utils.getCurrentColorSpace(renderObject.context);\n    const \
colorFormat = utils.getCurrentColorFormat(renderObject.context);\n    const \
depthStencilFormat = \
utils.getCurrentDepthStencilFormat(renderObject.context);\n    const \
primitiveTopology = utils.getPrimitiveTopology(object, material);\n    let \
needsUpdate = false;\n    if (data.material !== material || \
data.materialVersion !== material.version || data.transparent !== \
material.transparent || data.blending !== material.blending || \
data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== \
material.blendSrc || data.blendDst !== material.blendDst || \
data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== \
material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || \
data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite \
!== material.colorWrite || data.depthWrite !== material.depthWrite || \
data.depthTest !== material.depthTest || data.depthFunc !== \
material.depthFunc || data.stencilWrite !== material.stencilWrite || \
data.stencilFunc !== material.stencilFunc || data.stencilFail !== \
material.stencilFail || data.stencilZFail !== material.stencilZFail || \
data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== \
material.stencilFuncMask || data.stencilWriteMask !== \
material.stencilWriteMask || data.side !== material.side || \
data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== \
sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== \
colorFormat || data.depthStencilFormat !== depthStencilFormat || \
data.primitiveTopology !== primitiveTopology || data.clippingContextCacheKey \
!== renderObject.clippingContext.cacheKey) {\n      data.material = \
material;\n      data.materialVersion = material.version;\n      \
data.transparent = material.transparent;\n      data.blending = \
material.blending;\n      data.premultipliedAlpha = \
material.premultipliedAlpha;\n      data.blendSrc = material.blendSrc;\n      \
data.blendDst = material.blendDst;\n      data.blendEquation = \
material.blendEquation;\n      data.blendSrcAlpha = material.blendSrcAlpha;\n \
     data.blendDstAlpha = material.blendDstAlpha;\n      \
data.blendEquationAlpha = material.blendEquationAlpha;\n      data.colorWrite \
= material.colorWrite;\n      data.depthWrite = material.depthWrite;\n      \
data.depthTest = material.depthTest;\n      data.depthFunc = \
material.depthFunc;\n      data.stencilWrite = material.stencilWrite;\n      \
data.stencilFunc = material.stencilFunc;\n      data.stencilFail = \
material.stencilFail;\n      data.stencilZFail = material.stencilZFail;\n     \
 data.stencilZPass = material.stencilZPass;\n      data.stencilFuncMask = \
material.stencilFuncMask;\n      data.stencilWriteMask = \
material.stencilWriteMask;\n      data.side = material.side;\n      \
data.alphaToCoverage = material.alphaToCoverage;\n      data.sampleCount = \
sampleCount;\n      data.colorSpace = colorSpace;\n      data.colorFormat = \
colorFormat;\n      data.depthStencilFormat = depthStencilFormat;\n      \
data.primitiveTopology = primitiveTopology;\n      \
data.clippingContextCacheKey = renderObject.clippingContext.cacheKey;\n      \
needsUpdate = true;\n    }\n    return needsUpdate;\n  }\n  \
getRenderCacheKey(renderObject) {\n    const { object, material } = \
renderObject;\n    const utils = this.utils;\n    const renderContext = \
renderObject.context;\n    return [\n      material.transparent,\n      \
material.blending,\n      material.premultipliedAlpha,\n      \
material.blendSrc,\n      material.blendDst,\n      material.blendEquation,\n \
     material.blendSrcAlpha,\n      material.blendDstAlpha,\n      \
material.blendEquationAlpha,\n      material.colorWrite,\n      \
material.depthWrite,\n      material.depthTest,\n      material.depthFunc,\n  \
    material.stencilWrite,\n      material.stencilFunc,\n      \
material.stencilFail,\n      material.stencilZFail,\n      \
material.stencilZPass,\n      material.stencilFuncMask,\n      \
material.stencilWriteMask,\n      material.side,\n      \
utils.getSampleCountRenderContext(renderContext),\n      \
utils.getCurrentColorSpace(renderContext),\n      \
utils.getCurrentColorFormat(renderContext),\n      \
utils.getCurrentDepthStencilFormat(renderContext),\n      \
utils.getPrimitiveTopology(object, material),\n      \
renderObject.getGeometryCacheKey(),\n      \
renderObject.clippingContext.cacheKey\n    ].join();\n  }\n  // textures\n  \
createSampler(texture2) {\n    this.textureUtils.createSampler(texture2);\n  \
}\n  destroySampler(texture2) {\n    \
this.textureUtils.destroySampler(texture2);\n  }\n  \
createDefaultTexture(texture2) {\n    \
this.textureUtils.createDefaultTexture(texture2);\n  }\n  \
createTexture(texture2, options) {\n    \
this.textureUtils.createTexture(texture2, options);\n  }\n  \
updateTexture(texture2, options) {\n    \
this.textureUtils.updateTexture(texture2, options);\n  }\n  \
generateMipmaps(texture2) {\n    \
this.textureUtils.generateMipmaps(texture2);\n  }\n  destroyTexture(texture2) \
{\n    this.textureUtils.destroyTexture(texture2);\n  }\n  \
copyTextureToBuffer(texture2, x2, y2, width, height, faceIndex) {\n    return \
this.textureUtils.copyTextureToBuffer(texture2, x2, y2, width, height, \
faceIndex);\n  }\n  initTimestampQuery(renderContext, descriptor) {\n    if \
(!this.trackTimestamp) return;\n    const renderContextData = \
this.get(renderContext);\n    if (!renderContextData.timeStampQuerySet) {\n   \
   const timeStampQuerySet = this.device.createQuerySet({ type: \
\"timestamp\", count: 2 });\n      const timestampWrites = {\n        \
querySet: timeStampQuerySet,\n        beginningOfPassWriteIndex: 0,\n        \
// Write timestamp in index 0 when pass begins.\n        endOfPassWriteIndex: \
1\n        // Write timestamp in index 1 when pass ends.\n      };\n      \
Object.assign(descriptor, {\n        timestampWrites\n      });\n      \
renderContextData.timeStampQuerySet = timeStampQuerySet;\n    }\n  }\n  // \
timestamp utils\n  prepareTimestampBuffer(renderContext, encoder) {\n    if \
(!this.trackTimestamp) return;\n    const renderContextData = \
this.get(renderContext);\n    const size = 2 * \
BigInt64Array.BYTES_PER_ELEMENT;\n    if \
(renderContextData.currentTimestampQueryBuffers === void 0) {\n      \
renderContextData.currentTimestampQueryBuffers = {\n        resolveBuffer: \
this.device.createBuffer({\n          label: \"timestamp resolve buffer\",\n  \
        size,\n          usage: GPUBufferUsage.QUERY_RESOLVE | \
GPUBufferUsage.COPY_SRC\n        }),\n        resultBuffer: \
this.device.createBuffer({\n          label: \"timestamp result buffer\",\n   \
       size,\n          usage: GPUBufferUsage.COPY_DST | \
GPUBufferUsage.MAP_READ\n        }),\n        isMappingPending: false\n      \
};\n    }\n    const { resolveBuffer, resultBuffer, isMappingPending } = \
renderContextData.currentTimestampQueryBuffers;\n    if (isMappingPending === \
true) return;\n    \
encoder.resolveQuerySet(renderContextData.timeStampQuerySet, 0, 2, \
resolveBuffer, 0);\n    encoder.copyBufferToBuffer(resolveBuffer, 0, \
resultBuffer, 0, size);\n  }\n  async resolveTimestampAsync(renderContext, \
type = \"render\") {\n    if (!this.trackTimestamp) return;\n    const \
renderContextData = this.get(renderContext);\n    if \
(renderContextData.currentTimestampQueryBuffers === void 0) return;\n    \
const { resultBuffer, isMappingPending } = \
renderContextData.currentTimestampQueryBuffers;\n    if (isMappingPending === \
true) return;\n    \
renderContextData.currentTimestampQueryBuffers.isMappingPending = true;\n    \
resultBuffer.mapAsync(GPUMapMode.READ).then(() => {\n      const times = new \
BigUint64Array(resultBuffer.getMappedRange());\n      const duration = \
Number(times[1] - times[0]) / 1e6;\n      \
this.renderer.info.updateTimestamp(type, duration);\n      \
resultBuffer.unmap();\n      \
renderContextData.currentTimestampQueryBuffers.isMappingPending = false;\n    \
});\n  }\n  // node builder\n  createNodeBuilder(object, renderer3) {\n    \
return new WGSLNodeBuilder(object, renderer3);\n  }\n  // program\n  \
createProgram(program) {\n    const programGPU = this.get(program);\n    \
programGPU.module = {\n      module: this.device.createShaderModule({ code: \
program.code, label: program.stage }),\n      entryPoint: \"main\"\n    };\n  \
}\n  destroyProgram(program) {\n    this.delete(program);\n  }\n  // \
pipelines\n  createRenderPipeline(renderObject, promises) {\n    \
this.pipelineUtils.createRenderPipeline(renderObject, promises);\n  }\n  \
createComputePipeline(computePipeline, bindings) {\n    \
this.pipelineUtils.createComputePipeline(computePipeline, bindings);\n  }\n  \
beginBundle(renderContext) {\n    const renderContextData = \
this.get(renderContext);\n    renderContextData._currentPass = \
renderContextData.currentPass;\n    renderContextData._currentSets = \
renderContextData.currentSets;\n    renderContextData.currentSets = { \
attributes: {}, bindingGroups: [], pipeline: null, index: null };\n    \
renderContextData.currentPass = \
this.pipelineUtils.createBundleEncoder(renderContext);\n  }\n  \
finishBundle(renderContext, bundle) {\n    const renderContextData = \
this.get(renderContext);\n    const bundleEncoder = \
renderContextData.currentPass;\n    const bundleGPU = \
bundleEncoder.finish();\n    this.get(bundle).bundleGPU = bundleGPU;\n    \
renderContextData.currentSets = renderContextData._currentSets;\n    \
renderContextData.currentPass = renderContextData._currentPass;\n  }\n  \
addBundle(renderContext, bundle) {\n    const renderContextData = \
this.get(renderContext);\n    \
renderContextData.renderBundles.push(this.get(bundle).bundleGPU);\n  }\n  // \
bindings\n  createBindings(bindGroup) {\n    \
this.bindingUtils.createBindings(bindGroup);\n  }\n  \
updateBindings(bindGroup) {\n    \
this.bindingUtils.createBindings(bindGroup);\n  }\n  updateBinding(binding) \
{\n    this.bindingUtils.updateBinding(binding);\n  }\n  // attributes\n  \
createIndexAttribute(attribute2) {\n    \
this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.INDEX | \
GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  \
createAttribute(attribute2) {\n    \
this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.VERTEX | \
GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  \
createStorageAttribute(attribute2) {\n    \
this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.STORAGE | \
GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n \
 }\n  createIndirectStorageAttribute(attribute2) {\n    \
this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.STORAGE | \
GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | \
GPUBufferUsage.COPY_DST);\n  }\n  updateAttribute(attribute2) {\n    \
this.attributeUtils.updateAttribute(attribute2);\n  }\n  \
destroyAttribute(attribute2) {\n    \
this.attributeUtils.destroyAttribute(attribute2);\n  }\n  // canvas\n  \
updateSize() {\n    this.colorBuffer = this.textureUtils.getColorBuffer();\n  \
  this.defaultRenderPassdescriptor = null;\n  }\n  // utils public\n  \
getMaxAnisotropy() {\n    return 16;\n  }\n  hasFeature(name) {\n    return \
this.device.features.has(name);\n  }\n  copyTextureToTexture(srcTexture, \
dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n    let dstX \
= 0;\n    let dstY = 0;\n    let dstLayer = 0;\n    let srcX = 0;\n    let \
srcY = 0;\n    let srcLayer = 0;\n    let srcWidth = \
srcTexture.image.width;\n    let srcHeight = srcTexture.image.height;\n    if \
(srcRegion !== null) {\n      srcX = srcRegion.x;\n      srcY = \
srcRegion.y;\n      srcLayer = srcRegion.z || 0;\n      srcWidth = \
srcRegion.width;\n      srcHeight = srcRegion.height;\n    }\n    if \
(dstPosition !== null) {\n      dstX = dstPosition.x;\n      dstY = \
dstPosition.y;\n      dstLayer = dstPosition.z || 0;\n    }\n    const \
encoder = this.device.createCommandEncoder({ label: \"copyTextureToTexture_\" \
+ srcTexture.id + \"_\" + dstTexture.id });\n    const sourceGPU = \
this.get(srcTexture).texture;\n    const destinationGPU = \
this.get(dstTexture).texture;\n    encoder.copyTextureToTexture(\n      {\n   \
     texture: sourceGPU,\n        mipLevel: level,\n        origin: { x: \
srcX, y: srcY, z: srcLayer }\n      },\n      {\n        texture: \
destinationGPU,\n        mipLevel: level,\n        origin: { x: dstX, y: \
dstY, z: dstLayer }\n      },\n      [\n        srcWidth,\n        \
srcHeight,\n        1\n      ]\n    );\n    \
this.device.queue.submit([encoder.finish()]);\n  }\n  \
copyFramebufferToTexture(texture2, renderContext, rectangle) {\n    const \
renderContextData = this.get(renderContext);\n    let sourceGPU = null;\n    \
if (renderContext.renderTarget) {\n      if (texture2.isDepthTexture) {\n     \
   sourceGPU = this.get(renderContext.depthTexture).texture;\n      } else \
{\n        sourceGPU = this.get(renderContext.textures[0]).texture;\n      \
}\n    } else {\n      if (texture2.isDepthTexture) {\n        sourceGPU = \
this.textureUtils.getDepthBuffer(renderContext.depth, \
renderContext.stencil);\n      } else {\n        sourceGPU = \
this.context.getCurrentTexture();\n      }\n    }\n    const destinationGPU = \
this.get(texture2).texture;\n    if (sourceGPU.format !== \
destinationGPU.format) {\n      console.error(\"WebGPUBackend: \
copyFramebufferToTexture: Source and destination formats do not match.\", \
sourceGPU.format, destinationGPU.format);\n      return;\n    }\n    let \
encoder;\n    if (renderContextData.currentPass) {\n      \
renderContextData.currentPass.end();\n      encoder = \
renderContextData.encoder;\n    } else {\n      encoder = \
this.device.createCommandEncoder({ label: \"copyFramebufferToTexture_\" + \
texture2.id });\n    }\n    encoder.copyTextureToTexture(\n      {\n        \
texture: sourceGPU,\n        origin: { x: rectangle.x, y: rectangle.y, z: 0 \
}\n      },\n      {\n        texture: destinationGPU\n      },\n      [\n    \
    rectangle.z,\n        rectangle.w\n      ]\n    );\n    if \
(texture2.generateMipmaps) this.textureUtils.generateMipmaps(texture2);\n    \
if (renderContextData.currentPass) {\n      const { descriptor } = \
renderContextData;\n      for (let i = 0; i < \
descriptor.colorAttachments.length; i++) {\n        \
descriptor.colorAttachments[i].loadOp = GPULoadOp.Load;\n      }\n      if \
(renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = \
GPULoadOp.Load;\n      if (renderContext.stencil) \
descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n      \
renderContextData.currentPass = encoder.beginRenderPass(descriptor);\n      \
renderContextData.currentSets = { attributes: {}, bindingGroups: [], \
pipeline: null, index: null };\n    } else {\n      \
this.device.queue.submit([encoder.finish()]);\n    }\n  }\n};\nvar \
IESSpotLight = class extends SpotLight {\n  constructor(color2, intensity, \
distance2, angle, penumbra, decay) {\n    super(color2, intensity, distance2, \
angle, penumbra, decay);\n    this.iesMap = null;\n  }\n  copy(source, \
recursive) {\n    super.copy(source, recursive);\n    this.iesMap = \
source.iesMap;\n    return this;\n  }\n};\nvar StandardNodeLibrary = class \
extends NodeLibrary {\n  constructor() {\n    super();\n    \
this.addMaterial(MeshPhongNodeMaterial, MeshPhongMaterial);\n    \
this.addMaterial(MeshStandardNodeMaterial, MeshStandardMaterial);\n    \
this.addMaterial(MeshPhysicalNodeMaterial, MeshPhysicalMaterial);\n    \
this.addMaterial(MeshToonNodeMaterial, MeshToonMaterial);\n    \
this.addMaterial(MeshBasicNodeMaterial, MeshBasicMaterial2);\n    \
this.addMaterial(MeshLambertNodeMaterial, MeshLambertMaterial2);\n    \
this.addMaterial(MeshNormalNodeMaterial, MeshNormalMaterial);\n    \
this.addMaterial(MeshMatcapNodeMaterial, MeshMatcapMaterial);\n    \
this.addMaterial(LineBasicNodeMaterial, LineBasicMaterial2);\n    \
this.addMaterial(LineDashedNodeMaterial, LineDashedMaterial);\n    \
this.addMaterial(PointsNodeMaterial, PointsMaterial);\n    \
this.addMaterial(SpriteNodeMaterial, SpriteMaterial);\n    \
this.addMaterial(ShadowNodeMaterial, ShadowMaterial);\n    \
this.addLight(PointLightNode, PointLight);\n    \
this.addLight(DirectionalLightNode, DirectionalLight2);\n    \
this.addLight(RectAreaLightNode, RectAreaLight);\n    \
this.addLight(SpotLightNode, SpotLight);\n    this.addLight(AmbientLightNode, \
AmbientLight2);\n    this.addLight(HemisphereLightNode, HemisphereLight);\n   \
 this.addLight(LightProbeNode, LightProbe);\n    \
this.addLight(IESSpotLightNode, IESSpotLight);\n    \
this.addToneMapping(linearToneMapping, LinearToneMapping2);\n    \
this.addToneMapping(reinhardToneMapping, ReinhardToneMapping2);\n    \
this.addToneMapping(cineonToneMapping, CineonToneMapping2);\n    \
this.addToneMapping(acesFilmicToneMapping, ACESFilmicToneMapping2);\n    \
this.addToneMapping(agxToneMapping, AgXToneMapping2);\n    \
this.addToneMapping(neutralToneMapping, NeutralToneMapping2);\n  }\n};\nvar \
WebGPURenderer = class extends Renderer {\n  constructor(parameters = {}) {\n \
   let BackendClass;\n    if (parameters.forceWebGL) {\n      BackendClass = \
WebGLBackend;\n    } else {\n      BackendClass = WebGPUBackend;\n      \
parameters.getFallback = () => {\n        \
console.warn(\"THREE.WebGPURenderer: WebGPU is not available, running under \
WebGL2 backend.\");\n        return new WebGLBackend(parameters);\n      };\n \
   }\n    const backend = new BackendClass(parameters);\n    super(backend, \
parameters);\n    this.library = new StandardNodeLibrary();\n    \
this.isWebGPURenderer = true;\n  }\n};\nif (typeof __THREE_DEVTOOLS__ !== \
\"undefined\") {\n  __THREE_DEVTOOLS__.dispatchEvent(new \
CustomEvent(\"register\", { detail: {\n    revision: REVISION2\n  } \
}));\n}\nif (typeof window !== \"undefined\") {\n  if (window.__THREE__) {\n  \
  console.warn(\"WARNING: Multiple instances of Three.js being \
imported.\");\n  } else {\n    window.__THREE__ = REVISION2;\n  }\n}\n\n// \
../../node_modules/three/examples/jsm/controls/TrackballControls.js\nvar \
_changeEvent = { type: \"change\" };\nvar _startEvent = { type: \"start\" \
};\nvar _endEvent = { type: \"end\" };\nvar _EPS = 1e-6;\nvar _STATE = { \
NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 \
};\nvar _v2 = new Vector2();\nvar _mouseChange = new Vector2();\nvar \
_objectUp = new Vector3();\nvar _pan = new Vector3();\nvar _axis = new \
Vector3();\nvar _quaternion = new Quaternion();\nvar _eyeDirection = new \
Vector3();\nvar _objectUpDirection = new Vector3();\nvar \
_objectSidewaysDirection = new Vector3();\nvar _moveDirection = new \
Vector3();\nvar TrackballControls = class extends Controls {\n  \
constructor(object, domElement = null) {\n    super(object, domElement);\n    \
this.enabled = true;\n    this.screen = { left: 0, top: 0, width: 0, height: \
0 };\n    this.rotateSpeed = 1;\n    this.zoomSpeed = 1.2;\n    this.panSpeed \
= 0.3;\n    this.noRotate = false;\n    this.noZoom = false;\n    this.noPan \
= false;\n    this.staticMoving = false;\n    this.dynamicDampingFactor = \
0.2;\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    \
this.minZoom = 0;\n    this.maxZoom = Infinity;\n    this.keys = [\n      \
\"KeyA\",\n      \"KeyS\",\n      \"KeyD\"\n      /*D*/\n    ];\n    \
this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: \
MOUSE.PAN };\n    this.state = _STATE.NONE;\n    this.keyState = \
_STATE.NONE;\n    this.target = new Vector3();\n    this._lastPosition = new \
Vector3();\n    this._lastZoom = 1;\n    this._touchZoomDistanceStart = 0;\n  \
  this._touchZoomDistanceEnd = 0;\n    this._lastAngle = 0;\n    this._eye = \
new Vector3();\n    this._movePrev = new Vector2();\n    this._moveCurr = new \
Vector2();\n    this._lastAxis = new Vector3();\n    this._zoomStart = new \
Vector2();\n    this._zoomEnd = new Vector2();\n    this._panStart = new \
Vector2();\n    this._panEnd = new Vector2();\n    this._pointers = [];\n    \
this._pointerPositions = {};\n    this._onPointerMove = \
onPointerMove2.bind(this);\n    this._onPointerDown = \
onPointerDown2.bind(this);\n    this._onPointerUp = onPointerUp.bind(this);\n \
   this._onPointerCancel = onPointerCancel2.bind(this);\n    \
this._onContextMenu = onContextMenu2.bind(this);\n    this._onMouseWheel = \
onMouseWheel.bind(this);\n    this._onKeyDown = onKeyDown.bind(this);\n    \
this._onKeyUp = onKeyUp.bind(this);\n    this._onTouchStart = \
onTouchStart.bind(this);\n    this._onTouchMove = onTouchMove.bind(this);\n   \
 this._onTouchEnd = onTouchEnd.bind(this);\n    this._onMouseDown = \
onMouseDown.bind(this);\n    this._onMouseMove = onMouseMove.bind(this);\n    \
this._onMouseUp = onMouseUp.bind(this);\n    this._target0 = \
this.target.clone();\n    this._position0 = this.object.position.clone();\n   \
 this._up0 = this.object.up.clone();\n    this._zoom0 = this.object.zoom;\n   \
 if (domElement !== null) {\n      this.connect();\n      \
this.handleResize();\n    }\n    this.update();\n  }\n  connect() {\n    \
window.addEventListener(\"keydown\", this._onKeyDown);\n    \
window.addEventListener(\"keyup\", this._onKeyUp);\n    \
this.domElement.addEventListener(\"pointerdown\", this._onPointerDown);\n    \
this.domElement.addEventListener(\"pointercancel\", this._onPointerCancel);\n \
   this.domElement.addEventListener(\"wheel\", this._onMouseWheel, { passive: \
false });\n    this.domElement.addEventListener(\"contextmenu\", \
this._onContextMenu);\n    this.domElement.style.touchAction = \"none\";\n  \
}\n  disconnect() {\n    window.removeEventListener(\"keydown\", \
this._onKeyDown);\n    window.removeEventListener(\"keyup\", \
this._onKeyUp);\n    this.domElement.removeEventListener(\"pointerdown\", \
this._onPointerDown);\n    \
this.domElement.removeEventListener(\"pointermove\", this._onPointerMove);\n  \
  this.domElement.removeEventListener(\"pointerup\", this._onPointerUp);\n    \
this.domElement.removeEventListener(\"pointercancel\", \
this._onPointerCancel);\n    this.domElement.removeEventListener(\"wheel\", \
this._onMouseWheel);\n    \
this.domElement.removeEventListener(\"contextmenu\", this._onContextMenu);\n  \
  this.domElement.style.touchAction = \"auto\";\n  }\n  dispose() {\n    \
this.disconnect();\n  }\n  handleResize() {\n    const box = \
this.domElement.getBoundingClientRect();\n    const d = \
this.domElement.ownerDocument.documentElement;\n    this.screen.left = \
box.left + window.pageXOffset - d.clientLeft;\n    this.screen.top = box.top \
+ window.pageYOffset - d.clientTop;\n    this.screen.width = box.width;\n    \
this.screen.height = box.height;\n  }\n  update() {\n    \
this._eye.subVectors(this.object.position, this.target);\n    if \
(!this.noRotate) {\n      this._rotateCamera();\n    }\n    if (!this.noZoom) \
{\n      this._zoomCamera();\n    }\n    if (!this.noPan) {\n      \
this._panCamera();\n    }\n    this.object.position.addVectors(this.target, \
this._eye);\n    if (this.object.isPerspectiveCamera) {\n      \
this._checkDistances();\n      this.object.lookAt(this.target);\n      if \
(this._lastPosition.distanceToSquared(this.object.position) > _EPS) {\n       \
 this.dispatchEvent(_changeEvent);\n        \
this._lastPosition.copy(this.object.position);\n      }\n    } else if \
(this.object.isOrthographicCamera) {\n      \
this.object.lookAt(this.target);\n      if \
(this._lastPosition.distanceToSquared(this.object.position) > _EPS || \
this._lastZoom !== this.object.zoom) {\n        \
this.dispatchEvent(_changeEvent);\n        \
this._lastPosition.copy(this.object.position);\n        this._lastZoom = \
this.object.zoom;\n      }\n    } else {\n      \
console.warn(\"THREE.TrackballControls: Unsupported camera type.\");\n    }\n \
 }\n  reset() {\n    this.state = _STATE.NONE;\n    this.keyState = \
_STATE.NONE;\n    this.target.copy(this._target0);\n    \
this.object.position.copy(this._position0);\n    \
this.object.up.copy(this._up0);\n    this.object.zoom = this._zoom0;\n    \
this.object.updateProjectionMatrix();\n    \
this._eye.subVectors(this.object.position, this.target);\n    \
this.object.lookAt(this.target);\n    this.dispatchEvent(_changeEvent);\n    \
this._lastPosition.copy(this.object.position);\n    this._lastZoom = \
this.object.zoom;\n  }\n  _panCamera() {\n    \
_mouseChange.copy(this._panEnd).sub(this._panStart);\n    if \
(_mouseChange.lengthSq()) {\n      if (this.object.isOrthographicCamera) {\n  \
      const scale_x = (this.object.right - this.object.left) / \
this.object.zoom / this.domElement.clientWidth;\n        const scale_y = \
(this.object.top - this.object.bottom) / this.object.zoom / \
this.domElement.clientWidth;\n        _mouseChange.x *= scale_x;\n        \
_mouseChange.y *= scale_y;\n      }\n      \
_mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);\n      \
_pan.copy(this._eye).cross(this.object.up).setLength(_mouseChange.x);\n      \
_pan.add(_objectUp.copy(this.object.up).setLength(_mouseChange.y));\n      \
this.object.position.add(_pan);\n      this.target.add(_pan);\n      if \
(this.staticMoving) {\n        this._panStart.copy(this._panEnd);\n      } \
else {\n        this._panStart.add(_mouseChange.subVectors(this._panEnd, \
this._panStart).multiplyScalar(this.dynamicDampingFactor));\n      }\n    }\n \
 }\n  _rotateCamera() {\n    _moveDirection.set(this._moveCurr.x - \
this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);\n    let angle = \
_moveDirection.length();\n    if (angle) {\n      \
this._eye.copy(this.object.position).sub(this.target);\n      \
_eyeDirection.copy(this._eye).normalize();\n      \
_objectUpDirection.copy(this.object.up).normalize();\n      \
_objectSidewaysDirection.crossVectors(_objectUpDirection, \
_eyeDirection).normalize();\n      \
_objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);\n      \
_objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);\n    \
  _moveDirection.copy(_objectUpDirection.add(_objectSidewaysDirection));\n    \
  _axis.crossVectors(_moveDirection, this._eye).normalize();\n      angle *= \
this.rotateSpeed;\n      _quaternion.setFromAxisAngle(_axis, angle);\n      \
this._eye.applyQuaternion(_quaternion);\n      \
this.object.up.applyQuaternion(_quaternion);\n      \
this._lastAxis.copy(_axis);\n      this._lastAngle = angle;\n    } else if \
(!this.staticMoving && this._lastAngle) {\n      this._lastAngle *= \
Math.sqrt(1 - this.dynamicDampingFactor);\n      \
this._eye.copy(this.object.position).sub(this.target);\n      \
_quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);\n      \
this._eye.applyQuaternion(_quaternion);\n      \
this.object.up.applyQuaternion(_quaternion);\n    }\n    \
this._movePrev.copy(this._moveCurr);\n  }\n  _zoomCamera() {\n    let \
factor;\n    if (this.state === _STATE.TOUCH_ZOOM_PAN) {\n      factor = \
this._touchZoomDistanceStart / this._touchZoomDistanceEnd;\n      \
this._touchZoomDistanceStart = this._touchZoomDistanceEnd;\n      if \
(this.object.isPerspectiveCamera) {\n        \
this._eye.multiplyScalar(factor);\n      } else if \
(this.object.isOrthographicCamera) {\n        this.object.zoom = \
MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);\n     \
   if (this._lastZoom !== this.object.zoom) {\n          \
this.object.updateProjectionMatrix();\n        }\n      } else {\n        \
console.warn(\"THREE.TrackballControls: Unsupported camera type\");\n      \
}\n    } else {\n      factor = 1 + (this._zoomEnd.y - this._zoomStart.y) * \
this.zoomSpeed;\n      if (factor !== 1 && factor > 0) {\n        if \
(this.object.isPerspectiveCamera) {\n          \
this._eye.multiplyScalar(factor);\n        } else if \
(this.object.isOrthographicCamera) {\n          this.object.zoom = \
MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);\n     \
     if (this._lastZoom !== this.object.zoom) {\n            \
this.object.updateProjectionMatrix();\n          }\n        } else {\n        \
  console.warn(\"THREE.TrackballControls: Unsupported camera type\");\n       \
 }\n      }\n      if (this.staticMoving) {\n        \
this._zoomStart.copy(this._zoomEnd);\n      } else {\n        \
this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * \
this.dynamicDampingFactor;\n      }\n    }\n  }\n  _getMouseOnScreen(pageX, \
pageY) {\n    _v2.set(\n      (pageX - this.screen.left) / \
this.screen.width,\n      (pageY - this.screen.top) / this.screen.height\n    \
);\n    return _v2;\n  }\n  _getMouseOnCircle(pageX, pageY) {\n    _v2.set(\n \
     (pageX - this.screen.width * 0.5 - this.screen.left) / \
(this.screen.width * 0.5),\n      (this.screen.height + 2 * (this.screen.top \
- pageY)) / this.screen.width\n      // screen.width intentional\n    );\n    \
return _v2;\n  }\n  _addPointer(event) {\n    this._pointers.push(event);\n  \
}\n  _removePointer(event) {\n    delete \
this._pointerPositions[event.pointerId];\n    for (let i = 0; i < \
this._pointers.length; i++) {\n      if (this._pointers[i].pointerId == \
event.pointerId) {\n        this._pointers.splice(i, 1);\n        return;\n   \
   }\n    }\n  }\n  _trackPointer(event) {\n    let position = \
this._pointerPositions[event.pointerId];\n    if (position === void 0) {\n    \
  position = new Vector2();\n      this._pointerPositions[event.pointerId] = \
position;\n    }\n    position.set(event.pageX, event.pageY);\n  }\n  \
_getSecondPointerPosition(event) {\n    const pointer = event.pointerId === \
this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];\n    \
return this._pointerPositions[pointer.pointerId];\n  }\n  _checkDistances() \
{\n    if (!this.noZoom || !this.noPan) {\n      if (this._eye.lengthSq() > \
this.maxDistance * this.maxDistance) {\n        \
this.object.position.addVectors(this.target, \
this._eye.setLength(this.maxDistance));\n        \
this._zoomStart.copy(this._zoomEnd);\n      }\n      if (this._eye.lengthSq() \
< this.minDistance * this.minDistance) {\n        \
this.object.position.addVectors(this.target, \
this._eye.setLength(this.minDistance));\n        \
this._zoomStart.copy(this._zoomEnd);\n      }\n    }\n  }\n};\nfunction \
onPointerDown2(event) {\n  if (this.enabled === false) return;\n  if \
(this._pointers.length === 0) {\n    \
this.domElement.setPointerCapture(event.pointerId);\n    \
this.domElement.addEventListener(\"pointermove\", this._onPointerMove);\n    \
this.domElement.addEventListener(\"pointerup\", this._onPointerUp);\n  }\n  \
this._addPointer(event);\n  if (event.pointerType === \"touch\") {\n    \
this._onTouchStart(event);\n  } else {\n    this._onMouseDown(event);\n  \
}\n}\nfunction onPointerMove2(event) {\n  if (this.enabled === false) \
return;\n  if (event.pointerType === \"touch\") {\n    \
this._onTouchMove(event);\n  } else {\n    this._onMouseMove(event);\n  \
}\n}\nfunction onPointerUp(event) {\n  if (this.enabled === false) return;\n  \
if (event.pointerType === \"touch\") {\n    this._onTouchEnd(event);\n  } \
else {\n    this._onMouseUp();\n  }\n  this._removePointer(event);\n  if \
(this._pointers.length === 0) {\n    \
this.domElement.releasePointerCapture(event.pointerId);\n    \
this.domElement.removeEventListener(\"pointermove\", this._onPointerMove);\n  \
  this.domElement.removeEventListener(\"pointerup\", this._onPointerUp);\n  \
}\n}\nfunction onPointerCancel2(event) {\n  \
this._removePointer(event);\n}\nfunction onKeyUp() {\n  if (this.enabled === \
false) return;\n  this.keyState = _STATE.NONE;\n  \
window.addEventListener(\"keydown\", this._onKeyDown);\n}\nfunction \
onKeyDown(event) {\n  if (this.enabled === false) return;\n  \
window.removeEventListener(\"keydown\", this._onKeyDown);\n  if \
(this.keyState !== _STATE.NONE) {\n    return;\n  } else if (event.code === \
this.keys[_STATE.ROTATE] && !this.noRotate) {\n    this.keyState = \
_STATE.ROTATE;\n  } else if (event.code === this.keys[_STATE.ZOOM] && \
!this.noZoom) {\n    this.keyState = _STATE.ZOOM;\n  } else if (event.code \
=== this.keys[_STATE.PAN] && !this.noPan) {\n    this.keyState = \
_STATE.PAN;\n  }\n}\nfunction onMouseDown(event) {\n  let mouseAction;\n  \
switch (event.button) {\n    case 0:\n      mouseAction = \
this.mouseButtons.LEFT;\n      break;\n    case 1:\n      mouseAction = \
this.mouseButtons.MIDDLE;\n      break;\n    case 2:\n      mouseAction = \
this.mouseButtons.RIGHT;\n      break;\n    default:\n      mouseAction = \
-1;\n  }\n  switch (mouseAction) {\n    case MOUSE.DOLLY:\n      this.state = \
_STATE.ZOOM;\n      break;\n    case MOUSE.ROTATE:\n      this.state = \
_STATE.ROTATE;\n      break;\n    case MOUSE.PAN:\n      this.state = \
_STATE.PAN;\n      break;\n    default:\n      this.state = _STATE.NONE;\n  \
}\n  const state = this.keyState !== _STATE.NONE ? this.keyState : \
this.state;\n  if (state === _STATE.ROTATE && !this.noRotate) {\n    \
this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\n    \
this._movePrev.copy(this._moveCurr);\n  } else if (state === _STATE.ZOOM && \
!this.noZoom) {\n    this._zoomStart.copy(this._getMouseOnScreen(event.pageX, \
event.pageY));\n    this._zoomEnd.copy(this._zoomStart);\n  } else if (state \
=== _STATE.PAN && !this.noPan) {\n    \
this._panStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));\n    \
this._panEnd.copy(this._panStart);\n  }\n  \
this.dispatchEvent(_startEvent);\n}\nfunction onMouseMove(event) {\n  const \
state = this.keyState !== _STATE.NONE ? this.keyState : this.state;\n  if \
(state === _STATE.ROTATE && !this.noRotate) {\n    \
this._movePrev.copy(this._moveCurr);\n    \
this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\n  } \
else if (state === _STATE.ZOOM && !this.noZoom) {\n    \
this._zoomEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));\n  } \
else if (state === _STATE.PAN && !this.noPan) {\n    \
this._panEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));\n  \
}\n}\nfunction onMouseUp() {\n  this.state = _STATE.NONE;\n  \
this.dispatchEvent(_endEvent);\n}\nfunction onMouseWheel(event) {\n  if \
(this.enabled === false) return;\n  if (this.noZoom === true) return;\n  \
event.preventDefault();\n  switch (event.deltaMode) {\n    case 2:\n      \
this._zoomStart.y -= event.deltaY * 0.025;\n      break;\n    case 1:\n      \
this._zoomStart.y -= event.deltaY * 0.01;\n      break;\n    default:\n      \
this._zoomStart.y -= event.deltaY * 25e-5;\n      break;\n  }\n  \
this.dispatchEvent(_startEvent);\n  \
this.dispatchEvent(_endEvent);\n}\nfunction onContextMenu2(event) {\n  if \
(this.enabled === false) return;\n  event.preventDefault();\n}\nfunction \
onTouchStart(event) {\n  this._trackPointer(event);\n  switch \
(this._pointers.length) {\n    case 1:\n      this.state = \
_STATE.TOUCH_ROTATE;\n      \
this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, \
this._pointers[0].pageY));\n      this._movePrev.copy(this._moveCurr);\n      \
break;\n    default:\n      this.state = _STATE.TOUCH_ZOOM_PAN;\n      const \
dx = this._pointers[0].pageX - this._pointers[1].pageX;\n      const dy = \
this._pointers[0].pageY - this._pointers[1].pageY;\n      \
this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx \
+ dy * dy);\n      const x2 = (this._pointers[0].pageX + \
this._pointers[1].pageX) / 2;\n      const y2 = (this._pointers[0].pageY + \
this._pointers[1].pageY) / 2;\n      \
this._panStart.copy(this._getMouseOnScreen(x2, y2));\n      \
this._panEnd.copy(this._panStart);\n      break;\n  }\n  \
this.dispatchEvent(_startEvent);\n}\nfunction onTouchMove(event) {\n  \
this._trackPointer(event);\n  switch (this._pointers.length) {\n    case 1:\n \
     this._movePrev.copy(this._moveCurr);\n      \
this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\n      \
break;\n    default:\n      const position = \
this._getSecondPointerPosition(event);\n      const dx = event.pageX - \
position.x;\n      const dy = event.pageY - position.y;\n      \
this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n      const x2 = \
(event.pageX + position.x) / 2;\n      const y2 = (event.pageY + position.y) \
/ 2;\n      this._panEnd.copy(this._getMouseOnScreen(x2, y2));\n      \
break;\n  }\n}\nfunction onTouchEnd(event) {\n  switch \
(this._pointers.length) {\n    case 0:\n      this.state = _STATE.NONE;\n     \
 break;\n    case 1:\n      this.state = _STATE.TOUCH_ROTATE;\n      \
this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\n      \
this._movePrev.copy(this._moveCurr);\n      break;\n    case 2:\n      \
this.state = _STATE.TOUCH_ZOOM_PAN;\n      for (let i = 0; i < \
this._pointers.length; i++) {\n        if (this._pointers[i].pointerId !== \
event.pointerId) {\n          const position = \
this._pointerPositions[this._pointers[i].pointerId];\n          \
this._moveCurr.copy(this._getMouseOnCircle(position.x, position.y));\n        \
  this._movePrev.copy(this._moveCurr);\n          break;\n        }\n      \
}\n      break;\n  }\n  this.dispatchEvent(_endEvent);\n}\n\n// \
../../node_modules/three/examples/jsm/controls/OrbitControls.js\nvar \
_changeEvent2 = { type: \"change\" };\nvar _startEvent2 = { type: \"start\" \
};\nvar _endEvent2 = { type: \"end\" };\nvar _ray = new Ray();\nvar _plane3 = \
new Plane();\nvar _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);\nvar _v = \
new Vector3();\nvar _twoPI = 2 * Math.PI;\nvar _STATE2 = {\n  NONE: -1,\n  \
ROTATE: 0,\n  DOLLY: 1,\n  PAN: 2,\n  TOUCH_ROTATE: 3,\n  TOUCH_PAN: 4,\n  \
TOUCH_DOLLY_PAN: 5,\n  TOUCH_DOLLY_ROTATE: 6\n};\nvar _EPS2 = 1e-6;\nvar \
OrbitControls = class extends Controls {\n  constructor(object, domElement = \
null) {\n    super(object, domElement);\n    this.state = _STATE2.NONE;\n    \
this.enabled = true;\n    this.target = new Vector3();\n    this.cursor = new \
Vector3();\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    \
this.minZoom = 0;\n    this.maxZoom = Infinity;\n    this.minTargetRadius = \
0;\n    this.maxTargetRadius = Infinity;\n    this.minPolarAngle = 0;\n    \
this.maxPolarAngle = Math.PI;\n    this.minAzimuthAngle = -Infinity;\n    \
this.maxAzimuthAngle = Infinity;\n    this.enableDamping = false;\n    \
this.dampingFactor = 0.05;\n    this.enableZoom = true;\n    this.zoomSpeed = \
1;\n    this.enableRotate = true;\n    this.rotateSpeed = 1;\n    \
this.enablePan = true;\n    this.panSpeed = 1;\n    this.screenSpacePanning = \
true;\n    this.keyPanSpeed = 7;\n    this.zoomToCursor = false;\n    \
this.autoRotate = false;\n    this.autoRotateSpeed = 2;\n    this.keys = { \
LEFT: \"ArrowLeft\", UP: \"ArrowUp\", RIGHT: \"ArrowRight\", BOTTOM: \
\"ArrowDown\" };\n    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: \
MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n    this.touches = { ONE: TOUCH.ROTATE, \
TWO: TOUCH.DOLLY_PAN };\n    this.target0 = this.target.clone();\n    \
this.position0 = this.object.position.clone();\n    this.zoom0 = \
this.object.zoom;\n    this._domElementKeyEvents = null;\n    \
this._lastPosition = new Vector3();\n    this._lastQuaternion = new \
Quaternion();\n    this._lastTargetPosition = new Vector3();\n    this._quat \
= new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));\n    \
this._quatInverse = this._quat.clone().invert();\n    this._spherical = new \
Spherical();\n    this._sphericalDelta = new Spherical();\n    this._scale = \
1;\n    this._panOffset = new Vector3();\n    this._rotateStart = new \
Vector2();\n    this._rotateEnd = new Vector2();\n    this._rotateDelta = new \
Vector2();\n    this._panStart = new Vector2();\n    this._panEnd = new \
Vector2();\n    this._panDelta = new Vector2();\n    this._dollyStart = new \
Vector2();\n    this._dollyEnd = new Vector2();\n    this._dollyDelta = new \
Vector2();\n    this._dollyDirection = new Vector3();\n    this._mouse = new \
Vector2();\n    this._performCursorZoom = false;\n    this._pointers = [];\n  \
  this._pointerPositions = {};\n    this._controlActive = false;\n    \
this._onPointerMove = onPointerMove3.bind(this);\n    this._onPointerDown = \
onPointerDown3.bind(this);\n    this._onPointerUp = \
onPointerUp2.bind(this);\n    this._onContextMenu = \
onContextMenu3.bind(this);\n    this._onMouseWheel = \
onMouseWheel2.bind(this);\n    this._onKeyDown = onKeyDown2.bind(this);\n    \
this._onTouchStart = onTouchStart2.bind(this);\n    this._onTouchMove = \
onTouchMove2.bind(this);\n    this._onMouseDown = onMouseDown2.bind(this);\n  \
  this._onMouseMove = onMouseMove2.bind(this);\n    \
this._interceptControlDown = interceptControlDown.bind(this);\n    \
this._interceptControlUp = interceptControlUp.bind(this);\n    if \
(this.domElement !== null) {\n      this.connect();\n    }\n    \
this.update();\n  }\n  connect() {\n    \
this.domElement.addEventListener(\"pointerdown\", this._onPointerDown);\n    \
this.domElement.addEventListener(\"pointercancel\", this._onPointerUp);\n    \
this.domElement.addEventListener(\"contextmenu\", this._onContextMenu);\n    \
this.domElement.addEventListener(\"wheel\", this._onMouseWheel, { passive: \
false });\n    const document2 = this.domElement.getRootNode();\n    \
document2.addEventListener(\"keydown\", this._interceptControlDown, { \
passive: true, capture: true });\n    this.domElement.style.touchAction = \
\"none\";\n  }\n  disconnect() {\n    \
this.domElement.removeEventListener(\"pointerdown\", this._onPointerDown);\n  \
  this.domElement.removeEventListener(\"pointermove\", \
this._onPointerMove);\n    this.domElement.removeEventListener(\"pointerup\", \
this._onPointerUp);\n    \
this.domElement.removeEventListener(\"pointercancel\", this._onPointerUp);\n  \
  this.domElement.removeEventListener(\"wheel\", this._onMouseWheel);\n    \
this.domElement.removeEventListener(\"contextmenu\", this._onContextMenu);\n  \
  this.stopListenToKeyEvents();\n    const document2 = \
this.domElement.getRootNode();\n    \
document2.removeEventListener(\"keydown\", this._interceptControlDown, { \
capture: true });\n    this.domElement.style.touchAction = \"auto\";\n  }\n  \
dispose() {\n    this.disconnect();\n  }\n  getPolarAngle() {\n    return \
this._spherical.phi;\n  }\n  getAzimuthalAngle() {\n    return \
this._spherical.theta;\n  }\n  getDistance() {\n    return \
this.object.position.distanceTo(this.target);\n  }\n  \
listenToKeyEvents(domElement) {\n    domElement.addEventListener(\"keydown\", \
this._onKeyDown);\n    this._domElementKeyEvents = domElement;\n  }\n  \
stopListenToKeyEvents() {\n    if (this._domElementKeyEvents !== null) {\n    \
  this._domElementKeyEvents.removeEventListener(\"keydown\", \
this._onKeyDown);\n      this._domElementKeyEvents = null;\n    }\n  }\n  \
saveState() {\n    this.target0.copy(this.target);\n    \
this.position0.copy(this.object.position);\n    this.zoom0 = \
this.object.zoom;\n  }\n  reset() {\n    this.target.copy(this.target0);\n    \
this.object.position.copy(this.position0);\n    this.object.zoom = \
this.zoom0;\n    this.object.updateProjectionMatrix();\n    \
this.dispatchEvent(_changeEvent2);\n    this.update();\n    this.state = \
_STATE2.NONE;\n  }\n  update(deltaTime = null) {\n    const position = \
this.object.position;\n    _v.copy(position).sub(this.target);\n    \
_v.applyQuaternion(this._quat);\n    this._spherical.setFromVector3(_v);\n    \
if (this.autoRotate && this.state === _STATE2.NONE) {\n      \
this._rotateLeft(this._getAutoRotationAngle(deltaTime));\n    }\n    if \
(this.enableDamping) {\n      this._spherical.theta += \
this._sphericalDelta.theta * this.dampingFactor;\n      this._spherical.phi \
+= this._sphericalDelta.phi * this.dampingFactor;\n    } else {\n      \
this._spherical.theta += this._sphericalDelta.theta;\n      \
this._spherical.phi += this._sphericalDelta.phi;\n    }\n    let min2 = \
this.minAzimuthAngle;\n    let max2 = this.maxAzimuthAngle;\n    if \
(isFinite(min2) && isFinite(max2)) {\n      if (min2 < -Math.PI) min2 += \
_twoPI;\n      else if (min2 > Math.PI) min2 -= _twoPI;\n      if (max2 < \
-Math.PI) max2 += _twoPI;\n      else if (max2 > Math.PI) max2 -= _twoPI;\n   \
   if (min2 <= max2) {\n        this._spherical.theta = Math.max(min2, \
Math.min(max2, this._spherical.theta));\n      } else {\n        \
this._spherical.theta = this._spherical.theta > (min2 + max2) / 2 ? \
Math.max(min2, this._spherical.theta) : Math.min(max2, \
this._spherical.theta);\n      }\n    }\n    this._spherical.phi = \
Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, \
this._spherical.phi));\n    this._spherical.makeSafe();\n    if \
(this.enableDamping === true) {\n      \
this.target.addScaledVector(this._panOffset, this.dampingFactor);\n    } else \
{\n      this.target.add(this._panOffset);\n    }\n    \
this.target.sub(this.cursor);\n    \
this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);\n    \
this.target.add(this.cursor);\n    let zoomChanged = false;\n    if \
(this.zoomToCursor && this._performCursorZoom || \
this.object.isOrthographicCamera) {\n      this._spherical.radius = \
this._clampDistance(this._spherical.radius);\n    } else {\n      const \
prevRadius = this._spherical.radius;\n      this._spherical.radius = \
this._clampDistance(this._spherical.radius * this._scale);\n      zoomChanged \
= prevRadius != this._spherical.radius;\n    }\n    \
_v.setFromSpherical(this._spherical);\n    \
_v.applyQuaternion(this._quatInverse);\n    \
position.copy(this.target).add(_v);\n    this.object.lookAt(this.target);\n   \
 if (this.enableDamping === true) {\n      this._sphericalDelta.theta *= 1 - \
this.dampingFactor;\n      this._sphericalDelta.phi *= 1 - \
this.dampingFactor;\n      this._panOffset.multiplyScalar(1 - \
this.dampingFactor);\n    } else {\n      this._sphericalDelta.set(0, 0, \
0);\n      this._panOffset.set(0, 0, 0);\n    }\n    if (this.zoomToCursor && \
this._performCursorZoom) {\n      let newRadius = null;\n      if \
(this.object.isPerspectiveCamera) {\n        const prevRadius = \
_v.length();\n        newRadius = this._clampDistance(prevRadius * \
this._scale);\n        const radiusDelta = prevRadius - newRadius;\n        \
this.object.position.addScaledVector(this._dollyDirection, radiusDelta);\n    \
    this.object.updateMatrixWorld();\n        zoomChanged = !!radiusDelta;\n  \
    } else if (this.object.isOrthographicCamera) {\n        const mouseBefore \
= new Vector3(this._mouse.x, this._mouse.y, 0);\n        \
mouseBefore.unproject(this.object);\n        const prevZoom = \
this.object.zoom;\n        this.object.zoom = Math.max(this.minZoom, \
Math.min(this.maxZoom, this.object.zoom / this._scale));\n        \
this.object.updateProjectionMatrix();\n        zoomChanged = prevZoom !== \
this.object.zoom;\n        const mouseAfter = new Vector3(this._mouse.x, \
this._mouse.y, 0);\n        mouseAfter.unproject(this.object);\n        \
this.object.position.sub(mouseAfter).add(mouseBefore);\n        \
this.object.updateMatrixWorld();\n        newRadius = _v.length();\n      } \
else {\n        console.warn(\"WARNING: OrbitControls.js encountered an \
unknown camera type - zoom to cursor disabled.\");\n        this.zoomToCursor \
= false;\n      }\n      if (newRadius !== null) {\n        if \
(this.screenSpacePanning) {\n          this.target.set(0, 0, \
-1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this\
.object.position);\n        } else {\n          \
_ray.origin.copy(this.object.position);\n          _ray.direction.set(0, 0, \
-1).transformDirection(this.object.matrix);\n          if \
(Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {\n            \
this.object.lookAt(this.target);\n          } else {\n            \
_plane3.setFromNormalAndCoplanarPoint(this.object.up, this.target);\n         \
   _ray.intersectPlane(_plane3, this.target);\n          }\n        }\n      \
}\n    } else if (this.object.isOrthographicCamera) {\n      const prevZoom = \
this.object.zoom;\n      this.object.zoom = Math.max(this.minZoom, \
Math.min(this.maxZoom, this.object.zoom / this._scale));\n      if (prevZoom \
!== this.object.zoom) {\n        this.object.updateProjectionMatrix();\n      \
  zoomChanged = true;\n      }\n    }\n    this._scale = 1;\n    \
this._performCursorZoom = false;\n    if (zoomChanged || \
this._lastPosition.distanceToSquared(this.object.position) > _EPS2 || 8 * (1 \
- this._lastQuaternion.dot(this.object.quaternion)) > _EPS2 || \
this._lastTargetPosition.distanceToSquared(this.target) > _EPS2) {\n      \
this.dispatchEvent(_changeEvent2);\n      \
this._lastPosition.copy(this.object.position);\n      \
this._lastQuaternion.copy(this.object.quaternion);\n      \
this._lastTargetPosition.copy(this.target);\n      return true;\n    }\n    \
return false;\n  }\n  _getAutoRotationAngle(deltaTime) {\n    if (deltaTime \
!== null) {\n      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;\n   \
 } else {\n      return _twoPI / 60 / 60 * this.autoRotateSpeed;\n    }\n  \
}\n  _getZoomScale(delta) {\n    const normalizedDelta = Math.abs(delta * \
0.01);\n    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);\n  }\n  \
_rotateLeft(angle) {\n    this._sphericalDelta.theta -= angle;\n  }\n  \
_rotateUp(angle) {\n    this._sphericalDelta.phi -= angle;\n  }\n  \
_panLeft(distance2, objectMatrix) {\n    _v.setFromMatrixColumn(objectMatrix, \
0);\n    _v.multiplyScalar(-distance2);\n    this._panOffset.add(_v);\n  }\n  \
_panUp(distance2, objectMatrix) {\n    if (this.screenSpacePanning === true) \
{\n      _v.setFromMatrixColumn(objectMatrix, 1);\n    } else {\n      \
_v.setFromMatrixColumn(objectMatrix, 0);\n      \
_v.crossVectors(this.object.up, _v);\n    }\n    \
_v.multiplyScalar(distance2);\n    this._panOffset.add(_v);\n  }\n  // deltaX \
and deltaY are in pixels; right and down are positive\n  _pan(deltaX, deltaY) \
{\n    const element2 = this.domElement;\n    if \
(this.object.isPerspectiveCamera) {\n      const position = \
this.object.position;\n      _v.copy(position).sub(this.target);\n      let \
targetDistance = _v.length();\n      targetDistance *= \
Math.tan(this.object.fov / 2 * Math.PI / 180);\n      this._panLeft(2 * \
deltaX * targetDistance / element2.clientHeight, this.object.matrix);\n      \
this._panUp(2 * deltaY * targetDistance / element2.clientHeight, \
this.object.matrix);\n    } else if (this.object.isOrthographicCamera) {\n    \
  this._panLeft(deltaX * (this.object.right - this.object.left) / \
this.object.zoom / element2.clientWidth, this.object.matrix);\n      \
this._panUp(deltaY * (this.object.top - this.object.bottom) / \
this.object.zoom / element2.clientHeight, this.object.matrix);\n    } else \
{\n      console.warn(\"WARNING: OrbitControls.js encountered an unknown \
camera type - pan disabled.\");\n      this.enablePan = false;\n    }\n  }\n  \
_dollyOut(dollyScale) {\n    if (this.object.isPerspectiveCamera || \
this.object.isOrthographicCamera) {\n      this._scale /= dollyScale;\n    } \
else {\n      console.warn(\"WARNING: OrbitControls.js encountered an unknown \
camera type - dolly/zoom disabled.\");\n      this.enableZoom = false;\n    \
}\n  }\n  _dollyIn(dollyScale) {\n    if (this.object.isPerspectiveCamera || \
this.object.isOrthographicCamera) {\n      this._scale *= dollyScale;\n    } \
else {\n      console.warn(\"WARNING: OrbitControls.js encountered an unknown \
camera type - dolly/zoom disabled.\");\n      this.enableZoom = false;\n    \
}\n  }\n  _updateZoomParameters(x2, y2) {\n    if (!this.zoomToCursor) {\n    \
  return;\n    }\n    this._performCursorZoom = true;\n    const rect = \
this.domElement.getBoundingClientRect();\n    const dx = x2 - rect.left;\n    \
const dy = y2 - rect.top;\n    const w = rect.width;\n    const h = \
rect.height;\n    this._mouse.x = dx / w * 2 - 1;\n    this._mouse.y = -(dy / \
h) * 2 + 1;\n    this._dollyDirection.set(this._mouse.x, this._mouse.y, \
1).unproject(this.object).sub(this.object.position).normalize();\n  }\n  \
_clampDistance(dist) {\n    return Math.max(this.minDistance, \
Math.min(this.maxDistance, dist));\n  }\n  //\n  // event callbacks - update \
the object state\n  //\n  _handleMouseDownRotate(event) {\n    \
this._rotateStart.set(event.clientX, event.clientY);\n  }\n  \
_handleMouseDownDolly(event) {\n    this._updateZoomParameters(event.clientX, \
event.clientX);\n    this._dollyStart.set(event.clientX, event.clientY);\n  \
}\n  _handleMouseDownPan(event) {\n    this._panStart.set(event.clientX, \
event.clientY);\n  }\n  _handleMouseMoveRotate(event) {\n    \
this._rotateEnd.set(event.clientX, event.clientY);\n    \
this._rotateDelta.subVectors(this._rotateEnd, \
this._rotateStart).multiplyScalar(this.rotateSpeed);\n    const element2 = \
this.domElement;\n    this._rotateLeft(_twoPI * this._rotateDelta.x / \
element2.clientHeight);\n    this._rotateUp(_twoPI * this._rotateDelta.y / \
element2.clientHeight);\n    this._rotateStart.copy(this._rotateEnd);\n    \
this.update();\n  }\n  _handleMouseMoveDolly(event) {\n    \
this._dollyEnd.set(event.clientX, event.clientY);\n    \
this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);\n    if \
(this._dollyDelta.y > 0) {\n      \
this._dollyOut(this._getZoomScale(this._dollyDelta.y));\n    } else if \
(this._dollyDelta.y < 0) {\n      \
this._dollyIn(this._getZoomScale(this._dollyDelta.y));\n    }\n    \
this._dollyStart.copy(this._dollyEnd);\n    this.update();\n  }\n  \
_handleMouseMovePan(event) {\n    this._panEnd.set(event.clientX, \
event.clientY);\n    this._panDelta.subVectors(this._panEnd, \
this._panStart).multiplyScalar(this.panSpeed);\n    \
this._pan(this._panDelta.x, this._panDelta.y);\n    \
this._panStart.copy(this._panEnd);\n    this.update();\n  }\n  \
_handleMouseWheel(event) {\n    this._updateZoomParameters(event.clientX, \
event.clientY);\n    if (event.deltaY < 0) {\n      \
this._dollyIn(this._getZoomScale(event.deltaY));\n    } else if (event.deltaY \
> 0) {\n      this._dollyOut(this._getZoomScale(event.deltaY));\n    }\n    \
this.update();\n  }\n  _handleKeyDown(event) {\n    let needsUpdate = \
false;\n    switch (event.code) {\n      case this.keys.UP:\n        if \
(event.ctrlKey || event.metaKey || event.shiftKey) {\n          \
this._rotateUp(_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n   \
     } else {\n          this._pan(0, this.keyPanSpeed);\n        }\n        \
needsUpdate = true;\n        break;\n      case this.keys.BOTTOM:\n        if \
(event.ctrlKey || event.metaKey || event.shiftKey) {\n          \
this._rotateUp(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n  \
      } else {\n          this._pan(0, -this.keyPanSpeed);\n        }\n       \
 needsUpdate = true;\n        break;\n      case this.keys.LEFT:\n        if \
(event.ctrlKey || event.metaKey || event.shiftKey) {\n          \
this._rotateLeft(_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n \
       } else {\n          this._pan(this.keyPanSpeed, 0);\n        }\n       \
 needsUpdate = true;\n        break;\n      case this.keys.RIGHT:\n        if \
(event.ctrlKey || event.metaKey || event.shiftKey) {\n          \
this._rotateLeft(-_twoPI * this.rotateSpeed / \
this.domElement.clientHeight);\n        } else {\n          \
this._pan(-this.keyPanSpeed, 0);\n        }\n        needsUpdate = true;\n    \
    break;\n    }\n    if (needsUpdate) {\n      event.preventDefault();\n    \
  this.update();\n    }\n  }\n  _handleTouchStartRotate(event) {\n    if \
(this._pointers.length === 1) {\n      this._rotateStart.set(event.pageX, \
event.pageY);\n    } else {\n      const position = \
this._getSecondPointerPosition(event);\n      const x2 = 0.5 * (event.pageX + \
position.x);\n      const y2 = 0.5 * (event.pageY + position.y);\n      \
this._rotateStart.set(x2, y2);\n    }\n  }\n  _handleTouchStartPan(event) {\n \
   if (this._pointers.length === 1) {\n      this._panStart.set(event.pageX, \
event.pageY);\n    } else {\n      const position = \
this._getSecondPointerPosition(event);\n      const x2 = 0.5 * (event.pageX + \
position.x);\n      const y2 = 0.5 * (event.pageY + position.y);\n      \
this._panStart.set(x2, y2);\n    }\n  }\n  _handleTouchStartDolly(event) {\n  \
  const position = this._getSecondPointerPosition(event);\n    const dx = \
event.pageX - position.x;\n    const dy = event.pageY - position.y;\n    \
const distance2 = Math.sqrt(dx * dx + dy * dy);\n    this._dollyStart.set(0, \
distance2);\n  }\n  _handleTouchStartDollyPan(event) {\n    if \
(this.enableZoom) this._handleTouchStartDolly(event);\n    if \
(this.enablePan) this._handleTouchStartPan(event);\n  }\n  \
_handleTouchStartDollyRotate(event) {\n    if (this.enableZoom) \
this._handleTouchStartDolly(event);\n    if (this.enableRotate) \
this._handleTouchStartRotate(event);\n  }\n  _handleTouchMoveRotate(event) \
{\n    if (this._pointers.length == 1) {\n      \
this._rotateEnd.set(event.pageX, event.pageY);\n    } else {\n      const \
position = this._getSecondPointerPosition(event);\n      const x2 = 0.5 * \
(event.pageX + position.x);\n      const y2 = 0.5 * (event.pageY + \
position.y);\n      this._rotateEnd.set(x2, y2);\n    }\n    \
this._rotateDelta.subVectors(this._rotateEnd, \
this._rotateStart).multiplyScalar(this.rotateSpeed);\n    const element2 = \
this.domElement;\n    this._rotateLeft(_twoPI * this._rotateDelta.x / \
element2.clientHeight);\n    this._rotateUp(_twoPI * this._rotateDelta.y / \
element2.clientHeight);\n    this._rotateStart.copy(this._rotateEnd);\n  }\n  \
_handleTouchMovePan(event) {\n    if (this._pointers.length === 1) {\n      \
this._panEnd.set(event.pageX, event.pageY);\n    } else {\n      const \
position = this._getSecondPointerPosition(event);\n      const x2 = 0.5 * \
(event.pageX + position.x);\n      const y2 = 0.5 * (event.pageY + \
position.y);\n      this._panEnd.set(x2, y2);\n    }\n    \
this._panDelta.subVectors(this._panEnd, \
this._panStart).multiplyScalar(this.panSpeed);\n    \
this._pan(this._panDelta.x, this._panDelta.y);\n    \
this._panStart.copy(this._panEnd);\n  }\n  _handleTouchMoveDolly(event) {\n   \
 const position = this._getSecondPointerPosition(event);\n    const dx = \
event.pageX - position.x;\n    const dy = event.pageY - position.y;\n    \
const distance2 = Math.sqrt(dx * dx + dy * dy);\n    this._dollyEnd.set(0, \
distance2);\n    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / \
this._dollyStart.y, this.zoomSpeed));\n    \
this._dollyOut(this._dollyDelta.y);\n    \
this._dollyStart.copy(this._dollyEnd);\n    const centerX = (event.pageX + \
position.x) * 0.5;\n    const centerY = (event.pageY + position.y) * 0.5;\n   \
 this._updateZoomParameters(centerX, centerY);\n  }\n  \
_handleTouchMoveDollyPan(event) {\n    if (this.enableZoom) \
this._handleTouchMoveDolly(event);\n    if (this.enablePan) \
this._handleTouchMovePan(event);\n  }\n  _handleTouchMoveDollyRotate(event) \
{\n    if (this.enableZoom) this._handleTouchMoveDolly(event);\n    if \
(this.enableRotate) this._handleTouchMoveRotate(event);\n  }\n  // pointers\n \
 _addPointer(event) {\n    this._pointers.push(event.pointerId);\n  }\n  \
_removePointer(event) {\n    delete \
this._pointerPositions[event.pointerId];\n    for (let i = 0; i < \
this._pointers.length; i++) {\n      if (this._pointers[i] == \
event.pointerId) {\n        this._pointers.splice(i, 1);\n        return;\n   \
   }\n    }\n  }\n  _isTrackingPointer(event) {\n    for (let i = 0; i < \
this._pointers.length; i++) {\n      if (this._pointers[i] == \
event.pointerId) return true;\n    }\n    return false;\n  }\n  \
_trackPointer(event) {\n    let position = \
this._pointerPositions[event.pointerId];\n    if (position === void 0) {\n    \
  position = new Vector2();\n      this._pointerPositions[event.pointerId] = \
position;\n    }\n    position.set(event.pageX, event.pageY);\n  }\n  \
_getSecondPointerPosition(event) {\n    const pointerId = event.pointerId === \
this._pointers[0] ? this._pointers[1] : this._pointers[0];\n    return \
this._pointerPositions[pointerId];\n  }\n  //\n  _customWheelEvent(event) {\n \
   const mode = event.deltaMode;\n    const newEvent = {\n      clientX: \
event.clientX,\n      clientY: event.clientY,\n      deltaY: event.deltaY\n   \
 };\n    switch (mode) {\n      case 1:\n        newEvent.deltaY *= 16;\n     \
   break;\n      case 2:\n        newEvent.deltaY *= 100;\n        break;\n   \
 }\n    if (event.ctrlKey && !this._controlActive) {\n      newEvent.deltaY \
*= 10;\n    }\n    return newEvent;\n  }\n};\nfunction onPointerDown3(event) \
{\n  if (this.enabled === false) return;\n  if (this._pointers.length === 0) \
{\n    this.domElement.setPointerCapture(event.pointerId);\n    \
this.domElement.addEventListener(\"pointermove\", this._onPointerMove);\n    \
this.domElement.addEventListener(\"pointerup\", this._onPointerUp);\n  }\n  \
if (this._isTrackingPointer(event)) return;\n  this._addPointer(event);\n  if \
(event.pointerType === \"touch\") {\n    this._onTouchStart(event);\n  } else \
{\n    this._onMouseDown(event);\n  }\n}\nfunction onPointerMove3(event) {\n  \
if (this.enabled === false) return;\n  if (event.pointerType === \"touch\") \
{\n    this._onTouchMove(event);\n  } else {\n    this._onMouseMove(event);\n \
 }\n}\nfunction onPointerUp2(event) {\n  this._removePointer(event);\n  \
switch (this._pointers.length) {\n    case 0:\n      \
this.domElement.releasePointerCapture(event.pointerId);\n      \
this.domElement.removeEventListener(\"pointermove\", this._onPointerMove);\n  \
    this.domElement.removeEventListener(\"pointerup\", this._onPointerUp);\n  \
    this.dispatchEvent(_endEvent2);\n      this.state = _STATE2.NONE;\n      \
break;\n    case 1:\n      const pointerId = this._pointers[0];\n      const \
position = this._pointerPositions[pointerId];\n      this._onTouchStart({ \
pointerId, pageX: position.x, pageY: position.y });\n      break;\n  \
}\n}\nfunction onMouseDown2(event) {\n  let mouseAction;\n  switch \
(event.button) {\n    case 0:\n      mouseAction = this.mouseButtons.LEFT;\n  \
    break;\n    case 1:\n      mouseAction = this.mouseButtons.MIDDLE;\n      \
break;\n    case 2:\n      mouseAction = this.mouseButtons.RIGHT;\n      \
break;\n    default:\n      mouseAction = -1;\n  }\n  switch (mouseAction) \
{\n    case MOUSE.DOLLY:\n      if (this.enableZoom === false) return;\n      \
this._handleMouseDownDolly(event);\n      this.state = _STATE2.DOLLY;\n      \
break;\n    case MOUSE.ROTATE:\n      if (event.ctrlKey || event.metaKey || \
event.shiftKey) {\n        if (this.enablePan === false) return;\n        \
this._handleMouseDownPan(event);\n        this.state = _STATE2.PAN;\n      } \
else {\n        if (this.enableRotate === false) return;\n        \
this._handleMouseDownRotate(event);\n        this.state = _STATE2.ROTATE;\n   \
   }\n      break;\n    case MOUSE.PAN:\n      if (event.ctrlKey || \
event.metaKey || event.shiftKey) {\n        if (this.enableRotate === false) \
return;\n        this._handleMouseDownRotate(event);\n        this.state = \
_STATE2.ROTATE;\n      } else {\n        if (this.enablePan === false) \
return;\n        this._handleMouseDownPan(event);\n        this.state = \
_STATE2.PAN;\n      }\n      break;\n    default:\n      this.state = \
_STATE2.NONE;\n  }\n  if (this.state !== _STATE2.NONE) {\n    \
this.dispatchEvent(_startEvent2);\n  }\n}\nfunction onMouseMove2(event) {\n  \
switch (this.state) {\n    case _STATE2.ROTATE:\n      if (this.enableRotate \
=== false) return;\n      this._handleMouseMoveRotate(event);\n      break;\n \
   case _STATE2.DOLLY:\n      if (this.enableZoom === false) return;\n      \
this._handleMouseMoveDolly(event);\n      break;\n    case _STATE2.PAN:\n     \
 if (this.enablePan === false) return;\n      \
this._handleMouseMovePan(event);\n      break;\n  }\n}\nfunction \
onMouseWheel2(event) {\n  if (this.enabled === false || this.enableZoom === \
false || this.state !== _STATE2.NONE) return;\n  event.preventDefault();\n  \
this.dispatchEvent(_startEvent2);\n  \
this._handleMouseWheel(this._customWheelEvent(event));\n  \
this.dispatchEvent(_endEvent2);\n}\nfunction onKeyDown2(event) {\n  if \
(this.enabled === false || this.enablePan === false) return;\n  \
this._handleKeyDown(event);\n}\nfunction onTouchStart2(event) {\n  \
this._trackPointer(event);\n  switch (this._pointers.length) {\n    case 1:\n \
     switch (this.touches.ONE) {\n        case TOUCH.ROTATE:\n          if \
(this.enableRotate === false) return;\n          \
this._handleTouchStartRotate(event);\n          this.state = \
_STATE2.TOUCH_ROTATE;\n          break;\n        case TOUCH.PAN:\n          \
if (this.enablePan === false) return;\n          \
this._handleTouchStartPan(event);\n          this.state = \
_STATE2.TOUCH_PAN;\n          break;\n        default:\n          this.state \
= _STATE2.NONE;\n      }\n      break;\n    case 2:\n      switch \
(this.touches.TWO) {\n        case TOUCH.DOLLY_PAN:\n          if \
(this.enableZoom === false && this.enablePan === false) return;\n          \
this._handleTouchStartDollyPan(event);\n          this.state = \
_STATE2.TOUCH_DOLLY_PAN;\n          break;\n        case \
TOUCH.DOLLY_ROTATE:\n          if (this.enableZoom === false && \
this.enableRotate === false) return;\n          \
this._handleTouchStartDollyRotate(event);\n          this.state = \
_STATE2.TOUCH_DOLLY_ROTATE;\n          break;\n        default:\n          \
this.state = _STATE2.NONE;\n      }\n      break;\n    default:\n      \
this.state = _STATE2.NONE;\n  }\n  if (this.state !== _STATE2.NONE) {\n    \
this.dispatchEvent(_startEvent2);\n  }\n}\nfunction onTouchMove2(event) {\n  \
this._trackPointer(event);\n  switch (this.state) {\n    case \
_STATE2.TOUCH_ROTATE:\n      if (this.enableRotate === false) return;\n      \
this._handleTouchMoveRotate(event);\n      this.update();\n      break;\n    \
case _STATE2.TOUCH_PAN:\n      if (this.enablePan === false) return;\n      \
this._handleTouchMovePan(event);\n      this.update();\n      break;\n    \
case _STATE2.TOUCH_DOLLY_PAN:\n      if (this.enableZoom === false && \
this.enablePan === false) return;\n      \
this._handleTouchMoveDollyPan(event);\n      this.update();\n      break;\n   \
 case _STATE2.TOUCH_DOLLY_ROTATE:\n      if (this.enableZoom === false && \
this.enableRotate === false) return;\n      \
this._handleTouchMoveDollyRotate(event);\n      this.update();\n      \
break;\n    default:\n      this.state = _STATE2.NONE;\n  }\n}\nfunction \
onContextMenu3(event) {\n  if (this.enabled === false) return;\n  \
event.preventDefault();\n}\nfunction interceptControlDown(event) {\n  if \
(event.key === \"Control\") {\n    this._controlActive = true;\n    const \
document2 = this.domElement.getRootNode();\n    \
document2.addEventListener(\"keyup\", this._interceptControlUp, { passive: \
true, capture: true });\n  }\n}\nfunction interceptControlUp(event) {\n  if \
(event.key === \"Control\") {\n    this._controlActive = false;\n    const \
document2 = this.domElement.getRootNode();\n    \
document2.removeEventListener(\"keyup\", this._interceptControlUp, { passive: \
true, capture: true });\n  }\n}\n\n// \
../../node_modules/three/examples/jsm/controls/FlyControls.js\nvar \
_changeEvent3 = { type: \"change\" };\nvar _EPS3 = 1e-6;\nvar _tmpQuaternion \
= new Quaternion();\nvar FlyControls = class extends Controls {\n  \
constructor(object, domElement = null) {\n    super(object, domElement);\n    \
this.movementSpeed = 1;\n    this.rollSpeed = 5e-3;\n    this.dragToLook = \
false;\n    this.autoForward = false;\n    this._moveState = { up: 0, down: \
0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: \
0, yawRight: 0, rollLeft: 0, rollRight: 0 };\n    this._moveVector = new \
Vector3(0, 0, 0);\n    this._rotationVector = new Vector3(0, 0, 0);\n    \
this._lastQuaternion = new Quaternion();\n    this._lastPosition = new \
Vector3();\n    this._status = 0;\n    this._onKeyDown = \
onKeyDown3.bind(this);\n    this._onKeyUp = onKeyUp2.bind(this);\n    \
this._onPointerMove = onPointerMove4.bind(this);\n    this._onPointerDown = \
onPointerDown4.bind(this);\n    this._onPointerUp = \
onPointerUp3.bind(this);\n    this._onPointerCancel = \
onPointerCancel3.bind(this);\n    this._onContextMenu = \
onContextMenu4.bind(this);\n    if (domElement !== null) {\n      \
this.connect();\n    }\n  }\n  connect() {\n    \
window.addEventListener(\"keydown\", this._onKeyDown);\n    \
window.addEventListener(\"keyup\", this._onKeyUp);\n    \
this.domElement.addEventListener(\"pointermove\", this._onPointerMove);\n    \
this.domElement.addEventListener(\"pointerdown\", this._onPointerDown);\n    \
this.domElement.addEventListener(\"pointerup\", this._onPointerUp);\n    \
this.domElement.addEventListener(\"pointercancel\", this._onPointerCancel);\n \
   this.domElement.addEventListener(\"contextmenu\", this._onContextMenu);\n  \
}\n  disconnect() {\n    window.removeEventListener(\"keydown\", \
this._onKeyDown);\n    window.removeEventListener(\"keyup\", \
this._onKeyUp);\n    this.domElement.removeEventListener(\"pointermove\", \
this._onPointerMove);\n    \
this.domElement.removeEventListener(\"pointerdown\", this._onPointerDown);\n  \
  this.domElement.removeEventListener(\"pointerup\", this._onPointerUp);\n    \
this.domElement.removeEventListener(\"pointercancel\", \
this._onPointerCancel);\n    \
this.domElement.removeEventListener(\"contextmenu\", this._onContextMenu);\n  \
}\n  dispose() {\n    this.disconnect();\n  }\n  update(delta) {\n    if \
(this.enabled === false) return;\n    const object = this.object;\n    const \
moveMult = delta * this.movementSpeed;\n    const rotMult = delta * \
this.rollSpeed;\n    object.translateX(this._moveVector.x * moveMult);\n    \
object.translateY(this._moveVector.y * moveMult);\n    \
object.translateZ(this._moveVector.z * moveMult);\n    \
_tmpQuaternion.set(this._rotationVector.x * rotMult, this._rotationVector.y * \
rotMult, this._rotationVector.z * rotMult, 1).normalize();\n    \
object.quaternion.multiply(_tmpQuaternion);\n    if \
(this._lastPosition.distanceToSquared(object.position) > _EPS3 || 8 * (1 - \
this._lastQuaternion.dot(object.quaternion)) > _EPS3) {\n      \
this.dispatchEvent(_changeEvent3);\n      \
this._lastQuaternion.copy(object.quaternion);\n      \
this._lastPosition.copy(object.position);\n    }\n  }\n  // private\n  \
_updateMovementVector() {\n    const forward = this._moveState.forward || \
this.autoForward && !this._moveState.back ? 1 : 0;\n    this._moveVector.x = \
-this._moveState.left + this._moveState.right;\n    this._moveVector.y = \
-this._moveState.down + this._moveState.up;\n    this._moveVector.z = \
-forward + this._moveState.back;\n  }\n  _updateRotationVector() {\n    \
this._rotationVector.x = -this._moveState.pitchDown + \
this._moveState.pitchUp;\n    this._rotationVector.y = \
-this._moveState.yawRight + this._moveState.yawLeft;\n    \
this._rotationVector.z = -this._moveState.rollRight + \
this._moveState.rollLeft;\n  }\n  _getContainerDimensions() {\n    if \
(this.domElement != document) {\n      return {\n        size: \
[this.domElement.offsetWidth, this.domElement.offsetHeight],\n        offset: \
[this.domElement.offsetLeft, this.domElement.offsetTop]\n      };\n    } else \
{\n      return {\n        size: [window.innerWidth, window.innerHeight],\n   \
     offset: [0, 0]\n      };\n    }\n  }\n};\nfunction onKeyDown3(event) {\n \
 if (event.altKey || this.enabled === false) {\n    return;\n  }\n  switch \
(event.code) {\n    case \"ShiftLeft\":\n    case \"ShiftRight\":\n      \
this.movementSpeedMultiplier = 0.1;\n      break;\n    case \"KeyW\":\n      \
this._moveState.forward = 1;\n      break;\n    case \"KeyS\":\n      \
this._moveState.back = 1;\n      break;\n    case \"KeyA\":\n      \
this._moveState.left = 1;\n      break;\n    case \"KeyD\":\n      \
this._moveState.right = 1;\n      break;\n    case \"KeyR\":\n      \
this._moveState.up = 1;\n      break;\n    case \"KeyF\":\n      \
this._moveState.down = 1;\n      break;\n    case \"ArrowUp\":\n      \
this._moveState.pitchUp = 1;\n      break;\n    case \"ArrowDown\":\n      \
this._moveState.pitchDown = 1;\n      break;\n    case \"ArrowLeft\":\n      \
this._moveState.yawLeft = 1;\n      break;\n    case \"ArrowRight\":\n      \
this._moveState.yawRight = 1;\n      break;\n    case \"KeyQ\":\n      \
this._moveState.rollLeft = 1;\n      break;\n    case \"KeyE\":\n      \
this._moveState.rollRight = 1;\n      break;\n  }\n  \
this._updateMovementVector();\n  this._updateRotationVector();\n}\nfunction \
onKeyUp2(event) {\n  if (this.enabled === false) return;\n  switch \
(event.code) {\n    case \"ShiftLeft\":\n    case \"ShiftRight\":\n      \
this.movementSpeedMultiplier = 1;\n      break;\n    case \"KeyW\":\n      \
this._moveState.forward = 0;\n      break;\n    case \"KeyS\":\n      \
this._moveState.back = 0;\n      break;\n    case \"KeyA\":\n      \
this._moveState.left = 0;\n      break;\n    case \"KeyD\":\n      \
this._moveState.right = 0;\n      break;\n    case \"KeyR\":\n      \
this._moveState.up = 0;\n      break;\n    case \"KeyF\":\n      \
this._moveState.down = 0;\n      break;\n    case \"ArrowUp\":\n      \
this._moveState.pitchUp = 0;\n      break;\n    case \"ArrowDown\":\n      \
this._moveState.pitchDown = 0;\n      break;\n    case \"ArrowLeft\":\n      \
this._moveState.yawLeft = 0;\n      break;\n    case \"ArrowRight\":\n      \
this._moveState.yawRight = 0;\n      break;\n    case \"KeyQ\":\n      \
this._moveState.rollLeft = 0;\n      break;\n    case \"KeyE\":\n      \
this._moveState.rollRight = 0;\n      break;\n  }\n  \
this._updateMovementVector();\n  this._updateRotationVector();\n}\nfunction \
onPointerDown4(event) {\n  if (this.enabled === false) return;\n  if \
(this.dragToLook) {\n    this._status++;\n  } else {\n    switch \
(event.button) {\n      case 0:\n        this._moveState.forward = 1;\n       \
 break;\n      case 2:\n        this._moveState.back = 1;\n        break;\n   \
 }\n    this._updateMovementVector();\n  }\n}\nfunction onPointerMove4(event) \
{\n  if (this.enabled === false) return;\n  if (!this.dragToLook || \
this._status > 0) {\n    const container = this._getContainerDimensions();\n  \
  const halfWidth = container.size[0] / 2;\n    const halfHeight = \
container.size[1] / 2;\n    this._moveState.yawLeft = -(event.pageX - \
container.offset[0] - halfWidth) / halfWidth;\n    this._moveState.pitchDown \
= (event.pageY - container.offset[1] - halfHeight) / halfHeight;\n    \
this._updateRotationVector();\n  }\n}\nfunction onPointerUp3(event) {\n  if \
(this.enabled === false) return;\n  if (this.dragToLook) {\n    \
this._status--;\n    this._moveState.yawLeft = this._moveState.pitchDown = \
0;\n  } else {\n    switch (event.button) {\n      case 0:\n        \
this._moveState.forward = 0;\n        break;\n      case 2:\n        \
this._moveState.back = 0;\n        break;\n    }\n    \
this._updateMovementVector();\n  }\n  \
this._updateRotationVector();\n}\nfunction onPointerCancel3() {\n  if \
(this.enabled === false) return;\n  if (this.dragToLook) {\n    this._status \
= 0;\n    this._moveState.yawLeft = this._moveState.pitchDown = 0;\n  } else \
{\n    this._moveState.forward = 0;\n    this._moveState.back = 0;\n    \
this._updateMovementVector();\n  }\n  \
this._updateRotationVector();\n}\nfunction onContextMenu4(event) {\n  if \
(this.enabled === false) return;\n  event.preventDefault();\n}\n\n// \
../../node_modules/three/examples/jsm/shaders/CopyShader.js\nvar CopyShader = \
{\n  name: \"CopyShader\",\n  uniforms: {\n    \"tDiffuse\": { value: null \
},\n    \"opacity\": { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n  \
  `\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = \
uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, \
1.0 );\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    \
`\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D \
tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = \
texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * \
texel;\n\n\n\t\t}`\n  )\n};\n\n// \
../../node_modules/three/examples/jsm/postprocessing/Pass.js\nvar Pass = \
class {\n  constructor() {\n    this.isPass = true;\n    this.enabled = \
true;\n    this.needsSwap = true;\n    this.clear = false;\n    \
this.renderToScreen = false;\n  }\n  setSize() {\n  }\n  render() {\n    \
console.error(\"THREE.Pass: .render() must be implemented in derived \
pass.\");\n  }\n  dispose() {\n  }\n};\nvar _camera2 = new \
OrthographicCamera(-1, 1, 1, -1, 0, 1);\nvar FullscreenTriangleGeometry = \
class extends BufferGeometry {\n  constructor() {\n    super();\n    \
this.setAttribute(\"position\", new Float32BufferAttribute([-1, 3, 0, -1, -1, \
0, 3, -1, 0], 3));\n    this.setAttribute(\"uv\", new \
Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));\n  }\n};\nvar _geometry2 = \
new FullscreenTriangleGeometry();\nvar FullScreenQuad = class {\n  \
constructor(material) {\n    this._mesh = new Mesh(_geometry2, material);\n  \
}\n  dispose() {\n    this._mesh.geometry.dispose();\n  }\n  \
render(renderer3) {\n    renderer3.render(this._mesh, _camera2);\n  }\n  get \
material() {\n    return this._mesh.material;\n  }\n  set material(value) {\n \
   this._mesh.material = value;\n  }\n};\n\n// \
../../node_modules/three/examples/jsm/postprocessing/ShaderPass.js\nvar \
ShaderPass = class extends Pass {\n  constructor(shader, textureID) {\n    \
super();\n    this.textureID = textureID !== void 0 ? textureID : \
\"tDiffuse\";\n    if (shader instanceof ShaderMaterial) {\n      \
this.uniforms = shader.uniforms;\n      this.material = shader;\n    } else \
if (shader) {\n      this.uniforms = UniformsUtils.clone(shader.uniforms);\n  \
    this.material = new ShaderMaterial({\n        name: shader.name !== void \
0 ? shader.name : \"unspecified\",\n        defines: Object.assign({}, \
shader.defines),\n        uniforms: this.uniforms,\n        vertexShader: \
shader.vertexShader,\n        fragmentShader: shader.fragmentShader\n      \
});\n    }\n    this.fsQuad = new FullScreenQuad(this.material);\n  }\n  \
render(renderer3, writeBuffer, readBuffer) {\n    if \
(this.uniforms[this.textureID]) {\n      this.uniforms[this.textureID].value \
= readBuffer.texture;\n    }\n    this.fsQuad.material = this.material;\n    \
if (this.renderToScreen) {\n      renderer3.setRenderTarget(null);\n      \
this.fsQuad.render(renderer3);\n    } else {\n      \
renderer3.setRenderTarget(writeBuffer);\n      if (this.clear) \
renderer3.clear(renderer3.autoClearColor, renderer3.autoClearDepth, \
renderer3.autoClearStencil);\n      this.fsQuad.render(renderer3);\n    }\n  \
}\n  dispose() {\n    this.material.dispose();\n    this.fsQuad.dispose();\n  \
}\n};\n\n// \
../../node_modules/three/examples/jsm/postprocessing/MaskPass.js\nvar \
MaskPass = class extends Pass {\n  constructor(scene3, camera3) {\n    \
super();\n    this.scene = scene3;\n    this.camera = camera3;\n    \
this.clear = true;\n    this.needsSwap = false;\n    this.inverse = false;\n  \
}\n  render(renderer3, writeBuffer, readBuffer) {\n    const context2 = \
renderer3.getContext();\n    const state = renderer3.state;\n    \
state.buffers.color.setMask(false);\n    \
state.buffers.depth.setMask(false);\n    \
state.buffers.color.setLocked(true);\n    \
state.buffers.depth.setLocked(true);\n    let writeValue, clearValue;\n    if \
(this.inverse) {\n      writeValue = 0;\n      clearValue = 1;\n    } else \
{\n      writeValue = 1;\n      clearValue = 0;\n    }\n    \
state.buffers.stencil.setTest(true);\n    \
state.buffers.stencil.setOp(context2.REPLACE, context2.REPLACE, \
context2.REPLACE);\n    state.buffers.stencil.setFunc(context2.ALWAYS, \
writeValue, 4294967295);\n    state.buffers.stencil.setClear(clearValue);\n   \
 state.buffers.stencil.setLocked(true);\n    \
renderer3.setRenderTarget(readBuffer);\n    if (this.clear) \
renderer3.clear();\n    renderer3.render(this.scene, this.camera);\n    \
renderer3.setRenderTarget(writeBuffer);\n    if (this.clear) \
renderer3.clear();\n    renderer3.render(this.scene, this.camera);\n    \
state.buffers.color.setLocked(false);\n    \
state.buffers.depth.setLocked(false);\n    \
state.buffers.color.setMask(true);\n    state.buffers.depth.setMask(true);\n  \
  state.buffers.stencil.setLocked(false);\n    \
state.buffers.stencil.setFunc(context2.EQUAL, 1, 4294967295);\n    \
state.buffers.stencil.setOp(context2.KEEP, context2.KEEP, context2.KEEP);\n   \
 state.buffers.stencil.setLocked(true);\n  }\n};\nvar ClearMaskPass = class \
extends Pass {\n  constructor() {\n    super();\n    this.needsSwap = \
false;\n  }\n  render(renderer3) {\n    \
renderer3.state.buffers.stencil.setLocked(false);\n    \
renderer3.state.buffers.stencil.setTest(false);\n  }\n};\n\n// \
../../node_modules/three/examples/jsm/postprocessing/EffectComposer.js\nvar \
EffectComposer = class {\n  constructor(renderer3, renderTarget) {\n    \
this.renderer = renderer3;\n    this._pixelRatio = \
renderer3.getPixelRatio();\n    if (renderTarget === void 0) {\n      const \
size = renderer3.getSize(new Vector2());\n      this._width = size.width;\n   \
   this._height = size.height;\n      renderTarget = new \
WebGLRenderTarget(this._width * this._pixelRatio, this._height * \
this._pixelRatio, { type: HalfFloatType });\n      renderTarget.texture.name \
= \"EffectComposer.rt1\";\n    } else {\n      this._width = \
renderTarget.width;\n      this._height = renderTarget.height;\n    }\n    \
this.renderTarget1 = renderTarget;\n    this.renderTarget2 = \
renderTarget.clone();\n    this.renderTarget2.texture.name = \
\"EffectComposer.rt2\";\n    this.writeBuffer = this.renderTarget1;\n    \
this.readBuffer = this.renderTarget2;\n    this.renderToScreen = true;\n    \
this.passes = [];\n    this.copyPass = new ShaderPass(CopyShader);\n    \
this.copyPass.material.blending = NoBlending;\n    this.clock = new \
Clock();\n  }\n  swapBuffers() {\n    const tmp2 = this.readBuffer;\n    \
this.readBuffer = this.writeBuffer;\n    this.writeBuffer = tmp2;\n  }\n  \
addPass(pass) {\n    this.passes.push(pass);\n    pass.setSize(this._width * \
this._pixelRatio, this._height * this._pixelRatio);\n  }\n  insertPass(pass, \
index5) {\n    this.passes.splice(index5, 0, pass);\n    \
pass.setSize(this._width * this._pixelRatio, this._height * \
this._pixelRatio);\n  }\n  removePass(pass) {\n    const index5 = \
this.passes.indexOf(pass);\n    if (index5 !== -1) {\n      \
this.passes.splice(index5, 1);\n    }\n  }\n  isLastEnabledPass(passIndex) \
{\n    for (let i = passIndex + 1; i < this.passes.length; i++) {\n      if \
(this.passes[i].enabled) {\n        return false;\n      }\n    }\n    return \
true;\n  }\n  render(deltaTime) {\n    if (deltaTime === void 0) {\n      \
deltaTime = this.clock.getDelta();\n    }\n    const currentRenderTarget = \
this.renderer.getRenderTarget();\n    let maskActive = false;\n    for (let i \
= 0, il = this.passes.length; i < il; i++) {\n      const pass = \
this.passes[i];\n      if (pass.enabled === false) continue;\n      \
pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);\n     \
 pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, \
maskActive);\n      if (pass.needsSwap) {\n        if (maskActive) {\n        \
  const context2 = this.renderer.getContext();\n          const stencil = \
this.renderer.state.buffers.stencil;\n          \
stencil.setFunc(context2.NOTEQUAL, 1, 4294967295);\n          \
this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, \
deltaTime);\n          stencil.setFunc(context2.EQUAL, 1, 4294967295);\n      \
  }\n        this.swapBuffers();\n      }\n      if (MaskPass !== void 0) {\n \
       if (pass instanceof MaskPass) {\n          maskActive = true;\n        \
} else if (pass instanceof ClearMaskPass) {\n          maskActive = false;\n  \
      }\n      }\n    }\n    \
this.renderer.setRenderTarget(currentRenderTarget);\n  }\n  \
reset(renderTarget) {\n    if (renderTarget === void 0) {\n      const size = \
this.renderer.getSize(new Vector2());\n      this._pixelRatio = \
this.renderer.getPixelRatio();\n      this._width = size.width;\n      \
this._height = size.height;\n      renderTarget = \
this.renderTarget1.clone();\n      renderTarget.setSize(this._width * \
this._pixelRatio, this._height * this._pixelRatio);\n    }\n    \
this.renderTarget1.dispose();\n    this.renderTarget2.dispose();\n    \
this.renderTarget1 = renderTarget;\n    this.renderTarget2 = \
renderTarget.clone();\n    this.writeBuffer = this.renderTarget1;\n    \
this.readBuffer = this.renderTarget2;\n  }\n  setSize(width, height) {\n    \
this._width = width;\n    this._height = height;\n    const effectiveWidth = \
this._width * this._pixelRatio;\n    const effectiveHeight = this._height * \
this._pixelRatio;\n    this.renderTarget1.setSize(effectiveWidth, \
effectiveHeight);\n    this.renderTarget2.setSize(effectiveWidth, \
effectiveHeight);\n    for (let i = 0; i < this.passes.length; i++) {\n      \
this.passes[i].setSize(effectiveWidth, effectiveHeight);\n    }\n  }\n  \
setPixelRatio(pixelRatio) {\n    this._pixelRatio = pixelRatio;\n    \
this.setSize(this._width, this._height);\n  }\n  dispose() {\n    \
this.renderTarget1.dispose();\n    this.renderTarget2.dispose();\n    \
this.copyPass.dispose();\n  }\n};\n\n// \
../../node_modules/three/examples/jsm/postprocessing/RenderPass.js\nvar \
RenderPass = class extends Pass {\n  constructor(scene3, camera3, \
overrideMaterial = null, clearColor = null, clearAlpha = null) {\n    \
super();\n    this.scene = scene3;\n    this.camera = camera3;\n    \
this.overrideMaterial = overrideMaterial;\n    this.clearColor = \
clearColor;\n    this.clearAlpha = clearAlpha;\n    this.clear = true;\n    \
this.clearDepth = false;\n    this.needsSwap = false;\n    \
this._oldClearColor = new Color();\n  }\n  render(renderer3, writeBuffer, \
readBuffer) {\n    const oldAutoClear = renderer3.autoClear;\n    \
renderer3.autoClear = false;\n    let oldClearAlpha, oldOverrideMaterial;\n   \
 if (this.overrideMaterial !== null) {\n      oldOverrideMaterial = \
this.scene.overrideMaterial;\n      this.scene.overrideMaterial = \
this.overrideMaterial;\n    }\n    if (this.clearColor !== null) {\n      \
renderer3.getClearColor(this._oldClearColor);\n      \
renderer3.setClearColor(this.clearColor, renderer3.getClearAlpha());\n    }\n \
   if (this.clearAlpha !== null) {\n      oldClearAlpha = \
renderer3.getClearAlpha();\n      renderer3.setClearAlpha(this.clearAlpha);\n \
   }\n    if (this.clearDepth == true) {\n      renderer3.clearDepth();\n    \
}\n    renderer3.setRenderTarget(this.renderToScreen ? null : readBuffer);\n  \
  if (this.clear === true) {\n      renderer3.clear(renderer3.autoClearColor, \
renderer3.autoClearDepth, renderer3.autoClearStencil);\n    }\n    \
renderer3.render(this.scene, this.camera);\n    if (this.clearColor !== null) \
{\n      renderer3.setClearColor(this._oldClearColor);\n    }\n    if \
(this.clearAlpha !== null) {\n      renderer3.setClearAlpha(oldClearAlpha);\n \
   }\n    if (this.overrideMaterial !== null) {\n      \
this.scene.overrideMaterial = oldOverrideMaterial;\n    }\n    \
renderer3.autoClear = oldAutoClear;\n  }\n};\n\n// \
../../node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() \
{\n  return _extends = Object.assign ? Object.assign.bind() : function(n) {\n \
   for (var e = 1; e < arguments.length; e++) {\n      var t = \
arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] \
= t[r]);\n    }\n    return n;\n  }, _extends.apply(null, \
arguments);\n}\n\n// \
../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunct\
ion _assertThisInitialized2(e) {\n  if (void 0 === e) throw new \
ReferenceError(\"this hasn't been initialised - super() hasn't been \
called\");\n  return e;\n}\n\n// \
../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction \
_setPrototypeOf2(t, e) {\n  return _setPrototypeOf2 = Object.setPrototypeOf ? \
Object.setPrototypeOf.bind() : function(t2, e2) {\n    return t2.__proto__ = \
e2, t2;\n  }, _setPrototypeOf2(t, e);\n}\n\n// \
../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\nfunction \
_inheritsLoose(t, o) {\n  t.prototype = Object.create(o.prototype), \
t.prototype.constructor = t, _setPrototypeOf2(t, o);\n}\n\n// \
../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nfunction \
_getPrototypeOf2(t) {\n  return _getPrototypeOf2 = Object.setPrototypeOf ? \
Object.getPrototypeOf.bind() : function(t2) {\n    return t2.__proto__ || \
Object.getPrototypeOf(t2);\n  }, _getPrototypeOf2(t);\n}\n\n// \
../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js\nfunction \
_isNativeFunction(t) {\n  try {\n    return -1 !== \
Function.toString.call(t).indexOf(\"[native code]\");\n  } catch (n) {\n    \
return \"function\" == typeof t;\n  }\n}\n\n// \
../../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\nfu\
nction _isNativeReflectConstruct2() {\n  try {\n    var t = \
!Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n \
   }));\n  } catch (t2) {\n  }\n  return (_isNativeReflectConstruct2 = \
function _isNativeReflectConstruct3() {\n    return !!t;\n  })();\n}\n\n// \
../../node_modules/@babel/runtime/helpers/esm/construct.js\nfunction \
_construct2(t, e, r) {\n  if (_isNativeReflectConstruct2()) return \
Reflect.construct.apply(null, arguments);\n  var o = [null];\n  \
o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && \
_setPrototypeOf2(p, r.prototype), p;\n}\n\n// \
../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\nfunction \
_wrapNativeSuper(t) {\n  var r = \"function\" == typeof Map ? /* @__PURE__ */ \
new Map() : void 0;\n  return _wrapNativeSuper = function \
_wrapNativeSuper2(t2) {\n    if (null === t2 || !_isNativeFunction(t2)) \
return t2;\n    if (\"function\" != typeof t2) throw new TypeError(\"Super \
expression must either be null or a function\");\n    if (void 0 !== r) {\n   \
   if (r.has(t2)) return r.get(t2);\n      r.set(t2, Wrapper);\n    }\n    \
function Wrapper() {\n      return _construct2(t2, arguments, \
_getPrototypeOf2(this).constructor);\n    }\n    return Wrapper.prototype = \
Object.create(t2.prototype, {\n      constructor: {\n        value: \
Wrapper,\n        enumerable: false,\n        writable: true,\n        \
configurable: true\n      }\n    }), _setPrototypeOf2(Wrapper, t2);\n  }, \
_wrapNativeSuper(t);\n}\n\n// \
../../node_modules/polished/dist/polished.esm.js\nvar ERRORS = {\n  \"1\": \
\"Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, \
0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 \
}).\\n\\n\",\n  \"2\": \"Passed invalid arguments to hsla, please pass \
multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: \
255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\\n\\n\",\n  \"3\": \
\"Passed an incorrect argument to a color function, please pass a string \
representation of a color.\\n\\n\",\n  \"4\": \"Couldn't generate valid rgb \
string from %s, it returned %s.\\n\\n\",\n  \"5\": \"Couldn't parse the color \
string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla \
notation.\\n\\n\",\n  \"6\": \"Passed invalid arguments to rgb, please pass \
multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, \
green: 205, blue: 100 }).\\n\\n\",\n  \"7\": \"Passed invalid arguments to \
rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object \
e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\\n\\n\",\n  \
\"8\": \"Passed invalid argument to toColorString, please pass a RgbColor, \
RgbaColor, HslColor or HslaColor object.\\n\\n\",\n  \"9\": \"Please provide \
a number of steps to the modularScale helper.\\n\\n\",\n  \"10\": \"Please \
pass a number or one of the predefined scales to the modularScale helper as \
the ratio.\\n\\n\",\n  \"11\": 'Invalid value passed as base to modularScale, \
expected number or em string but got \"%s\"\\n\\n',\n  \"12\": 'Expected a \
string ending in \"px\" or a number passed as the first argument to %s(), got \
\"%s\" instead.\\n\\n',\n  \"13\": 'Expected a string ending in \"px\" or a \
number passed as the second argument to %s(), got \"%s\" instead.\\n\\n',\n  \
\"14\": 'Passed invalid pixel value (\"%s\") to %s(), please pass a value \
like \"12px\" or 12.\\n\\n',\n  \"15\": 'Passed invalid base value (\"%s\") \
to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n  \"16\": \"You \
must provide a template to this method.\\n\\n\",\n  \"17\": \"You passed an \
unsupported selector state to this method.\\n\\n\",\n  \"18\": \"minScreen \
and maxScreen must be provided as stringified numbers with the same \
units.\\n\\n\",\n  \"19\": \"fromSize and toSize must be provided as \
stringified numbers with the same units.\\n\\n\",\n  \"20\": \"expects either \
an array of objects or a single object with the properties prop, fromSize, \
and toSize.\\n\\n\",\n  \"21\": \"expects the objects in the first argument \
array to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n  \
\"22\": \"expects the first argument object to have the properties `prop`, \
`fromSize`, and `toSize`.\\n\\n\",\n  \"23\": \"fontFace expects a name of a \
font-family.\\n\\n\",\n  \"24\": \"fontFace expects either the path to the \
font file(s) or a name of a local copy.\\n\\n\",\n  \"25\": \"fontFace \
expects localFonts to be an array.\\n\\n\",\n  \"26\": \"fontFace expects \
fileFormats to be an array.\\n\\n\",\n  \"27\": \"radialGradient requries at \
least 2 color-stops to properly render.\\n\\n\",\n  \"28\": \"Please supply a \
filename to retinaImage() as the first argument.\\n\\n\",\n  \"29\": \"Passed \
invalid argument to triangle, please pass correct pointingDirection e.g. \
'right'.\\n\\n\",\n  \"30\": \"Passed an invalid value to `height` or \
`width`. Please provide a pixel based unit.\\n\\n\",\n  \"31\": \"The \
animation shorthand only takes 8 arguments. See the specification for more \
information: http://mdn.io/animation\\n\\n\",\n  \"32\": \"To pass multiple \
animations please supply them in arrays, e.g. animation(['rotate', '2s'], \
['move', '1s'])\\nTo pass a single animation please supply them in simple \
values, e.g. animation('rotate', '2s')\\n\\n\",\n  \"33\": \"The animation \
shorthand arrays can only have 8 elements. See the specification for more \
information: http://mdn.io/animation\\n\\n\",\n  \"34\": \"borderRadius \
expects a radius value as a string or number as the second \
argument.\\n\\n\",\n  \"35\": 'borderRadius expects one of \"top\", \
\"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n  \"36\": \
\"Property must be a string value.\\n\\n\",\n  \"37\": \"Syntax Error at \
%s.\\n\\n\",\n  \"38\": \"Formula contains a function that needs parentheses \
at %s.\\n\\n\",\n  \"39\": \"Formula is missing closing parenthesis at \
%s.\\n\\n\",\n  \"40\": \"Formula has too many closing parentheses at \
%s.\\n\\n\",\n  \"41\": \"All values in a formula must have the same unit or \
be unitless.\\n\\n\",\n  \"42\": \"Please provide a number of steps to the \
modularScale helper.\\n\\n\",\n  \"43\": \"Please pass a number or one of the \
predefined scales to the modularScale helper as the ratio.\\n\\n\",\n  \
\"44\": \"Invalid value passed as base to modularScale, expected number or \
em/rem string but got %s.\\n\\n\",\n  \"45\": \"Passed invalid argument to \
hslToColorString, please pass a HslColor or HslaColor object.\\n\\n\",\n  \
\"46\": \"Passed invalid argument to rgbToColorString, please pass a RgbColor \
or RgbaColor object.\\n\\n\",\n  \"47\": \"minScreen and maxScreen must be \
provided as stringified numbers with the same units.\\n\\n\",\n  \"48\": \
\"fromSize and toSize must be provided as stringified numbers with the same \
units.\\n\\n\",\n  \"49\": \"Expects either an array of objects or a single \
object with the properties prop, fromSize, and toSize.\\n\\n\",\n  \"50\": \
\"Expects the objects in the first argument array to have the properties \
prop, fromSize, and toSize.\\n\\n\",\n  \"51\": \"Expects the first argument \
object to have the properties prop, fromSize, and toSize.\\n\\n\",\n  \"52\": \
\"fontFace expects either the path to the font file(s) or a name of a local \
copy.\\n\\n\",\n  \"53\": \"fontFace expects localFonts to be an \
array.\\n\\n\",\n  \"54\": \"fontFace expects fileFormats to be an \
array.\\n\\n\",\n  \"55\": \"fontFace expects a name of a \
font-family.\\n\\n\",\n  \"56\": \"linearGradient requries at least 2 \
color-stops to properly render.\\n\\n\",\n  \"57\": \"radialGradient requries \
at least 2 color-stops to properly render.\\n\\n\",\n  \"58\": \"Please \
supply a filename to retinaImage() as the first argument.\\n\\n\",\n  \"59\": \
\"Passed invalid argument to triangle, please pass correct pointingDirection \
e.g. 'right'.\\n\\n\",\n  \"60\": \"Passed an invalid value to `height` or \
`width`. Please provide a pixel based unit.\\n\\n\",\n  \"61\": \"Property \
must be a string value.\\n\\n\",\n  \"62\": \"borderRadius expects a radius \
value as a string or number as the second argument.\\n\\n\",\n  \"63\": \
'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as \
the first argument.\\n\\n',\n  \"64\": \"The animation shorthand only takes 8 \
arguments. See the specification for more information: \
http://mdn.io/animation.\\n\\n\",\n  \"65\": \"To pass multiple animations \
please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', \
'1s'])\\\\nTo pass a single animation please supply them in simple values, \
e.g. animation('rotate', '2s').\\n\\n\",\n  \"66\": \"The animation shorthand \
arrays can only have 8 elements. See the specification for more information: \
http://mdn.io/animation.\\n\\n\",\n  \"67\": \"You must provide a template to \
this method.\\n\\n\",\n  \"68\": \"You passed an unsupported selector state \
to this method.\\n\\n\",\n  \"69\": 'Expected a string ending in \"px\" or a \
number passed as the first argument to %s(), got %s instead.\\n\\n',\n  \
\"70\": 'Expected a string ending in \"px\" or a number passed as the second \
argument to %s(), got %s instead.\\n\\n',\n  \"71\": 'Passed invalid pixel \
value %s to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n  \"72\": \
'Passed invalid base value %s to %s(), please pass a value like \"12px\" or \
12.\\n\\n',\n  \"73\": \"Please provide a valid CSS variable.\\n\\n\",\n  \
\"74\": \"CSS variable not found and no default was provided.\\n\\n\",\n  \
\"75\": \"important requires a valid style object, got a %s \
instead.\\n\\n\",\n  \"76\": \"fromSize and toSize must be provided as \
stringified numbers with the same units as minScreen and \
maxScreen.\\n\\n\",\n  \"77\": 'remToPx expects a value in \"rem\" but you \
provided it in \"%s\".\\n\\n',\n  \"78\": 'base must be set in \"px\" or \
\"%\" but you set it in \"%s\".\\n'\n};\nfunction format() {\n  for (var _len \
= arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) \
{\n    args[_key] = arguments[_key];\n  }\n  var a2 = args[0];\n  var b = \
[];\n  var c2;\n  for (c2 = 1; c2 < args.length; c2 += 1) {\n    \
b.push(args[c2]);\n  }\n  b.forEach(function(d) {\n    a2 = \
a2.replace(/%[a-z]/, d);\n  });\n  return a2;\n}\nvar PolishedError = /* \
@__PURE__ */ function(_Error) {\n  _inheritsLoose(PolishedError2, _Error);\n  \
function PolishedError2(code) {\n    var _this;\n    if (false) {\n      \
_this = _Error.call(this, \"An error occurred. See \
https://github.com/styled-components/polished/blob/main/src/internalHelpers/e\
rrors.md#\" + code + \" for more information.\") || this;\n    } else {\n     \
 for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : \
0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = \
arguments[_key2];\n      }\n      _this = _Error.call(this, format.apply(void \
0, [ERRORS[code]].concat(args))) || this;\n    }\n    return \
_assertThisInitialized2(_this);\n  }\n  return PolishedError2;\n}(/* \
@__PURE__ */ _wrapNativeSuper(Error));\nfunction endsWith(string, suffix) {\n \
 return string.substr(-suffix.length) === suffix;\n}\nvar cssRegex$1 = \
/^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\nfunction stripUnit(value) {\n  if \
(typeof value !== \"string\") return value;\n  var matchedValue = \
value.match(cssRegex$1);\n  return matchedValue ? parseFloat(value) : \
value;\n}\nvar pxtoFactory = function pxtoFactory2(to) {\n  return \
function(pxval, base) {\n    if (base === void 0) {\n      base = \"16px\";\n \
   }\n    var newPxval = pxval;\n    var newBase = base;\n    if (typeof \
pxval === \"string\") {\n      if (!endsWith(pxval, \"px\")) {\n        throw \
new PolishedError(69, to, pxval);\n      }\n      newPxval = \
stripUnit(pxval);\n    }\n    if (typeof base === \"string\") {\n      if \
(!endsWith(base, \"px\")) {\n        throw new PolishedError(70, to, base);\n \
     }\n      newBase = stripUnit(base);\n    }\n    if (typeof newPxval === \
\"string\") {\n      throw new PolishedError(71, pxval, to);\n    }\n    if \
(typeof newBase === \"string\") {\n      throw new PolishedError(72, base, \
to);\n    }\n    return \"\" + newPxval / newBase + to;\n  };\n};\nvar \
pixelsto = pxtoFactory;\nvar em = pixelsto(\"em\");\nvar rem = \
pixelsto(\"rem\");\nfunction colorToInt(color2) {\n  return Math.round(color2 \
* 255);\n}\nfunction convertToInt(red, green, blue) {\n  return \
colorToInt(red) + \",\" + colorToInt(green) + \",\" + \
colorToInt(blue);\n}\nfunction hslToRgb2(hue, saturation, lightness, \
convert2) {\n  if (convert2 === void 0) {\n    convert2 = convertToInt;\n  \
}\n  if (saturation === 0) {\n    return convert2(lightness, lightness, \
lightness);\n  }\n  var huePrime = (hue % 360 + 360) % 360 / 60;\n  var \
chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;\n  var \
secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));\n  var red = \
0;\n  var green = 0;\n  var blue = 0;\n  if (huePrime >= 0 && huePrime < 1) \
{\n    red = chroma;\n    green = secondComponent;\n  } else if (huePrime >= \
1 && huePrime < 2) {\n    red = secondComponent;\n    green = chroma;\n  } \
else if (huePrime >= 2 && huePrime < 3) {\n    green = chroma;\n    blue = \
secondComponent;\n  } else if (huePrime >= 3 && huePrime < 4) {\n    green = \
secondComponent;\n    blue = chroma;\n  } else if (huePrime >= 4 && huePrime \
< 5) {\n    red = secondComponent;\n    blue = chroma;\n  } else if (huePrime \
>= 5 && huePrime < 6) {\n    red = chroma;\n    blue = secondComponent;\n  \
}\n  var lightnessModification = lightness - chroma / 2;\n  var finalRed = \
red + lightnessModification;\n  var finalGreen = green + \
lightnessModification;\n  var finalBlue = blue + lightnessModification;\n  \
return convert2(finalRed, finalGreen, finalBlue);\n}\nvar namedColorMap = {\n \
 aliceblue: \"f0f8ff\",\n  antiquewhite: \"faebd7\",\n  aqua: \"00ffff\",\n  \
aquamarine: \"7fffd4\",\n  azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  \
bisque: \"ffe4c4\",\n  black: \"000\",\n  blanchedalmond: \"ffebcd\",\n  \
blue: \"0000ff\",\n  blueviolet: \"8a2be2\",\n  brown: \"a52a2a\",\n  \
burlywood: \"deb887\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n \
 chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \
\"6495ed\",\n  cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \
\"00ffff\",\n  darkblue: \"00008b\",\n  darkcyan: \"008b8b\",\n  \
darkgoldenrod: \"b8860b\",\n  darkgray: \"a9a9a9\",\n  darkgreen: \
\"006400\",\n  darkgrey: \"a9a9a9\",\n  darkkhaki: \"bdb76b\",\n  \
darkmagenta: \"8b008b\",\n  darkolivegreen: \"556b2f\",\n  darkorange: \
\"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \"8b0000\",\n  darksalmon: \
\"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  darkslateblue: \"483d8b\",\n  \
darkslategray: \"2f4f4f\",\n  darkslategrey: \"2f4f4f\",\n  darkturquoise: \
\"00ced1\",\n  darkviolet: \"9400d3\",\n  deeppink: \"ff1493\",\n  \
deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  dimgrey: \"696969\",\n  \
dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  floralwhite: \
\"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"ff00ff\",\n  gainsboro: \
\"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  goldenrod: \
\"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  greenyellow: \
\"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  hotpink: \
\"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  ivory: \
\"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  lavenderblush: \
\"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \"fffacd\",\n  \
lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  lightcyan: \"e0ffff\",\n \
 lightgoldenrodyellow: \"fafad2\",\n  lightgray: \"d3d3d3\",\n  lightgreen: \
\"90ee90\",\n  lightgrey: \"d3d3d3\",\n  lightpink: \"ffb6c1\",\n  \
lightsalmon: \"ffa07a\",\n  lightseagreen: \"20b2aa\",\n  lightskyblue: \
\"87cefa\",\n  lightslategray: \"789\",\n  lightslategrey: \"789\",\n  \
lightsteelblue: \"b0c4de\",\n  lightyellow: \"ffffe0\",\n  lime: \"0f0\",\n  \
limegreen: \"32cd32\",\n  linen: \"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \
\"800000\",\n  mediumaquamarine: \"66cdaa\",\n  mediumblue: \"0000cd\",\n  \
mediumorchid: \"ba55d3\",\n  mediumpurple: \"9370db\",\n  mediumseagreen: \
\"3cb371\",\n  mediumslateblue: \"7b68ee\",\n  mediumspringgreen: \
\"00fa9a\",\n  mediumturquoise: \"48d1cc\",\n  mediumvioletred: \"c71585\",\n \
 midnightblue: \"191970\",\n  mintcream: \"f5fffa\",\n  mistyrose: \
\"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  navajowhite: \"ffdead\",\n  navy: \
\"000080\",\n  oldlace: \"fdf5e6\",\n  olive: \"808000\",\n  olivedrab: \
\"6b8e23\",\n  orange: \"ffa500\",\n  orangered: \"ff4500\",\n  orchid: \
\"da70d6\",\n  palegoldenrod: \"eee8aa\",\n  palegreen: \"98fb98\",\n  \
paleturquoise: \"afeeee\",\n  palevioletred: \"db7093\",\n  papayawhip: \
\"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pink: \
\"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \"b0e0e6\",\n  purple: \
\"800080\",\n  rebeccapurple: \"639\",\n  red: \"f00\",\n  rosybrown: \
\"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \"8b4513\",\n  salmon: \
\"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \"2e8b57\",\n  seashell: \
\"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyblue: \
\"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \"708090\",\n  slategrey: \
\"708090\",\n  snow: \"fffafa\",\n  springgreen: \"00ff7f\",\n  steelblue: \
\"4682b4\",\n  tan: \"d2b48c\",\n  teal: \"008080\",\n  thistle: \
\"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \"40e0d0\",\n  violet: \
\"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n  whitesmoke: \
\"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \"9acd32\"\n};\nfunction \
nameToHex(color2) {\n  if (typeof color2 !== \"string\") return color2;\n  \
var normalizedColorName = color2.toLowerCase();\n  return \
namedColorMap[normalizedColorName] ? \"#\" + \
namedColorMap[normalizedColorName] : color2;\n}\nvar hexRegex = \
/^#[a-fA-F0-9]{6}$/;\nvar hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;\nvar \
reducedHexRegex = /^#[a-fA-F0-9]{3}$/;\nvar reducedRgbaHexRegex = \
/^#[a-fA-F0-9]{4}$/;\nvar rgbRegex = \
/^rgb\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*\\)\
$/i;\nvar rgbaRegex = \
/^rgb(?:a)?\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\
\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]?)\\s*\\)$/i;\nvar hslRegex = \
/^hsl\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\\
s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*\\)$/i;\nvar hslaRegex = \
/^hsl(?:a)?\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9\
]?)%\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]\
?)\\s*\\)$/i;\nfunction parseToRgb(color2) {\n  if (typeof color2 !== \
\"string\") {\n    throw new PolishedError(3);\n  }\n  var normalizedColor = \
nameToHex(color2);\n  if (normalizedColor.match(hexRegex)) {\n    return {\n  \
    red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n      \
green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n      \
blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16)\n    };\n  \
}\n  if (normalizedColor.match(hexRgbaRegex)) {\n    var alpha = \
parseFloat((parseInt(\"\" + normalizedColor[7] + normalizedColor[8], 16) / \
255).toFixed(2));\n    return {\n      red: parseInt(\"\" + \
normalizedColor[1] + normalizedColor[2], 16),\n      green: parseInt(\"\" + \
normalizedColor[3] + normalizedColor[4], 16),\n      blue: parseInt(\"\" + \
normalizedColor[5] + normalizedColor[6], 16),\n      alpha\n    };\n  }\n  if \
(normalizedColor.match(reducedHexRegex)) {\n    return {\n      red: \
parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n      green: \
parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n      blue: \
parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16)\n    };\n  }\n  \
if (normalizedColor.match(reducedRgbaHexRegex)) {\n    var _alpha = \
parseFloat((parseInt(\"\" + normalizedColor[4] + normalizedColor[4], 16) / \
255).toFixed(2));\n    return {\n      red: parseInt(\"\" + \
normalizedColor[1] + normalizedColor[1], 16),\n      green: parseInt(\"\" + \
normalizedColor[2] + normalizedColor[2], 16),\n      blue: parseInt(\"\" + \
normalizedColor[3] + normalizedColor[3], 16),\n      alpha: _alpha\n    };\n  \
}\n  var rgbMatched = rgbRegex.exec(normalizedColor);\n  if (rgbMatched) {\n  \
  return {\n      red: parseInt(\"\" + rgbMatched[1], 10),\n      green: \
parseInt(\"\" + rgbMatched[2], 10),\n      blue: parseInt(\"\" + \
rgbMatched[3], 10)\n    };\n  }\n  var rgbaMatched = \
rgbaRegex.exec(normalizedColor.substring(0, 50));\n  if (rgbaMatched) {\n    \
return {\n      red: parseInt(\"\" + rgbaMatched[1], 10),\n      green: \
parseInt(\"\" + rgbaMatched[2], 10),\n      blue: parseInt(\"\" + \
rgbaMatched[3], 10),\n      alpha: parseFloat(\"\" + rgbaMatched[4]) > 1 ? \
parseFloat(\"\" + rgbaMatched[4]) / 100 : parseFloat(\"\" + rgbaMatched[4])\n \
   };\n  }\n  var hslMatched = hslRegex.exec(normalizedColor);\n  if \
(hslMatched) {\n    var hue = parseInt(\"\" + hslMatched[1], 10);\n    var \
saturation = parseInt(\"\" + hslMatched[2], 10) / 100;\n    var lightness = \
parseInt(\"\" + hslMatched[3], 10) / 100;\n    var rgbColorString = \"rgb(\" \
+ hslToRgb2(hue, saturation, lightness) + \")\";\n    var hslRgbMatched = \
rgbRegex.exec(rgbColorString);\n    if (!hslRgbMatched) {\n      throw new \
PolishedError(4, normalizedColor, rgbColorString);\n    }\n    return {\n     \
 red: parseInt(\"\" + hslRgbMatched[1], 10),\n      green: parseInt(\"\" + \
hslRgbMatched[2], 10),\n      blue: parseInt(\"\" + hslRgbMatched[3], 10)\n   \
 };\n  }\n  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, \
50));\n  if (hslaMatched) {\n    var _hue = parseInt(\"\" + hslaMatched[1], \
10);\n    var _saturation = parseInt(\"\" + hslaMatched[2], 10) / 100;\n    \
var _lightness = parseInt(\"\" + hslaMatched[3], 10) / 100;\n    var \
_rgbColorString = \"rgb(\" + hslToRgb2(_hue, _saturation, _lightness) + \
\")\";\n    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);\n    if \
(!_hslRgbMatched) {\n      throw new PolishedError(4, normalizedColor, \
_rgbColorString);\n    }\n    return {\n      red: parseInt(\"\" + \
_hslRgbMatched[1], 10),\n      green: parseInt(\"\" + _hslRgbMatched[2], \
10),\n      blue: parseInt(\"\" + _hslRgbMatched[3], 10),\n      alpha: \
parseFloat(\"\" + hslaMatched[4]) > 1 ? parseFloat(\"\" + hslaMatched[4]) / \
100 : parseFloat(\"\" + hslaMatched[4])\n    };\n  }\n  throw new \
PolishedError(5);\n}\nfunction rgbToHsl2(color2) {\n  var red = color2.red / \
255;\n  var green = color2.green / 255;\n  var blue = color2.blue / 255;\n  \
var max2 = Math.max(red, green, blue);\n  var min2 = Math.min(red, green, \
blue);\n  var lightness = (max2 + min2) / 2;\n  if (max2 === min2) {\n    if \
(color2.alpha !== void 0) {\n      return {\n        hue: 0,\n        \
saturation: 0,\n        lightness,\n        alpha: color2.alpha\n      };\n   \
 } else {\n      return {\n        hue: 0,\n        saturation: 0,\n        \
lightness\n      };\n    }\n  }\n  var hue;\n  var delta = max2 - min2;\n  \
var saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 \
+ min2);\n  switch (max2) {\n    case red:\n      hue = (green - blue) / \
delta + (green < blue ? 6 : 0);\n      break;\n    case green:\n      hue = \
(blue - red) / delta + 2;\n      break;\n    default:\n      hue = (red - \
green) / delta + 4;\n      break;\n  }\n  hue *= 60;\n  if (color2.alpha !== \
void 0) {\n    return {\n      hue,\n      saturation,\n      lightness,\n    \
  alpha: color2.alpha\n    };\n  }\n  return {\n    hue,\n    saturation,\n   \
 lightness\n  };\n}\nfunction parseToHsl(color2) {\n  return \
rgbToHsl2(parseToRgb(color2));\n}\nvar reduceHexValue = function \
reduceHexValue2(value) {\n  if (value.length === 7 && value[1] === value[2] \
&& value[3] === value[4] && value[5] === value[6]) {\n    return \"#\" + \
value[1] + value[3] + value[5];\n  }\n  return value;\n};\nvar \
reduceHexValue$1 = reduceHexValue;\nfunction numberToHex(value) {\n  var hex \
= value.toString(16);\n  return hex.length === 1 ? \"0\" + hex : \
hex;\n}\nfunction colorToHex(color2) {\n  return \
numberToHex(Math.round(color2 * 255));\n}\nfunction convertToHex(red, green, \
blue) {\n  return reduceHexValue$1(\"#\" + colorToHex(red) + \
colorToHex(green) + colorToHex(blue));\n}\nfunction hslToHex(hue, saturation, \
lightness) {\n  return hslToRgb2(hue, saturation, lightness, \
convertToHex);\n}\nfunction hsl(value, saturation, lightness) {\n  if (typeof \
value === \"number\" && typeof saturation === \"number\" && typeof lightness \
=== \"number\") {\n    return hslToHex(value, saturation, lightness);\n  } \
else if (typeof value === \"object\" && saturation === void 0 && lightness \
=== void 0) {\n    return hslToHex(value.hue, value.saturation, \
value.lightness);\n  }\n  throw new PolishedError(1);\n}\nfunction \
hsla(value, saturation, lightness, alpha) {\n  if (typeof value === \
\"number\" && typeof saturation === \"number\" && typeof lightness === \
\"number\" && typeof alpha === \"number\") {\n    return alpha >= 1 ? \
hslToHex(value, saturation, lightness) : \"rgba(\" + hslToRgb2(value, \
saturation, lightness) + \",\" + alpha + \")\";\n  } else if (typeof value \
=== \"object\" && saturation === void 0 && lightness === void 0 && alpha === \
void 0) {\n    return value.alpha >= 1 ? hslToHex(value.hue, \
value.saturation, value.lightness) : \"rgba(\" + hslToRgb2(value.hue, \
value.saturation, value.lightness) + \",\" + value.alpha + \")\";\n  }\n  \
throw new PolishedError(2);\n}\nfunction rgb(value, green, blue) {\n  if \
(typeof value === \"number\" && typeof green === \"number\" && typeof blue \
=== \"number\") {\n    return reduceHexValue$1(\"#\" + numberToHex(value) + \
numberToHex(green) + numberToHex(blue));\n  } else if (typeof value === \
\"object\" && green === void 0 && blue === void 0) {\n    return \
reduceHexValue$1(\"#\" + numberToHex(value.red) + numberToHex(value.green) + \
numberToHex(value.blue));\n  }\n  throw new PolishedError(6);\n}\nfunction \
rgba(firstValue, secondValue, thirdValue, fourthValue) {\n  if (typeof \
firstValue === \"string\" && typeof secondValue === \"number\") {\n    var \
rgbValue = parseToRgb(firstValue);\n    return \"rgba(\" + rgbValue.red + \
\",\" + rgbValue.green + \",\" + rgbValue.blue + \",\" + secondValue + \
\")\";\n  } else if (typeof firstValue === \"number\" && typeof secondValue \
=== \"number\" && typeof thirdValue === \"number\" && typeof fourthValue === \
\"number\") {\n    return fourthValue >= 1 ? rgb(firstValue, secondValue, \
thirdValue) : \"rgba(\" + firstValue + \",\" + secondValue + \",\" + \
thirdValue + \",\" + fourthValue + \")\";\n  } else if (typeof firstValue === \
\"object\" && secondValue === void 0 && thirdValue === void 0 && fourthValue \
=== void 0) {\n    return firstValue.alpha >= 1 ? rgb(firstValue.red, \
firstValue.green, firstValue.blue) : \"rgba(\" + firstValue.red + \",\" + \
firstValue.green + \",\" + firstValue.blue + \",\" + firstValue.alpha + \
\")\";\n  }\n  throw new PolishedError(7);\n}\nvar isRgb = function \
isRgb2(color2) {\n  return typeof color2.red === \"number\" && typeof \
color2.green === \"number\" && typeof color2.blue === \"number\" && (typeof \
color2.alpha !== \"number\" || typeof color2.alpha === \
\"undefined\");\n};\nvar isRgba = function isRgba2(color2) {\n  return typeof \
color2.red === \"number\" && typeof color2.green === \"number\" && typeof \
color2.blue === \"number\" && typeof color2.alpha === \"number\";\n};\nvar \
isHsl = function isHsl2(color2) {\n  return typeof color2.hue === \"number\" \
&& typeof color2.saturation === \"number\" && typeof color2.lightness === \
\"number\" && (typeof color2.alpha !== \"number\" || typeof color2.alpha === \
\"undefined\");\n};\nvar isHsla = function isHsla2(color2) {\n  return typeof \
color2.hue === \"number\" && typeof color2.saturation === \"number\" && \
typeof color2.lightness === \"number\" && typeof color2.alpha === \
\"number\";\n};\nfunction toColorString(color2) {\n  if (typeof color2 !== \
\"object\") throw new PolishedError(8);\n  if (isRgba(color2)) return \
rgba(color2);\n  if (isRgb(color2)) return rgb(color2);\n  if \
(isHsla(color2)) return hsla(color2);\n  if (isHsl(color2)) return \
hsl(color2);\n  throw new PolishedError(8);\n}\nfunction curried(f, length2, \
acc) {\n  return function fn() {\n    var combined = \
acc.concat(Array.prototype.slice.call(arguments));\n    return \
combined.length >= length2 ? f.apply(this, combined) : curried(f, length2, \
combined);\n  };\n}\nfunction curry(f) {\n  return curried(f, f.length, \
[]);\n}\nfunction adjustHue(degree, color2) {\n  if (color2 === \
\"transparent\") return color2;\n  var hslColor = parseToHsl(color2);\n  \
return toColorString(_extends({}, hslColor, {\n    hue: hslColor.hue + \
parseFloat(degree)\n  }));\n}\nvar curriedAdjustHue = \
curry(adjustHue);\nfunction guard(lowerBoundary, upperBoundary, value) {\n  \
return Math.max(lowerBoundary, Math.min(upperBoundary, value));\n}\nfunction \
darken2(amount, color2) {\n  if (color2 === \"transparent\") return color2;\n \
 var hslColor = parseToHsl(color2);\n  return toColorString(_extends({}, \
hslColor, {\n    lightness: guard(0, 1, hslColor.lightness - \
parseFloat(amount))\n  }));\n}\nvar curriedDarken = curry(darken2);\nfunction \
desaturate2(amount, color2) {\n  if (color2 === \"transparent\") return \
color2;\n  var hslColor = parseToHsl(color2);\n  return \
toColorString(_extends({}, hslColor, {\n    saturation: guard(0, 1, \
hslColor.saturation - parseFloat(amount))\n  }));\n}\nvar curriedDesaturate = \
curry(desaturate2);\nfunction lighten2(amount, color2) {\n  if (color2 === \
\"transparent\") return color2;\n  var hslColor = parseToHsl(color2);\n  \
return toColorString(_extends({}, hslColor, {\n    lightness: guard(0, 1, \
hslColor.lightness + parseFloat(amount))\n  }));\n}\nvar curriedLighten = \
curry(lighten2);\nfunction mix2(weight, color2, otherColor) {\n  if (color2 \
=== \"transparent\") return otherColor;\n  if (otherColor === \
\"transparent\") return color2;\n  if (weight === 0) return otherColor;\n  \
var parsedColor1 = parseToRgb(color2);\n  var color1 = _extends({}, \
parsedColor1, {\n    alpha: typeof parsedColor1.alpha === \"number\" ? \
parsedColor1.alpha : 1\n  });\n  var parsedColor2 = parseToRgb(otherColor);\n \
 var color22 = _extends({}, parsedColor2, {\n    alpha: typeof \
parsedColor2.alpha === \"number\" ? parsedColor2.alpha : 1\n  });\n  var \
alphaDelta = color1.alpha - color22.alpha;\n  var x2 = parseFloat(weight) * 2 \
- 1;\n  var y2 = x2 * alphaDelta === -1 ? x2 : x2 + alphaDelta;\n  var z2 = 1 \
+ x2 * alphaDelta;\n  var weight1 = (y2 / z2 + 1) / 2;\n  var weight2 = 1 - \
weight1;\n  var mixedColor = {\n    red: Math.floor(color1.red * weight1 + \
color22.red * weight2),\n    green: Math.floor(color1.green * weight1 + \
color22.green * weight2),\n    blue: Math.floor(color1.blue * weight1 + \
color22.blue * weight2),\n    alpha: color1.alpha * parseFloat(weight) + \
color22.alpha * (1 - parseFloat(weight))\n  };\n  return \
rgba(mixedColor);\n}\nvar curriedMix = curry(mix2);\nvar mix$1 = \
curriedMix;\nfunction opacify(amount, color2) {\n  if (color2 === \
\"transparent\") return color2;\n  var parsedColor = parseToRgb(color2);\n  \
var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : \
1;\n  var colorWithAlpha = _extends({}, parsedColor, {\n    alpha: guard(0, \
1, (alpha * 100 + parseFloat(amount) * 100) / 100)\n  });\n  return \
rgba(colorWithAlpha);\n}\nvar curriedOpacify = curry(opacify);\nvar \
curriedOpacify$1 = curriedOpacify;\nfunction saturate3(amount, color2) {\n  \
if (color2 === \"transparent\") return color2;\n  var hslColor = \
parseToHsl(color2);\n  return toColorString(_extends({}, hslColor, {\n    \
saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))\n  \
}));\n}\nvar curriedSaturate = curry(saturate3);\nfunction setHue(hue, \
color2) {\n  if (color2 === \"transparent\") return color2;\n  return \
toColorString(_extends({}, parseToHsl(color2), {\n    hue: parseFloat(hue)\n  \
}));\n}\nvar curriedSetHue = curry(setHue);\nfunction setLightness(lightness, \
color2) {\n  if (color2 === \"transparent\") return color2;\n  return \
toColorString(_extends({}, parseToHsl(color2), {\n    lightness: \
parseFloat(lightness)\n  }));\n}\nvar curriedSetLightness = \
curry(setLightness);\nfunction setSaturation(saturation, color2) {\n  if \
(color2 === \"transparent\") return color2;\n  return \
toColorString(_extends({}, parseToHsl(color2), {\n    saturation: \
parseFloat(saturation)\n  }));\n}\nvar curriedSetSaturation = \
curry(setSaturation);\nfunction shade(percentage, color2) {\n  if (color2 === \
\"transparent\") return color2;\n  return mix$1(parseFloat(percentage), \
\"rgb(0, 0, 0)\", color2);\n}\nvar curriedShade = curry(shade);\nfunction \
tint(percentage, color2) {\n  if (color2 === \"transparent\") return \
color2;\n  return mix$1(parseFloat(percentage), \"rgb(255, 255, 255)\", \
color2);\n}\nvar curriedTint = curry(tint);\nfunction transparentize(amount, \
color2) {\n  if (color2 === \"transparent\") return color2;\n  var \
parsedColor = parseToRgb(color2);\n  var alpha = typeof parsedColor.alpha === \
\"number\" ? parsedColor.alpha : 1;\n  var colorWithAlpha = _extends({}, \
parsedColor, {\n    alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * \
100).toFixed(2) / 100)\n  });\n  return rgba(colorWithAlpha);\n}\nvar \
curriedTransparentize = curry(transparentize);\n\n// \
../../node_modules/@tweenjs/tween.js/dist/tween.esm.js\nvar Easing = \
Object.freeze({\n  Linear: Object.freeze({\n    None: function(amount) {\n    \
  return amount;\n    },\n    In: function(amount) {\n      return amount;\n  \
  },\n    Out: function(amount) {\n      return amount;\n    },\n    InOut: \
function(amount) {\n      return amount;\n    }\n  }),\n  Quadratic: \
Object.freeze({\n    In: function(amount) {\n      return amount * amount;\n  \
  },\n    Out: function(amount) {\n      return amount * (2 - amount);\n    \
},\n    InOut: function(amount) {\n      if ((amount *= 2) < 1) {\n        \
return 0.5 * amount * amount;\n      }\n      return -0.5 * (--amount * \
(amount - 2) - 1);\n    }\n  }),\n  Cubic: Object.freeze({\n    In: \
function(amount) {\n      return amount * amount * amount;\n    },\n    Out: \
function(amount) {\n      return --amount * amount * amount + 1;\n    },\n    \
InOut: function(amount) {\n      if ((amount *= 2) < 1) {\n        return 0.5 \
* amount * amount * amount;\n      }\n      return 0.5 * ((amount -= 2) * \
amount * amount + 2);\n    }\n  }),\n  Quartic: Object.freeze({\n    In: \
function(amount) {\n      return amount * amount * amount * amount;\n    },\n \
   Out: function(amount) {\n      return 1 - --amount * amount * amount * \
amount;\n    },\n    InOut: function(amount) {\n      if ((amount *= 2) < 1) \
{\n        return 0.5 * amount * amount * amount * amount;\n      }\n      \
return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n    }\n  }),\n \
 Quintic: Object.freeze({\n    In: function(amount) {\n      return amount * \
amount * amount * amount * amount;\n    },\n    Out: function(amount) {\n     \
 return --amount * amount * amount * amount * amount + 1;\n    },\n    InOut: \
function(amount) {\n      if ((amount *= 2) < 1) {\n        return 0.5 * \
amount * amount * amount * amount * amount;\n      }\n      return 0.5 * \
((amount -= 2) * amount * amount * amount * amount + 2);\n    }\n  }),\n  \
Sinusoidal: Object.freeze({\n    In: function(amount) {\n      return 1 - \
Math.sin((1 - amount) * Math.PI / 2);\n    },\n    Out: function(amount) {\n  \
    return Math.sin(amount * Math.PI / 2);\n    },\n    InOut: \
function(amount) {\n      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - \
amount)));\n    }\n  }),\n  Exponential: Object.freeze({\n    In: \
function(amount) {\n      return amount === 0 ? 0 : Math.pow(1024, amount - \
1);\n    },\n    Out: function(amount) {\n      return amount === 1 ? 1 : 1 - \
Math.pow(2, -10 * amount);\n    },\n    InOut: function(amount) {\n      if \
(amount === 0) {\n        return 0;\n      }\n      if (amount === 1) {\n     \
   return 1;\n      }\n      if ((amount *= 2) < 1) {\n        return 0.5 * \
Math.pow(1024, amount - 1);\n      }\n      return 0.5 * (-Math.pow(2, -10 * \
(amount - 1)) + 2);\n    }\n  }),\n  Circular: Object.freeze({\n    In: \
function(amount) {\n      return 1 - Math.sqrt(1 - amount * amount);\n    \
},\n    Out: function(amount) {\n      return Math.sqrt(1 - --amount * \
amount);\n    },\n    InOut: function(amount) {\n      if ((amount *= 2) < 1) \
{\n        return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n      }\n     \
 return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n    }\n  }),\n  \
Elastic: Object.freeze({\n    In: function(amount) {\n      if (amount === 0) \
{\n        return 0;\n      }\n      if (amount === 1) {\n        return 1;\n \
     }\n      return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - \
1.1) * 5 * Math.PI);\n    },\n    Out: function(amount) {\n      if (amount \
=== 0) {\n        return 0;\n      }\n      if (amount === 1) {\n        \
return 1;\n      }\n      return Math.pow(2, -10 * amount) * Math.sin((amount \
- 0.1) * 5 * Math.PI) + 1;\n    },\n    InOut: function(amount) {\n      if \
(amount === 0) {\n        return 0;\n      }\n      if (amount === 1) {\n     \
   return 1;\n      }\n      amount *= 2;\n      if (amount < 1) {\n        \
return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * \
Math.PI);\n      }\n      return 0.5 * Math.pow(2, -10 * (amount - 1)) * \
Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\n    }\n  }),\n  Back: \
Object.freeze({\n    In: function(amount) {\n      var s = 1.70158;\n      \
return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);\n    },\n \
   Out: function(amount) {\n      var s = 1.70158;\n      return amount === 0 \
? 0 : --amount * amount * ((s + 1) * amount + s) + 1;\n    },\n    InOut: \
function(amount) {\n      var s = 1.70158 * 1.525;\n      if ((amount *= 2) < \
1) {\n        return 0.5 * (amount * amount * ((s + 1) * amount - s));\n      \
}\n      return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + \
2);\n    }\n  }),\n  Bounce: Object.freeze({\n    In: function(amount) {\n    \
  return 1 - Easing.Bounce.Out(1 - amount);\n    },\n    Out: \
function(amount) {\n      if (amount < 1 / 2.75) {\n        return 7.5625 * \
amount * amount;\n      } else if (amount < 2 / 2.75) {\n        return \
7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n      } else if (amount < \
2.5 / 2.75) {\n        return 7.5625 * (amount -= 2.25 / 2.75) * amount + \
0.9375;\n      } else {\n        return 7.5625 * (amount -= 2.625 / 2.75) * \
amount + 0.984375;\n      }\n    },\n    InOut: function(amount) {\n      if \
(amount < 0.5) {\n        return Easing.Bounce.In(amount * 2) * 0.5;\n      \
}\n      return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n    }\n  \
}),\n  generatePow: function(power) {\n    if (power === void 0) {\n      \
power = 4;\n    }\n    power = power < Number.EPSILON ? Number.EPSILON : \
power;\n    power = power > 1e4 ? 1e4 : power;\n    return {\n      In: \
function(amount) {\n        return Math.pow(amount, power);\n      },\n      \
Out: function(amount) {\n        return 1 - Math.pow(1 - amount, power);\n    \
  },\n      InOut: function(amount) {\n        if (amount < 0.5) {\n          \
return Math.pow(amount * 2, power) / 2;\n        }\n        return (1 - \
Math.pow(2 - amount * 2, power)) / 2 + 0.5;\n      }\n    };\n  }\n});\nvar \
now4 = function() {\n  return performance.now();\n};\nvar Group2 = (\n  /** \
@class */\n  function() {\n    function Group3() {\n      var tweens = [];\n  \
    for (var _i = 0; _i < arguments.length; _i++) {\n        tweens[_i] = \
arguments[_i];\n      }\n      this._tweens = {};\n      \
this._tweensAddedDuringUpdate = {};\n      this.add.apply(this, tweens);\n    \
}\n    Group3.prototype.getAll = function() {\n      var _this = this;\n      \
return Object.keys(this._tweens).map(function(tweenId) {\n        return \
_this._tweens[tweenId];\n      });\n    };\n    Group3.prototype.removeAll = \
function() {\n      this._tweens = {};\n    };\n    Group3.prototype.add = \
function() {\n      var _a;\n      var tweens = [];\n      for (var _i = 0; \
_i < arguments.length; _i++) {\n        tweens[_i] = arguments[_i];\n      \
}\n      for (var _b = 0, tweens_1 = tweens; _b < tweens_1.length; _b++) {\n  \
      var tween = tweens_1[_b];\n        (_a = tween._group) === null || _a \
=== void 0 ? void 0 : _a.remove(tween);\n        tween._group = this;\n       \
 this._tweens[tween.getId()] = tween;\n        \
this._tweensAddedDuringUpdate[tween.getId()] = tween;\n      }\n    };\n    \
Group3.prototype.remove = function() {\n      var tweens = [];\n      for \
(var _i = 0; _i < arguments.length; _i++) {\n        tweens[_i] = \
arguments[_i];\n      }\n      for (var _a = 0, tweens_2 = tweens; _a < \
tweens_2.length; _a++) {\n        var tween = tweens_2[_a];\n        \
tween._group = void 0;\n        delete this._tweens[tween.getId()];\n        \
delete this._tweensAddedDuringUpdate[tween.getId()];\n      }\n    };\n    \
Group3.prototype.allStopped = function() {\n      return \
this.getAll().every(function(tween) {\n        return !tween.isPlaying();\n   \
   });\n    };\n    Group3.prototype.update = function(time, preserve) {\n    \
  if (time === void 0) {\n        time = now4();\n      }\n      if (preserve \
=== void 0) {\n        preserve = true;\n      }\n      var tweenIds = \
Object.keys(this._tweens);\n      if (tweenIds.length === 0)\n        \
return;\n      while (tweenIds.length > 0) {\n        \
this._tweensAddedDuringUpdate = {};\n        for (var i = 0; i < \
tweenIds.length; i++) {\n          var tween = this._tweens[tweenIds[i]];\n   \
       var autoStart = !preserve;\n          if (tween && tween.update(time, \
autoStart) === false && !preserve)\n            this.remove(tween);\n        \
}\n        tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n      }\n  \
  };\n    return Group3;\n  }()\n);\nvar Interpolation = {\n  Linear: \
function(v, k) {\n    var m2 = v.length - 1;\n    var f = m2 * k;\n    var i \
= Math.floor(f);\n    var fn = Interpolation.Utils.Linear;\n    if (k < 0) \
{\n      return fn(v[0], v[1], f);\n    }\n    if (k > 1) {\n      return \
fn(v[m2], v[m2 - 1], m2 - f);\n    }\n    return fn(v[i], v[i + 1 > m2 ? m2 : \
i + 1], f - i);\n  },\n  Bezier: function(v, k) {\n    var b = 0;\n    var n \
= v.length - 1;\n    var pw = Math.pow;\n    var bn = \
Interpolation.Utils.Bernstein;\n    for (var i = 0; i <= n; i++) {\n      b \
+= pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n    }\n    return b;\n  \
},\n  CatmullRom: function(v, k) {\n    var m2 = v.length - 1;\n    var f = \
m2 * k;\n    var i = Math.floor(f);\n    var fn = \
Interpolation.Utils.CatmullRom;\n    if (v[0] === v[m2]) {\n      if (k < 0) \
{\n        i = Math.floor(f = m2 * (1 + k));\n      }\n      return fn(v[(i - \
1 + m2) % m2], v[i], v[(i + 1) % m2], v[(i + 2) % m2], f - i);\n    } else \
{\n      if (k < 0) {\n        return v[0] - (fn(v[0], v[0], v[1], v[1], -f) \
- v[0]);\n      }\n      if (k > 1) {\n        return v[m2] - (fn(v[m2], \
v[m2], v[m2 - 1], v[m2 - 1], f - m2) - v[m2]);\n      }\n      return fn(v[i \
? i - 1 : 0], v[i], v[m2 < i + 1 ? m2 : i + 1], v[m2 < i + 2 ? m2 : i + 2], f \
- i);\n    }\n  },\n  Utils: {\n    Linear: function(p0, p1, t) {\n      \
return (p1 - p0) * t + p0;\n    },\n    Bernstein: function(n, i) {\n      \
var fc = Interpolation.Utils.Factorial;\n      return fc(n) / fc(i) / fc(n - \
i);\n    },\n    Factorial: /* @__PURE__ */ function() {\n      var a2 = \
[1];\n      return function(n) {\n        var s = 1;\n        if (a2[n]) {\n  \
        return a2[n];\n        }\n        for (var i = n; i > 1; i--) {\n     \
     s *= i;\n        }\n        a2[n] = s;\n        return s;\n      };\n    \
}(),\n    CatmullRom: function(p0, p1, p2, p3, t) {\n      var v0 = (p2 - p0) \
* 0.5;\n      var v1 = (p3 - p1) * 0.5;\n      var t2 = t * t;\n      var t3 \
= t * t2;\n      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 \
- 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n  }\n};\nvar Sequence = (\n  /** \
@class */\n  function() {\n    function Sequence2() {\n    }\n    \
Sequence2.nextId = function() {\n      return Sequence2._nextId++;\n    };\n  \
  Sequence2._nextId = 0;\n    return Sequence2;\n  }()\n);\nvar mainGroup = \
new Group2();\nvar Tween = (\n  /** @class */\n  function() {\n    function \
Tween2(object, group) {\n      this._isPaused = false;\n      \
this._pauseStart = 0;\n      this._valuesStart = {};\n      this._valuesEnd = \
{};\n      this._valuesStartRepeat = {};\n      this._duration = 1e3;\n      \
this._isDynamic = false;\n      this._initialRepeat = 0;\n      this._repeat \
= 0;\n      this._yoyo = false;\n      this._isPlaying = false;\n      \
this._reversed = false;\n      this._delayTime = 0;\n      this._startTime = \
0;\n      this._easingFunction = Easing.Linear.None;\n      \
this._interpolationFunction = Interpolation.Linear;\n      \
this._chainedTweens = [];\n      this._onStartCallbackFired = false;\n      \
this._onEveryStartCallbackFired = false;\n      this._id = \
Sequence.nextId();\n      this._isChainStopped = false;\n      \
this._propertiesAreSetUp = false;\n      this._goToEnd = false;\n      \
this._object = object;\n      if (typeof group === \"object\") {\n        \
this._group = group;\n        group.add(this);\n      } else if (group === \
true) {\n        this._group = mainGroup;\n        mainGroup.add(this);\n     \
 }\n    }\n    Tween2.prototype.getId = function() {\n      return \
this._id;\n    };\n    Tween2.prototype.isPlaying = function() {\n      \
return this._isPlaying;\n    };\n    Tween2.prototype.isPaused = function() \
{\n      return this._isPaused;\n    };\n    Tween2.prototype.getDuration = \
function() {\n      return this._duration;\n    };\n    Tween2.prototype.to = \
function(target, duration) {\n      if (duration === void 0) {\n        \
duration = 1e3;\n      }\n      if (this._isPlaying)\n        throw new \
Error(\"Can not call Tween.to() while Tween is already started or paused. \
Stop the Tween first.\");\n      this._valuesEnd = target;\n      \
this._propertiesAreSetUp = false;\n      this._duration = duration < 0 ? 0 : \
duration;\n      return this;\n    };\n    Tween2.prototype.duration = \
function(duration) {\n      if (duration === void 0) {\n        duration = \
1e3;\n      }\n      this._duration = duration < 0 ? 0 : duration;\n      \
return this;\n    };\n    Tween2.prototype.dynamic = function(dynamic) {\n    \
  if (dynamic === void 0) {\n        dynamic = false;\n      }\n      \
this._isDynamic = dynamic;\n      return this;\n    };\n    \
Tween2.prototype.start = function(time, overrideStartingValues) {\n      if \
(time === void 0) {\n        time = now4();\n      }\n      if \
(overrideStartingValues === void 0) {\n        overrideStartingValues = \
false;\n      }\n      if (this._isPlaying) {\n        return this;\n      \
}\n      this._repeat = this._initialRepeat;\n      if (this._reversed) {\n   \
     this._reversed = false;\n        for (var property2 in \
this._valuesStartRepeat) {\n          \
this._swapEndStartRepeatValues(property2);\n          \
this._valuesStart[property2] = this._valuesStartRepeat[property2];\n        \
}\n      }\n      this._isPlaying = true;\n      this._isPaused = false;\n    \
  this._onStartCallbackFired = false;\n      this._onEveryStartCallbackFired \
= false;\n      this._isChainStopped = false;\n      this._startTime = \
time;\n      this._startTime += this._delayTime;\n      if \
(!this._propertiesAreSetUp || overrideStartingValues) {\n        \
this._propertiesAreSetUp = true;\n        if (!this._isDynamic) {\n          \
var tmp2 = {};\n          for (var prop in this._valuesEnd)\n            \
tmp2[prop] = this._valuesEnd[prop];\n          this._valuesEnd = tmp2;\n      \
  }\n        this._setupProperties(this._object, this._valuesStart, \
this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);\n      }\n \
     return this;\n    };\n    Tween2.prototype.startFromCurrentValues = \
function(time) {\n      return this.start(time, true);\n    };\n    \
Tween2.prototype._setupProperties = function(_object, _valuesStart, \
_valuesEnd, _valuesStartRepeat, overrideStartingValues) {\n      for (var \
property2 in _valuesEnd) {\n        var startValue = _object[property2];\n    \
    var startValueIsArray = Array.isArray(startValue);\n        var propType \
= startValueIsArray ? \"array\" : typeof startValue;\n        var \
isInterpolationList = !startValueIsArray && \
Array.isArray(_valuesEnd[property2]);\n        if (propType === \"undefined\" \
|| propType === \"function\") {\n          continue;\n        }\n        if \
(isInterpolationList) {\n          var endValues = _valuesEnd[property2];\n   \
       if (endValues.length === 0) {\n            continue;\n          }\n    \
      var temp2 = [startValue];\n          for (var i = 0, l = \
endValues.length; i < l; i += 1) {\n            var value = \
this._handleRelativeValue(startValue, endValues[i]);\n            if \
(isNaN(value)) {\n              isInterpolationList = false;\n              \
console.warn(\"Found invalid interpolation list. Skipping.\");\n              \
break;\n            }\n            temp2.push(value);\n          }\n          \
if (isInterpolationList) {\n            _valuesEnd[property2] = temp2;\n      \
    }\n        }\n        if ((propType === \"object\" || startValueIsArray) \
&& startValue && !isInterpolationList) {\n          _valuesStart[property2] = \
startValueIsArray ? [] : {};\n          var nestedObject = startValue;\n      \
    for (var prop in nestedObject) {\n            \
_valuesStart[property2][prop] = nestedObject[prop];\n          }\n          \
_valuesStartRepeat[property2] = startValueIsArray ? [] : {};\n          var \
endValues = _valuesEnd[property2];\n          if (!this._isDynamic) {\n       \
     var tmp2 = {};\n            for (var prop in endValues)\n              \
tmp2[prop] = endValues[prop];\n            _valuesEnd[property2] = endValues \
= tmp2;\n          }\n          this._setupProperties(nestedObject, \
_valuesStart[property2], endValues, _valuesStartRepeat[property2], \
overrideStartingValues);\n        } else {\n          if (typeof \
_valuesStart[property2] === \"undefined\" || overrideStartingValues) {\n      \
      _valuesStart[property2] = startValue;\n          }\n          if \
(!startValueIsArray) {\n            _valuesStart[property2] *= 1;\n          \
}\n          if (isInterpolationList) {\n            \
_valuesStartRepeat[property2] = _valuesEnd[property2].slice().reverse();\n    \
      } else {\n            _valuesStartRepeat[property2] = \
_valuesStart[property2] || 0;\n          }\n        }\n      }\n    };\n    \
Tween2.prototype.stop = function() {\n      if (!this._isChainStopped) {\n    \
    this._isChainStopped = true;\n        this.stopChainedTweens();\n      \
}\n      if (!this._isPlaying) {\n        return this;\n      }\n      \
this._isPlaying = false;\n      this._isPaused = false;\n      if \
(this._onStopCallback) {\n        this._onStopCallback(this._object);\n      \
}\n      return this;\n    };\n    Tween2.prototype.end = function() {\n      \
this._goToEnd = true;\n      this.update(this._startTime + this._duration);\n \
     return this;\n    };\n    Tween2.prototype.pause = function(time) {\n    \
  if (time === void 0) {\n        time = now4();\n      }\n      if \
(this._isPaused || !this._isPlaying) {\n        return this;\n      }\n      \
this._isPaused = true;\n      this._pauseStart = time;\n      return this;\n  \
  };\n    Tween2.prototype.resume = function(time) {\n      if (time === void \
0) {\n        time = now4();\n      }\n      if (!this._isPaused || \
!this._isPlaying) {\n        return this;\n      }\n      this._isPaused = \
false;\n      this._startTime += time - this._pauseStart;\n      \
this._pauseStart = 0;\n      return this;\n    };\n    \
Tween2.prototype.stopChainedTweens = function() {\n      for (var i = 0, \
numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n \
       this._chainedTweens[i].stop();\n      }\n      return this;\n    };\n  \
  Tween2.prototype.group = function(group) {\n      if (!group) {\n        \
console.warn(\"tween.group() without args has been removed, use \
group.add(tween) instead.\");\n        return this;\n      }\n      \
group.add(this);\n      return this;\n    };\n    Tween2.prototype.remove = \
function() {\n      var _a;\n      (_a = this._group) === null || _a === void \
0 ? void 0 : _a.remove(this);\n      return this;\n    };\n    \
Tween2.prototype.delay = function(amount) {\n      if (amount === void 0) {\n \
       amount = 0;\n      }\n      this._delayTime = amount;\n      return \
this;\n    };\n    Tween2.prototype.repeat = function(times) {\n      if \
(times === void 0) {\n        times = 0;\n      }\n      this._initialRepeat \
= times;\n      this._repeat = times;\n      return this;\n    };\n    \
Tween2.prototype.repeatDelay = function(amount) {\n      \
this._repeatDelayTime = amount;\n      return this;\n    };\n    \
Tween2.prototype.yoyo = function(yoyo) {\n      if (yoyo === void 0) {\n      \
  yoyo = false;\n      }\n      this._yoyo = yoyo;\n      return this;\n    \
};\n    Tween2.prototype.easing = function(easingFunction) {\n      if \
(easingFunction === void 0) {\n        easingFunction = Easing.Linear.None;\n \
     }\n      this._easingFunction = easingFunction;\n      return this;\n    \
};\n    Tween2.prototype.interpolation = function(interpolationFunction) {\n  \
    if (interpolationFunction === void 0) {\n        interpolationFunction = \
Interpolation.Linear;\n      }\n      this._interpolationFunction = \
interpolationFunction;\n      return this;\n    };\n    \
Tween2.prototype.chain = function() {\n      var tweens = [];\n      for (var \
_i = 0; _i < arguments.length; _i++) {\n        tweens[_i] = arguments[_i];\n \
     }\n      this._chainedTweens = tweens;\n      return this;\n    };\n    \
Tween2.prototype.onStart = function(callback) {\n      this._onStartCallback \
= callback;\n      return this;\n    };\n    Tween2.prototype.onEveryStart = \
function(callback) {\n      this._onEveryStartCallback = callback;\n      \
return this;\n    };\n    Tween2.prototype.onUpdate = function(callback) {\n  \
    this._onUpdateCallback = callback;\n      return this;\n    };\n    \
Tween2.prototype.onRepeat = function(callback) {\n      \
this._onRepeatCallback = callback;\n      return this;\n    };\n    \
Tween2.prototype.onComplete = function(callback) {\n      \
this._onCompleteCallback = callback;\n      return this;\n    };\n    \
Tween2.prototype.onStop = function(callback) {\n      this._onStopCallback = \
callback;\n      return this;\n    };\n    Tween2.prototype.update = \
function(time, autoStart) {\n      var _this = this;\n      var _a;\n      if \
(time === void 0) {\n        time = now4();\n      }\n      if (autoStart === \
void 0) {\n        autoStart = Tween2.autoStartOnUpdate;\n      }\n      if \
(this._isPaused)\n        return true;\n      var property2;\n      if \
(!this._goToEnd && !this._isPlaying) {\n        if (autoStart)\n          \
this.start(time, true);\n        else\n          return false;\n      }\n     \
 this._goToEnd = false;\n      if (time < this._startTime) {\n        return \
true;\n      }\n      if (this._onStartCallbackFired === false) {\n        if \
(this._onStartCallback) {\n          this._onStartCallback(this._object);\n   \
     }\n        this._onStartCallbackFired = true;\n      }\n      if \
(this._onEveryStartCallbackFired === false) {\n        if \
(this._onEveryStartCallback) {\n          \
this._onEveryStartCallback(this._object);\n        }\n        \
this._onEveryStartCallbackFired = true;\n      }\n      var elapsedTime = \
time - this._startTime;\n      var durationAndDelay = this._duration + ((_a = \
this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);\n   \
   var totalTime = this._duration + this._repeat * durationAndDelay;\n      \
var calculateElapsedPortion = function() {\n        if (_this._duration === \
0)\n          return 1;\n        if (elapsedTime > totalTime) {\n          \
return 1;\n        }\n        var timesRepeated = Math.trunc(elapsedTime / \
durationAndDelay);\n        var timeIntoCurrentRepeat = elapsedTime - \
timesRepeated * durationAndDelay;\n        var portion = \
Math.min(timeIntoCurrentRepeat / _this._duration, 1);\n        if (portion \
=== 0 && elapsedTime === _this._duration) {\n          return 1;\n        }\n \
       return portion;\n      };\n      var elapsed = \
calculateElapsedPortion();\n      var value = \
this._easingFunction(elapsed);\n      this._updateProperties(this._object, \
this._valuesStart, this._valuesEnd, value);\n      if \
(this._onUpdateCallback) {\n        this._onUpdateCallback(this._object, \
elapsed);\n      }\n      if (this._duration === 0 || elapsedTime >= \
this._duration) {\n        if (this._repeat > 0) {\n          var \
completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / \
durationAndDelay) + 1, this._repeat);\n          if (isFinite(this._repeat)) \
{\n            this._repeat -= completeCount;\n          }\n          for \
(property2 in this._valuesStartRepeat) {\n            if (!this._yoyo && \
typeof this._valuesEnd[property2] === \"string\") {\n              \
this._valuesStartRepeat[property2] = // eslint-disable-next-line\n            \
  // @ts-ignore FIXME?\n              this._valuesStartRepeat[property2] + \
parseFloat(this._valuesEnd[property2]);\n            }\n            if \
(this._yoyo) {\n              this._swapEndStartRepeatValues(property2);\n    \
        }\n            this._valuesStart[property2] = \
this._valuesStartRepeat[property2];\n          }\n          if (this._yoyo) \
{\n            this._reversed = !this._reversed;\n          }\n          \
this._startTime += durationAndDelay * completeCount;\n          if \
(this._onRepeatCallback) {\n            \
this._onRepeatCallback(this._object);\n          }\n          \
this._onEveryStartCallbackFired = false;\n          return true;\n        } \
else {\n          if (this._onCompleteCallback) {\n            \
this._onCompleteCallback(this._object);\n          }\n          for (var i = \
0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) \
{\n            this._chainedTweens[i].start(this._startTime + this._duration, \
false);\n          }\n          this._isPlaying = false;\n          return \
false;\n        }\n      }\n      return true;\n    };\n    \
Tween2.prototype._updateProperties = function(_object, _valuesStart, \
_valuesEnd, value) {\n      for (var property2 in _valuesEnd) {\n        if \
(_valuesStart[property2] === void 0) {\n          continue;\n        }\n      \
  var start = _valuesStart[property2] || 0;\n        var end = \
_valuesEnd[property2];\n        var startIsArray = \
Array.isArray(_object[property2]);\n        var endIsArray = \
Array.isArray(end);\n        var isInterpolationList = !startIsArray && \
endIsArray;\n        if (isInterpolationList) {\n          _object[property2] \
= this._interpolationFunction(end, value);\n        } else if (typeof end === \
\"object\" && end) {\n          this._updateProperties(_object[property2], \
start, end, value);\n        } else {\n          end = \
this._handleRelativeValue(start, end);\n          if (typeof end === \
\"number\") {\n            _object[property2] = start + (end - start) * \
value;\n          }\n        }\n      }\n    };\n    \
Tween2.prototype._handleRelativeValue = function(start, end) {\n      if \
(typeof end !== \"string\") {\n        return end;\n      }\n      if \
(end.charAt(0) === \"+\" || end.charAt(0) === \"-\") {\n        return start \
+ parseFloat(end);\n      }\n      return parseFloat(end);\n    };\n    \
Tween2.prototype._swapEndStartRepeatValues = function(property2) {\n      var \
tmp2 = this._valuesStartRepeat[property2];\n      var endValue = \
this._valuesEnd[property2];\n      if (typeof endValue === \"string\") {\n    \
    this._valuesStartRepeat[property2] = this._valuesStartRepeat[property2] + \
parseFloat(endValue);\n      } else {\n        \
this._valuesStartRepeat[property2] = this._valuesEnd[property2];\n      }\n   \
   this._valuesEnd[property2] = tmp2;\n    };\n    Tween2.autoStartOnUpdate = \
false;\n    return Tween2;\n  }()\n);\nvar nextId = Sequence.nextId;\nvar \
TWEEN = mainGroup;\nvar getAll = TWEEN.getAll.bind(TWEEN);\nvar removeAll4 = \
TWEEN.removeAll.bind(TWEEN);\nvar add5 = TWEEN.add.bind(TWEEN);\nvar remove = \
TWEEN.remove.bind(TWEEN);\nvar update2 = TWEEN.update.bind(TWEEN);\n\n// \
../../node_modules/three-render-objects/dist/three-render-objects.mjs\nfuncti\
on styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = \
ref.insertAt;\n  if (typeof document === \"undefined\") {\n    return;\n  }\n \
 var head = document.head || document.getElementsByTagName(\"head\")[0];\n  \
var style = document.createElement(\"style\");\n  style.type = \
\"text/css\";\n  if (insertAt === \"top\") {\n    if (head.firstChild) {\n    \
  head.insertBefore(style, head.firstChild);\n    } else {\n      \
head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  \
}\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else \
{\n    style.appendChild(document.createTextNode(css));\n  }\n}\nvar css_248z \
= \".scene-nav-info {\\n  bottom: 5px;\\n  width: 100%;\\n  text-align: \
center;\\n  color: slategrey;\\n  opacity: 0.7;\\n  font-size: \
10px;\\n}\\n\\n.scene-tooltip {\\n  top: 0;\\n  color: lavender;\\n  \
font-size: 15px;\\n}\\n\\n.scene-nav-info, .scene-tooltip {\\n  position: \
absolute;\\n  font-family: sans-serif;\\n  pointer-events: none;\\n  \
user-select: none;\\n}\\n\\n.scene-container canvas:focus {\\n  outline: \
none;\\n}\";\nstyleInject(css_248z);\nfunction _arrayLikeToArray5(r, a2) {\n  \
(null == a2 || a2 > r.length) && (a2 = r.length);\n  for (var e = 0, n = \
Array(a2); e < a2; e++) n[e] = r[e];\n  return n;\n}\nfunction \
_arrayWithHoles5(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction \
_arrayWithoutHoles4(r) {\n  if (Array.isArray(r)) return \
_arrayLikeToArray5(r);\n}\nfunction _defineProperty3(e, r, t) {\n  return (r \
= _toPropertyKey4(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n   \
 enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] \
= t, e;\n}\nfunction _iterableToArray4(r) {\n  if (\"undefined\" != typeof \
Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return \
Array.from(r);\n}\nfunction _iterableToArrayLimit5(r, l) {\n  var t = null == \
r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || \
r[\"@@iterator\"];\n  if (null != t) {\n    var e, n, i, u, a2 = [], f = \
true, o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ;\n \
     else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length \
!== l); f = true) ;\n    } catch (r2) {\n      o = true, n = r2;\n    } \
finally {\n      try {\n        if (!f && null != t.return && (u = \
t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) \
throw n;\n      }\n    }\n    return a2;\n  }\n}\nfunction \
_nonIterableRest5() {\n  throw new TypeError(\"Invalid attempt to destructure \
non-iterable instance.\\nIn order to be iterable, non-array objects must have \
a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread4() {\n  \
throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn \
order to be iterable, non-array objects must have a [Symbol.iterator]() \
method.\");\n}\nfunction _slicedToArray5(r, e) {\n  return \
_arrayWithHoles5(r) || _iterableToArrayLimit5(r, e) || \
_unsupportedIterableToArray5(r, e) || _nonIterableRest5();\n}\nfunction \
_toConsumableArray4(r) {\n  return _arrayWithoutHoles4(r) || \
_iterableToArray4(r) || _unsupportedIterableToArray5(r) || \
_nonIterableSpread4();\n}\nfunction _toPrimitive4(t, r) {\n  if (\"object\" \
!= typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 \
!== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != \
typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (\"string\" === r ? String : \
Number)(t);\n}\nfunction _toPropertyKey4(t) {\n  var i = _toPrimitive4(t, \
\"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction \
_unsupportedIterableToArray5(r, a2) {\n  if (r) {\n    if (\"string\" == \
typeof r) return _arrayLikeToArray5(r, a2);\n    var t = \
{}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && \
r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? \
Array.from(r) : \"Arguments\" === t || \
/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray5(r, \
a2) : void 0;\n  }\n}\nvar three2 = window.THREE ? window.THREE : {\n  \
WebGLRenderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \
SRGBColorSpace,\n  TextureLoader,\n  Vector2,\n  Vector3,\n  Box3,\n  \
Color,\n  Mesh,\n  SphereGeometry,\n  MeshBasicMaterial,\n  BackSide,\n  \
EventDispatcher,\n  MOUSE,\n  Quaternion,\n  Spherical,\n  Clock\n};\nvar \
threeRenderObjects = index2({\n  props: {\n    width: {\n      \"default\": \
window.innerWidth,\n      onChange: function onChange8(width, state, \
prevWidth) {\n        isNaN(width) && (state.width = prevWidth);\n      }\n   \
 },\n    height: {\n      \"default\": window.innerHeight,\n      onChange: \
function onChange9(height, state, prevHeight) {\n        isNaN(height) && \
(state.height = prevHeight);\n      }\n    },\n    backgroundColor: {\n      \
\"default\": \"#000011\"\n    },\n    backgroundImageUrl: {},\n    \
onBackgroundImageLoaded: {},\n    showNavInfo: {\n      \"default\": true\n   \
 },\n    skyRadius: {\n      \"default\": 5e4\n    },\n    objects: {\n      \
\"default\": []\n    },\n    lights: {\n      \"default\": []\n    },\n    \
enablePointerInteraction: {\n      \"default\": true,\n      onChange: \
function onChange10(_, state) {\n        state.hoverObj = null;\n        if \
(state.toolTipElem) state.toolTipElem.innerHTML = \"\";\n      },\n      \
triggerUpdate: false\n    },\n    lineHoverPrecision: {\n      \"default\": \
1,\n      triggerUpdate: false\n    },\n    hoverOrderComparator: {\n      \
\"default\": function _default8() {\n        return -1;\n      },\n      \
triggerUpdate: false\n    },\n    // keep existing order by default\n    \
hoverFilter: {\n      \"default\": function _default9() {\n        return \
true;\n      },\n      triggerUpdate: false\n    },\n    // exclude objects \
from interaction\n    tooltipContent: {\n      triggerUpdate: false\n    },\n \
   hoverDuringDrag: {\n      \"default\": false,\n      triggerUpdate: \
false\n    },\n    clickAfterDrag: {\n      \"default\": false,\n      \
triggerUpdate: false\n    },\n    onHover: {\n      \"default\": function \
_default10() {\n      },\n      triggerUpdate: false\n    },\n    onClick: \
{\n      \"default\": function _default11() {\n      },\n      triggerUpdate: \
false\n    },\n    onRightClick: {\n      triggerUpdate: false\n    }\n  },\n \
 methods: {\n    tick: function tick(state) {\n      if (state.initialised) \
{\n        state.controls.update && state.controls.update(Math.min(1, \
state.clock.getDelta()));\n        state.postProcessingComposer ? \
state.postProcessingComposer.render() : state.renderer.render(state.scene, \
state.camera);\n        state.extraRenderers.forEach(function(r) {\n          \
return r.render(state.scene, state.camera);\n        });\n        if \
(state.enablePointerInteraction) {\n          var topObject = null;\n         \
 if (state.hoverDuringDrag || !state.isPointerDragging) {\n            var \
intersects = this.intersectingObjects(state.pointerPos.x, \
state.pointerPos.y).filter(function(d) {\n              return \
state.hoverFilter(d.object);\n            }).sort(function(a2, b) {\n         \
     return state.hoverOrderComparator(a2.object, b.object);\n            \
});\n            var topIntersect = intersects.length ? intersects[0] : \
null;\n            topObject = topIntersect ? topIntersect.object : null;\n   \
         state.intersectionPoint = topIntersect ? topIntersect.point : \
null;\n          }\n          if (topObject !== state.hoverObj) {\n           \
 state.onHover(topObject, state.hoverObj);\n            \
state.toolTipElem.innerHTML = topObject ? \
index3(state.tooltipContent)(topObject) || \"\" : \"\";\n            \
state.hoverObj = topObject;\n          }\n        }\n        \
state.tweenGroup.update();\n      }\n      return this;\n    },\n    \
getPointerPos: function getPointerPos(state) {\n      var _state$pointerPos = \
state.pointerPos, x2 = _state$pointerPos.x, y2 = _state$pointerPos.y;\n      \
return {\n        x: x2,\n        y: y2\n      };\n    },\n    \
cameraPosition: function cameraPosition2(state, position, lookAt, \
transitionDuration) {\n      var camera3 = state.camera;\n      if (position \
&& state.initialised) {\n        var finalPos = position;\n        var \
finalLookAt = lookAt || {\n          x: 0,\n          y: 0,\n          z: 0\n \
       };\n        if (!transitionDuration) {\n          \
setCameraPos(finalPos);\n          setLookAt(finalLookAt);\n        } else \
{\n          var camPos = Object.assign({}, camera3.position);\n          var \
camLookAt = getLookAt();\n          state.tweenGroup.add(new \
Tween(camPos).to(finalPos, \
transitionDuration).easing(Easing.Quadratic.Out).onUpdate(setCameraPos).start\
());\n          state.tweenGroup.add(new Tween(camLookAt).to(finalLookAt, \
transitionDuration / \
3).easing(Easing.Quadratic.Out).onUpdate(setLookAt).start());\n        }\n    \
    return this;\n      }\n      return Object.assign({}, camera3.position, \
{\n        lookAt: getLookAt()\n      });\n      function setCameraPos(pos) \
{\n        var x2 = pos.x, y2 = pos.y, z2 = pos.z;\n        if (x2 !== void \
0) camera3.position.x = x2;\n        if (y2 !== void 0) camera3.position.y = \
y2;\n        if (z2 !== void 0) camera3.position.z = z2;\n      }\n      \
function setLookAt(lookAt2) {\n        var lookAtVect = new \
three2.Vector3(lookAt2.x, lookAt2.y, lookAt2.z);\n        if \
(state.controls.target) {\n          state.controls.target = lookAtVect;\n    \
    } else {\n          camera3.lookAt(lookAtVect);\n        }\n      }\n     \
 function getLookAt() {\n        return Object.assign(new three2.Vector3(0, \
0, -1e3).applyQuaternion(camera3.quaternion).add(camera3.position));\n      \
}\n    },\n    zoomToFit: function zoomToFit(state) {\n      var \
transitionDuration = arguments.length > 1 && arguments[1] !== void 0 ? \
arguments[1] : 0;\n      var padding = arguments.length > 2 && arguments[2] \
!== void 0 ? arguments[2] : 10;\n      for (var _len = arguments.length, \
bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) \
{\n        bboxArgs[_key - 3] = arguments[_key];\n      }\n      return \
this.fitToBbox(this.getBbox.apply(this, bboxArgs), transitionDuration, \
padding);\n    },\n    fitToBbox: function fitToBbox(state, bbox) {\n      \
var transitionDuration = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : 0;\n      var padding = arguments.length > 3 && arguments[3] \
!== void 0 ? arguments[3] : 10;\n      var camera3 = state.camera;\n      if \
(bbox) {\n        var center = new three2.Vector3(0, 0, 0);\n        var \
maxBoxSide = Math.max.apply(Math, \
_toConsumableArray4(Object.entries(bbox).map(function(_ref) {\n          var \
_ref2 = _slicedToArray5(_ref, 2), coordType = _ref2[0], coords = _ref2[1];\n  \
        return Math.max.apply(Math, \
_toConsumableArray4(coords.map(function(c2) {\n            return \
Math.abs(center[coordType] - c2);\n          })));\n        }))) * 2;\n       \
 var paddedFov = (1 - padding * 2 / state.height) * camera3.fov;\n        var \
fitHeightDistance = maxBoxSide / Math.atan(paddedFov * Math.PI / 180);\n      \
  var fitWidthDistance = fitHeightDistance / camera3.aspect;\n        var \
distance2 = Math.max(fitHeightDistance, fitWidthDistance);\n        if \
(distance2 > 0) {\n          var newCameraPosition = \
center.clone().sub(camera3.position).normalize().multiplyScalar(-distance2);\
\n          this.cameraPosition(newCameraPosition, center, \
transitionDuration);\n        }\n      }\n      return this;\n    },\n    \
getBbox: function getBbox(state) {\n      var objFilter = arguments.length > \
1 && arguments[1] !== void 0 ? arguments[1] : function() {\n        return \
true;\n      };\n      var box = new three2.Box3(new three2.Vector3(0, 0, 0), \
new three2.Vector3(0, 0, 0));\n      var objs = \
state.objects.filter(objFilter);\n      if (!objs.length) return null;\n      \
objs.forEach(function(obj) {\n        return box.expandByObject(obj);\n      \
});\n      return Object.assign.apply(Object, _toConsumableArray4([\"x\", \
\"y\", \"z\"].map(function(c2) {\n        return _defineProperty3({}, c2, \
[box.min[c2], box.max[c2]]);\n      })));\n    },\n    getScreenCoords: \
function getScreenCoords(state, x2, y2, z2) {\n      var vec = new \
three2.Vector3(x2, y2, z2);\n      vec.project(this.camera());\n      return \
{\n        // align relative pos to canvas dimensions\n        x: (vec.x + 1) \
* state.width / 2,\n        y: -(vec.y - 1) * state.height / 2\n      };\n    \
},\n    getSceneCoords: function getSceneCoords(state, screenX, screenY) {\n  \
    var distance2 = arguments.length > 3 && arguments[3] !== void 0 ? \
arguments[3] : 0;\n      var relCoords = new three2.Vector2(screenX / \
state.width * 2 - 1, -(screenY / state.height) * 2 + 1);\n      var raycaster \
= new three2.Raycaster();\n      raycaster.setFromCamera(relCoords, \
state.camera);\n      return Object.assign({}, raycaster.ray.at(distance2, \
new three2.Vector3()));\n    },\n    intersectingObjects: function \
intersectingObjects(state, x2, y2) {\n      var relCoords = new \
three2.Vector2(x2 / state.width * 2 - 1, -(y2 / state.height) * 2 + 1);\n     \
 var raycaster = new three2.Raycaster();\n      \
raycaster.params.Line.threshold = state.lineHoverPrecision;\n      \
raycaster.setFromCamera(relCoords, state.camera);\n      return \
raycaster.intersectObjects(state.objects, true);\n    },\n    renderer: \
function renderer(state) {\n      return state.renderer;\n    },\n    scene: \
function scene(state) {\n      return state.scene;\n    },\n    camera: \
function camera(state) {\n      return state.camera;\n    },\n    \
postProcessingComposer: function postProcessingComposer(state) {\n      \
return state.postProcessingComposer;\n    },\n    controls: function \
controls(state) {\n      return state.controls;\n    },\n    tbControls: \
function tbControls(state) {\n      return state.controls;\n    }\n    // to \
be deprecated\n  },\n  stateInit: function stateInit2() {\n    return {\n     \
 scene: new three2.Scene(),\n      camera: new three2.PerspectiveCamera(),\n  \
    clock: new three2.Clock(),\n      tweenGroup: new Group2()\n    };\n  \
},\n  init: function init2(domNode, state) {\n    var _ref4 = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, \
_ref4$controlType = _ref4.controlType, controlType = _ref4$controlType === \
void 0 ? \"trackball\" : _ref4$controlType, _ref4$useWebGPU = \
_ref4.useWebGPU, useWebGPU = _ref4$useWebGPU === void 0 ? false : \
_ref4$useWebGPU, _ref4$rendererConfig = _ref4.rendererConfig, rendererConfig \
= _ref4$rendererConfig === void 0 ? {} : _ref4$rendererConfig, \
_ref4$extraRenderers = _ref4.extraRenderers, extraRenderers = \
_ref4$extraRenderers === void 0 ? [] : _ref4$extraRenderers, \
_ref4$waitForLoadComp = _ref4.waitForLoadComplete, waitForLoadComplete = \
_ref4$waitForLoadComp === void 0 ? true : _ref4$waitForLoadComp;\n    \
domNode.innerHTML = \"\";\n    domNode.appendChild(state.container = \
document.createElement(\"div\"));\n    state.container.className = \
\"scene-container\";\n    state.container.style.position = \"relative\";\n    \
state.container.appendChild(state.navInfo = \
document.createElement(\"div\"));\n    state.navInfo.className = \
\"scene-nav-info\";\n    state.navInfo.textContent = {\n      orbit: \
\"Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan\",\n   \
   trackball: \"Left-click: rotate, Mouse-wheel/middle-click: zoom, \
Right-click: pan\",\n      fly: \"WASD: move, R|F: up | down, Q|E: roll, \
up|down: pitch, left|right: yaw\"\n    }[controlType] || \"\";\n    \
state.navInfo.style.display = state.showNavInfo ? null : \"none\";\n    \
state.toolTipElem = document.createElement(\"div\");\n    \
state.toolTipElem.classList.add(\"scene-tooltip\");\n    \
state.container.appendChild(state.toolTipElem);\n    state.pointerPos = new \
three2.Vector2();\n    state.pointerPos.x = -2;\n    state.pointerPos.y = \
-2;\n    [\"pointermove\", \"pointerdown\"].forEach(function(evType) {\n      \
return state.container.addEventListener(evType, function(ev) {\n        \
evType === \"pointerdown\" && (state.isPointerPressed = true);\n        \
!state.isPointerDragging && ev.type === \"pointermove\" && (ev.pressure > 0 \
|| state.isPointerPressed) && (ev.pointerType !== \"touch\" || ev.movementX \
=== void 0 || [ev.movementX, ev.movementY].some(function(m2) {\n          \
return Math.abs(m2) > 1;\n        })) && (state.isPointerDragging = true);\n  \
      if (state.enablePointerInteraction) {\n          var offset = \
getOffset(state.container);\n          state.pointerPos.x = ev.pageX - \
offset.left;\n          state.pointerPos.y = ev.pageY - offset.top;\n         \
 state.toolTipElem.style.top = \"\".concat(state.pointerPos.y, \"px\");\n     \
     state.toolTipElem.style.left = \"\".concat(state.pointerPos.x, \
\"px\");\n          state.toolTipElem.style.transform = \
\"translate(-\".concat(state.pointerPos.x / state.width * 100, \"%, \
\").concat(\n            // flip to above if near bottom\n            \
state.height - state.pointerPos.y < 100 ? \"calc(-100% - 8px)\" : \"21px\",\n \
           \")\"\n          );\n        }\n        function getOffset(el) {\n \
         var rect = el.getBoundingClientRect(), scrollLeft = \
window.pageXOffset || document.documentElement.scrollLeft, scrollTop = \
window.pageYOffset || document.documentElement.scrollTop;\n          return \
{\n            top: rect.top + scrollTop,\n            left: rect.left + \
scrollLeft\n          };\n        }\n      }, {\n        passive: true\n      \
});\n    });\n    state.container.addEventListener(\"pointerup\", \
function(ev) {\n      state.isPointerPressed = false;\n      if \
(state.isPointerDragging) {\n        state.isPointerDragging = false;\n       \
 if (!state.clickAfterDrag) return;\n      }\n      \
requestAnimationFrame(function() {\n        if (ev.button === 0) {\n          \
state.onClick(state.hoverObj || null, ev, state.intersectionPoint);\n        \
}\n        if (ev.button === 2 && state.onRightClick) {\n          \
state.onRightClick(state.hoverObj || null, ev, state.intersectionPoint);\n    \
    }\n      });\n    }, {\n      passive: true,\n      capture: true\n    \
});\n    state.container.addEventListener(\"contextmenu\", function(ev) {\n   \
   if (state.onRightClick) ev.preventDefault();\n    });\n    state.renderer \
= new (useWebGPU ? WebGPURenderer : three2.WebGLRenderer)(Object.assign({\n   \
   antialias: true,\n      alpha: true\n    }, rendererConfig));\n    \
state.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));\n    \
state.container.appendChild(state.renderer.domElement);\n    \
state.extraRenderers = extraRenderers;\n    \
state.extraRenderers.forEach(function(r) {\n      r.domElement.style.position \
= \"absolute\";\n      r.domElement.style.top = \"0px\";\n      \
r.domElement.style.pointerEvents = \"none\";\n      \
state.container.appendChild(r.domElement);\n    });\n    \
state.postProcessingComposer = new EffectComposer(state.renderer);\n    \
state.postProcessingComposer.addPass(new RenderPass(state.scene, \
state.camera));\n    state.controls = new {\n      trackball: \
TrackballControls,\n      orbit: OrbitControls,\n      fly: FlyControls\n    \
}[controlType](state.camera, state.renderer.domElement);\n    if (controlType \
=== \"fly\") {\n      state.controls.movementSpeed = 300;\n      \
state.controls.rollSpeed = Math.PI / 6;\n      state.controls.dragToLook = \
true;\n    }\n    if (controlType === \"trackball\" || controlType === \
\"orbit\") {\n      state.controls.minDistance = 0.1;\n      \
state.controls.maxDistance = state.skyRadius;\n      \
state.controls.addEventListener(\"start\", function() {\n        \
state.controlsEngaged = true;\n      });\n      \
state.controls.addEventListener(\"change\", function() {\n        if \
(state.controlsEngaged) {\n          state.controlsDragging = true;\n        \
}\n      });\n      state.controls.addEventListener(\"end\", function() {\n   \
     state.controlsEngaged = false;\n        state.controlsDragging = \
false;\n      });\n    }\n    [state.renderer, \
state.postProcessingComposer].concat(_toConsumableArray4(state.extraRenderers\
)).forEach(function(r) {\n      return r.setSize(state.width, \
state.height);\n    });\n    state.camera.aspect = state.width / \
state.height;\n    state.camera.updateProjectionMatrix();\n    \
state.camera.position.z = 1e3;\n    state.scene.add(state.skysphere = new \
three2.Mesh());\n    state.skysphere.visible = false;\n    state.loadComplete \
= state.scene.visible = !waitForLoadComplete;\n    window.scene = \
state.scene;\n  },\n  update: function update3(state, changedProps) {\n    if \
(state.width && state.height && (changedProps.hasOwnProperty(\"width\") || \
changedProps.hasOwnProperty(\"height\"))) {\n      \
state.container.style.width = \"\".concat(state.width, \"px\");\n      \
state.container.style.height = \"\".concat(state.height, \"px\");\n      \
[state.renderer, \
state.postProcessingComposer].concat(_toConsumableArray4(state.extraRenderers\
)).forEach(function(r) {\n        return r.setSize(state.width, \
state.height);\n      });\n      state.camera.aspect = state.width / \
state.height;\n      state.camera.updateProjectionMatrix();\n    }\n    if \
(changedProps.hasOwnProperty(\"skyRadius\") && state.skyRadius) {\n      \
state.controls.hasOwnProperty(\"maxDistance\") && changedProps.skyRadius && \
(state.controls.maxDistance = Math.min(state.controls.maxDistance, \
state.skyRadius));\n      state.camera.far = state.skyRadius * 2.5;\n      \
state.camera.updateProjectionMatrix();\n      state.skysphere.geometry = new \
three2.SphereGeometry(state.skyRadius);\n    }\n    if \
(changedProps.hasOwnProperty(\"backgroundColor\")) {\n      var alpha = \
parseToRgb(state.backgroundColor).alpha;\n      if (alpha === void 0) alpha = \
1;\n      state.renderer.setClearColor(new three2.Color(curriedOpacify$1(1, \
state.backgroundColor)), alpha);\n    }\n    if \
(changedProps.hasOwnProperty(\"backgroundImageUrl\")) {\n      if \
(!state.backgroundImageUrl) {\n        state.skysphere.visible = false;\n     \
   state.skysphere.material.map = null;\n        !state.loadComplete && \
finishLoad();\n      } else {\n        new \
three2.TextureLoader().load(state.backgroundImageUrl, function(texture2) {\n  \
        texture2.colorSpace = three2.SRGBColorSpace;\n          \
state.skysphere.material = new three2.MeshBasicMaterial({\n            map: \
texture2,\n            side: three2.BackSide\n          });\n          \
state.skysphere.visible = true;\n          state.onBackgroundImageLoaded && \
setTimeout(state.onBackgroundImageLoaded);\n          !state.loadComplete && \
finishLoad();\n        });\n      }\n    }\n    \
changedProps.hasOwnProperty(\"showNavInfo\") && (state.navInfo.style.display \
= state.showNavInfo ? null : \"none\");\n    if \
(changedProps.hasOwnProperty(\"lights\")) {\n      (changedProps.lights || \
[]).forEach(function(light) {\n        return state.scene.remove(light);\n    \
  });\n      state.lights.forEach(function(light) {\n        return \
state.scene.add(light);\n      });\n    }\n    if \
(changedProps.hasOwnProperty(\"objects\")) {\n      (changedProps.objects || \
[]).forEach(function(obj) {\n        return state.scene.remove(obj);\n      \
});\n      state.objects.forEach(function(obj) {\n        return \
state.scene.add(obj);\n      });\n    }\n    function finishLoad() {\n      \
state.loadComplete = state.scene.visible = true;\n    }\n  }\n});\n\n// \
../../node_modules/3d-force-graph/dist/3d-force-graph.mjs\nfunction \
styleInject2(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = \
ref.insertAt;\n  if (typeof document === \"undefined\") {\n    return;\n  }\n \
 var head = document.head || document.getElementsByTagName(\"head\")[0];\n  \
var style = document.createElement(\"style\");\n  style.type = \
\"text/css\";\n  if (insertAt === \"top\") {\n    if (head.firstChild) {\n    \
  head.insertBefore(style, head.firstChild);\n    } else {\n      \
head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  \
}\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else \
{\n    style.appendChild(document.createTextNode(css));\n  }\n}\nvar \
css_248z2 = \".graph-info-msg {\\n  top: 50%;\\n  width: 100%;\\n  \
text-align: center;\\n  color: lavender;\\n  opacity: 0.7;\\n  font-size: \
22px;\\n  position: absolute;\\n  font-family: \
Sans-serif;\\n}\\n\\n.scene-container .clickable {\\n  cursor: \
pointer;\\n}\\n\\n.scene-container .grabbable {\\n  cursor: move;\\n  cursor: \
grab;\\n  cursor: -moz-grab;\\n  cursor: \
-webkit-grab;\\n}\\n\\n.scene-container .grabbable:active {\\n  cursor: \
grabbing;\\n  cursor: -moz-grabbing;\\n  cursor: \
-webkit-grabbing;\\n}\";\nstyleInject2(css_248z2);\nfunction \
_arrayLikeToArray6(r, a2) {\n  (null == a2 || a2 > r.length) && (a2 = \
r.length);\n  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];\n  \
return n;\n}\nfunction _arrayWithoutHoles5(r) {\n  if (Array.isArray(r)) \
return _arrayLikeToArray6(r);\n}\nfunction _defineProperty4(e, r, t) {\n  \
return (r = _toPropertyKey5(r)) in e ? Object.defineProperty(e, r, {\n    \
value: t,\n    enumerable: true,\n    configurable: true,\n    writable: \
true\n  }) : e[r] = t, e;\n}\nfunction _iterableToArray5(r) {\n  if \
(\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != \
r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _nonIterableSpread5() \
{\n  throw new TypeError(\"Invalid attempt to spread non-iterable \
instance.\\nIn order to be iterable, non-array objects must have a \
[Symbol.iterator]() method.\");\n}\nfunction ownKeys3(e, r) {\n  var t = \
Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = \
Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function(r2) {\n     \
 return Object.getOwnPropertyDescriptor(e, r2).enumerable;\n    })), \
t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread23(e) {\n  \
for (var r = 1; r < arguments.length; r++) {\n    var t = null != \
arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys3(Object(t), \
true).forEach(function(r2) {\n      _defineProperty4(e, r2, t[r2]);\n    }) : \
Object.getOwnPropertyDescriptors ? Object.defineProperties(e, \
Object.getOwnPropertyDescriptors(t)) : \
ownKeys3(Object(t)).forEach(function(r2) {\n      Object.defineProperty(e, \
r2, Object.getOwnPropertyDescriptor(t, r2));\n    });\n  }\n  return \
e;\n}\nfunction _toConsumableArray5(r) {\n  return _arrayWithoutHoles5(r) || \
_iterableToArray5(r) || _unsupportedIterableToArray6(r) || \
_nonIterableSpread5();\n}\nfunction _toPrimitive5(t, r) {\n  if (\"object\" \
!= typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 \
!== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != \
typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (\"string\" === r ? String : \
Number)(t);\n}\nfunction _toPropertyKey5(t) {\n  var i = _toPrimitive5(t, \
\"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction \
_unsupportedIterableToArray6(r, a2) {\n  if (r) {\n    if (\"string\" == \
typeof r) return _arrayLikeToArray6(r, a2);\n    var t = \
{}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && \
r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? \
Array.from(r) : \"Arguments\" === t || \
/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray6(r, \
a2) : void 0;\n  }\n}\nfunction linkKapsule(kapsulePropName, kapsuleType) {\n \
 var dummyK = new kapsuleType();\n  dummyK._destructor && \
dummyK._destructor();\n  return {\n    linkProp: function linkProp(prop) {\n  \
    return {\n        \"default\": dummyK[prop](),\n        onChange: \
function onChange13(v, state) {\n          state[kapsulePropName][prop](v);\n \
       },\n        triggerUpdate: false\n      };\n    },\n    linkMethod: \
function linkMethod(method) {\n      return function(state) {\n        var \
kapsuleInstance = state[kapsulePropName];\n        for (var _len = \
arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < \
_len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n     \
   var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);\n    \
    return returnVal === kapsuleInstance ? this : returnVal;\n      };\n    \
}\n  };\n}\nvar three3 = window.THREE ? window.THREE : {\n  AmbientLight,\n  \
DirectionalLight,\n  Vector3,\n  REVISION\n};\nvar \
CAMERA_DISTANCE2NODES_FACTOR = 170;\nvar bindFG = linkKapsule(\"forceGraph\", \
threeForcegraph);\nvar linkedFGProps = Object.assign.apply(Object, \
_toConsumableArray5([\"jsonUrl\", \"graphData\", \"numDimensions\", \
\"dagMode\", \"dagLevelDistance\", \"dagNodeFilter\", \"onDagError\", \
\"nodeRelSize\", \"nodeId\", \"nodeVal\", \"nodeResolution\", \"nodeColor\", \
\"nodeAutoColorBy\", \"nodeOpacity\", \"nodeVisibility\", \
\"nodeThreeObject\", \"nodeThreeObjectExtend\", \"linkSource\", \
\"linkTarget\", \"linkVisibility\", \"linkColor\", \"linkAutoColorBy\", \
\"linkOpacity\", \"linkWidth\", \"linkResolution\", \"linkCurvature\", \
\"linkCurveRotation\", \"linkMaterial\", \"linkThreeObject\", \
\"linkThreeObjectExtend\", \"linkPositionUpdate\", \
\"linkDirectionalArrowLength\", \"linkDirectionalArrowColor\", \
\"linkDirectionalArrowRelPos\", \"linkDirectionalArrowResolution\", \
\"linkDirectionalParticles\", \"linkDirectionalParticleSpeed\", \
\"linkDirectionalParticleWidth\", \"linkDirectionalParticleColor\", \
\"linkDirectionalParticleResolution\", \"forceEngine\", \"d3AlphaDecay\", \
\"d3VelocityDecay\", \"d3AlphaMin\", \"ngraphPhysics\", \"warmupTicks\", \
\"cooldownTicks\", \"cooldownTime\", \"onEngineTick\", \
\"onEngineStop\"].map(function(p) {\n  return _defineProperty4({}, p, \
bindFG.linkProp(p));\n})));\nvar linkedFGMethods = \
Object.assign.apply(Object, _toConsumableArray5([\"refresh\", \
\"getGraphBbox\", \"d3Force\", \"d3ReheatSimulation\", \
\"emitParticle\"].map(function(p) {\n  return _defineProperty4({}, p, \
bindFG.linkMethod(p));\n})));\nvar bindRenderObjs = \
linkKapsule(\"renderObjs\", threeRenderObjects);\nvar linkedRenderObjsProps = \
Object.assign.apply(Object, _toConsumableArray5([\"width\", \"height\", \
\"backgroundColor\", \"showNavInfo\", \
\"enablePointerInteraction\"].map(function(p) {\n  return \
_defineProperty4({}, p, bindRenderObjs.linkProp(p));\n})));\nvar \
linkedRenderObjsMethods = Object.assign.apply(Object, \
_toConsumableArray5([\"lights\", \"cameraPosition\", \
\"postProcessingComposer\"].map(function(p) {\n  return _defineProperty4({}, \
p, bindRenderObjs.linkMethod(p));\n})).concat([{\n  graph2ScreenCoords: \
bindRenderObjs.linkMethod(\"getScreenCoords\"),\n  screen2GraphCoords: \
bindRenderObjs.linkMethod(\"getSceneCoords\")\n}]));\nvar _3dForceGraph = \
index2({\n  props: _objectSpread23(_objectSpread23({\n    nodeLabel: {\n      \
\"default\": \"name\",\n      triggerUpdate: false\n    },\n    linkLabel: \
{\n      \"default\": \"name\",\n      triggerUpdate: false\n    },\n    \
linkHoverPrecision: {\n      \"default\": 1,\n      onChange: function \
onChange11(p, state) {\n        return \
state.renderObjs.lineHoverPrecision(p);\n      },\n      triggerUpdate: \
false\n    },\n    enableNavigationControls: {\n      \"default\": true,\n    \
  onChange: function onChange12(enable, state) {\n        var controls3 = \
state.renderObjs.controls();\n        if (controls3) {\n          \
controls3.enabled = enable;\n          enable && controls3.domElement && \
controls3.domElement.dispatchEvent(new PointerEvent(\"pointerup\"));\n        \
}\n      },\n      triggerUpdate: false\n    },\n    enableNodeDrag: {\n      \
\"default\": true,\n      triggerUpdate: false\n    },\n    onNodeDrag: {\n   \
   \"default\": function _default12() {\n      },\n      triggerUpdate: \
false\n    },\n    onNodeDragEnd: {\n      \"default\": function _default13() \
{\n      },\n      triggerUpdate: false\n    },\n    onNodeClick: {\n      \
triggerUpdate: false\n    },\n    onNodeRightClick: {\n      triggerUpdate: \
false\n    },\n    onNodeHover: {\n      triggerUpdate: false\n    },\n    \
onLinkClick: {\n      triggerUpdate: false\n    },\n    onLinkRightClick: {\n \
     triggerUpdate: false\n    },\n    onLinkHover: {\n      triggerUpdate: \
false\n    },\n    onBackgroundClick: {\n      triggerUpdate: false\n    },\n \
   onBackgroundRightClick: {\n      triggerUpdate: false\n    }\n  }, \
linkedFGProps), linkedRenderObjsProps),\n  methods: \
_objectSpread23(_objectSpread23({\n    zoomToFit: function zoomToFit2(state, \
transitionDuration, padding) {\n      var _state$forceGraph;\n      for (var \
_len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key \
= 3; _key < _len; _key++) {\n        bboxArgs[_key - 3] = arguments[_key];\n  \
    }\n      state.renderObjs.fitToBbox((_state$forceGraph = \
state.forceGraph).getGraphBbox.apply(_state$forceGraph, bboxArgs), \
transitionDuration, padding);\n      return this;\n    },\n    \
pauseAnimation: function pauseAnimation(state) {\n      if \
(state.animationFrameRequestId !== null) {\n        \
cancelAnimationFrame(state.animationFrameRequestId);\n        \
state.animationFrameRequestId = null;\n      }\n      return this;\n    },\n  \
  resumeAnimation: function resumeAnimation(state) {\n      if \
(state.animationFrameRequestId === null) {\n        this._animationCycle();\n \
     }\n      return this;\n    },\n    _animationCycle: function \
_animationCycle(state) {\n      if (state.enablePointerInteraction) {\n       \
 this.renderer().domElement.style.cursor = null;\n      }\n      \
state.forceGraph.tickFrame();\n      state.renderObjs.tick();\n      \
state.animationFrameRequestId = \
requestAnimationFrame(this._animationCycle);\n    },\n    scene: function \
scene2(state) {\n      return state.renderObjs.scene();\n    },\n    // \
Expose scene\n    camera: function camera2(state) {\n      return \
state.renderObjs.camera();\n    },\n    // Expose camera\n    renderer: \
function renderer2(state) {\n      return state.renderObjs.renderer();\n    \
},\n    // Expose renderer\n    controls: function controls2(state) {\n      \
return state.renderObjs.controls();\n    },\n    // Expose controls\n    \
tbControls: function tbControls2(state) {\n      return \
state.renderObjs.tbControls();\n    },\n    // To be deprecated\n    \
_destructor: function _destructor() {\n      this.pauseAnimation();\n      \
this.graphData({\n        nodes: [],\n        links: []\n      });\n    }\n  \
}, linkedFGMethods), linkedRenderObjsMethods),\n  stateInit: function \
stateInit3(_ref5) {\n    var controlType = _ref5.controlType, rendererConfig \
= _ref5.rendererConfig, extraRenderers = _ref5.extraRenderers;\n    var \
forceGraph = new threeForcegraph();\n    return {\n      forceGraph,\n      \
renderObjs: threeRenderObjects({\n        controlType,\n        \
rendererConfig,\n        extraRenderers\n      \
}).objects([forceGraph]).lights([new three3.AmbientLight(13421772, Math.PI), \
new three3.DirectionalLight(16777215, 0.6 * Math.PI)])\n    };\n  },\n  init: \
function init3(domNode, state) {\n    domNode.innerHTML = \"\";\n    \
domNode.appendChild(state.container = document.createElement(\"div\"));\n    \
state.container.style.position = \"relative\";\n    var roDomNode = \
document.createElement(\"div\");\n    \
state.container.appendChild(roDomNode);\n    state.renderObjs(roDomNode);\n   \
 var camera3 = state.renderObjs.camera();\n    var renderer3 = \
state.renderObjs.renderer();\n    var controls3 = \
state.renderObjs.controls();\n    controls3.enabled = \
!!state.enableNavigationControls;\n    state.lastSetCameraZ = \
camera3.position.z;\n    var infoElem;\n    \
state.container.appendChild(infoElem = document.createElement(\"div\"));\n    \
infoElem.className = \"graph-info-msg\";\n    infoElem.textContent = \"\";\n  \
  state.forceGraph.onLoading(function() {\n      infoElem.textContent = \
\"Loading...\";\n    }).onFinishLoading(function() {\n      \
infoElem.textContent = \"\";\n    }).onUpdate(function() {\n      \
state.graphData = state.forceGraph.graphData();\n      if (camera3.position.x \
=== 0 && camera3.position.y === 0 && camera3.position.z === \
state.lastSetCameraZ && state.graphData.nodes.length) {\n        \
camera3.lookAt(state.forceGraph.position);\n        state.lastSetCameraZ = \
camera3.position.z = Math.cbrt(state.graphData.nodes.length) * \
CAMERA_DISTANCE2NODES_FACTOR;\n      }\n    }).onFinishUpdate(function() {\n  \
    if (state._dragControls) {\n        var curNodeDrag = \
state.graphData.nodes.find(function(node) {\n          return \
node.__initialFixedPos && !node.__disposeControlsAfterDrag;\n        });\n    \
    if (curNodeDrag) {\n          curNodeDrag.__disposeControlsAfterDrag = \
true;\n        } else {\n          state._dragControls.dispose();\n        \
}\n        state._dragControls = void 0;\n      }\n      if \
(state.enableNodeDrag && state.enablePointerInteraction && state.forceEngine \
=== \"d3\") {\n        var dragControls = state._dragControls = new \
DragControls(state.graphData.nodes.map(function(node) {\n          return \
node.__threeObj;\n        }).filter(function(obj) {\n          return obj;\n  \
      }), camera3, renderer3.domElement);\n        \
dragControls.addEventListener(\"dragstart\", function(event) {\n          \
controls3.enabled = false;\n          event.object.__initialPos = \
event.object.position.clone();\n          event.object.__prevPos = \
event.object.position.clone();\n          var node = \
getGraphObj(event.object).__data;\n          !node.__initialFixedPos && \
(node.__initialFixedPos = {\n            fx: node.fx,\n            fy: \
node.fy,\n            fz: node.fz\n          });\n          \
!node.__initialPos && (node.__initialPos = {\n            x: node.x,\n        \
    y: node.y,\n            z: node.z\n          });\n          [\"x\", \
\"y\", \"z\"].forEach(function(c2) {\n            return \
node[\"f\".concat(c2)] = node[c2];\n          });\n          \
renderer3.domElement.classList.add(\"grabbable\");\n        });\n        \
dragControls.addEventListener(\"drag\", function(event) {\n          var \
nodeObj = getGraphObj(event.object);\n          if \
(!event.object.hasOwnProperty(\"__graphObjType\")) {\n            var initPos \
= event.object.__initialPos;\n            var prevPos = \
event.object.__prevPos;\n            var _newPos = event.object.position;\n   \
         nodeObj.position.add(_newPos.clone().sub(prevPos));\n            \
prevPos.copy(_newPos);\n            _newPos.copy(initPos);\n          }\n     \
     var node = nodeObj.__data;\n          var newPos = nodeObj.position;\n   \
       var translate = {\n            x: newPos.x - node.x,\n            y: \
newPos.y - node.y,\n            z: newPos.z - node.z\n          };\n          \
[\"x\", \"y\", \"z\"].forEach(function(c2) {\n            return \
node[\"f\".concat(c2)] = node[c2] = newPos[c2];\n          });\n          \
state.forceGraph.d3AlphaTarget(0.3).resetCountdown();\n          \
node.__dragged = true;\n          state.onNodeDrag(node, translate);\n        \
});\n        dragControls.addEventListener(\"dragend\", function(event) {\n   \
       delete event.object.__initialPos;\n          delete \
event.object.__prevPos;\n          var node = \
getGraphObj(event.object).__data;\n          if \
(node.__disposeControlsAfterDrag) {\n            dragControls.dispose();\n    \
        delete node.__disposeControlsAfterDrag;\n          }\n          var \
initFixedPos = node.__initialFixedPos;\n          var initPos = \
node.__initialPos;\n          var translate = {\n            x: initPos.x - \
node.x,\n            y: initPos.y - node.y,\n            z: initPos.z - \
node.z\n          };\n          if (initFixedPos) {\n            [\"x\", \
\"y\", \"z\"].forEach(function(c2) {\n              var fc = \
\"f\".concat(c2);\n              if (initFixedPos[fc] === void 0) {\n         \
       delete node[fc];\n              }\n            });\n            delete \
node.__initialFixedPos;\n            delete node.__initialPos;\n            \
if (node.__dragged) {\n              delete node.__dragged;\n              \
state.onNodeDragEnd(node, translate);\n            }\n          }\n          \
state.forceGraph.d3AlphaTarget(0).resetCountdown();\n          if \
(state.enableNavigationControls) {\n            controls3.enabled = true;\n   \
         controls3.domElement && controls3.domElement.ownerDocument && \
controls3.domElement.ownerDocument.dispatchEvent(\n              // simulate \
mouseup to ensure the controls don't take over after dragend\n              \
new PointerEvent(\"pointerup\", {\n                pointerType: \"touch\"\n   \
           })\n            );\n          }\n          \
renderer3.domElement.classList.remove(\"grabbable\");\n        });\n      }\n \
   });\n    three3.REVISION < 155 && \
(state.renderObjs.renderer().useLegacyLights = false);\n    \
state.renderObjs.hoverOrderComparator(function(a2, b) {\n      var aObj = \
getGraphObj(a2);\n      if (!aObj) return 1;\n      var bObj = \
getGraphObj(b);\n      if (!bObj) return -1;\n      var isNode = function \
isNode2(o) {\n        return o.__graphObjType === \"node\";\n      };\n      \
return isNode(bObj) - isNode(aObj);\n    }).tooltipContent(function(obj) {\n  \
    var graphObj = getGraphObj(obj);\n      return graphObj ? \
index3(state[\"\".concat(graphObj.__graphObjType, \
\"Label\")])(graphObj.__data) || \"\" : \"\";\n    \
}).hoverDuringDrag(false).onHover(function(obj) {\n      var hoverObj = \
getGraphObj(obj);\n      if (hoverObj !== state.hoverObj) {\n        var \
prevObjType = state.hoverObj ? state.hoverObj.__graphObjType : null;\n        \
var prevObjData = state.hoverObj ? state.hoverObj.__data : null;\n        var \
objType = hoverObj ? hoverObj.__graphObjType : null;\n        var objData = \
hoverObj ? hoverObj.__data : null;\n        if (prevObjType && prevObjType \
!== objType) {\n          var fn = state[\"on\".concat(prevObjType === \
\"node\" ? \"Node\" : \"Link\", \"Hover\")];\n          fn && fn(null, \
prevObjData);\n        }\n        if (objType) {\n          var _fn = \
state[\"on\".concat(objType === \"node\" ? \"Node\" : \"Link\", \
\"Hover\")];\n          _fn && _fn(objData, prevObjType === objType ? \
prevObjData : null);\n        }\n        \
renderer3.domElement.classList[hoverObj && state[\"on\".concat(objType === \
\"node\" ? \"Node\" : \"Link\", \"Click\")] || !hoverObj && \
state.onBackgroundClick ? \"add\" : \"remove\"](\"clickable\");\n        \
state.hoverObj = hoverObj;\n      }\n    \
}).clickAfterDrag(false).onClick(function(obj, ev) {\n      var graphObj = \
getGraphObj(obj);\n      if (graphObj) {\n        var fn = \
state[\"on\".concat(graphObj.__graphObjType === \"node\" ? \"Node\" : \
\"Link\", \"Click\")];\n        fn && fn(graphObj.__data, ev);\n      } else \
{\n        state.onBackgroundClick && state.onBackgroundClick(ev);\n      }\n \
   }).onRightClick(function(obj, ev) {\n      var graphObj = \
getGraphObj(obj);\n      if (graphObj) {\n        var fn = \
state[\"on\".concat(graphObj.__graphObjType === \"node\" ? \"Node\" : \
\"Link\", \"RightClick\")];\n        fn && fn(graphObj.__data, ev);\n      } \
else {\n        state.onBackgroundRightClick && \
state.onBackgroundRightClick(ev);\n      }\n    });\n    \
this._animationCycle();\n  }\n});\nfunction getGraphObj(object) {\n  var obj \
= object;\n  while (obj && !obj.hasOwnProperty(\"__graphObjType\")) {\n    \
obj = obj.parent;\n  }\n  return obj;\n}\n\n// <stdin>\ncore.ForceGraph3D = \
async (args, env) => {\n  await interpretate.shared.SpriteText.load();\n  \
const data = await interpretate(args[0], env);\n  const SpriteText = \
interpretate.shared.SpriteText.SpriteText;\n  const opts = await \
core._getRules(args, env);\n  const labels = (opts.VertexLabels || \
[]).reduce((acc, { lhs, rhs }) => {\n    acc[lhs] = rhs;\n    return acc;\n  \
}, {});\n  const nodeIds = /* @__PURE__ */ new Set();\n  const links = \
data.map(({ lhs, rhs }) => {\n    nodeIds.add(lhs);\n    nodeIds.add(rhs);\n  \
  return { source: String(rhs), target: String(lhs) };\n  });\n  const nodes \
= Array.from(nodeIds).map((id2) => ({\n    id: String(id2),\n    label: \
labels[id2] || String(id2)\n  }));\n  let imageSize = opts.ImageSize || \
350;\n  if (!Array.isArray(imageSize)) {\n    imageSize = [imageSize, \
imageSize * 0.7];\n  }\n  const Graph = \
_3dForceGraph({})(env.element).width(imageSize[0]).height(imageSize[1]).coold\
ownTicks(100).graphData({ nodes, links }).nodeThreeObject((node) => {\n    \
const sprite = new SpriteText(node.label);\n    sprite.material.depthWrite = \
true;\n    sprite.color = \"white\";\n    sprite.textHeight = 12;\n    return \
sprite;\n  }).nodeThreeObjectExtend(false);\n  if (\"Charge\" in opts) {\n    \
Graph.d3Force(\"charge\").strength(opts.Charge);\n  }\n  \
Graph.onEngineStop(() => Graph.zoomToFit(400));\n  env.local.Graph = \
Graph;\n};\ncore.ForceGraph3D.destroy = () => {\n  console.warn(\"3D graph \
was removed\");\n};\ncore.ForceGraph3D.virtual = true;\n/*! Bundled license \
information:\n\nthree/build/three.module.js:\n  (**\n   * @license\n   * \
Copyright 2010-2024 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   \
*)\n\nthree/build/three.webgpu.js:\n  (**\n   * @license\n   * Copyright \
2010-2024 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   *)\n*/\n", 
    "Display" -> "esm", "Hash" -> "d81ffd6f-7664-4c65-915e-4084f73925d7", 
    "Invisible" -> False, "MetaOnly" -> False, "Props" -> <||>, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> ".md\nNote, ==you don't need to compile and reevaluate the \
cell above== an invisible output cell stores JS module in this \
notebook.\n\nNow we need to register this symbol in Wolfram Language", 
    "Display" -> "codemirror", "Hash" -> 
     "d68e1058-cff9-446e-b09f-4e10bfea1e62", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "Note, ==you don't need to compile and reevaluate the cell \
above== an invisible output cell stores JS module in this notebook.\n\nNow we \
need to register this symbol in Wolfram Language", "Display" -> "markdown", 
    "Hash" -> "6f2a3300-40b0-4e21-9a23-15baa723f60c", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Output", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "ForceGraph3D /: MakeBoxes[f_ForceGraph3D, StandardForm] := \
With[{\n  (* compress it for the case if you have many labels and vertices \
*)\n  o = CreateFrontEndObject[f] \n},\n  (* low-level decoration box *)\n  \
ViewBox[o, o]\n]", "Display" -> "codemirror", 
    "Hash" -> "0dbd713f-67bf-4cd0-8390-818796ea949a", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> ".md\n## Testing\nLet us make a simple graph", 
    "Display" -> "codemirror", "Hash" -> 
     "fa71f990-1247-422f-9a6b-2208c6d216bc", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "## Testing\nLet us make a simple graph", 
    "Display" -> "markdown", "Hash" -> 
     "98ec924e-7249-43e4-84f6-362d05f12199", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Output", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "ForceGraph3D[{\n  1->2, 2->3, 3->4, 4->2, 3->5\n}, \
\"VertexLabels\"->{1->\"one\", 4->\"four\", 5->\"five\"}, ImageSize->500]", 
    "Display" -> "codemirror", "Hash" -> 
     "5ec196d7-da48-4f56-b56a-2564160a9f68", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "(*VB[*)(FrontEndExecutable[\"7350994e-9424-4b9f-a7f0-dcc29c29\
ba2a\"])(*,*)(*\"1:eJxTTMoPSmNkYGAoZgESHvk5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVg\
EKmxubGlhamqTqWpoYmeiaJFmm6SaapxnopiQnG1kCUVKiUSIAeQIVrA==\"*)(*]VB*)", 
    "Display" -> "codemirror", "Hash" -> 
     "1eba839b-2ec1-432d-b7d0-9bc7bcb06565", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Output", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> ".md\nTry to drag around the nodes.\n\nMore nodes!", 
    "Display" -> "codemirror", "Hash" -> 
     "4743f801-465f-4aaf-b993-a7ed1c214462", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "Try to drag around the nodes.\n\nMore nodes!", 
    "Display" -> "markdown", "Hash" -> 
     "6fdcb423-5d32-4621-b37b-6e0d1666b881", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Output", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "words = DictionaryLookup[\"pea*\"];\nFlatten[Map[(Thread[# -> \
\n       DeleteCases[Nearest[words, #, 3], #]]) &, \
words]];\n\nForceGraph3D[%, ImageSize->500]", "Display" -> "codemirror", 
    "Hash" -> "d61df717-8c5d-4d28-83c2-bdb2560beba9", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Input", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>, 
   <|"Data" -> "(*VB[*)(FrontEndExecutable[\"bcb3e485-f716-4f53-bc06-81af27ed\
a67a\"])(*,*)(*\"1:eJxTTMoPSmNkYGAoZgESHvk5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVg\
EKJyUnGaeaWJjqppkbmumapJka6yYlG5jpWhgmphmZp6YkmpknAgCK7hYF\"*)(*]VB*)", 
    "Display" -> "codemirror", "Hash" -> 
     "1260ef7e-2244-43c8-90e8-bc3518853747", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "State" -> "Idle", 
    "Type" -> "Output", "UID" -> Null, "Notebook" -> 
     "0e558a46-d138-4d43-ac36-3fa77b0def40"|>}, "serializer" -> "jsfn4"|>
