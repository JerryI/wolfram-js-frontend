"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[6640],{82764:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var r=i(17624),s=i(4552);const o={env:["WLJS"],package:"wljs-graphics3d-threejs",source:"https://github.com/JerryI/Mathematica-ThreeJS-graphics-engine/blob/dev/src/kernel.js",update:!0,numericArray:!0},t=void 0,a={id:"frontend/Reference/Graphics3D/GraphicsComplex",title:"GraphicsComplex",description:"represents an efficient graphics structure for drawing complex 3D objects (or 2D - see GraphicsComplex) storing vertices data in data variable. It replaces indexes found in primitives (can be nested) with a corresponding vertices and colors (if specified)",source:"@site/docs/frontend/Reference/Graphics3D/GraphicsComplex.md",sourceDirName:"frontend/Reference/Graphics3D",slug:"/frontend/Reference/Graphics3D/GraphicsComplex",permalink:"/frontend/Reference/Graphics3D/GraphicsComplex",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:173126759e4,frontMatter:{env:["WLJS"],package:"wljs-graphics3d-threejs",source:"https://github.com/JerryI/Mathematica-ThreeJS-graphics-engine/blob/dev/src/kernel.js",update:!0,numericArray:!0},sidebar:"tutorialSidebar",previous:{title:"GeometricTransformation",permalink:"/frontend/Reference/Graphics3D/GeometricTransformation"},next:{title:"GraphicsGroup",permalink:"/frontend/Reference/Graphics3D/GraphicsGroup"}},c={},d=[{value:"Supported primitives",id:"supported-primitives",level:2},{value:"<code>Line</code>",id:"line",level:3},{value:"<code>Polygon</code>",id:"polygon",level:3},{value:"Non-indexed geometry",id:"non-indexed-geometry",level:4},{value:"<code>Point</code>",id:"point",level:3},{value:"Options",id:"options",level:2},{value:"<code>&quot;VertexColors&quot;</code>",id:"vertexcolors",level:3},{value:"<code>&quot;VertexNormals&quot;</code>",id:"vertexnormals",level:3},{value:"Dynamic updates",id:"dynamic-updates",level:2},{value:"Basic fixed indexes",id:"basic-fixed-indexes",level:3},{value:"Update indexes and vertices",id:"update-indexes-and-vertices",level:3},{value:"Non-indexed",id:"non-indexed",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.M)(),...e.components},{Wl:o}=n;return o||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Wl",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:"GraphicsComplex[data_List, primitives_, opts___]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["represents an efficient graphics structure for drawing complex 3D objects (or 2D - see ",(0,r.jsx)(n.a,{href:"/frontend/Reference/Graphics/GraphicsComplex",children:"GraphicsComplex"}),") storing vertices data in ",(0,r.jsx)(n.code,{children:"data"})," variable. It replaces indexes found in ",(0,r.jsx)(n.code,{children:"primitives"})," (can be nested) with a corresponding vertices and colors (if specified)"]}),"\n",(0,r.jsxs)(n.p,{children:["Most plotting functions such as ",(0,r.jsx)(n.a,{href:"/frontend/Reference/Plotting%20Functions/ListPlot3D",children:"ListPlot3D"})," and others use this way showing 3D graphics."]}),"\n",(0,r.jsxs)(n.p,{children:["The implementation of ",(0,r.jsx)(n.a,{href:"/frontend/Reference/Graphics3D/GraphicsComplex",children:"GraphicsComplex"})," is based on a low-level THREE.js buffer position ",(0,r.jsx)(n.a,{href:"https://threejs.org/docs/#api/en/core/BufferAttribute",children:"attribute"})," directly written to a GPU memory."]}),"\n",(0,r.jsx)(n.h2,{id:"supported-primitives",children:"Supported primitives"}),"\n",(0,r.jsx)(n.h3,{id:"line",children:(0,r.jsx)(n.code,{children:"Line"})}),"\n",(0,r.jsx)(n.p,{children:"No restrictions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:'v = PolyhedronData["Dodecahedron", "Vertices"] // N;\ni = PolyhedronData["Dodecahedron", "FaceIndices"];\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:"GraphicsComplex[v, {Black, Line[i]}] // Graphics3D \n"})}),"\n",(0,r.jsx)(o,{children:'v = PolyhedronData["Dodecahedron", "Vertices"] // N; i = PolyhedronData["Dodecahedron", "FaceIndices"]; GraphicsComplex[v, {Black, Line[i]}] // Graphics3D '}),"\n",(0,r.jsx)(n.h3,{id:"polygon",children:(0,r.jsx)(n.code,{children:"Polygon"})}),"\n",(0,r.jsx)(n.p,{children:"Triangles works faster than quads or pentagons"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:"GraphicsComplex[v, Polygon[i]] // Graphics3D \n"})}),"\n",(0,r.jsx)(o,{children:'v = PolyhedronData["Dodecahedron", "Vertices"] // N; i = PolyhedronData["Dodecahedron", "FaceIndices"]; GraphicsComplex[v, {Polygon[i]}] // Graphics3D '}),"\n",(0,r.jsx)(n.h4,{id:"non-indexed-geometry",children:"Non-indexed geometry"}),"\n",(0,r.jsx)(n.p,{children:"One can provide only the ranges for the triangles to be rendered"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:"GraphicsComplex[v, Polygon[1, Length[v]]] // Graphics3D \n"})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"it assumes you are using triangles"})}),"\n",(0,r.jsx)(n.h3,{id:"point",children:(0,r.jsx)(n.code,{children:"Point"})}),"\n",(0,r.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,r.jsx)(n.h3,{id:"vertexcolors",children:(0,r.jsx)(n.code,{children:'"VertexColors"'})}),"\n",(0,r.jsx)(n.p,{children:"Defines sets of colors used for shading vertices"}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'"VertexColors"'})," is a plain list which must have the following form"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:'"VertexColors" ->{{r1,g1,b1}, {r2,g2,b2}, ...}\n'})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Supports dynamic updates"})}),"\n",(0,r.jsx)(n.h3,{id:"vertexnormals",children:(0,r.jsx)(n.code,{children:'"VertexNormals"'})}),"\n",(0,r.jsx)(n.p,{children:"Defines sets of normals used for shading"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Supports dynamic updates"})}),"\n",(0,r.jsx)(n.h2,{id:"dynamic-updates",children:"Dynamic updates"}),"\n",(0,r.jsx)(n.h3,{id:"basic-fixed-indexes",children:"Basic fixed indexes"}),"\n",(0,r.jsxs)(n.p,{children:["It does support dynamic updates for vertices data and colors. Use ",(0,r.jsx)(n.a,{href:"/frontend/Reference/Interpreter/Offload",children:"Offload"})," wrapper."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",metastring:'title="cell 1"',children:'(* generate mesh *)\nproc = HardcorePointProcess[50, 0.5, 2];\nreg = Rectangle[{-10, -10}, {10, 10}];\nsamples = RandomPointConfiguration[proc, reg]["Points"];\n\n(* triangulate *)\nNeeds["ComputationalGeometry`"];\ntriangles2[points_] := Module[{tr, triples},\n  tr = DelaunayTriangulation[points];\n  triples = Flatten[Function[{v, list},\n      Switch[Length[list],\n        (* account for nodes with connectivity 2 or less *)\n        1, {},\n        2, {Flatten[{v, list}]}, \n        _, {v, ##} & @@@ Partition[list, 2, 1, {1, 1}]\n      ]\n    ] @@@ tr, 1];\n  Cases[GatherBy[triples, Sort], a_ /; Length[a] == 3 :> a[[1]]]]\n\ntriangles = triangles2[samples];\n\n(* sample function *)\nf[p_, {x_,y_,z_}] := z Exp[-(*FB[*)(((*SpB[*)Power[Norm[p - {x,y}](*|*),(*|*)2](*]SpB*))(*,*)/(*,*)(2.))(*]FB*)]\n\n(* initial data *)\nprobe = {#[[1]], #[[2]], f[#, {10, 0, 0}]} &/@ samples // Chop;\ncolors = With[{mm = MinMax[probe[[All,3]]]},\n      (Blend[{{mm[[1]], Blue}, {mm[[2]], Red}}, #[[3]]] )&/@ probe /. {RGBColor -> List} // Chop];\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",metastring:'title="cell 2"',children:'Graphics3D[{\n  GraphicsComplex[probe // Offload, {Polygon[triangles]}, "VertexColors"->Offload[colors, "Static"->True]],\n\n  EventHandler[Sphere[{0,0,0}, 0.1], {"transform"->Function[data, With[{pos = data["position"]},\n    probe = {#[[1]], #[[2]], f[#, pos]} &/@ samples // Chop;\n    colors = With[{mm = MinMax[probe[[All,3]]]},\n      (Blend[{{mm[[1]], Blue}, {mm[[2]], Red}}, #[[3]]] )&/@ probe /. {RGBColor -> List} // Chop];\n  ]]}]\n}]\n'})}),"\n",(0,r.jsx)(n.p,{children:"The result is interactive 3D plot"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:i(43408).c+"",width:"810",height:"574"})}),"\n",(0,r.jsx)(n.p,{children:"Or the variation of it, if we add a point light source"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:'light = {0,0,0};\nGraphics3D[{\n  GraphicsComplex[probe // Offload, {Polygon[triangles]}],\n  PointLight[Red, light // Offload],\n\n  EventHandler[Sphere[{0,0,0}, 0.1], {"transform"->Function[data, With[{pos = data["position"]},\n    probe = {#[[1]], #[[2]], f[#, pos]} &/@ samples // Chop;\n    light = pos;\n  ]]}]\n}]\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:i(67535).c+"",width:"810",height:"574"})}),"\n",(0,r.jsx)(n.h3,{id:"update-indexes-and-vertices",children:"Update indexes and vertices"}),"\n",(0,r.jsxs)(n.p,{children:["For more complicated example you can update both. Here is an example with dynamic adapter for ",(0,r.jsx)(n.code,{children:"ParametericPlot3D"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"define shapes"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",metastring:'title="cell 1"',children:"sample[t_] := With[{\n   complex = ParametricPlot3D[\n     (1 - t) * {\n       (2 + Cos[v]) * Cos[u],\n       (2 + Cos[v]) * Sin[u],\n       Sin[v]\n     } + t * {\n       1.16^v * Cos[v] * (1 + Cos[u]),\n       -1.16^v * Sin[v] * (1 + Cos[u]),\n       -2 * 1.16^v * (1 + Sin[u]) + 1.0\n     },\n     {u, 0, 2\\[Pi]},\n     {v, -\\[Pi], \\[Pi]},\n     MaxRecursion -> 2,\n     Mesh -> None\n   ][[1, 1]]\n   },\n  {\n   complex[[1]],\n   Cases[complex[[2]], _Polygon, 6] // First // First,\n   complex[[3, 2]]\n  }\n]\n"})}),"\n",(0,r.jsx)(n.p,{children:"now construct the scene"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:'LeakyModule[{\n    vertices, normals, indices\n  },\n    {\n      EventHandler[InputRange[0,1,0.1,0], Function[value,\n        With[{res  = sample[value]},\n          normals = res[[3]];\n          indices = res[[2]];\n          vertices = res[[1]];\n        ];\n      ]],\n\n      {vertices, indices, normals} = sample[0];\n      \n      Graphics3D[{\n        MeshMaterial[MeshToonMaterial[]], Gray, \n        SpotLight[Red, 5 {1,1,1}], SpotLight[Blue, 5 {-1,-1,1}], \n        SpotLight[Green, 5 {1,-1,1}], \n        PointLight[Magenta, {10,10,10}],\n        \n        GraphicsComplex[vertices // Offload, {\n          Polygon[indices // Offload]\n        }, VertexNormals->Offload[normals, "Static"->True]]\n        \n      }, Lighting->None]\n    } // Column // Panel \n]\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:i(64792).c+"",width:"782",height:"606"})}),"\n",(0,r.jsx)(n.h3,{id:"non-indexed",children:"Non-indexed"}),"\n",(0,r.jsxs)(n.p,{children:["This is a another mode of working with ",(0,r.jsx)(n.a,{href:"#Non-indexed%20geometry",children:"Non-indexed geometry"})," in ",(0,r.jsx)(n.code,{children:"Polygon"}),". The benefit of this approach, you can use fixed length buffer for vertices and limit your drawing range using two arguments of Polygon."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Use non-indexed geometry if your polygon count reaches ",(0,r.jsx)(n.strong,{children:"1 million"}),"."]})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Paint 3D"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:i(96787).c+"",width:"800",height:"585"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Marching Cubes examples"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:i(19404).c+"",width:"800",height:"645"})})]})}function p(e={}){const{wrapper:n}={...(0,s.M)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},19404:(e,n,i)=>{i.d(n,{c:()=>r});const r=i.p+"assets/images/balls-ezgif.com-video-to-gif-converter 1-edc2643a208aacae7738271688617fd6.gif"},67535:(e,n,i)=>{i.d(n,{c:()=>r});const r=i.p+"assets/images/Gauss3DLight-ezgif.com-optipng-55aa0786b7a01b061d0bc25b91692b8a.png"},43408:(e,n,i)=>{i.d(n,{c:()=>r});const r=i.p+"assets/images/Gaussian3D-ezgif.com-optipng-705015b2beafdce52658122815e639f2.png"},64792:(e,n,i)=>{i.d(n,{c:()=>r});const r=i.p+"assets/images/morph-ezgif.com-video-to-gif-converter-6bfe804e641e87e5b52ccc0441ee3b59.gif"},96787:(e,n,i)=>{i.d(n,{c:()=>r});const r=i.p+"assets/images/paint3d-ezgif.com-video-to-gif-converter-6503962e9ed7a85543946c8da8140487.gif"},4552:(e,n,i)=>{i.d(n,{I:()=>a,M:()=>t});var r=i(11504);const s={},o=r.createContext(s);function t(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);