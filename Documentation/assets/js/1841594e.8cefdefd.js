"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[1580],{35076:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var o=t(17624),l=t(4552);const s={},r=void 0,i={id:"frontend/Advanced/Events system/Notebook, cells and windows",title:"Notebook, cells and windows",description:"Cells and notebook objects can also emit events and there is no need in cloning event objects to assign multiple handlers (it is done automatically once an EventHandler method is applied).",source:"@site/docs/frontend/Advanced/Events system/Notebook, cells and windows.md",sourceDirName:"frontend/Advanced/Events system",slug:"/frontend/Advanced/Events system/Notebook, cells and windows",permalink:"/frontend/Advanced/Events system/Notebook, cells and windows",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1716132984e3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Mouse and keyboard",permalink:"/frontend/Advanced/Events system/Mouse and keyboard"},next:{title:"Parallel kernels",permalink:"/frontend/Advanced/Events system/Parallel kernels"}},d={},c=[{value:"Notebook",id:"notebook",level:2},{value:"Cells",id:"cells",level:2},{value:"Window",id:"window",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.M)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Cells and notebook objects can also emit events and there is no need in cloning event objects to assign multiple handlers (it is done automatically once an ",(0,o.jsx)(n.code,{children:"EventHandler"})," method is applied)."]}),"\n",(0,o.jsx)(n.h2,{id:"notebook",children:"Notebook"}),"\n",(0,o.jsxs)(n.p,{children:["To get the current notebook object ",(0,o.jsx)(n.a,{href:"/frontend/Reference/Cells%20and%20Notebook/RemoteNotebook",children:"RemoteNotebook"})," from the current context - use ",(0,o.jsx)(n.a,{href:"/frontend/Reference/Cells%20and%20Notebook/EvaluationNotebook",children:"EvaluationNotebook"}),". There are many patterns available to subscribe"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"OnClose"'})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"OnBeforeSave"'})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"OnBeforeLoad"'})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"OnWebSocketConnected"'})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"AfterWebSocketConnected"'})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"CellError"'})}),"\n",(0,o.jsx)(n.li,{children:"... many more internal events"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"most of them used in plugins and extensions. So far the most practical use cases comes to only first one"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:'EventHandler[EvaluationNotebook[], {\n\t"OnClose" -> Function[Null,\n\t\tSetTimeout[Beep[], 1500];\n\t\t(* beep after closing *)\n\t]\n}];\n'})}),"\n",(0,o.jsx)(n.p,{children:"It can be used to clean up handlers, listeners or to stop tasks, once a notebook has been closed."}),"\n",(0,o.jsxs)(n.admonition,{type:"tip",children:[(0,o.jsx)(n.p,{children:"To clean up handlers one can explicitly clone it beforehand"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:'With[{cloned = EventClone[EvaluationNotebook[]]},\n\tEventHandler[cloned, {\n\t\t"OnClose" -> Function[Null,\n\t\t\tSetTimeout[Beep[], 1500];\n\t\t\t(* beep after closing *)\n\n\t\t\tDelete[cloned];\n\t\t]\n\t}]\n];\n'})}),(0,o.jsxs)(n.p,{children:["and then apply ",(0,o.jsx)(n.code,{children:"EventRemove"}),", otherwise it will fire every time you close a notebook."]})]}),"\n",(0,o.jsx)(n.h2,{id:"cells",children:"Cells"}),"\n",(0,o.jsxs)(n.p,{children:["There are following functions are available to extract cell objects ",(0,o.jsx)(n.a,{href:"/frontend/Reference/Cells%20and%20Notebook/RemoteCellObj",children:"RemoteCellObj"})," from the evaluation context"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/frontend/Reference/Cells%20and%20Notebook/EvaluationCell",children:"EvaluationCell"})," an input cell (where the code is written)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/frontend/Reference/Cells%20and%20Notebook/ResultCell",children:"ResultCell"})," an output cell (even if it does not exists yet)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"There are following patterns available to attach handlers"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"Destroy"'})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"State"'})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"Error"'})}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The most practical one is the first one"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:'With[{},\n  EventHandler[ResultCell[], {"Destroy" -> (Print["Destroyed!"] &)}];\n  "Lovely day"\n]\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"try to reevaluate it multiple times"})}),"\n",(0,o.jsx)(n.p,{children:"It can be used to unsubscribe from listeners, stop tasks once a cell has been reevaluated or destroyed."}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Cell events are supported for all types of cells including ",(0,o.jsx)(n.a,{href:"/frontend/Cell%20types/WLX",children:"WLX"}),", ",(0,o.jsx)(n.a,{href:"/frontend/Cell%20types/Slides",children:"Slides"}),", and etc."]})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Cell events are working as well for ",(0,o.jsx)(n.strong,{children:"projected outputs to new windows"})]})}),"\n",(0,o.jsx)(n.h2,{id:"window",children:"Window"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.a,{href:"/frontend/Reference/Frontend%20IO/WindowObj",children:"WindowObj"})," represents a current window, where the notebook is running. Usually it is used in ",(0,o.jsx)(n.a,{href:"/frontend/Reference/Frontend%20IO/FrontFetch",children:"FrontFetch"}),", ",(0,o.jsx)(n.a,{href:"/frontend/Reference/Frontend%20IO/FrontSubmit",children:"FrontSubmit"}),", however it also supports a few patterns for handlers"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"keydown"'})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"capturekeydown"'})}),"\n"]}),"\n",(0,o.jsxs)(n.admonition,{type:"warning",children:[(0,o.jsx)(n.p,{children:"Those events are captured globally on the given window. It means, you have to explicitly remove event listener from there or refresh the window if you do not need to track keys anymore."}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:'"capturekeydown"'})," will block most keys. Capture ",(0,o.jsx)(n.code,{children:"Escape"})," code for example to make sure that user can have control back if needed."]})]}),"\n",(0,o.jsx)(n.p,{children:"For example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:'ev = EventHandler[CurrentWindow[], {\n\t"keydown" -> Function[key,\n\t\tIf[key === "Escape", EventRemove[ev]];\n\t\tPrint[key];\n\t]\n}];\n'})})]})}function h(e={}){const{wrapper:n}={...(0,l.M)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},4552:(e,n,t)=>{t.d(n,{I:()=>i,M:()=>r});var o=t(11504);const l={},s=o.createContext(l);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);