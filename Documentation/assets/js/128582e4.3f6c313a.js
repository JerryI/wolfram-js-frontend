"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[1244],{8668:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var r=s(17624),i=s(4552);const o={},t=void 0,c={id:"frontend/Reference/Misc/Promise",title:"Promise",description:"Promise",source:"@site/docs/frontend/Reference/Misc/Promise.md",sourceDirName:"frontend/Reference/Misc",slug:"/frontend/Reference/Misc/Promise",permalink:"/frontend/Reference/Misc/Promise",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1711835414e3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Language",permalink:"/frontend/Reference/Misc/Language"},next:{title:"Plotly",permalink:"/frontend/Reference/Plotly/"}},l={},d=[{value:"<code>Promise</code>",id:"promise",level:2},{value:"<code>Then</code>",id:"then",level:2},{value:"Example",id:"example",level:3},{value:"<code>WaitAll</code>",id:"waitall",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.M)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"promise",children:(0,r.jsx)(n.code,{children:"Promise"})}),"\n",(0,r.jsxs)(n.p,{children:["A constructor and also representation of ",(0,r.jsx)(n.a,{href:"/frontend/Reference/Misc/Events#%60EventObject%60",children:(0,r.jsx)(n.code,{children:"EventObject"})})," which ",(0,r.jsx)(n.strong,{children:"can be fired only once"})," (aka resolved) and even before a corresponding handler is attached"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:"Promise[] _Promise (* constructor *)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To resolve or reject a promise - use ",(0,r.jsx)(n.a,{href:"/frontend/Reference/Misc/Events#%60EventFire%60",children:(0,r.jsx)(n.code,{children:"EventFire"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:"EventFire[p_Promise, Resolve | Reject, data_]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"then",children:(0,r.jsx)(n.code,{children:"Then"})}),"\n",(0,r.jsx)(n.p,{children:"An expression for asynchronous subscribing to promise resolution or rejection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:"Then[p_Promise | _List | _, resolve_]\nThen[p_Promise | _List | _, resolve_, reject_]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["where ",(0,r.jsx)(n.code,{children:"resolve"})," and ",(0,r.jsx)(n.code,{children:"reject"})," are any arbitrary functions. This is ",(0,r.jsx)(n.strong,{children:"non-blocking"})," function."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The key difference between ",(0,r.jsx)(n.a,{href:"/frontend/Reference/Misc/Events#%60EventHandler%60",children:(0,r.jsx)(n.code,{children:"EventHandler"})})," and ",(0,r.jsx)(n.a,{href:"#%60Then%60",children:(0,r.jsx)(n.code,{children:"Then"})})," is that ",(0,r.jsx)(n.a,{href:"#%60Then%60",children:(0,r.jsx)(n.code,{children:"Then"})})," ",(0,r.jsx)(n.strong,{children:"can even be applied to already resolved"})," ",(0,r.jsx)(n.code,{children:"Promise"})," object (after it was fired), which will cause an immediate evaluation of ",(0,r.jsx)(n.code,{children:"resolve"})," or ",(0,r.jsx)(n.code,{children:"reject"})," functions."]})}),"\n",(0,r.jsxs)(n.p,{children:["Being applied to a ",(0,r.jsx)(n.code,{children:"List"})," of ",(0,r.jsx)(n.code,{children:"_Promise"})," objects it will wait until all of them are resolved before evaluating ",(0,r.jsx)(n.code,{children:"resolve"})," function."]}),"\n",(0,r.jsxs)(n.p,{children:["Any Wolfram Expressions, which is not a ",(0,r.jsx)(n.code,{children:"List"})," or ",(0,r.jsx)(n.code,{children:"Promise"})," ",(0,r.jsx)(n.strong,{children:"counts as resolved"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.p,{children:"Let's try with a multiple promise events"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:'p1 = Promise[];\np2 = Promise[];\n\nSetTimeout[EventFire[p1, Resolve, Null], 1000];\nSetTimeout[EventFire[p2, Resolve, Null], 1500];\n\nThen[{p1,p2,Null}, Function[Null,\n\tEcho["Resolved!"];\n]];\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here ",(0,r.jsx)(n.code,{children:"Null"})," as a last element of a list was used just for demonstration purposes. It can also be any non ",(0,r.jsx)(n.code,{children:"_Promise | _List"})," expression."]}),"\n",(0,r.jsx)(n.h2,{id:"waitall",children:(0,r.jsx)(n.code,{children:"WaitAll"})}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"synchronous blocking function"})," to wait until a promise has resolved and returns the result"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mathematica",children:"WaitAll[p_Promise] _\n"})}),"\n",(0,r.jsxs)(n.p,{children:["There is ",(0,r.jsx)(n.strong,{children:"a timeout of 5 seconds"}),", then ",(0,r.jsx)(n.code,{children:"$Failed"})," is returned."]}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsxs)(n.p,{children:["Be careful while using this. Avoid to use in ",(0,r.jsx)(n.code,{children:"SessionSubmit"}),", ",(0,r.jsx)(n.code,{children:"BackgroundTask"})," and other interrupting the main loop subroutines. If your promise resolution does depend on TCP socket message, it will never be resolved properly, since all subroutines blocks TCP sockets and other external services."]})})]})}function h(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},4552:(e,n,s)=>{s.d(n,{I:()=>c,M:()=>t});var r=s(11504);const i={},o=r.createContext(i);function t(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);