"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[8808],{57760:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"spider","metadata":{"permalink":"/blog/spider","source":"@site/blog/2024-04-19-spider/index.md","title":"Procedural spider animation","description":"I have been always amazed by a fascinating procedural animation using in some games like Rain World. The key feature there is that you define sort of a target points for a model and a clever algorithm figures out the way how each bone or \\"leg\\" will move to achieve the goal. This is a common problem of kinematics. Let\'s start with the simplest approach","date":"2024-04-19T00:00:00.000Z","tags":[{"label":"animation","permalink":"/blog/tags/animation"}],"readingTime":4.55,"hasTruncateMarker":true,"authors":[{"name":"Kirill Vasin","title":"Maintainer","url":"https://github.com/JerryI","imageURL":"https://avatars.githubusercontent.com/u/4111822?s=48&v=4","key":"jerryi"}],"frontMatter":{"authors":"jerryi","tags":["animation"],"enableComments":true,"slug":"spider"},"unlisted":false,"nextItem":{"title":"Image tracing and animation","permalink":"/blog/image-trace"}},"content":"![](./../spider-ezgif.com-crop.gif)\\n\\nI have been always amazed by a fascinating procedural animation using in some games like *Rain World*. The key feature there is that you define sort of a target points for a model and a clever algorithm figures out the way how each bone or \\"leg\\" will move to achieve the goal. This is a common problem of kinematics. Let\'s start with the simplest approach\\n\\n\x3c!--truncate--\x3e\\n## Cycloid\\nIf we roll a ball over a plane surface with attached marker at the side it will produce a well-known curve\\n\\n```mathematica\\nParametricPlot[{x - Sin[x], 1 - Cos[x]}, {x,0,6Pi}]\\n```\\n\\n<Wl>{`ParametricPlot[{x - Sin[x], 1 - Cos[x]}, {x,0,6Pi}]`}</Wl>\\n\\nImagine it it were legs, which would follow multiple cycloids with a little offset. But firstly, we should get rid of a plane ground and turn it into something more interesting\\n\\n```mathematica @\\nland[x_] := 5.0 + (*FB[*)((Sin[x])(*,*)/(*,*)(10.0))(*]FB*) + Cos[(*FB[*)((x)(*,*)/(*,*)(10.0))(*]FB*)] x + (*FB[*)(((*SpB[*)Power[x(*|*),(*|*)2](*]SpB*))(*,*)/(*,*)(100.0))(*]FB*)\\n\\nParametricPlot[{x, land[x]}, {x,-20,80}]\\n```\\n\\n<Wl>{`ParametricPlot[{x, 5.0 + (*FB[*)((Sin[x])(*,*)/(*,*)(10.0))(*]FB*) + Cos[(*FB[*)((x)(*,*)/(*,*)(10.0))(*]FB*)] x + (*FB[*)(((*SpB[*)Power[x(*|*),(*|*)2](*]SpB*))(*,*)/(*,*)(100.0))(*]FB*)}, {x,-20,80}]`}</Wl>\\n\\nTo project cycloid onto `land` curve, we could not find anything better, that to offset `y` axis\\n\\n```mathematica @\\nParametricPlot[\\n  With[{b = land[x]}, {\\n    {x, b},\\n    {(*FB[*)(((4x - Sin[4x]))(*,*)/(*,*)(4))(*]FB*), b + 1 - Cos[4x]}\\n  }\\n] // Evaluate, {x,-20,80}]\\n```\\n\\n<Wl>{`ListLinePlot[Table[With[{b = 5.0 + ((Sin[x])/(10.0)) + Cos[((x)/(10.0))] x + ((Power[x,2])/(100.0))}, {{x, b},{(((4x - Sin[4x]))/(4)), b + 1 - Cos[4x]}}] , {x,-20,80, 0.2}]//Transpose]`}</Wl>\\n\\n*try to zoom in with a mouse*\\n\\n## FABRIK Inverse\xa0Kinematics\\nLegs of a spider are not straight lines, and consists of small segments needed to be animated separately. For this case there is a nice heuristic algorithm [FABRIK](http://www.andreasaristidou.com/FABRIK.html).\\n\\nI do not claim that my implementation is most optimized, but it does solve a problem\\n\\n```mathematica\\nClearAll[cached];\\ncached[expr_] := cached[expr] = expr;\\nSetAttributes[cached, HoldAll]\\n\\nSetAttributes[fabrik, HoldFirst]\\n\\nfabrik[chain_, target_, origin_] := Module[{\\n\\tbuffer, prev, \\n\\tlengths = cached[Norm /@ (chain // Reverse // Differences) // Reverse]\\n},\\n  buffer = Table[With[{p = chain[[-i]]},\\n    If[i === 1,\\n      prev = target;\\n      target\\n    ,\\n    \\n      prev = prev - Normalize[(prev - p)] lengths[[1-i]];\\n      prev \\n    ]\\n  ], {i, chain // Length}] // Reverse;\\n\\n  chain = Table[With[{p = buffer[[i]]},\\n    If[i === 1,\\n      prev = origin;\\n      origin\\n    ,\\n    \\n      prev = prev - Normalize[(prev - p)] lengths[[i-1]];\\n      prev \\n    ]\\n  ], {i, chain // Length}];\\n]\\n```\\n\\nLet us see how it works in the following example\\n\\n```mathematica\\nchain = {{0,0}, {0.5,1}, {1,1}, {1,0.5}};\\n\\nGraphics[{\\n  Line[chain // Offload],\\n  EventHandler[Graphics`Canvas[], {\\"mousemove\\" -> Function[xy,\\n    fabrik[chain, xy, {0,0}]\\n  ]}]\\n}]\\n```\\n\\n![](./../tricks-ezgif.com-optimize.gif)\\n\\nThe next idea will be to assign the target position of each leg to a cycloid.\\n\\n## Modelling legs\\nWe can isolate our a leg into a independent component, hence it would be easier to combine them together\\n\\n```mathematica @\\nleg[event_String, target_, origin_] := Module[{\\n  (*BB[*)(* initial leg segments *)(*,*)(*\\"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU=\\"*)(*]BB*)\\n  chain = Table[k(target - origin) + origin, {k, -0.6, 1.6, 0.4}]\\n},\\n  (*BB[*)(* subscribe to an update *)(*,*)(*\\"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU=\\"*)(*]BB*)\\n  With[{cloned = EventClone[event]},    \\n    EventHandler[cloned, Function[Null,\\n      fabrik[chain, target, origin]\\n    ]];\\n  ];\\n\\n  Offload[chain]\\n]\\n\\nSetAttributes[leg, HoldRest];\\n```\\n\\nhere the first argument specifies an `EventObject` identifier, that will be called later on to update all legs segments in the animation loop.\\n\\nNow we can combine multiple legs, which target\'s variables will follows cycloids with small offsets as follows\\n\\n```mathematica @\\ngetTarget[xoffset_, x_] := With[{b = land[x + xoffset]}, \\n  {\\n    (*FB[*)(((4(x + xoffset) - Sin[4(x + xoffset)]))(*,*)/(*,*)(4))(*]FB*), \\n    b + 1 - Cos[4(x + xoffset)]\\n  }\\n]\\n```\\n\\n```mathematica @\\nModule[{t = 4.0 (*BB[*)(*x-position of a spider*)(*,*)(*\\"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU=\\"*)(*]BB*), ev = CreateUUID[]},\\n {\\n  Graphics[{\\n    Line[leg[ev, {t,1 + land[t]}, getTarget[-0.5, t]]], \\n    Line[leg[ev, {t,1 + land[t]}, getTarget[+0.25, t]]],\\n    Line[leg[ev, {t,1 + land[t]}, getTarget[0, t]]],    \\n    Line[leg[ev, {t,1 + land[t]}, getTarget[-0.25, t]]], \\n    Line[leg[ev, {t,1 + land[t]}, getTarget[+0.5, t]]],    \\n    \\n    (*BB[*)(* ground curve *)(*,*)(*\\"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU=\\"*)(*]BB*)\\n    Plot[land[x], {x,0,20}]//First \\n  }],\\n\\n  EventHandler[InputRange[0,10, 0.1], Function[value, t = value; EventFire[ev, Null]]]\\n } // Row \\n]\\n```\\n\\n![](./../Screenshot%202024-05-19%20at%2016.10.26.png)\\n\\n## Adding controls\\nSlides are boring. Using ``Graphics`Canvas[]`` with `EventHandler` we can capture arrow keys and animate accordingly. However, to animate continuously we can set a timer and remove it once the target position of a spider has been reached\\n\\n```mathematica @\\nModule[{\\n  t = 4.0, \\n  ev = CreateUUID[], \\n  target = 4.0, task = Null, \\n  wake, sleep, view = {0,0}, \\n  win = CurrentWindow[]\\n},\\n\\n  (*BB[*)(* using linear interpolation animate to the target*)(*,*)(*\\"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU=\\"*)(*]BB*)\\n  wake := If[task === Null, task = SetInterval[\\n    t = t + 0.1 (target - t);\\n    EventFire[ev, Null];\\n    \\n    If[Abs[t - target] < 0.01, sleep];\\n  , 30]];\\n\\n  sleep := With[{},\\n    TaskRemove[task];\\n    task = Null;\\n  ];\\n\\n  (*BB[*)(* animate the camera by view of the canvas *)(*,*)(*\\"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU=\\"*)(*]BB*)\\n  camera := With[{center = (*FB[*)(({30,20})(*,*)/(*,*)(2))(*]FB*) + view, spider = {t, land[t]}},\\n    If[Norm[center - spider] > 10, \\n      view = (center - spider)/2;\\n      FrontSubmit[ZoomAt[1, -view], MetaMarker[\\"marked\\"], \\"Window\\"->win];\\n    ];\\n  ];\\n\\n \\n  Graphics[{\\n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[-2 0.5, t]]], \\n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[+2 0.25, t]]],\\n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[0, t]]],    \\n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[-2 0.25, t]]], \\n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[+2 0.5, t]]],    \\n\\n    Plot[land[x], {x,-20,80}]//First,\\n\\n    MetaMarker[\\"marked\\"],\\n\\n    EventHandler[Graphics`Canvas[], {\\n      \\"capturekeydown\\" -> Function[value, \\n        Switch[value,\\n          \\"ArrowRight\\",\\n            target = target + 1;\\n            camera;\\n            wake;\\n          ,  \\n          \\"ArrowLeft\\",\\n            target = target - 1;\\n            camera;\\n            wake;\\n          ,\\n          _,\\n            Null\\n        ];\\n        EventFire[ev, Null]\\n      ]\\n    }]\\n  }, PlotRange->{{0, 30}, {0, 20}}, ImagePadding->None]\\n]\\n```\\n\\nHere we also animate the view of the canvas and pan it to keep our spider in the center of the screen. To achieve that we mark the graphics with `MetaMarker` and then execute in its context `ZoomAt` function, which affects the state of an existing `Graphics` container.\\n\\n*The result*\\n\\n![](./../spider-ezgif.com-crop.gif)\\n\\n*focus on a canvas with your mouse and control the spider using arrow keys*\\n\\nNotebook is available by the link below\\n\\n [__Spider.wln__](./Spider.wln)"},{"id":"image-trace","metadata":{"permalink":"/blog/image-trace","source":"@site/blog/2024-04-13-imagetrace/index.md","title":"Image tracing and animation","description":"The notebook focuses on tracing and animating the contours of GIF images using WLJS Notebook.","date":"2024-04-13T00:00:00.000Z","tags":[{"label":"animation","permalink":"/blog/tags/animation"}],"readingTime":2.58,"hasTruncateMarker":true,"authors":[{"name":"Kirill Vasin","title":"Maintainer","url":"https://github.com/JerryI","imageURL":"https://avatars.githubusercontent.com/u/4111822?s=48&v=4","key":"jerryi"}],"frontMatter":{"authors":"jerryi","enableComments":true,"slug":"image-trace","tags":["animation"]},"unlisted":false,"prevItem":{"title":"Procedural spider animation","permalink":"/blog/spider"},"nextItem":{"title":"Image and Raster were implemented!","permalink":"/blog/imageraster"}},"content":"The notebook focuses on tracing and animating the contours of GIF images using WLJS Notebook.\\n\\nFirstly, import as a usual file\\n\\n```mathematica @\\nimgs = (*BB[*)(* Drag and drop your gif here *)(*,*)(*\\"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU=\\"*)(*]BB*);\\n```\\n\\nNow in `imgs` we have a sequence of images. In our case this is a dinosaur \\n\\n![giphy](./../giphy.gif)\\n\\n*the source is unknown, sorry*\\n\\n\x3c!--truncate--\x3e\\n\\nTo trace all contours we adapt a method from @anderstood on StackExchange\\n\\nA custom function `trace[ii_]` is defined to process each image frame. \\n\\n```mathematica\\ntrace[ii_] :=\\nModule[{img, pts, z, m, n, cn, f, g}, \\n  img = ii;\\n  img = Binarize[img~ColorConvert~\\"Grayscale\\"~ImageResize~500~Blur~3];\\n  pts = DeleteDuplicates@Cases[Normal@ListContourPlot[Reverse@ImageData[img], \\n       Contours -> {0.5}], _Line, -1][[1, 1]];\\n\\n  z = pts[[All, 1]] + I*pts[[All, 2]];\\n  m = 50;\\n  n = Length@z;\\n  cn = 1/n*Table[Sum[z[[k]]*Exp[-I*i*k*2 Pi/n], {k, 1, n}], {i, -m, m}];\\n{f[t_], g[t_]} = {Re@#, Im@#} &@\\n    Sum[cn[[i + m + 1]]*Exp[I*i*t], {i, -m, m}] // ComplexExpand;\\n  Function[t, {f[t], g[t]}]\\n]\\n```\\n\\nIn a nutshell it does:\\n\\n- Binarizes and processes the image.\\n- Extracts contour points using the data from `ListContourPlot` (kinda a hack \ud83d\ude03).\\n- Performs Fourier analysis to create a smooth curve representation.\\n- Returns a parameterized function of the contour.\\n\\n## Frame processing\\n\\nThen we need to process each frame like that\\n\\n```mathematica\\nframes = Map[With[{f = trace[#]}, \\n  Table[f[p], {p,0,2Pi,0.01}]\\n]&, imgs];\\n```\\n*it might take a while*\\n\\nThe processed frames are animated with a slider as follows\\n\\n```mathematica\\ncurrentFrame = frames // First;\\n\\nEventHandler[InputRange[1,Length[imgs], 1, 1], Function[v, \\n\\tcurrentFrame = frames[[v]]\\n]]\\n\\nGraphics[Line[currentFrame // Offload]]\\n```\\n\\n![](./../dino66-ezgif.com-optimize.gif)\\n\\nHowever we can go further and analyze each color plotting a separate curve for it.\\n\\n## Color separation\\nTo find dominant colors use can follows this approach\\n\\n```mathematica\\nimg = imgs // First;\\n\\n(* Convert Image Data to a List of Colors *)\\ncolors = ImageData[ImageResize[img, 200], \\"Byte\\"];\\ncolorsList = Flatten[colors, 1];\\n\\n(* Cluster Colors Using KMeans *)\\nclusters = FindClusters[colorsList, 4, Method -> \\"KMeans\\"];\\n\\n(* Extract and Visualize Dominant Colors *)\\ndominantColors = Map[Mean, clusters];\\ndominantColors = Select[dominantColors, Norm[#[[;;3]]]>10 &];\\ndominantColorsRGB = RGBColor /@ (dominantColors / 255)\\n```\\n\\nas a result we have\\n\\n```mathematica @\\n{(*VB[*)(RGBColor[{116204/126735, 124/1207, 72346/126735, 42004/42245}])(*,*)(*\\"1:eJxTTMoPSmNkYGAoZgESHvk5KRCeGJAIcndyzs/JLwouTyxJzghJzS3ISSxJhchzIMmnscD0+2QWlxTZKJU89Qx/a1/0ZMq5uOM+u+yLOvoO8ca4PLIv6jo5T9Hl4nt7AA1hJUk=\\"*)(*]VB*),(*VB[*)(RGBColor[{1339/159154, 277964/397885, 35905/477462, 2365267/2387310}])(*,*)(*\\"1:eJxTTMoPSmNkYGAoZgESHvk5KRCeGJAIcndyzs/JLwouTyxJzghJzS3ISSxJhchzIMmnscD0+2QWlxT5pez1+GrVaF9kfnJb/beoZ/ZFE7K2LfZ02GxftJy9VDVmy3t7AA3lJL8=\\"*)(*]VB*),(*VB[*)(RGBColor[{19736/26295, 128738/149005, 163801/447015, 443111/447015}])(*,*)(*\\"1:eJxTTMoPSmNkYGAoZgESHvk5KRCeGJAIcndyzs/JLwouTyxJzghJzS3ISSxJhchzIMmnscD0+2QWlxSFXeRLmsHywr6Is/vVmkNLX9sX/V+y9fOi4uv2RYeX1veU7HhvDwAkIidz\\"*)(*]VB*)}\\n```\\n\\nOn the next step we will convolve those colors with an image\\n\\n```mathematica\\nClamp[val_List, max_] := Clamp[val//First, max]\\nClamp[val_, max_] := If[val > 0.5, 1, 0] max \\n\\ncolorSeparate[img_, colors_] := Table[Map[\\n  Map[\\n    Function[pixel, \\n      Clamp[i[[;;3]] . pixel[[;;3]] / 255.0, 1]\\n    ]\\n  , #]&\\n, img // ImageData] // Image, {i, colors}]\\n```\\n\\n```mathematica\\nImageResize[#, 100] &/@ colorSeparate[img, dominantColors] \\n```\\n\\n![](./../Screenshot%202024-05-19%20at%2013.55.02.png)\\n\\n### Animating each color channel separately\\nFirstly we will apply curve extracting on each channel of the frame\\n\\n```mathematica\\nframesColored = Table[Map[With[{f = trace[#]}, \\n  Table[f[p], {p,0,2Pi,0.01}]\\n]&, colorSeparate[frame, dominantColors] ], {frame, imgs}];\\n```\\n\\n```mathematica\\ncurrentFrameColored = framesColored // First;\\n\\nEventHandler[InputRange[1,Length[imgs], 1, 1], Function[v, currentFrameColored = framesColored[[v]]]]\\n\\nGraphics[\\n  Table[\\n    With[{i=i},\\n      {dominantColorsRGB[[i]], Polygon[currentFrameColored[[i]] // Offload]}\\n    ]\\n  , {i, Length[dominantColorsRGB]}] // Reverse\\n]\\n```\\n\\nHere we use `Polygon` instead of `Line` to get filling for each closed curve. An algorithm did not work well for all colors and we effectively have only two instead of 3\\n\\n![](./../dinooo.svg)\\n\\nTry it on your images!\\n\\n[__Image tracing.wln__](./Image%20tracing.wln)"},{"id":"imageraster","metadata":{"permalink":"/blog/imageraster","source":"@site/blog/2023-09-14-image-raster/2023-08-20-image-raster.md","title":"Image and Raster were implemented!","description":"It means, MatrixPlot as well as Rasterize can work properly finally","date":"2023-08-20T00:00:00.000Z","tags":[{"label":"graphics","permalink":"/blog/tags/graphics"}],"readingTime":0.73,"hasTruncateMarker":true,"authors":[{"name":"Kirill Vasin","title":"Maintainer","url":"https://github.com/JerryI","imageURL":"https://avatars.githubusercontent.com/u/4111822?s=48&v=4","key":"jerryi"}],"frontMatter":{"slug":"imageraster","title":"Image and Raster were implemented!","authors":"jerryi","tags":["graphics"],"enableComments":true,"draft":false},"unlisted":false,"prevItem":{"title":"Image tracing and animation","permalink":"/blog/image-trace"},"nextItem":{"title":"Realtime path-tracing","permalink":"/blog/rtx-intro"}},"content":"![](plot.svg)\\n\\n```mathematica\\nMatrixPlot[\\n Fourier[Table[\\n   UnitStep[i, 4 - i] UnitStep[j, 7 - j], {i, -25, 25}, {j, -25, \\n    25}]]]\\n```\\nIt means, `MatrixPlot` as well as `Rasterize` can work properly finally\\n\\n\x3c!--truncate--\x3e\\n\\n\\n\\n## Raster\\n\\n`MatrixPlot` produces `Graphics` with `Raster` inside. However, similar function `ArrayPlot` __won\'t work properly__ since it doesn\'t provide the `PlotRange` option.\\n\\nIn my implementation of `Graphics` it cannot guess what the plot range would be. Therefore you have to manually provide it. For example\\n\\n```mathematica\\nGraphics[{\\n\\tRaster[Table[{x, y, x, y}, {x, .1, 1, .1}, {y, .1, 1, .1}]]}\\n\\t, PlotRange->{{0.1,10}, {0.1,10}\\n}]\\n```\\n\\n\\n\\nHere `PlotRange` is necessary, otherwise it will be set to `{-1,1}`.\\n\\n## Image\\nThis is actually a separate entity, that uses HTML5 canvas\\n> despite this fact, you can still easily embed it into `Graphics` using `Inset` wrapper\\n\\n\\n\\nPlease see __Reference__ section in the frontend docs for more information. See Ya!"},{"id":"rtx-intro","metadata":{"permalink":"/blog/rtx-intro","source":"@site/blog/2023-07-20-rtx/index.md","title":"Realtime path-tracing","description":"There is nothing more exciting in programming than designing a graphics application. Thankfully, there is one person on Github Garrett Johnson, who implemented a path-tracing algorithm on top of the well-known THREE.js graphics engine. Moreover, it fully supports features from the original library and can be anytime flipped as a main renderer.","date":"2023-07-20T00:00:00.000Z","tags":[{"label":"frontend","permalink":"/blog/tags/frontend"},{"label":"graphics","permalink":"/blog/tags/graphics"}],"readingTime":2.05,"hasTruncateMarker":true,"authors":[{"name":"Kirill Vasin","title":"Maintainer","url":"https://github.com/JerryI","imageURL":"https://avatars.githubusercontent.com/u/4111822?s=48&v=4","key":"jerryi"}],"frontMatter":{"slug":"rtx-intro","title":"Realtime path-tracing","authors":"jerryi","tags":["frontend","graphics"],"enableComments":true},"unlisted":false,"prevItem":{"title":"Image and Raster were implemented!","permalink":"/blog/imageraster"}},"content":"![](Screenshot%20from%202023-07-20%2020-04-08.png)\\n\\nThere is nothing more exciting in programming than designing a graphics application. Thankfully, there is one person on Github [Garrett Johnson](https://github.com/gkjohnson), who implemented a path-tracing algorithm on top of the well-known [THREE.js](https://threejs.org) graphics engine. Moreover, it fully supports features from the original library and can be anytime flipped as a main renderer.\\n\\n\x3c!--truncate--\x3e\\n\\nI hooked up his [library](https://github.com/gkjohnson/three-gpu-pathtracer) to works as a secondary engine for `Graphics3D` function presented in [wljs-graphics3d-threejs](https://github.com/JerryI/Mathematica-ThreeJS-graphics-engine) library. Just pass an option\\n\\n```mathematica\\nGraphics3D[%, \\"RTX\\"->True]\\n```\\n\\nAnd it will bake a realtime photorealistic image. It also supports all properties used in traditional rendering, i.e. `Emissive[]`, `Metallness[]`, HDRI map and many more!\\n\\nSome classical examples from Wolfram Mathematica\\n\\n![](IMG_0556.png)\\n\\n\\n![](screenshot(8)%201.png)\\n\\nYou might recognize those examples from `Graphics3D` official documentation page. Here is some other neat pictures produced using the following code\\n\\n### Metallic maze\\nThis was taken from the discussion [here](https://mathematica.stackexchange.com/questions/191047/making-holes-from-maze-generated-graphics3d). The maze is made from many polygons, where for the surface `Metallness[1], Roughness[0]` were applied. Since it provides perfect reflection, the overall time for rendering (when the noise has gone) is relatively low.\\n\\n```mathematica\\nshowmaze = Uncompress[FromCharacterCode @@ ImageData[Import[\\"https://i.stack.imgur.com/XVJcP.png\\"], \\"Byte\\"]];\\nprims = CapsuleShape @@@ Cases[showmaze, _Cylinder, Infinity];\\nprims = prims /. {{5., 5., 5.} -> {5.5, 5., 5.}, {1., 1., 1.} -> {1., 0.5, 1.}};\\nims = RegionImage[#, {{0.3`, 5.7`}, {0.3`, 5.7`}, {0.3`, 5.7`}}, RasterSize -> 100] & /@ prims;\\nim = ImageApply[Max, ims];\\n```\\n\\nThen, the generated mesh is lit by `lighting` arrays, which contain randomly distributed glowing spheres\\n\\n```mathematica\\nlighting = Table[{Emissive[RGBColor@@(RandomReal[{0,1}, 3]), 2], Sphere[RandomReal[{1,92}, 3], RandomReal[{1,7}]]}, {i, 1, 30}];\\nShow[bmr = ImageMesh[im, Method -> \\"DualMarchingCubes\\"], PlotRange -> {{0, 91}, {1, 92}, {0, 91}}][[1]];\\nGraphics3D[{lighting, Metalness[0], Roughness[0], %},  \\"Lighting\\"->None, ViewProjection->\\"Perspective\\", \\"RTX\\"->True]\\n```\\n\\n\\n![](screenshot(12).png)\\n\\nDespite the complicity of the scene, __it renders in real time__ with an acceptable amount of noise.\\n\\n### Torus Knot\\nThis is rather classical example, but uses a glossy surface using `Roughness[0]` lit by two glowing spheres\\n\\n```mathematica\\nKnotData[{\\"TorusKnot\\", {3, 5}}][[1]];\\nGraphics3D[{{Emissive[Red, 5], Sphere[{0,0,-0.1}, 0.14]}, {Roughness[0],Cyan, %}, {Emissive[RGBColor[{1,1,1}], 5], Sphere[{0,0,0.4}, 0.1]}}, Lighting->None, \\"RTX\\"->True]\\n```\\n\\nHere is the result\\n\\n![](screenshot(13).png)\\n\\nLooks like a dream...\\n\\n## Limitations\\n- The dynamic scenes now are not supported, but can be added in theory according to the documentation of the path-rendering library. \\n- Requires a dedicated GPU (actually with my Intel UHD integrated graphics it works, but demands an extremely long time to compile shaders to start rendering). However, iPhones, Androids can still handle not very complicated scenes.\\n- Safari crashes (Firefox, Chrome, Vivaldi work well)"}]}}')}}]);