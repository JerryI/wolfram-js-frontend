"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[2272],{9828:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var i=t(17624),a=t(4552);const r={authors:"jerryi",tags:["animation"],enableComments:!0,slug:"spider"},o="Procedural spider animation",s={permalink:"/blog/spider",source:"@site/blog/2024-04-19-spider/index.md",title:"Procedural spider animation",description:'I have been always amazed by a fascinating procedural animation using in some games like Rain World. The key feature there is that you define sort of a target points for a model and a clever algorithm figures out the way how each bone or "leg" will move to achieve the goal. This is a common problem of kinematics. Let\'s start with the simplest approach',date:"2024-04-19T00:00:00.000Z",tags:[{label:"animation",permalink:"/blog/tags/animation"}],readingTime:4.55,hasTruncateMarker:!0,authors:[{name:"Kirill Vasin",title:"Maintainer",url:"https://github.com/JerryI",imageURL:"https://avatars.githubusercontent.com/u/4111822?s=48&v=4",key:"jerryi"}],frontMatter:{authors:"jerryi",tags:["animation"],enableComments:!0,slug:"spider"},unlisted:!1,nextItem:{title:"Image tracing and animation",permalink:"/blog/image-trace"}},l={authorsImageUrls:[void 0]},c=[{value:"Cycloid",id:"cycloid",level:2},{value:"FABRIK Inverse\xa0Kinematics",id:"fabrik-inversekinematics",level:2},{value:"Modelling legs",id:"modelling-legs",level:2},{value:"Adding controls",id:"adding-controls",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.M)(),...e.components},{CodeMirror:r,Wl:o}=n;return r||g("CodeMirror",!0),o||g("Wl",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:t(59072).c+"",width:"596",height:"394"})}),"\n",(0,i.jsxs)(n.p,{children:["I have been always amazed by a fascinating procedural animation using in some games like ",(0,i.jsx)(n.em,{children:"Rain World"}),'. The key feature there is that you define sort of a target points for a model and a clever algorithm figures out the way how each bone or "leg" will move to achieve the goal. This is a common problem of kinematics. Let\'s start with the simplest approach']}),"\n",(0,i.jsx)(n.h2,{id:"cycloid",children:"Cycloid"}),"\n",(0,i.jsx)(n.p,{children:"If we roll a ball over a plane surface with attached marker at the side it will produce a well-known curve"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mathematica",children:"ParametricPlot[{x - Sin[x], 1 - Cos[x]}, {x,0,6Pi}]\n"})}),"\n",(0,i.jsx)(o,{children:"ParametricPlot[{x - Sin[x], 1 - Cos[x]}, {x,0,6Pi}]"}),"\n",(0,i.jsx)(n.p,{children:"Imagine it it were legs, which would follow multiple cycloids with a little offset. But firstly, we should get rid of a plane ground and turn it into something more interesting"}),"\n",(0,i.jsx)(r,{children:"land[x_] := 5.0 + (*FB[*)((Sin[x])(*,*)/(*,*)(10.0))(*]FB*) + Cos[(*FB[*)((x)(*,*)/(*,*)(10.0))(*]FB*)] x + (*FB[*)(((*SpB[*)Power[x(*|*),(*|*)2](*]SpB*))(*,*)/(*,*)(100.0))(*]FB*)\n\nParametricPlot[{x, land[x]}, {x,-20,80}]"}),"\n",(0,i.jsx)(o,{children:"ParametricPlot[{x, 5.0 + (*FB[*)((Sin[x])(*,*)/(*,*)(10.0))(*]FB*) + Cos[(*FB[*)((x)(*,*)/(*,*)(10.0))(*]FB*)] x + (*FB[*)(((*SpB[*)Power[x(*|*),(*|*)2](*]SpB*))(*,*)/(*,*)(100.0))(*]FB*)}, {x,-20,80}]"}),"\n",(0,i.jsxs)(n.p,{children:["To project cycloid onto ",(0,i.jsx)(n.code,{children:"land"})," curve, we could not find anything better, that to offset ",(0,i.jsx)(n.code,{children:"y"})," axis"]}),"\n",(0,i.jsx)(r,{children:"ParametricPlot[\n  With[{b = land[x]}, {\n    {x, b},\n    {(*FB[*)(((4x - Sin[4x]))(*,*)/(*,*)(4))(*]FB*), b + 1 - Cos[4x]}\n  }\n] // Evaluate, {x,-20,80}]"}),"\n",(0,i.jsx)(o,{children:"ListLinePlot[Table[With[{b = 5.0 + ((Sin[x])/(10.0)) + Cos[((x)/(10.0))] x + ((Power[x,2])/(100.0))}, {{x, b},{(((4x - Sin[4x]))/(4)), b + 1 - Cos[4x]}}] , {x,-20,80, 0.2}]//Transpose]"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"try to zoom in with a mouse"})}),"\n",(0,i.jsx)(n.h2,{id:"fabrik-inversekinematics",children:"FABRIK Inverse\xa0Kinematics"}),"\n",(0,i.jsxs)(n.p,{children:["Legs of a spider are not straight lines, and consists of small segments needed to be animated separately. For this case there is a nice heuristic algorithm ",(0,i.jsx)(n.a,{href:"http://www.andreasaristidou.com/FABRIK.html",children:"FABRIK"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"I do not claim that my implementation is most optimized, but it does solve a problem"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mathematica",children:"ClearAll[cached];\ncached[expr_] := cached[expr] = expr;\nSetAttributes[cached, HoldAll]\n\nSetAttributes[fabrik, HoldFirst]\n\nfabrik[chain_, target_, origin_] := Module[{\n\tbuffer, prev, \n\tlengths = cached[Norm /@ (chain // Reverse // Differences) // Reverse]\n},\n  buffer = Table[With[{p = chain[[-i]]},\n    If[i === 1,\n      prev = target;\n      target\n    ,\n    \n      prev = prev - Normalize[(prev - p)] lengths[[1-i]];\n      prev \n    ]\n  ], {i, chain // Length}] // Reverse;\n\n  chain = Table[With[{p = buffer[[i]]},\n    If[i === 1,\n      prev = origin;\n      origin\n    ,\n    \n      prev = prev - Normalize[(prev - p)] lengths[[i-1]];\n      prev \n    ]\n  ], {i, chain // Length}];\n]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let us see how it works in the following example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mathematica",children:'chain = {{0,0}, {0.5,1}, {1,1}, {1,0.5}};\n\nGraphics[{\n  Line[chain // Offload],\n  EventHandler[Graphics`Canvas[], {"mousemove" -> Function[xy,\n    fabrik[chain, xy, {0,0}]\n  ]}]\n}]\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:t(54784).c+"",width:"604",height:"406"})}),"\n",(0,i.jsx)(n.p,{children:"The next idea will be to assign the target position of each leg to a cycloid."}),"\n",(0,i.jsx)(n.h2,{id:"modelling-legs",children:"Modelling legs"}),"\n",(0,i.jsx)(n.p,{children:"We can isolate our a leg into a independent component, hence it would be easier to combine them together"}),"\n",(0,i.jsx)(r,{children:'leg[event_String, target_, origin_] := Module[{\n  (*BB[*)(* initial leg segments *)(*,*)(*"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU="*)(*]BB*)\n  chain = Table[k(target - origin) + origin, {k, -0.6, 1.6, 0.4}]\n},\n  (*BB[*)(* subscribe to an update *)(*,*)(*"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU="*)(*]BB*)\n  With[{cloned = EventClone[event]},    \n    EventHandler[cloned, Function[Null,\n      fabrik[chain, target, origin]\n    ]];\n  ];\n\n  Offload[chain]\n]\n\nSetAttributes[leg, HoldRest];'}),"\n",(0,i.jsxs)(n.p,{children:["here the first argument specifies an ",(0,i.jsx)(n.code,{children:"EventObject"})," identifier, that will be called later on to update all legs segments in the animation loop."]}),"\n",(0,i.jsx)(n.p,{children:"Now we can combine multiple legs, which target's variables will follows cycloids with small offsets as follows"}),"\n",(0,i.jsx)(r,{children:"getTarget[xoffset_, x_] := With[{b = land[x + xoffset]}, \n  {\n    (*FB[*)(((4(x + xoffset) - Sin[4(x + xoffset)]))(*,*)/(*,*)(4))(*]FB*), \n    b + 1 - Cos[4(x + xoffset)]\n  }\n]"}),"\n",(0,i.jsx)(r,{children:'Module[{t = 4.0 (*BB[*)(*x-position of a spider*)(*,*)(*"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU="*)(*]BB*), ev = CreateUUID[]},\n {\n  Graphics[{\n    Line[leg[ev, {t,1 + land[t]}, getTarget[-0.5, t]]], \n    Line[leg[ev, {t,1 + land[t]}, getTarget[+0.25, t]]],\n    Line[leg[ev, {t,1 + land[t]}, getTarget[0, t]]],    \n    Line[leg[ev, {t,1 + land[t]}, getTarget[-0.25, t]]], \n    Line[leg[ev, {t,1 + land[t]}, getTarget[+0.5, t]]],    \n    \n    (*BB[*)(* ground curve *)(*,*)(*"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU="*)(*]BB*)\n    Plot[land[x], {x,0,20}]//First \n  }],\n\n  EventHandler[InputRange[0,10, 0.1], Function[value, t = value; EventFire[ev, Null]]]\n } // Row \n]'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:t(30052).c+"",width:"1386",height:"522"})}),"\n",(0,i.jsx)(n.h2,{id:"adding-controls",children:"Adding controls"}),"\n",(0,i.jsxs)(n.p,{children:["Slides are boring. Using ",(0,i.jsx)(n.code,{children:"Graphics`Canvas[]"})," with ",(0,i.jsx)(n.code,{children:"EventHandler"})," we can capture arrow keys and animate accordingly. However, to animate continuously we can set a timer and remove it once the target position of a spider has been reached"]}),"\n",(0,i.jsx)(r,{children:'Module[{\n  t = 4.0, \n  ev = CreateUUID[], \n  target = 4.0, task = Null, \n  wake, sleep, view = {0,0}, \n  win = CurrentWindow[]\n},\n\n  (*BB[*)(* using linear interpolation animate to the target*)(*,*)(*"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU="*)(*]BB*)\n  wake := If[task === Null, task = SetInterval[\n    t = t + 0.1 (target - t);\n    EventFire[ev, Null];\n    \n    If[Abs[t - target] < 0.01, sleep];\n  , 30]];\n\n  sleep := With[{},\n    TaskRemove[task];\n    task = Null;\n  ];\n\n  (*BB[*)(* animate the camera by view of the canvas *)(*,*)(*"1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU="*)(*]BB*)\n  camera := With[{center = (*FB[*)(({30,20})(*,*)/(*,*)(2))(*]FB*) + view, spider = {t, land[t]}},\n    If[Norm[center - spider] > 10, \n      view = (center - spider)/2;\n      FrontSubmit[ZoomAt[1, -view], MetaMarker["marked"], "Window"->win];\n    ];\n  ];\n\n \n  Graphics[{\n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[-2 0.5, t]]], \n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[+2 0.25, t]]],\n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[0, t]]],    \n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[-2 0.25, t]]], \n    Line[leg[ev, {t,1.5 + land[t]}, getTarget[+2 0.5, t]]],    \n\n    Plot[land[x], {x,-20,80}]//First,\n\n    MetaMarker["marked"],\n\n    EventHandler[Graphics`Canvas[], {\n      "capturekeydown" -> Function[value, \n        Switch[value,\n          "ArrowRight",\n            target = target + 1;\n            camera;\n            wake;\n          ,  \n          "ArrowLeft",\n            target = target - 1;\n            camera;\n            wake;\n          ,\n          _,\n            Null\n        ];\n        EventFire[ev, Null]\n      ]\n    }]\n  }, PlotRange->{{0, 30}, {0, 20}}, ImagePadding->None]\n]'}),"\n",(0,i.jsxs)(n.p,{children:["Here we also animate the view of the canvas and pan it to keep our spider in the center of the screen. To achieve that we mark the graphics with ",(0,i.jsx)(n.code,{children:"MetaMarker"})," and then execute in its context ",(0,i.jsx)(n.code,{children:"ZoomAt"})," function, which affects the state of an existing ",(0,i.jsx)(n.code,{children:"Graphics"})," container."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"The result"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:t(59072).c+"",width:"596",height:"394"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"focus on a canvas with your mouse and control the spider using arrow keys"})}),"\n",(0,i.jsx)(n.p,{children:"Notebook is available by the link below"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(33710).c+"",children:(0,i.jsx)(n.strong,{children:"Spider.wln"})})})]})}function h(e={}){const{wrapper:n}={...(0,a.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function g(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},33710:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/files/Spider-41586fdedb28cb1c92361bdf8beedef5.wln"},30052:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/Screenshot 2024-05-19 at 16.10.26-a26b99795275884ef26e2c4d3b0af9dd.png"},59072:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/spider-ezgif.com-crop-aee9fb4d1f59d68177bb6663c1fbb22a.gif"},54784:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/tricks-ezgif.com-optimize-e4b273a3ee3af9fe054fd4dd8436dbc6.gif"},4552:(e,n,t)=>{t.d(n,{I:()=>s,M:()=>o});var i=t(11504);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);