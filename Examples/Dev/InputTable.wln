<|"notebook" -> <|"name" -> "Autodidact", "id" -> "outrun-5b9b9", 
   "kernel" -> LocalKernel, "objects" -> <||>, 
   "path" -> "/Volumes/Data/Temporary/InputTable.wln", "cell" :> Exit[], 
   "date" -> DateObject[{2023, 10, 16, 16, 57, 2.907302`7.216065135665663}, 
     "Instant", "Gregorian", 2.], "symbols" -> <||>, 
   "channel" -> WebSocketChannel[
     KirillBelov`WebSocketHandler`WebSocketChannel`$23], 
   "SelectedCell" -> "8f4b173e-6867-4e9f-97ad-8e6ee5033ec0"|>, 
 "cells" -> {<|"id" -> "3e3046f9-ecbd-45a1-8fc4-705a8ad35ef1", 
    "type" -> "input", "data" -> "NPM[\"handsontable\"] // Install ", 
    "display" -> "codemirror", "sign" -> "outrun-5b9b9", 
    "props" -> <|"hidden" -> False|>|>, 
   <|"id" -> "5aa26811-db30-49ea-b302-2ada2654e584", "type" -> "output", 
    "data" -> "FrontEndBox[\"\", \
\"1:eJxTTMoPSmNkYGAoZgESHvk5KWlMIB4HkAguqcxJdcqvgIiA5INKc1KLuYAMp8Tk7PSi/NK8l\
DRmmPIgdyfn/Jz8okyQcUXGYPDaHs5AM4UHbEFRZoF/nmdeQWlJMStQwC0xpzgVAFxJIrc=\"]", 
    "display" -> "codemirror", "sign" -> "outrun-5b9b9", 
    "props" -> <|"hidden" -> False|>|>, 
   <|"id" -> "c744bd53-4eae-4d73-9624-ac02c1c6ea46", "type" -> "input", 
    "data" -> "SetEnvironment[\"PATH\"->\"/Library/Frameworks/Python.framewor\
k/Versions/3.10/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin\
:/Library/Apple/usr/bin\"]", "display" -> "codemirror", 
    "sign" -> "outrun-5b9b9", "props" -> <|"hidden" -> False|>|>, 
   <|"id" -> "3e4eb1c6-bbaf-4483-888a-0aacf9d8afcb", "type" -> "input", 
    "data" -> ".md\nHTML element", "display" -> "codemirror", 
    "sign" -> "outrun-5b9b9", "props" -> <|"hidden" -> True|>|>, 
   <|"id" -> "8f4b173e-6867-4e9f-97ad-8e6ee5033ec0", "type" -> "input", 
    "data" -> ".html\n<link rel=\"stylesheet\" \
href=\"node_modules/handsontable/dist/handsontable.min.css\" />\n\n<div \
id=\"tab\"></div>", "display" -> "codemirror", "sign" -> "outrun-5b9b9", 
    "props" -> <|"hidden" -> False|>|>, 
   <|"id" -> "f0611e70-f122-448b-874b-7c48d023ac37", "type" -> "output", 
    "data" -> "\n<link rel=\"stylesheet\" \
href=\"node_modules/handsontable/dist/handsontable.min.css\" />\n\n<div \
id=\"tab\"></div>", "display" -> "html", "sign" -> "outrun-5b9b9", 
    "props" -> <|"hidden" -> False|>|>, 
   <|"id" -> "fc049716-9d79-4e12-a13f-bbbd28040129", "type" -> "input", 
    "data" -> ".md\na test module", "display" -> "codemirror", 
    "sign" -> "outrun-5b9b9", "props" -> <|"hidden" -> True|>|>, 
   <|"id" -> "6491c0d4-626d-45a4-ba57-f54f5d11f6f3", "type" -> "output", 
    "data" -> "\na test module", "display" -> "markdown", 
    "sign" -> "outrun-5b9b9", "props" -> <|"hidden" -> False|>|>, 
   <|"id" -> "bc2200cb-3723-46e1-a641-bc0031689920", "type" -> "input", 
    "data" -> ".esm\n\nimport Handsontable from \"handsontable\";\n//import \
\"handsontable/dist/handsontable.min.css\";\n//import \
\"pikaday/css/pikaday.css\";\n\nconst data = [];\n\nfor (let i = 0; i < 1500; \
++i) {\n  data.push([i, Math.random(), Math.random()]);\n}\n\nconst loadData \
= (offset, window) => {\n  const res = [];\n  if (offset + window > \
data.length) return 'EOF';\n  const size = Math.min(offset + window, \
data.length);\n  for (let i = offset; i < size; ++i) {\n    \
res.push(data[i]);\n  }\n  return [size - offset, res];\n}\n\nconst parent = \
document.getElementById('tab');\nparent.style.maxHeight = \
'400px';\nparent.style.position = \"relative\";\nparent.style.display = \
\"block\";\nparent.innerHTML = '';\n\nconst example = \
document.createElement('div');\nparent.appendChild(example);\n\n\n\n\nexample\
.position = \"relative\";\nexample.display = \"block\";\n\nconst \
bufferMaxSize = 150;\nconst initial = loadData(0, bufferMaxSize);\nlet \
bufferSize = initial[0];\n\nlet offset = 0;\n\nconst hot = new \
Handsontable(example, {\n  data: initial[1],\n  height: '100%',\n  \
multiColumnSorting: true,\n  filters: true,\n  rowHeaders: (i) => {\n    \
return String(offset + i)\n    \n  },\n  manualRowMove: true,\n  \
renderAllRows: false,\n  contextMenu: true,\n\n  licenseKey: \
\"non-commercial-and-evaluation\",\n  afterChange: function (change, source) \
{\n    if (source === 'loadData') {\n      return; //don't save this change\n \
   }\n\n    console.log(change);\n    \
//clearTimeout(autosaveNotification);\n\n    \n  }\n  \n});\n\n\n\nconst \
shift = 50;\n\nhot.addHook(\"afterScrollVertically\", function(){\n  const \
last = hot.getPlugin('AutoRowSize').getLastVisibleRow();\n  const first = \
hot.getPlugin('AutoRowSize').getFirstVisibleRow();\n  \n  if (last >= \
bufferSize - 1) {\n\n\n    const newData = loadData(offset + shift, \
bufferMaxSize);\n    if (newData === 'EOF') {\n      console.log('EOF');\n    \
  return;\n    }\n\n    bufferSize = newData[0];\n    \n    offset += \
shift;\n    \n    hot.suspendRender();\n    hot.updateSettings({\n    \
\t\t\tdata: newData[1]\n    \t\t});\n    hot.scrollViewportTo(first - \
shift);\n    hot.resumeRender();\n    \n  }\n\n  if (offset > 0 && first < 1) \
{\n    offset -= shift;\n    \n    const newData = loadData(offset, \
bufferMaxSize);\n    bufferSize = newData[0];\n    \n    \
hot.suspendRender();\n    hot.updateSettings({\n    \t\t\tdata: newData[1]\n  \
  \t\t});\n    hot.scrollViewportTo(first + shift);\n    hot.resumeRender();  \
  \n  }\n\n  \n\n      \n  });\n\n\n", "display" -> "codemirror", 
    "sign" -> "outrun-5b9b9", "props" -> <|"hidden" -> False|>|>, 
   <|"id" -> "728d48bf-a038-4037-b94f-8c06d1ee72e6", "type" -> "output", 
    "data" -> "var __create = Object.create;\nvar __defProp = \
Object.defineProperty;\nvar __getOwnPropDesc = \
Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = \
Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar \
__hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) \
=> function __require() {\n  return mod || (0, \
cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), \
mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in \
all)\n    __defProp(target, name, { get: all[name], enumerable: true \
});\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && \
typeof from === \"object\" || typeof from === \"function\") {\n    for (let \
key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key \
!== except)\n        __defProp(to, key, { get: () => from[key], enumerable: \
!(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return \
to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? \
__create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in \
node compatibility mode or this is not an ESM\n  // file that has been \
converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \
\"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \
\"module.exports\" for node compatibility.\n  isNodeMode || !mod || \
!mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: \
true }) : target,\n  mod\n));\n\n// \
node_modules/core-js/internals/global.js\nvar require_global = __commonJS({\n \
 \"node_modules/core-js/internals/global.js\"(exports, module2) {\n    \"use \
strict\";\n    var check = function(it) {\n      return it && it.Math === \
Math && it;\n    };\n    module2.exports = // eslint-disable-next-line \
es/no-global-this -- safe\n    check(typeof globalThis == \"object\" && \
globalThis) || check(typeof window == \"object\" && window) || // \
eslint-disable-next-line no-restricted-globals -- safe\n    check(typeof self \
== \"object\" && self) || check(typeof global == \"object\" && global) || // \
eslint-disable-next-line no-new-func -- fallback\n    function() {\n      \
return this;\n    }() || exports || Function(\"return this\")();\n  \
}\n});\n\n// node_modules/core-js/internals/fails.js\nvar require_fails = \
__commonJS({\n  \"node_modules/core-js/internals/fails.js\"(exports, module2) \
{\n    \"use strict\";\n    module2.exports = function(exec2) {\n      try \
{\n        return !!exec2();\n      } catch (error2) {\n        return \
true;\n      }\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/descriptors.js\nvar require_descriptors = \
__commonJS({\n  \"node_modules/core-js/internals/descriptors.js\"(exports, \
module2) {\n    \"use strict\";\n    var fails3 = require_fails();\n    \
module2.exports = !fails3(function() {\n      return \
Object.defineProperty({}, 1, { get: function() {\n        return 7;\n      } \
})[1] !== 7;\n    });\n  }\n});\n\n// \
node_modules/core-js/internals/function-bind-native.js\nvar \
require_function_bind_native = __commonJS({\n  \
\"node_modules/core-js/internals/function-bind-native.js\"(exports, module2) \
{\n    \"use strict\";\n    var fails3 = require_fails();\n    \
module2.exports = !fails3(function() {\n      var test = function() {\n      \
}.bind();\n      return typeof test != \"function\" || \
test.hasOwnProperty(\"prototype\");\n    });\n  }\n});\n\n// \
node_modules/core-js/internals/function-call.js\nvar require_function_call = \
__commonJS({\n  \"node_modules/core-js/internals/function-call.js\"(exports, \
module2) {\n    \"use strict\";\n    var NATIVE_BIND = \
require_function_bind_native();\n    var call2 = Function.prototype.call;\n   \
 module2.exports = NATIVE_BIND ? call2.bind(call2) : function() {\n      \
return call2.apply(call2, arguments);\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/object-property-is-enumerable.js\nvar \
require_object_property_is_enumerable = __commonJS({\n  \
\"node_modules/core-js/internals/object-property-is-enumerable.js\"(exports) \
{\n    \"use strict\";\n    var $propertyIsEnumerable = \
{}.propertyIsEnumerable;\n    var getOwnPropertyDescriptor = \
Object.getOwnPropertyDescriptor;\n    var NASHORN_BUG = \
getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n    \
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n      var \
descriptor = getOwnPropertyDescriptor(this, V);\n      return !!descriptor && \
descriptor.enumerable;\n    } : $propertyIsEnumerable;\n  }\n});\n\n// \
node_modules/core-js/internals/create-property-descriptor.js\nvar \
require_create_property_descriptor = __commonJS({\n  \
\"node_modules/core-js/internals/create-property-descriptor.js\"(exports, \
module2) {\n    \"use strict\";\n    module2.exports = function(bitmap, \
value) {\n      return {\n        enumerable: !(bitmap & 1),\n        \
configurable: !(bitmap & 2),\n        writable: !(bitmap & 4),\n        \
value\n      };\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/function-uncurry-this.js\nvar \
require_function_uncurry_this = __commonJS({\n  \
\"node_modules/core-js/internals/function-uncurry-this.js\"(exports, module2) \
{\n    \"use strict\";\n    var NATIVE_BIND = \
require_function_bind_native();\n    var FunctionPrototype = \
Function.prototype;\n    var call2 = FunctionPrototype.call;\n    var \
uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call2, \
call2);\n    module2.exports = NATIVE_BIND ? uncurryThisWithBind : \
function(fn) {\n      return function() {\n        return call2.apply(fn, \
arguments);\n      };\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/classof-raw.js\nvar require_classof_raw = \
__commonJS({\n  \"node_modules/core-js/internals/classof-raw.js\"(exports, \
module2) {\n    \"use strict\";\n    var uncurryThis2 = \
require_function_uncurry_this();\n    var toString = \
uncurryThis2({}.toString);\n    var stringSlice = uncurryThis2(\"\".slice);\n \
   module2.exports = function(it) {\n      return stringSlice(toString(it), \
8, -1);\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/indexed-object.js\nvar require_indexed_object \
= __commonJS({\n  \
\"node_modules/core-js/internals/indexed-object.js\"(exports, module2) {\n    \
\"use strict\";\n    var uncurryThis2 = require_function_uncurry_this();\n    \
var fails3 = require_fails();\n    var classof = require_classof_raw();\n    \
var $Object = Object;\n    var split = uncurryThis2(\"\".split);\n    \
module2.exports = fails3(function() {\n      return \
!$Object(\"z\").propertyIsEnumerable(0);\n    }) ? function(it) {\n      \
return classof(it) === \"String\" ? split(it, \"\") : $Object(it);\n    } : \
$Object;\n  }\n});\n\n// \
node_modules/core-js/internals/is-null-or-undefined.js\nvar \
require_is_null_or_undefined = __commonJS({\n  \
\"node_modules/core-js/internals/is-null-or-undefined.js\"(exports, module2) \
{\n    \"use strict\";\n    module2.exports = function(it) {\n      return it \
=== null || it === void 0;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/require-object-coercible.js\nvar \
require_require_object_coercible = __commonJS({\n  \
\"node_modules/core-js/internals/require-object-coercible.js\"(exports, \
module2) {\n    \"use strict\";\n    var isNullOrUndefined = \
require_is_null_or_undefined();\n    var $TypeError = TypeError;\n    \
module2.exports = function(it) {\n      if (isNullOrUndefined(it))\n        \
throw new $TypeError(\"Can't call method on \" + it);\n      return it;\n    \
};\n  }\n});\n\n// node_modules/core-js/internals/to-indexed-object.js\nvar \
require_to_indexed_object = __commonJS({\n  \
\"node_modules/core-js/internals/to-indexed-object.js\"(exports, module2) {\n \
   \"use strict\";\n    var IndexedObject = require_indexed_object();\n    \
var requireObjectCoercible = require_require_object_coercible();\n    \
module2.exports = function(it) {\n      return \
IndexedObject(requireObjectCoercible(it));\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/document-all.js\nvar require_document_all = \
__commonJS({\n  \"node_modules/core-js/internals/document-all.js\"(exports, \
module2) {\n    \"use strict\";\n    var documentAll = typeof document == \
\"object\" && document.all;\n    var IS_HTMLDDA = typeof documentAll == \
\"undefined\" && documentAll !== void 0;\n    module2.exports = {\n      all: \
documentAll,\n      IS_HTMLDDA\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/is-callable.js\nvar require_is_callable = \
__commonJS({\n  \"node_modules/core-js/internals/is-callable.js\"(exports, \
module2) {\n    \"use strict\";\n    var $documentAll = \
require_document_all();\n    var documentAll = $documentAll.all;\n    \
module2.exports = $documentAll.IS_HTMLDDA ? function(argument) {\n      \
return typeof argument == \"function\" || argument === documentAll;\n    } : \
function(argument) {\n      return typeof argument == \"function\";\n    };\n \
 }\n});\n\n// node_modules/core-js/internals/is-object.js\nvar \
require_is_object = __commonJS({\n  \
\"node_modules/core-js/internals/is-object.js\"(exports, module2) {\n    \
\"use strict\";\n    var isCallable2 = require_is_callable();\n    var \
$documentAll = require_document_all();\n    var documentAll = \
$documentAll.all;\n    module2.exports = $documentAll.IS_HTMLDDA ? \
function(it) {\n      return typeof it == \"object\" ? it !== null : \
isCallable2(it) || it === documentAll;\n    } : function(it) {\n      return \
typeof it == \"object\" ? it !== null : isCallable2(it);\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/get-built-in.js\nvar \
require_get_built_in = __commonJS({\n  \
\"node_modules/core-js/internals/get-built-in.js\"(exports, module2) {\n    \
\"use strict\";\n    var global3 = require_global();\n    var isCallable2 = \
require_is_callable();\n    var aFunction = function(argument) {\n      \
return isCallable2(argument) ? argument : void 0;\n    };\n    \
module2.exports = function(namespace, method) {\n      return \
arguments.length < 2 ? aFunction(global3[namespace]) : global3[namespace] && \
global3[namespace][method];\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/object-is-prototype-of.js\nvar \
require_object_is_prototype_of = __commonJS({\n  \
\"node_modules/core-js/internals/object-is-prototype-of.js\"(exports, \
module2) {\n    \"use strict\";\n    var uncurryThis2 = \
require_function_uncurry_this();\n    module2.exports = \
uncurryThis2({}.isPrototypeOf);\n  }\n});\n\n// \
node_modules/core-js/internals/engine-user-agent.js\nvar \
require_engine_user_agent = __commonJS({\n  \
\"node_modules/core-js/internals/engine-user-agent.js\"(exports, module2) {\n \
   \"use strict\";\n    module2.exports = typeof navigator != \"undefined\" \
&& String(navigator.userAgent) || \"\";\n  }\n});\n\n// \
node_modules/core-js/internals/engine-v8-version.js\nvar \
require_engine_v8_version = __commonJS({\n  \
\"node_modules/core-js/internals/engine-v8-version.js\"(exports, module2) {\n \
   \"use strict\";\n    var global3 = require_global();\n    var userAgent = \
require_engine_user_agent();\n    var process2 = global3.process;\n    var \
Deno = global3.Deno;\n    var versions = process2 && process2.versions || \
Deno && Deno.version;\n    var v8 = versions && versions.v8;\n    var \
match;\n    var version;\n    if (v8) {\n      match = v8.split(\".\");\n     \
 version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n    \
}\n    if (!version && userAgent) {\n      match = \
userAgent.match(/Edge\\/(\\d+)/);\n      if (!match || match[1] >= 74) {\n    \
    match = userAgent.match(/Chrome\\/(\\d+)/);\n        if (match)\n         \
 version = +match[1];\n      }\n    }\n    module2.exports = version;\n  \
}\n});\n\n// \
node_modules/core-js/internals/symbol-constructor-detection.js\nvar \
require_symbol_constructor_detection = __commonJS({\n  \
\"node_modules/core-js/internals/symbol-constructor-detection.js\"(exports, \
module2) {\n    \"use strict\";\n    var V8_VERSION = \
require_engine_v8_version();\n    var fails3 = require_fails();\n    var \
global3 = require_global();\n    var $String2 = global3.String;\n    \
module2.exports = !!Object.getOwnPropertySymbols && !fails3(function() {\n    \
  var symbol = Symbol(\"symbol detection\");\n      return !$String2(symbol) \
|| !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not \
inherited from DOM collections prototypes to instances\n      !Symbol.sham && \
V8_VERSION && V8_VERSION < 41;\n    });\n  }\n});\n\n// \
node_modules/core-js/internals/use-symbol-as-uid.js\nvar \
require_use_symbol_as_uid = __commonJS({\n  \
\"node_modules/core-js/internals/use-symbol-as-uid.js\"(exports, module2) {\n \
   \"use strict\";\n    var NATIVE_SYMBOL2 = \
require_symbol_constructor_detection();\n    module2.exports = NATIVE_SYMBOL2 \
&& !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n  }\n});\n\n// \
node_modules/core-js/internals/is-symbol.js\nvar require_is_symbol = \
__commonJS({\n  \"node_modules/core-js/internals/is-symbol.js\"(exports, \
module2) {\n    \"use strict\";\n    var getBuiltIn2 = \
require_get_built_in();\n    var isCallable2 = require_is_callable();\n    \
var isPrototypeOf = require_object_is_prototype_of();\n    var \
USE_SYMBOL_AS_UID = require_use_symbol_as_uid();\n    var $Object = Object;\n \
   module2.exports = USE_SYMBOL_AS_UID ? function(it) {\n      return typeof \
it == \"symbol\";\n    } : function(it) {\n      var $Symbol = \
getBuiltIn2(\"Symbol\");\n      return isCallable2($Symbol) && \
isPrototypeOf($Symbol.prototype, $Object(it));\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/try-to-string.js\nvar require_try_to_string = \
__commonJS({\n  \"node_modules/core-js/internals/try-to-string.js\"(exports, \
module2) {\n    \"use strict\";\n    var $String2 = String;\n    \
module2.exports = function(argument) {\n      try {\n        return \
$String2(argument);\n      } catch (error2) {\n        return \"Object\";\n   \
   }\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/a-callable.js\nvar require_a_callable = \
__commonJS({\n  \"node_modules/core-js/internals/a-callable.js\"(exports, \
module2) {\n    \"use strict\";\n    var isCallable2 = \
require_is_callable();\n    var tryToString = require_try_to_string();\n    \
var $TypeError = TypeError;\n    module2.exports = function(argument) {\n     \
 if (isCallable2(argument))\n        return argument;\n      throw new \
$TypeError(tryToString(argument) + \" is not a function\");\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/get-method.js\nvar \
require_get_method = __commonJS({\n  \
\"node_modules/core-js/internals/get-method.js\"(exports, module2) {\n    \
\"use strict\";\n    var aCallable = require_a_callable();\n    var \
isNullOrUndefined = require_is_null_or_undefined();\n    module2.exports = \
function(V, P) {\n      var func = V[P];\n      return \
isNullOrUndefined(func) ? void 0 : aCallable(func);\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/ordinary-to-primitive.js\nvar \
require_ordinary_to_primitive = __commonJS({\n  \
\"node_modules/core-js/internals/ordinary-to-primitive.js\"(exports, module2) \
{\n    \"use strict\";\n    var call2 = require_function_call();\n    var \
isCallable2 = require_is_callable();\n    var isObject2 = \
require_is_object();\n    var $TypeError = TypeError;\n    module2.exports = \
function(input, pref) {\n      var fn, val;\n      if (pref === \"string\" && \
isCallable2(fn = input.toString) && !isObject2(val = call2(fn, input)))\n     \
   return val;\n      if (isCallable2(fn = input.valueOf) && !isObject2(val = \
call2(fn, input)))\n        return val;\n      if (pref !== \"string\" && \
isCallable2(fn = input.toString) && !isObject2(val = call2(fn, input)))\n     \
   return val;\n      throw new $TypeError(\"Can't convert object to \
primitive value\");\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/is-pure.js\nvar require_is_pure = \
__commonJS({\n  \"node_modules/core-js/internals/is-pure.js\"(exports, \
module2) {\n    \"use strict\";\n    module2.exports = false;\n  }\n});\n\n// \
node_modules/core-js/internals/define-global-property.js\nvar \
require_define_global_property = __commonJS({\n  \
\"node_modules/core-js/internals/define-global-property.js\"(exports, \
module2) {\n    \"use strict\";\n    var global3 = require_global();\n    var \
defineProperty = Object.defineProperty;\n    module2.exports = function(key, \
value) {\n      try {\n        defineProperty(global3, key, { value, \
configurable: true, writable: true });\n      } catch (error2) {\n        \
global3[key] = value;\n      }\n      return value;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/shared-store.js\nvar require_shared_store = \
__commonJS({\n  \"node_modules/core-js/internals/shared-store.js\"(exports, \
module2) {\n    \"use strict\";\n    var global3 = require_global();\n    var \
defineGlobalProperty = require_define_global_property();\n    var SHARED = \
\"__core-js_shared__\";\n    var store = global3[SHARED] || \
defineGlobalProperty(SHARED, {});\n    module2.exports = store;\n  \
}\n});\n\n// node_modules/core-js/internals/shared.js\nvar require_shared = \
__commonJS({\n  \"node_modules/core-js/internals/shared.js\"(exports, \
module2) {\n    \"use strict\";\n    var IS_PURE = require_is_pure();\n    \
var store = require_shared_store();\n    (module2.exports = function(key, \
value) {\n      return store[key] || (store[key] = value !== void 0 ? value : \
{});\n    })(\"versions\", []).push({\n      version: \"3.33.0\",\n      \
mode: IS_PURE ? \"pure\" : \"global\",\n      copyright: \"\\xA9 2014-2023 \
Denis Pushkarev (zloirock.ru)\",\n      license: \
\"https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE\",\n      source: \
\"https://github.com/zloirock/core-js\"\n    });\n  }\n});\n\n// \
node_modules/core-js/internals/to-object.js\nvar require_to_object = \
__commonJS({\n  \"node_modules/core-js/internals/to-object.js\"(exports, \
module2) {\n    \"use strict\";\n    var requireObjectCoercible = \
require_require_object_coercible();\n    var $Object = Object;\n    \
module2.exports = function(argument) {\n      return \
$Object(requireObjectCoercible(argument));\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/has-own-property.js\nvar \
require_has_own_property = __commonJS({\n  \
\"node_modules/core-js/internals/has-own-property.js\"(exports, module2) {\n  \
  \"use strict\";\n    var uncurryThis2 = require_function_uncurry_this();\n  \
  var toObject4 = require_to_object();\n    var hasOwnProperty2 = \
uncurryThis2({}.hasOwnProperty);\n    module2.exports = Object.hasOwn || \
function hasOwn(it, key) {\n      return hasOwnProperty2(toObject4(it), \
key);\n    };\n  }\n});\n\n// node_modules/core-js/internals/uid.js\nvar \
require_uid = __commonJS({\n  \
\"node_modules/core-js/internals/uid.js\"(exports, module2) {\n    \"use \
strict\";\n    var uncurryThis2 = require_function_uncurry_this();\n    var \
id = 0;\n    var postfix = Math.random();\n    var toString = uncurryThis2(1 \
.toString);\n    module2.exports = function(key) {\n      return \"Symbol(\" \
+ (key === void 0 ? \"\" : key) + \")_\" + toString(++id + postfix, 36);\n    \
};\n  }\n});\n\n// node_modules/core-js/internals/well-known-symbol.js\nvar \
require_well_known_symbol = __commonJS({\n  \
\"node_modules/core-js/internals/well-known-symbol.js\"(exports, module2) {\n \
   \"use strict\";\n    var global3 = require_global();\n    var shared = \
require_shared();\n    var hasOwn = require_has_own_property();\n    var uid \
= require_uid();\n    var NATIVE_SYMBOL2 = \
require_symbol_constructor_detection();\n    var USE_SYMBOL_AS_UID = \
require_use_symbol_as_uid();\n    var Symbol2 = global3.Symbol;\n    var \
WellKnownSymbolsStore = shared(\"wks\");\n    var createWellKnownSymbol = \
USE_SYMBOL_AS_UID ? Symbol2[\"for\"] || Symbol2 : Symbol2 && \
Symbol2.withoutSetter || uid;\n    module2.exports = function(name) {\n      \
if (!hasOwn(WellKnownSymbolsStore, name)) {\n        \
WellKnownSymbolsStore[name] = NATIVE_SYMBOL2 && hasOwn(Symbol2, name) ? \
Symbol2[name] : createWellKnownSymbol(\"Symbol.\" + name);\n      }\n      \
return WellKnownSymbolsStore[name];\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/to-primitive.js\nvar require_to_primitive = \
__commonJS({\n  \"node_modules/core-js/internals/to-primitive.js\"(exports, \
module2) {\n    \"use strict\";\n    var call2 = require_function_call();\n   \
 var isObject2 = require_is_object();\n    var isSymbol2 = \
require_is_symbol();\n    var getMethod = require_get_method();\n    var \
ordinaryToPrimitive = require_ordinary_to_primitive();\n    var \
wellKnownSymbol = require_well_known_symbol();\n    var $TypeError = \
TypeError;\n    var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n    \
module2.exports = function(input, pref) {\n      if (!isObject2(input) || \
isSymbol2(input))\n        return input;\n      var exoticToPrim = \
getMethod(input, TO_PRIMITIVE);\n      var result;\n      if (exoticToPrim) \
{\n        if (pref === void 0)\n          pref = \"default\";\n        \
result = call2(exoticToPrim, input, pref);\n        if (!isObject2(result) || \
isSymbol2(result))\n          return result;\n        throw new \
$TypeError(\"Can't convert object to primitive value\");\n      }\n      if \
(pref === void 0)\n        pref = \"number\";\n      return \
ordinaryToPrimitive(input, pref);\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/to-property-key.js\nvar \
require_to_property_key = __commonJS({\n  \
\"node_modules/core-js/internals/to-property-key.js\"(exports, module2) {\n   \
 \"use strict\";\n    var toPrimitive = require_to_primitive();\n    var \
isSymbol2 = require_is_symbol();\n    module2.exports = function(argument) \
{\n      var key = toPrimitive(argument, \"string\");\n      return \
isSymbol2(key) ? key : key + \"\";\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/document-create-element.js\nvar \
require_document_create_element = __commonJS({\n  \
\"node_modules/core-js/internals/document-create-element.js\"(exports, \
module2) {\n    \"use strict\";\n    var global3 = require_global();\n    var \
isObject2 = require_is_object();\n    var document2 = global3.document;\n    \
var EXISTS = isObject2(document2) && isObject2(document2.createElement);\n    \
module2.exports = function(it) {\n      return EXISTS ? \
document2.createElement(it) : {};\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/ie8-dom-define.js\nvar require_ie8_dom_define \
= __commonJS({\n  \
\"node_modules/core-js/internals/ie8-dom-define.js\"(exports, module2) {\n    \
\"use strict\";\n    var DESCRIPTORS = require_descriptors();\n    var fails3 \
= require_fails();\n    var createElement2 = \
require_document_create_element();\n    module2.exports = !DESCRIPTORS && \
!fails3(function() {\n      return \
Object.defineProperty(createElement2(\"div\"), \"a\", {\n        get: \
function() {\n          return 7;\n        }\n      }).a !== 7;\n    });\n  \
}\n});\n\n// \
node_modules/core-js/internals/object-get-own-property-descriptor.js\nvar \
require_object_get_own_property_descriptor = __commonJS({\n  \
\"node_modules/core-js/internals/object-get-own-property-descriptor.js\"(expo\
rts) {\n    \"use strict\";\n    var DESCRIPTORS = require_descriptors();\n   \
 var call2 = require_function_call();\n    var propertyIsEnumerableModule = \
require_object_property_is_enumerable();\n    var createPropertyDescriptor = \
require_create_property_descriptor();\n    var toIndexedObject = \
require_to_indexed_object();\n    var toPropertyKey = \
require_to_property_key();\n    var hasOwn = require_has_own_property();\n    \
var IE8_DOM_DEFINE = require_ie8_dom_define();\n    var \
$getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    exports.f = \
DESCRIPTORS ? $getOwnPropertyDescriptor : function \
getOwnPropertyDescriptor(O, P) {\n      O = toIndexedObject(O);\n      P = \
toPropertyKey(P);\n      if (IE8_DOM_DEFINE)\n        try {\n          return \
$getOwnPropertyDescriptor(O, P);\n        } catch (error2) {\n        }\n     \
 if (hasOwn(O, P))\n        return \
createPropertyDescriptor(!call2(propertyIsEnumerableModule.f, O, P), O[P]);\n \
   };\n  }\n});\n\n// \
node_modules/core-js/internals/v8-prototype-define-bug.js\nvar \
require_v8_prototype_define_bug = __commonJS({\n  \
\"node_modules/core-js/internals/v8-prototype-define-bug.js\"(exports, \
module2) {\n    \"use strict\";\n    var DESCRIPTORS = \
require_descriptors();\n    var fails3 = require_fails();\n    \
module2.exports = DESCRIPTORS && fails3(function() {\n      return \
Object.defineProperty(function() {\n      }, \"prototype\", {\n        value: \
42,\n        writable: false\n      }).prototype !== 42;\n    });\n  \
}\n});\n\n// node_modules/core-js/internals/an-object.js\nvar \
require_an_object = __commonJS({\n  \
\"node_modules/core-js/internals/an-object.js\"(exports, module2) {\n    \
\"use strict\";\n    var isObject2 = require_is_object();\n    var $String2 = \
String;\n    var $TypeError = TypeError;\n    module2.exports = \
function(argument) {\n      if (isObject2(argument))\n        return \
argument;\n      throw new $TypeError($String2(argument) + \" is not an \
object\");\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/object-define-property.js\nvar \
require_object_define_property = __commonJS({\n  \
\"node_modules/core-js/internals/object-define-property.js\"(exports) {\n    \
\"use strict\";\n    var DESCRIPTORS = require_descriptors();\n    var \
IE8_DOM_DEFINE = require_ie8_dom_define();\n    var V8_PROTOTYPE_DEFINE_BUG = \
require_v8_prototype_define_bug();\n    var anObject = require_an_object();\n \
   var toPropertyKey = require_to_property_key();\n    var $TypeError = \
TypeError;\n    var $defineProperty = Object.defineProperty;\n    var \
$getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var \
ENUMERABLE = \"enumerable\";\n    var CONFIGURABLE = \"configurable\";\n    \
var WRITABLE = \"writable\";\n    exports.f = DESCRIPTORS ? \
V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n      \
anObject(O);\n      P = toPropertyKey(P);\n      anObject(Attributes);\n      \
if (typeof O === \"function\" && P === \"prototype\" && \"value\" in \
Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n        var \
current = $getOwnPropertyDescriptor(O, P);\n        if (current && \
current[WRITABLE]) {\n          O[P] = Attributes.value;\n          \
Attributes = {\n            configurable: CONFIGURABLE in Attributes ? \
Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n            enumerable: \
ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n    \
        writable: false\n          };\n        }\n      }\n      return \
$defineProperty(O, P, Attributes);\n    } : $defineProperty : function \
defineProperty(O, P, Attributes) {\n      anObject(O);\n      P = \
toPropertyKey(P);\n      anObject(Attributes);\n      if (IE8_DOM_DEFINE)\n   \
     try {\n          return $defineProperty(O, P, Attributes);\n        } \
catch (error2) {\n        }\n      if (\"get\" in Attributes || \"set\" in \
Attributes)\n        throw new $TypeError(\"Accessors not supported\");\n     \
 if (\"value\" in Attributes)\n        O[P] = Attributes.value;\n      return \
O;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/create-non-enumerable-property.js\nvar \
require_create_non_enumerable_property = __commonJS({\n  \
\"node_modules/core-js/internals/create-non-enumerable-property.js\"(exports, \
module2) {\n    \"use strict\";\n    var DESCRIPTORS = \
require_descriptors();\n    var definePropertyModule = \
require_object_define_property();\n    var createPropertyDescriptor = \
require_create_property_descriptor();\n    module2.exports = DESCRIPTORS ? \
function(object, key, value) {\n      return definePropertyModule.f(object, \
key, createPropertyDescriptor(1, value));\n    } : function(object, key, \
value) {\n      object[key] = value;\n      return object;\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/function-name.js\nvar \
require_function_name = __commonJS({\n  \
\"node_modules/core-js/internals/function-name.js\"(exports, module2) {\n    \
\"use strict\";\n    var DESCRIPTORS = require_descriptors();\n    var hasOwn \
= require_has_own_property();\n    var FunctionPrototype = \
Function.prototype;\n    var getDescriptor = DESCRIPTORS && \
Object.getOwnPropertyDescriptor;\n    var EXISTS = hasOwn(FunctionPrototype, \
\"name\");\n    var PROPER = EXISTS && function something() {\n    }.name === \
\"something\";\n    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS \
&& getDescriptor(FunctionPrototype, \"name\").configurable);\n    \
module2.exports = {\n      EXISTS,\n      PROPER,\n      CONFIGURABLE\n    \
};\n  }\n});\n\n// node_modules/core-js/internals/inspect-source.js\nvar \
require_inspect_source = __commonJS({\n  \
\"node_modules/core-js/internals/inspect-source.js\"(exports, module2) {\n    \
\"use strict\";\n    var uncurryThis2 = require_function_uncurry_this();\n    \
var isCallable2 = require_is_callable();\n    var store = \
require_shared_store();\n    var functionToString = \
uncurryThis2(Function.toString);\n    if (!isCallable2(store.inspectSource)) \
{\n      store.inspectSource = function(it) {\n        return \
functionToString(it);\n      };\n    }\n    module2.exports = \
store.inspectSource;\n  }\n});\n\n// \
node_modules/core-js/internals/weak-map-basic-detection.js\nvar \
require_weak_map_basic_detection = __commonJS({\n  \
\"node_modules/core-js/internals/weak-map-basic-detection.js\"(exports, \
module2) {\n    \"use strict\";\n    var global3 = require_global();\n    var \
isCallable2 = require_is_callable();\n    var WeakMap2 = global3.WeakMap;\n   \
 module2.exports = isCallable2(WeakMap2) && /native \
code/.test(String(WeakMap2));\n  }\n});\n\n// \
node_modules/core-js/internals/shared-key.js\nvar require_shared_key = \
__commonJS({\n  \"node_modules/core-js/internals/shared-key.js\"(exports, \
module2) {\n    \"use strict\";\n    var shared = require_shared();\n    var \
uid = require_uid();\n    var keys = shared(\"keys\");\n    module2.exports = \
function(key) {\n      return keys[key] || (keys[key] = uid(key));\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/hidden-keys.js\nvar \
require_hidden_keys = __commonJS({\n  \
\"node_modules/core-js/internals/hidden-keys.js\"(exports, module2) {\n    \
\"use strict\";\n    module2.exports = {};\n  }\n});\n\n// \
node_modules/core-js/internals/internal-state.js\nvar require_internal_state \
= __commonJS({\n  \
\"node_modules/core-js/internals/internal-state.js\"(exports, module2) {\n    \
\"use strict\";\n    var NATIVE_WEAK_MAP = \
require_weak_map_basic_detection();\n    var global3 = require_global();\n    \
var isObject2 = require_is_object();\n    var createNonEnumerableProperty = \
require_create_non_enumerable_property();\n    var hasOwn = \
require_has_own_property();\n    var shared = require_shared_store();\n    \
var sharedKey = require_shared_key();\n    var hiddenKeys = \
require_hidden_keys();\n    var OBJECT_ALREADY_INITIALIZED = \"Object already \
initialized\";\n    var TypeError2 = global3.TypeError;\n    var WeakMap2 = \
global3.WeakMap;\n    var set;\n    var get;\n    var has;\n    var enforce = \
function(it) {\n      return has(it) ? get(it) : set(it, {});\n    };\n    \
var getterFor = function(TYPE) {\n      return function(it) {\n        var \
state;\n        if (!isObject2(it) || (state = get(it)).type !== TYPE) {\n    \
      throw new TypeError2(\"Incompatible receiver, \" + TYPE + \" \
required\");\n        }\n        return state;\n      };\n    };\n    if \
(NATIVE_WEAK_MAP || shared.state) {\n      store = shared.state || \
(shared.state = new WeakMap2());\n      store.get = store.get;\n      \
store.has = store.has;\n      store.set = store.set;\n      set = \
function(it, metadata) {\n        if (store.has(it))\n          throw new \
TypeError2(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n      \
  store.set(it, metadata);\n        return metadata;\n      };\n      get = \
function(it) {\n        return store.get(it) || {};\n      };\n      has = \
function(it) {\n        return store.has(it);\n      };\n    } else {\n      \
STATE = sharedKey(\"state\");\n      hiddenKeys[STATE] = true;\n      set = \
function(it, metadata) {\n        if (hasOwn(it, STATE))\n          throw new \
TypeError2(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n      \
  createNonEnumerableProperty(it, STATE, metadata);\n        return \
metadata;\n      };\n      get = function(it) {\n        return hasOwn(it, \
STATE) ? it[STATE] : {};\n      };\n      has = function(it) {\n        \
return hasOwn(it, STATE);\n      };\n    }\n    var store;\n    var STATE;\n  \
  module2.exports = {\n      set,\n      get,\n      has,\n      enforce,\n   \
   getterFor\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/make-built-in.js\nvar require_make_built_in = \
__commonJS({\n  \"node_modules/core-js/internals/make-built-in.js\"(exports, \
module2) {\n    \"use strict\";\n    var uncurryThis2 = \
require_function_uncurry_this();\n    var fails3 = require_fails();\n    var \
isCallable2 = require_is_callable();\n    var hasOwn = \
require_has_own_property();\n    var DESCRIPTORS = require_descriptors();\n   \
 var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;\n    \
var inspectSource = require_inspect_source();\n    var InternalStateModule = \
require_internal_state();\n    var enforceInternalState = \
InternalStateModule.enforce;\n    var getInternalState = \
InternalStateModule.get;\n    var $String2 = String;\n    var defineProperty \
= Object.defineProperty;\n    var stringSlice = uncurryThis2(\"\".slice);\n   \
 var replace2 = uncurryThis2(\"\".replace);\n    var join = \
uncurryThis2([].join);\n    var CONFIGURABLE_LENGTH = DESCRIPTORS && \
!fails3(function() {\n      return defineProperty(function() {\n      }, \
\"length\", { value: 8 }).length !== 8;\n    });\n    var TEMPLATE = \
String(String).split(\"String\");\n    var makeBuiltIn = module2.exports = \
function(value, name, options) {\n      if (stringSlice($String2(name), 0, 7) \
=== \"Symbol(\") {\n        name = \"[\" + replace2($String2(name), \
/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\";\n      }\n      if (options && \
options.getter)\n        name = \"get \" + name;\n      if (options && \
options.setter)\n        name = \"set \" + name;\n      if (!hasOwn(value, \
\"name\") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {\n        if \
(DESCRIPTORS)\n          defineProperty(value, \"name\", { value: name, \
configurable: true });\n        else\n          value.name = name;\n      }\n \
     if (CONFIGURABLE_LENGTH && options && hasOwn(options, \"arity\") && \
value.length !== options.arity) {\n        defineProperty(value, \"length\", \
{ value: options.arity });\n      }\n      try {\n        if (options && \
hasOwn(options, \"constructor\") && options.constructor) {\n          if \
(DESCRIPTORS)\n            defineProperty(value, \"prototype\", { writable: \
false });\n        } else if (value.prototype)\n          value.prototype = \
void 0;\n      } catch (error2) {\n      }\n      var state = \
enforceInternalState(value);\n      if (!hasOwn(state, \"source\")) {\n       \
 state.source = join(TEMPLATE, typeof name == \"string\" ? name : \"\");\n    \
  }\n      return value;\n    };\n    Function.prototype.toString = \
makeBuiltIn(function toString() {\n      return isCallable2(this) && \
getInternalState(this).source || inspectSource(this);\n    }, \
\"toString\");\n  }\n});\n\n// \
node_modules/core-js/internals/define-built-in.js\nvar \
require_define_built_in = __commonJS({\n  \
\"node_modules/core-js/internals/define-built-in.js\"(exports, module2) {\n   \
 \"use strict\";\n    var isCallable2 = require_is_callable();\n    var \
definePropertyModule = require_object_define_property();\n    var makeBuiltIn \
= require_make_built_in();\n    var defineGlobalProperty = \
require_define_global_property();\n    module2.exports = function(O, key, \
value, options) {\n      if (!options)\n        options = {};\n      var \
simple = options.enumerable;\n      var name = options.name !== void 0 ? \
options.name : key;\n      if (isCallable2(value))\n        \
makeBuiltIn(value, name, options);\n      if (options.global) {\n        if \
(simple)\n          O[key] = value;\n        else\n          \
defineGlobalProperty(key, value);\n      } else {\n        try {\n          \
if (!options.unsafe)\n            delete O[key];\n          else if \
(O[key])\n            simple = true;\n        } catch (error2) {\n        }\n \
       if (simple)\n          O[key] = value;\n        else\n          \
definePropertyModule.f(O, key, {\n            value,\n            enumerable: \
false,\n            configurable: !options.nonConfigurable,\n            \
writable: !options.nonWritable\n          });\n      }\n      return O;\n    \
};\n  }\n});\n\n// node_modules/core-js/internals/math-trunc.js\nvar \
require_math_trunc = __commonJS({\n  \
\"node_modules/core-js/internals/math-trunc.js\"(exports, module2) {\n    \
\"use strict\";\n    var ceil = Math.ceil;\n    var floor = Math.floor;\n    \
module2.exports = Math.trunc || function trunc(x) {\n      var n = +x;\n      \
return (n > 0 ? floor : ceil)(n);\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/to-integer-or-infinity.js\nvar \
require_to_integer_or_infinity = __commonJS({\n  \
\"node_modules/core-js/internals/to-integer-or-infinity.js\"(exports, \
module2) {\n    \"use strict\";\n    var trunc = require_math_trunc();\n    \
module2.exports = function(argument) {\n      var number = +argument;\n      \
return number !== number || number === 0 ? 0 : trunc(number);\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/to-absolute-index.js\nvar \
require_to_absolute_index = __commonJS({\n  \
\"node_modules/core-js/internals/to-absolute-index.js\"(exports, module2) {\n \
   \"use strict\";\n    var toIntegerOrInfinity2 = \
require_to_integer_or_infinity();\n    var max = Math.max;\n    var min = \
Math.min;\n    module2.exports = function(index2, length) {\n      var \
integer = toIntegerOrInfinity2(index2);\n      return integer < 0 ? \
max(integer + length, 0) : min(integer, length);\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/to-length.js\nvar require_to_length = \
__commonJS({\n  \"node_modules/core-js/internals/to-length.js\"(exports, \
module2) {\n    \"use strict\";\n    var toIntegerOrInfinity2 = \
require_to_integer_or_infinity();\n    var min = Math.min;\n    \
module2.exports = function(argument) {\n      return argument > 0 ? \
min(toIntegerOrInfinity2(argument), 9007199254740991) : 0;\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/length-of-array-like.js\nvar \
require_length_of_array_like = __commonJS({\n  \
\"node_modules/core-js/internals/length-of-array-like.js\"(exports, module2) \
{\n    \"use strict\";\n    var toLength = require_to_length();\n    \
module2.exports = function(obj) {\n      return toLength(obj.length);\n    \
};\n  }\n});\n\n// node_modules/core-js/internals/array-includes.js\nvar \
require_array_includes = __commonJS({\n  \
\"node_modules/core-js/internals/array-includes.js\"(exports, module2) {\n    \
\"use strict\";\n    var toIndexedObject = require_to_indexed_object();\n    \
var toAbsoluteIndex = require_to_absolute_index();\n    var \
lengthOfArrayLike4 = require_length_of_array_like();\n    var createMethod = \
function(IS_INCLUDES) {\n      return function($this, el, fromIndex) {\n      \
  var O = toIndexedObject($this);\n        var length = \
lengthOfArrayLike4(O);\n        var index2 = toAbsoluteIndex(fromIndex, \
length);\n        var value;\n        if (IS_INCLUDES && el !== el)\n         \
 while (length > index2) {\n            value = O[index2++];\n            if \
(value !== value)\n              return true;\n          }\n        else\n    \
      for (; length > index2; index2++) {\n            if ((IS_INCLUDES || \
index2 in O) && O[index2] === el)\n              return IS_INCLUDES || index2 \
|| 0;\n          }\n        return !IS_INCLUDES && -1;\n      };\n    };\n    \
module2.exports = {\n      // `Array.prototype.includes` method\n      // \
https://tc39.es/ecma262/#sec-array.prototype.includes\n      includes: \
createMethod(true),\n      // `Array.prototype.indexOf` method\n      // \
https://tc39.es/ecma262/#sec-array.prototype.indexof\n      indexOf: \
createMethod(false)\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/object-keys-internal.js\nvar \
require_object_keys_internal = __commonJS({\n  \
\"node_modules/core-js/internals/object-keys-internal.js\"(exports, module2) \
{\n    \"use strict\";\n    var uncurryThis2 = \
require_function_uncurry_this();\n    var hasOwn = \
require_has_own_property();\n    var toIndexedObject = \
require_to_indexed_object();\n    var indexOf = \
require_array_includes().indexOf;\n    var hiddenKeys = \
require_hidden_keys();\n    var push2 = uncurryThis2([].push);\n    \
module2.exports = function(object, names) {\n      var O = \
toIndexedObject(object);\n      var i = 0;\n      var result = [];\n      var \
key;\n      for (key in O)\n        !hasOwn(hiddenKeys, key) && hasOwn(O, \
key) && push2(result, key);\n      while (names.length > i)\n        if \
(hasOwn(O, key = names[i++])) {\n          ~indexOf(result, key) || \
push2(result, key);\n        }\n      return result;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/enum-bug-keys.js\nvar require_enum_bug_keys = \
__commonJS({\n  \"node_modules/core-js/internals/enum-bug-keys.js\"(exports, \
module2) {\n    \"use strict\";\n    module2.exports = [\n      \
\"constructor\",\n      \"hasOwnProperty\",\n      \"isPrototypeOf\",\n      \
\"propertyIsEnumerable\",\n      \"toLocaleString\",\n      \"toString\",\n   \
   \"valueOf\"\n    ];\n  }\n});\n\n// \
node_modules/core-js/internals/object-get-own-property-names.js\nvar \
require_object_get_own_property_names = __commonJS({\n  \
\"node_modules/core-js/internals/object-get-own-property-names.js\"(exports) \
{\n    \"use strict\";\n    var internalObjectKeys = \
require_object_keys_internal();\n    var enumBugKeys = \
require_enum_bug_keys();\n    var hiddenKeys = enumBugKeys.concat(\"length\", \
\"prototype\");\n    exports.f = Object.getOwnPropertyNames || function \
getOwnPropertyNames(O) {\n      return internalObjectKeys(O, hiddenKeys);\n   \
 };\n  }\n});\n\n// \
node_modules/core-js/internals/object-get-own-property-symbols.js\nvar \
require_object_get_own_property_symbols = __commonJS({\n  \
\"node_modules/core-js/internals/object-get-own-property-symbols.js\"(exports\
) {\n    \"use strict\";\n    exports.f = Object.getOwnPropertySymbols;\n  \
}\n});\n\n// node_modules/core-js/internals/own-keys.js\nvar require_own_keys \
= __commonJS({\n  \"node_modules/core-js/internals/own-keys.js\"(exports, \
module2) {\n    \"use strict\";\n    var getBuiltIn2 = \
require_get_built_in();\n    var uncurryThis2 = \
require_function_uncurry_this();\n    var getOwnPropertyNamesModule = \
require_object_get_own_property_names();\n    var getOwnPropertySymbolsModule \
= require_object_get_own_property_symbols();\n    var anObject = \
require_an_object();\n    var concat = uncurryThis2([].concat);\n    \
module2.exports = getBuiltIn2(\"Reflect\", \"ownKeys\") || function \
ownKeys(it) {\n      var keys = getOwnPropertyNamesModule.f(anObject(it));\n  \
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n      return \
getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n    \
};\n  }\n});\n\n// \
node_modules/core-js/internals/copy-constructor-properties.js\nvar \
require_copy_constructor_properties = __commonJS({\n  \
\"node_modules/core-js/internals/copy-constructor-properties.js\"(exports, \
module2) {\n    \"use strict\";\n    var hasOwn = \
require_has_own_property();\n    var ownKeys = require_own_keys();\n    var \
getOwnPropertyDescriptorModule = \
require_object_get_own_property_descriptor();\n    var definePropertyModule = \
require_object_define_property();\n    module2.exports = function(target, \
source, exceptions) {\n      var keys = ownKeys(source);\n      var \
defineProperty = definePropertyModule.f;\n      var getOwnPropertyDescriptor \
= getOwnPropertyDescriptorModule.f;\n      for (var i = 0; i < keys.length; \
i++) {\n        var key = keys[i];\n        if (!hasOwn(target, key) && \
!(exceptions && hasOwn(exceptions, key))) {\n          defineProperty(target, \
key, getOwnPropertyDescriptor(source, key));\n        }\n      }\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/is-forced.js\nvar \
require_is_forced = __commonJS({\n  \
\"node_modules/core-js/internals/is-forced.js\"(exports, module2) {\n    \
\"use strict\";\n    var fails3 = require_fails();\n    var isCallable2 = \
require_is_callable();\n    var replacement = /#|\\.prototype\\./;\n    var \
isForced = function(feature, detection) {\n      var value = \
data2[normalize(feature)];\n      return value === POLYFILL ? true : value \
=== NATIVE ? false : isCallable2(detection) ? fails3(detection) : \
!!detection;\n    };\n    var normalize = isForced.normalize = \
function(string) {\n      return String(string).replace(replacement, \
\".\").toLowerCase();\n    };\n    var data2 = isForced.data = {};\n    var \
NATIVE = isForced.NATIVE = \"N\";\n    var POLYFILL = isForced.POLYFILL = \
\"P\";\n    module2.exports = isForced;\n  }\n});\n\n// \
node_modules/core-js/internals/export.js\nvar require_export = __commonJS({\n \
 \"node_modules/core-js/internals/export.js\"(exports, module2) {\n    \"use \
strict\";\n    var global3 = require_global();\n    var \
getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;\n  \
  var createNonEnumerableProperty = \
require_create_non_enumerable_property();\n    var defineBuiltIn = \
require_define_built_in();\n    var defineGlobalProperty = \
require_define_global_property();\n    var copyConstructorProperties = \
require_copy_constructor_properties();\n    var isForced = \
require_is_forced();\n    module2.exports = function(options, source) {\n     \
 var TARGET = options.target;\n      var GLOBAL = options.global;\n      var \
STATIC = options.stat;\n      var FORCED4, target, key, targetProperty, \
sourceProperty, descriptor;\n      if (GLOBAL) {\n        target = global3;\n \
     } else if (STATIC) {\n        target = global3[TARGET] || \
defineGlobalProperty(TARGET, {});\n      } else {\n        target = \
(global3[TARGET] || {}).prototype;\n      }\n      if (target)\n        for \
(key in source) {\n          sourceProperty = source[key];\n          if \
(options.dontCallGetSet) {\n            descriptor = \
getOwnPropertyDescriptor(target, key);\n            targetProperty = \
descriptor && descriptor.value;\n          } else\n            targetProperty \
= target[key];\n          FORCED4 = isForced(GLOBAL ? key : TARGET + (STATIC \
? \".\" : \"#\") + key, options.forced);\n          if (!FORCED4 && \
targetProperty !== void 0) {\n            if (typeof sourceProperty == typeof \
targetProperty)\n              continue;\n            \
copyConstructorProperties(sourceProperty, targetProperty);\n          }\n     \
     if (options.sham || targetProperty && targetProperty.sham) {\n           \
 createNonEnumerableProperty(sourceProperty, \"sham\", true);\n          }\n  \
        defineBuiltIn(target, key, sourceProperty, options);\n        }\n    \
};\n  }\n});\n\n// node_modules/core-js/internals/is-array.js\nvar \
require_is_array = __commonJS({\n  \
\"node_modules/core-js/internals/is-array.js\"(exports, module2) {\n    \"use \
strict\";\n    var classof = require_classof_raw();\n    module2.exports = \
Array.isArray || function isArray(argument) {\n      return classof(argument) \
=== \"Array\";\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/array-set-length.js\nvar \
require_array_set_length = __commonJS({\n  \
\"node_modules/core-js/internals/array-set-length.js\"(exports, module2) {\n  \
  \"use strict\";\n    var DESCRIPTORS = require_descriptors();\n    var \
isArray = require_is_array();\n    var $TypeError = TypeError;\n    var \
getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var \
SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {\n      if \
(this !== void 0)\n        return true;\n      try {\n        \
Object.defineProperty([], \"length\", { writable: false }).length = 1;\n      \
} catch (error2) {\n        return error2 instanceof TypeError;\n      }\n    \
}();\n    module2.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, \
length) {\n      if (isArray(O) && !getOwnPropertyDescriptor(O, \
\"length\").writable) {\n        throw new $TypeError(\"Cannot set read only \
.length\");\n      }\n      return O.length = length;\n    } : function(O, \
length) {\n      return O.length = length;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/does-not-exceed-safe-integer.js\nvar \
require_does_not_exceed_safe_integer = __commonJS({\n  \
\"node_modules/core-js/internals/does-not-exceed-safe-integer.js\"(exports, \
module2) {\n    \"use strict\";\n    var $TypeError = TypeError;\n    var \
MAX_SAFE_INTEGER = 9007199254740991;\n    module2.exports = function(it) {\n  \
    if (it > MAX_SAFE_INTEGER)\n        throw $TypeError(\"Maximum allowed \
index exceeded\");\n      return it;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/function-apply.js\nvar require_function_apply \
= __commonJS({\n  \
\"node_modules/core-js/internals/function-apply.js\"(exports, module2) {\n    \
\"use strict\";\n    var NATIVE_BIND = require_function_bind_native();\n    \
var FunctionPrototype = Function.prototype;\n    var apply3 = \
FunctionPrototype.apply;\n    var call2 = FunctionPrototype.call;\n    \
module2.exports = typeof Reflect == \"object\" && Reflect.apply || \
(NATIVE_BIND ? call2.bind(apply3) : function() {\n      return \
call2.apply(apply3, arguments);\n    });\n  }\n});\n\n// \
node_modules/core-js/internals/function-uncurry-this-accessor.js\nvar \
require_function_uncurry_this_accessor = __commonJS({\n  \
\"node_modules/core-js/internals/function-uncurry-this-accessor.js\"(exports, \
module2) {\n    \"use strict\";\n    var uncurryThis2 = \
require_function_uncurry_this();\n    var aCallable = require_a_callable();\n \
   module2.exports = function(object, key, method) {\n      try {\n        \
return uncurryThis2(aCallable(Object.getOwnPropertyDescriptor(object, \
key)[method]));\n      } catch (error2) {\n      }\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/a-possible-prototype.js\nvar \
require_a_possible_prototype = __commonJS({\n  \
\"node_modules/core-js/internals/a-possible-prototype.js\"(exports, module2) \
{\n    \"use strict\";\n    var isCallable2 = require_is_callable();\n    var \
$String2 = String;\n    var $TypeError = TypeError;\n    module2.exports = \
function(argument) {\n      if (typeof argument == \"object\" || \
isCallable2(argument))\n        return argument;\n      throw new \
$TypeError(\"Can't set \" + $String2(argument) + \" as a prototype\");\n    \
};\n  }\n});\n\n// \
node_modules/core-js/internals/object-set-prototype-of.js\nvar \
require_object_set_prototype_of = __commonJS({\n  \
\"node_modules/core-js/internals/object-set-prototype-of.js\"(exports, \
module2) {\n    \"use strict\";\n    var uncurryThisAccessor = \
require_function_uncurry_this_accessor();\n    var anObject = \
require_an_object();\n    var aPossiblePrototype = \
require_a_possible_prototype();\n    module2.exports = Object.setPrototypeOf \
|| (\"__proto__\" in {} ? function() {\n      var CORRECT_SETTER = false;\n   \
   var test = {};\n      var setter;\n      try {\n        setter = \
uncurryThisAccessor(Object.prototype, \"__proto__\", \"set\");\n        \
setter(test, []);\n        CORRECT_SETTER = test instanceof Array;\n      } \
catch (error2) {\n      }\n      return function setPrototypeOf(O, proto) {\n \
       anObject(O);\n        aPossiblePrototype(proto);\n        if \
(CORRECT_SETTER)\n          setter(O, proto);\n        else\n          \
O.__proto__ = proto;\n        return O;\n      };\n    }() : void 0);\n  \
}\n});\n\n// node_modules/core-js/internals/proxy-accessor.js\nvar \
require_proxy_accessor = __commonJS({\n  \
\"node_modules/core-js/internals/proxy-accessor.js\"(exports, module2) {\n    \
\"use strict\";\n    var defineProperty = \
require_object_define_property().f;\n    module2.exports = function(Target, \
Source, key) {\n      key in Target || defineProperty(Target, key, {\n        \
configurable: true,\n        get: function() {\n          return \
Source[key];\n        },\n        set: function(it) {\n          Source[key] \
= it;\n        }\n      });\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/inherit-if-required.js\nvar \
require_inherit_if_required = __commonJS({\n  \
\"node_modules/core-js/internals/inherit-if-required.js\"(exports, module2) \
{\n    \"use strict\";\n    var isCallable2 = require_is_callable();\n    var \
isObject2 = require_is_object();\n    var setPrototypeOf = \
require_object_set_prototype_of();\n    module2.exports = function($this, \
dummy, Wrapper) {\n      var NewTarget, NewTargetPrototype;\n      if (\n     \
   // it can work only with native `setPrototypeOf`\n        setPrototypeOf \
&& // we haven't completely correct pre-ES6 way for getting `new.target`, so \
use this\n        isCallable2(NewTarget = dummy.constructor) && NewTarget !== \
Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && \
NewTargetPrototype !== Wrapper.prototype\n      )\n        \
setPrototypeOf($this, NewTargetPrototype);\n      return $this;\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/to-string-tag-support.js\nvar \
require_to_string_tag_support = __commonJS({\n  \
\"node_modules/core-js/internals/to-string-tag-support.js\"(exports, module2) \
{\n    \"use strict\";\n    var wellKnownSymbol = \
require_well_known_symbol();\n    var TO_STRING_TAG = \
wellKnownSymbol(\"toStringTag\");\n    var test = {};\n    \
test[TO_STRING_TAG] = \"z\";\n    module2.exports = String(test) === \
\"[object z]\";\n  }\n});\n\n// \
node_modules/core-js/internals/classof.js\nvar require_classof = \
__commonJS({\n  \"node_modules/core-js/internals/classof.js\"(exports, \
module2) {\n    \"use strict\";\n    var TO_STRING_TAG_SUPPORT = \
require_to_string_tag_support();\n    var isCallable2 = \
require_is_callable();\n    var classofRaw = require_classof_raw();\n    var \
wellKnownSymbol = require_well_known_symbol();\n    var TO_STRING_TAG = \
wellKnownSymbol(\"toStringTag\");\n    var $Object = Object;\n    var \
CORRECT_ARGUMENTS = classofRaw(function() {\n      return arguments;\n    \
}()) === \"Arguments\";\n    var tryGet = function(it, key) {\n      try {\n  \
      return it[key];\n      } catch (error2) {\n      }\n    };\n    \
module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n      \
var O, tag, result;\n      return it === void 0 ? \"Undefined\" : it === null \
? \"Null\" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == \
\"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = \
classofRaw(O)) === \"Object\" && isCallable2(O.callee) ? \"Arguments\" : \
result;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/to-string.js\nvar require_to_string = \
__commonJS({\n  \"node_modules/core-js/internals/to-string.js\"(exports, \
module2) {\n    \"use strict\";\n    var classof = require_classof();\n    \
var $String2 = String;\n    module2.exports = function(argument) {\n      if \
(classof(argument) === \"Symbol\")\n        throw new TypeError(\"Cannot \
convert a Symbol value to a string\");\n      return $String2(argument);\n    \
};\n  }\n});\n\n// \
node_modules/core-js/internals/normalize-string-argument.js\nvar \
require_normalize_string_argument = __commonJS({\n  \
\"node_modules/core-js/internals/normalize-string-argument.js\"(exports, \
module2) {\n    \"use strict\";\n    var toString = require_to_string();\n    \
module2.exports = function(argument, $default) {\n      return argument === \
void 0 ? arguments.length < 2 ? \"\" : $default : toString(argument);\n    \
};\n  }\n});\n\n// node_modules/core-js/internals/install-error-cause.js\nvar \
require_install_error_cause = __commonJS({\n  \
\"node_modules/core-js/internals/install-error-cause.js\"(exports, module2) \
{\n    \"use strict\";\n    var isObject2 = require_is_object();\n    var \
createNonEnumerableProperty = require_create_non_enumerable_property();\n    \
module2.exports = function(O, options) {\n      if (isObject2(options) && \
\"cause\" in options) {\n        createNonEnumerableProperty(O, \"cause\", \
options.cause);\n      }\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/error-stack-clear.js\nvar \
require_error_stack_clear = __commonJS({\n  \
\"node_modules/core-js/internals/error-stack-clear.js\"(exports, module2) {\n \
   \"use strict\";\n    var uncurryThis2 = require_function_uncurry_this();\n \
   var $Error = Error;\n    var replace2 = uncurryThis2(\"\".replace);\n    \
var TEST = function(arg) {\n      return String(new $Error(arg).stack);\n    \
}(\"zxcasd\");\n    var V8_OR_CHAKRA_STACK_ENTRY = /\\n\\s*at \
[^:]*:[^\\n]*/;\n    var IS_V8_OR_CHAKRA_STACK = \
V8_OR_CHAKRA_STACK_ENTRY.test(TEST);\n    module2.exports = function(stack, \
dropEntries) {\n      if (IS_V8_OR_CHAKRA_STACK && typeof stack == \"string\" \
&& !$Error.prepareStackTrace) {\n        while (dropEntries--)\n          \
stack = replace2(stack, V8_OR_CHAKRA_STACK_ENTRY, \"\");\n      }\n      \
return stack;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/error-stack-installable.js\nvar \
require_error_stack_installable = __commonJS({\n  \
\"node_modules/core-js/internals/error-stack-installable.js\"(exports, \
module2) {\n    \"use strict\";\n    var fails3 = require_fails();\n    var \
createPropertyDescriptor = require_create_property_descriptor();\n    \
module2.exports = !fails3(function() {\n      var error2 = new \
Error(\"a\");\n      if (!(\"stack\" in error2))\n        return true;\n      \
Object.defineProperty(error2, \"stack\", createPropertyDescriptor(1, 7));\n   \
   return error2.stack !== 7;\n    });\n  }\n});\n\n// \
node_modules/core-js/internals/error-stack-install.js\nvar \
require_error_stack_install = __commonJS({\n  \
\"node_modules/core-js/internals/error-stack-install.js\"(exports, module2) \
{\n    \"use strict\";\n    var createNonEnumerableProperty = \
require_create_non_enumerable_property();\n    var clearErrorStack = \
require_error_stack_clear();\n    var ERROR_STACK_INSTALLABLE = \
require_error_stack_installable();\n    var captureStackTrace = \
Error.captureStackTrace;\n    module2.exports = function(error2, C, stack, \
dropEntries) {\n      if (ERROR_STACK_INSTALLABLE) {\n        if \
(captureStackTrace)\n          captureStackTrace(error2, C);\n        else\n  \
        createNonEnumerableProperty(error2, \"stack\", clearErrorStack(stack, \
dropEntries));\n      }\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/wrap-error-constructor-with-cause.js\nvar \
require_wrap_error_constructor_with_cause = __commonJS({\n  \
\"node_modules/core-js/internals/wrap-error-constructor-with-cause.js\"(expor\
ts, module2) {\n    \"use strict\";\n    var getBuiltIn2 = \
require_get_built_in();\n    var hasOwn = require_has_own_property();\n    \
var createNonEnumerableProperty = require_create_non_enumerable_property();\n \
   var isPrototypeOf = require_object_is_prototype_of();\n    var \
setPrototypeOf = require_object_set_prototype_of();\n    var \
copyConstructorProperties = require_copy_constructor_properties();\n    var \
proxyAccessor = require_proxy_accessor();\n    var inheritIfRequired = \
require_inherit_if_required();\n    var normalizeStringArgument = \
require_normalize_string_argument();\n    var installErrorCause = \
require_install_error_cause();\n    var installErrorStack = \
require_error_stack_install();\n    var DESCRIPTORS = \
require_descriptors();\n    var IS_PURE = require_is_pure();\n    \
module2.exports = function(FULL_NAME, wrapper, FORCED4, IS_AGGREGATE_ERROR) \
{\n      var STACK_TRACE_LIMIT = \"stackTraceLimit\";\n      var \
OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;\n      var path = \
FULL_NAME.split(\".\");\n      var ERROR_NAME = path[path.length - 1];\n      \
var OriginalError = getBuiltIn2.apply(null, path);\n      if \
(!OriginalError)\n        return;\n      var OriginalErrorPrototype = \
OriginalError.prototype;\n      if (!IS_PURE && \
hasOwn(OriginalErrorPrototype, \"cause\"))\n        delete \
OriginalErrorPrototype.cause;\n      if (!FORCED4)\n        return \
OriginalError;\n      var BaseError = getBuiltIn2(\"Error\");\n      var \
WrappedError = wrapper(function(a, b) {\n        var message = \
normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, void 0);\n        var \
result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();\n   \
     if (message !== void 0)\n          createNonEnumerableProperty(result, \
\"message\", message);\n        installErrorStack(result, WrappedError, \
result.stack, 2);\n        if (this && isPrototypeOf(OriginalErrorPrototype, \
this))\n          inheritIfRequired(result, this, WrappedError);\n        if \
(arguments.length > OPTIONS_POSITION)\n          installErrorCause(result, \
arguments[OPTIONS_POSITION]);\n        return result;\n      });\n      \
WrappedError.prototype = OriginalErrorPrototype;\n      if (ERROR_NAME !== \
\"Error\") {\n        if (setPrototypeOf)\n          \
setPrototypeOf(WrappedError, BaseError);\n        else\n          \
copyConstructorProperties(WrappedError, BaseError, { name: true });\n      } \
else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {\n        \
proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);\n        \
proxyAccessor(WrappedError, OriginalError, \"prepareStackTrace\");\n      }\n \
     copyConstructorProperties(WrappedError, OriginalError);\n      if \
(!IS_PURE)\n        try {\n          if (OriginalErrorPrototype.name !== \
ERROR_NAME) {\n            \
createNonEnumerableProperty(OriginalErrorPrototype, \"name\", ERROR_NAME);\n  \
        }\n          OriginalErrorPrototype.constructor = WrappedError;\n     \
   } catch (error2) {\n        }\n      return WrappedError;\n    };\n  \
}\n});\n\n// \
node_modules/core-js/internals/function-uncurry-this-clause.js\nvar \
require_function_uncurry_this_clause = __commonJS({\n  \
\"node_modules/core-js/internals/function-uncurry-this-clause.js\"(exports, \
module2) {\n    \"use strict\";\n    var classofRaw = \
require_classof_raw();\n    var uncurryThis2 = \
require_function_uncurry_this();\n    module2.exports = function(fn) {\n      \
if (classofRaw(fn) === \"Function\")\n        return uncurryThis2(fn);\n    \
};\n  }\n});\n\n// \
node_modules/core-js/internals/function-bind-context.js\nvar \
require_function_bind_context = __commonJS({\n  \
\"node_modules/core-js/internals/function-bind-context.js\"(exports, module2) \
{\n    \"use strict\";\n    var uncurryThis2 = \
require_function_uncurry_this_clause();\n    var aCallable = \
require_a_callable();\n    var NATIVE_BIND = \
require_function_bind_native();\n    var bind = \
uncurryThis2(uncurryThis2.bind);\n    module2.exports = function(fn, that) \
{\n      aCallable(fn);\n      return that === void 0 ? fn : NATIVE_BIND ? \
bind(fn, that) : function() {\n        return fn.apply(that, arguments);\n    \
  };\n    };\n  }\n});\n\n// node_modules/core-js/internals/html.js\nvar \
require_html = __commonJS({\n  \
\"node_modules/core-js/internals/html.js\"(exports, module2) {\n    \"use \
strict\";\n    var getBuiltIn2 = require_get_built_in();\n    module2.exports \
= getBuiltIn2(\"document\", \"documentElement\");\n  }\n});\n\n// \
node_modules/core-js/internals/array-slice.js\nvar require_array_slice = \
__commonJS({\n  \"node_modules/core-js/internals/array-slice.js\"(exports, \
module2) {\n    \"use strict\";\n    var uncurryThis2 = \
require_function_uncurry_this();\n    module2.exports = \
uncurryThis2([].slice);\n  }\n});\n\n// \
node_modules/core-js/internals/validate-arguments-length.js\nvar \
require_validate_arguments_length = __commonJS({\n  \
\"node_modules/core-js/internals/validate-arguments-length.js\"(exports, \
module2) {\n    \"use strict\";\n    var $TypeError = TypeError;\n    \
module2.exports = function(passed, required) {\n      if (passed < \
required)\n        throw new $TypeError(\"Not enough arguments\");\n      \
return passed;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/engine-is-ios.js\nvar require_engine_is_ios = \
__commonJS({\n  \"node_modules/core-js/internals/engine-is-ios.js\"(exports, \
module2) {\n    \"use strict\";\n    var userAgent = \
require_engine_user_agent();\n    module2.exports = \
/(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);\n  }\n});\n\n// \
node_modules/core-js/internals/engine-is-node.js\nvar require_engine_is_node \
= __commonJS({\n  \
\"node_modules/core-js/internals/engine-is-node.js\"(exports, module2) {\n    \
\"use strict\";\n    var global3 = require_global();\n    var classof = \
require_classof_raw();\n    module2.exports = classof(global3.process) === \
\"process\";\n  }\n});\n\n// node_modules/core-js/internals/task.js\nvar \
require_task = __commonJS({\n  \
\"node_modules/core-js/internals/task.js\"(exports, module2) {\n    \"use \
strict\";\n    var global3 = require_global();\n    var apply3 = \
require_function_apply();\n    var bind = require_function_bind_context();\n  \
  var isCallable2 = require_is_callable();\n    var hasOwn = \
require_has_own_property();\n    var fails3 = require_fails();\n    var html \
= require_html();\n    var arraySlice2 = require_array_slice();\n    var \
createElement2 = require_document_create_element();\n    var \
validateArgumentsLength = require_validate_arguments_length();\n    var \
IS_IOS = require_engine_is_ios();\n    var IS_NODE = \
require_engine_is_node();\n    var set = global3.setImmediate;\n    var clear \
= global3.clearImmediate;\n    var process2 = global3.process;\n    var \
Dispatch = global3.Dispatch;\n    var Function2 = global3.Function;\n    var \
MessageChannel = global3.MessageChannel;\n    var String2 = global3.String;\n \
   var counter = 0;\n    var queue = {};\n    var ONREADYSTATECHANGE = \
\"onreadystatechange\";\n    var $location;\n    var defer;\n    var \
channel;\n    var port;\n    fails3(function() {\n      $location = \
global3.location;\n    });\n    var run = function(id) {\n      if \
(hasOwn(queue, id)) {\n        var fn = queue[id];\n        delete \
queue[id];\n        fn();\n      }\n    };\n    var runner = function(id) {\n \
     return function() {\n        run(id);\n      };\n    };\n    var \
eventListener = function(event2) {\n      run(event2.data);\n    };\n    var \
globalPostMessageDefer = function(id) {\n      \
global3.postMessage(String2(id), $location.protocol + \"//\" + \
$location.host);\n    };\n    if (!set || !clear) {\n      set = function \
setImmediate2(handler) {\n        validateArgumentsLength(arguments.length, \
1);\n        var fn = isCallable2(handler) ? handler : Function2(handler);\n  \
      var args = arraySlice2(arguments, 1);\n        queue[++counter] = \
function() {\n          apply3(fn, void 0, args);\n        };\n        \
defer(counter);\n        return counter;\n      };\n      clear = function \
clearImmediate2(id) {\n        delete queue[id];\n      };\n      if \
(IS_NODE) {\n        defer = function(id) {\n          \
process2.nextTick(runner(id));\n        };\n      } else if (Dispatch && \
Dispatch.now) {\n        defer = function(id) {\n          \
Dispatch.now(runner(id));\n        };\n      } else if (MessageChannel && \
!IS_IOS) {\n        channel = new MessageChannel();\n        port = \
channel.port2;\n        channel.port1.onmessage = eventListener;\n        \
defer = bind(port.postMessage, port);\n      } else if \
(global3.addEventListener && isCallable2(global3.postMessage) && \
!global3.importScripts && $location && $location.protocol !== \"file:\" && \
!fails3(globalPostMessageDefer)) {\n        defer = globalPostMessageDefer;\n \
       global3.addEventListener(\"message\", eventListener, false);\n      } \
else if (ONREADYSTATECHANGE in createElement2(\"script\")) {\n        defer = \
function(id) {\n          \
html.appendChild(createElement2(\"script\"))[ONREADYSTATECHANGE] = function() \
{\n            html.removeChild(this);\n            run(id);\n          };\n  \
      };\n      } else {\n        defer = function(id) {\n          \
setTimeout(runner(id), 0);\n        };\n      }\n    }\n    module2.exports = \
{\n      set,\n      clear\n    };\n  }\n});\n\n// \
node_modules/core-js/modules/web.clear-immediate.js\nvar \
require_web_clear_immediate = __commonJS({\n  \
\"node_modules/core-js/modules/web.clear-immediate.js\"() {\n    \"use \
strict\";\n    var $6 = require_export();\n    var global3 = \
require_global();\n    var clearImmediate2 = require_task().clear;\n    $6({ \
global: true, bind: true, enumerable: true, forced: global3.clearImmediate \
!== clearImmediate2 }, {\n      clearImmediate: clearImmediate2\n    });\n  \
}\n});\n\n// node_modules/core-js/internals/engine-is-bun.js\nvar \
require_engine_is_bun = __commonJS({\n  \
\"node_modules/core-js/internals/engine-is-bun.js\"(exports, module2) {\n    \
\"use strict\";\n    module2.exports = typeof Bun == \"function\" && Bun && \
typeof Bun.version == \"string\";\n  }\n});\n\n// \
node_modules/core-js/internals/schedulers-fix.js\nvar require_schedulers_fix \
= __commonJS({\n  \
\"node_modules/core-js/internals/schedulers-fix.js\"(exports, module2) {\n    \
\"use strict\";\n    var global3 = require_global();\n    var apply3 = \
require_function_apply();\n    var isCallable2 = require_is_callable();\n    \
var ENGINE_IS_BUN = require_engine_is_bun();\n    var USER_AGENT = \
require_engine_user_agent();\n    var arraySlice2 = require_array_slice();\n  \
  var validateArgumentsLength = require_validate_arguments_length();\n    var \
Function2 = global3.Function;\n    var WRAP = /MSIE .\\./.test(USER_AGENT) || \
ENGINE_IS_BUN && function() {\n      var version = \
global3.Bun.version.split(\".\");\n      return version.length < 3 || \
version[0] === \"0\" && (version[1] < 3 || version[1] === \"3\" && version[2] \
=== \"0\");\n    }();\n    module2.exports = function(scheduler, hasTimeArg) \
{\n      var firstParamIndex = hasTimeArg ? 2 : 1;\n      return WRAP ? \
function(handler, timeout) {\n        var boundArgs = \
validateArgumentsLength(arguments.length, 1) > firstParamIndex;\n        var \
fn = isCallable2(handler) ? handler : Function2(handler);\n        var params \
= boundArgs ? arraySlice2(arguments, firstParamIndex) : [];\n        var \
callback = boundArgs ? function() {\n          apply3(fn, this, params);\n    \
    } : fn;\n        return hasTimeArg ? scheduler(callback, timeout) : \
scheduler(callback);\n      } : scheduler;\n    };\n  }\n});\n\n// \
node_modules/core-js/modules/web.set-immediate.js\nvar \
require_web_set_immediate = __commonJS({\n  \
\"node_modules/core-js/modules/web.set-immediate.js\"() {\n    \"use \
strict\";\n    var $6 = require_export();\n    var global3 = \
require_global();\n    var setTask = require_task().set;\n    var \
schedulersFix = require_schedulers_fix();\n    var setImmediate2 = \
global3.setImmediate ? schedulersFix(setTask, false) : setTask;\n    $6({ \
global: true, bind: true, enumerable: true, forced: global3.setImmediate !== \
setImmediate2 }, {\n      setImmediate: setImmediate2\n    });\n  \
}\n});\n\n// node_modules/dompurify/dist/purify.js\nvar require_purify = \
__commonJS({\n  \"node_modules/dompurify/dist/purify.js\"(exports, module2) \
{\n    (function(global3, factory) {\n      typeof exports === \"object\" && \
typeof module2 !== \"undefined\" ? module2.exports = factory() : typeof \
define === \"function\" && define.amd ? define(factory) : (global3 = typeof \
globalThis !== \"undefined\" ? globalThis : global3 || self, \
global3.DOMPurify = factory());\n    })(exports, function() {\n      \"use \
strict\";\n      function _typeof(obj) {\n        \"@babel/helpers - \
typeof\";\n        return _typeof = \"function\" == typeof Symbol && \
\"symbol\" == typeof Symbol.iterator ? function(obj2) {\n          return \
typeof obj2;\n        } : function(obj2) {\n          return obj2 && \
\"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== \
Symbol.prototype ? \"symbol\" : typeof obj2;\n        }, _typeof(obj);\n      \
}\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = \
Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n          \
o2.__proto__ = p2;\n          return o2;\n        };\n        return \
_setPrototypeOf(o, p);\n      }\n      function _isNativeReflectConstruct() \
{\n        if (typeof Reflect === \"undefined\" || !Reflect.construct)\n      \
    return false;\n        if (Reflect.construct.sham)\n          return \
false;\n        if (typeof Proxy === \"function\")\n          return true;\n  \
      try {\n          \
Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n  \
        }));\n          return true;\n        } catch (e) {\n          return \
false;\n        }\n      }\n      function _construct(Parent, args, Class) \
{\n        if (_isNativeReflectConstruct()) {\n          _construct = \
Reflect.construct;\n        } else {\n          _construct = function \
_construct2(Parent2, args2, Class2) {\n            var a = [null];\n          \
  a.push.apply(a, args2);\n            var Constructor = \
Function.bind.apply(Parent2, a);\n            var instance = new \
Constructor();\n            if (Class2)\n              \
_setPrototypeOf(instance, Class2.prototype);\n            return instance;\n  \
        };\n        }\n        return _construct.apply(null, arguments);\n    \
  }\n      function _toConsumableArray(arr) {\n        return \
_arrayWithoutHoles(arr) || _iterableToArray(arr) || \
_unsupportedIterableToArray(arr) || _nonIterableSpread();\n      }\n      \
function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr))\n         \
 return _arrayLikeToArray(arr);\n      }\n      function \
_iterableToArray(iter) {\n        if (typeof Symbol !== \"undefined\" && \
iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null)\n          \
return Array.from(iter);\n      }\n      function \
_unsupportedIterableToArray(o, minLen) {\n        if (!o)\n          \
return;\n        if (typeof o === \"string\")\n          return \
_arrayLikeToArray(o, minLen);\n        var n = \
Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" \
&& o.constructor)\n          n = o.constructor.name;\n        if (n === \
\"Map\" || n === \"Set\")\n          return Array.from(o);\n        if (n === \
\"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n        \
  return _arrayLikeToArray(o, minLen);\n      }\n      function \
_arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length)\n \
         len = arr.length;\n        for (var i = 0, arr2 = new Array(len); i \
< len; i++)\n          arr2[i] = arr[i];\n        return arr2;\n      }\n     \
 function _nonIterableSpread() {\n        throw new TypeError(\"Invalid \
attempt to spread non-iterable instance.\\nIn order to be iterable, non-array \
objects must have a [Symbol.iterator]() method.\");\n      }\n      var \
hasOwnProperty2 = Object.hasOwnProperty, setPrototypeOf = \
Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = \
Object.getPrototypeOf, getOwnPropertyDescriptor = \
Object.getOwnPropertyDescriptor;\n      var freeze = Object.freeze, seal = \
Object.seal, create = Object.create;\n      var _ref = typeof Reflect !== \
\"undefined\" && Reflect, apply3 = _ref.apply, construct = _ref.construct;\n  \
    if (!apply3) {\n        apply3 = function apply4(fun, thisValue, args) \
{\n          return fun.apply(thisValue, args);\n        };\n      }\n      \
if (!freeze) {\n        freeze = function freeze2(x) {\n          return x;\n \
       };\n      }\n      if (!seal) {\n        seal = function seal2(x) {\n  \
        return x;\n        };\n      }\n      if (!construct) {\n        \
construct = function construct2(Func, args) {\n          return \
_construct(Func, _toConsumableArray(args));\n        };\n      }\n      var \
arrayForEach = unapply(Array.prototype.forEach);\n      var arrayPop = \
unapply(Array.prototype.pop);\n      var arrayPush = \
unapply(Array.prototype.push);\n      var stringToLowerCase = \
unapply(String.prototype.toLowerCase);\n      var stringToString = \
unapply(String.prototype.toString);\n      var stringMatch = \
unapply(String.prototype.match);\n      var stringReplace = \
unapply(String.prototype.replace);\n      var stringIndexOf = \
unapply(String.prototype.indexOf);\n      var stringTrim = \
unapply(String.prototype.trim);\n      var regExpTest = \
unapply(RegExp.prototype.test);\n      var typeErrorCreate = \
unconstruct(TypeError);\n      function unapply(func) {\n        return \
function(thisArg) {\n          for (var _len = arguments.length, args = new \
Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            \
args[_key - 1] = arguments[_key];\n          }\n          return apply3(func, \
thisArg, args);\n        };\n      }\n      function unconstruct(func) {\n    \
    return function() {\n          for (var _len2 = arguments.length, args = \
new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            \
args[_key2] = arguments[_key2];\n          }\n          return \
construct(func, args);\n        };\n      }\n      function addToSet(set, \
array, transformCaseFunc) {\n        var _transformCaseFunc;\n        \
transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && \
_transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n     \
   if (setPrototypeOf) {\n          setPrototypeOf(set, null);\n        }\n   \
     var l = array.length;\n        while (l--) {\n          var element = \
array[l];\n          if (typeof element === \"string\") {\n            var \
lcElement = transformCaseFunc(element);\n            if (lcElement !== \
element) {\n              if (!isFrozen(array)) {\n                array[l] = \
lcElement;\n              }\n              element = lcElement;\n            \
}\n          }\n          set[element] = true;\n        }\n        return \
set;\n      }\n      function clone2(object) {\n        var newObject = \
create(null);\n        var property;\n        for (property in object) {\n    \
      if (apply3(hasOwnProperty2, object, [property]) === true) {\n           \
 newObject[property] = object[property];\n          }\n        }\n        \
return newObject;\n      }\n      function lookupGetter(object, prop) {\n     \
   while (object !== null) {\n          var desc = \
getOwnPropertyDescriptor(object, prop);\n          if (desc) {\n            \
if (desc.get) {\n              return unapply(desc.get);\n            }\n     \
       if (typeof desc.value === \"function\") {\n              return \
unapply(desc.value);\n            }\n          }\n          object = \
getPrototypeOf(object);\n        }\n        function fallbackValue(element) \
{\n          console.warn(\"fallback value for\", element);\n          return \
null;\n        }\n        return fallbackValue;\n      }\n      var html$1 = \
freeze([\"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"article\", \
\"aside\", \"audio\", \"b\", \"bdi\", \"bdo\", \"big\", \"blink\", \
\"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \
\"center\", \"cite\", \"code\", \"col\", \"colgroup\", \"content\", \"data\", \
\"datalist\", \"dd\", \"decorator\", \"del\", \"details\", \"dfn\", \
\"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \
\"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \
\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \
\"hgroup\", \"hr\", \"html\", \"i\", \"img\", \"input\", \"ins\", \"kbd\", \
\"label\", \"legend\", \"li\", \"main\", \"map\", \"mark\", \"marquee\", \
\"menu\", \"menuitem\", \"meter\", \"nav\", \"nobr\", \"ol\", \"optgroup\", \
\"option\", \"output\", \"p\", \"picture\", \"pre\", \"progress\", \"q\", \
\"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"section\", \"select\", \
\"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\", \
\"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \
\"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \
\"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\"]);\n    \
  var svg$1 = freeze([\"svg\", \"a\", \"altglyph\", \"altglyphdef\", \
\"altglyphitem\", \"animatecolor\", \"animatemotion\", \"animatetransform\", \
\"circle\", \"clippath\", \"defs\", \"desc\", \"ellipse\", \"filter\", \
\"font\", \"g\", \"glyph\", \"glyphref\", \"hkern\", \"image\", \"line\", \
\"lineargradient\", \"marker\", \"mask\", \"metadata\", \"mpath\", \"path\", \
\"pattern\", \"polygon\", \"polyline\", \"radialgradient\", \"rect\", \
\"stop\", \"style\", \"switch\", \"symbol\", \"text\", \"textpath\", \
\"title\", \"tref\", \"tspan\", \"view\", \"vkern\"]);\n      var svgFilters \
= freeze([\"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \
\"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \
\"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \
\"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \
\"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \
\"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \
\"feTurbulence\"]);\n      var svgDisallowed = freeze([\"animate\", \
\"color-profile\", \"cursor\", \"discard\", \"fedropshadow\", \"font-face\", \
\"font-face-format\", \"font-face-name\", \"font-face-src\", \
\"font-face-uri\", \"foreignobject\", \"hatch\", \"hatchpath\", \"mesh\", \
\"meshgradient\", \"meshpatch\", \"meshrow\", \"missing-glyph\", \"script\", \
\"set\", \"solidcolor\", \"unknown\", \"use\"]);\n      var mathMl$1 = \
freeze([\"math\", \"menclose\", \"merror\", \"mfenced\", \"mfrac\", \
\"mglyph\", \"mi\", \"mlabeledtr\", \"mmultiscripts\", \"mn\", \"mo\", \
\"mover\", \"mpadded\", \"mphantom\", \"mroot\", \"mrow\", \"ms\", \
\"mspace\", \"msqrt\", \"mstyle\", \"msub\", \"msup\", \"msubsup\", \
\"mtable\", \"mtd\", \"mtext\", \"mtr\", \"munder\", \"munderover\"]);\n      \
var mathMlDisallowed = freeze([\"maction\", \"maligngroup\", \"malignmark\", \
\"mlongdiv\", \"mscarries\", \"mscarry\", \"msgroup\", \"mstack\", \
\"msline\", \"msrow\", \"semantics\", \"annotation\", \"annotation-xml\", \
\"mprescripts\", \"none\"]);\n      var text = freeze([\"#text\"]);\n      \
var html = freeze([\"accept\", \"action\", \"align\", \"alt\", \
\"autocapitalize\", \"autocomplete\", \"autopictureinpicture\", \"autoplay\", \
\"background\", \"bgcolor\", \"border\", \"capture\", \"cellpadding\", \
\"cellspacing\", \"checked\", \"cite\", \"class\", \"clear\", \"color\", \
\"cols\", \"colspan\", \"controls\", \"controlslist\", \"coords\", \
\"crossorigin\", \"datetime\", \"decoding\", \"default\", \"dir\", \
\"disabled\", \"disablepictureinpicture\", \"disableremoteplayback\", \
\"download\", \"draggable\", \"enctype\", \"enterkeyhint\", \"face\", \
\"for\", \"headers\", \"height\", \"hidden\", \"high\", \"href\", \
\"hreflang\", \"id\", \"inputmode\", \"integrity\", \"ismap\", \"kind\", \
\"label\", \"lang\", \"list\", \"loading\", \"loop\", \"low\", \"max\", \
\"maxlength\", \"media\", \"method\", \"min\", \"minlength\", \"multiple\", \
\"muted\", \"name\", \"nonce\", \"noshade\", \"novalidate\", \"nowrap\", \
\"open\", \"optimum\", \"pattern\", \"placeholder\", \"playsinline\", \
\"poster\", \"preload\", \"pubdate\", \"radiogroup\", \"readonly\", \"rel\", \
\"required\", \"rev\", \"reversed\", \"role\", \"rows\", \"rowspan\", \
\"spellcheck\", \"scope\", \"selected\", \"shape\", \"size\", \"sizes\", \
\"span\", \"srclang\", \"start\", \"src\", \"srcset\", \"step\", \"style\", \
\"summary\", \"tabindex\", \"title\", \"translate\", \"type\", \"usemap\", \
\"valign\", \"value\", \"width\", \"xmlns\", \"slot\"]);\n      var svg = \
freeze([\"accent-height\", \"accumulate\", \"additive\", \
\"alignment-baseline\", \"ascent\", \"attributename\", \"attributetype\", \
\"azimuth\", \"basefrequency\", \"baseline-shift\", \"begin\", \"bias\", \
\"by\", \"class\", \"clip\", \"clippathunits\", \"clip-path\", \"clip-rule\", \
\"color\", \"color-interpolation\", \"color-interpolation-filters\", \
\"color-profile\", \"color-rendering\", \"cx\", \"cy\", \"d\", \"dx\", \
\"dy\", \"diffuseconstant\", \"direction\", \"display\", \"divisor\", \
\"dur\", \"edgemode\", \"elevation\", \"end\", \"fill\", \"fill-opacity\", \
\"fill-rule\", \"filter\", \"filterunits\", \"flood-color\", \
\"flood-opacity\", \"font-family\", \"font-size\", \"font-size-adjust\", \
\"font-stretch\", \"font-style\", \"font-variant\", \"font-weight\", \"fx\", \
\"fy\", \"g1\", \"g2\", \"glyph-name\", \"glyphref\", \"gradientunits\", \
\"gradienttransform\", \"height\", \"href\", \"id\", \"image-rendering\", \
\"in\", \"in2\", \"k\", \"k1\", \"k2\", \"k3\", \"k4\", \"kerning\", \
\"keypoints\", \"keysplines\", \"keytimes\", \"lang\", \"lengthadjust\", \
\"letter-spacing\", \"kernelmatrix\", \"kernelunitlength\", \
\"lighting-color\", \"local\", \"marker-end\", \"marker-mid\", \
\"marker-start\", \"markerheight\", \"markerunits\", \"markerwidth\", \
\"maskcontentunits\", \"maskunits\", \"max\", \"mask\", \"media\", \
\"method\", \"mode\", \"min\", \"name\", \"numoctaves\", \"offset\", \
\"operator\", \"opacity\", \"order\", \"orient\", \"orientation\", \
\"origin\", \"overflow\", \"paint-order\", \"path\", \"pathlength\", \
\"patterncontentunits\", \"patterntransform\", \"patternunits\", \"points\", \
\"preservealpha\", \"preserveaspectratio\", \"primitiveunits\", \"r\", \
\"rx\", \"ry\", \"radius\", \"refx\", \"refy\", \"repeatcount\", \
\"repeatdur\", \"restart\", \"result\", \"rotate\", \"scale\", \"seed\", \
\"shape-rendering\", \"specularconstant\", \"specularexponent\", \
\"spreadmethod\", \"startoffset\", \"stddeviation\", \"stitchtiles\", \
\"stop-color\", \"stop-opacity\", \"stroke-dasharray\", \
\"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\", \
\"stroke-miterlimit\", \"stroke-opacity\", \"stroke\", \"stroke-width\", \
\"style\", \"surfacescale\", \"systemlanguage\", \"tabindex\", \"targetx\", \
\"targety\", \"transform\", \"transform-origin\", \"text-anchor\", \
\"text-decoration\", \"text-rendering\", \"textlength\", \"type\", \"u1\", \
\"u2\", \"unicode\", \"values\", \"viewbox\", \"visibility\", \"version\", \
\"vert-adv-y\", \"vert-origin-x\", \"vert-origin-y\", \"width\", \
\"word-spacing\", \"wrap\", \"writing-mode\", \"xchannelselector\", \
\"ychannelselector\", \"x\", \"x1\", \"x2\", \"xmlns\", \"y\", \"y1\", \
\"y2\", \"z\", \"zoomandpan\"]);\n      var mathMl = freeze([\"accent\", \
\"accentunder\", \"align\", \"bevelled\", \"close\", \"columnsalign\", \
\"columnlines\", \"columnspan\", \"denomalign\", \"depth\", \"dir\", \
\"display\", \"displaystyle\", \"encoding\", \"fence\", \"frame\", \
\"height\", \"href\", \"id\", \"largeop\", \"length\", \"linethickness\", \
\"lspace\", \"lquote\", \"mathbackground\", \"mathcolor\", \"mathsize\", \
\"mathvariant\", \"maxsize\", \"minsize\", \"movablelimits\", \"notation\", \
\"numalign\", \"open\", \"rowalign\", \"rowlines\", \"rowspacing\", \
\"rowspan\", \"rspace\", \"rquote\", \"scriptlevel\", \"scriptminsize\", \
\"scriptsizemultiplier\", \"selection\", \"separator\", \"separators\", \
\"stretchy\", \"subscriptshift\", \"supscriptshift\", \"symmetric\", \
\"voffset\", \"width\", \"xmlns\"]);\n      var xml = freeze([\"xlink:href\", \
\"xml:id\", \"xlink:title\", \"xml:space\", \"xmlns:xlink\"]);\n      var \
MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm);\n      var \
ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n      var TMPLIT_EXPR = \
seal(/\\${[\\w\\W]*}/gm);\n      var DATA_ATTR = \
seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n      var ARIA_ATTR = \
seal(/^aria-[\\-\\w]+$/);\n      var IS_ALLOWED_URI = seal(\n        \
/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+\
.\\-:]|$))/i\n        // eslint-disable-line no-useless-escape\n      );\n    \
  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n      var \
ATTR_WHITESPACE = seal(\n        \
/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g\n      \
  // eslint-disable-line no-control-regex\n      );\n      var DOCTYPE_NAME = \
seal(/^html$/i);\n      var getGlobal = function getGlobal2() {\n        \
return typeof window === \"undefined\" ? null : window;\n      };\n      var \
_createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, \
document2) {\n        if (_typeof(trustedTypes) !== \"object\" || typeof \
trustedTypes.createPolicy !== \"function\") {\n          return null;\n       \
 }\n        var suffix = null;\n        var ATTR_NAME = \
\"data-tt-policy-suffix\";\n        if (document2.currentScript && \
document2.currentScript.hasAttribute(ATTR_NAME)) {\n          suffix = \
document2.currentScript.getAttribute(ATTR_NAME);\n        }\n        var \
policyName = \"dompurify\" + (suffix ? \"#\" + suffix : \"\");\n        try \
{\n          return trustedTypes.createPolicy(policyName, {\n            \
createHTML: function createHTML(html2) {\n              return html2;\n       \
     },\n            createScriptURL: function createScriptURL(scriptUrl) {\n \
             return scriptUrl;\n            }\n          });\n        } catch \
(_) {\n          console.warn(\"TrustedTypes policy \" + policyName + \" \
could not be created.\");\n          return null;\n        }\n      };\n      \
function createDOMPurify() {\n        var window2 = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : getGlobal();\n        var DOMPurify2 \
= function DOMPurify3(root) {\n          return createDOMPurify(root);\n      \
  };\n        DOMPurify2.version = \"2.4.7\";\n        DOMPurify2.removed = \
[];\n        if (!window2 || !window2.document || window2.document.nodeType \
!== 9) {\n          DOMPurify2.isSupported = false;\n          return \
DOMPurify2;\n        }\n        var originalDocument = window2.document;\n    \
    var document2 = window2.document;\n        var DocumentFragment = \
window2.DocumentFragment, HTMLTemplateElement2 = window2.HTMLTemplateElement, \
Node2 = window2.Node, Element = window2.Element, NodeFilter = \
window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap \
= _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || \
window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = \
window2.HTMLFormElement, DOMParser = window2.DOMParser, trustedTypes = \
window2.trustedTypes;\n        var ElementPrototype = Element.prototype;\n    \
    var cloneNode = lookupGetter(ElementPrototype, \"cloneNode\");\n        \
var getNextSibling = lookupGetter(ElementPrototype, \"nextSibling\");\n       \
 var getChildNodes = lookupGetter(ElementPrototype, \"childNodes\");\n        \
var getParentNode = lookupGetter(ElementPrototype, \"parentNode\");\n        \
if (typeof HTMLTemplateElement2 === \"function\") {\n          var template = \
document2.createElement(\"template\");\n          if (template.content && \
template.content.ownerDocument) {\n            document2 = \
template.content.ownerDocument;\n          }\n        }\n        var \
trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, \
originalDocument);\n        var emptyHTML = trustedTypesPolicy ? \
trustedTypesPolicy.createHTML(\"\") : \"\";\n        var _document = \
document2, implementation = _document.implementation, createNodeIterator = \
_document.createNodeIterator, createDocumentFragment = \
_document.createDocumentFragment, getElementsByTagName = \
_document.getElementsByTagName;\n        var importNode = \
originalDocument.importNode;\n        var documentMode = {};\n        try {\n \
         documentMode = clone2(document2).documentMode ? \
document2.documentMode : {};\n        } catch (_) {\n        }\n        var \
hooks = {};\n        DOMPurify2.isSupported = typeof getParentNode === \
\"function\" && implementation && implementation.createHTMLDocument !== void \
0 && documentMode !== 9;\n        var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, \
ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, \
ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, \
ATTR_WHITESPACE$1 = ATTR_WHITESPACE;\n        var IS_ALLOWED_URI$1 = \
IS_ALLOWED_URI;\n        var ALLOWED_TAGS = null;\n        var \
DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), \
_toConsumableArray(svg$1), _toConsumableArray(svgFilters), \
_toConsumableArray(mathMl$1), _toConsumableArray(text)));\n        var \
ALLOWED_ATTR = null;\n        var DEFAULT_ALLOWED_ATTR = addToSet({}, \
[].concat(_toConsumableArray(html), _toConsumableArray(svg), \
_toConsumableArray(mathMl), _toConsumableArray(xml)));\n        var \
CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n          \
tagNameCheck: {\n            writable: true,\n            configurable: \
false,\n            enumerable: true,\n            value: null\n          \
},\n          attributeNameCheck: {\n            writable: true,\n            \
configurable: false,\n            enumerable: true,\n            value: \
null\n          },\n          allowCustomizedBuiltInElements: {\n            \
writable: true,\n            configurable: false,\n            enumerable: \
true,\n            value: false\n          }\n        }));\n        var \
FORBID_TAGS = null;\n        var FORBID_ATTR = null;\n        var \
ALLOW_ARIA_ATTR = true;\n        var ALLOW_DATA_ATTR = true;\n        var \
ALLOW_UNKNOWN_PROTOCOLS = false;\n        var ALLOW_SELF_CLOSE_IN_ATTR = \
true;\n        var SAFE_FOR_TEMPLATES = false;\n        var WHOLE_DOCUMENT = \
false;\n        var SET_CONFIG = false;\n        var FORCE_BODY = false;\n    \
    var RETURN_DOM = false;\n        var RETURN_DOM_FRAGMENT = false;\n       \
 var RETURN_TRUSTED_TYPE = false;\n        var SANITIZE_DOM = true;\n        \
var SANITIZE_NAMED_PROPS = false;\n        var SANITIZE_NAMED_PROPS_PREFIX = \
\"user-content-\";\n        var KEEP_CONTENT = true;\n        var IN_PLACE = \
false;\n        var USE_PROFILES = {};\n        var FORBID_CONTENTS = null;\n \
       var DEFAULT_FORBID_CONTENTS = addToSet({}, [\"annotation-xml\", \
\"audio\", \"colgroup\", \"desc\", \"foreignobject\", \"head\", \"iframe\", \
\"math\", \"mi\", \"mn\", \"mo\", \"ms\", \"mtext\", \"noembed\", \
\"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\", \"svg\", \
\"template\", \"thead\", \"title\", \"video\", \"xmp\"]);\n        var \
DATA_URI_TAGS = null;\n        var DEFAULT_DATA_URI_TAGS = addToSet({}, \
[\"audio\", \"video\", \"img\", \"source\", \"image\", \"track\"]);\n        \
var URI_SAFE_ATTRIBUTES = null;\n        var DEFAULT_URI_SAFE_ATTRIBUTES = \
addToSet({}, [\"alt\", \"class\", \"for\", \"id\", \"label\", \"name\", \
\"pattern\", \"placeholder\", \"role\", \"summary\", \"title\", \"value\", \
\"style\", \"xmlns\"]);\n        var MATHML_NAMESPACE = \
\"http://www.w3.org/1998/Math/MathML\";\n        var SVG_NAMESPACE = \
\"http://www.w3.org/2000/svg\";\n        var HTML_NAMESPACE = \
\"http://www.w3.org/1999/xhtml\";\n        var NAMESPACE = HTML_NAMESPACE;\n  \
      var IS_EMPTY_INPUT = false;\n        var ALLOWED_NAMESPACES = null;\n   \
     var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, \
SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n        var \
PARSER_MEDIA_TYPE;\n        var SUPPORTED_PARSER_MEDIA_TYPES = \
[\"application/xhtml+xml\", \"text/html\"];\n        var \
DEFAULT_PARSER_MEDIA_TYPE = \"text/html\";\n        var transformCaseFunc;\n  \
      var CONFIG = null;\n        var formElement = \
document2.createElement(\"form\");\n        var isRegexOrFunction = function \
isRegexOrFunction2(testValue) {\n          return testValue instanceof RegExp \
|| testValue instanceof Function;\n        };\n        var _parseConfig = \
function _parseConfig2(cfg) {\n          if (CONFIG && CONFIG === cfg) {\n    \
        return;\n          }\n          if (!cfg || _typeof(cfg) !== \
\"object\") {\n            cfg = {};\n          }\n          cfg = \
clone2(cfg);\n          PARSER_MEDIA_TYPE = // eslint-disable-next-line \
unicorn/prefer-includes\n          \
SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? \
PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = \
cfg.PARSER_MEDIA_TYPE;\n          transformCaseFunc = PARSER_MEDIA_TYPE === \
\"application/xhtml+xml\" ? stringToString : stringToLowerCase;\n          \
ALLOWED_TAGS = \"ALLOWED_TAGS\" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, \
transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n          ALLOWED_ATTR = \
\"ALLOWED_ATTR\" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : \
DEFAULT_ALLOWED_ATTR;\n          ALLOWED_NAMESPACES = \"ALLOWED_NAMESPACES\" \
in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : \
DEFAULT_ALLOWED_NAMESPACES;\n          URI_SAFE_ATTRIBUTES = \
\"ADD_URI_SAFE_ATTR\" in cfg ? addToSet(\n            \
clone2(DEFAULT_URI_SAFE_ATTRIBUTES),\n            // eslint-disable-line \
indent\n            cfg.ADD_URI_SAFE_ATTR,\n            // \
eslint-disable-line indent\n            transformCaseFunc\n            // \
eslint-disable-line indent\n          ) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      \
    DATA_URI_TAGS = \"ADD_DATA_URI_TAGS\" in cfg ? addToSet(\n            \
clone2(DEFAULT_DATA_URI_TAGS),\n            // eslint-disable-line indent\n   \
         cfg.ADD_DATA_URI_TAGS,\n            // eslint-disable-line indent\n  \
          transformCaseFunc\n            // eslint-disable-line indent\n      \
    ) : DEFAULT_DATA_URI_TAGS;\n          FORBID_CONTENTS = \
\"FORBID_CONTENTS\" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, \
transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n          FORBID_TAGS = \
\"FORBID_TAGS\" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : \
{};\n          FORBID_ATTR = \"FORBID_ATTR\" in cfg ? addToSet({}, \
cfg.FORBID_ATTR, transformCaseFunc) : {};\n          USE_PROFILES = \
\"USE_PROFILES\" in cfg ? cfg.USE_PROFILES : false;\n          \
ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n          ALLOW_DATA_ATTR = \
cfg.ALLOW_DATA_ATTR !== false;\n          ALLOW_UNKNOWN_PROTOCOLS = \
cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n          ALLOW_SELF_CLOSE_IN_ATTR = \
cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;\n          SAFE_FOR_TEMPLATES = \
cfg.SAFE_FOR_TEMPLATES || false;\n          WHOLE_DOCUMENT = \
cfg.WHOLE_DOCUMENT || false;\n          RETURN_DOM = cfg.RETURN_DOM || \
false;\n          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n   \
       RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n          \
FORCE_BODY = cfg.FORCE_BODY || false;\n          SANITIZE_DOM = \
cfg.SANITIZE_DOM !== false;\n          SANITIZE_NAMED_PROPS = \
cfg.SANITIZE_NAMED_PROPS || false;\n          KEEP_CONTENT = cfg.KEEP_CONTENT \
!== false;\n          IN_PLACE = cfg.IN_PLACE || false;\n          \
IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;\n          \
NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n          \
CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n          if \
(cfg.CUSTOM_ELEMENT_HANDLING && \
isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n            \
CUSTOM_ELEMENT_HANDLING.tagNameCheck = \
cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n          }\n          if \
(cfg.CUSTOM_ELEMENT_HANDLING && \
isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n        \
    CUSTOM_ELEMENT_HANDLING.attributeNameCheck = \
cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n          }\n          if \
(cfg.CUSTOM_ELEMENT_HANDLING && typeof \
cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === \"boolean\") \
{\n            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = \
cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n          }\n    \
      if (SAFE_FOR_TEMPLATES) {\n            ALLOW_DATA_ATTR = false;\n       \
   }\n          if (RETURN_DOM_FRAGMENT) {\n            RETURN_DOM = true;\n  \
        }\n          if (USE_PROFILES) {\n            ALLOWED_TAGS = \
addToSet({}, _toConsumableArray(text));\n            ALLOWED_ATTR = [];\n     \
       if (USE_PROFILES.html === true) {\n              \
addToSet(ALLOWED_TAGS, html$1);\n              addToSet(ALLOWED_ATTR, \
html);\n            }\n            if (USE_PROFILES.svg === true) {\n         \
     addToSet(ALLOWED_TAGS, svg$1);\n              addToSet(ALLOWED_ATTR, \
svg);\n              addToSet(ALLOWED_ATTR, xml);\n            }\n            \
if (USE_PROFILES.svgFilters === true) {\n              addToSet(ALLOWED_TAGS, \
svgFilters);\n              addToSet(ALLOWED_ATTR, svg);\n              \
addToSet(ALLOWED_ATTR, xml);\n            }\n            if \
(USE_PROFILES.mathMl === true) {\n              addToSet(ALLOWED_TAGS, \
mathMl$1);\n              addToSet(ALLOWED_ATTR, mathMl);\n              \
addToSet(ALLOWED_ATTR, xml);\n            }\n          }\n          if \
(cfg.ADD_TAGS) {\n            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n  \
            ALLOWED_TAGS = clone2(ALLOWED_TAGS);\n            }\n            \
addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n          }\n       \
   if (cfg.ADD_ATTR) {\n            if (ALLOWED_ATTR === \
DEFAULT_ALLOWED_ATTR) {\n              ALLOWED_ATTR = clone2(ALLOWED_ATTR);\n \
           }\n            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, \
transformCaseFunc);\n          }\n          if (cfg.ADD_URI_SAFE_ATTR) {\n    \
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, \
transformCaseFunc);\n          }\n          if (cfg.FORBID_CONTENTS) {\n      \
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n              \
FORBID_CONTENTS = clone2(FORBID_CONTENTS);\n            }\n            \
addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n          \
}\n          if (KEEP_CONTENT) {\n            ALLOWED_TAGS[\"#text\"] = \
true;\n          }\n          if (WHOLE_DOCUMENT) {\n            \
addToSet(ALLOWED_TAGS, [\"html\", \"head\", \"body\"]);\n          }\n        \
  if (ALLOWED_TAGS.table) {\n            addToSet(ALLOWED_TAGS, \
[\"tbody\"]);\n            delete FORBID_TAGS.tbody;\n          }\n          \
if (freeze) {\n            freeze(cfg);\n          }\n          CONFIG = \
cfg;\n        };\n        var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, \
[\"mi\", \"mo\", \"mn\", \"ms\", \"mtext\"]);\n        var \
HTML_INTEGRATION_POINTS = addToSet({}, [\"foreignobject\", \"desc\", \
\"title\", \"annotation-xml\"]);\n        var COMMON_SVG_AND_HTML_ELEMENTS = \
addToSet({}, [\"title\", \"style\", \"font\", \"a\", \"script\"]);\n        \
var ALL_SVG_TAGS = addToSet({}, svg$1);\n        addToSet(ALL_SVG_TAGS, \
svgFilters);\n        addToSet(ALL_SVG_TAGS, svgDisallowed);\n        var \
ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n        addToSet(ALL_MATHML_TAGS, \
mathMlDisallowed);\n        var _checkValidNamespace = function \
_checkValidNamespace2(element) {\n          var parent2 = \
getParentNode(element);\n          if (!parent2 || !parent2.tagName) {\n      \
      parent2 = {\n              namespaceURI: NAMESPACE,\n              \
tagName: \"template\"\n            };\n          }\n          var tagName = \
stringToLowerCase(element.tagName);\n          var parentTagName = \
stringToLowerCase(parent2.tagName);\n          if \
(!ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return false;\n    \
      }\n          if (element.namespaceURI === SVG_NAMESPACE) {\n            \
if (parent2.namespaceURI === HTML_NAMESPACE) {\n              return tagName \
=== \"svg\";\n            }\n            if (parent2.namespaceURI === \
MATHML_NAMESPACE) {\n              return tagName === \"svg\" && \
(parentTagName === \"annotation-xml\" || \
MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n            }\n            \
return Boolean(ALL_SVG_TAGS[tagName]);\n          }\n          if \
(element.namespaceURI === MATHML_NAMESPACE) {\n            if \
(parent2.namespaceURI === HTML_NAMESPACE) {\n              return tagName === \
\"math\";\n            }\n            if (parent2.namespaceURI === \
SVG_NAMESPACE) {\n              return tagName === \"math\" && \
HTML_INTEGRATION_POINTS[parentTagName];\n            }\n            return \
Boolean(ALL_MATHML_TAGS[tagName]);\n          }\n          if \
(element.namespaceURI === HTML_NAMESPACE) {\n            if \
(parent2.namespaceURI === SVG_NAMESPACE && \
!HTML_INTEGRATION_POINTS[parentTagName]) {\n              return false;\n     \
       }\n            if (parent2.namespaceURI === MATHML_NAMESPACE && \
!MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n              return \
false;\n            }\n            return !ALL_MATHML_TAGS[tagName] && \
(COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n          \
}\n          if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && \
ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return true;\n       \
   }\n          return false;\n        };\n        var _forceRemove = \
function _forceRemove2(node) {\n          arrayPush(DOMPurify2.removed, {\n   \
         element: node\n          });\n          try {\n            \
node.parentNode.removeChild(node);\n          } catch (_) {\n            try \
{\n              node.outerHTML = emptyHTML;\n            } catch (_2) {\n    \
          node.remove();\n            }\n          }\n        };\n        var \
_removeAttribute = function _removeAttribute2(name, node) {\n          try \
{\n            arrayPush(DOMPurify2.removed, {\n              attribute: \
node.getAttributeNode(name),\n              from: node\n            });\n     \
     } catch (_) {\n            arrayPush(DOMPurify2.removed, {\n             \
 attribute: null,\n              from: node\n            });\n          }\n   \
       node.removeAttribute(name);\n          if (name === \"is\" && \
!ALLOWED_ATTR[name]) {\n            if (RETURN_DOM || RETURN_DOM_FRAGMENT) \
{\n              try {\n                _forceRemove(node);\n              } \
catch (_) {\n              }\n            } else {\n              try {\n     \
           node.setAttribute(name, \"\");\n              } catch (_) {\n      \
        }\n            }\n          }\n        };\n        var _initDocument \
= function _initDocument2(dirty) {\n          var doc;\n          var \
leadingWhitespace;\n          if (FORCE_BODY) {\n            dirty = \
\"<remove></remove>\" + dirty;\n          } else {\n            var matches = \
stringMatch(dirty, /^[\\r\\n\\t ]+/);\n            leadingWhitespace = \
matches && matches[0];\n          }\n          if (PARSER_MEDIA_TYPE === \
\"application/xhtml+xml\" && NAMESPACE === HTML_NAMESPACE) {\n            \
dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + \
dirty + \"</body></html>\";\n          }\n          var dirtyPayload = \
trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n          \
if (NAMESPACE === HTML_NAMESPACE) {\n            try {\n              doc = \
new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n           \
 } catch (_) {\n            }\n          }\n          if (!doc || \
!doc.documentElement) {\n            doc = \
implementation.createDocument(NAMESPACE, \"template\", null);\n            \
try {\n              doc.documentElement.innerHTML = IS_EMPTY_INPUT ? \
emptyHTML : dirtyPayload;\n            } catch (_) {\n            }\n         \
 }\n          var body = doc.body || doc.documentElement;\n          if \
(dirty && leadingWhitespace) {\n            \
body.insertBefore(document2.createTextNode(leadingWhitespace), \
body.childNodes[0] || null);\n          }\n          if (NAMESPACE === \
HTML_NAMESPACE) {\n            return getElementsByTagName.call(doc, \
WHOLE_DOCUMENT ? \"html\" : \"body\")[0];\n          }\n          return \
WHOLE_DOCUMENT ? doc.documentElement : body;\n        };\n        var \
_createIterator = function _createIterator2(root) {\n          return \
createNodeIterator.call(\n            root.ownerDocument || root,\n           \
 root,\n            // eslint-disable-next-line no-bitwise\n            \
NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,\n   \
         null,\n            false\n          );\n        };\n        var \
_isClobbered = function _isClobbered2(elm) {\n          return elm instanceof \
HTMLFormElement && (typeof elm.nodeName !== \"string\" || typeof \
elm.textContent !== \"string\" || typeof elm.removeChild !== \"function\" || \
!(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== \
\"function\" || typeof elm.setAttribute !== \"function\" || typeof \
elm.namespaceURI !== \"string\" || typeof elm.insertBefore !== \"function\" \
|| typeof elm.hasChildNodes !== \"function\");\n        };\n        var \
_isNode = function _isNode2(object) {\n          return _typeof(Node2) === \
\"object\" ? object instanceof Node2 : object && _typeof(object) === \
\"object\" && typeof object.nodeType === \"number\" && typeof object.nodeName \
=== \"string\";\n        };\n        var _executeHook = function \
_executeHook2(entryPoint, currentNode, data2) {\n          if \
(!hooks[entryPoint]) {\n            return;\n          }\n          \
arrayForEach(hooks[entryPoint], function(hook2) {\n            \
hook2.call(DOMPurify2, currentNode, data2, CONFIG);\n          });\n        \
};\n        var _sanitizeElements = function _sanitizeElements2(currentNode) \
{\n          var content;\n          _executeHook(\"beforeSanitizeElements\", \
currentNode, null);\n          if (_isClobbered(currentNode)) {\n            \
_forceRemove(currentNode);\n            return true;\n          }\n          \
if (regExpTest(/[\\u0080-\\uFFFF]/, currentNode.nodeName)) {\n            \
_forceRemove(currentNode);\n            return true;\n          }\n          \
var tagName = transformCaseFunc(currentNode.nodeName);\n          \
_executeHook(\"uponSanitizeElement\", currentNode, {\n            tagName,\n  \
          allowedTags: ALLOWED_TAGS\n          });\n          if \
(currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && \
(!_isNode(currentNode.content) || \
!_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, \
currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) \
{\n            _forceRemove(currentNode);\n            return true;\n         \
 }\n          if (tagName === \"select\" && regExpTest(/<template/i, \
currentNode.innerHTML)) {\n            _forceRemove(currentNode);\n           \
 return true;\n          }\n          if (!ALLOWED_TAGS[tagName] || \
FORBID_TAGS[tagName]) {\n            if (!FORBID_TAGS[tagName] && \
_basicCustomElementTest(tagName)) {\n              if \
(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && \
regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\n                \
return false;\n              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck \
instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\n       \
         return false;\n            }\n            if (KEEP_CONTENT && \
!FORBID_CONTENTS[tagName]) {\n              var parentNode = \
getParentNode(currentNode) || currentNode.parentNode;\n              var \
childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n          \
    if (childNodes && parentNode) {\n                var childCount = \
childNodes.length;\n                for (var i = childCount - 1; i >= 0; --i) \
{\n                  parentNode.insertBefore(cloneNode(childNodes[i], true), \
getNextSibling(currentNode));\n                }\n              }\n           \
 }\n            _forceRemove(currentNode);\n            return true;\n        \
  }\n          if (currentNode instanceof Element && \
!_checkValidNamespace(currentNode)) {\n            \
_forceRemove(currentNode);\n            return true;\n          }\n          \
if ((tagName === \"noscript\" || tagName === \"noembed\" || tagName === \
\"noframes\") && regExpTest(/<\\/no(script|embed|frames)/i, \
currentNode.innerHTML)) {\n            _forceRemove(currentNode);\n           \
 return true;\n          }\n          if (SAFE_FOR_TEMPLATES && \
currentNode.nodeType === 3) {\n            content = \
currentNode.textContent;\n            content = stringReplace(content, \
MUSTACHE_EXPR$1, \" \");\n            content = stringReplace(content, \
ERB_EXPR$1, \" \");\n            content = stringReplace(content, \
TMPLIT_EXPR$1, \" \");\n            if (currentNode.textContent !== content) \
{\n              arrayPush(DOMPurify2.removed, {\n                element: \
currentNode.cloneNode()\n              });\n              \
currentNode.textContent = content;\n            }\n          }\n          \
_executeHook(\"afterSanitizeElements\", currentNode, null);\n          return \
false;\n        };\n        var _isValidAttribute = function \
_isValidAttribute2(lcTag, lcName, value) {\n          if (SANITIZE_DOM && \
(lcName === \"id\" || lcName === \"name\") && (value in document2 || value in \
formElement)) {\n            return false;\n          }\n          if \
(ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, \
lcName))\n            ;\n          else if (ALLOW_ARIA_ATTR && \
regExpTest(ARIA_ATTR$1, lcName))\n            ;\n          else if \
(!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n            if (\n          \
    // First condition does a very basic check if a) it's basically a valid \
custom element tagname AND\n              // b) if the tagName passes \
whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n   \
           // and c) if the attribute name passes whatever the user has \
configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n              \
_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck \
instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) \
|| CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && \
CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && \
(CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && \
regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || \
CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && \
CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second \
condition checks if it's an `is`-attribute, AND\n              // the value \
passes whatever the user has configured for \
CUSTOM_ELEMENT_HANDLING.tagNameCheck\n              lcName === \"is\" && \
CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && \
(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && \
regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || \
CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && \
CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))\n            )\n              \
;\n            else {\n              return false;\n            }\n          \
} else if (URI_SAFE_ATTRIBUTES[lcName])\n            ;\n          else if \
(regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, \
\"\")))\n            ;\n          else if ((lcName === \"src\" || lcName === \
\"xlink:href\" || lcName === \"href\") && lcTag !== \"script\" && \
stringIndexOf(value, \"data:\") === 0 && DATA_URI_TAGS[lcTag])\n            \
;\n          else if (ALLOW_UNKNOWN_PROTOCOLS && \
!regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, \
\"\")))\n            ;\n          else if (value) {\n            return \
false;\n          } else\n            ;\n          return true;\n        };\n \
       var _basicCustomElementTest = function \
_basicCustomElementTest2(tagName) {\n          return tagName.indexOf(\"-\") \
> 0;\n        };\n        var _sanitizeAttributes = function \
_sanitizeAttributes2(currentNode) {\n          var attr;\n          var \
value;\n          var lcName;\n          var l;\n          \
_executeHook(\"beforeSanitizeAttributes\", currentNode, null);\n          var \
attributes = currentNode.attributes;\n          if (!attributes) {\n          \
  return;\n          }\n          var hookEvent = {\n            attrName: \
\"\",\n            attrValue: \"\",\n            keepAttr: true,\n            \
allowedAttributes: ALLOWED_ATTR\n          };\n          l = \
attributes.length;\n          while (l--) {\n            attr = \
attributes[l];\n            var _attr = attr, name = _attr.name, namespaceURI \
= _attr.namespaceURI;\n            value = name === \"value\" ? attr.value : \
stringTrim(attr.value);\n            lcName = transformCaseFunc(name);\n      \
      hookEvent.attrName = lcName;\n            hookEvent.attrValue = \
value;\n            hookEvent.keepAttr = true;\n            \
hookEvent.forceKeepAttr = void 0;\n            \
_executeHook(\"uponSanitizeAttribute\", currentNode, hookEvent);\n            \
value = hookEvent.attrValue;\n            if (hookEvent.forceKeepAttr) {\n    \
          continue;\n            }\n            _removeAttribute(name, \
currentNode);\n            if (!hookEvent.keepAttr) {\n              \
continue;\n            }\n            if (!ALLOW_SELF_CLOSE_IN_ATTR && \
regExpTest(/\\/>/i, value)) {\n              _removeAttribute(name, \
currentNode);\n              continue;\n            }\n            if \
(SAFE_FOR_TEMPLATES) {\n              value = stringReplace(value, \
MUSTACHE_EXPR$1, \" \");\n              value = stringReplace(value, \
ERB_EXPR$1, \" \");\n              value = stringReplace(value, \
TMPLIT_EXPR$1, \" \");\n            }\n            var lcTag = \
transformCaseFunc(currentNode.nodeName);\n            if \
(!_isValidAttribute(lcTag, lcName, value)) {\n              continue;\n       \
     }\n            if (SANITIZE_NAMED_PROPS && (lcName === \"id\" || lcName \
=== \"name\")) {\n              _removeAttribute(name, currentNode);\n        \
      value = SANITIZE_NAMED_PROPS_PREFIX + value;\n            }\n           \
 if (trustedTypesPolicy && _typeof(trustedTypes) === \"object\" && typeof \
trustedTypes.getAttributeType === \"function\") {\n              if \
(namespaceURI)\n                ;\n              else {\n                \
switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n                  \
case \"TrustedHTML\": {\n                    value = \
trustedTypesPolicy.createHTML(value);\n                    break;\n           \
       }\n                  case \"TrustedScriptURL\": {\n                    \
value = trustedTypesPolicy.createScriptURL(value);\n                    \
break;\n                  }\n                }\n              }\n            \
}\n            try {\n              if (namespaceURI) {\n                \
currentNode.setAttributeNS(namespaceURI, name, value);\n              } else \
{\n                currentNode.setAttribute(name, value);\n              }\n  \
            arrayPop(DOMPurify2.removed);\n            } catch (_) {\n        \
    }\n          }\n          _executeHook(\"afterSanitizeAttributes\", \
currentNode, null);\n        };\n        var _sanitizeShadowDOM = function \
_sanitizeShadowDOM2(fragment) {\n          var shadowNode;\n          var \
shadowIterator = _createIterator(fragment);\n          \
_executeHook(\"beforeSanitizeShadowDOM\", fragment, null);\n          while \
(shadowNode = shadowIterator.nextNode()) {\n            \
_executeHook(\"uponSanitizeShadowNode\", shadowNode, null);\n            if \
(_sanitizeElements(shadowNode)) {\n              continue;\n            }\n   \
         if (shadowNode.content instanceof DocumentFragment) {\n              \
_sanitizeShadowDOM2(shadowNode.content);\n            }\n            \
_sanitizeAttributes(shadowNode);\n          }\n          \
_executeHook(\"afterSanitizeShadowDOM\", fragment, null);\n        };\n       \
 DOMPurify2.sanitize = function(dirty) {\n          var cfg = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        \
  var body;\n          var importedNode;\n          var currentNode;\n        \
  var oldNode;\n          var returnNode;\n          IS_EMPTY_INPUT = \
!dirty;\n          if (IS_EMPTY_INPUT) {\n            dirty = \"<!-->\";\n    \
      }\n          if (typeof dirty !== \"string\" && !_isNode(dirty)) {\n    \
        if (typeof dirty.toString === \"function\") {\n              dirty = \
dirty.toString();\n              if (typeof dirty !== \"string\") {\n         \
       throw typeErrorCreate(\"dirty is not a string, aborting\");\n          \
    }\n            } else {\n              throw typeErrorCreate(\"toString \
is not a function\");\n            }\n          }\n          if \
(!DOMPurify2.isSupported) {\n            if (_typeof(window2.toStaticHTML) \
=== \"object\" || typeof window2.toStaticHTML === \"function\") {\n           \
   if (typeof dirty === \"string\") {\n                return \
window2.toStaticHTML(dirty);\n              }\n              if \
(_isNode(dirty)) {\n                return \
window2.toStaticHTML(dirty.outerHTML);\n              }\n            }\n      \
      return dirty;\n          }\n          if (!SET_CONFIG) {\n            \
_parseConfig(cfg);\n          }\n          DOMPurify2.removed = [];\n         \
 if (typeof dirty === \"string\") {\n            IN_PLACE = false;\n          \
}\n          if (IN_PLACE) {\n            if (dirty.nodeName) {\n             \
 var tagName = transformCaseFunc(dirty.nodeName);\n              if \
(!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n                throw \
typeErrorCreate(\"root node is forbidden and cannot be sanitized \
in-place\");\n              }\n            }\n          } else if (dirty \
instanceof Node2) {\n            body = _initDocument(\"<!---->\");\n         \
   importedNode = body.ownerDocument.importNode(dirty, true);\n            if \
(importedNode.nodeType === 1 && importedNode.nodeName === \"BODY\") {\n       \
       body = importedNode;\n            } else if (importedNode.nodeName === \
\"HTML\") {\n              body = importedNode;\n            } else {\n       \
       body.appendChild(importedNode);\n            }\n          } else {\n   \
         if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // \
eslint-disable-next-line unicorn/prefer-includes\n            \
dirty.indexOf(\"<\") === -1) {\n              return trustedTypesPolicy && \
RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n         \
   }\n            body = _initDocument(dirty);\n            if (!body) {\n    \
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : \
\"\";\n            }\n          }\n          if (body && FORCE_BODY) {\n      \
      _forceRemove(body.firstChild);\n          }\n          var nodeIterator \
= _createIterator(IN_PLACE ? dirty : body);\n          while (currentNode = \
nodeIterator.nextNode()) {\n            if (currentNode.nodeType === 3 && \
currentNode === oldNode) {\n              continue;\n            }\n          \
  if (_sanitizeElements(currentNode)) {\n              continue;\n            \
}\n            if (currentNode.content instanceof DocumentFragment) {\n       \
       _sanitizeShadowDOM(currentNode.content);\n            }\n            \
_sanitizeAttributes(currentNode);\n            oldNode = currentNode;\n       \
   }\n          oldNode = null;\n          if (IN_PLACE) {\n            \
return dirty;\n          }\n          if (RETURN_DOM) {\n            if \
(RETURN_DOM_FRAGMENT) {\n              returnNode = \
createDocumentFragment.call(body.ownerDocument);\n              while \
(body.firstChild) {\n                \
returnNode.appendChild(body.firstChild);\n              }\n            } else \
{\n              returnNode = body;\n            }\n            if \
(ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {\n              \
returnNode = importNode.call(originalDocument, returnNode, true);\n           \
 }\n            return returnNode;\n          }\n          var serializedHTML \
= WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n          if \
(WHOLE_DOCUMENT && ALLOWED_TAGS[\"!doctype\"] && body.ownerDocument && \
body.ownerDocument.doctype && body.ownerDocument.doctype.name && \
regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n            \
serializedHTML = \"<!DOCTYPE \" + body.ownerDocument.doctype.name + \">\\n\" \
+ serializedHTML;\n          }\n          if (SAFE_FOR_TEMPLATES) {\n         \
   serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, \" \");\n  \
          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, \" \
\");\n            serializedHTML = stringReplace(serializedHTML, \
TMPLIT_EXPR$1, \" \");\n          }\n          return trustedTypesPolicy && \
RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : \
serializedHTML;\n        };\n        DOMPurify2.setConfig = function(cfg) {\n \
         _parseConfig(cfg);\n          SET_CONFIG = true;\n        };\n       \
 DOMPurify2.clearConfig = function() {\n          CONFIG = null;\n          \
SET_CONFIG = false;\n        };\n        DOMPurify2.isValidAttribute = \
function(tag, attr, value) {\n          if (!CONFIG) {\n            \
_parseConfig({});\n          }\n          var lcTag = \
transformCaseFunc(tag);\n          var lcName = transformCaseFunc(attr);\n    \
      return _isValidAttribute(lcTag, lcName, value);\n        };\n        \
DOMPurify2.addHook = function(entryPoint, hookFunction) {\n          if \
(typeof hookFunction !== \"function\") {\n            return;\n          }\n  \
        hooks[entryPoint] = hooks[entryPoint] || [];\n          \
arrayPush(hooks[entryPoint], hookFunction);\n        };\n        \
DOMPurify2.removeHook = function(entryPoint) {\n          if \
(hooks[entryPoint]) {\n            return arrayPop(hooks[entryPoint]);\n      \
    }\n        };\n        DOMPurify2.removeHooks = function(entryPoint) {\n  \
        if (hooks[entryPoint]) {\n            hooks[entryPoint] = [];\n       \
   }\n        };\n        DOMPurify2.removeAllHooks = function() {\n          \
hooks = {};\n        };\n        return DOMPurify2;\n      }\n      var \
purify = createDOMPurify();\n      return purify;\n    });\n  }\n});\n\n// \
node_modules/moment/moment.js\nvar require_moment = __commonJS({\n  \
\"node_modules/moment/moment.js\"(exports, module2) {\n    (function(global3, \
factory) {\n      typeof exports === \"object\" && typeof module2 !== \
\"undefined\" ? module2.exports = factory() : typeof define === \"function\" \
&& define.amd ? define(factory) : global3.moment = factory();\n    \
})(exports, function() {\n      \"use strict\";\n      var hookCallback;\n    \
  function hooks() {\n        return hookCallback.apply(null, arguments);\n   \
   }\n      function setHookCallback(callback) {\n        hookCallback = \
callback;\n      }\n      function isArray(input) {\n        return input \
instanceof Array || Object.prototype.toString.call(input) === \"[object \
Array]\";\n      }\n      function isObject2(input) {\n        return input \
!= null && Object.prototype.toString.call(input) === \"[object Object]\";\n   \
   }\n      function hasOwnProp(a, b) {\n        return \
Object.prototype.hasOwnProperty.call(a, b);\n      }\n      function \
isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n          \
return Object.getOwnPropertyNames(obj).length === 0;\n        } else {\n      \
    var k;\n          for (k in obj) {\n            if (hasOwnProp(obj, k)) \
{\n              return false;\n            }\n          }\n          return \
true;\n        }\n      }\n      function isUndefined2(input) {\n        \
return input === void 0;\n      }\n      function isNumber(input) {\n        \
return typeof input === \"number\" || Object.prototype.toString.call(input) \
=== \"[object Number]\";\n      }\n      function isDate2(input) {\n        \
return input instanceof Date || Object.prototype.toString.call(input) === \
\"[object Date]\";\n      }\n      function map(arr, fn) {\n        var res = \
[], i, arrLen = arr.length;\n        for (i = 0; i < arrLen; ++i) {\n         \
 res.push(fn(arr[i], i));\n        }\n        return res;\n      }\n      \
function extend2(a, b) {\n        for (var i in b) {\n          if \
(hasOwnProp(b, i)) {\n            a[i] = b[i];\n          }\n        }\n      \
  if (hasOwnProp(b, \"toString\")) {\n          a.toString = b.toString;\n    \
    }\n        if (hasOwnProp(b, \"valueOf\")) {\n          a.valueOf = \
b.valueOf;\n        }\n        return a;\n      }\n      function \
createUTC(input, format2, locale2, strict) {\n        return \
createLocalOrUTC(input, format2, locale2, strict, true).utc();\n      }\n     \
 function defaultParsingFlags() {\n        return {\n          empty: \
false,\n          unusedTokens: [],\n          unusedInput: [],\n          \
overflow: -2,\n          charsLeftOver: 0,\n          nullInput: false,\n     \
     invalidEra: null,\n          invalidMonth: null,\n          \
invalidFormat: false,\n          userInvalidated: false,\n          iso: \
false,\n          parsedDateParts: [],\n          era: null,\n          \
meridiem: null,\n          rfc2822: false,\n          weekdayMismatch: \
false\n        };\n      }\n      function getParsingFlags(m) {\n        if \
(m._pf == null) {\n          m._pf = defaultParsingFlags();\n        }\n      \
  return m._pf;\n      }\n      var some;\n      if (Array.prototype.some) \
{\n        some = Array.prototype.some;\n      } else {\n        some = \
function(fun) {\n          var t = Object(this), len = t.length >>> 0, i;\n   \
       for (i = 0; i < len; i++) {\n            if (i in t && fun.call(this, \
t[i], i, t)) {\n              return true;\n            }\n          }\n      \
    return false;\n        };\n      }\n      function isValid(m) {\n        \
if (m._isValid == null) {\n          var flags = getParsingFlags(m), \
parsedParts = some.call(flags.parsedDateParts, function(i) {\n            \
return i != null;\n          }), isNowValid = !isNaN(m._d.getTime()) && \
flags.overflow < 0 && !flags.empty && !flags.invalidEra && \
!flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && \
!flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && \
(!flags.meridiem || flags.meridiem && parsedParts);\n          if (m._strict) \
{\n            isNowValid = isNowValid && flags.charsLeftOver === 0 && \
flags.unusedTokens.length === 0 && flags.bigHour === void 0;\n          }\n   \
       if (Object.isFrozen == null || !Object.isFrozen(m)) {\n            \
m._isValid = isNowValid;\n          } else {\n            return \
isNowValid;\n          }\n        }\n        return m._isValid;\n      }\n    \
  function createInvalid(flags) {\n        var m = createUTC(NaN);\n        \
if (flags != null) {\n          extend2(getParsingFlags(m), flags);\n        \
} else {\n          getParsingFlags(m).userInvalidated = true;\n        }\n   \
     return m;\n      }\n      var momentProperties = hooks.momentProperties \
= [], updateInProgress = false;\n      function copyConfig(to2, from2) {\n    \
    var i, prop, val, momentPropertiesLen = momentProperties.length;\n        \
if (!isUndefined2(from2._isAMomentObject)) {\n          to2._isAMomentObject \
= from2._isAMomentObject;\n        }\n        if (!isUndefined2(from2._i)) \
{\n          to2._i = from2._i;\n        }\n        if \
(!isUndefined2(from2._f)) {\n          to2._f = from2._f;\n        }\n        \
if (!isUndefined2(from2._l)) {\n          to2._l = from2._l;\n        }\n     \
   if (!isUndefined2(from2._strict)) {\n          to2._strict = \
from2._strict;\n        }\n        if (!isUndefined2(from2._tzm)) {\n         \
 to2._tzm = from2._tzm;\n        }\n        if (!isUndefined2(from2._isUTC)) \
{\n          to2._isUTC = from2._isUTC;\n        }\n        if \
(!isUndefined2(from2._offset)) {\n          to2._offset = from2._offset;\n    \
    }\n        if (!isUndefined2(from2._pf)) {\n          to2._pf = \
getParsingFlags(from2);\n        }\n        if (!isUndefined2(from2._locale)) \
{\n          to2._locale = from2._locale;\n        }\n        if \
(momentPropertiesLen > 0) {\n          for (i = 0; i < momentPropertiesLen; \
i++) {\n            prop = momentProperties[i];\n            val = \
from2[prop];\n            if (!isUndefined2(val)) {\n              to2[prop] \
= val;\n            }\n          }\n        }\n        return to2;\n      }\n \
     function Moment(config) {\n        copyConfig(this, config);\n        \
this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        \
if (!this.isValid()) {\n          this._d = /* @__PURE__ */ new Date(NaN);\n  \
      }\n        if (updateInProgress === false) {\n          \
updateInProgress = true;\n          hooks.updateOffset(this);\n          \
updateInProgress = false;\n        }\n      }\n      function isMoment(obj) \
{\n        return obj instanceof Moment || obj != null && \
obj._isAMomentObject != null;\n      }\n      function warn2(msg) {\n        \
if (hooks.suppressDeprecationWarnings === false && typeof console !== \
\"undefined\" && console.warn) {\n          console.warn(\"Deprecation \
warning: \" + msg);\n        }\n      }\n      function deprecate(msg, fn) \
{\n        var firstTime = true;\n        return extend2(function() {\n       \
   if (hooks.deprecationHandler != null) {\n            \
hooks.deprecationHandler(null, msg);\n          }\n          if (firstTime) \
{\n            var args = [], arg, i, key, argLen = arguments.length;\n       \
     for (i = 0; i < argLen; i++) {\n              arg = \"\";\n              \
if (typeof arguments[i] === \"object\") {\n                arg += \"\\n[\" + \
i + \"] \";\n                for (key in arguments[0]) {\n                  \
if (hasOwnProp(arguments[0], key)) {\n                    arg += key + \": \" \
+ arguments[0][key] + \", \";\n                  }\n                }\n       \
         arg = arg.slice(0, -2);\n              } else {\n                arg \
= arguments[i];\n              }\n              args.push(arg);\n            \
}\n            warn2(\n              msg + \"\\nArguments: \" + \
Array.prototype.slice.call(args).join(\"\") + \"\\n\" + new Error().stack\n   \
         );\n            firstTime = false;\n          }\n          return \
fn.apply(this, arguments);\n        }, fn);\n      }\n      var deprecations \
= {};\n      function deprecateSimple(name, msg) {\n        if \
(hooks.deprecationHandler != null) {\n          \
hooks.deprecationHandler(name, msg);\n        }\n        if \
(!deprecations[name]) {\n          warn2(msg);\n          deprecations[name] \
= true;\n        }\n      }\n      hooks.suppressDeprecationWarnings = \
false;\n      hooks.deprecationHandler = null;\n      function \
isFunction2(input) {\n        return typeof Function !== \"undefined\" && \
input instanceof Function || Object.prototype.toString.call(input) === \
\"[object Function]\";\n      }\n      function set(config) {\n        var \
prop, i;\n        for (i in config) {\n          if (hasOwnProp(config, i)) \
{\n            prop = config[i];\n            if (isFunction2(prop)) {\n      \
        this[i] = prop;\n            } else {\n              this[\"_\" + i] \
= prop;\n            }\n          }\n        }\n        this._config = \
config;\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n          \
(this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + \"|\" + \
/\\d{1,2}/.source\n        );\n      }\n      function \
mergeConfigs(parentConfig, childConfig) {\n        var res = extend2({}, \
parentConfig), prop;\n        for (prop in childConfig) {\n          if \
(hasOwnProp(childConfig, prop)) {\n            if \
(isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {\n           \
   res[prop] = {};\n              extend2(res[prop], parentConfig[prop]);\n   \
           extend2(res[prop], childConfig[prop]);\n            } else if \
(childConfig[prop] != null) {\n              res[prop] = childConfig[prop];\n \
           } else {\n              delete res[prop];\n            }\n         \
 }\n        }\n        for (prop in parentConfig) {\n          if \
(hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && \
isObject2(parentConfig[prop])) {\n            res[prop] = extend2({}, \
res[prop]);\n          }\n        }\n        return res;\n      }\n      \
function Locale(config) {\n        if (config != null) {\n          \
this.set(config);\n        }\n      }\n      var keys;\n      if \
(Object.keys) {\n        keys = Object.keys;\n      } else {\n        keys = \
function(obj) {\n          var i, res = [];\n          for (i in obj) {\n     \
       if (hasOwnProp(obj, i)) {\n              res.push(i);\n            }\n \
         }\n          return res;\n        };\n      }\n      var \
defaultCalendar = {\n        sameDay: \"[Today at] LT\",\n        nextDay: \
\"[Tomorrow at] LT\",\n        nextWeek: \"dddd [at] LT\",\n        lastDay: \
\"[Yesterday at] LT\",\n        lastWeek: \"[Last] dddd [at] LT\",\n        \
sameElse: \"L\"\n      };\n      function calendar(key, mom, now2) {\n        \
var output = this._calendar[key] || this._calendar[\"sameElse\"];\n        \
return isFunction2(output) ? output.call(mom, now2) : output;\n      }\n      \
function zeroFill(number, targetLength, forceSign) {\n        var absNumber = \
\"\" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 \
= number >= 0;\n        return (sign2 ? forceSign ? \"+\" : \"\" : \"-\") + \
Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    \
  }\n      var formattingTokens = \
/(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[\
o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|\
e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = \
/(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, \
formatTokenFunctions = {};\n      function addFormatToken(token2, padded, \
ordinal2, callback) {\n        var func = callback;\n        if (typeof \
callback === \"string\") {\n          func = function() {\n            return \
this[callback]();\n          };\n        }\n        if (token2) {\n          \
formatTokenFunctions[token2] = func;\n        }\n        if (padded) {\n      \
    formatTokenFunctions[padded[0]] = function() {\n            return \
zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n          };\n  \
      }\n        if (ordinal2) {\n          formatTokenFunctions[ordinal2] = \
function() {\n            return this.localeData().ordinal(\n              \
func.apply(this, arguments),\n              token2\n            );\n          \
};\n        }\n      }\n      function removeFormattingTokens(input) {\n      \
  if (input.match(/\\[[\\s\\S]/)) {\n          return \
input.replace(/^\\[|\\]$/g, \"\");\n        }\n        return \
input.replace(/\\\\/g, \"\");\n      }\n      function \
makeFormatFunction(format2) {\n        var array = \
format2.match(formattingTokens), i, length;\n        for (i = 0, length = \
array.length; i < length; i++) {\n          if \
(formatTokenFunctions[array[i]]) {\n            array[i] = \
formatTokenFunctions[array[i]];\n          } else {\n            array[i] = \
removeFormattingTokens(array[i]);\n          }\n        }\n        return \
function(mom) {\n          var output = \"\", i2;\n          for (i2 = 0; i2 \
< length; i2++) {\n            output += isFunction2(array[i2]) ? \
array[i2].call(mom, format2) : array[i2];\n          }\n          return \
output;\n        };\n      }\n      function formatMoment(m, format2) {\n     \
   if (!m.isValid()) {\n          return m.localeData().invalidDate();\n      \
  }\n        format2 = expandFormat(format2, m.localeData());\n        \
formatFunctions[format2] = formatFunctions[format2] || \
makeFormatFunction(format2);\n        return formatFunctions[format2](m);\n   \
   }\n      function expandFormat(format2, locale2) {\n        var i = 5;\n   \
     function replaceLongDateFormatTokens(input) {\n          return \
locale2.longDateFormat(input) || input;\n        }\n        \
localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && \
localFormattingTokens.test(format2)) {\n          format2 = \
format2.replace(\n            localFormattingTokens,\n            \
replaceLongDateFormatTokens\n          );\n          \
localFormattingTokens.lastIndex = 0;\n          i -= 1;\n        }\n        \
return format2;\n      }\n      var defaultLongDateFormat = {\n        LTS: \
\"h:mm:ss A\",\n        LT: \"h:mm A\",\n        L: \"MM/DD/YYYY\",\n        \
LL: \"MMMM D, YYYY\",\n        LLL: \"MMMM D, YYYY h:mm A\",\n        LLLL: \
\"dddd, MMMM D, YYYY h:mm A\"\n      };\n      function longDateFormat(key) \
{\n        var format2 = this._longDateFormat[key], formatUpper = \
this._longDateFormat[key.toUpperCase()];\n        if (format2 || \
!formatUpper) {\n          return format2;\n        }\n        \
this._longDateFormat[key] = \
formatUpper.match(formattingTokens).map(function(tok) {\n          if (tok \
=== \"MMMM\" || tok === \"MM\" || tok === \"DD\" || tok === \"dddd\") {\n     \
       return tok.slice(1);\n          }\n          return tok;\n        \
}).join(\"\");\n        return this._longDateFormat[key];\n      }\n      var \
defaultInvalidDate = \"Invalid date\";\n      function invalidDate() {\n      \
  return this._invalidDate;\n      }\n      var defaultOrdinal = \"%d\", \
defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n      function ordinal(number) \
{\n        return this._ordinal.replace(\"%d\", number);\n      }\n      var \
defaultRelativeTime = {\n        future: \"in %s\",\n        past: \"%s \
ago\",\n        s: \"a few seconds\",\n        ss: \"%d seconds\",\n        \
m: \"a minute\",\n        mm: \"%d minutes\",\n        h: \"an hour\",\n      \
  hh: \"%d hours\",\n        d: \"a day\",\n        dd: \"%d days\",\n        \
w: \"a week\",\n        ww: \"%d weeks\",\n        M: \"a month\",\n        \
MM: \"%d months\",\n        y: \"a year\",\n        yy: \"%d years\"\n      \
};\n      function relativeTime(number, withoutSuffix, string, isFuture) {\n  \
      var output = this._relativeTime[string];\n        return \
isFunction2(output) ? output(number, withoutSuffix, string, isFuture) : \
output.replace(/%d/i, number);\n      }\n      function pastFuture(diff2, \
output) {\n        var format2 = this._relativeTime[diff2 > 0 ? \"future\" : \
\"past\"];\n        return isFunction2(format2) ? format2(output) : \
format2.replace(/%s/i, output);\n      }\n      var aliases = {};\n      \
function addUnitAlias(unit, shorthand) {\n        var lowerCase = \
unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + \"s\"] \
= aliases[shorthand] = unit;\n      }\n      function normalizeUnits(units) \
{\n        return typeof units === \"string\" ? aliases[units] || \
aliases[units.toLowerCase()] : void 0;\n      }\n      function \
normalizeObjectUnits(inputObject) {\n        var normalizedInput = {}, \
normalizedProp, prop;\n        for (prop in inputObject) {\n          if \
(hasOwnProp(inputObject, prop)) {\n            normalizedProp = \
normalizeUnits(prop);\n            if (normalizedProp) {\n              \
normalizedInput[normalizedProp] = inputObject[prop];\n            }\n         \
 }\n        }\n        return normalizedInput;\n      }\n      var priorities \
= {};\n      function addUnitPriority(unit, priority) {\n        \
priorities[unit] = priority;\n      }\n      function \
getPrioritizedUnits(unitsObj) {\n        var units = [], u;\n        for (u \
in unitsObj) {\n          if (hasOwnProp(unitsObj, u)) {\n            \
units.push({ unit: u, priority: priorities[u] });\n          }\n        }\n   \
     units.sort(function(a, b) {\n          return a.priority - b.priority;\n \
       });\n        return units;\n      }\n      function isLeapYear(year) \
{\n        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n   \
   }\n      function absFloor(number) {\n        if (number < 0) {\n          \
return Math.ceil(number) || 0;\n        } else {\n          return \
Math.floor(number);\n        }\n      }\n      function \
toInt(argumentForCoercion) {\n        var coercedNumber = \
+argumentForCoercion, value = 0;\n        if (coercedNumber !== 0 && \
isFinite(coercedNumber)) {\n          value = absFloor(coercedNumber);\n      \
  }\n        return value;\n      }\n      function makeGetSet(unit, \
keepTime) {\n        return function(value) {\n          if (value != null) \
{\n            set$1(this, unit, value);\n            \
hooks.updateOffset(this, keepTime);\n            return this;\n          } \
else {\n            return get(this, unit);\n          }\n        };\n      \
}\n      function get(mom, unit) {\n        return mom.isValid() ? \
mom._d[\"get\" + (mom._isUTC ? \"UTC\" : \"\") + unit]() : NaN;\n      }\n    \
  function set$1(mom, unit, value) {\n        if (mom.isValid() && \
!isNaN(value)) {\n          if (unit === \"FullYear\" && \
isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n         \
   value = toInt(value);\n            mom._d[\"set\" + (mom._isUTC ? \"UTC\" \
: \"\") + unit](\n              value,\n              mom.month(),\n          \
    daysInMonth(value, mom.month())\n            );\n          } else {\n     \
       mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + unit](value);\n       \
   }\n        }\n      }\n      function stringGet(units) {\n        units = \
normalizeUnits(units);\n        if (isFunction2(this[units])) {\n          \
return this[units]();\n        }\n        return this;\n      }\n      \
function stringSet(units, value) {\n        if (typeof units === \"object\") \
{\n          units = normalizeObjectUnits(units);\n          var prioritized \
= getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;\n       \
   for (i = 0; i < prioritizedLen; i++) {\n            \
this[prioritized[i].unit](units[prioritized[i].unit]);\n          }\n        \
} else {\n          units = normalizeUnits(units);\n          if \
(isFunction2(this[units])) {\n            return this[units](value);\n        \
  }\n        }\n        return this;\n      }\n      var match1 = /\\d/, \
match2 = /\\d\\d/, match3 = /\\d{3}/, match4 = /\\d{4}/, match6 = \
/[+-]?\\d{6}/, match1to2 = /\\d\\d?/, match3to4 = /\\d\\d\\d\\d?/, match5to6 \
= /\\d\\d\\d\\d\\d\\d?/, match1to3 = /\\d{1,3}/, match1to4 = /\\d{1,4}/, \
match1to6 = /[+-]?\\d{1,6}/, matchUnsigned = /\\d+/, matchSigned = \
/[+-]?\\d+/, matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi, matchShortOffset = \
/Z|[+-]\\d\\d(?::?\\d\\d)?/gi, matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/, \
matchWord = \
/[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF0\
7\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1\
,256}){1,2}/i, regexes;\n      regexes = {};\n      function \
addRegexToken(token2, regex, strictRegex) {\n        regexes[token2] = \
isFunction2(regex) ? regex : function(isStrict, localeData2) {\n          \
return isStrict && strictRegex ? strictRegex : regex;\n        };\n      }\n  \
    function getParseRegexForToken(token2, config) {\n        if \
(!hasOwnProp(regexes, token2)) {\n          return new \
RegExp(unescapeFormat(token2));\n        }\n        return \
regexes[token2](config._strict, config._locale);\n      }\n      function \
unescapeFormat(s) {\n        return regexEscape(\n          \
s.replace(\"\\\\\", \"\").replace(\n            \
/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g,\n            \
function(matched, p1, p2, p3, p4) {\n              return p1 || p2 || p3 || \
p4;\n            }\n          )\n        );\n      }\n      function \
regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \
\"\\\\$&\");\n      }\n      var tokens = {};\n      function \
addParseToken(token2, callback) {\n        var i, func = callback, \
tokenLen;\n        if (typeof token2 === \"string\") {\n          token2 = \
[token2];\n        }\n        if (isNumber(callback)) {\n          func = \
function(input, array) {\n            array[callback] = toInt(input);\n       \
   };\n        }\n        tokenLen = token2.length;\n        for (i = 0; i < \
tokenLen; i++) {\n          tokens[token2[i]] = func;\n        }\n      }\n   \
   function addWeekParseToken(token2, callback) {\n        \
addParseToken(token2, function(input, array, config, token3) {\n          \
config._w = config._w || {};\n          callback(input, config._w, config, \
token3);\n        });\n      }\n      function \
addTimeToArrayFromToken(token2, input, config) {\n        if (input != null \
&& hasOwnProp(tokens, token2)) {\n          tokens[token2](input, config._a, \
config, token2);\n        }\n      }\n      var YEAR = 0, MONTH = 1, DATE = \
2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = \
8;\n      function mod(n, x) {\n        return (n % x + x) % x;\n      }\n    \
  var indexOf;\n      if (Array.prototype.indexOf) {\n        indexOf = \
Array.prototype.indexOf;\n      } else {\n        indexOf = function(o) {\n   \
       var i;\n          for (i = 0; i < this.length; ++i) {\n            if \
(this[i] === o) {\n              return i;\n            }\n          }\n      \
    return -1;\n        };\n      }\n      function daysInMonth(year, month) \
{\n        if (isNaN(year) || isNaN(month)) {\n          return NaN;\n        \
}\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) \
/ 12;\n        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - \
modMonth % 7 % 2;\n      }\n      addFormatToken(\"M\", [\"MM\", 2], \"Mo\", \
function() {\n        return this.month() + 1;\n      });\n      \
addFormatToken(\"MMM\", 0, 0, function(format2) {\n        return \
this.localeData().monthsShort(this, format2);\n      });\n      \
addFormatToken(\"MMMM\", 0, 0, function(format2) {\n        return \
this.localeData().months(this, format2);\n      });\n      \
addUnitAlias(\"month\", \"M\");\n      addUnitPriority(\"month\", 8);\n      \
addRegexToken(\"M\", match1to2);\n      addRegexToken(\"MM\", match1to2, \
match2);\n      addRegexToken(\"MMM\", function(isStrict, locale2) {\n        \
return locale2.monthsShortRegex(isStrict);\n      });\n      \
addRegexToken(\"MMMM\", function(isStrict, locale2) {\n        return \
locale2.monthsRegex(isStrict);\n      });\n      addParseToken([\"M\", \
\"MM\"], function(input, array) {\n        array[MONTH] = toInt(input) - 1;\n \
     });\n      addParseToken([\"MMM\", \"MMMM\"], function(input, array, \
config, token2) {\n        var month = config._locale.monthsParse(input, \
token2, config._strict);\n        if (month != null) {\n          \
array[MONTH] = month;\n        } else {\n          \
getParsingFlags(config).invalidMonth = input;\n        }\n      });\n      \
var defaultLocaleMonths = \
\"January_February_March_April_May_June_July_August_September_October_Novembe\
r_December\".split(\n        \"_\"\n      ), defaultLocaleMonthsShort = \
\"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\".split(\"_\"), \
MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/, \
defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;\n      \
function localeMonths(m, format2) {\n        if (!m) {\n          return \
isArray(this._months) ? this._months : this._months[\"standalone\"];\n        \
}\n        return isArray(this._months) ? this._months[m.month()] : \
this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? \
\"format\" : \"standalone\"][m.month()];\n      }\n      function \
localeMonthsShort(m, format2) {\n        if (!m) {\n          return \
isArray(this._monthsShort) ? this._monthsShort : \
this._monthsShort[\"standalone\"];\n        }\n        return \
isArray(this._monthsShort) ? this._monthsShort[m.month()] : \
this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? \"format\" : \
\"standalone\"][m.month()];\n      }\n      function \
handleStrictParse(monthName, format2, strict) {\n        var i, ii, mom, llc \
= monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n         \
 this._monthsParse = [];\n          this._longMonthsParse = [];\n          \
this._shortMonthsParse = [];\n          for (i = 0; i < 12; ++i) {\n          \
  mom = createUTC([2e3, i]);\n            this._shortMonthsParse[i] = \
this.monthsShort(\n              mom,\n              \"\"\n            \
).toLocaleLowerCase();\n            this._longMonthsParse[i] = \
this.months(mom, \"\").toLocaleLowerCase();\n          }\n        }\n        \
if (strict) {\n          if (format2 === \"MMM\") {\n            ii = \
indexOf.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii \
: null;\n          } else {\n            ii = \
indexOf.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii \
: null;\n          }\n        } else {\n          if (format2 === \"MMM\") \
{\n            ii = indexOf.call(this._shortMonthsParse, llc);\n            \
if (ii !== -1) {\n              return ii;\n            }\n            ii = \
indexOf.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii \
: null;\n          } else {\n            ii = \
indexOf.call(this._longMonthsParse, llc);\n            if (ii !== -1) {\n     \
         return ii;\n            }\n            ii = \
indexOf.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii \
: null;\n          }\n        }\n      }\n      function \
localeMonthsParse(monthName, format2, strict) {\n        var i, mom, regex;\n \
       if (this._monthsParseExact) {\n          return \
handleStrictParse.call(this, monthName, format2, strict);\n        }\n        \
if (!this._monthsParse) {\n          this._monthsParse = [];\n          \
this._longMonthsParse = [];\n          this._shortMonthsParse = [];\n        \
}\n        for (i = 0; i < 12; i++) {\n          mom = createUTC([2e3, i]);\n \
         if (strict && !this._longMonthsParse[i]) {\n            \
this._longMonthsParse[i] = new RegExp(\n              \"^\" + \
this.months(mom, \"\").replace(\".\", \"\") + \"$\",\n              \"i\"\n   \
         );\n            this._shortMonthsParse[i] = new RegExp(\n            \
  \"^\" + this.monthsShort(mom, \"\").replace(\".\", \"\") + \"$\",\n         \
     \"i\"\n            );\n          }\n          if (!strict && \
!this._monthsParse[i]) {\n            regex = \"^\" + this.months(mom, \"\") \
+ \"|^\" + this.monthsShort(mom, \"\");\n            this._monthsParse[i] = \
new RegExp(regex.replace(\".\", \"\"), \"i\");\n          }\n          if \
(strict && format2 === \"MMMM\" && this._longMonthsParse[i].test(monthName)) \
{\n            return i;\n          } else if (strict && format2 === \"MMM\" \
&& this._shortMonthsParse[i].test(monthName)) {\n            return i;\n      \
    } else if (!strict && this._monthsParse[i].test(monthName)) {\n           \
 return i;\n          }\n        }\n      }\n      function setMonth(mom, \
value) {\n        var dayOfMonth;\n        if (!mom.isValid()) {\n          \
return mom;\n        }\n        if (typeof value === \"string\") {\n          \
if (/^\\d+$/.test(value)) {\n            value = toInt(value);\n          } \
else {\n            value = mom.localeData().monthsParse(value);\n            \
if (!isNumber(value)) {\n              return mom;\n            }\n          \
}\n        }\n        dayOfMonth = Math.min(mom.date(), \
daysInMonth(mom.year(), value));\n        mom._d[\"set\" + (mom._isUTC ? \
\"UTC\" : \"\") + \"Month\"](value, dayOfMonth);\n        return mom;\n      \
}\n      function getSetMonth(value) {\n        if (value != null) {\n        \
  setMonth(this, value);\n          hooks.updateOffset(this, true);\n         \
 return this;\n        } else {\n          return get(this, \"Month\");\n     \
   }\n      }\n      function getDaysInMonth() {\n        return \
daysInMonth(this.year(), this.month());\n      }\n      function \
monthsShortRegex(isStrict) {\n        if (this._monthsParseExact) {\n         \
 if (!hasOwnProp(this, \"_monthsRegex\")) {\n            \
computeMonthsParse.call(this);\n          }\n          if (isStrict) {\n      \
      return this._monthsShortStrictRegex;\n          } else {\n            \
return this._monthsShortRegex;\n          }\n        } else {\n          if \
(!hasOwnProp(this, \"_monthsShortRegex\")) {\n            \
this._monthsShortRegex = defaultMonthsShortRegex;\n          }\n          \
return this._monthsShortStrictRegex && isStrict ? \
this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n      }\n  \
    function monthsRegex(isStrict) {\n        if (this._monthsParseExact) {\n \
         if (!hasOwnProp(this, \"_monthsRegex\")) {\n            \
computeMonthsParse.call(this);\n          }\n          if (isStrict) {\n      \
      return this._monthsStrictRegex;\n          } else {\n            return \
this._monthsRegex;\n          }\n        } else {\n          if \
(!hasOwnProp(this, \"_monthsRegex\")) {\n            this._monthsRegex = \
defaultMonthsRegex;\n          }\n          return this._monthsStrictRegex && \
isStrict ? this._monthsStrictRegex : this._monthsRegex;\n        }\n      }\n \
     function computeMonthsParse() {\n        function cmpLenRev(a, b) {\n    \
      return b.length - a.length;\n        }\n        var shortPieces = [], \
longPieces = [], mixedPieces = [], i, mom;\n        for (i = 0; i < 12; i++) \
{\n          mom = createUTC([2e3, i]);\n          \
shortPieces.push(this.monthsShort(mom, \"\"));\n          \
longPieces.push(this.months(mom, \"\"));\n          \
mixedPieces.push(this.months(mom, \"\"));\n          \
mixedPieces.push(this.monthsShort(mom, \"\"));\n        }\n        \
shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        \
mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n          \
shortPieces[i] = regexEscape(shortPieces[i]);\n          longPieces[i] = \
regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n  \
        mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n        \
this._monthsRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \
\"i\");\n        this._monthsShortRegex = this._monthsRegex;\n        \
this._monthsStrictRegex = new RegExp(\n          \"^(\" + \
longPieces.join(\"|\") + \")\",\n          \"i\"\n        );\n        \
this._monthsShortStrictRegex = new RegExp(\n          \"^(\" + \
shortPieces.join(\"|\") + \")\",\n          \"i\"\n        );\n      }\n      \
addFormatToken(\"Y\", 0, 0, function() {\n        var y = this.year();\n      \
  return y <= 9999 ? zeroFill(y, 4) : \"+\" + y;\n      });\n      \
addFormatToken(0, [\"YY\", 2], 0, function() {\n        return this.year() % \
100;\n      });\n      addFormatToken(0, [\"YYYY\", 4], 0, \"year\");\n      \
addFormatToken(0, [\"YYYYY\", 5], 0, \"year\");\n      addFormatToken(0, \
[\"YYYYYY\", 6, true], 0, \"year\");\n      addUnitAlias(\"year\", \"y\");\n  \
    addUnitPriority(\"year\", 1);\n      addRegexToken(\"Y\", matchSigned);\n \
     addRegexToken(\"YY\", match1to2, match2);\n      addRegexToken(\"YYYY\", \
match1to4, match4);\n      addRegexToken(\"YYYYY\", match1to6, match6);\n     \
 addRegexToken(\"YYYYYY\", match1to6, match6);\n      \
addParseToken([\"YYYYY\", \"YYYYYY\"], YEAR);\n      addParseToken(\"YYYY\", \
function(input, array) {\n        array[YEAR] = input.length === 2 ? \
hooks.parseTwoDigitYear(input) : toInt(input);\n      });\n      \
addParseToken(\"YY\", function(input, array) {\n        array[YEAR] = \
hooks.parseTwoDigitYear(input);\n      });\n      addParseToken(\"Y\", \
function(input, array) {\n        array[YEAR] = parseInt(input, 10);\n      \
});\n      function daysInYear(year) {\n        return isLeapYear(year) ? 366 \
: 365;\n      }\n      hooks.parseTwoDigitYear = function(input) {\n        \
return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);\n      };\n      var \
getSetYear = makeGetSet(\"FullYear\", true);\n      function getIsLeapYear() \
{\n        return isLeapYear(this.year());\n      }\n      function \
createDate(y, m, d, h, M, s, ms) {\n        var date;\n        if (y < 100 && \
y >= 0) {\n          date = new Date(y + 400, m, d, h, M, s, ms);\n          \
if (isFinite(date.getFullYear())) {\n            date.setFullYear(y);\n       \
   }\n        } else {\n          date = new Date(y, m, d, h, M, s, ms);\n    \
    }\n        return date;\n      }\n      function createUTCDate(y) {\n     \
   var date, args;\n        if (y < 100 && y >= 0) {\n          args = \
Array.prototype.slice.call(arguments);\n          args[0] = y + 400;\n        \
  date = new Date(Date.UTC.apply(null, args));\n          if \
(isFinite(date.getUTCFullYear())) {\n            date.setUTCFullYear(y);\n    \
      }\n        } else {\n          date = new Date(Date.UTC.apply(null, \
arguments));\n        }\n        return date;\n      }\n      function \
firstWeekOffset(year, dow, doy) {\n        var fwd = 7 + dow - doy, fwdlw = \
(7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n        return \
-fwdlw + fwd - 1;\n      }\n      function dayOfYearFromWeeks(year, week, \
weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7, \
weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) \
+ localWeekday + weekOffset, resYear, resDayOfYear;\n        if (dayOfYear <= \
0) {\n          resYear = year - 1;\n          resDayOfYear = \
daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > \
daysInYear(year)) {\n          resYear = year + 1;\n          resDayOfYear = \
dayOfYear - daysInYear(year);\n        } else {\n          resYear = year;\n  \
        resDayOfYear = dayOfYear;\n        }\n        return {\n          \
year: resYear,\n          dayOfYear: resDayOfYear\n        };\n      }\n      \
function weekOfYear(mom, dow, doy) {\n        var weekOffset = \
firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - \
weekOffset - 1) / 7) + 1, resWeek, resYear;\n        if (week < 1) {\n        \
  resYear = mom.year() - 1;\n          resWeek = week + weeksInYear(resYear, \
dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n  \
        resWeek = week - weeksInYear(mom.year(), dow, doy);\n          \
resYear = mom.year() + 1;\n        } else {\n          resYear = \
mom.year();\n          resWeek = week;\n        }\n        return {\n         \
 week: resWeek,\n          year: resYear\n        };\n      }\n      function \
weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, \
dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        \
return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n      }\n      \
addFormatToken(\"w\", [\"ww\", 2], \"wo\", \"week\");\n      \
addFormatToken(\"W\", [\"WW\", 2], \"Wo\", \"isoWeek\");\n      \
addUnitAlias(\"week\", \"w\");\n      addUnitAlias(\"isoWeek\", \"W\");\n     \
 addUnitPriority(\"week\", 5);\n      addUnitPriority(\"isoWeek\", 5);\n      \
addRegexToken(\"w\", match1to2);\n      addRegexToken(\"ww\", match1to2, \
match2);\n      addRegexToken(\"W\", match1to2);\n      addRegexToken(\"WW\", \
match1to2, match2);\n      addWeekParseToken(\n        [\"w\", \"ww\", \"W\", \
\"WW\"],\n        function(input, week, config, token2) {\n          \
week[token2.substr(0, 1)] = toInt(input);\n        }\n      );\n      \
function localeWeek(mom) {\n        return weekOfYear(mom, this._week.dow, \
this._week.doy).week;\n      }\n      var defaultLocaleWeek = {\n        dow: \
0,\n        // Sunday is the first day of the week.\n        doy: 6\n        \
// The week that contains Jan 6th is the first week of the year.\n      };\n  \
    function localeFirstDayOfWeek() {\n        return this._week.dow;\n      \
}\n      function localeFirstDayOfYear() {\n        return this._week.doy;\n  \
    }\n      function getSetWeek(input) {\n        var week = \
this.localeData().week(this);\n        return input == null ? week : \
this.add((input - week) * 7, \"d\");\n      }\n      function \
getSetISOWeek(input) {\n        var week = weekOfYear(this, 1, 4).week;\n     \
   return input == null ? week : this.add((input - week) * 7, \"d\");\n      \
}\n      addFormatToken(\"d\", 0, \"do\", \"day\");\n      \
addFormatToken(\"dd\", 0, 0, function(format2) {\n        return \
this.localeData().weekdaysMin(this, format2);\n      });\n      \
addFormatToken(\"ddd\", 0, 0, function(format2) {\n        return \
this.localeData().weekdaysShort(this, format2);\n      });\n      \
addFormatToken(\"dddd\", 0, 0, function(format2) {\n        return \
this.localeData().weekdays(this, format2);\n      });\n      \
addFormatToken(\"e\", 0, 0, \"weekday\");\n      addFormatToken(\"E\", 0, 0, \
\"isoWeekday\");\n      addUnitAlias(\"day\", \"d\");\n      \
addUnitAlias(\"weekday\", \"e\");\n      addUnitAlias(\"isoWeekday\", \
\"E\");\n      addUnitPriority(\"day\", 11);\n      \
addUnitPriority(\"weekday\", 11);\n      addUnitPriority(\"isoWeekday\", \
11);\n      addRegexToken(\"d\", match1to2);\n      addRegexToken(\"e\", \
match1to2);\n      addRegexToken(\"E\", match1to2);\n      \
addRegexToken(\"dd\", function(isStrict, locale2) {\n        return \
locale2.weekdaysMinRegex(isStrict);\n      });\n      addRegexToken(\"ddd\", \
function(isStrict, locale2) {\n        return \
locale2.weekdaysShortRegex(isStrict);\n      });\n      \
addRegexToken(\"dddd\", function(isStrict, locale2) {\n        return \
locale2.weekdaysRegex(isStrict);\n      });\n      addWeekParseToken([\"dd\", \
\"ddd\", \"dddd\"], function(input, week, config, token2) {\n        var \
weekday = config._locale.weekdaysParse(input, token2, config._strict);\n      \
  if (weekday != null) {\n          week.d = weekday;\n        } else {\n     \
     getParsingFlags(config).invalidWeekday = input;\n        }\n      });\n  \
    addWeekParseToken([\"d\", \"e\", \"E\"], function(input, week, config, \
token2) {\n        week[token2] = toInt(input);\n      });\n      function \
parseWeekday(input, locale2) {\n        if (typeof input !== \"string\") {\n  \
        return input;\n        }\n        if (!isNaN(input)) {\n          \
return parseInt(input, 10);\n        }\n        input = \
locale2.weekdaysParse(input);\n        if (typeof input === \"number\") {\n   \
       return input;\n        }\n        return null;\n      }\n      \
function parseIsoWeekday(input, locale2) {\n        if (typeof input === \
\"string\") {\n          return locale2.weekdaysParse(input) % 7 || 7;\n      \
  }\n        return isNaN(input) ? null : input;\n      }\n      function \
shiftWeekdays(ws, n) {\n        return ws.slice(n, 7).concat(ws.slice(0, \
n));\n      }\n      var defaultLocaleWeekdays = \
\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"), \
defaultLocaleWeekdaysShort = \"Sun_Mon_Tue_Wed_Thu_Fri_Sat\".split(\"_\"), \
defaultLocaleWeekdaysMin = \"Su_Mo_Tu_We_Th_Fr_Sa\".split(\"_\"), \
defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, \
defaultWeekdaysMinRegex = matchWord;\n      function localeWeekdays(m, \
format2) {\n        var weekdays = isArray(this._weekdays) ? this._weekdays : \
this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? \
\"format\" : \"standalone\"];\n        return m === true ? \
shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;\n \
     }\n      function localeWeekdaysShort(m) {\n        return m === true ? \
shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? \
this._weekdaysShort[m.day()] : this._weekdaysShort;\n      }\n      function \
localeWeekdaysMin(m) {\n        return m === true ? \
shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? \
this._weekdaysMin[m.day()] : this._weekdaysMin;\n      }\n      function \
handleStrictParse$1(weekdayName, format2, strict) {\n        var i, ii, mom, \
llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n \
         this._weekdaysParse = [];\n          this._shortWeekdaysParse = \
[];\n          this._minWeekdaysParse = [];\n          for (i = 0; i < 7; \
++i) {\n            mom = createUTC([2e3, 1]).day(i);\n            \
this._minWeekdaysParse[i] = this.weekdaysMin(\n              mom,\n           \
   \"\"\n            ).toLocaleLowerCase();\n            \
this._shortWeekdaysParse[i] = this.weekdaysShort(\n              mom,\n       \
       \"\"\n            ).toLocaleLowerCase();\n            \
this._weekdaysParse[i] = this.weekdays(mom, \"\").toLocaleLowerCase();\n      \
    }\n        }\n        if (strict) {\n          if (format2 === \"dddd\") \
{\n            ii = indexOf.call(this._weekdaysParse, llc);\n            \
return ii !== -1 ? ii : null;\n          } else if (format2 === \"ddd\") {\n  \
          ii = indexOf.call(this._shortWeekdaysParse, llc);\n            \
return ii !== -1 ? ii : null;\n          } else {\n            ii = \
indexOf.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii \
: null;\n          }\n        } else {\n          if (format2 === \"dddd\") \
{\n            ii = indexOf.call(this._weekdaysParse, llc);\n            if \
(ii !== -1) {\n              return ii;\n            }\n            ii = \
indexOf.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n  \
            return ii;\n            }\n            ii = \
indexOf.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii \
: null;\n          } else if (format2 === \"ddd\") {\n            ii = \
indexOf.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n  \
            return ii;\n            }\n            ii = \
indexOf.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n       \
       return ii;\n            }\n            ii = \
indexOf.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii \
: null;\n          } else {\n            ii = \
indexOf.call(this._minWeekdaysParse, llc);\n            if (ii !== -1) {\n    \
          return ii;\n            }\n            ii = \
indexOf.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n       \
       return ii;\n            }\n            ii = \
indexOf.call(this._shortWeekdaysParse, llc);\n            return ii !== -1 ? \
ii : null;\n          }\n        }\n      }\n      function \
localeWeekdaysParse(weekdayName, format2, strict) {\n        var i, mom, \
regex;\n        if (this._weekdaysParseExact) {\n          return \
handleStrictParse$1.call(this, weekdayName, format2, strict);\n        }\n    \
    if (!this._weekdaysParse) {\n          this._weekdaysParse = [];\n        \
  this._minWeekdaysParse = [];\n          this._shortWeekdaysParse = [];\n    \
      this._fullWeekdaysParse = [];\n        }\n        for (i = 0; i < 7; \
i++) {\n          mom = createUTC([2e3, 1]).day(i);\n          if (strict && \
!this._fullWeekdaysParse[i]) {\n            this._fullWeekdaysParse[i] = new \
RegExp(\n              \"^\" + this.weekdays(mom, \"\").replace(\".\", \
\"\\\\.?\") + \"$\",\n              \"i\"\n            );\n            \
this._shortWeekdaysParse[i] = new RegExp(\n              \"^\" + \
this.weekdaysShort(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\",\n           \
   \"i\"\n            );\n            this._minWeekdaysParse[i] = new \
RegExp(\n              \"^\" + this.weekdaysMin(mom, \"\").replace(\".\", \
\"\\\\.?\") + \"$\",\n              \"i\"\n            );\n          }\n      \
    if (!this._weekdaysParse[i]) {\n            regex = \"^\" + \
this.weekdays(mom, \"\") + \"|^\" + this.weekdaysShort(mom, \"\") + \"|^\" + \
this.weekdaysMin(mom, \"\");\n            this._weekdaysParse[i] = new \
RegExp(regex.replace(\".\", \"\"), \"i\");\n          }\n          if (strict \
&& format2 === \"dddd\" && this._fullWeekdaysParse[i].test(weekdayName)) {\n  \
          return i;\n          } else if (strict && format2 === \"ddd\" && \
this._shortWeekdaysParse[i].test(weekdayName)) {\n            return i;\n     \
     } else if (strict && format2 === \"dd\" && \
this._minWeekdaysParse[i].test(weekdayName)) {\n            return i;\n       \
   } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n        \
    return i;\n          }\n        }\n      }\n      function \
getSetDayOfWeek(input) {\n        if (!this.isValid()) {\n          return \
input != null ? this : NaN;\n        }\n        var day = this._isUTC ? \
this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n       \
   input = parseWeekday(input, this.localeData());\n          return \
this.add(input - day, \"d\");\n        } else {\n          return day;\n      \
  }\n      }\n      function getSetLocaleDayOfWeek(input) {\n        if \
(!this.isValid()) {\n          return input != null ? this : NaN;\n        \
}\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % \
7;\n        return input == null ? weekday : this.add(input - weekday, \
\"d\");\n      }\n      function getSetISODayOfWeek(input) {\n        if \
(!this.isValid()) {\n          return input != null ? this : NaN;\n        \
}\n        if (input != null) {\n          var weekday = \
parseIsoWeekday(input, this.localeData());\n          return \
this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n         \
 return this.day() || 7;\n        }\n      }\n      function \
weekdaysRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n          \
if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n            \
computeWeekdaysParse.call(this);\n          }\n          if (isStrict) {\n    \
        return this._weekdaysStrictRegex;\n          } else {\n            \
return this._weekdaysRegex;\n          }\n        } else {\n          if \
(!hasOwnProp(this, \"_weekdaysRegex\")) {\n            this._weekdaysRegex = \
defaultWeekdaysRegex;\n          }\n          return \
this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : \
this._weekdaysRegex;\n        }\n      }\n      function \
weekdaysShortRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n     \
     if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n            \
computeWeekdaysParse.call(this);\n          }\n          if (isStrict) {\n    \
        return this._weekdaysShortStrictRegex;\n          } else {\n          \
  return this._weekdaysShortRegex;\n          }\n        } else {\n          \
if (!hasOwnProp(this, \"_weekdaysShortRegex\")) {\n            \
this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n          }\n          \
return this._weekdaysShortStrictRegex && isStrict ? \
this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n      \
}\n      function weekdaysMinRegex(isStrict) {\n        if \
(this._weekdaysParseExact) {\n          if (!hasOwnProp(this, \
\"_weekdaysRegex\")) {\n            computeWeekdaysParse.call(this);\n        \
  }\n          if (isStrict) {\n            return \
this._weekdaysMinStrictRegex;\n          } else {\n            return \
this._weekdaysMinRegex;\n          }\n        } else {\n          if \
(!hasOwnProp(this, \"_weekdaysMinRegex\")) {\n            \
this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n          }\n          \
return this._weekdaysMinStrictRegex && isStrict ? \
this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n      }\n  \
    function computeWeekdaysParse() {\n        function cmpLenRev(a, b) {\n   \
       return b.length - a.length;\n        }\n        var minPieces = [], \
shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, \
longp;\n        for (i = 0; i < 7; i++) {\n          mom = createUTC([2e3, \
1]).day(i);\n          minp = regexEscape(this.weekdaysMin(mom, \"\"));\n     \
     shortp = regexEscape(this.weekdaysShort(mom, \"\"));\n          longp = \
regexEscape(this.weekdays(mom, \"\"));\n          minPieces.push(minp);\n     \
     shortPieces.push(shortp);\n          longPieces.push(longp);\n          \
mixedPieces.push(minp);\n          mixedPieces.push(shortp);\n          \
mixedPieces.push(longp);\n        }\n        minPieces.sort(cmpLenRev);\n     \
   shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        \
mixedPieces.sort(cmpLenRev);\n        this._weekdaysRegex = new RegExp(\"^(\" \
+ mixedPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysShortRegex \
= this._weekdaysRegex;\n        this._weekdaysMinRegex = \
this._weekdaysRegex;\n        this._weekdaysStrictRegex = new RegExp(\n       \
   \"^(\" + longPieces.join(\"|\") + \")\",\n          \"i\"\n        );\n    \
    this._weekdaysShortStrictRegex = new RegExp(\n          \"^(\" + \
shortPieces.join(\"|\") + \")\",\n          \"i\"\n        );\n        \
this._weekdaysMinStrictRegex = new RegExp(\n          \"^(\" + \
minPieces.join(\"|\") + \")\",\n          \"i\"\n        );\n      }\n      \
function hFormat() {\n        return this.hours() % 12 || 12;\n      }\n      \
function kFormat() {\n        return this.hours() || 24;\n      }\n      \
addFormatToken(\"H\", [\"HH\", 2], 0, \"hour\");\n      addFormatToken(\"h\", \
[\"hh\", 2], 0, hFormat);\n      addFormatToken(\"k\", [\"kk\", 2], 0, \
kFormat);\n      addFormatToken(\"hmm\", 0, 0, function() {\n        return \
\"\" + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n      });\n      \
addFormatToken(\"hmmss\", 0, 0, function() {\n        return \"\" + \
hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), \
2);\n      });\n      addFormatToken(\"Hmm\", 0, 0, function() {\n        \
return \"\" + this.hours() + zeroFill(this.minutes(), 2);\n      });\n      \
addFormatToken(\"Hmmss\", 0, 0, function() {\n        return \"\" + \
this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n   \
   });\n      function meridiem(token2, lowercase) {\n        \
addFormatToken(token2, 0, 0, function() {\n          return \
this.localeData().meridiem(\n            this.hours(),\n            \
this.minutes(),\n            lowercase\n          );\n        });\n      }\n  \
    meridiem(\"a\", true);\n      meridiem(\"A\", false);\n      \
addUnitAlias(\"hour\", \"h\");\n      addUnitPriority(\"hour\", 13);\n      \
function matchMeridiem(isStrict, locale2) {\n        return \
locale2._meridiemParse;\n      }\n      addRegexToken(\"a\", \
matchMeridiem);\n      addRegexToken(\"A\", matchMeridiem);\n      \
addRegexToken(\"H\", match1to2);\n      addRegexToken(\"h\", match1to2);\n    \
  addRegexToken(\"k\", match1to2);\n      addRegexToken(\"HH\", match1to2, \
match2);\n      addRegexToken(\"hh\", match1to2, match2);\n      \
addRegexToken(\"kk\", match1to2, match2);\n      addRegexToken(\"hmm\", \
match3to4);\n      addRegexToken(\"hmmss\", match5to6);\n      \
addRegexToken(\"Hmm\", match3to4);\n      addRegexToken(\"Hmmss\", \
match5to6);\n      addParseToken([\"H\", \"HH\"], HOUR);\n      \
addParseToken([\"k\", \"kk\"], function(input, array, config) {\n        var \
kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n   \
   });\n      addParseToken([\"a\", \"A\"], function(input, array, config) \
{\n        config._isPm = config._locale.isPM(input);\n        \
config._meridiem = input;\n      });\n      addParseToken([\"h\", \"hh\"], \
function(input, array, config) {\n        array[HOUR] = toInt(input);\n       \
 getParsingFlags(config).bigHour = true;\n      });\n      \
addParseToken(\"hmm\", function(input, array, config) {\n        var pos = \
input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n       \
 array[MINUTE] = toInt(input.substr(pos));\n        \
getParsingFlags(config).bigHour = true;\n      });\n      \
addParseToken(\"hmmss\", function(input, array, config) {\n        var pos1 = \
input.length - 4, pos2 = input.length - 2;\n        array[HOUR] = \
toInt(input.substr(0, pos1));\n        array[MINUTE] = \
toInt(input.substr(pos1, 2));\n        array[SECOND] = \
toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n \
     });\n      addParseToken(\"Hmm\", function(input, array, config) {\n     \
   var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, \
pos));\n        array[MINUTE] = toInt(input.substr(pos));\n      });\n      \
addParseToken(\"Hmmss\", function(input, array, config) {\n        var pos1 = \
input.length - 4, pos2 = input.length - 2;\n        array[HOUR] = \
toInt(input.substr(0, pos1));\n        array[MINUTE] = \
toInt(input.substr(pos1, 2));\n        array[SECOND] = \
toInt(input.substr(pos2));\n      });\n      function localeIsPM(input) {\n   \
     return (input + \"\").toLowerCase().charAt(0) === \"p\";\n      }\n      \
var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i, getSetHour = \
makeGetSet(\"Hours\", true);\n      function localeMeridiem(hours2, minutes2, \
isLower) {\n        if (hours2 > 11) {\n          return isLower ? \"pm\" : \
\"PM\";\n        } else {\n          return isLower ? \"am\" : \"AM\";\n      \
  }\n      }\n      var baseConfig = {\n        calendar: defaultCalendar,\n  \
      longDateFormat: defaultLongDateFormat,\n        invalidDate: \
defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        \
dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: \
defaultRelativeTime,\n        months: defaultLocaleMonths,\n        \
monthsShort: defaultLocaleMonthsShort,\n        week: defaultLocaleWeek,\n    \
    weekdays: defaultLocaleWeekdays,\n        weekdaysMin: \
defaultLocaleWeekdaysMin,\n        weekdaysShort: \
defaultLocaleWeekdaysShort,\n        meridiemParse: \
defaultLocaleMeridiemParse\n      };\n      var locales = {}, localeFamilies \
= {}, globalLocale;\n      function commonPrefix(arr1, arr2) {\n        var \
i, minl = Math.min(arr1.length, arr2.length);\n        for (i = 0; i < minl; \
i += 1) {\n          if (arr1[i] !== arr2[i]) {\n            return i;\n      \
    }\n        }\n        return minl;\n      }\n      function \
normalizeLocale(key) {\n        return key ? key.toLowerCase().replace(\"_\", \
\"-\") : key;\n      }\n      function chooseLocale(names) {\n        var i = \
0, j, next, locale2, split;\n        while (i < names.length) {\n          \
split = normalizeLocale(names[i]).split(\"-\");\n          j = \
split.length;\n          next = normalizeLocale(names[i + 1]);\n          \
next = next ? next.split(\"-\") : null;\n          while (j > 0) {\n          \
  locale2 = loadLocale(split.slice(0, j).join(\"-\"));\n            if \
(locale2) {\n              return locale2;\n            }\n            if \
(next && next.length >= j && commonPrefix(split, next) >= j - 1) {\n          \
    break;\n            }\n            j--;\n          }\n          i++;\n    \
    }\n        return globalLocale;\n      }\n      function \
isLocaleNameSane(name) {\n        return name.match(\"^[^/\\\\\\\\]*$\") != \
null;\n      }\n      function loadLocale(name) {\n        var oldLocale = \
null, aliasedRequire;\n        if (locales[name] === void 0 && typeof module2 \
!== \"undefined\" && module2 && module2.exports && isLocaleNameSane(name)) \
{\n          try {\n            oldLocale = globalLocale._abbr;\n            \
aliasedRequire = require;\n            aliasedRequire(\"./locale/\" + \
name);\n            getSetGlobalLocale(oldLocale);\n          } catch (e) {\n \
           locales[name] = null;\n          }\n        }\n        return \
locales[name];\n      }\n      function getSetGlobalLocale(key, values) {\n   \
     var data2;\n        if (key) {\n          if (isUndefined2(values)) {\n  \
          data2 = getLocale(key);\n          } else {\n            data2 = \
defineLocale(key, values);\n          }\n          if (data2) {\n            \
globalLocale = data2;\n          } else {\n            if (typeof console !== \
\"undefined\" && console.warn) {\n              console.warn(\n               \
 \"Locale \" + key + \" not found. Did you forget to load it?\"\n             \
 );\n            }\n          }\n        }\n        return \
globalLocale._abbr;\n      }\n      function defineLocale(name, config) {\n   \
     if (config !== null) {\n          var locale2, parentConfig = \
baseConfig;\n          config.abbr = name;\n          if (locales[name] != \
null) {\n            deprecateSimple(\n              \
\"defineLocaleOverride\",\n              \"use \
moment.updateLocale(localeName, config) to change an existing locale. \
moment.defineLocale(localeName, config) should only be used for creating a \
new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more \
info.\"\n            );\n            parentConfig = locales[name]._config;\n  \
        } else if (config.parentLocale != null) {\n            if \
(locales[config.parentLocale] != null) {\n              parentConfig = \
locales[config.parentLocale]._config;\n            } else {\n              \
locale2 = loadLocale(config.parentLocale);\n              if (locale2 != \
null) {\n                parentConfig = locale2._config;\n              } \
else {\n                if (!localeFamilies[config.parentLocale]) {\n         \
         localeFamilies[config.parentLocale] = [];\n                }\n       \
         localeFamilies[config.parentLocale].push({\n                  \
name,\n                  config\n                });\n                return \
null;\n              }\n            }\n          }\n          locales[name] = \
new Locale(mergeConfigs(parentConfig, config));\n          if \
(localeFamilies[name]) {\n            \
localeFamilies[name].forEach(function(x) {\n              \
defineLocale(x.name, x.config);\n            });\n          }\n          \
getSetGlobalLocale(name);\n          return locales[name];\n        } else \
{\n          delete locales[name];\n          return null;\n        }\n      \
}\n      function updateLocale(name, config) {\n        if (config != null) \
{\n          var locale2, tmpLocale, parentConfig = baseConfig;\n          if \
(locales[name] != null && locales[name].parentLocale != null) {\n            \
locales[name].set(mergeConfigs(locales[name]._config, config));\n          } \
else {\n            tmpLocale = loadLocale(name);\n            if (tmpLocale \
!= null) {\n              parentConfig = tmpLocale._config;\n            }\n  \
          config = mergeConfigs(parentConfig, config);\n            if \
(tmpLocale == null) {\n              config.abbr = name;\n            }\n     \
       locale2 = new Locale(config);\n            locale2.parentLocale = \
locales[name];\n            locales[name] = locale2;\n          }\n          \
getSetGlobalLocale(name);\n        } else {\n          if (locales[name] != \
null) {\n            if (locales[name].parentLocale != null) {\n              \
locales[name] = locales[name].parentLocale;\n              if (name === \
getSetGlobalLocale()) {\n                getSetGlobalLocale(name);\n          \
    }\n            } else if (locales[name] != null) {\n              delete \
locales[name];\n            }\n          }\n        }\n        return \
locales[name];\n      }\n      function getLocale(key) {\n        var \
locale2;\n        if (key && key._locale && key._locale._abbr) {\n          \
key = key._locale._abbr;\n        }\n        if (!key) {\n          return \
globalLocale;\n        }\n        if (!isArray(key)) {\n          locale2 = \
loadLocale(key);\n          if (locale2) {\n            return locale2;\n     \
     }\n          key = [key];\n        }\n        return \
chooseLocale(key);\n      }\n      function listLocales() {\n        return \
keys(locales);\n      }\n      function checkOverflow(m) {\n        var \
overflow, a = m._a;\n        if (a && getParsingFlags(m).overflow === -2) {\n \
         overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || \
a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 \
|| a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] \
!== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || \
a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? \
MILLISECOND : -1;\n          if (getParsingFlags(m)._overflowDayOfYear && \
(overflow < YEAR || overflow > DATE)) {\n            overflow = DATE;\n       \
   }\n          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n \
           overflow = WEEK;\n          }\n          if \
(getParsingFlags(m)._overflowWeekday && overflow === -1) {\n            \
overflow = WEEKDAY;\n          }\n          getParsingFlags(m).overflow = \
overflow;\n        }\n        return m;\n      }\n      var extendedIsoRegex \
= \
/^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\
\\d\\d))(?:(T| \
)(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)\
?)?$/, basicIsoRegex = \
/^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\
\\d|))(?:(T| \
)(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)\
?$/, tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/, isoDates = [\n        \
[\"YYYYYY-MM-DD\", /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        [\"YYYY-MM-DD\", \
/\\d{4}-\\d\\d-\\d\\d/],\n        [\"GGGG-[W]WW-E\", /\\d{4}-W\\d\\d-\\d/],\n \
       [\"GGGG-[W]WW\", /\\d{4}-W\\d\\d/, false],\n        [\"YYYY-DDD\", \
/\\d{4}-\\d{3}/],\n        [\"YYYY-MM\", /\\d{4}-\\d\\d/, false],\n        \
[\"YYYYYYMMDD\", /[+-]\\d{10}/],\n        [\"YYYYMMDD\", /\\d{8}/],\n        \
[\"GGGG[W]WWE\", /\\d{4}W\\d{3}/],\n        [\"GGGG[W]WW\", /\\d{4}W\\d{2}/, \
false],\n        [\"YYYYDDD\", /\\d{7}/],\n        [\"YYYYMM\", /\\d{6}/, \
false],\n        [\"YYYY\", /\\d{4}/, false]\n      ], isoTimes = [\n        \
[\"HH:mm:ss.SSSS\", /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        \
[\"HH:mm:ss,SSSS\", /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n        [\"HH:mm:ss\", \
/\\d\\d:\\d\\d:\\d\\d/],\n        [\"HH:mm\", /\\d\\d:\\d\\d/],\n        \
[\"HHmmss.SSSS\", /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        [\"HHmmss,SSSS\", \
/\\d\\d\\d\\d\\d\\d,\\d+/],\n        [\"HHmmss\", /\\d\\d\\d\\d\\d\\d/],\n    \
    [\"HHmm\", /\\d\\d\\d\\d/],\n        [\"HH\", /\\d\\d/]\n      ], \
aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i, rfc2822 = \
/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Ju\
n|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(\
?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/, obsOffsets = {\n        UT: \
0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        \
CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 \
* 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n      };\n      function \
configFromISO(config) {\n        var i, l, string = config._i, match = \
extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, \
dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen \
= isoTimes.length;\n        if (match) {\n          \
getParsingFlags(config).iso = true;\n          for (i = 0, l = isoDatesLen; i \
< l; i++) {\n            if (isoDates[i][1].exec(match[1])) {\n              \
dateFormat = isoDates[i][0];\n              allowTime = isoDates[i][2] !== \
false;\n              break;\n            }\n          }\n          if \
(dateFormat == null) {\n            config._isValid = false;\n            \
return;\n          }\n          if (match[3]) {\n            for (i = 0, l = \
isoTimesLen; i < l; i++) {\n              if (isoTimes[i][1].exec(match[3])) \
{\n                timeFormat = (match[2] || \" \") + isoTimes[i][0];\n       \
         break;\n              }\n            }\n            if (timeFormat \
== null) {\n              config._isValid = false;\n              return;\n   \
         }\n          }\n          if (!allowTime && timeFormat != null) {\n  \
          config._isValid = false;\n            return;\n          }\n        \
  if (match[4]) {\n            if (tzRegex.exec(match[4])) {\n              \
tzFormat = \"Z\";\n            } else {\n              config._isValid = \
false;\n              return;\n            }\n          }\n          \
config._f = dateFormat + (timeFormat || \"\") + (tzFormat || \"\");\n         \
 configFromStringAndFormat(config);\n        } else {\n          \
config._isValid = false;\n        }\n      }\n      function \
extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, \
secondStr) {\n        var result = [\n          untruncateYear(yearStr),\n    \
      defaultLocaleMonthsShort.indexOf(monthStr),\n          parseInt(dayStr, \
10),\n          parseInt(hourStr, 10),\n          parseInt(minuteStr, 10)\n   \
     ];\n        if (secondStr) {\n          result.push(parseInt(secondStr, \
10));\n        }\n        return result;\n      }\n      function \
untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        \
if (year <= 49) {\n          return 2e3 + year;\n        } else if (year <= \
999) {\n          return 1900 + year;\n        }\n        return year;\n      \
}\n      function preprocessRFC2822(s) {\n        return \
s.replace(/\\([^()]*\\)|[\\n\\t]/g, \" \").replace(/(\\s\\s+)/g, \" \
\").replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\");\n      }\n      \
function checkWeekday(weekdayStr, parsedInput, config) {\n        if \
(weekdayStr) {\n          var weekdayProvided = \
defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(\n   \
         parsedInput[0],\n            parsedInput[1],\n            \
parsedInput[2]\n          ).getDay();\n          if (weekdayProvided !== \
weekdayActual) {\n            getParsingFlags(config).weekdayMismatch = \
true;\n            config._isValid = false;\n            return false;\n      \
    }\n        }\n        return true;\n      }\n      function \
calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if \
(obsOffset) {\n          return obsOffsets[obsOffset];\n        } else if \
(militaryOffset) {\n          return 0;\n        } else {\n          var hm = \
parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;\n          return \
h * 60 + m;\n        }\n      }\n      function configFromRFC2822(config) {\n \
       var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;\n \
       if (match) {\n          parsedArray = extractFromRFC2822Strings(\n     \
       match[4],\n            match[3],\n            match[2],\n            \
match[5],\n            match[6],\n            match[7]\n          );\n        \
  if (!checkWeekday(match[1], parsedArray, config)) {\n            return;\n  \
        }\n          config._a = parsedArray;\n          config._tzm = \
calculateOffset(match[8], match[9], match[10]);\n          config._d = \
createUTCDate.apply(null, config._a);\n          \
config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n          \
getParsingFlags(config).rfc2822 = true;\n        } else {\n          \
config._isValid = false;\n        }\n      }\n      function \
configFromString(config) {\n        var matched = \
aspNetJsonRegex.exec(config._i);\n        if (matched !== null) {\n          \
config._d = /* @__PURE__ */ new Date(+matched[1]);\n          return;\n       \
 }\n        configFromISO(config);\n        if (config._isValid === false) \
{\n          delete config._isValid;\n        } else {\n          return;\n   \
     }\n        configFromRFC2822(config);\n        if (config._isValid === \
false) {\n          delete config._isValid;\n        } else {\n          \
return;\n        }\n        if (config._strict) {\n          config._isValid \
= false;\n        } else {\n          \
hooks.createFromInputFallback(config);\n        }\n      }\n      \
hooks.createFromInputFallback = deprecate(\n        \"value provided is not \
in a recognized RFC2822 or ISO format. moment construction falls back to js \
Date(), which is not reliable across all browsers and versions. Non \
RFC2822/ISO date formats are discouraged. Please refer to \
http://momentjs.com/guides/#/warnings/js-date/ for more info.\",\n        \
function(config) {\n          config._d = /* @__PURE__ */ new Date(config._i \
+ (config._useUTC ? \" UTC\" : \"\"));\n        }\n      );\n      function \
defaults(a, b, c) {\n        if (a != null) {\n          return a;\n        \
}\n        if (b != null) {\n          return b;\n        }\n        return \
c;\n      }\n      function currentDateArray(config) {\n        var nowValue \
= new Date(hooks.now());\n        if (config._useUTC) {\n          return [\n \
           nowValue.getUTCFullYear(),\n            nowValue.getUTCMonth(),\n  \
          nowValue.getUTCDate()\n          ];\n        }\n        return \
[nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n      }\n \
     function configFromArray(config) {\n        var i, date, input = [], \
currentDate, expectedWeekday, yearToUse;\n        if (config._d) {\n          \
return;\n        }\n        currentDate = currentDateArray(config);\n        \
if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n     \
     dayOfYearFromWeekInfo(config);\n        }\n        if (config._dayOfYear \
!= null) {\n          yearToUse = defaults(config._a[YEAR], \
currentDate[YEAR]);\n          if (config._dayOfYear > daysInYear(yearToUse) \
|| config._dayOfYear === 0) {\n            \
getParsingFlags(config)._overflowDayOfYear = true;\n          }\n          \
date = createUTCDate(yearToUse, 0, config._dayOfYear);\n          \
config._a[MONTH] = date.getUTCMonth();\n          config._a[DATE] = \
date.getUTCDate();\n        }\n        for (i = 0; i < 3 && config._a[i] == \
null; ++i) {\n          config._a[i] = input[i] = currentDate[i];\n        \
}\n        for (; i < 7; i++) {\n          config._a[i] = input[i] = \
config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];\n        }\n        if \
(config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 \
&& config._a[MILLISECOND] === 0) {\n          config._nextDay = true;\n       \
   config._a[HOUR] = 0;\n        }\n        config._d = (config._useUTC ? \
createUTCDate : createDate).apply(\n          null,\n          input\n        \
);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : \
config._d.getDay();\n        if (config._tzm != null) {\n          \
config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        \
}\n        if (config._nextDay) {\n          config._a[HOUR] = 24;\n        \
}\n        if (config._w && typeof config._w.d !== \"undefined\" && \
config._w.d !== expectedWeekday) {\n          \
getParsingFlags(config).weekdayMismatch = true;\n        }\n      }\n      \
function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, \
weekday, dow, doy, temp, weekdayOverflow, curWeek;\n        w = config._w;\n  \
      if (w.GG != null || w.W != null || w.E != null) {\n          dow = 1;\n \
         doy = 4;\n          weekYear = defaults(\n            w.GG,\n        \
    config._a[YEAR],\n            weekOfYear(createLocal(), 1, 4).year\n      \
    );\n          week = defaults(w.W, 1);\n          weekday = defaults(w.E, \
1);\n          if (weekday < 1 || weekday > 7) {\n            weekdayOverflow \
= true;\n          }\n        } else {\n          dow = \
config._locale._week.dow;\n          doy = config._locale._week.doy;\n        \
  curWeek = weekOfYear(createLocal(), dow, doy);\n          weekYear = \
defaults(w.gg, config._a[YEAR], curWeek.year);\n          week = \
defaults(w.w, curWeek.week);\n          if (w.d != null) {\n            \
weekday = w.d;\n            if (weekday < 0 || weekday > 6) {\n              \
weekdayOverflow = true;\n            }\n          } else if (w.e != null) {\n \
           weekday = w.e + dow;\n            if (w.e < 0 || w.e > 6) {\n      \
        weekdayOverflow = true;\n            }\n          } else {\n          \
  weekday = dow;\n          }\n        }\n        if (week < 1 || week > \
weeksInYear(weekYear, dow, doy)) {\n          \
getParsingFlags(config)._overflowWeeks = true;\n        } else if \
(weekdayOverflow != null) {\n          \
getParsingFlags(config)._overflowWeekday = true;\n        } else {\n          \
temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n          \
config._a[YEAR] = temp.year;\n          config._dayOfYear = temp.dayOfYear;\n \
       }\n      }\n      hooks.ISO_8601 = function() {\n      };\n      \
hooks.RFC_2822 = function() {\n      };\n      function \
configFromStringAndFormat(config) {\n        if (config._f === \
hooks.ISO_8601) {\n          configFromISO(config);\n          return;\n      \
  }\n        if (config._f === hooks.RFC_2822) {\n          \
configFromRFC2822(config);\n          return;\n        }\n        config._a = \
[];\n        getParsingFlags(config).empty = true;\n        var string = \"\" \
+ config._i, i, parsedInput, tokens2, token2, skipped, stringLength = \
string.length, totalParsedInputLength = 0, era, tokenLen;\n        tokens2 = \
expandFormat(config._f, config._locale).match(formattingTokens) || [];\n      \
  tokenLen = tokens2.length;\n        for (i = 0; i < tokenLen; i++) {\n      \
    token2 = tokens2[i];\n          parsedInput = \
(string.match(getParseRegexForToken(token2, config)) || [])[0];\n          if \
(parsedInput) {\n            skipped = string.substr(0, \
string.indexOf(parsedInput));\n            if (skipped.length > 0) {\n        \
      getParsingFlags(config).unusedInput.push(skipped);\n            }\n     \
       string = string.slice(\n              string.indexOf(parsedInput) + \
parsedInput.length\n            );\n            totalParsedInputLength += \
parsedInput.length;\n          }\n          if (formatTokenFunctions[token2]) \
{\n            if (parsedInput) {\n              \
getParsingFlags(config).empty = false;\n            } else {\n              \
getParsingFlags(config).unusedTokens.push(token2);\n            }\n           \
 addTimeToArrayFromToken(token2, parsedInput, config);\n          } else if \
(config._strict && !parsedInput) {\n            \
getParsingFlags(config).unusedTokens.push(token2);\n          }\n        }\n  \
      getParsingFlags(config).charsLeftOver = stringLength - \
totalParsedInputLength;\n        if (string.length > 0) {\n          \
getParsingFlags(config).unusedInput.push(string);\n        }\n        if \
(config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && \
config._a[HOUR] > 0) {\n          getParsingFlags(config).bigHour = void 0;\n \
       }\n        getParsingFlags(config).parsedDateParts = \
config._a.slice(0);\n        getParsingFlags(config).meridiem = \
config._meridiem;\n        config._a[HOUR] = meridiemFixWrap(\n          \
config._locale,\n          config._a[HOUR],\n          config._meridiem\n     \
   );\n        era = getParsingFlags(config).era;\n        if (era !== null) \
{\n          config._a[YEAR] = config._locale.erasConvertYear(era, \
config._a[YEAR]);\n        }\n        configFromArray(config);\n        \
checkOverflow(config);\n      }\n      function meridiemFixWrap(locale2, \
hour, meridiem2) {\n        var isPm;\n        if (meridiem2 == null) {\n     \
     return hour;\n        }\n        if (locale2.meridiemHour != null) {\n   \
       return locale2.meridiemHour(hour, meridiem2);\n        } else if \
(locale2.isPM != null) {\n          isPm = locale2.isPM(meridiem2);\n         \
 if (isPm && hour < 12) {\n            hour += 12;\n          }\n          if \
(!isPm && hour === 12) {\n            hour = 0;\n          }\n          \
return hour;\n        } else {\n          return hour;\n        }\n      }\n  \
    function configFromStringAndArray(config) {\n        var tempConfig, \
bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid \
= false, configfLen = config._f.length;\n        if (configfLen === 0) {\n    \
      getParsingFlags(config).invalidFormat = true;\n          config._d = /* \
@__PURE__ */ new Date(NaN);\n          return;\n        }\n        for (i = \
0; i < configfLen; i++) {\n          currentScore = 0;\n          \
validFormatFound = false;\n          tempConfig = copyConfig({}, config);\n   \
       if (config._useUTC != null) {\n            tempConfig._useUTC = \
config._useUTC;\n          }\n          tempConfig._f = config._f[i];\n       \
   configFromStringAndFormat(tempConfig);\n          if (isValid(tempConfig)) \
{\n            validFormatFound = true;\n          }\n          currentScore \
+= getParsingFlags(tempConfig).charsLeftOver;\n          currentScore += \
getParsingFlags(tempConfig).unusedTokens.length * 10;\n          \
getParsingFlags(tempConfig).score = currentScore;\n          if \
(!bestFormatIsValid) {\n            if (scoreToBeat == null || currentScore < \
scoreToBeat || validFormatFound) {\n              scoreToBeat = \
currentScore;\n              bestMoment = tempConfig;\n              if \
(validFormatFound) {\n                bestFormatIsValid = true;\n             \
 }\n            }\n          } else {\n            if (currentScore < \
scoreToBeat) {\n              scoreToBeat = currentScore;\n              \
bestMoment = tempConfig;\n            }\n          }\n        }\n        \
extend2(config, bestMoment || tempConfig);\n      }\n      function \
configFromObject(config) {\n        if (config._d) {\n          return;\n     \
   }\n        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === \
void 0 ? i.date : i.day;\n        config._a = map(\n          [i.year, \
i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],\n          \
function(obj) {\n            return obj && parseInt(obj, 10);\n          }\n  \
      );\n        configFromArray(config);\n      }\n      function \
createFromConfig(config) {\n        var res = new \
Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n  \
        res.add(1, \"d\");\n          res._nextDay = void 0;\n        }\n     \
   return res;\n      }\n      function prepareConfig(config) {\n        var \
input = config._i, format2 = config._f;\n        config._locale = \
config._locale || getLocale(config._l);\n        if (input === null || \
format2 === void 0 && input === \"\") {\n          return createInvalid({ \
nullInput: true });\n        }\n        if (typeof input === \"string\") {\n  \
        config._i = input = config._locale.preparse(input);\n        }\n      \
  if (isMoment(input)) {\n          return new \
Moment(checkOverflow(input));\n        } else if (isDate2(input)) {\n         \
 config._d = input;\n        } else if (isArray(format2)) {\n          \
configFromStringAndArray(config);\n        } else if (format2) {\n          \
configFromStringAndFormat(config);\n        } else {\n          \
configFromInput(config);\n        }\n        if (!isValid(config)) {\n        \
  config._d = null;\n        }\n        return config;\n      }\n      \
function configFromInput(config) {\n        var input = config._i;\n        \
if (isUndefined2(input)) {\n          config._d = new Date(hooks.now());\n    \
    } else if (isDate2(input)) {\n          config._d = new \
Date(input.valueOf());\n        } else if (typeof input === \"string\") {\n   \
       configFromString(config);\n        } else if (isArray(input)) {\n      \
    config._a = map(input.slice(0), function(obj) {\n            return \
parseInt(obj, 10);\n          });\n          configFromArray(config);\n       \
 } else if (isObject2(input)) {\n          configFromObject(config);\n        \
} else if (isNumber(input)) {\n          config._d = new Date(input);\n       \
 } else {\n          hooks.createFromInputFallback(config);\n        }\n      \
}\n      function createLocalOrUTC(input, format2, locale2, strict, isUTC) \
{\n        var c = {};\n        if (format2 === true || format2 === false) \
{\n          strict = format2;\n          format2 = void 0;\n        }\n      \
  if (locale2 === true || locale2 === false) {\n          strict = locale2;\n \
         locale2 = void 0;\n        }\n        if (isObject2(input) && \
isObjectEmpty(input) || isArray(input) && input.length === 0) {\n          \
input = void 0;\n        }\n        c._isAMomentObject = true;\n        \
c._useUTC = c._isUTC = isUTC;\n        c._l = locale2;\n        c._i = \
input;\n        c._f = format2;\n        c._strict = strict;\n        return \
createFromConfig(c);\n      }\n      function createLocal(input, format2, \
locale2, strict) {\n        return createLocalOrUTC(input, format2, locale2, \
strict, false);\n      }\n      var prototypeMin = deprecate(\n        \
\"moment().min is deprecated, use moment.max instead. \
http://momentjs.com/guides/#/warnings/min-max/\",\n        function() {\n     \
     var other = createLocal.apply(null, arguments);\n          if \
(this.isValid() && other.isValid()) {\n            return other < this ? this \
: other;\n          } else {\n            return createInvalid();\n          \
}\n        }\n      ), prototypeMax = deprecate(\n        \"moment().max is \
deprecated, use moment.min instead. \
http://momentjs.com/guides/#/warnings/min-max/\",\n        function() {\n     \
     var other = createLocal.apply(null, arguments);\n          if \
(this.isValid() && other.isValid()) {\n            return other > this ? this \
: other;\n          } else {\n            return createInvalid();\n          \
}\n        }\n      );\n      function pickBy(fn, moments) {\n        var \
res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n         \
 moments = moments[0];\n        }\n        if (!moments.length) {\n          \
return createLocal();\n        }\n        res = moments[0];\n        for (i = \
1; i < moments.length; ++i) {\n          if (!moments[i].isValid() || \
moments[i][fn](res)) {\n            res = moments[i];\n          }\n        \
}\n        return res;\n      }\n      function min() {\n        var args = \
[].slice.call(arguments, 0);\n        return pickBy(\"isBefore\", args);\n    \
  }\n      function max() {\n        var args = [].slice.call(arguments, \
0);\n        return pickBy(\"isAfter\", args);\n      }\n      var now = \
function() {\n        return Date.now ? Date.now() : +/* @__PURE__ */ new \
Date();\n      };\n      var ordering = [\n        \"year\",\n        \
\"quarter\",\n        \"month\",\n        \"week\",\n        \"day\",\n       \
 \"hour\",\n        \"minute\",\n        \"second\",\n        \
\"millisecond\"\n      ];\n      function isDurationValid(m) {\n        var \
key, unitHasDecimal = false, i, orderLen = ordering.length;\n        for (key \
in m) {\n          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) \
!== -1 && (m[key] == null || !isNaN(m[key])))) {\n            return false;\n \
         }\n        }\n        for (i = 0; i < orderLen; ++i) {\n          if \
(m[ordering[i]]) {\n            if (unitHasDecimal) {\n              return \
false;\n            }\n            if (parseFloat(m[ordering[i]]) !== \
toInt(m[ordering[i]])) {\n              unitHasDecimal = true;\n            \
}\n          }\n        }\n        return true;\n      }\n      function \
isValid$1() {\n        return this._isValid;\n      }\n      function \
createInvalid$1() {\n        return createDuration(NaN);\n      }\n      \
function Duration(duration) {\n        var normalizedInput = \
normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters \
= normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 \
= normalizedInput.week || normalizedInput.isoWeek || 0, days2 = \
normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = \
normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, \
milliseconds2 = normalizedInput.millisecond || 0;\n        this._isValid = \
isDurationValid(normalizedInput);\n        this._milliseconds = \
+milliseconds2 + seconds2 * 1e3 + // 1000\n        minutes2 * 6e4 + // 1000 * \
60\n        hours2 * 1e3 * 60 * 60;\n        this._days = +days2 + weeks2 * \
7;\n        this._months = +months2 + quarters * 3 + years2 * 12;\n        \
this._data = {};\n        this._locale = getLocale();\n        \
this._bubble();\n      }\n      function isDuration(obj) {\n        return \
obj instanceof Duration;\n      }\n      function absRound(number) {\n        \
if (number < 0) {\n          return Math.round(-1 * number) * -1;\n        } \
else {\n          return Math.round(number);\n        }\n      }\n      \
function compareArrays(array1, array2, dontConvert) {\n        var len = \
Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - \
array2.length), diffs = 0, i;\n        for (i = 0; i < len; i++) {\n          \
if (dontConvert && array1[i] !== array2[i] || !dontConvert && \
toInt(array1[i]) !== toInt(array2[i])) {\n            diffs++;\n          }\n \
       }\n        return diffs + lengthDiff;\n      }\n      function \
offset3(token2, separator) {\n        addFormatToken(token2, 0, 0, function() \
{\n          var offset4 = this.utcOffset(), sign2 = \"+\";\n          if \
(offset4 < 0) {\n            offset4 = -offset4;\n            sign2 = \
\"-\";\n          }\n          return sign2 + zeroFill(~~(offset4 / 60), 2) + \
separator + zeroFill(~~offset4 % 60, 2);\n        });\n      }\n      \
offset3(\"Z\", \":\");\n      offset3(\"ZZ\", \"\");\n      \
addRegexToken(\"Z\", matchShortOffset);\n      addRegexToken(\"ZZ\", \
matchShortOffset);\n      addParseToken([\"Z\", \"ZZ\"], function(input, \
array, config) {\n        config._useUTC = true;\n        config._tzm = \
offsetFromString(matchShortOffset, input);\n      });\n      var chunkOffset \
= /([\\+\\-]|\\d\\d)/gi;\n      function offsetFromString(matcher, string) \
{\n        var matches = (string || \"\").match(matcher), chunk, parts, \
minutes2;\n        if (matches === null) {\n          return null;\n        \
}\n        chunk = matches[matches.length - 1] || [];\n        parts = (chunk \
+ \"\").match(chunkOffset) || [\"-\", 0, 0];\n        minutes2 = +(parts[1] * \
60) + toInt(parts[2]);\n        return minutes2 === 0 ? 0 : parts[0] === \
\"+\" ? minutes2 : -minutes2;\n      }\n      function cloneWithOffset(input, \
model) {\n        var res, diff2;\n        if (model._isUTC) {\n          res \
= model.clone();\n          diff2 = (isMoment(input) || isDate2(input) ? \
input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n          \
res._d.setTime(res._d.valueOf() + diff2);\n          hooks.updateOffset(res, \
false);\n          return res;\n        } else {\n          return \
createLocal(input).local();\n        }\n      }\n      function \
getDateOffset(m) {\n        return -Math.round(m._d.getTimezoneOffset());\n   \
   }\n      hooks.updateOffset = function() {\n      };\n      function \
getSetOffset(input, keepLocalTime, keepMinutes) {\n        var offset4 = \
this._offset || 0, localAdjust;\n        if (!this.isValid()) {\n          \
return input != null ? this : NaN;\n        }\n        if (input != null) {\n \
         if (typeof input === \"string\") {\n            input = \
offsetFromString(matchShortOffset, input);\n            if (input === null) \
{\n              return this;\n            }\n          } else if \
(Math.abs(input) < 16 && !keepMinutes) {\n            input = input * 60;\n   \
       }\n          if (!this._isUTC && keepLocalTime) {\n            \
localAdjust = getDateOffset(this);\n          }\n          this._offset = \
input;\n          this._isUTC = true;\n          if (localAdjust != null) {\n \
           this.add(localAdjust, \"m\");\n          }\n          if (offset4 \
!== input) {\n            if (!keepLocalTime || this._changeInProgress) {\n   \
           addSubtract(\n                this,\n                \
createDuration(input - offset4, \"m\"),\n                1,\n                \
false\n              );\n            } else if (!this._changeInProgress) {\n  \
            this._changeInProgress = true;\n              \
hooks.updateOffset(this, true);\n              this._changeInProgress = \
null;\n            }\n          }\n          return this;\n        } else {\n \
         return this._isUTC ? offset4 : getDateOffset(this);\n        }\n     \
 }\n      function getSetZone(input, keepLocalTime) {\n        if (input != \
null) {\n          if (typeof input !== \"string\") {\n            input = \
-input;\n          }\n          this.utcOffset(input, keepLocalTime);\n       \
   return this;\n        } else {\n          return -this.utcOffset();\n      \
  }\n      }\n      function setOffsetToUTC(keepLocalTime) {\n        return \
this.utcOffset(0, keepLocalTime);\n      }\n      function \
setOffsetToLocal(keepLocalTime) {\n        if (this._isUTC) {\n          \
this.utcOffset(0, keepLocalTime);\n          this._isUTC = false;\n          \
if (keepLocalTime) {\n            this.subtract(getDateOffset(this), \
\"m\");\n          }\n        }\n        return this;\n      }\n      \
function setOffsetToParsedOffset() {\n        if (this._tzm != null) {\n      \
    this.utcOffset(this._tzm, false, true);\n        } else if (typeof \
this._i === \"string\") {\n          var tZone = \
offsetFromString(matchOffset, this._i);\n          if (tZone != null) {\n     \
       this.utcOffset(tZone);\n          } else {\n            \
this.utcOffset(0, true);\n          }\n        }\n        return this;\n      \
}\n      function hasAlignedHourOffset(input) {\n        if (!this.isValid()) \
{\n          return false;\n        }\n        input = input ? \
createLocal(input).utcOffset() : 0;\n        return (this.utcOffset() - \
input) % 60 === 0;\n      }\n      function isDaylightSavingTime() {\n        \
return this.utcOffset() > this.clone().month(0).utcOffset() || \
this.utcOffset() > this.clone().month(5).utcOffset();\n      }\n      \
function isDaylightSavingTimeShifted() {\n        if \
(!isUndefined2(this._isDSTShifted)) {\n          return this._isDSTShifted;\n \
       }\n        var c = {}, other;\n        copyConfig(c, this);\n        c \
= prepareConfig(c);\n        if (c._a) {\n          other = c._isUTC ? \
createUTC(c._a) : createLocal(c._a);\n          this._isDSTShifted = \
this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n        } else \
{\n          this._isDSTShifted = false;\n        }\n        return \
this._isDSTShifted;\n      }\n      function isLocal() {\n        return \
this.isValid() ? !this._isUTC : false;\n      }\n      function isUtcOffset() \
{\n        return this.isValid() ? this._isUTC : false;\n      }\n      \
function isUtc() {\n        return this.isValid() ? this._isUTC && \
this._offset === 0 : false;\n      }\n      var aspNetRegex = \
/^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/, isoRegex = \
/^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:\
([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9\
,.]*)S)?)?$/;\n      function createDuration(input, key) {\n        var \
duration = input, match = null, sign2, ret, diffRes;\n        if \
(isDuration(input)) {\n          duration = {\n            ms: \
input._milliseconds,\n            d: input._days,\n            M: \
input._months\n          };\n        } else if (isNumber(input) || \
!isNaN(+input)) {\n          duration = {};\n          if (key) {\n           \
 duration[key] = +input;\n          } else {\n            \
duration.milliseconds = +input;\n          }\n        } else if (match = \
aspNetRegex.exec(input)) {\n          sign2 = match[1] === \"-\" ? -1 : 1;\n  \
        duration = {\n            y: 0,\n            d: toInt(match[DATE]) * \
sign2,\n            h: toInt(match[HOUR]) * sign2,\n            m: \
toInt(match[MINUTE]) * sign2,\n            s: toInt(match[SECOND]) * sign2,\n \
           ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2\n            \
// the millisecond decimal point is included in the match\n          };\n     \
   } else if (match = isoRegex.exec(input)) {\n          sign2 = match[1] === \
\"-\" ? -1 : 1;\n          duration = {\n            y: parseIso(match[2], \
sign2),\n            M: parseIso(match[3], sign2),\n            w: \
parseIso(match[4], sign2),\n            d: parseIso(match[5], sign2),\n       \
     h: parseIso(match[6], sign2),\n            m: parseIso(match[7], \
sign2),\n            s: parseIso(match[8], sign2)\n          };\n        } \
else if (duration == null) {\n          duration = {};\n        } else if \
(typeof duration === \"object\" && (\"from\" in duration || \"to\" in \
duration)) {\n          diffRes = momentsDifference(\n            \
createLocal(duration.from),\n            createLocal(duration.to)\n          \
);\n          duration = {};\n          duration.ms = diffRes.milliseconds;\n \
         duration.M = diffRes.months;\n        }\n        ret = new \
Duration(duration);\n        if (isDuration(input) && hasOwnProp(input, \
\"_locale\")) {\n          ret._locale = input._locale;\n        }\n        \
if (isDuration(input) && hasOwnProp(input, \"_isValid\")) {\n          \
ret._isValid = input._isValid;\n        }\n        return ret;\n      }\n     \
 createDuration.fn = Duration.prototype;\n      createDuration.invalid = \
createInvalid$1;\n      function parseIso(inp, sign2) {\n        var res = \
inp && parseFloat(inp.replace(\",\", \".\"));\n        return (isNaN(res) ? 0 \
: res) * sign2;\n      }\n      function positiveMomentsDifference(base, \
other) {\n        var res = {};\n        res.months = other.month() - \
base.month() + (other.year() - base.year()) * 12;\n        if \
(base.clone().add(res.months, \"M\").isAfter(other)) {\n          \
--res.months;\n        }\n        res.milliseconds = +other - \
+base.clone().add(res.months, \"M\");\n        return res;\n      }\n      \
function momentsDifference(base, other) {\n        var res;\n        if \
(!(base.isValid() && other.isValid())) {\n          return { milliseconds: 0, \
months: 0 };\n        }\n        other = cloneWithOffset(other, base);\n      \
  if (base.isBefore(other)) {\n          res = \
positiveMomentsDifference(base, other);\n        } else {\n          res = \
positiveMomentsDifference(other, base);\n          res.milliseconds = \
-res.milliseconds;\n          res.months = -res.months;\n        }\n        \
return res;\n      }\n      function createAdder(direction, name) {\n        \
return function(val, period) {\n          var dur, tmp;\n          if (period \
!== null && !isNaN(+period)) {\n            deprecateSimple(\n              \
name,\n              \"moment().\" + name + \"(period, number) is deprecated. \
Please use moment().\" + name + \"(number, period). See \
http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.\"\n  \
          );\n            tmp = val;\n            val = period;\n            \
period = tmp;\n          }\n          dur = createDuration(val, period);\n    \
      addSubtract(this, dur, direction);\n          return this;\n        \
};\n      }\n      function addSubtract(mom, duration, isAdding, \
updateOffset) {\n        var milliseconds2 = duration._milliseconds, days2 = \
absRound(duration._days), months2 = absRound(duration._months);\n        if \
(!mom.isValid()) {\n          return;\n        }\n        updateOffset = \
updateOffset == null ? true : updateOffset;\n        if (months2) {\n         \
 setMonth(mom, get(mom, \"Month\") + months2 * isAdding);\n        }\n        \
if (days2) {\n          set$1(mom, \"Date\", get(mom, \"Date\") + days2 * \
isAdding);\n        }\n        if (milliseconds2) {\n          \
mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);\n        }\n     \
   if (updateOffset) {\n          hooks.updateOffset(mom, days2 || \
months2);\n        }\n      }\n      var add = createAdder(1, \"add\"), \
subtract = createAdder(-1, \"subtract\");\n      function isString(input) {\n \
       return typeof input === \"string\" || input instanceof String;\n      \
}\n      function isMomentInput(input) {\n        return isMoment(input) || \
isDate2(input) || isString(input) || isNumber(input) || \
isNumberOrStringArray(input) || isMomentInputObject(input) || input === null \
|| input === void 0;\n      }\n      function isMomentInputObject(input) {\n  \
      var objectTest = isObject2(input) && !isObjectEmpty(input), \
propertyTest = false, properties = [\n          \"years\",\n          \
\"year\",\n          \"y\",\n          \"months\",\n          \"month\",\n    \
      \"M\",\n          \"days\",\n          \"day\",\n          \"d\",\n     \
     \"dates\",\n          \"date\",\n          \"D\",\n          \
\"hours\",\n          \"hour\",\n          \"h\",\n          \"minutes\",\n   \
       \"minute\",\n          \"m\",\n          \"seconds\",\n          \
\"second\",\n          \"s\",\n          \"milliseconds\",\n          \
\"millisecond\",\n          \"ms\"\n        ], i, property, propertyLen = \
properties.length;\n        for (i = 0; i < propertyLen; i += 1) {\n          \
property = properties[i];\n          propertyTest = propertyTest || \
hasOwnProp(input, property);\n        }\n        return objectTest && \
propertyTest;\n      }\n      function isNumberOrStringArray(input) {\n       \
 var arrayTest = isArray(input), dataTypeTest = false;\n        if \
(arrayTest) {\n          dataTypeTest = input.filter(function(item) {\n       \
     return !isNumber(item) && isString(input);\n          }).length === 0;\n \
       }\n        return arrayTest && dataTypeTest;\n      }\n      function \
isCalendarSpec(input) {\n        var objectTest = isObject2(input) && \
!isObjectEmpty(input), propertyTest = false, properties = [\n          \
\"sameDay\",\n          \"nextDay\",\n          \"lastDay\",\n          \
\"nextWeek\",\n          \"lastWeek\",\n          \"sameElse\"\n        ], i, \
property;\n        for (i = 0; i < properties.length; i += 1) {\n          \
property = properties[i];\n          propertyTest = propertyTest || \
hasOwnProp(input, property);\n        }\n        return objectTest && \
propertyTest;\n      }\n      function getCalendarFormat(myMoment, now2) {\n  \
      var diff2 = myMoment.diff(now2, \"days\", true);\n        return diff2 \
< -6 ? \"sameElse\" : diff2 < -1 ? \"lastWeek\" : diff2 < 0 ? \"lastDay\" : \
diff2 < 1 ? \"sameDay\" : diff2 < 2 ? \"nextDay\" : diff2 < 7 ? \"nextWeek\" \
: \"sameElse\";\n      }\n      function calendar$1(time, formats) {\n        \
if (arguments.length === 1) {\n          if (!arguments[0]) {\n            \
time = void 0;\n            formats = void 0;\n          } else if \
(isMomentInput(arguments[0])) {\n            time = arguments[0];\n           \
 formats = void 0;\n          } else if (isCalendarSpec(arguments[0])) {\n    \
        formats = arguments[0];\n            time = void 0;\n          }\n    \
    }\n        var now2 = time || createLocal(), sod = cloneWithOffset(now2, \
this).startOf(\"day\"), format2 = hooks.calendarFormat(this, sod) || \
\"sameElse\", output = formats && (isFunction2(formats[format2]) ? \
formats[format2].call(this, now2) : formats[format2]);\n        return \
this.format(\n          output || this.localeData().calendar(format2, this, \
createLocal(now2))\n        );\n      }\n      function clone2() {\n        \
return new Moment(this);\n      }\n      function isAfter(input, units) {\n   \
     var localInput = isMoment(input) ? input : createLocal(input);\n        \
if (!(this.isValid() && localInput.isValid())) {\n          return false;\n   \
     }\n        units = normalizeUnits(units) || \"millisecond\";\n        if \
(units === \"millisecond\") {\n          return this.valueOf() > \
localInput.valueOf();\n        } else {\n          return \
localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    \
  }\n      function isBefore(input, units) {\n        var localInput = \
isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() \
&& localInput.isValid())) {\n          return false;\n        }\n        \
units = normalizeUnits(units) || \"millisecond\";\n        if (units === \
\"millisecond\") {\n          return this.valueOf() < localInput.valueOf();\n \
       } else {\n          return this.clone().endOf(units).valueOf() < \
localInput.valueOf();\n        }\n      }\n      function isBetween(from2, \
to2, units, inclusivity) {\n        var localFrom = isMoment(from2) ? from2 : \
createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);\n       \
 if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n       \
   return false;\n        }\n        inclusivity = inclusivity || \"()\";\n   \
     return (inclusivity[0] === \"(\" ? this.isAfter(localFrom, units) : \
!this.isBefore(localFrom, units)) && (inclusivity[1] === \")\" ? \
this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n      }\n    \
  function isSame(input, units) {\n        var localInput = isMoment(input) ? \
input : createLocal(input), inputMs;\n        if (!(this.isValid() && \
localInput.isValid())) {\n          return false;\n        }\n        units = \
normalizeUnits(units) || \"millisecond\";\n        if (units === \
\"millisecond\") {\n          return this.valueOf() === \
localInput.valueOf();\n        } else {\n          inputMs = \
localInput.valueOf();\n          return this.clone().startOf(units).valueOf() \
<= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    \
  }\n      function isSameOrAfter(input, units) {\n        return \
this.isSame(input, units) || this.isAfter(input, units);\n      }\n      \
function isSameOrBefore(input, units) {\n        return this.isSame(input, \
units) || this.isBefore(input, units);\n      }\n      function diff(input, \
units, asFloat) {\n        var that, zoneDelta, output;\n        if \
(!this.isValid()) {\n          return NaN;\n        }\n        that = \
cloneWithOffset(input, this);\n        if (!that.isValid()) {\n          \
return NaN;\n        }\n        zoneDelta = (that.utcOffset() - \
this.utcOffset()) * 6e4;\n        units = normalizeUnits(units);\n        \
switch (units) {\n          case \"year\":\n            output = \
monthDiff(this, that) / 12;\n            break;\n          case \"month\":\n  \
          output = monthDiff(this, that);\n            break;\n          case \
\"quarter\":\n            output = monthDiff(this, that) / 3;\n            \
break;\n          case \"second\":\n            output = (this - that) / \
1e3;\n            break;\n          case \"minute\":\n            output = \
(this - that) / 6e4;\n            break;\n          case \"hour\":\n          \
  output = (this - that) / 36e5;\n            break;\n          case \
\"day\":\n            output = (this - that - zoneDelta) / 864e5;\n           \
 break;\n          case \"week\":\n            output = (this - that - \
zoneDelta) / 6048e5;\n            break;\n          default:\n            \
output = this - that;\n        }\n        return asFloat ? output : \
absFloor(output);\n      }\n      function monthDiff(a, b) {\n        if \
(a.date() < b.date()) {\n          return -monthDiff(b, a);\n        }\n      \
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), \
anchor = a.clone().add(wholeMonthDiff, \"months\"), anchor2, adjust;\n        \
if (b - anchor < 0) {\n          anchor2 = a.clone().add(wholeMonthDiff - 1, \
\"months\");\n          adjust = (b - anchor) / (anchor - anchor2);\n        \
} else {\n          anchor2 = a.clone().add(wholeMonthDiff + 1, \
\"months\");\n          adjust = (b - anchor) / (anchor2 - anchor);\n        \
}\n        return -(wholeMonthDiff + adjust) || 0;\n      }\n      \
hooks.defaultFormat = \"YYYY-MM-DDTHH:mm:ssZ\";\n      hooks.defaultFormatUtc \
= \"YYYY-MM-DDTHH:mm:ss[Z]\";\n      function toString() {\n        return \
this.clone().locale(\"en\").format(\"ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\");\n   \
   }\n      function toISOString(keepOffset) {\n        if (!this.isValid()) \
{\n          return null;\n        }\n        var utc = keepOffset !== true, \
m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > \
9999) {\n          return formatMoment(\n            m,\n            utc ? \
\"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]\" : \"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ\"\n       \
   );\n        }\n        if (isFunction2(Date.prototype.toISOString)) {\n    \
      if (utc) {\n            return this.toDate().toISOString();\n          \
} else {\n            return new Date(this.valueOf() + this.utcOffset() * 60 \
* 1e3).toISOString().replace(\"Z\", formatMoment(m, \"Z\"));\n          }\n   \
     }\n        return formatMoment(\n          m,\n          utc ? \
\"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]\" : \"YYYY-MM-DD[T]HH:mm:ss.SSSZ\"\n        \
);\n      }\n      function inspect() {\n        if (!this.isValid()) {\n     \
     return \"moment.invalid(/* \" + this._i + \" */)\";\n        }\n        \
var func = \"moment\", zone = \"\", prefix, year, datetime, suffix;\n        \
if (!this.isLocal()) {\n          func = this.utcOffset() === 0 ? \
\"moment.utc\" : \"moment.parseZone\";\n          zone = \"Z\";\n        }\n  \
      prefix = \"[\" + func + '(\"]';\n        year = 0 <= this.year() && \
this.year() <= 9999 ? \"YYYY\" : \"YYYYYY\";\n        datetime = \
\"-MM-DD[T]HH:mm:ss.SSS\";\n        suffix = zone + '[\")]';\n        return \
this.format(prefix + year + datetime + suffix);\n      }\n      function \
format(inputString) {\n        if (!inputString) {\n          inputString = \
this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n     \
   var output = formatMoment(this, inputString);\n        return \
this.localeData().postformat(output);\n      }\n      function from(time, \
withoutSuffix) {\n        if (this.isValid() && (isMoment(time) && \
time.isValid() || createLocal(time).isValid())) {\n          return \
createDuration({ to: this, from: time \
}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n        \
  return this.localeData().invalidDate();\n        }\n      }\n      function \
fromNow(withoutSuffix) {\n        return this.from(createLocal(), \
withoutSuffix);\n      }\n      function to(time, withoutSuffix) {\n        \
if (this.isValid() && (isMoment(time) && time.isValid() || \
createLocal(time).isValid())) {\n          return createDuration({ from: \
this, to: time }).locale(this.locale()).humanize(!withoutSuffix);\n        } \
else {\n          return this.localeData().invalidDate();\n        }\n      \
}\n      function toNow(withoutSuffix) {\n        return \
this.to(createLocal(), withoutSuffix);\n      }\n      function locale(key) \
{\n        var newLocaleData;\n        if (key === void 0) {\n          \
return this._locale._abbr;\n        } else {\n          newLocaleData = \
getLocale(key);\n          if (newLocaleData != null) {\n            \
this._locale = newLocaleData;\n          }\n          return this;\n        \
}\n      }\n      var lang = deprecate(\n        \"moment().lang() is \
deprecated. Instead, use moment().localeData() to get the language \
configuration. Use moment().locale() to change languages.\",\n        \
function(key) {\n          if (key === void 0) {\n            return \
this.localeData();\n          } else {\n            return \
this.locale(key);\n          }\n        }\n      );\n      function \
localeData() {\n        return this._locale;\n      }\n      var \
MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * \
MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n      \
function mod$1(dividend, divisor) {\n        return (dividend % divisor + \
divisor) % divisor;\n      }\n      function localStartOfDate(y, m, d) {\n    \
    if (y < 100 && y >= 0) {\n          return new Date(y + 400, m, d) - \
MS_PER_400_YEARS;\n        } else {\n          return new Date(y, m, \
d).valueOf();\n        }\n      }\n      function utcStartOfDate(y, m, d) {\n \
       if (y < 100 && y >= 0) {\n          return Date.UTC(y + 400, m, d) - \
MS_PER_400_YEARS;\n        } else {\n          return Date.UTC(y, m, d);\n    \
    }\n      }\n      function startOf(units) {\n        var time, \
startOfDate;\n        units = normalizeUnits(units);\n        if (units === \
void 0 || units === \"millisecond\" || !this.isValid()) {\n          return \
this;\n        }\n        startOfDate = this._isUTC ? utcStartOfDate : \
localStartOfDate;\n        switch (units) {\n          case \"year\":\n       \
     time = startOfDate(this.year(), 0, 1);\n            break;\n          \
case \"quarter\":\n            time = startOfDate(\n              \
this.year(),\n              this.month() - this.month() % 3,\n              \
1\n            );\n            break;\n          case \"month\":\n            \
time = startOfDate(this.year(), this.month(), 1);\n            break;\n       \
   case \"week\":\n            time = startOfDate(\n              \
this.year(),\n              this.month(),\n              this.date() - \
this.weekday()\n            );\n            break;\n          case \
\"isoWeek\":\n            time = startOfDate(\n              this.year(),\n   \
           this.month(),\n              this.date() - (this.isoWeekday() - \
1)\n            );\n            break;\n          case \"day\":\n          \
case \"date\":\n            time = startOfDate(this.year(), this.month(), \
this.date());\n            break;\n          case \"hour\":\n            time \
= this._d.valueOf();\n            time -= mod$1(\n              time + \
(this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\n              \
MS_PER_HOUR\n            );\n            break;\n          case \"minute\":\n \
           time = this._d.valueOf();\n            time -= mod$1(time, \
MS_PER_MINUTE);\n            break;\n          case \"second\":\n            \
time = this._d.valueOf();\n            time -= mod$1(time, MS_PER_SECOND);\n  \
          break;\n        }\n        this._d.setTime(time);\n        \
hooks.updateOffset(this, true);\n        return this;\n      }\n      \
function endOf(units) {\n        var time, startOfDate;\n        units = \
normalizeUnits(units);\n        if (units === void 0 || units === \
\"millisecond\" || !this.isValid()) {\n          return this;\n        }\n    \
    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n        \
switch (units) {\n          case \"year\":\n            time = \
startOfDate(this.year() + 1, 0, 1) - 1;\n            break;\n          case \
\"quarter\":\n            time = startOfDate(\n              this.year(),\n   \
           this.month() - this.month() % 3 + 3,\n              1\n            \
) - 1;\n            break;\n          case \"month\":\n            time = \
startOfDate(this.year(), this.month() + 1, 1) - 1;\n            break;\n      \
    case \"week\":\n            time = startOfDate(\n              \
this.year(),\n              this.month(),\n              this.date() - \
this.weekday() + 7\n            ) - 1;\n            break;\n          case \
\"isoWeek\":\n            time = startOfDate(\n              this.year(),\n   \
           this.month(),\n              this.date() - (this.isoWeekday() - 1) \
+ 7\n            ) - 1;\n            break;\n          case \"day\":\n        \
  case \"date\":\n            time = startOfDate(this.year(), this.month(), \
this.date() + 1) - 1;\n            break;\n          case \"hour\":\n         \
   time = this._d.valueOf();\n            time += MS_PER_HOUR - mod$1(\n      \
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\n        \
      MS_PER_HOUR\n            ) - 1;\n            break;\n          case \
\"minute\":\n            time = this._d.valueOf();\n            time += \
MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n            break;\n         \
 case \"second\":\n            time = this._d.valueOf();\n            time += \
MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n            break;\n        \
}\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n  \
      return this;\n      }\n      function valueOf() {\n        return \
this._d.valueOf() - (this._offset || 0) * 6e4;\n      }\n      function \
unix() {\n        return Math.floor(this.valueOf() / 1e3);\n      }\n      \
function toDate() {\n        return new Date(this.valueOf());\n      }\n      \
function toArray() {\n        var m = this;\n        return [\n          \
m.year(),\n          m.month(),\n          m.date(),\n          m.hour(),\n   \
       m.minute(),\n          m.second(),\n          m.millisecond()\n        \
];\n      }\n      function toObject4() {\n        var m = this;\n        \
return {\n          years: m.year(),\n          months: m.month(),\n          \
date: m.date(),\n          hours: m.hours(),\n          minutes: \
m.minutes(),\n          seconds: m.seconds(),\n          milliseconds: \
m.milliseconds()\n        };\n      }\n      function toJSON() {\n        \
return this.isValid() ? this.toISOString() : null;\n      }\n      function \
isValid$2() {\n        return isValid(this);\n      }\n      function \
parsingFlags() {\n        return extend2({}, getParsingFlags(this));\n      \
}\n      function invalidAt() {\n        return \
getParsingFlags(this).overflow;\n      }\n      function creationData() {\n   \
     return {\n          input: this._i,\n          format: this._f,\n        \
  locale: this._locale,\n          isUTC: this._isUTC,\n          strict: \
this._strict\n        };\n      }\n      addFormatToken(\"N\", 0, 0, \
\"eraAbbr\");\n      addFormatToken(\"NN\", 0, 0, \"eraAbbr\");\n      \
addFormatToken(\"NNN\", 0, 0, \"eraAbbr\");\n      addFormatToken(\"NNNN\", \
0, 0, \"eraName\");\n      addFormatToken(\"NNNNN\", 0, 0, \"eraNarrow\");\n  \
    addFormatToken(\"y\", [\"y\", 1], \"yo\", \"eraYear\");\n      \
addFormatToken(\"y\", [\"yy\", 2], 0, \"eraYear\");\n      \
addFormatToken(\"y\", [\"yyy\", 3], 0, \"eraYear\");\n      \
addFormatToken(\"y\", [\"yyyy\", 4], 0, \"eraYear\");\n      \
addRegexToken(\"N\", matchEraAbbr);\n      addRegexToken(\"NN\", \
matchEraAbbr);\n      addRegexToken(\"NNN\", matchEraAbbr);\n      \
addRegexToken(\"NNNN\", matchEraName);\n      addRegexToken(\"NNNNN\", \
matchEraNarrow);\n      addParseToken(\n        [\"N\", \"NN\", \"NNN\", \
\"NNNN\", \"NNNNN\"],\n        function(input, array, config, token2) {\n     \
     var era = config._locale.erasParse(input, token2, config._strict);\n     \
     if (era) {\n            getParsingFlags(config).era = era;\n          } \
else {\n            getParsingFlags(config).invalidEra = input;\n          \
}\n        }\n      );\n      addRegexToken(\"y\", matchUnsigned);\n      \
addRegexToken(\"yy\", matchUnsigned);\n      addRegexToken(\"yyy\", \
matchUnsigned);\n      addRegexToken(\"yyyy\", matchUnsigned);\n      \
addRegexToken(\"yo\", matchEraYearOrdinal);\n      addParseToken([\"y\", \
\"yy\", \"yyy\", \"yyyy\"], YEAR);\n      addParseToken([\"yo\"], \
function(input, array, config, token2) {\n        var match;\n        if \
(config._locale._eraYearOrdinalRegex) {\n          match = \
input.match(config._locale._eraYearOrdinalRegex);\n        }\n        if \
(config._locale.eraYearOrdinalParse) {\n          array[YEAR] = \
config._locale.eraYearOrdinalParse(input, match);\n        } else {\n         \
 array[YEAR] = parseInt(input, 10);\n        }\n      });\n      function \
localeEras(m, format2) {\n        var i, l, date, eras = this._eras || \
getLocale(\"en\")._eras;\n        for (i = 0, l = eras.length; i < l; ++i) \
{\n          switch (typeof eras[i].since) {\n            case \"string\":\n  \
            date = hooks(eras[i].since).startOf(\"day\");\n              \
eras[i].since = date.valueOf();\n              break;\n          }\n          \
switch (typeof eras[i].until) {\n            case \"undefined\":\n            \
  eras[i].until = Infinity;\n              break;\n            case \
\"string\":\n              date = \
hooks(eras[i].until).startOf(\"day\").valueOf();\n              eras[i].until \
= date.valueOf();\n              break;\n          }\n        }\n        \
return eras;\n      }\n      function localeErasParse(eraName, format2, \
strict) {\n        var i, l, eras = this.eras(), name, abbr, narrow;\n        \
eraName = eraName.toUpperCase();\n        for (i = 0, l = eras.length; i < l; \
++i) {\n          name = eras[i].name.toUpperCase();\n          abbr = \
eras[i].abbr.toUpperCase();\n          narrow = \
eras[i].narrow.toUpperCase();\n          if (strict) {\n            switch \
(format2) {\n              case \"N\":\n              case \"NN\":\n          \
    case \"NNN\":\n                if (abbr === eraName) {\n                  \
return eras[i];\n                }\n                break;\n              \
case \"NNNN\":\n                if (name === eraName) {\n                  \
return eras[i];\n                }\n                break;\n              \
case \"NNNNN\":\n                if (narrow === eraName) {\n                  \
return eras[i];\n                }\n                break;\n            }\n   \
       } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {\n            \
return eras[i];\n          }\n        }\n      }\n      function \
localeErasConvertYear(era, year) {\n        var dir = era.since <= era.until \
? 1 : -1;\n        if (year === void 0) {\n          return \
hooks(era.since).year();\n        } else {\n          return \
hooks(era.since).year() + (year - era.offset) * dir;\n        }\n      }\n    \
  function getEraName() {\n        var i, l, val, eras = \
this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) \
{\n          val = this.clone().startOf(\"day\").valueOf();\n          if \
(eras[i].since <= val && val <= eras[i].until) {\n            return \
eras[i].name;\n          }\n          if (eras[i].until <= val && val <= \
eras[i].since) {\n            return eras[i].name;\n          }\n        }\n  \
      return \"\";\n      }\n      function getEraNarrow() {\n        var i, \
l, val, eras = this.localeData().eras();\n        for (i = 0, l = \
eras.length; i < l; ++i) {\n          val = \
this.clone().startOf(\"day\").valueOf();\n          if (eras[i].since <= val \
&& val <= eras[i].until) {\n            return eras[i].narrow;\n          }\n \
         if (eras[i].until <= val && val <= eras[i].since) {\n            \
return eras[i].narrow;\n          }\n        }\n        return \"\";\n      \
}\n      function getEraAbbr() {\n        var i, l, val, eras = \
this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) \
{\n          val = this.clone().startOf(\"day\").valueOf();\n          if \
(eras[i].since <= val && val <= eras[i].until) {\n            return \
eras[i].abbr;\n          }\n          if (eras[i].until <= val && val <= \
eras[i].since) {\n            return eras[i].abbr;\n          }\n        }\n  \
      return \"\";\n      }\n      function getEraYear() {\n        var i, l, \
dir, val, eras = this.localeData().eras();\n        for (i = 0, l = \
eras.length; i < l; ++i) {\n          dir = eras[i].since <= eras[i].until ? \
1 : -1;\n          val = this.clone().startOf(\"day\").valueOf();\n          \
if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && \
val <= eras[i].since) {\n            return (this.year() - \
hooks(eras[i].since).year()) * dir + eras[i].offset;\n          }\n        \
}\n        return this.year();\n      }\n      function \
erasNameRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasNameRegex\")) \
{\n          computeErasParse.call(this);\n        }\n        return isStrict \
? this._erasNameRegex : this._erasRegex;\n      }\n      function \
erasAbbrRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasAbbrRegex\")) \
{\n          computeErasParse.call(this);\n        }\n        return isStrict \
? this._erasAbbrRegex : this._erasRegex;\n      }\n      function \
erasNarrowRegex(isStrict) {\n        if (!hasOwnProp(this, \
\"_erasNarrowRegex\")) {\n          computeErasParse.call(this);\n        }\n \
       return isStrict ? this._erasNarrowRegex : this._erasRegex;\n      }\n  \
    function matchEraAbbr(isStrict, locale2) {\n        return \
locale2.erasAbbrRegex(isStrict);\n      }\n      function \
matchEraName(isStrict, locale2) {\n        return \
locale2.erasNameRegex(isStrict);\n      }\n      function \
matchEraNarrow(isStrict, locale2) {\n        return \
locale2.erasNarrowRegex(isStrict);\n      }\n      function \
matchEraYearOrdinal(isStrict, locale2) {\n        return \
locale2._eraYearOrdinalRegex || matchUnsigned;\n      }\n      function \
computeErasParse() {\n        var abbrPieces = [], namePieces = [], \
narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();\n        for \
(i = 0, l = eras.length; i < l; ++i) {\n          \
namePieces.push(regexEscape(eras[i].name));\n          \
abbrPieces.push(regexEscape(eras[i].abbr));\n          \
narrowPieces.push(regexEscape(eras[i].narrow));\n          \
mixedPieces.push(regexEscape(eras[i].name));\n          \
mixedPieces.push(regexEscape(eras[i].abbr));\n          \
mixedPieces.push(regexEscape(eras[i].narrow));\n        }\n        \
this._erasRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \
\"i\");\n        this._erasNameRegex = new RegExp(\"^(\" + \
namePieces.join(\"|\") + \")\", \"i\");\n        this._erasAbbrRegex = new \
RegExp(\"^(\" + abbrPieces.join(\"|\") + \")\", \"i\");\n        \
this._erasNarrowRegex = new RegExp(\n          \"^(\" + \
narrowPieces.join(\"|\") + \")\",\n          \"i\"\n        );\n      }\n     \
 addFormatToken(0, [\"gg\", 2], 0, function() {\n        return \
this.weekYear() % 100;\n      });\n      addFormatToken(0, [\"GG\", 2], 0, \
function() {\n        return this.isoWeekYear() % 100;\n      });\n      \
function addWeekYearFormatToken(token2, getter) {\n        addFormatToken(0, \
[token2, token2.length], 0, getter);\n      }\n      \
addWeekYearFormatToken(\"gggg\", \"weekYear\");\n      \
addWeekYearFormatToken(\"ggggg\", \"weekYear\");\n      \
addWeekYearFormatToken(\"GGGG\", \"isoWeekYear\");\n      \
addWeekYearFormatToken(\"GGGGG\", \"isoWeekYear\");\n      \
addUnitAlias(\"weekYear\", \"gg\");\n      addUnitAlias(\"isoWeekYear\", \
\"GG\");\n      addUnitPriority(\"weekYear\", 1);\n      \
addUnitPriority(\"isoWeekYear\", 1);\n      addRegexToken(\"G\", \
matchSigned);\n      addRegexToken(\"g\", matchSigned);\n      \
addRegexToken(\"GG\", match1to2, match2);\n      addRegexToken(\"gg\", \
match1to2, match2);\n      addRegexToken(\"GGGG\", match1to4, match4);\n      \
addRegexToken(\"gggg\", match1to4, match4);\n      addRegexToken(\"GGGGG\", \
match1to6, match6);\n      addRegexToken(\"ggggg\", match1to6, match6);\n     \
 addWeekParseToken(\n        [\"gggg\", \"ggggg\", \"GGGG\", \"GGGGG\"],\n    \
    function(input, week, config, token2) {\n          week[token2.substr(0, \
2)] = toInt(input);\n        }\n      );\n      addWeekParseToken([\"gg\", \
\"GG\"], function(input, week, config, token2) {\n        week[token2] = \
hooks.parseTwoDigitYear(input);\n      });\n      function \
getSetWeekYear(input) {\n        return getSetWeekYearHelper.call(\n          \
this,\n          input,\n          this.week(),\n          this.weekday(),\n  \
        this.localeData()._week.dow,\n          this.localeData()._week.doy\n \
       );\n      }\n      function getSetISOWeekYear(input) {\n        return \
getSetWeekYearHelper.call(\n          this,\n          input,\n          \
this.isoWeek(),\n          this.isoWeekday(),\n          1,\n          4\n    \
    );\n      }\n      function getISOWeeksInYear() {\n        return \
weeksInYear(this.year(), 1, 4);\n      }\n      function \
getISOWeeksInISOWeekYear() {\n        return weeksInYear(this.isoWeekYear(), \
1, 4);\n      }\n      function getWeeksInYear() {\n        var weekInfo = \
this.localeData()._week;\n        return weeksInYear(this.year(), \
weekInfo.dow, weekInfo.doy);\n      }\n      function getWeeksInWeekYear() \
{\n        var weekInfo = this.localeData()._week;\n        return \
weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n      }\n      \
function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var \
weeksTarget;\n        if (input == null) {\n          return weekOfYear(this, \
dow, doy).year;\n        } else {\n          weeksTarget = weeksInYear(input, \
dow, doy);\n          if (week > weeksTarget) {\n            week = \
weeksTarget;\n          }\n          return setWeekAll.call(this, input, \
week, weekday, dow, doy);\n        }\n      }\n      function \
setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = \
dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = \
createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n        \
this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n  \
      this.date(date.getUTCDate());\n        return this;\n      }\n      \
addFormatToken(\"Q\", 0, \"Qo\", \"quarter\");\n      \
addUnitAlias(\"quarter\", \"Q\");\n      addUnitPriority(\"quarter\", 7);\n   \
   addRegexToken(\"Q\", match1);\n      addParseToken(\"Q\", function(input, \
array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n      });\n      \
function getSetQuarter(input) {\n        return input == null ? \
Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() \
% 3);\n      }\n      addFormatToken(\"D\", [\"DD\", 2], \"Do\", \"date\");\n \
     addUnitAlias(\"date\", \"D\");\n      addUnitPriority(\"date\", 9);\n    \
  addRegexToken(\"D\", match1to2);\n      addRegexToken(\"DD\", match1to2, \
match2);\n      addRegexToken(\"Do\", function(isStrict, locale2) {\n        \
return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : \
locale2._dayOfMonthOrdinalParseLenient;\n      });\n      \
addParseToken([\"D\", \"DD\"], DATE);\n      addParseToken(\"Do\", \
function(input, array) {\n        array[DATE] = \
toInt(input.match(match1to2)[0]);\n      });\n      var getSetDayOfMonth = \
makeGetSet(\"Date\", true);\n      addFormatToken(\"DDD\", [\"DDDD\", 3], \
\"DDDo\", \"dayOfYear\");\n      addUnitAlias(\"dayOfYear\", \"DDD\");\n      \
addUnitPriority(\"dayOfYear\", 4);\n      addRegexToken(\"DDD\", \
match1to3);\n      addRegexToken(\"DDDD\", match3);\n      \
addParseToken([\"DDD\", \"DDDD\"], function(input, array, config) {\n        \
config._dayOfYear = toInt(input);\n      });\n      function \
getSetDayOfYear(input) {\n        var dayOfYear = Math.round(\n          \
(this.clone().startOf(\"day\") - this.clone().startOf(\"year\")) / 864e5\n    \
    ) + 1;\n        return input == null ? dayOfYear : this.add(input - \
dayOfYear, \"d\");\n      }\n      addFormatToken(\"m\", [\"mm\", 2], 0, \
\"minute\");\n      addUnitAlias(\"minute\", \"m\");\n      \
addUnitPriority(\"minute\", 14);\n      addRegexToken(\"m\", match1to2);\n    \
  addRegexToken(\"mm\", match1to2, match2);\n      addParseToken([\"m\", \
\"mm\"], MINUTE);\n      var getSetMinute = makeGetSet(\"Minutes\", false);\n \
     addFormatToken(\"s\", [\"ss\", 2], 0, \"second\");\n      \
addUnitAlias(\"second\", \"s\");\n      addUnitPriority(\"second\", 15);\n    \
  addRegexToken(\"s\", match1to2);\n      addRegexToken(\"ss\", match1to2, \
match2);\n      addParseToken([\"s\", \"ss\"], SECOND);\n      var \
getSetSecond = makeGetSet(\"Seconds\", false);\n      addFormatToken(\"S\", \
0, 0, function() {\n        return ~~(this.millisecond() / 100);\n      });\n \
     addFormatToken(0, [\"SS\", 2], 0, function() {\n        return \
~~(this.millisecond() / 10);\n      });\n      addFormatToken(0, [\"SSS\", \
3], 0, \"millisecond\");\n      addFormatToken(0, [\"SSSS\", 4], 0, \
function() {\n        return this.millisecond() * 10;\n      });\n      \
addFormatToken(0, [\"SSSSS\", 5], 0, function() {\n        return \
this.millisecond() * 100;\n      });\n      addFormatToken(0, [\"SSSSSS\", \
6], 0, function() {\n        return this.millisecond() * 1e3;\n      });\n    \
  addFormatToken(0, [\"SSSSSSS\", 7], 0, function() {\n        return \
this.millisecond() * 1e4;\n      });\n      addFormatToken(0, [\"SSSSSSSS\", \
8], 0, function() {\n        return this.millisecond() * 1e5;\n      });\n    \
  addFormatToken(0, [\"SSSSSSSSS\", 9], 0, function() {\n        return \
this.millisecond() * 1e6;\n      });\n      addUnitAlias(\"millisecond\", \
\"ms\");\n      addUnitPriority(\"millisecond\", 16);\n      \
addRegexToken(\"S\", match1to3, match1);\n      addRegexToken(\"SS\", \
match1to3, match2);\n      addRegexToken(\"SSS\", match1to3, match3);\n      \
var token, getSetMillisecond;\n      for (token = \"SSSS\"; token.length <= \
9; token += \"S\") {\n        addRegexToken(token, matchUnsigned);\n      }\n \
     function parseMs(input, array) {\n        array[MILLISECOND] = \
toInt((\"0.\" + input) * 1e3);\n      }\n      for (token = \"S\"; \
token.length <= 9; token += \"S\") {\n        addParseToken(token, \
parseMs);\n      }\n      getSetMillisecond = makeGetSet(\"Milliseconds\", \
false);\n      addFormatToken(\"z\", 0, 0, \"zoneAbbr\");\n      \
addFormatToken(\"zz\", 0, 0, \"zoneName\");\n      function getZoneAbbr() {\n \
       return this._isUTC ? \"UTC\" : \"\";\n      }\n      function \
getZoneName() {\n        return this._isUTC ? \"Coordinated Universal Time\" \
: \"\";\n      }\n      var proto = Moment.prototype;\n      proto.add = \
add;\n      proto.calendar = calendar$1;\n      proto.clone = clone2;\n      \
proto.diff = diff;\n      proto.endOf = endOf;\n      proto.format = \
format;\n      proto.from = from;\n      proto.fromNow = fromNow;\n      \
proto.to = to;\n      proto.toNow = toNow;\n      proto.get = stringGet;\n    \
  proto.invalidAt = invalidAt;\n      proto.isAfter = isAfter;\n      \
proto.isBefore = isBefore;\n      proto.isBetween = isBetween;\n      \
proto.isSame = isSame;\n      proto.isSameOrAfter = isSameOrAfter;\n      \
proto.isSameOrBefore = isSameOrBefore;\n      proto.isValid = isValid$2;\n    \
  proto.lang = lang;\n      proto.locale = locale;\n      proto.localeData = \
localeData;\n      proto.max = prototypeMax;\n      proto.min = \
prototypeMin;\n      proto.parsingFlags = parsingFlags;\n      proto.set = \
stringSet;\n      proto.startOf = startOf;\n      proto.subtract = \
subtract;\n      proto.toArray = toArray;\n      proto.toObject = \
toObject4;\n      proto.toDate = toDate;\n      proto.toISOString = \
toISOString;\n      proto.inspect = inspect;\n      if (typeof Symbol !== \
\"undefined\" && Symbol.for != null) {\n        \
proto[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n          \
return \"Moment<\" + this.format() + \">\";\n        };\n      }\n      \
proto.toJSON = toJSON;\n      proto.toString = toString;\n      proto.unix = \
unix;\n      proto.valueOf = valueOf;\n      proto.creationData = \
creationData;\n      proto.eraName = getEraName;\n      proto.eraNarrow = \
getEraNarrow;\n      proto.eraAbbr = getEraAbbr;\n      proto.eraYear = \
getEraYear;\n      proto.year = getSetYear;\n      proto.isLeapYear = \
getIsLeapYear;\n      proto.weekYear = getSetWeekYear;\n      \
proto.isoWeekYear = getSetISOWeekYear;\n      proto.quarter = proto.quarters \
= getSetQuarter;\n      proto.month = getSetMonth;\n      proto.daysInMonth = \
getDaysInMonth;\n      proto.week = proto.weeks = getSetWeek;\n      \
proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n      proto.weeksInYear = \
getWeeksInYear;\n      proto.weeksInWeekYear = getWeeksInWeekYear;\n      \
proto.isoWeeksInYear = getISOWeeksInYear;\n      proto.isoWeeksInISOWeekYear \
= getISOWeeksInISOWeekYear;\n      proto.date = getSetDayOfMonth;\n      \
proto.day = proto.days = getSetDayOfWeek;\n      proto.weekday = \
getSetLocaleDayOfWeek;\n      proto.isoWeekday = getSetISODayOfWeek;\n      \
proto.dayOfYear = getSetDayOfYear;\n      proto.hour = proto.hours = \
getSetHour;\n      proto.minute = proto.minutes = getSetMinute;\n      \
proto.second = proto.seconds = getSetSecond;\n      proto.millisecond = \
proto.milliseconds = getSetMillisecond;\n      proto.utcOffset = \
getSetOffset;\n      proto.utc = setOffsetToUTC;\n      proto.local = \
setOffsetToLocal;\n      proto.parseZone = setOffsetToParsedOffset;\n      \
proto.hasAlignedHourOffset = hasAlignedHourOffset;\n      proto.isDST = \
isDaylightSavingTime;\n      proto.isLocal = isLocal;\n      \
proto.isUtcOffset = isUtcOffset;\n      proto.isUtc = isUtc;\n      \
proto.isUTC = isUtc;\n      proto.zoneAbbr = getZoneAbbr;\n      \
proto.zoneName = getZoneName;\n      proto.dates = deprecate(\n        \
\"dates accessor is deprecated. Use date instead.\",\n        \
getSetDayOfMonth\n      );\n      proto.months = deprecate(\n        \"months \
accessor is deprecated. Use month instead\",\n        getSetMonth\n      );\n \
     proto.years = deprecate(\n        \"years accessor is deprecated. Use \
year instead\",\n        getSetYear\n      );\n      proto.zone = \
deprecate(\n        \"moment().zone is deprecated, use moment().utcOffset \
instead. http://momentjs.com/guides/#/warnings/zone/\",\n        getSetZone\n \
     );\n      proto.isDSTShifted = deprecate(\n        \"isDSTShifted is \
deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more \
information\",\n        isDaylightSavingTimeShifted\n      );\n      function \
createUnix(input) {\n        return createLocal(input * 1e3);\n      }\n      \
function createInZone() {\n        return createLocal.apply(null, \
arguments).parseZone();\n      }\n      function preParsePostFormat(string) \
{\n        return string;\n      }\n      var proto$1 = Locale.prototype;\n   \
   proto$1.calendar = calendar;\n      proto$1.longDateFormat = \
longDateFormat;\n      proto$1.invalidDate = invalidDate;\n      \
proto$1.ordinal = ordinal;\n      proto$1.preparse = preParsePostFormat;\n    \
  proto$1.postformat = preParsePostFormat;\n      proto$1.relativeTime = \
relativeTime;\n      proto$1.pastFuture = pastFuture;\n      proto$1.set = \
set;\n      proto$1.eras = localeEras;\n      proto$1.erasParse = \
localeErasParse;\n      proto$1.erasConvertYear = localeErasConvertYear;\n    \
  proto$1.erasAbbrRegex = erasAbbrRegex;\n      proto$1.erasNameRegex = \
erasNameRegex;\n      proto$1.erasNarrowRegex = erasNarrowRegex;\n      \
proto$1.months = localeMonths;\n      proto$1.monthsShort = \
localeMonthsShort;\n      proto$1.monthsParse = localeMonthsParse;\n      \
proto$1.monthsRegex = monthsRegex;\n      proto$1.monthsShortRegex = \
monthsShortRegex;\n      proto$1.week = localeWeek;\n      \
proto$1.firstDayOfYear = localeFirstDayOfYear;\n      proto$1.firstDayOfWeek \
= localeFirstDayOfWeek;\n      proto$1.weekdays = localeWeekdays;\n      \
proto$1.weekdaysMin = localeWeekdaysMin;\n      proto$1.weekdaysShort = \
localeWeekdaysShort;\n      proto$1.weekdaysParse = localeWeekdaysParse;\n    \
  proto$1.weekdaysRegex = weekdaysRegex;\n      proto$1.weekdaysShortRegex = \
weekdaysShortRegex;\n      proto$1.weekdaysMinRegex = weekdaysMinRegex;\n     \
 proto$1.isPM = localeIsPM;\n      proto$1.meridiem = localeMeridiem;\n      \
function get$1(format2, index2, field, setter) {\n        var locale2 = \
getLocale(), utc = createUTC().set(setter, index2);\n        return \
locale2[field](utc, format2);\n      }\n      function \
listMonthsImpl(format2, index2, field) {\n        if (isNumber(format2)) {\n  \
        index2 = format2;\n          format2 = void 0;\n        }\n        \
format2 = format2 || \"\";\n        if (index2 != null) {\n          return \
get$1(format2, index2, field, \"month\");\n        }\n        var i, out = \
[];\n        for (i = 0; i < 12; i++) {\n          out[i] = get$1(format2, i, \
field, \"month\");\n        }\n        return out;\n      }\n      function \
listWeekdaysImpl(localeSorted, format2, index2, field) {\n        if (typeof \
localeSorted === \"boolean\") {\n          if (isNumber(format2)) {\n         \
   index2 = format2;\n            format2 = void 0;\n          }\n          \
format2 = format2 || \"\";\n        } else {\n          format2 = \
localeSorted;\n          index2 = format2;\n          localeSorted = false;\n \
         if (isNumber(format2)) {\n            index2 = format2;\n            \
format2 = void 0;\n          }\n          format2 = format2 || \"\";\n        \
}\n        var locale2 = getLocale(), shift2 = localeSorted ? \
locale2._week.dow : 0, i, out = [];\n        if (index2 != null) {\n          \
return get$1(format2, (index2 + shift2) % 7, field, \"day\");\n        }\n    \
    for (i = 0; i < 7; i++) {\n          out[i] = get$1(format2, (i + shift2) \
% 7, field, \"day\");\n        }\n        return out;\n      }\n      \
function listMonths(format2, index2) {\n        return \
listMonthsImpl(format2, index2, \"months\");\n      }\n      function \
listMonthsShort(format2, index2) {\n        return listMonthsImpl(format2, \
index2, \"monthsShort\");\n      }\n      function listWeekdays(localeSorted, \
format2, index2) {\n        return listWeekdaysImpl(localeSorted, format2, \
index2, \"weekdays\");\n      }\n      function \
listWeekdaysShort(localeSorted, format2, index2) {\n        return \
listWeekdaysImpl(localeSorted, format2, index2, \"weekdaysShort\");\n      \
}\n      function listWeekdaysMin(localeSorted, format2, index2) {\n        \
return listWeekdaysImpl(localeSorted, format2, index2, \"weekdaysMin\");\n    \
  }\n      getSetGlobalLocale(\"en\", {\n        eras: [\n          {\n       \
     since: \"0001-01-01\",\n            until: Infinity,\n            \
offset: 1,\n            name: \"Anno Domini\",\n            narrow: \"AD\",\n \
           abbr: \"AD\"\n          },\n          {\n            since: \
\"0000-12-31\",\n            until: -Infinity,\n            offset: 1,\n      \
      name: \"Before Christ\",\n            narrow: \"BC\",\n            \
abbr: \"BC\"\n          }\n        ],\n        dayOfMonthOrdinalParse: \
/\\d{1,2}(th|st|nd|rd)/,\n        ordinal: function(number) {\n          var \
b = number % 10, output = toInt(number % 100 / 10) === 1 ? \"th\" : b === 1 ? \
\"st\" : b === 2 ? \"nd\" : b === 3 ? \"rd\" : \"th\";\n          return \
number + output;\n        }\n      });\n      hooks.lang = deprecate(\n       \
 \"moment.lang is deprecated. Use moment.locale instead.\",\n        \
getSetGlobalLocale\n      );\n      hooks.langData = deprecate(\n        \
\"moment.langData is deprecated. Use moment.localeData instead.\",\n        \
getLocale\n      );\n      var mathAbs = Math.abs;\n      function abs() {\n  \
      var data2 = this._data;\n        this._milliseconds = \
mathAbs(this._milliseconds);\n        this._days = mathAbs(this._days);\n     \
   this._months = mathAbs(this._months);\n        data2.milliseconds = \
mathAbs(data2.milliseconds);\n        data2.seconds = \
mathAbs(data2.seconds);\n        data2.minutes = mathAbs(data2.minutes);\n    \
    data2.hours = mathAbs(data2.hours);\n        data2.months = \
mathAbs(data2.months);\n        data2.years = mathAbs(data2.years);\n        \
return this;\n      }\n      function addSubtract$1(duration, input, value, \
direction) {\n        var other = createDuration(input, value);\n        \
duration._milliseconds += direction * other._milliseconds;\n        \
duration._days += direction * other._days;\n        duration._months += \
direction * other._months;\n        return duration._bubble();\n      }\n     \
 function add$1(input, value) {\n        return addSubtract$1(this, input, \
value, 1);\n      }\n      function subtract$1(input, value) {\n        \
return addSubtract$1(this, input, value, -1);\n      }\n      function \
absCeil(number) {\n        if (number < 0) {\n          return \
Math.floor(number);\n        } else {\n          return Math.ceil(number);\n  \
      }\n      }\n      function bubble() {\n        var milliseconds2 = \
this._milliseconds, days2 = this._days, months2 = this._months, data2 = \
this._data, seconds2, minutes2, hours2, years2, monthsFromDays;\n        if \
(!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && \
days2 <= 0 && months2 <= 0)) {\n          milliseconds2 += \
absCeil(monthsToDays(months2) + days2) * 864e5;\n          days2 = 0;\n       \
   months2 = 0;\n        }\n        data2.milliseconds = milliseconds2 % \
1e3;\n        seconds2 = absFloor(milliseconds2 / 1e3);\n        \
data2.seconds = seconds2 % 60;\n        minutes2 = absFloor(seconds2 / 60);\n \
       data2.minutes = minutes2 % 60;\n        hours2 = absFloor(minutes2 / \
60);\n        data2.hours = hours2 % 24;\n        days2 += absFloor(hours2 / \
24);\n        monthsFromDays = absFloor(daysToMonths(days2));\n        \
months2 += monthsFromDays;\n        days2 -= \
absCeil(monthsToDays(monthsFromDays));\n        years2 = absFloor(months2 / \
12);\n        months2 %= 12;\n        data2.days = days2;\n        \
data2.months = months2;\n        data2.years = years2;\n        return \
this;\n      }\n      function daysToMonths(days2) {\n        return days2 * \
4800 / 146097;\n      }\n      function monthsToDays(months2) {\n        \
return months2 * 146097 / 4800;\n      }\n      function as(units) {\n        \
if (!this.isValid()) {\n          return NaN;\n        }\n        var days2, \
months2, milliseconds2 = this._milliseconds;\n        units = \
normalizeUnits(units);\n        if (units === \"month\" || units === \
\"quarter\" || units === \"year\") {\n          days2 = this._days + \
milliseconds2 / 864e5;\n          months2 = this._months + \
daysToMonths(days2);\n          switch (units) {\n            case \
\"month\":\n              return months2;\n            case \"quarter\":\n    \
          return months2 / 3;\n            case \"year\":\n              \
return months2 / 12;\n          }\n        } else {\n          days2 = \
this._days + Math.round(monthsToDays(this._months));\n          switch \
(units) {\n            case \"week\":\n              return days2 / 7 + \
milliseconds2 / 6048e5;\n            case \"day\":\n              return \
days2 + milliseconds2 / 864e5;\n            case \"hour\":\n              \
return days2 * 24 + milliseconds2 / 36e5;\n            case \"minute\":\n     \
         return days2 * 1440 + milliseconds2 / 6e4;\n            case \
\"second\":\n              return days2 * 86400 + milliseconds2 / 1e3;\n      \
      case \"millisecond\":\n              return Math.floor(days2 * 864e5) + \
milliseconds2;\n            default:\n              throw new Error(\"Unknown \
unit \" + units);\n          }\n        }\n      }\n      function \
valueOf$1() {\n        if (!this.isValid()) {\n          return NaN;\n        \
}\n        return this._milliseconds + this._days * 864e5 + this._months % 12 \
* 2592e6 + toInt(this._months / 12) * 31536e6;\n      }\n      function \
makeAs(alias) {\n        return function() {\n          return \
this.as(alias);\n        };\n      }\n      var asMilliseconds = \
makeAs(\"ms\"), asSeconds = makeAs(\"s\"), asMinutes = makeAs(\"m\"), asHours \
= makeAs(\"h\"), asDays = makeAs(\"d\"), asWeeks = makeAs(\"w\"), asMonths = \
makeAs(\"M\"), asQuarters = makeAs(\"Q\"), asYears = makeAs(\"y\");\n      \
function clone$1() {\n        return createDuration(this);\n      }\n      \
function get$2(units) {\n        units = normalizeUnits(units);\n        \
return this.isValid() ? this[units + \"s\"]() : NaN;\n      }\n      function \
makeGetter(name) {\n        return function() {\n          return \
this.isValid() ? this._data[name] : NaN;\n        };\n      }\n      var \
milliseconds = makeGetter(\"milliseconds\"), seconds = \
makeGetter(\"seconds\"), minutes = makeGetter(\"minutes\"), hours = \
makeGetter(\"hours\"), days = makeGetter(\"days\"), months = \
makeGetter(\"months\"), years = makeGetter(\"years\");\n      function \
weeks() {\n        return absFloor(this.days() / 7);\n      }\n      var \
round = Math.round, thresholds = {\n        ss: 44,\n        // a few seconds \
to seconds\n        s: 45,\n        // seconds to minute\n        m: 45,\n    \
    // minutes to hour\n        h: 22,\n        // hours to day\n        d: \
26,\n        // days to month/week\n        w: null,\n        // weeks to \
month\n        M: 11\n        // months to year\n      };\n      function \
substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {\n       \
 return locale2.relativeTime(number || 1, !!withoutSuffix, string, \
isFuture);\n      }\n      function relativeTime$1(posNegDuration, \
withoutSuffix, thresholds2, locale2) {\n        var duration = \
createDuration(posNegDuration).abs(), seconds2 = round(duration.as(\"s\")), \
minutes2 = round(duration.as(\"m\")), hours2 = round(duration.as(\"h\")), \
days2 = round(duration.as(\"d\")), months2 = round(duration.as(\"M\")), \
weeks2 = round(duration.as(\"w\")), years2 = round(duration.as(\"y\")), a = \
seconds2 <= thresholds2.ss && [\"s\", seconds2] || seconds2 < thresholds2.s \
&& [\"ss\", seconds2] || minutes2 <= 1 && [\"m\"] || minutes2 < thresholds2.m \
&& [\"mm\", minutes2] || hours2 <= 1 && [\"h\"] || hours2 < thresholds2.h && \
[\"hh\", hours2] || days2 <= 1 && [\"d\"] || days2 < thresholds2.d && \
[\"dd\", days2];\n        if (thresholds2.w != null) {\n          a = a || \
weeks2 <= 1 && [\"w\"] || weeks2 < thresholds2.w && [\"ww\", weeks2];\n       \
 }\n        a = a || months2 <= 1 && [\"M\"] || months2 < thresholds2.M && \
[\"MM\", months2] || years2 <= 1 && [\"y\"] || [\"yy\", years2];\n        \
a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = \
locale2;\n        return substituteTimeAgo.apply(null, a);\n      }\n      \
function getSetRelativeTimeRounding(roundingFunction) {\n        if \
(roundingFunction === void 0) {\n          return round;\n        }\n        \
if (typeof roundingFunction === \"function\") {\n          round = \
roundingFunction;\n          return true;\n        }\n        return false;\n \
     }\n      function getSetRelativeTimeThreshold(threshold, limit) {\n      \
  if (thresholds[threshold] === void 0) {\n          return false;\n        \
}\n        if (limit === void 0) {\n          return thresholds[threshold];\n \
       }\n        thresholds[threshold] = limit;\n        if (threshold === \
\"s\") {\n          thresholds.ss = limit - 1;\n        }\n        return \
true;\n      }\n      function humanize(argWithSuffix, argThresholds) {\n     \
   if (!this.isValid()) {\n          return \
this.localeData().invalidDate();\n        }\n        var withSuffix = false, \
th = thresholds, locale2, output;\n        if (typeof argWithSuffix === \
\"object\") {\n          argThresholds = argWithSuffix;\n          \
argWithSuffix = false;\n        }\n        if (typeof argWithSuffix === \
\"boolean\") {\n          withSuffix = argWithSuffix;\n        }\n        if \
(typeof argThresholds === \"object\") {\n          th = Object.assign({}, \
thresholds, argThresholds);\n          if (argThresholds.s != null && \
argThresholds.ss == null) {\n            th.ss = argThresholds.s - 1;\n       \
   }\n        }\n        locale2 = this.localeData();\n        output = \
relativeTime$1(this, !withSuffix, th, locale2);\n        if (withSuffix) {\n  \
        output = locale2.pastFuture(+this, output);\n        }\n        \
return locale2.postformat(output);\n      }\n      var abs$1 = Math.abs;\n    \
  function sign(x) {\n        return (x > 0) - (x < 0) || +x;\n      }\n      \
function toISOString$1() {\n        if (!this.isValid()) {\n          return \
this.localeData().invalidDate();\n        }\n        var seconds2 = \
abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = \
abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), \
totalSign, ymSign, daysSign, hmsSign;\n        if (!total) {\n          \
return \"P0D\";\n        }\n        minutes2 = absFloor(seconds2 / 60);\n     \
   hours2 = absFloor(minutes2 / 60);\n        seconds2 %= 60;\n        \
minutes2 %= 60;\n        years2 = absFloor(months2 / 12);\n        months2 %= \
12;\n        s = seconds2 ? seconds2.toFixed(3).replace(/\\.?0+$/, \"\") : \
\"\";\n        totalSign = total < 0 ? \"-\" : \"\";\n        ymSign = \
sign(this._months) !== sign(total) ? \"-\" : \"\";\n        daysSign = \
sign(this._days) !== sign(total) ? \"-\" : \"\";\n        hmsSign = \
sign(this._milliseconds) !== sign(total) ? \"-\" : \"\";\n        return \
totalSign + \"P\" + (years2 ? ymSign + years2 + \"Y\" : \"\") + (months2 ? \
ymSign + months2 + \"M\" : \"\") + (days2 ? daysSign + days2 + \"D\" : \"\") \
+ (hours2 || minutes2 || seconds2 ? \"T\" : \"\") + (hours2 ? hmsSign + \
hours2 + \"H\" : \"\") + (minutes2 ? hmsSign + minutes2 + \"M\" : \"\") + \
(seconds2 ? hmsSign + s + \"S\" : \"\");\n      }\n      var proto$2 = \
Duration.prototype;\n      proto$2.isValid = isValid$1;\n      proto$2.abs = \
abs;\n      proto$2.add = add$1;\n      proto$2.subtract = subtract$1;\n      \
proto$2.as = as;\n      proto$2.asMilliseconds = asMilliseconds;\n      \
proto$2.asSeconds = asSeconds;\n      proto$2.asMinutes = asMinutes;\n      \
proto$2.asHours = asHours;\n      proto$2.asDays = asDays;\n      \
proto$2.asWeeks = asWeeks;\n      proto$2.asMonths = asMonths;\n      \
proto$2.asQuarters = asQuarters;\n      proto$2.asYears = asYears;\n      \
proto$2.valueOf = valueOf$1;\n      proto$2._bubble = bubble;\n      \
proto$2.clone = clone$1;\n      proto$2.get = get$2;\n      \
proto$2.milliseconds = milliseconds;\n      proto$2.seconds = seconds;\n      \
proto$2.minutes = minutes;\n      proto$2.hours = hours;\n      proto$2.days \
= days;\n      proto$2.weeks = weeks;\n      proto$2.months = months;\n      \
proto$2.years = years;\n      proto$2.humanize = humanize;\n      \
proto$2.toISOString = toISOString$1;\n      proto$2.toString = \
toISOString$1;\n      proto$2.toJSON = toISOString$1;\n      proto$2.locale = \
locale;\n      proto$2.localeData = localeData;\n      proto$2.toIsoString = \
deprecate(\n        \"toIsoString() is deprecated. Please use toISOString() \
instead (notice the capitals)\",\n        toISOString$1\n      );\n      \
proto$2.lang = lang;\n      addFormatToken(\"X\", 0, 0, \"unix\");\n      \
addFormatToken(\"x\", 0, 0, \"valueOf\");\n      addRegexToken(\"x\", \
matchSigned);\n      addRegexToken(\"X\", matchTimestamp);\n      \
addParseToken(\"X\", function(input, array, config) {\n        config._d = \
new Date(parseFloat(input) * 1e3);\n      });\n      addParseToken(\"x\", \
function(input, array, config) {\n        config._d = new \
Date(toInt(input));\n      });\n      hooks.version = \"2.29.4\";\n      \
setHookCallback(createLocal);\n      hooks.fn = proto;\n      hooks.min = \
min;\n      hooks.max = max;\n      hooks.now = now;\n      hooks.utc = \
createUTC;\n      hooks.unix = createUnix;\n      hooks.months = \
listMonths;\n      hooks.isDate = isDate2;\n      hooks.locale = \
getSetGlobalLocale;\n      hooks.invalid = createInvalid;\n      \
hooks.duration = createDuration;\n      hooks.isMoment = isMoment;\n      \
hooks.weekdays = listWeekdays;\n      hooks.parseZone = createInZone;\n      \
hooks.localeData = getLocale;\n      hooks.isDuration = isDuration;\n      \
hooks.monthsShort = listMonthsShort;\n      hooks.weekdaysMin = \
listWeekdaysMin;\n      hooks.defineLocale = defineLocale;\n      \
hooks.updateLocale = updateLocale;\n      hooks.locales = listLocales;\n      \
hooks.weekdaysShort = listWeekdaysShort;\n      hooks.normalizeUnits = \
normalizeUnits;\n      hooks.relativeTimeRounding = \
getSetRelativeTimeRounding;\n      hooks.relativeTimeThreshold = \
getSetRelativeTimeThreshold;\n      hooks.calendarFormat = \
getCalendarFormat;\n      hooks.prototype = proto;\n      hooks.HTML5_FMT = \
{\n        DATETIME_LOCAL: \"YYYY-MM-DDTHH:mm\",\n        // <input \
type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: \
\"YYYY-MM-DDTHH:mm:ss\",\n        // <input type=\"datetime-local\" \
step=\"1\" />\n        DATETIME_LOCAL_MS: \"YYYY-MM-DDTHH:mm:ss.SSS\",\n      \
  // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: \
\"YYYY-MM-DD\",\n        // <input type=\"date\" />\n        TIME: \
\"HH:mm\",\n        // <input type=\"time\" />\n        TIME_SECONDS: \
\"HH:mm:ss\",\n        // <input type=\"time\" step=\"1\" />\n        \
TIME_MS: \"HH:mm:ss.SSS\",\n        // <input type=\"time\" step=\"0.001\" \
/>\n        WEEK: \"GGGG-[W]WW\",\n        // <input type=\"week\" />\n       \
 MONTH: \"YYYY-MM\"\n        // <input type=\"month\" />\n      };\n      \
return hooks;\n    });\n  }\n});\n\n// \
node_modules/core-js/internals/get-json-replacer-function.js\nvar \
require_get_json_replacer_function = __commonJS({\n  \
\"node_modules/core-js/internals/get-json-replacer-function.js\"(exports, \
module2) {\n    \"use strict\";\n    var uncurryThis2 = \
require_function_uncurry_this();\n    var isArray = require_is_array();\n    \
var isCallable2 = require_is_callable();\n    var classof = \
require_classof_raw();\n    var toString = require_to_string();\n    var \
push2 = uncurryThis2([].push);\n    module2.exports = function(replacer) {\n  \
    if (isCallable2(replacer))\n        return replacer;\n      if \
(!isArray(replacer))\n        return;\n      var rawLength = \
replacer.length;\n      var keys = [];\n      for (var i = 0; i < rawLength; \
i++) {\n        var element = replacer[i];\n        if (typeof element == \
\"string\")\n          push2(keys, element);\n        else if (typeof element \
== \"number\" || classof(element) === \"Number\" || classof(element) === \
\"String\")\n          push2(keys, toString(element));\n      }\n      var \
keysLength = keys.length;\n      var root = true;\n      return function(key, \
value) {\n        if (root) {\n          root = false;\n          return \
value;\n        }\n        if (isArray(this))\n          return value;\n      \
  for (var j = 0; j < keysLength; j++)\n          if (keys[j] === key)\n      \
      return value;\n      };\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/object-keys.js\nvar require_object_keys = \
__commonJS({\n  \"node_modules/core-js/internals/object-keys.js\"(exports, \
module2) {\n    \"use strict\";\n    var internalObjectKeys = \
require_object_keys_internal();\n    var enumBugKeys = \
require_enum_bug_keys();\n    module2.exports = Object.keys || function \
keys(O) {\n      return internalObjectKeys(O, enumBugKeys);\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/object-define-properties.js\nvar \
require_object_define_properties = __commonJS({\n  \
\"node_modules/core-js/internals/object-define-properties.js\"(exports) {\n   \
 \"use strict\";\n    var DESCRIPTORS = require_descriptors();\n    var \
V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();\n    var \
definePropertyModule = require_object_define_property();\n    var anObject = \
require_an_object();\n    var toIndexedObject = \
require_to_indexed_object();\n    var objectKeys = require_object_keys();\n   \
 exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? \
Object.defineProperties : function defineProperties(O, Properties) {\n      \
anObject(O);\n      var props = toIndexedObject(Properties);\n      var keys \
= objectKeys(Properties);\n      var length = keys.length;\n      var index2 \
= 0;\n      var key;\n      while (length > index2)\n        \
definePropertyModule.f(O, key = keys[index2++], props[key]);\n      return \
O;\n    };\n  }\n});\n\n// \
node_modules/core-js/internals/object-create.js\nvar require_object_create = \
__commonJS({\n  \"node_modules/core-js/internals/object-create.js\"(exports, \
module2) {\n    \"use strict\";\n    var anObject = require_an_object();\n    \
var definePropertiesModule = require_object_define_properties();\n    var \
enumBugKeys = require_enum_bug_keys();\n    var hiddenKeys = \
require_hidden_keys();\n    var html = require_html();\n    var \
documentCreateElement = require_document_create_element();\n    var sharedKey \
= require_shared_key();\n    var GT = \">\";\n    var LT = \"<\";\n    var \
PROTOTYPE = \"prototype\";\n    var SCRIPT = \"script\";\n    var IE_PROTO = \
sharedKey(\"IE_PROTO\");\n    var EmptyConstructor = function() {\n    };\n   \
 var scriptTag = function(content) {\n      return LT + SCRIPT + GT + content \
+ LT + \"/\" + SCRIPT + GT;\n    };\n    var NullProtoObjectViaActiveX = \
function(activeXDocument2) {\n      \
activeXDocument2.write(scriptTag(\"\"));\n      activeXDocument2.close();\n   \
   var temp = activeXDocument2.parentWindow.Object;\n      activeXDocument2 = \
null;\n      return temp;\n    };\n    var NullProtoObjectViaIFrame = \
function() {\n      var iframe = documentCreateElement(\"iframe\");\n      \
var JS = \"java\" + SCRIPT + \":\";\n      var iframeDocument;\n      \
iframe.style.display = \"none\";\n      html.appendChild(iframe);\n      \
iframe.src = String(JS);\n      iframeDocument = \
iframe.contentWindow.document;\n      iframeDocument.open();\n      \
iframeDocument.write(scriptTag(\"document.F=Object\"));\n      \
iframeDocument.close();\n      return iframeDocument.F;\n    };\n    var \
activeXDocument;\n    var NullProtoObject = function() {\n      try {\n       \
 activeXDocument = new ActiveXObject(\"htmlfile\");\n      } catch (error2) \
{\n      }\n      NullProtoObject = typeof document != \"undefined\" ? \
document.domain && activeXDocument ? \
NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : \
NullProtoObjectViaActiveX(activeXDocument);\n      var length = \
enumBugKeys.length;\n      while (length--)\n        delete \
NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n      return \
NullProtoObject();\n    };\n    hiddenKeys[IE_PROTO] = true;\n    \
module2.exports = Object.create || function create(O, Properties) {\n      \
var result;\n      if (O !== null) {\n        EmptyConstructor[PROTOTYPE] = \
anObject(O);\n        result = new EmptyConstructor();\n        \
EmptyConstructor[PROTOTYPE] = null;\n        result[IE_PROTO] = O;\n      } \
else\n        result = NullProtoObject();\n      return Properties === void 0 \
? result : definePropertiesModule.f(result, Properties);\n    };\n  \
}\n});\n\n// node_modules/core-js/internals/add-to-unscopables.js\nvar \
require_add_to_unscopables = __commonJS({\n  \
\"node_modules/core-js/internals/add-to-unscopables.js\"(exports, module2) \
{\n    \"use strict\";\n    var wellKnownSymbol = \
require_well_known_symbol();\n    var create = require_object_create();\n    \
var defineProperty = require_object_define_property().f;\n    var UNSCOPABLES \
= wellKnownSymbol(\"unscopables\");\n    var ArrayPrototype = \
Array.prototype;\n    if (ArrayPrototype[UNSCOPABLES] === void 0) {\n      \
defineProperty(ArrayPrototype, UNSCOPABLES, {\n        configurable: true,\n  \
      value: create(null)\n      });\n    }\n    module2.exports = \
function(key) {\n      ArrayPrototype[UNSCOPABLES][key] = true;\n    };\n  \
}\n});\n\n// node_modules/pikaday/pikaday.js\nvar require_pikaday = \
__commonJS({\n  \"node_modules/pikaday/pikaday.js\"(exports, module2) {\n    \
(function(root, factory) {\n      \"use strict\";\n      var moment12;\n      \
if (typeof exports === \"object\") {\n        try {\n          moment12 = \
require_moment();\n        } catch (e) {\n        }\n        module2.exports \
= factory(moment12);\n      } else if (typeof define === \"function\" && \
define.amd) {\n        define(function(req) {\n          var id = \
\"moment\";\n          try {\n            moment12 = req(id);\n          } \
catch (e) {\n          }\n          return factory(moment12);\n        });\n  \
    } else {\n        root.Pikaday = factory(root.moment);\n      }\n    \
})(exports, function(moment12) {\n      \"use strict\";\n      var hasMoment \
= typeof moment12 === \"function\", hasEventListeners = \
!!window.addEventListener, document2 = window.document, sto = \
window.setTimeout, addEvent2 = function(el, e, callback, capture) {\n        \
if (hasEventListeners) {\n          el.addEventListener(e, callback, \
!!capture);\n        } else {\n          el.attachEvent(\"on\" + e, \
callback);\n        }\n      }, removeEvent2 = function(el, e, callback, \
capture) {\n        if (hasEventListeners) {\n          \
el.removeEventListener(e, callback, !!capture);\n        } else {\n          \
el.detachEvent(\"on\" + e, callback);\n        }\n      }, trim = \
function(str) {\n        return str.trim ? str.trim() : \
str.replace(/^\\s+|\\s+$/g, \"\");\n      }, hasClass2 = function(el, cn) {\n \
       return (\" \" + el.className + \" \").indexOf(\" \" + cn + \" \") !== \
-1;\n      }, addClass2 = function(el, cn) {\n        if (!hasClass2(el, cn)) \
{\n          el.className = el.className === \"\" ? cn : el.className + \" \" \
+ cn;\n        }\n      }, removeClass2 = function(el, cn) {\n        \
el.className = trim((\" \" + el.className + \" \").replace(\" \" + cn + \" \
\", \" \"));\n      }, isArray = function(obj) {\n        return \
/Array/.test(Object.prototype.toString.call(obj));\n      }, isDate2 = \
function(obj) {\n        return \
/Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());\n  \
    }, isWeekend = function(date) {\n        var day = date.getDay();\n       \
 return day === 0 || day === 6;\n      }, isLeapYear = function(year) {\n     \
   return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n      }, \
getDaysInMonth = function(year, month) {\n        return [31, \
isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n \
     }, setToStartOfDay = function(date) {\n        if (isDate2(date))\n      \
    date.setHours(0, 0, 0, 0);\n      }, compareDates = function(a, b) {\n    \
    return a.getTime() === b.getTime();\n      }, extend2 = function(to, \
from, overwrite) {\n        var prop, hasProp;\n        for (prop in from) \
{\n          hasProp = to[prop] !== void 0;\n          if (hasProp && typeof \
from[prop] === \"object\" && from[prop] !== null && from[prop].nodeName === \
void 0) {\n            if (isDate2(from[prop])) {\n              if \
(overwrite) {\n                to[prop] = new Date(from[prop].getTime());\n   \
           }\n            } else if (isArray(from[prop])) {\n              if \
(overwrite) {\n                to[prop] = from[prop].slice(0);\n              \
}\n            } else {\n              to[prop] = extend2({}, from[prop], \
overwrite);\n            }\n          } else if (overwrite || !hasProp) {\n   \
         to[prop] = from[prop];\n          }\n        }\n        return to;\n \
     }, fireEvent = function(el, eventName, data2) {\n        var ev;\n       \
 if (document2.createEvent) {\n          ev = \
document2.createEvent(\"HTMLEvents\");\n          ev.initEvent(eventName, \
true, false);\n          ev = extend2(ev, data2);\n          \
el.dispatchEvent(ev);\n        } else if (document2.createEventObject) {\n    \
      ev = document2.createEventObject();\n          ev = extend2(ev, \
data2);\n          el.fireEvent(\"on\" + eventName, ev);\n        }\n      }, \
adjustCalendar = function(calendar) {\n        if (calendar.month < 0) {\n    \
      calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);\n          \
calendar.month += 12;\n        }\n        if (calendar.month > 11) {\n        \
  calendar.year += Math.floor(Math.abs(calendar.month) / 12);\n          \
calendar.month -= 12;\n        }\n        return calendar;\n      }, defaults \
= {\n        // bind the picker to a form field\n        field: null,\n       \
 // automatically show/hide the picker on `field` focus (default `true` if \
`field` is set)\n        bound: void 0,\n        // data-attribute on the \
input field with an aria assistance text (only applied when `bound` is set)\n \
       ariaLabel: \"Use the arrow keys to pick a date\",\n        // position \
of the datepicker, relative to the field (default to bottom & left)\n        \
// ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on \
the bottom/left position)\n        position: \"bottom left\",\n        // \
automatically fit in the viewport even if it means repositioning from the \
position option\n        reposition: true,\n        // the default output \
format for `.toString()` and `field` value\n        format: \"YYYY-MM-DD\",\n \
       // the toString function which gets passed a current date object and \
format\n        // and returns a string\n        toString: null,\n        // \
used to create date object from current input string\n        parse: null,\n  \
      // the initial date to view when first opened\n        defaultDate: \
null,\n        // make the `defaultDate` the initial selected value\n        \
setDefaultDate: false,\n        // first day of week (0: Sunday, 1: Monday \
etc)\n        firstDay: 0,\n        // minimum number of days in the week \
that gets week number one\n        // default ISO 8601, week 01 is the week \
with the first Thursday (4)\n        firstWeekOfYearMinDays: 4,\n        // \
the default flag for moment's strict date parsing\n        formatStrict: \
false,\n        // the minimum/earliest date that can be selected\n        \
minDate: null,\n        // the maximum/latest date that can be selected\n     \
   maxDate: null,\n        // number of years either side, or array of \
upper/lower range\n        yearRange: 10,\n        // show week numbers at \
head of row\n        showWeekNumber: false,\n        // Week picker mode\n    \
    pickWholeWeek: false,\n        // used internally (don't config \
outside)\n        minYear: 0,\n        maxYear: 9999,\n        minMonth: void \
0,\n        maxMonth: void 0,\n        startRange: null,\n        endRange: \
null,\n        isRTL: false,\n        // Additional text to append to the \
year in the calendar title\n        yearSuffix: \"\",\n        // Render the \
month after year in the calendar title\n        showMonthAfterYear: false,\n  \
      // Render days of the calendar grid that fall in the next or previous \
month\n        showDaysInNextAndPreviousMonths: false,\n        // Allows \
user to select days that fall in the next or previous month\n        \
enableSelectionDaysInNextAndPreviousMonths: false,\n        // how many \
months are visible\n        numberOfMonths: 1,\n        // when \
numberOfMonths is used, this will help you to choose where the main calendar \
will be (default `left`, can be set to `right`)\n        // only used for the \
first display or when a selected date is not visible\n        mainCalendar: \
\"left\",\n        // Specify a DOM element to render the calendar in\n       \
 container: void 0,\n        // Blur field when date is selected\n        \
blurFieldOnSelect: true,\n        // internationalization\n        i18n: {\n  \
        previousMonth: \"Previous Month\",\n          nextMonth: \"Next \
Month\",\n          months: [\"January\", \"February\", \"March\", \"April\", \
\"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \
\"November\", \"December\"],\n          weekdays: [\"Sunday\", \"Monday\", \
\"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n        \
  weekdaysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \
\"Sat\"]\n        },\n        // Theme Classname\n        theme: null,\n      \
  // events array\n        events: [],\n        // callback function\n        \
onSelect: null,\n        onOpen: null,\n        onClose: null,\n        \
onDraw: null,\n        // Enable keyboard input\n        keyboardInput: \
true\n      }, renderDayName = function(opts, day, abbr) {\n        day += \
opts.firstDay;\n        while (day >= 7) {\n          day -= 7;\n        }\n  \
      return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];\n \
     }, renderDay = function(opts) {\n        var arr = [];\n        var \
ariaSelected = \"false\";\n        if (opts.isEmpty) {\n          if \
(opts.showDaysInNextAndPreviousMonths) {\n            \
arr.push(\"is-outside-current-month\");\n            if \
(!opts.enableSelectionDaysInNextAndPreviousMonths) {\n              \
arr.push(\"is-selection-disabled\");\n            }\n          } else {\n     \
       return '<td class=\"is-empty\"></td>';\n          }\n        }\n       \
 if (opts.isDisabled) {\n          arr.push(\"is-disabled\");\n        }\n    \
    if (opts.isToday) {\n          arr.push(\"is-today\");\n        }\n       \
 if (opts.isSelected) {\n          arr.push(\"is-selected\");\n          \
ariaSelected = \"true\";\n        }\n        if (opts.hasEvent) {\n          \
arr.push(\"has-event\");\n        }\n        if (opts.isInRange) {\n          \
arr.push(\"is-inrange\");\n        }\n        if (opts.isStartRange) {\n      \
    arr.push(\"is-startrange\");\n        }\n        if (opts.isEndRange) {\n \
         arr.push(\"is-endrange\");\n        }\n        return '<td \
data-day=\"' + opts.day + '\" class=\"' + arr.join(\" \") + '\" \
aria-selected=\"' + ariaSelected + '\"><button class=\"pika-button pika-day\" \
type=\"button\" data-pika-year=\"' + opts.year + '\" data-pika-month=\"' + \
opts.month + '\" data-pika-day=\"' + opts.day + '\">' + opts.day + \
\"</button></td>\";\n      }, isoWeek = function(date, \
firstWeekOfYearMinDays) {\n        date.setHours(0, 0, 0, 0);\n        var \
yearDay = date.getDate(), weekDay = date.getDay(), dayInFirstWeek = \
firstWeekOfYearMinDays, dayShift = dayInFirstWeek - 1, daysPerWeek = 7, \
prevWeekDay = function(day) {\n          return (day + daysPerWeek - 1) % \
daysPerWeek;\n        };\n        date.setDate(yearDay + dayShift - \
prevWeekDay(weekDay));\n        var jan4th = new Date(date.getFullYear(), 0, \
dayInFirstWeek), msPerDay = 24 * 60 * 60 * 1e3, daysBetween = (date.getTime() \
- jan4th.getTime()) / msPerDay, weekNum = 1 + Math.round((daysBetween - \
dayShift + prevWeekDay(jan4th.getDay())) / daysPerWeek);\n        return \
weekNum;\n      }, renderWeek = function(d, m, y, firstWeekOfYearMinDays) {\n \
       var date = new Date(y, m, d), week = hasMoment ? \
moment12(date).isoWeek() : isoWeek(date, firstWeekOfYearMinDays);\n        \
return '<td class=\"pika-week\">' + week + \"</td>\";\n      }, renderRow = \
function(days, isRTL, pickWholeWeek, isRowSelected) {\n        return '<tr \
class=\"pika-row' + (pickWholeWeek ? \" pick-whole-week\" : \"\") + \
(isRowSelected ? \" is-selected\" : \"\") + '\">' + (isRTL ? days.reverse() : \
days).join(\"\") + \"</tr>\";\n      }, renderBody = function(rows) {\n       \
 return \"<tbody>\" + rows.join(\"\") + \"</tbody>\";\n      }, renderHead = \
function(opts) {\n        var i, arr = [];\n        if (opts.showWeekNumber) \
{\n          arr.push(\"<th></th>\");\n        }\n        for (i = 0; i < 7; \
i++) {\n          arr.push('<th scope=\"col\"><abbr title=\"' + \
renderDayName(opts, i) + '\">' + renderDayName(opts, i, true) + \
\"</abbr></th>\");\n        }\n        return \"<thead><tr>\" + (opts.isRTL ? \
arr.reverse() : arr).join(\"\") + \"</tr></thead>\";\n      }, renderTitle = \
function(instance, c, year, month, refYear, randId) {\n        var i, j, arr, \
opts = instance._o, isMinYear = year === opts.minYear, isMaxYear = year === \
opts.maxYear, html = '<div id=\"' + randId + '\" class=\"pika-title\" \
role=\"heading\" aria-live=\"assertive\">', monthHtml, yearHtml, prev = true, \
next = true;\n        for (arr = [], i = 0; i < 12; i++) {\n          \
arr.push('<option value=\"' + (year === refYear ? i - c : 12 + i - c) + '\"' \
+ (i === month ? ' selected=\"selected\"' : \"\") + (isMinYear && i < \
opts.minMonth || isMaxYear && i > opts.maxMonth ? ' disabled=\"disabled\"' : \
\"\") + \">\" + opts.i18n.months[i] + \"</option>\");\n        }\n        \
monthHtml = '<div class=\"pika-label\">' + opts.i18n.months[month] + '<select \
class=\"pika-select pika-select-month\" tabindex=\"-1\">' + arr.join(\"\") + \
\"</select></div>\";\n        if (isArray(opts.yearRange)) {\n          i = \
opts.yearRange[0];\n          j = opts.yearRange[1] + 1;\n        } else {\n  \
        i = year - opts.yearRange;\n          j = 1 + year + \
opts.yearRange;\n        }\n        for (arr = []; i < j && i <= \
opts.maxYear; i++) {\n          if (i >= opts.minYear) {\n            \
arr.push('<option value=\"' + i + '\"' + (i === year ? ' \
selected=\"selected\"' : \"\") + \">\" + i + \"</option>\");\n          }\n   \
     }\n        yearHtml = '<div class=\"pika-label\">' + year + \
opts.yearSuffix + '<select class=\"pika-select pika-select-year\" \
tabindex=\"-1\">' + arr.join(\"\") + \"</select></div>\";\n        if \
(opts.showMonthAfterYear) {\n          html += yearHtml + monthHtml;\n        \
} else {\n          html += monthHtml + yearHtml;\n        }\n        if \
(isMinYear && (month === 0 || opts.minMonth >= month)) {\n          prev = \
false;\n        }\n        if (isMaxYear && (month === 11 || opts.maxMonth <= \
month)) {\n          next = false;\n        }\n        if (c === 0) {\n       \
   html += '<button class=\"pika-prev' + (prev ? \"\" : \" is-disabled\") + \
'\" type=\"button\">' + opts.i18n.previousMonth + \"</button>\";\n        }\n \
       if (c === instance._o.numberOfMonths - 1) {\n          html += \
'<button class=\"pika-next' + (next ? \"\" : \" is-disabled\") + '\" \
type=\"button\">' + opts.i18n.nextMonth + \"</button>\";\n        }\n        \
return html += \"</div>\";\n      }, renderTable = function(opts, data2, \
randId) {\n        return '<table cellpadding=\"0\" cellspacing=\"0\" \
class=\"pika-table\" role=\"grid\" aria-labelledby=\"' + randId + '\">' + \
renderHead(opts) + renderBody(data2) + \"</table>\";\n      }, Pikaday2 = \
function(options) {\n        var self2 = this, opts = \
self2.config(options);\n        self2._onMouseDown = function(e) {\n          \
if (!self2._v) {\n            return;\n          }\n          e = e || \
window.event;\n          var target = e.target || e.srcElement;\n          if \
(!target) {\n            return;\n          }\n          if \
(!hasClass2(target, \"is-disabled\")) {\n            if (hasClass2(target, \
\"pika-button\") && !hasClass2(target, \"is-empty\") && \
!hasClass2(target.parentNode, \"is-disabled\")) {\n              \
self2.setDate(new Date(target.getAttribute(\"data-pika-year\"), \
target.getAttribute(\"data-pika-month\"), \
target.getAttribute(\"data-pika-day\")));\n              if (opts.bound) {\n  \
              sto(function() {\n                  self2.hide();\n             \
     if (opts.blurFieldOnSelect && opts.field) {\n                    \
opts.field.blur();\n                  }\n                }, 100);\n           \
   }\n            } else if (hasClass2(target, \"pika-prev\")) {\n            \
  self2.prevMonth();\n            } else if (hasClass2(target, \
\"pika-next\")) {\n              self2.nextMonth();\n            }\n          \
}\n          if (!hasClass2(target, \"pika-select\")) {\n            if \
(e.preventDefault) {\n              e.preventDefault();\n            } else \
{\n              e.returnValue = false;\n              return false;\n        \
    }\n          } else {\n            self2._c = true;\n          }\n        \
};\n        self2._onChange = function(e) {\n          e = e || \
window.event;\n          var target = e.target || e.srcElement;\n          if \
(!target) {\n            return;\n          }\n          if \
(hasClass2(target, \"pika-select-month\")) {\n            \
self2.gotoMonth(target.value);\n          } else if (hasClass2(target, \
\"pika-select-year\")) {\n            self2.gotoYear(target.value);\n         \
 }\n        };\n        self2._onKeyChange = function(e) {\n          e = e \
|| window.event;\n          if (self2.isVisible()) {\n            switch \
(e.keyCode) {\n              case 13:\n              case 27:\n               \
 if (opts.field) {\n                  opts.field.blur();\n                }\n \
               break;\n              case 37:\n                \
self2.adjustDate(\"subtract\", 1);\n                break;\n              \
case 38:\n                self2.adjustDate(\"subtract\", 7);\n                \
break;\n              case 39:\n                self2.adjustDate(\"add\", \
1);\n                break;\n              case 40:\n                \
self2.adjustDate(\"add\", 7);\n                break;\n              case \
8:\n              case 46:\n                self2.setDate(null);\n            \
    break;\n            }\n          }\n        };\n        \
self2._parseFieldValue = function() {\n          if (opts.parse) {\n          \
  return opts.parse(opts.field.value, opts.format);\n          } else if \
(hasMoment) {\n            var date = moment12(opts.field.value, opts.format, \
opts.formatStrict);\n            return date && date.isValid() ? \
date.toDate() : null;\n          } else {\n            return new \
Date(Date.parse(opts.field.value));\n          }\n        };\n        \
self2._onInputChange = function(e) {\n          var date;\n          if \
(e.firedBy === self2) {\n            return;\n          }\n          date = \
self2._parseFieldValue();\n          if (isDate2(date)) {\n            \
self2.setDate(date);\n          }\n          if (!self2._v) {\n            \
self2.show();\n          }\n        };\n        self2._onInputFocus = \
function() {\n          self2.show();\n        };\n        \
self2._onInputClick = function() {\n          self2.show();\n        };\n     \
   self2._onInputBlur = function() {\n          var pEl = \
document2.activeElement;\n          do {\n            if (hasClass2(pEl, \
\"pika-single\")) {\n              return;\n            }\n          } while \
(pEl = pEl.parentNode);\n          if (!self2._c) {\n            self2._b = \
sto(function() {\n              self2.hide();\n            }, 50);\n          \
}\n          self2._c = false;\n        };\n        self2._onClick = \
function(e) {\n          e = e || window.event;\n          var target = \
e.target || e.srcElement, pEl = target;\n          if (!target) {\n           \
 return;\n          }\n          if (!hasEventListeners && hasClass2(target, \
\"pika-select\")) {\n            if (!target.onchange) {\n              \
target.setAttribute(\"onchange\", \"return;\");\n              \
addEvent2(target, \"change\", self2._onChange);\n            }\n          }\n \
         do {\n            if (hasClass2(pEl, \"pika-single\") || pEl === \
opts.trigger) {\n              return;\n            }\n          } while (pEl \
= pEl.parentNode);\n          if (self2._v && target !== opts.trigger && pEl \
!== opts.trigger) {\n            self2.hide();\n          }\n        };\n     \
   self2.el = document2.createElement(\"div\");\n        self2.el.className = \
\"pika-single\" + (opts.isRTL ? \" is-rtl\" : \"\") + (opts.theme ? \" \" + \
opts.theme : \"\");\n        addEvent2(self2.el, \"mousedown\", \
self2._onMouseDown, true);\n        addEvent2(self2.el, \"touchend\", \
self2._onMouseDown, true);\n        addEvent2(self2.el, \"change\", \
self2._onChange);\n        if (opts.keyboardInput) {\n          \
addEvent2(document2, \"keydown\", self2._onKeyChange);\n        }\n        if \
(opts.field) {\n          if (opts.container) {\n            \
opts.container.appendChild(self2.el);\n          } else if (opts.bound) {\n   \
         document2.body.appendChild(self2.el);\n          } else {\n          \
  opts.field.parentNode.insertBefore(self2.el, opts.field.nextSibling);\n     \
     }\n          addEvent2(opts.field, \"change\", self2._onInputChange);\n  \
        if (!opts.defaultDate) {\n            opts.defaultDate = \
self2._parseFieldValue();\n            opts.setDefaultDate = true;\n          \
}\n        }\n        var defDate = opts.defaultDate;\n        if \
(isDate2(defDate)) {\n          if (opts.setDefaultDate) {\n            \
self2.setDate(defDate, true);\n          } else {\n            \
self2.gotoDate(defDate);\n          }\n        } else {\n          \
self2.gotoDate(/* @__PURE__ */ new Date());\n        }\n        if \
(opts.bound) {\n          this.hide();\n          self2.el.className += \" \
is-bound\";\n          addEvent2(opts.trigger, \"click\", \
self2._onInputClick);\n          addEvent2(opts.trigger, \"focus\", \
self2._onInputFocus);\n          addEvent2(opts.trigger, \"blur\", \
self2._onInputBlur);\n        } else {\n          this.show();\n        }\n   \
   };\n      Pikaday2.prototype = {\n        /**\n         * configure \
functionality\n         */\n        config: function(options) {\n          if \
(!this._o) {\n            this._o = extend2({}, defaults, true);\n          \
}\n          var opts = extend2(this._o, options, true);\n          \
opts.isRTL = !!opts.isRTL;\n          opts.field = opts.field && \
opts.field.nodeName ? opts.field : null;\n          opts.theme = typeof \
opts.theme === \"string\" && opts.theme ? opts.theme : null;\n          \
opts.bound = !!(opts.bound !== void 0 ? opts.field && opts.bound : \
opts.field);\n          opts.trigger = opts.trigger && opts.trigger.nodeName \
? opts.trigger : opts.field;\n          opts.disableWeekends = \
!!opts.disableWeekends;\n          opts.disableDayFn = typeof \
opts.disableDayFn === \"function\" ? opts.disableDayFn : null;\n          var \
nom = parseInt(opts.numberOfMonths, 10) || 1;\n          opts.numberOfMonths \
= nom > 4 ? 4 : nom;\n          if (!isDate2(opts.minDate)) {\n            \
opts.minDate = false;\n          }\n          if (!isDate2(opts.maxDate)) {\n \
           opts.maxDate = false;\n          }\n          if (opts.minDate && \
opts.maxDate && opts.maxDate < opts.minDate) {\n            opts.maxDate = \
opts.minDate = false;\n          }\n          if (opts.minDate) {\n           \
 this.setMinDate(opts.minDate);\n          }\n          if (opts.maxDate) {\n \
           this.setMaxDate(opts.maxDate);\n          }\n          if \
(isArray(opts.yearRange)) {\n            var fallback = (/* @__PURE__ */ new \
Date()).getFullYear() - 10;\n            opts.yearRange[0] = \
parseInt(opts.yearRange[0], 10) || fallback;\n            opts.yearRange[1] = \
parseInt(opts.yearRange[1], 10) || fallback;\n          } else {\n            \
opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || \
defaults.yearRange;\n            if (opts.yearRange > 100) {\n              \
opts.yearRange = 100;\n            }\n          }\n          return opts;\n   \
     },\n        /**\n         * return a formatted string of the current \
selection (using Moment.js if available)\n         */\n        toString: \
function(format) {\n          format = format || this._o.format;\n          \
if (!isDate2(this._d)) {\n            return \"\";\n          }\n          if \
(this._o.toString) {\n            return this._o.toString(this._d, format);\n \
         }\n          if (hasMoment) {\n            return \
moment12(this._d).format(format);\n          }\n          return \
this._d.toDateString();\n        },\n        /**\n         * return a \
Moment.js object of the current selection (if available)\n         */\n       \
 getMoment: function() {\n          return hasMoment ? moment12(this._d) : \
null;\n        },\n        /**\n         * set the current selection from a \
Moment.js object (if available)\n         */\n        setMoment: \
function(date, preventOnSelect) {\n          if (hasMoment && \
moment12.isMoment(date)) {\n            this.setDate(date.toDate(), \
preventOnSelect);\n          }\n        },\n        /**\n         * return a \
Date object of the current selection\n         */\n        getDate: \
function() {\n          return isDate2(this._d) ? new Date(this._d.getTime()) \
: null;\n        },\n        /**\n         * set the current selection\n      \
   */\n        setDate: function(date, preventOnSelect) {\n          if \
(!date) {\n            this._d = null;\n            if (this._o.field) {\n    \
          this._o.field.value = \"\";\n              fireEvent(this._o.field, \
\"change\", { firedBy: this });\n            }\n            return \
this.draw();\n          }\n          if (typeof date === \"string\") {\n      \
      date = new Date(Date.parse(date));\n          }\n          if \
(!isDate2(date)) {\n            return;\n          }\n          var min = \
this._o.minDate, max = this._o.maxDate;\n          if (isDate2(min) && date < \
min) {\n            date = min;\n          } else if (isDate2(max) && date > \
max) {\n            date = max;\n          }\n          this._d = new \
Date(date.getTime());\n          setToStartOfDay(this._d);\n          \
this.gotoDate(this._d);\n          if (this._o.field) {\n            \
this._o.field.value = this.toString();\n            fireEvent(this._o.field, \
\"change\", { firedBy: this });\n          }\n          if (!preventOnSelect \
&& typeof this._o.onSelect === \"function\") {\n            \
this._o.onSelect.call(this, this.getDate());\n          }\n        },\n       \
 /**\n         * clear and reset the date\n         */\n        clear: \
function() {\n          this.setDate(null);\n        },\n        /**\n        \
 * change view to a specific date\n         */\n        gotoDate: \
function(date) {\n          var newCalendar = true;\n          if \
(!isDate2(date)) {\n            return;\n          }\n          if \
(this.calendars) {\n            var firstVisibleDate = new \
Date(this.calendars[0].year, this.calendars[0].month, 1), lastVisibleDate = \
new Date(this.calendars[this.calendars.length - 1].year, \
this.calendars[this.calendars.length - 1].month, 1), visibleDate = \
date.getTime();\n            \
lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);\n            \
lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);\n            \
newCalendar = visibleDate < firstVisibleDate.getTime() || \
lastVisibleDate.getTime() < visibleDate;\n          }\n          if \
(newCalendar) {\n            this.calendars = [{\n              month: \
date.getMonth(),\n              year: date.getFullYear()\n            }];\n   \
         if (this._o.mainCalendar === \"right\") {\n              \
this.calendars[0].month += 1 - this._o.numberOfMonths;\n            }\n       \
   }\n          this.adjustCalendars();\n        },\n        adjustDate: \
function(sign, days) {\n          var day = this.getDate() || /* @__PURE__ */ \
new Date();\n          var difference = parseInt(days) * 24 * 60 * 60 * \
1e3;\n          var newDay;\n          if (sign === \"add\") {\n            \
newDay = new Date(day.valueOf() + difference);\n          } else if (sign === \
\"subtract\") {\n            newDay = new Date(day.valueOf() - difference);\n \
         }\n          this.setDate(newDay);\n        },\n        \
adjustCalendars: function() {\n          this.calendars[0] = \
adjustCalendar(this.calendars[0]);\n          for (var c = 1; c < \
this._o.numberOfMonths; c++) {\n            this.calendars[c] = \
adjustCalendar({\n              month: this.calendars[0].month + c,\n         \
     year: this.calendars[0].year\n            });\n          }\n          \
this.draw();\n        },\n        gotoToday: function() {\n          \
this.gotoDate(/* @__PURE__ */ new Date());\n        },\n        /**\n         \
* change view to a specific month (zero-index, e.g. 0: January)\n         \
*/\n        gotoMonth: function(month) {\n          if (!isNaN(month)) {\n    \
        this.calendars[0].month = parseInt(month, 10);\n            \
this.adjustCalendars();\n          }\n        },\n        nextMonth: \
function() {\n          this.calendars[0].month++;\n          \
this.adjustCalendars();\n        },\n        prevMonth: function() {\n        \
  this.calendars[0].month--;\n          this.adjustCalendars();\n        },\n \
       /**\n         * change view to a specific full year (e.g. \"2012\")\n  \
       */\n        gotoYear: function(year) {\n          if (!isNaN(year)) \
{\n            this.calendars[0].year = parseInt(year, 10);\n            \
this.adjustCalendars();\n          }\n        },\n        /**\n         * \
change the minDate\n         */\n        setMinDate: function(value) {\n      \
    if (value instanceof Date) {\n            setToStartOfDay(value);\n       \
     this._o.minDate = value;\n            this._o.minYear = \
value.getFullYear();\n            this._o.minMonth = value.getMonth();\n      \
    } else {\n            this._o.minDate = defaults.minDate;\n            \
this._o.minYear = defaults.minYear;\n            this._o.minMonth = \
defaults.minMonth;\n            this._o.startRange = defaults.startRange;\n   \
       }\n          this.draw();\n        },\n        /**\n         * change \
the maxDate\n         */\n        setMaxDate: function(value) {\n          if \
(value instanceof Date) {\n            setToStartOfDay(value);\n            \
this._o.maxDate = value;\n            this._o.maxYear = \
value.getFullYear();\n            this._o.maxMonth = value.getMonth();\n      \
    } else {\n            this._o.maxDate = defaults.maxDate;\n            \
this._o.maxYear = defaults.maxYear;\n            this._o.maxMonth = \
defaults.maxMonth;\n            this._o.endRange = defaults.endRange;\n       \
   }\n          this.draw();\n        },\n        setStartRange: \
function(value) {\n          this._o.startRange = value;\n        },\n        \
setEndRange: function(value) {\n          this._o.endRange = value;\n        \
},\n        /**\n         * refresh the HTML\n         */\n        draw: \
function(force) {\n          if (!this._v && !force) {\n            return;\n \
         }\n          var opts = this._o, minYear = opts.minYear, maxYear = \
opts.maxYear, minMonth = opts.minMonth, maxMonth = opts.maxMonth, html = \
\"\", randId;\n          if (this._y <= minYear) {\n            this._y = \
minYear;\n            if (!isNaN(minMonth) && this._m < minMonth) {\n         \
     this._m = minMonth;\n            }\n          }\n          if (this._y \
>= maxYear) {\n            this._y = maxYear;\n            if \
(!isNaN(maxMonth) && this._m > maxMonth) {\n              this._m = \
maxMonth;\n            }\n          }\n          for (var c = 0; c < \
opts.numberOfMonths; c++) {\n            randId = \"pika-title-\" + \
Math.random().toString(36).replace(/[^a-z]+/g, \"\").substr(0, 2);\n          \
  html += '<div class=\"pika-lendar\">' + renderTitle(this, c, \
this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, \
randId) + this.render(this.calendars[c].year, this.calendars[c].month, \
randId) + \"</div>\";\n          }\n          this.el.innerHTML = html;\n     \
     if (opts.bound) {\n            if (opts.field.type !== \"hidden\") {\n   \
           sto(function() {\n                opts.trigger.focus();\n          \
    }, 1);\n            }\n          }\n          if (typeof this._o.onDraw \
=== \"function\") {\n            this._o.onDraw(this);\n          }\n         \
 if (opts.bound) {\n            opts.field.setAttribute(\"aria-label\", \
opts.ariaLabel);\n          }\n        },\n        adjustPosition: function() \
{\n          var field, pEl, width, height, viewportWidth, viewportHeight, \
scrollTop, left2, top2, clientRect, leftAligned, bottomAligned;\n          if \
(this._o.container)\n            return;\n          this.el.style.position = \
\"absolute\";\n          field = this._o.trigger;\n          pEl = field;\n   \
       width = this.el.offsetWidth;\n          height = \
this.el.offsetHeight;\n          viewportWidth = window.innerWidth || \
document2.documentElement.clientWidth;\n          viewportHeight = \
window.innerHeight || document2.documentElement.clientHeight;\n          \
scrollTop = window.pageYOffset || document2.body.scrollTop || \
document2.documentElement.scrollTop;\n          leftAligned = true;\n         \
 bottomAligned = true;\n          if (typeof field.getBoundingClientRect === \
\"function\") {\n            clientRect = field.getBoundingClientRect();\n    \
        left2 = clientRect.left + window.pageXOffset;\n            top2 = \
clientRect.bottom + window.pageYOffset;\n          } else {\n            \
left2 = pEl.offsetLeft;\n            top2 = pEl.offsetTop + \
pEl.offsetHeight;\n            while (pEl = pEl.offsetParent) {\n             \
 left2 += pEl.offsetLeft;\n              top2 += pEl.offsetTop;\n            \
}\n          }\n          if (this._o.reposition && left2 + width > \
viewportWidth || this._o.position.indexOf(\"right\") > -1 && left2 - width + \
field.offsetWidth > 0) {\n            left2 = left2 - width + \
field.offsetWidth;\n            leftAligned = false;\n          }\n          \
if (this._o.reposition && top2 + height > viewportHeight + scrollTop || \
this._o.position.indexOf(\"top\") > -1 && top2 - height - field.offsetHeight \
> 0) {\n            top2 = top2 - height - field.offsetHeight;\n            \
bottomAligned = false;\n          }\n          this.el.style.left = left2 + \
\"px\";\n          this.el.style.top = top2 + \"px\";\n          \
addClass2(this.el, leftAligned ? \"left-aligned\" : \"right-aligned\");\n     \
     addClass2(this.el, bottomAligned ? \"bottom-aligned\" : \
\"top-aligned\");\n          removeClass2(this.el, !leftAligned ? \
\"left-aligned\" : \"right-aligned\");\n          removeClass2(this.el, \
!bottomAligned ? \"bottom-aligned\" : \"top-aligned\");\n        },\n        \
/**\n         * render HTML for a particular month\n         */\n        \
render: function(year, month, randId) {\n          var opts = this._o, now = \
/* @__PURE__ */ new Date(), days = getDaysInMonth(year, month), before = new \
Date(year, month, 1).getDay(), data2 = [], row = [];\n          \
setToStartOfDay(now);\n          if (opts.firstDay > 0) {\n            before \
-= opts.firstDay;\n            if (before < 0) {\n              before += \
7;\n            }\n          }\n          var previousMonth = month === 0 ? \
11 : month - 1, nextMonth = month === 11 ? 0 : month + 1, yearOfPreviousMonth \
= month === 0 ? year - 1 : year, yearOfNextMonth = month === 11 ? year + 1 : \
year, daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, \
previousMonth);\n          var cells = days + before, after = cells;\n        \
  while (after > 7) {\n            after -= 7;\n          }\n          cells \
+= 7 - after;\n          var isWeekSelected = false;\n          for (var i = \
0, r = 0; i < cells; i++) {\n            var day = new Date(year, month, 1 + \
(i - before)), isSelected = isDate2(this._d) ? compareDates(day, this._d) : \
false, isToday = compareDates(day, now), hasEvent = \
opts.events.indexOf(day.toDateString()) !== -1 ? true : false, isEmpty2 = i < \
before || i >= days + before, dayNumber = 1 + (i - before), monthNumber = \
month, yearNumber = year, isStartRange = opts.startRange && \
compareDates(opts.startRange, day), isEndRange = opts.endRange && \
compareDates(opts.endRange, day), isInRange = opts.startRange && \
opts.endRange && opts.startRange < day && day < opts.endRange, isDisabled2 = \
opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || \
opts.disableWeekends && isWeekend(day) || opts.disableDayFn && \
opts.disableDayFn(day);\n            if (isEmpty2) {\n              if (i < \
before) {\n                dayNumber = daysInPreviousMonth + dayNumber;\n     \
           monthNumber = previousMonth;\n                yearNumber = \
yearOfPreviousMonth;\n              } else {\n                dayNumber = \
dayNumber - days;\n                monthNumber = nextMonth;\n                \
yearNumber = yearOfNextMonth;\n              }\n            }\n            \
var dayConfig = {\n              day: dayNumber,\n              month: \
monthNumber,\n              year: yearNumber,\n              hasEvent,\n      \
        isSelected,\n              isToday,\n              isDisabled: \
isDisabled2,\n              isEmpty: isEmpty2,\n              isStartRange,\n \
             isEndRange,\n              isInRange,\n              \
showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,\n      \
        enableSelectionDaysInNextAndPreviousMonths: \
opts.enableSelectionDaysInNextAndPreviousMonths\n            };\n            \
if (opts.pickWholeWeek && isSelected) {\n              isWeekSelected = \
true;\n            }\n            row.push(renderDay(dayConfig));\n           \
 if (++r === 7) {\n              if (opts.showWeekNumber) {\n                \
row.unshift(renderWeek(i - before, month, year, \
opts.firstWeekOfYearMinDays));\n              }\n              \
data2.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));\n \
             row = [];\n              r = 0;\n              isWeekSelected = \
false;\n            }\n          }\n          return renderTable(opts, data2, \
randId);\n        },\n        isVisible: function() {\n          return \
this._v;\n        },\n        show: function() {\n          if \
(!this.isVisible()) {\n            this._v = true;\n            \
this.draw();\n            removeClass2(this.el, \"is-hidden\");\n            \
if (this._o.bound) {\n              addEvent2(document2, \"click\", \
this._onClick);\n              this.adjustPosition();\n            }\n        \
    if (typeof this._o.onOpen === \"function\") {\n              \
this._o.onOpen.call(this);\n            }\n          }\n        },\n        \
hide: function() {\n          var v = this._v;\n          if (v !== false) \
{\n            if (this._o.bound) {\n              removeEvent2(document2, \
\"click\", this._onClick);\n            }\n            if \
(!this._o.container) {\n              this.el.style.position = \"static\";\n  \
            this.el.style.left = \"auto\";\n              this.el.style.top = \
\"auto\";\n            }\n            addClass2(this.el, \"is-hidden\");\n    \
        this._v = false;\n            if (v !== void 0 && typeof \
this._o.onClose === \"function\") {\n              \
this._o.onClose.call(this);\n            }\n          }\n        },\n        \
/**\n         * GAME OVER\n         */\n        destroy: function() {\n       \
   var opts = this._o;\n          this.hide();\n          \
removeEvent2(this.el, \"mousedown\", this._onMouseDown, true);\n          \
removeEvent2(this.el, \"touchend\", this._onMouseDown, true);\n          \
removeEvent2(this.el, \"change\", this._onChange);\n          if \
(opts.keyboardInput) {\n            removeEvent2(document2, \"keydown\", \
this._onKeyChange);\n          }\n          if (opts.field) {\n            \
removeEvent2(opts.field, \"change\", this._onInputChange);\n            if \
(opts.bound) {\n              removeEvent2(opts.trigger, \"click\", \
this._onInputClick);\n              removeEvent2(opts.trigger, \"focus\", \
this._onInputFocus);\n              removeEvent2(opts.trigger, \"blur\", \
this._onInputBlur);\n            }\n          }\n          if \
(this.el.parentNode) {\n            \
this.el.parentNode.removeChild(this.el);\n          }\n        }\n      };\n  \
    return Pikaday2;\n    });\n  }\n});\n\n// \
node_modules/numbro/dist/numbro.min.js\nvar require_numbro_min = \
__commonJS({\n  \"node_modules/numbro/dist/numbro.min.js\"(exports, module2) \
{\n    !function(e) {\n      if (\"object\" == typeof exports && \
\"undefined\" != typeof module2)\n        module2.exports = e();\n      else \
if (\"function\" == typeof define && define.amd)\n        define([], e);\n    \
  else {\n        (\"undefined\" != typeof window ? window : \"undefined\" != \
typeof global ? global : \"undefined\" != typeof self ? self : this).numbro = \
e();\n      }\n    }(function() {\n      return function a(o, u, c) {\n       \
 function s(t, e2) {\n          if (!u[t]) {\n            if (!o[t]) {\n      \
        var r = \"function\" == typeof require && require;\n              if \
(!e2 && r)\n                return r(t, true);\n              if (l)\n        \
        return l(t, true);\n              var n = new Error(\"Cannot find \
module '\" + t + \"'\");\n              throw n.code = \"MODULE_NOT_FOUND\", \
n;\n            }\n            var i = u[t] = { exports: {} };\n            \
o[t][0].call(i.exports, function(e3) {\n              return s(o[t][1][e3] || \
e3);\n            }, i, i.exports, a, o, u, c);\n          }\n          \
return u[t].exports;\n        }\n        for (var l = \"function\" == typeof \
require && require, e = 0; e < c.length; e++)\n          s(c[e]);\n        \
return s;\n      }({ 1: [function(e, r, t) {\n        !function(e2) {\n       \
   \"use strict\";\n          var t2, k = \
/^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i, _ = Math.ceil, L = \
Math.floor, T = \"[BigNumber Error] \", P = T + \"Number primitive has more \
than 15 significant digits: \", U = 1e14, j = 14, C = 9007199254740991, R = \
[1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], I = \
1e7, $6 = 1e9;\n          function G(e3) {\n            var t3 = 0 | e3;\n    \
        return 0 < e3 || e3 === t3 ? t3 : t3 - 1;\n          }\n          \
function V(e3) {\n            for (var t3, r2, n = 1, i = e3.length, a = \
e3[0] + \"\"; n < i; ) {\n              for (t3 = e3[n++] + \"\", r2 = j - \
t3.length; r2--; t3 = \"0\" + t3)\n                ;\n              a += \
t3;\n            }\n            for (i = a.length; 48 === a.charCodeAt(--i); \
)\n              ;\n            return a.slice(0, i + 1 || 1);\n          }\n \
         function q(e3, t3) {\n            var r2, n, i = e3.c, a = t3.c, o = \
e3.s, u = t3.s, c = e3.e, s = t3.e;\n            if (!o || !u)\n              \
return null;\n            if (r2 = i && !i[0], n = a && !a[0], r2 || n)\n     \
         return r2 ? n ? 0 : -u : o;\n            if (o != u)\n              \
return o;\n            if (r2 = o < 0, n = c == s, !i || !a)\n              \
return n ? 0 : !i ^ r2 ? 1 : -1;\n            if (!n)\n              return s \
< c ^ r2 ? 1 : -1;\n            for (u = (c = i.length) < (s = a.length) ? c \
: s, o = 0; o < u; o++)\n              if (i[o] != a[o])\n                \
return i[o] > a[o] ^ r2 ? 1 : -1;\n            return c == s ? 0 : s < c ^ r2 \
? 1 : -1;\n          }\n          function Z(e3, t3, r2, n) {\n            if \
(e3 < t3 || r2 < e3 || e3 !== (e3 < 0 ? _(e3) : L(e3)))\n              throw \
Error(T + (n || \"Argument\") + (\"number\" == typeof e3 ? e3 < t3 || r2 < e3 \
? \" out of range: \" : \" not an integer: \" : \" not a primitive number: \
\") + String(e3));\n          }\n          function z(e3) {\n            var \
t3 = e3.c.length - 1;\n            return G(e3.e / j) == t3 && e3.c[t3] % 2 \
!= 0;\n          }\n          function W(e3, t3) {\n            return (1 < \
e3.length ? e3.charAt(0) + \".\" + e3.slice(1) : e3) + (t3 < 0 ? \"e\" : \
\"e+\") + t3;\n          }\n          function H(e3, t3, r2) {\n            \
var n, i;\n            if (t3 < 0) {\n              for (i = r2 + \".\"; \
++t3; i += r2)\n                ;\n              e3 = i + e3;\n            } \
else if (++t3 > (n = e3.length)) {\n              for (i = r2, t3 -= n; --t3; \
i += r2)\n                ;\n              e3 += i;\n            } else\n     \
         t3 < n && (e3 = e3.slice(0, t3) + \".\" + e3.slice(t3));\n           \
 return e3;\n          }\n          (t2 = function e3(t3) {\n            var \
y, f, p, r2, s, o, u, c, l, g, n = A.prototype = { constructor: A, toString: \
null, valueOf: null }, d = new A(1), b = 20, w = 4, h = -7, v = 21, m = -1e7, \
O = 1e7, x = false, a = 1, S = 0, N = { prefix: \"\", groupSize: 3, \
secondaryGroupSize: 0, groupSeparator: \",\", decimalSeparator: \".\", \
fractionGroupSize: 0, fractionGroupSeparator: \"\\xA0\", suffix: \"\" }, M = \
\"0123456789abcdefghijklmnopqrstuvwxyz\";\n            function A(e4, t4) {\n \
             var r3, n2, i2, a2, o2, u2, c2, s2, l2 = this;\n              if \
(!(l2 instanceof A))\n                return new A(e4, t4);\n              if \
(null == t4) {\n                if (e4 instanceof A)\n                  \
return l2.s = e4.s, l2.e = e4.e, void (l2.c = (e4 = e4.c) ? e4.slice() : \
e4);\n                if ((u2 = \"number\" == typeof e4) && 0 * e4 == 0) {\n  \
                if (l2.s = 1 / e4 < 0 ? (e4 = -e4, -1) : 1, e4 === ~~e4) {\n  \
                  for (a2 = 0, o2 = e4; 10 <= o2; o2 /= 10, a2++)\n           \
           ;\n                    return l2.e = a2, void (l2.c = [e4]);\n     \
             }\n                  s2 = String(e4);\n                } else \
{\n                  if (s2 = String(e4), !k.test(s2))\n                    \
return p(l2, s2, u2);\n                  l2.s = 45 == s2.charCodeAt(0) ? (s2 \
= s2.slice(1), -1) : 1;\n                }\n                -1 < (a2 = \
s2.indexOf(\".\")) && (s2 = s2.replace(\".\", \"\")), 0 < (o2 = \
s2.search(/e/i)) ? (a2 < 0 && (a2 = o2), a2 += +s2.slice(o2 + 1), s2 = \
s2.substring(0, o2)) : a2 < 0 && (a2 = s2.length);\n              } else {\n  \
              if (Z(t4, 2, M.length, \"Base\"), s2 = String(e4), 10 == t4)\n  \
                return E(l2 = new A(e4 instanceof A ? e4 : s2), b + l2.e + 1, \
w);\n                if (u2 = \"number\" == typeof e4) {\n                  \
if (0 * e4 != 0)\n                    return p(l2, s2, u2, t4);\n             \
     if (l2.s = 1 / e4 < 0 ? (s2 = s2.slice(1), -1) : 1, A.DEBUG && 15 < \
s2.replace(/^0\\.0*|\\./, \"\").length)\n                    throw Error(P + \
e4);\n                  u2 = false;\n                } else\n                 \
 l2.s = 45 === s2.charCodeAt(0) ? (s2 = s2.slice(1), -1) : 1;\n               \
 for (r3 = M.slice(0, t4), a2 = o2 = 0, c2 = s2.length; o2 < c2; o2++)\n      \
            if (r3.indexOf(n2 = s2.charAt(o2)) < 0) {\n                    if \
(\".\" == n2) {\n                      if (a2 < o2) {\n                       \
 a2 = c2;\n                        continue;\n                      }\n       \
             } else if (!i2 && (s2 == s2.toUpperCase() && (s2 = \
s2.toLowerCase()) || s2 == s2.toLowerCase() && (s2 = s2.toUpperCase()))) {\n  \
                    i2 = true, o2 = -1, a2 = 0;\n                      \
continue;\n                    }\n                    return p(l2, \
String(e4), u2, t4);\n                  }\n                -1 < (a2 = (s2 = \
f(s2, t4, 10, l2.s)).indexOf(\".\")) ? s2 = s2.replace(\".\", \"\") : a2 = \
s2.length;\n              }\n              for (o2 = 0; 48 === \
s2.charCodeAt(o2); o2++)\n                ;\n              for (c2 = \
s2.length; 48 === s2.charCodeAt(--c2); )\n                ;\n              if \
(s2 = s2.slice(o2, ++c2)) {\n                if (c2 -= o2, u2 && A.DEBUG && \
15 < c2 && (C < e4 || e4 !== L(e4)))\n                  throw Error(P + l2.s \
* e4);\n                if (O < (a2 = a2 - o2 - 1))\n                  l2.c = \
l2.e = null;\n                else if (a2 < m)\n                  l2.c = \
[l2.e = 0];\n                else {\n                  if (l2.e = a2, l2.c = \
[], o2 = (a2 + 1) % j, a2 < 0 && (o2 += j), o2 < c2) {\n                    \
for (o2 && l2.c.push(+s2.slice(0, o2)), c2 -= j; o2 < c2; )\n                 \
     l2.c.push(+s2.slice(o2, o2 += j));\n                    s2 = \
s2.slice(o2), o2 = j - s2.length;\n                  } else\n                 \
   o2 -= c2;\n                  for (; o2--; s2 += \"0\")\n                   \
 ;\n                  l2.c.push(+s2);\n                }\n              } \
else\n                l2.c = [l2.e = 0];\n            }\n            function \
i(e4, t4, r3, n2) {\n              var i2, a2, o2, u2, c2;\n              if \
(null == r3 ? r3 = w : Z(r3, 0, 8), !e4.c)\n                return \
e4.toString();\n              if (i2 = e4.c[0], o2 = e4.e, null == t4)\n      \
          c2 = V(e4.c), c2 = 1 == n2 || 2 == n2 && (o2 <= h || v <= o2) ? \
W(c2, o2) : H(c2, o2, \"0\");\n              else if (a2 = (e4 = E(new A(e4), \
t4, r3)).e, u2 = (c2 = V(e4.c)).length, 1 == n2 || 2 == n2 && (t4 <= a2 || a2 \
<= h)) {\n                for (; u2 < t4; c2 += \"0\", u2++)\n                \
  ;\n                c2 = W(c2, a2);\n              } else if (t4 -= o2, c2 = \
H(c2, a2, \"0\"), u2 < a2 + 1) {\n                if (0 < --t4)\n             \
     for (c2 += \".\"; t4--; c2 += \"0\")\n                    ;\n            \
  } else if (0 < (t4 += a2 - u2))\n                for (a2 + 1 == u2 && (c2 \
+= \".\"); t4--; c2 += \"0\")\n                  ;\n              return e4.s \
< 0 && i2 ? \"-\" + c2 : c2;\n            }\n            function B(e4, t4) \
{\n              for (var r3, n2 = 1, i2 = new A(e4[0]); n2 < e4.length; \
n2++) {\n                if (!(r3 = new A(e4[n2])).s) {\n                  i2 \
= r3;\n                  break;\n                }\n                \
t4.call(i2, r3) && (i2 = r3);\n              }\n              return i2;\n    \
        }\n            function D(e4, t4, r3) {\n              for (var n2 = \
1, i2 = t4.length; !t4[--i2]; t4.pop())\n                ;\n              for \
(i2 = t4[0]; 10 <= i2; i2 /= 10, n2++)\n                ;\n              \
return (r3 = n2 + r3 * j - 1) > O ? e4.c = e4.e = null : e4.c = r3 < m ? \
[e4.e = 0] : (e4.e = r3, t4), e4;\n            }\n            function E(e4, \
t4, r3, n2) {\n              var i2, a2, o2, u2, c2, s2, l2, f2 = e4.c, p2 = \
R;\n              if (f2) {\n                e: {\n                  for (i2 \
= 1, u2 = f2[0]; 10 <= u2; u2 /= 10, i2++)\n                    ;\n           \
       if ((a2 = t4 - i2) < 0)\n                    a2 += j, o2 = t4, l2 = \
(c2 = f2[s2 = 0]) / p2[i2 - o2 - 1] % 10 | 0;\n                  else if ((s2 \
= _((a2 + 1) / j)) >= f2.length) {\n                    if (!n2)\n            \
          break e;\n                    for (; f2.length <= s2; f2.push(0))\n \
                     ;\n                    c2 = l2 = 0, o2 = (a2 %= j) - j + \
(i2 = 1);\n                  } else {\n                    for (c2 = u2 = \
f2[s2], i2 = 1; 10 <= u2; u2 /= 10, i2++)\n                      ;\n          \
          l2 = (o2 = (a2 %= j) - j + i2) < 0 ? 0 : c2 / p2[i2 - o2 - 1] % 10 \
| 0;\n                  }\n                  if (n2 = n2 || t4 < 0 || null != \
f2[s2 + 1] || (o2 < 0 ? c2 : c2 % p2[i2 - o2 - 1]), n2 = r3 < 4 ? (l2 || n2) \
&& (0 == r3 || r3 == (e4.s < 0 ? 3 : 2)) : 5 < l2 || 5 == l2 && (4 == r3 || \
n2 || 6 == r3 && (0 < a2 ? 0 < o2 ? c2 / p2[i2 - o2] : 0 : f2[s2 - 1]) % 10 & \
1 || r3 == (e4.s < 0 ? 8 : 7)), t4 < 1 || !f2[0])\n                    return \
f2.length = 0, n2 ? (t4 -= e4.e + 1, f2[0] = p2[(j - t4 % j) % j], e4.e = -t4 \
|| 0) : f2[0] = e4.e = 0, e4;\n                  if (0 == a2 ? (f2.length = \
s2, u2 = 1, s2--) : (f2.length = s2 + 1, u2 = p2[j - a2], f2[s2] = 0 < o2 ? \
L(c2 / p2[i2 - o2] % p2[o2]) * u2 : 0), n2)\n                    for (; ; ) \
{\n                      if (0 == s2) {\n                        for (a2 = 1, \
o2 = f2[0]; 10 <= o2; o2 /= 10, a2++)\n                          ;\n          \
              for (o2 = f2[0] += u2, u2 = 1; 10 <= o2; o2 /= 10, u2++)\n      \
                    ;\n                        a2 != u2 && (e4.e++, f2[0] == \
U && (f2[0] = 1));\n                        break;\n                      }\n \
                     if (f2[s2] += u2, f2[s2] != U)\n                        \
break;\n                      f2[s2--] = 0, u2 = 1;\n                    }\n  \
                for (a2 = f2.length; 0 === f2[--a2]; f2.pop())\n              \
      ;\n                }\n                e4.e > O ? e4.c = e4.e = null : \
e4.e < m && (e4.c = [e4.e = 0]);\n              }\n              return e4;\n \
           }\n            function F(e4) {\n              var t4, r3 = \
e4.e;\n              return null === r3 ? e4.toString() : (t4 = V(e4.c), t4 = \
r3 <= h || v <= r3 ? W(t4, r3) : H(t4, r3, \"0\"), e4.s < 0 ? \"-\" + t4 : \
t4);\n            }\n            return A.clone = e3, A.ROUND_UP = 0, \
A.ROUND_DOWN = 1, A.ROUND_CEIL = 2, A.ROUND_FLOOR = 3, A.ROUND_HALF_UP = 4, \
A.ROUND_HALF_DOWN = 5, A.ROUND_HALF_EVEN = 6, A.ROUND_HALF_CEIL = 7, \
A.ROUND_HALF_FLOOR = 8, A.EUCLID = 9, A.config = A.set = function(e4) {\n     \
         var t4, r3;\n              if (null != e4) {\n                if \
(\"object\" != typeof e4)\n                  throw Error(T + \"Object \
expected: \" + e4);\n                if (e4.hasOwnProperty(t4 = \
\"DECIMAL_PLACES\") && (Z(r3 = e4[t4], 0, $6, t4), b = r3), \
e4.hasOwnProperty(t4 = \"ROUNDING_MODE\") && (Z(r3 = e4[t4], 0, 8, t4), w = \
r3), e4.hasOwnProperty(t4 = \"EXPONENTIAL_AT\") && ((r3 = e4[t4]) && r3.pop ? \
(Z(r3[0], -$6, 0, t4), Z(r3[1], 0, $6, t4), h = r3[0], v = r3[1]) : (Z(r3, \
-$6, $6, t4), h = -(v = r3 < 0 ? -r3 : r3))), e4.hasOwnProperty(t4 = \
\"RANGE\"))\n                  if ((r3 = e4[t4]) && r3.pop)\n                 \
   Z(r3[0], -$6, -1, t4), Z(r3[1], 1, $6, t4), m = r3[0], O = r3[1];\n        \
          else {\n                    if (Z(r3, -$6, $6, t4), !r3)\n          \
            throw Error(T + t4 + \" cannot be zero: \" + r3);\n               \
     m = -(O = r3 < 0 ? -r3 : r3);\n                  }\n                if \
(e4.hasOwnProperty(t4 = \"CRYPTO\")) {\n                  if ((r3 = e4[t4]) \
!== !!r3)\n                    throw Error(T + t4 + \" not true or false: \" \
+ r3);\n                  if (r3) {\n                    if (\"undefined\" == \
typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes)\n \
                     throw x = !r3, Error(T + \"crypto unavailable\");\n      \
              x = r3;\n                  } else\n                    x = \
r3;\n                }\n                if (e4.hasOwnProperty(t4 = \
\"MODULO_MODE\") && (Z(r3 = e4[t4], 0, 9, t4), a = r3), e4.hasOwnProperty(t4 \
= \"POW_PRECISION\") && (Z(r3 = e4[t4], 0, $6, t4), S = r3), \
e4.hasOwnProperty(t4 = \"FORMAT\")) {\n                  if (\"object\" != \
typeof (r3 = e4[t4]))\n                    throw Error(T + t4 + \" not an \
object: \" + r3);\n                  N = r3;\n                }\n             \
   if (e4.hasOwnProperty(t4 = \"ALPHABET\")) {\n                  if \
(\"string\" != typeof (r3 = e4[t4]) || /^.$|[+-.\\s]|(.).*\\1/.test(r3))\n    \
                throw Error(T + t4 + \" invalid: \" + r3);\n                  \
M = r3;\n                }\n              }\n              return { \
DECIMAL_PLACES: b, ROUNDING_MODE: w, EXPONENTIAL_AT: [h, v], RANGE: [m, O], \
CRYPTO: x, MODULO_MODE: a, POW_PRECISION: S, FORMAT: N, ALPHABET: M };\n      \
      }, A.isBigNumber = function(e4) {\n              return e4 instanceof A \
|| e4 && true === e4._isBigNumber || false;\n            }, A.maximum = A.max \
= function() {\n              return B(arguments, n.lt);\n            }, \
A.minimum = A.min = function() {\n              return B(arguments, n.gt);\n  \
          }, A.random = (r2 = 9007199254740992, s = Math.random() * r2 & \
2097151 ? function() {\n              return L(Math.random() * r2);\n         \
   } : function() {\n              return 8388608 * (1073741824 * \
Math.random() | 0) + (8388608 * Math.random() | 0);\n            }, \
function(e4) {\n              var t4, r3, n2, i2, a2, o2 = 0, u2 = [], c2 = \
new A(d);\n              if (null == e4 ? e4 = b : Z(e4, 0, $6), i2 = _(e4 / \
j), x)\n                if (crypto.getRandomValues) {\n                  for \
(t4 = crypto.getRandomValues(new Uint32Array(i2 *= 2)); o2 < i2; )\n          \
          9e15 <= (a2 = 131072 * t4[o2] + (t4[o2 + 1] >>> 11)) ? (r3 = \
crypto.getRandomValues(new Uint32Array(2)), t4[o2] = r3[0], t4[o2 + 1] = \
r3[1]) : (u2.push(a2 % 1e14), o2 += 2);\n                  o2 = i2 / 2;\n     \
           } else {\n                  if (!crypto.randomBytes)\n             \
       throw x = false, Error(T + \"crypto unavailable\");\n                  \
for (t4 = crypto.randomBytes(i2 *= 7); o2 < i2; )\n                    9e15 \
<= (a2 = 281474976710656 * (31 & t4[o2]) + 1099511627776 * t4[o2 + 1] + \
4294967296 * t4[o2 + 2] + 16777216 * t4[o2 + 3] + (t4[o2 + 4] << 16) + (t4[o2 \
+ 5] << 8) + t4[o2 + 6]) ? crypto.randomBytes(7).copy(t4, o2) : (u2.push(a2 % \
1e14), o2 += 7);\n                  o2 = i2 / 7;\n                }\n         \
     if (!x)\n                for (; o2 < i2; )\n                  (a2 = s()) \
< 9e15 && (u2[o2++] = a2 % 1e14);\n              for (i2 = u2[--o2], e4 %= j, \
i2 && e4 && (a2 = R[j - e4], u2[o2] = L(i2 / a2) * a2); 0 === u2[o2]; \
u2.pop(), o2--)\n                ;\n              if (o2 < 0)\n               \
 u2 = [n2 = 0];\n              else {\n                for (n2 = -1; 0 === \
u2[0]; u2.splice(0, 1), n2 -= j)\n                  ;\n                for \
(o2 = 1, a2 = u2[0]; 10 <= a2; a2 /= 10, o2++)\n                  ;\n         \
       o2 < j && (n2 -= j - o2);\n              }\n              return c2.e \
= n2, c2.c = u2, c2;\n            }), A.sum = function() {\n              for \
(var e4 = 1, t4 = arguments, r3 = new A(t4[0]); e4 < t4.length; )\n           \
     r3 = r3.plus(t4[e4++]);\n              return r3;\n            }, f = \
function() {\n              var v2 = \"0123456789\";\n              function \
m2(e4, t4, r3, n2) {\n                for (var i2, a2, o2 = [0], u2 = 0, c2 = \
e4.length; u2 < c2; ) {\n                  for (a2 = o2.length; a2--; o2[a2] \
*= t4)\n                    ;\n                  for (o2[0] += \
n2.indexOf(e4.charAt(u2++)), i2 = 0; i2 < o2.length; i2++)\n                  \
  o2[i2] > r3 - 1 && (null == o2[i2 + 1] && (o2[i2 + 1] = 0), o2[i2 + 1] += \
o2[i2] / r3 | 0, o2[i2] %= r3);\n                }\n                return \
o2.reverse();\n              }\n              return function(e4, t4, r3, n2, \
i2) {\n                var a2, o2, u2, c2, s2, l2, f2, p2, g2 = \
e4.indexOf(\".\"), h2 = b, d2 = w;\n                for (0 <= g2 && (c2 = S, \
S = 0, e4 = e4.replace(\".\", \"\"), l2 = (p2 = new A(t4)).pow(e4.length - \
g2), S = c2, p2.c = m2(H(V(l2.c), l2.e, \"0\"), 10, r3, v2), p2.e = \
p2.c.length), u2 = c2 = (f2 = m2(e4, t4, r3, i2 ? (a2 = M, v2) : (a2 = v2, \
M))).length; 0 == f2[--c2]; f2.pop())\n                  ;\n                \
if (!f2[0])\n                  return a2.charAt(0);\n                if (g2 < \
0 ? --u2 : (l2.c = f2, l2.e = u2, l2.s = n2, f2 = (l2 = y(l2, p2, h2, d2, \
r3)).c, s2 = l2.r, u2 = l2.e), g2 = f2[o2 = u2 + h2 + 1], c2 = r3 / 2, s2 = \
s2 || o2 < 0 || null != f2[o2 + 1], s2 = d2 < 4 ? (null != g2 || s2) && (0 == \
d2 || d2 == (l2.s < 0 ? 3 : 2)) : c2 < g2 || g2 == c2 && (4 == d2 || s2 || 6 \
== d2 && 1 & f2[o2 - 1] || d2 == (l2.s < 0 ? 8 : 7)), o2 < 1 || !f2[0])\n     \
             e4 = s2 ? H(a2.charAt(1), -h2, a2.charAt(0)) : a2.charAt(0);\n   \
             else {\n                  if (f2.length = o2, s2)\n              \
      for (--r3; ++f2[--o2] > r3; )\n                      f2[o2] = 0, o2 || \
(++u2, f2 = [1].concat(f2));\n                  for (c2 = f2.length; \
!f2[--c2]; )\n                    ;\n                  for (g2 = 0, e4 = \
\"\"; g2 <= c2; e4 += a2.charAt(f2[g2++]))\n                    ;\n           \
       e4 = H(e4, u2, a2.charAt(0));\n                }\n                \
return e4;\n              };\n            }(), y = function() {\n             \
 function M2(e4, t4, r3) {\n                var n2, i2, a2, o2, u2 = 0, c2 = \
e4.length, s2 = t4 % I, l2 = t4 / I | 0;\n                for (e4 = \
e4.slice(); c2--; )\n                  u2 = ((i2 = s2 * (a2 = e4[c2] % I) + \
(n2 = l2 * a2 + (o2 = e4[c2] / I | 0) * s2) % I * I + u2) / r3 | 0) + (n2 / I \
| 0) + l2 * o2, e4[c2] = i2 % r3;\n                return u2 && (e4 = \
[u2].concat(e4)), e4;\n              }\n              function B2(e4, t4, r3, \
n2) {\n                var i2, a2;\n                if (r3 != n2)\n           \
       a2 = n2 < r3 ? 1 : -1;\n                else\n                  for \
(i2 = a2 = 0; i2 < r3; i2++)\n                    if (e4[i2] != t4[i2]) {\n   \
                   a2 = e4[i2] > t4[i2] ? 1 : -1;\n                      \
break;\n                    }\n                return a2;\n              }\n  \
            function D2(e4, t4, r3, n2) {\n                for (var i2 = 0; \
r3--; )\n                  e4[r3] -= i2, i2 = e4[r3] < t4[r3] ? 1 : 0, e4[r3] \
= i2 * n2 + e4[r3] - t4[r3];\n                for (; !e4[0] && 1 < e4.length; \
e4.splice(0, 1))\n                  ;\n              }\n              return \
function(e4, t4, r3, n2, i2) {\n                var a2, o2, u2, c2, s2, l2, \
f2, p2, g2, h2, d2, v2, m2, y2, b2, w2, O2, x2 = e4.s == t4.s ? 1 : -1, S2 = \
e4.c, N2 = t4.c;\n                if (!(S2 && S2[0] && N2 && N2[0]))\n        \
          return new A(e4.s && t4.s && (S2 ? !N2 || S2[0] != N2[0] : N2) ? S2 \
&& 0 == S2[0] || !N2 ? 0 * x2 : x2 / 0 : NaN);\n                for (g2 = (p2 \
= new A(x2)).c = [], x2 = r3 + (o2 = e4.e - t4.e) + 1, i2 || (i2 = U, o2 = \
G(e4.e / j) - G(t4.e / j), x2 = x2 / j | 0), u2 = 0; N2[u2] == (S2[u2] || 0); \
u2++)\n                  ;\n                if (N2[u2] > (S2[u2] || 0) && \
o2--, x2 < 0)\n                  g2.push(1), c2 = true;\n                else \
{\n                  for (y2 = S2.length, w2 = N2.length, x2 += 2, 1 < (s2 = \
L(i2 / (N2[u2 = 0] + 1))) && (N2 = M2(N2, s2, i2), S2 = M2(S2, s2, i2), w2 = \
N2.length, y2 = S2.length), m2 = w2, d2 = (h2 = S2.slice(0, w2)).length; d2 < \
w2; h2[d2++] = 0)\n                    ;\n                  O2 = N2.slice(), \
O2 = [0].concat(O2), b2 = N2[0], N2[1] >= i2 / 2 && b2++;\n                  \
do {\n                    if (s2 = 0, (a2 = B2(N2, h2, w2, d2)) < 0) {\n      \
                if (v2 = h2[0], w2 != d2 && (v2 = v2 * i2 + (h2[1] || 0)), 1 \
< (s2 = L(v2 / b2)))\n                        for (i2 <= s2 && (s2 = i2 - 1), \
f2 = (l2 = M2(N2, s2, i2)).length, d2 = h2.length; 1 == B2(l2, h2, f2, d2); \
)\n                          s2--, D2(l2, w2 < f2 ? O2 : N2, f2, i2), f2 = \
l2.length, a2 = 1;\n                      else\n                        0 == \
s2 && (a2 = s2 = 1), f2 = (l2 = N2.slice()).length;\n                      if \
(f2 < d2 && (l2 = [0].concat(l2)), D2(h2, l2, d2, i2), d2 = h2.length, -1 == \
a2)\n                        for (; B2(N2, h2, w2, d2) < 1; )\n               \
           s2++, D2(h2, w2 < d2 ? O2 : N2, d2, i2), d2 = h2.length;\n         \
           } else\n                      0 === a2 && (s2++, h2 = [0]);\n      \
              g2[u2++] = s2, h2[0] ? h2[d2++] = S2[m2] || 0 : (h2 = [S2[m2]], \
d2 = 1);\n                  } while ((m2++ < y2 || null != h2[0]) && x2--);\n \
                 c2 = null != h2[0], g2[0] || g2.splice(0, 1);\n              \
  }\n                if (i2 == U) {\n                  for (u2 = 1, x2 = \
g2[0]; 10 <= x2; x2 /= 10, u2++)\n                    ;\n                  \
E(p2, r3 + (p2.e = u2 + o2 * j - 1) + 1, n2, c2);\n                } else\n   \
               p2.e = o2, p2.r = +c2;\n                return p2;\n           \
   };\n            }(), o = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i, u = \
/^([^.]+)\\.$/, c = /^\\.([^.]+)$/, l = /^-?(Infinity|NaN)$/, g = \
/^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g, p = function(e4, t4, r3, n2) {\n           \
   var i2, a2 = r3 ? t4 : t4.replace(g, \"\");\n              if \
(l.test(a2))\n                e4.s = isNaN(a2) ? null : a2 < 0 ? -1 : 1, e4.c \
= e4.e = null;\n              else {\n                if (!r3 && (a2 = \
a2.replace(o, function(e5, t5, r4) {\n                  return i2 = \"x\" == \
(r4 = r4.toLowerCase()) ? 16 : \"b\" == r4 ? 2 : 8, n2 && n2 != i2 ? e5 : \
t5;\n                }), n2 && (i2 = n2, a2 = a2.replace(u, \
\"$1\").replace(c, \"0.$1\")), t4 != a2))\n                  return new A(a2, \
i2);\n                if (A.DEBUG)\n                  throw Error(T + \"Not \
a\" + (n2 ? \" base \" + n2 : \"\") + \" number: \" + t4);\n                \
e4.c = e4.e = e4.s = null;\n              }\n            }, n.absoluteValue = \
n.abs = function() {\n              var e4 = new A(this);\n              \
return e4.s < 0 && (e4.s = 1), e4;\n            }, n.comparedTo = \
function(e4, t4) {\n              return q(this, new A(e4, t4));\n            \
}, n.decimalPlaces = n.dp = function(e4, t4) {\n              var r3, n2, \
i2;\n              if (null != e4)\n                return Z(e4, 0, $6), null \
== t4 ? t4 = w : Z(t4, 0, 8), E(new A(this), e4 + this.e + 1, t4);\n          \
    if (!(r3 = this.c))\n                return null;\n              if (n2 = \
((i2 = r3.length - 1) - G(this.e / j)) * j, i2 = r3[i2])\n                for \
(; i2 % 10 == 0; i2 /= 10, n2--)\n                  ;\n              return \
n2 < 0 && (n2 = 0), n2;\n            }, n.dividedBy = n.div = function(e4, \
t4) {\n              return y(this, new A(e4, t4), b, w);\n            }, \
n.dividedToIntegerBy = n.idiv = function(e4, t4) {\n              return \
y(this, new A(e4, t4), 0, 1);\n            }, n.exponentiatedBy = n.pow = \
function(e4, t4) {\n              var r3, n2, i2, a2, o2, u2, c2, s2, l2 = \
this;\n              if ((e4 = new A(e4)).c && !e4.isInteger())\n             \
   throw Error(T + \"Exponent not an integer: \" + F(e4));\n              if \
(null != t4 && (t4 = new A(t4)), o2 = 14 < e4.e, !l2.c || !l2.c[0] || 1 == \
l2.c[0] && !l2.e && 1 == l2.c.length || !e4.c || !e4.c[0])\n                \
return s2 = new A(Math.pow(+F(l2), o2 ? 2 - z(e4) : +F(e4))), t4 ? s2.mod(t4) \
: s2;\n              if (u2 = e4.s < 0, t4) {\n                if (t4.c ? \
!t4.c[0] : !t4.s)\n                  return new A(NaN);\n                (n2 \
= !u2 && l2.isInteger() && t4.isInteger()) && (l2 = l2.mod(t4));\n            \
  } else {\n                if (9 < e4.e && (0 < l2.e || l2.e < -1 || (0 == \
l2.e ? 1 < l2.c[0] || o2 && 24e7 <= l2.c[1] : l2.c[0] < 8e13 || o2 && l2.c[0] \
<= 9999975e7)))\n                  return a2 = l2.s < 0 && z(e4) ? -0 : 0, -1 \
< l2.e && (a2 = 1 / a2), new A(u2 ? 1 / a2 : a2);\n                S && (a2 = \
_(S / j + 2));\n              }\n              for (c2 = o2 ? (r3 = new \
A(0.5), u2 && (e4.s = 1), z(e4)) : (i2 = Math.abs(+F(e4))) % 2, s2 = new \
A(d); ; ) {\n                if (c2) {\n                  if (!(s2 = \
s2.times(l2)).c)\n                    break;\n                  a2 ? \
s2.c.length > a2 && (s2.c.length = a2) : n2 && (s2 = s2.mod(t4));\n           \
     }\n                if (i2) {\n                  if (0 === (i2 = L(i2 / \
2)))\n                    break;\n                  c2 = i2 % 2;\n            \
    } else if (E(e4 = e4.times(r3), e4.e + 1, 1), 14 < e4.e)\n                \
  c2 = z(e4);\n                else {\n                  if (0 == (i2 = \
+F(e4)))\n                    break;\n                  c2 = i2 % 2;\n        \
        }\n                l2 = l2.times(l2), a2 ? l2.c && l2.c.length > a2 \
&& (l2.c.length = a2) : n2 && (l2 = l2.mod(t4));\n              }\n           \
   return n2 ? s2 : (u2 && (s2 = d.div(s2)), t4 ? s2.mod(t4) : a2 ? E(s2, S, \
w, void 0) : s2);\n            }, n.integerValue = function(e4) {\n           \
   var t4 = new A(this);\n              return null == e4 ? e4 = w : Z(e4, 0, \
8), E(t4, t4.e + 1, e4);\n            }, n.isEqualTo = n.eq = function(e4, \
t4) {\n              return 0 === q(this, new A(e4, t4));\n            }, \
n.isFinite = function() {\n              return !!this.c;\n            }, \
n.isGreaterThan = n.gt = function(e4, t4) {\n              return 0 < q(this, \
new A(e4, t4));\n            }, n.isGreaterThanOrEqualTo = n.gte = \
function(e4, t4) {\n              return 1 === (t4 = q(this, new A(e4, t4))) \
|| 0 === t4;\n            }, n.isInteger = function() {\n              return \
!!this.c && G(this.e / j) > this.c.length - 2;\n            }, n.isLessThan = \
n.lt = function(e4, t4) {\n              return q(this, new A(e4, t4)) < 0;\n \
           }, n.isLessThanOrEqualTo = n.lte = function(e4, t4) {\n            \
  return -1 === (t4 = q(this, new A(e4, t4))) || 0 === t4;\n            }, \
n.isNaN = function() {\n              return !this.s;\n            }, \
n.isNegative = function() {\n              return this.s < 0;\n            }, \
n.isPositive = function() {\n              return 0 < this.s;\n            }, \
n.isZero = function() {\n              return !!this.c && 0 == this.c[0];\n   \
         }, n.minus = function(e4, t4) {\n              var r3, n2, i2, a2, \
o2 = this, u2 = o2.s;\n              if (t4 = (e4 = new A(e4, t4)).s, !u2 || \
!t4)\n                return new A(NaN);\n              if (u2 != t4)\n       \
         return e4.s = -t4, o2.plus(e4);\n              var c2 = o2.e / j, s2 \
= e4.e / j, l2 = o2.c, f2 = e4.c;\n              if (!c2 || !s2) {\n          \
      if (!l2 || !f2)\n                  return l2 ? (e4.s = -t4, e4) : new \
A(f2 ? o2 : NaN);\n                if (!l2[0] || !f2[0])\n                  \
return f2[0] ? (e4.s = -t4, e4) : new A(l2[0] ? o2 : 3 == w ? -0 : 0);\n      \
        }\n              if (c2 = G(c2), s2 = G(s2), l2 = l2.slice(), u2 = c2 \
- s2) {\n                for ((i2 = (a2 = u2 < 0) ? (u2 = -u2, l2) : (s2 = \
c2, f2)).reverse(), t4 = u2; t4--; i2.push(0))\n                  ;\n         \
       i2.reverse();\n              } else\n                for (n2 = (a2 = \
(u2 = l2.length) < (t4 = f2.length)) ? u2 : t4, u2 = t4 = 0; t4 < n2; t4++)\n \
                 if (l2[t4] != f2[t4]) {\n                    a2 = l2[t4] < \
f2[t4];\n                    break;\n                  }\n              if \
(a2 && (i2 = l2, l2 = f2, f2 = i2, e4.s = -e4.s), 0 < (t4 = (n2 = f2.length) \
- (r3 = l2.length)))\n                for (; t4--; l2[r3++] = 0)\n            \
      ;\n              for (t4 = U - 1; u2 < n2; ) {\n                if \
(l2[--n2] < f2[n2]) {\n                  for (r3 = n2; r3 && !l2[--r3]; \
l2[r3] = t4)\n                    ;\n                  --l2[r3], l2[n2] += \
U;\n                }\n                l2[n2] -= f2[n2];\n              }\n   \
           for (; 0 == l2[0]; l2.splice(0, 1), --s2)\n                ;\n     \
         return l2[0] ? D(e4, l2, s2) : (e4.s = 3 == w ? -1 : 1, e4.c = [e4.e \
= 0], e4);\n            }, n.modulo = n.mod = function(e4, t4) {\n            \
  var r3, n2, i2 = this;\n              return e4 = new A(e4, t4), !i2.c || \
!e4.s || e4.c && !e4.c[0] ? new A(NaN) : !e4.c || i2.c && !i2.c[0] ? new \
A(i2) : (9 == a ? (n2 = e4.s, e4.s = 1, r3 = y(i2, e4, 0, 3), e4.s = n2, r3.s \
*= n2) : r3 = y(i2, e4, 0, a), (e4 = i2.minus(r3.times(e4))).c[0] || 1 != a \
|| (e4.s = i2.s), e4);\n            }, n.multipliedBy = n.times = \
function(e4, t4) {\n              var r3, n2, i2, a2, o2, u2, c2, s2, l2, f2, \
p2, g2, h2, d2, v2, m2 = this, y2 = m2.c, b2 = (e4 = new A(e4, t4)).c;\n      \
        if (!(y2 && b2 && y2[0] && b2[0]))\n                return !m2.s || \
!e4.s || y2 && !y2[0] && !b2 || b2 && !b2[0] && !y2 ? e4.c = e4.e = e4.s = \
null : (e4.s *= m2.s, y2 && b2 ? (e4.c = [0], e4.e = 0) : e4.c = e4.e = \
null), e4;\n              for (n2 = G(m2.e / j) + G(e4.e / j), e4.s *= m2.s, \
(c2 = y2.length) < (f2 = b2.length) && (h2 = y2, y2 = b2, b2 = h2, i2 = c2, \
c2 = f2, f2 = i2), i2 = c2 + f2, h2 = []; i2--; h2.push(0))\n                \
;\n              for (d2 = U, v2 = I, i2 = f2; 0 <= --i2; ) {\n               \
 for (r3 = 0, p2 = b2[i2] % v2, g2 = b2[i2] / v2 | 0, a2 = i2 + (o2 = c2); i2 \
< a2; )\n                  r3 = ((s2 = p2 * (s2 = y2[--o2] % v2) + (u2 = g2 * \
s2 + (l2 = y2[o2] / v2 | 0) * p2) % v2 * v2 + h2[a2] + r3) / d2 | 0) + (u2 / \
v2 | 0) + g2 * l2, h2[a2--] = s2 % d2;\n                h2[a2] = r3;\n        \
      }\n              return r3 ? ++n2 : h2.splice(0, 1), D(e4, h2, n2);\n   \
         }, n.negated = function() {\n              var e4 = new A(this);\n   \
           return e4.s = -e4.s || null, e4;\n            }, n.plus = \
function(e4, t4) {\n              var r3, n2 = this, i2 = n2.s;\n             \
 if (t4 = (e4 = new A(e4, t4)).s, !i2 || !t4)\n                return new \
A(NaN);\n              if (i2 != t4)\n                return e4.s = -t4, \
n2.minus(e4);\n              var a2 = n2.e / j, o2 = e4.e / j, u2 = n2.c, c2 \
= e4.c;\n              if (!a2 || !o2) {\n                if (!u2 || !c2)\n   \
               return new A(i2 / 0);\n                if (!u2[0] || !c2[0])\n \
                 return c2[0] ? e4 : new A(u2[0] ? n2 : 0 * i2);\n            \
  }\n              if (a2 = G(a2), o2 = G(o2), u2 = u2.slice(), i2 = a2 - o2) \
{\n                for ((r3 = 0 < i2 ? (o2 = a2, c2) : (i2 = -i2, \
u2)).reverse(); i2--; r3.push(0))\n                  ;\n                \
r3.reverse();\n              }\n              for ((i2 = u2.length) - (t4 = \
c2.length) < 0 && (r3 = c2, c2 = u2, u2 = r3, t4 = i2), i2 = 0; t4; )\n       \
         i2 = (u2[--t4] = u2[t4] + c2[t4] + i2) / U | 0, u2[t4] = U === \
u2[t4] ? 0 : u2[t4] % U;\n              return i2 && (u2 = [i2].concat(u2), \
++o2), D(e4, u2, o2);\n            }, n.precision = n.sd = function(e4, t4) \
{\n              var r3, n2, i2;\n              if (null != e4 && e4 !== \
!!e4)\n                return Z(e4, 1, $6), null == t4 ? t4 = w : Z(t4, 0, \
8), E(new A(this), e4, t4);\n              if (!(r3 = this.c))\n              \
  return null;\n              if (n2 = (i2 = r3.length - 1) * j + 1, i2 = \
r3[i2]) {\n                for (; i2 % 10 == 0; i2 /= 10, n2--)\n             \
     ;\n                for (i2 = r3[0]; 10 <= i2; i2 /= 10, n2++)\n          \
        ;\n              }\n              return e4 && this.e + 1 > n2 && (n2 \
= this.e + 1), n2;\n            }, n.shiftedBy = function(e4) {\n             \
 return Z(e4, -C, C), this.times(\"1e\" + e4);\n            }, n.squareRoot = \
n.sqrt = function() {\n              var e4, t4, r3, n2, i2, a2 = this, o2 = \
a2.c, u2 = a2.s, c2 = a2.e, s2 = b + 4, l2 = new A(\"0.5\");\n              \
if (1 !== u2 || !o2 || !o2[0])\n                return new A(!u2 || u2 < 0 && \
(!o2 || o2[0]) ? NaN : o2 ? a2 : 1 / 0);\n              if ((r3 = 0 == (u2 = \
Math.sqrt(+F(a2))) || u2 == 1 / 0 ? (((t4 = V(o2)).length + c2) % 2 == 0 && \
(t4 += \"0\"), u2 = Math.sqrt(+t4), c2 = G((c2 + 1) / 2) - (c2 < 0 || c2 % \
2), new A(t4 = u2 == 1 / 0 ? \"1e\" + c2 : (t4 = u2.toExponential()).slice(0, \
t4.indexOf(\"e\") + 1) + c2)) : new A(u2 + \"\")).c[0]) {\n                \
for ((u2 = (c2 = r3.e) + s2) < 3 && (u2 = 0); ; )\n                  if (i2 = \
r3, r3 = l2.times(i2.plus(y(a2, i2, s2, 1))), V(i2.c).slice(0, u2) === (t4 = \
V(r3.c)).slice(0, u2)) {\n                    if (r3.e < c2 && --u2, \"9999\" \
!= (t4 = t4.slice(u2 - 3, u2 + 1)) && (n2 || \"4999\" != t4)) {\n             \
         +t4 && (+t4.slice(1) || \"5\" != t4.charAt(0)) || (E(r3, r3.e + b + \
2, 1), e4 = !r3.times(r3).eq(a2));\n                      break;\n            \
        }\n                    if (!n2 && (E(i2, i2.e + b + 2, 0), \
i2.times(i2).eq(a2))) {\n                      r3 = i2;\n                     \
 break;\n                    }\n                    s2 += 4, u2 += 4, n2 = \
1;\n                  }\n              }\n              return E(r3, r3.e + b \
+ 1, w, e4);\n            }, n.toExponential = function(e4, t4) {\n           \
   return null != e4 && (Z(e4, 0, $6), e4++), i(this, e4, t4, 1);\n           \
 }, n.toFixed = function(e4, t4) {\n              return null != e4 && (Z(e4, \
0, $6), e4 = e4 + this.e + 1), i(this, e4, t4);\n            }, n.toFormat = \
function(e4, t4, r3) {\n              var n2;\n              if (null == \
r3)\n                null != e4 && t4 && \"object\" == typeof t4 ? (r3 = t4, \
t4 = null) : e4 && \"object\" == typeof e4 ? (r3 = e4, e4 = t4 = null) : r3 = \
N;\n              else if (\"object\" != typeof r3)\n                throw \
Error(T + \"Argument not an object: \" + r3);\n              if (n2 = \
this.toFixed(e4, t4), this.c) {\n                var i2, a2 = \
n2.split(\".\"), o2 = +r3.groupSize, u2 = +r3.secondaryGroupSize, c2 = \
r3.groupSeparator || \"\", s2 = a2[0], l2 = a2[1], f2 = this.s < 0, p2 = f2 ? \
s2.slice(1) : s2, g2 = p2.length;\n                if (u2 && (i2 = o2, o2 = \
u2, g2 -= u2 = i2), 0 < o2 && 0 < g2) {\n                  for (i2 = g2 % o2 \
|| o2, s2 = p2.substr(0, i2); i2 < g2; i2 += o2)\n                    s2 += \
c2 + p2.substr(i2, o2);\n                  0 < u2 && (s2 += c2 + \
p2.slice(i2)), f2 && (s2 = \"-\" + s2);\n                }\n                \
n2 = l2 ? s2 + (r3.decimalSeparator || \"\") + ((u2 = +r3.fractionGroupSize) \
? l2.replace(new RegExp(\"\\\\d{\" + u2 + \"}\\\\B\", \"g\"), \"$&\" + \
(r3.fractionGroupSeparator || \"\")) : l2) : s2;\n              }\n           \
   return (r3.prefix || \"\") + n2 + (r3.suffix || \"\");\n            }, \
n.toFraction = function(e4) {\n              var t4, r3, n2, i2, a2, o2, u2, \
c2, s2, l2, f2, p2, g2 = this, h2 = g2.c;\n              if (null != e4 && \
(!(u2 = new A(e4)).isInteger() && (u2.c || 1 !== u2.s) || u2.lt(d)))\n        \
        throw Error(T + \"Argument \" + (u2.isInteger() ? \"out of range: \" \
: \"not an integer: \") + F(u2));\n              if (!h2)\n                \
return new A(g2);\n              for (t4 = new A(d), s2 = r3 = new A(d), n2 = \
c2 = new A(d), p2 = V(h2), a2 = t4.e = p2.length - g2.e - 1, t4.c[0] = R[(o2 \
= a2 % j) < 0 ? j + o2 : o2], e4 = !e4 || 0 < u2.comparedTo(t4) ? 0 < a2 ? t4 \
: s2 : u2, o2 = O, O = 1 / 0, u2 = new A(p2), c2.c[0] = 0; l2 = y(u2, t4, 0, \
1), 1 != (i2 = r3.plus(l2.times(n2))).comparedTo(e4); )\n                r3 = \
n2, n2 = i2, s2 = c2.plus(l2.times(i2 = s2)), c2 = i2, t4 = \
u2.minus(l2.times(i2 = t4)), u2 = i2;\n              return i2 = \
y(e4.minus(r3), n2, 0, 1), c2 = c2.plus(i2.times(s2)), r3 = \
r3.plus(i2.times(n2)), c2.s = s2.s = g2.s, f2 = y(s2, n2, a2 *= 2, \
w).minus(g2).abs().comparedTo(y(c2, r3, a2, w).minus(g2).abs()) < 1 ? [s2, \
n2] : [c2, r3], O = o2, f2;\n            }, n.toNumber = function() {\n       \
       return +F(this);\n            }, n.toPrecision = function(e4, t4) {\n  \
            return null != e4 && Z(e4, 1, $6), i(this, e4, t4, 2);\n          \
  }, n.toString = function(e4) {\n              var t4, r3 = this, n2 = r3.s, \
i2 = r3.e;\n              return null === i2 ? n2 ? (t4 = \"Infinity\", n2 < \
0 && (t4 = \"-\" + t4)) : t4 = \"NaN\" : (t4 = null == e4 ? i2 <= h || v <= \
i2 ? W(V(r3.c), i2) : H(V(r3.c), i2, \"0\") : 10 === e4 ? H(V((r3 = E(new \
A(r3), b + i2 + 1, w)).c), r3.e, \"0\") : (Z(e4, 2, M.length, \"Base\"), \
f(H(V(r3.c), i2, \"0\"), 10, e4, n2, true)), n2 < 0 && r3.c[0] && (t4 = \"-\" \
+ t4)), t4;\n            }, n.valueOf = n.toJSON = function() {\n             \
 return F(this);\n            }, n._isBigNumber = true, \"function\" == \
typeof Symbol && \"symbol\" == typeof Symbol.iterator && \
(n[Symbol.toStringTag] = \"BigNumber\", \
n[Symbol.for(\"nodejs.util.inspect.custom\")] = n.valueOf), null != t3 && \
A.set(t3), A;\n          }()).default = t2.BigNumber = t2, void 0 !== r && \
r.exports ? r.exports = t2 : (e2 || (e2 = \"undefined\" != typeof self && \
self ? self : window), e2.BigNumber = t2);\n        }(this);\n      }, {}], \
2: [function(e, t, r) {\n        \"use strict\";\n        t.exports = { \
languageTag: \"en-US\", delimiters: { thousands: \",\", decimal: \".\" }, \
abbreviations: { thousand: \"k\", million: \"m\", billion: \"b\", trillion: \
\"t\" }, spaceSeparated: false, ordinal: function(e2) {\n          var t2 = \
e2 % 10;\n          return 1 == ~~(e2 % 100 / 10) ? \"th\" : 1 === t2 ? \
\"st\" : 2 === t2 ? \"nd\" : 3 === t2 ? \"rd\" : \"th\";\n        }, \
currency: { symbol: \"$\", position: \"prefix\", code: \"USD\" }, \
currencyFormat: { thousandSeparated: true, totalLength: 4, spaceSeparated: \
true }, formats: { fourDigits: { totalLength: 4, spaceSeparated: true }, \
fullWithTwoDecimals: { output: \"currency\", thousandSeparated: true, \
mantissa: 2 }, fullWithTwoDecimalsNoCurrency: { thousandSeparated: true, \
mantissa: 2 }, fullWithNoDecimals: { output: \"currency\", thousandSeparated: \
true, mantissa: 0 } } };\n      }, {}], 3: [function(e, t, r) {\n        \
\"use strict\";\n        function C(e2, t2) {\n          return function(e3) \
{\n            if (Array.isArray(e3))\n              return e3;\n          \
}(e2) || function(e3, t3) {\n            var r2 = [], n2 = true, i2 = false, \
a = void 0;\n            try {\n              for (var o2, u2 = \
e3[Symbol.iterator](); !(n2 = (o2 = u2.next()).done) && (r2.push(o2.value), \
!t3 || r2.length !== t3); n2 = true)\n                ;\n            } catch \
(e4) {\n              i2 = true, a = e4;\n            } finally {\n           \
   try {\n                n2 || null == u2.return || u2.return();\n           \
   } finally {\n                if (i2)\n                  throw a;\n         \
     }\n            }\n            return r2;\n          }(e2, t2) || \
function() {\n            throw new TypeError(\"Invalid attempt to \
destructure non-iterable instance\");\n          }();\n        }\n        var \
R = e(\"./globalState\"), o = e(\"./validating\"), u = e(\"./parsing\"), n = \
[\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"], M = \
{ general: { scale: 1024, suffixes: n, marker: \"bd\" }, binary: { scale: \
1024, suffixes: [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \
\"ZiB\", \"YiB\"], marker: \"b\" }, decimal: { scale: 1e3, suffixes: n, \
marker: \"d\" } }, I = { totalLength: 0, characteristic: 0, forceAverage: \
false, average: false, mantissa: -1, optionalMantissa: true, \
thousandSeparated: false, spaceSeparated: false, negative: \"sign\", \
forceSign: false };\n        function i(e2) {\n          var t2 = 1 < \
arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, r2 = 2 < \
arguments.length ? arguments[2] : void 0;\n          if (\"string\" == typeof \
t2 && (t2 = u.parseFormat(t2)), !o.validateFormat(t2))\n            return \
\"ERROR: invalid format\";\n          var n2 = t2.prefix || \"\", i2 = \
t2.postfix || \"\", a = function(e3, t3, r3) {\n            switch \
(t3.output) {\n              case \"currency\":\n                return t3 = \
A(t3, R.currentCurrencyDefaultFormat()), function(e4, t4, r4) {\n             \
     var n4 = r4.currentCurrency(), i4 = Object.assign({}, I, t4), a3 = void \
0, o3 = \"\", u3 = !!i4.totalLength || !!i4.forceAverage || i4.average, c2 = \
t4.currencyPosition || n4.position, s2 = t4.currencySymbol || n4.symbol;\n    \
              i4.spaceSeparated && (o3 = \" \");\n                  \"infix\" \
=== c2 && (a3 = o3 + s2 + o3);\n                  var l2 = D({ instance: e4, \
providedFormat: t4, state: r4, decimalSeparator: a3 });\n                  \
\"prefix\" === c2 && (l2 = e4._value < 0 && \"sign\" === i4.negative ? \
\"-\".concat(o3).concat(s2).concat(l2.slice(1)) : s2 + o3 + l2);\n            \
      c2 && \"postfix\" !== c2 || (l2 = l2 + (o3 = u3 ? \"\" : o3) + s2);\n   \
               return l2;\n                }(e3, t3, R);\n              case \
\"percent\":\n                return t3 = A(t3, \
R.currentPercentageDefaultFormat()), function(e4, t4, r4, n4) {\n             \
     var i4 = t4.prefixSymbol, a3 = D({ instance: n4(100 * e4._value), \
providedFormat: t4, state: r4 }), o3 = Object.assign({}, I, t4);\n            \
      if (i4)\n                    return \"%\".concat(o3.spaceSeparated ? \" \
\" : \"\").concat(a3);\n                  return \
\"\".concat(a3).concat(o3.spaceSeparated ? \" \" : \"\", \"%\");\n            \
    }(e3, t3, R, r3);\n              case \"byte\":\n                return \
t3 = A(t3, R.currentByteDefaultFormat()), h = e3, v = R, m = r3, y = (d = \
t3).base || \"binary\", b = M[y], w = B(h._value, b.suffixes, b.scale), O = \
w.value, x = w.suffix, S = D({ instance: m(O), providedFormat: d, state: v, \
defaults: v.currentByteDefaultFormat() }), N = v.currentAbbreviations(), \
\"\".concat(S).concat(N.spaced ? \" \" : \"\").concat(x);\n              case \
\"time\":\n                return t3 = A(t3, R.currentTimeDefaultFormat()), l \
= e3, f = Math.floor(l._value / 60 / 60), p2 = Math.floor((l._value - 60 * f \
* 60) / 60), g = Math.round(l._value - 60 * f * 60 - 60 * p2), \"\".concat(f, \
\":\").concat(p2 < 10 ? \"0\" : \"\").concat(p2, \":\").concat(g < 10 ? \"0\" \
: \"\").concat(g);\n              case \"ordinal\":\n                return \
t3 = A(t3, R.currentOrdinalDefaultFormat()), n3 = e3, i3 = t3, o2 = (a2 = \
R).currentOrdinal(), u2 = Object.assign({}, I, i3), c = D({ instance: n3, \
providedFormat: i3, state: a2 }), s = o2(n3._value), \
\"\".concat(c).concat(u2.spaceSeparated ? \" \" : \"\").concat(s);\n          \
    case \"number\":\n              default:\n                return D({ \
instance: e3, providedFormat: t3, numbro: r3 });\n            }\n            \
var n3, i3, a2, o2, u2, c, s;\n            var l, f, p2, g;\n            var \
h, d, v, m, y, b, w, O, x, S, N;\n          }(e2, t2, r2);\n          return \
a = (a = n2 + a) + i2;\n        }\n        function B(e2, t2, r2) {\n         \
 var n2 = t2[0], i2 = Math.abs(e2);\n          if (r2 <= i2) {\n            \
for (var a = 1; a < t2.length; ++a) {\n              var o2 = Math.pow(r2, \
a), u2 = Math.pow(r2, a + 1);\n              if (o2 <= i2 && i2 < u2) {\n     \
           n2 = t2[a], e2 /= o2;\n                break;\n              }\n   \
         }\n            n2 === t2[0] && (e2 /= Math.pow(r2, t2.length - 1), \
n2 = t2[t2.length - 1]);\n          }\n          return { value: e2, suffix: \
n2 };\n        }\n        function p(e2) {\n          for (var t2 = \"\", r2 \
= 0; r2 < e2; r2++)\n            t2 += \"0\";\n          return t2;\n        \
}\n        function $6(e2, t2) {\n          return -1 !== \
e2.toString().indexOf(\"e\") ? function(e3, t3) {\n            var r2 = \
e3.toString(), n2 = C(r2.split(\"e\"), 2), i2 = n2[0], a = n2[1], o2 = \
C(i2.split(\".\"), 2), u2 = o2[0], c = o2[1], s = void 0 === c ? \"\" : c;\n  \
          if (0 < +a)\n              r2 = u2 + s + p(a - s.length);\n         \
   else {\n              var l = \".\";\n              l = +u2 < 0 ? \
\"-0\".concat(l) : \"0\".concat(l);\n              var f = (p(-a - 1) + \
Math.abs(u2) + s).substr(0, t3);\n              f.length < t3 && (f += p(t3 - \
f.length)), r2 = l + f;\n            }\n            return 0 < +a && 0 < t3 \
&& (r2 += \".\".concat(p(t3))), r2;\n          }(e2, t2) : \
(Math.round(+\"\".concat(e2, \"e+\").concat(t2)) / Math.pow(10, \
t2)).toFixed(t2);\n        }\n        function D(e2) {\n          var t2 = \
e2.instance, r2 = e2.providedFormat, n2 = e2.state, i2 = void 0 === n2 ? R : \
n2, a = e2.decimalSeparator, o2 = e2.defaults, u2 = void 0 === o2 ? \
i2.currentDefaults() : o2, c = t2._value;\n          if (0 === c && \
i2.hasZeroFormat())\n            return i2.getZeroFormat();\n          if \
(!isFinite(c))\n            return c.toString();\n          var s, l, f, p2, \
g, h, d, v, m = Object.assign({}, I, u2, r2), y = m.totalLength, b = y ? 0 : \
m.characteristic, w = m.optionalCharacteristic, O = m.forceAverage, x = !!y \
|| !!O || m.average, S = y ? -1 : x && void 0 === r2.mantissa ? 0 : \
m.mantissa, N = !y && (void 0 === r2.optionalMantissa ? -1 === S : \
m.optionalMantissa), M2 = m.trimMantissa, B2 = m.thousandSeparated, D2 = \
m.spaceSeparated, A2 = m.negative, E = m.forceSign, F = m.exponential, k = \
\"\";\n          if (x) {\n            var _ = function(e3) {\n              \
var t3 = e3.value, r3 = e3.forceAverage, n3 = e3.abbreviations, i3 = \
e3.spaceSeparated, a2 = void 0 !== i3 && i3, o3 = e3.totalLength, u3 = void 0 \
=== o3 ? 0 : o3, c2 = \"\", s2 = Math.abs(t3), l2 = -1;\n              if (s2 \
>= Math.pow(10, 12) && !r3 || \"trillion\" === r3 ? (c2 = n3.trillion, t3 /= \
Math.pow(10, 12)) : s2 < Math.pow(10, 12) && s2 >= Math.pow(10, 9) && !r3 || \
\"billion\" === r3 ? (c2 = n3.billion, t3 /= Math.pow(10, 9)) : s2 < \
Math.pow(10, 9) && s2 >= Math.pow(10, 6) && !r3 || \"million\" === r3 ? (c2 = \
n3.million, t3 /= Math.pow(10, 6)) : (s2 < Math.pow(10, 6) && s2 >= \
Math.pow(10, 3) && !r3 || \"thousand\" === r3) && (c2 = n3.thousand, t3 /= \
Math.pow(10, 3)), c2 && (c2 = (a2 ? \" \" : \"\") + c2), u3) {\n              \
  var f2 = t3.toString().split(\".\")[0];\n                l2 = Math.max(u3 - \
f2.length, 0);\n              }\n              return { value: t3, \
abbreviation: c2, mantissaPrecision: l2 };\n            }({ value: c, \
forceAverage: O, abbreviations: i2.currentAbbreviations(), spaceSeparated: \
D2, totalLength: y });\n            c = _.value, k += _.abbreviation, y && (S \
= _.mantissaPrecision);\n          }\n          if (F) {\n            var L = \
(l = (s = { value: c, characteristicPrecision: b }).value, f = \
s.characteristicPrecision, p2 = void 0 === f ? 0 : f, g = \
C(l.toExponential().split(\"e\"), 2), h = g[0], d = g[1], v = +h, p2 && 1 < \
p2 && (v *= Math.pow(10, p2 - 1), d = 0 <= (d = +d - (p2 - 1)) ? \
\"+\".concat(d) : d), { value: v, abbreviation: \"e\".concat(d) });\n         \
   c = L.value, k = L.abbreviation + k;\n          }\n          var T, P, U, \
j = function(e3, t3, r3, n3, i3) {\n            if (-1 === n3)\n              \
return e3;\n            var a2 = $6(t3, n3), o3 = \
C(a2.toString().split(\".\"), 2), u3 = o3[0], c2 = o3[1], s2 = void 0 === c2 \
? \"\" : c2;\n            if (s2.match(/^0+$/) && (r3 || i3))\n              \
return u3;\n            var l2 = s2.match(/0+$/);\n            return i3 && \
l2 ? \"\".concat(u3, \".\").concat(s2.toString().slice(0, l2.index)) : \
a2.toString();\n          }(c.toString(), c, N, S, M2);\n          return j = \
function(e3, t3, r3, n3, i3) {\n            var a2 = n3.currentDelimiters(), \
o3 = a2.thousands;\n            i3 = i3 || a2.decimal;\n            var u3 = \
a2.thousandsSize || 3, c2 = e3.toString(), s2 = c2.split(\".\")[0], l2 = \
c2.split(\".\")[1];\n            return r3 && (t3 < 0 && (s2 = s2.slice(1)), \
function(e4, t4) {\n              for (var r4 = [], n4 = 0, i4 = e4; 0 < i4; \
i4--)\n                n4 === t4 && (r4.unshift(i4), n4 = 0), n4++;\n         \
     return r4;\n            }(s2.length, u3).forEach(function(e4, t4) {\n    \
          s2 = s2.slice(0, e4 + t4) + o3 + s2.slice(e4 + t4);\n            \
}), t3 < 0 && (s2 = \"-\".concat(s2))), c2 = l2 ? s2 + i3 + l2 : s2;\n        \
  }(j = function(e3, t3, r3, n3) {\n            var i3 = e3, a2 = \
C(i3.toString().split(\".\"), 2), o3 = a2[0], u3 = a2[1];\n            if \
(o3.match(/^-?0$/) && r3)\n              return u3 ? \
\"\".concat(o3.replace(\"0\", \"\"), \".\").concat(u3) : o3.replace(\"0\", \
\"\");\n            if (o3.length < n3)\n              for (var c2 = n3 - \
o3.length, s2 = 0; s2 < c2; s2++)\n                i3 = \"0\".concat(i3);\n   \
         return i3.toString();\n          }(j, 0, w, b), c, B2, i2, a), (x || \
F) && (j = j + k), (E || c < 0) && (T = j, U = A2, j = 0 === (P = c) ? T : 0 \
== +T ? T.replace(\"-\", \"\") : 0 < P ? \"+\".concat(T) : \"sign\" === U ? T \
: \"(\".concat(T.replace(\"-\", \"\"), \")\")), j;\n        }\n        \
function A(e2, t2) {\n          if (!e2)\n            return t2;\n          \
var r2 = Object.keys(e2);\n          return 1 === r2.length && \"output\" === \
r2[0] ? t2 : e2;\n        }\n        t.exports = function(n2) {\n          \
return { format: function() {\n            for (var e2 = arguments.length, t2 \
= new Array(e2), r2 = 0; r2 < e2; r2++)\n              t2[r2] = \
arguments[r2];\n            return i.apply(void 0, t2.concat([n2]));\n        \
  }, getByteUnit: function() {\n            for (var e2 = arguments.length, \
t2 = new Array(e2), r2 = 0; r2 < e2; r2++)\n              t2[r2] = \
arguments[r2];\n            return function(e3) {\n              var t3 = \
M.general;\n              return B(e3._value, t3.suffixes, \
t3.scale).suffix;\n            }.apply(void 0, t2.concat([n2]));\n          \
}, getBinaryByteUnit: function() {\n            for (var e2 = \
arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)\n              \
t2[r2] = arguments[r2];\n            return function(e3) {\n              var \
t3 = M.binary;\n              return B(e3._value, t3.suffixes, \
t3.scale).suffix;\n            }.apply(void 0, t2.concat([n2]));\n          \
}, getDecimalByteUnit: function() {\n            for (var e2 = \
arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)\n              \
t2[r2] = arguments[r2];\n            return function(e3) {\n              var \
t3 = M.decimal;\n              return B(e3._value, t3.suffixes, \
t3.scale).suffix;\n            }.apply(void 0, t2.concat([n2]));\n          \
}, formatOrDefault: A };\n        };\n      }, { \"./globalState\": 4, \
\"./parsing\": 8, \"./validating\": 10 }], 4: [function(e, t, r) {\n        \
\"use strict\";\n        var i = e(\"./en-US\"), n = e(\"./validating\"), a = \
e(\"./parsing\"), o = {}, u = void 0, c = {}, s = null, l = {};\n        \
function f(e2) {\n          u = e2;\n        }\n        function p() {\n      \
    return c[u];\n        }\n        o.languages = function() {\n          \
return Object.assign({}, c);\n        }, o.currentLanguage = function() {\n   \
       return u;\n        }, o.currentCurrency = function() {\n          \
return p().currency;\n        }, o.currentAbbreviations = function() {\n      \
    return p().abbreviations;\n        }, o.currentDelimiters = function() \
{\n          return p().delimiters;\n        }, o.currentOrdinal = function() \
{\n          return p().ordinal;\n        }, o.currentDefaults = function() \
{\n          return Object.assign({}, p().defaults, l);\n        }, \
o.currentOrdinalDefaultFormat = function() {\n          return \
Object.assign({}, o.currentDefaults(), p().ordinalFormat);\n        }, \
o.currentByteDefaultFormat = function() {\n          return Object.assign({}, \
o.currentDefaults(), p().byteFormat);\n        }, \
o.currentPercentageDefaultFormat = function() {\n          return \
Object.assign({}, o.currentDefaults(), p().percentageFormat);\n        }, \
o.currentCurrencyDefaultFormat = function() {\n          return \
Object.assign({}, o.currentDefaults(), p().currencyFormat);\n        }, \
o.currentTimeDefaultFormat = function() {\n          return Object.assign({}, \
o.currentDefaults(), p().timeFormat);\n        }, o.setDefaults = \
function(e2) {\n          e2 = a.parseFormat(e2), n.validateFormat(e2) && (l \
= e2);\n        }, o.getZeroFormat = function() {\n          return s;\n      \
  }, o.setZeroFormat = function(e2) {\n          return s = \"string\" == \
typeof e2 ? e2 : null;\n        }, o.hasZeroFormat = function() {\n          \
return null !== s;\n        }, o.languageData = function(e2) {\n          if \
(e2) {\n            if (c[e2])\n              return c[e2];\n            \
throw new Error('Unknown tag \"'.concat(e2, '\"'));\n          }\n          \
return p();\n        }, o.registerLanguage = function(e2) {\n          var t2 \
= 1 < arguments.length && void 0 !== arguments[1] && arguments[1];\n          \
if (!n.validateLanguage(e2))\n            throw new Error(\"Invalid language \
data\");\n          c[e2.languageTag] = e2, t2 && f(e2.languageTag);\n        \
}, o.setLanguage = function(e2) {\n          var t2 = 1 < arguments.length && \
void 0 !== arguments[1] ? arguments[1] : i.languageTag;\n          if \
(!c[e2]) {\n            var r2 = e2.split(\"-\")[0], n2 = \
Object.keys(c).find(function(e3) {\n              return e3.split(\"-\")[0] \
=== r2;\n            });\n            return c[n2] ? void f(n2) : void \
f(t2);\n          }\n          f(e2);\n        }, o.registerLanguage(i), u = \
i.languageTag, t.exports = o;\n      }, { \"./en-US\": 2, \"./parsing\": 8, \
\"./validating\": 10 }], 5: [function(n, e, t) {\n        \"use strict\";\n   \
     e.exports = function(t2) {\n          return { loadLanguagesInNode: \
function(e2) {\n            return r = t2, void e2.forEach(function(t3) {\n   \
           var e3 = void 0;\n              try {\n                e3 = \
n(\"../languages/\".concat(t3));\n              } catch (e4) {\n              \
  console.error('Unable to load \"'.concat(t3, '\". No matching language file \
found.'));\n              }\n              e3 && r.registerLanguage(e3);\n    \
        });\n            var r;\n          } };\n        };\n      }, {}], 6: \
[function(e, t, r) {\n        \"use strict\";\n        var c = \
e(\"bignumber.js\");\n        function a(e2, t2, r2) {\n          var n = new \
c(e2._value), i = t2;\n          return r2.isNumbro(t2) && (i = t2._value), i \
= new c(i), e2._value = n.minus(i).toNumber(), e2;\n        }\n        \
t.exports = function(u) {\n          return { add: function(e2, t2) {\n       \
     return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) \
&& (o = n._value), o = new c(o), r2._value = a2.plus(o).toNumber(), r2;\n     \
       var r2, n, i, a2, o;\n          }, subtract: function(e2, t2) {\n      \
      return a(e2, t2, u);\n          }, multiply: function(e2, t2) {\n       \
     return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) \
&& (o = n._value), o = new c(o), r2._value = a2.times(o).toNumber(), r2;\n    \
        var r2, n, i, a2, o;\n          }, divide: function(e2, t2) {\n       \
     return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) \
&& (o = n._value), o = new c(o), r2._value = a2.dividedBy(o).toNumber(), \
r2;\n            var r2, n, i, a2, o;\n          }, set: function(e2, t2) {\n \
           return r2 = e2, i = n = t2, u.isNumbro(n) && (i = n._value), \
r2._value = i, r2;\n            var r2, n, i;\n          }, difference: \
function(e2, t2) {\n            return r2 = t2, a(i = (n = u)(e2._value), r2, \
n), Math.abs(i._value);\n            var r2, n, i;\n          } };\n        \
};\n      }, { \"bignumber.js\": 1 }], 7: [function(e, t, r) {\n        \"use \
strict\";\n        function i(e2, t2) {\n          for (var r2 = 0; r2 < \
t2.length; r2++) {\n            var n2 = t2[r2];\n            n2.enumerable = \
n2.enumerable || false, n2.configurable = true, \"value\" in n2 && \
(n2.writable = true), Object.defineProperty(e2, n2.key, n2);\n          }\n   \
     }\n        var a = e(\"./globalState\"), n = e(\"./validating\"), o = \
e(\"./loading\")(g), u = e(\"./unformatting\"), c = e(\"./formatting\")(g), s \
= e(\"./manipulating\")(g), l = e(\"./parsing\"), f = function() {\n          \
function t2(e3) {\n            !function(e4, t3) {\n              if (!(e4 \
instanceof t3))\n                throw new TypeError(\"Cannot call a class as \
a function\");\n            }(this, t2), this._value = e3;\n          }\n     \
     var e2, r2, n2;\n          return e2 = t2, (r2 = [{ key: \"clone\", \
value: function() {\n            return g(this._value);\n          } }, { \
key: \"format\", value: function() {\n            var e3 = 0 < \
arguments.length && void 0 !== arguments[0] ? arguments[0] : {};\n            \
return c.format(this, e3);\n          } }, { key: \"formatCurrency\", value: \
function(e3) {\n            return \"string\" == typeof e3 && (e3 = \
l.parseFormat(e3)), (e3 = c.formatOrDefault(e3, \
a.currentCurrencyDefaultFormat())).output = \"currency\", c.format(this, \
e3);\n          } }, { key: \"formatTime\", value: function() {\n            \
var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : \
{};\n            return e3.output = \"time\", c.format(this, e3);\n          \
} }, { key: \"binaryByteUnits\", value: function() {\n            return \
c.getBinaryByteUnit(this);\n          } }, { key: \"decimalByteUnits\", \
value: function() {\n            return c.getDecimalByteUnit(this);\n         \
 } }, { key: \"byteUnits\", value: function() {\n            return \
c.getByteUnit(this);\n          } }, { key: \"difference\", value: \
function(e3) {\n            return s.difference(this, e3);\n          } }, { \
key: \"add\", value: function(e3) {\n            return s.add(this, e3);\n    \
      } }, { key: \"subtract\", value: function(e3) {\n            return \
s.subtract(this, e3);\n          } }, { key: \"multiply\", value: \
function(e3) {\n            return s.multiply(this, e3);\n          } }, { \
key: \"divide\", value: function(e3) {\n            return s.divide(this, \
e3);\n          } }, { key: \"set\", value: function(e3) {\n            \
return s.set(this, p(e3));\n          } }, { key: \"value\", value: \
function() {\n            return this._value;\n          } }, { key: \
\"valueOf\", value: function() {\n            return this._value;\n          \
} }]) && i(e2.prototype, r2), n2 && i(e2, n2), t2;\n        }();\n        \
function p(e2) {\n          var t2 = e2;\n          return g.isNumbro(e2) ? \
t2 = e2._value : \"string\" == typeof e2 ? t2 = g.unformat(e2) : isNaN(e2) && \
(t2 = NaN), t2;\n        }\n        function g(e2) {\n          return new \
f(p(e2));\n        }\n        g.version = \"2.1.2\", g.isNumbro = \
function(e2) {\n          return e2 instanceof f;\n        }, g.language = \
a.currentLanguage, g.registerLanguage = a.registerLanguage, g.setLanguage = \
a.setLanguage, g.languages = a.languages, g.languageData = a.languageData, \
g.zeroFormat = a.setZeroFormat, g.defaultFormat = a.currentDefaults, \
g.setDefaults = a.setDefaults, g.defaultCurrencyFormat = \
a.currentCurrencyDefaultFormat, g.validate = n.validate, \
g.loadLanguagesInNode = o.loadLanguagesInNode, g.unformat = u.unformat, \
t.exports = g;\n      }, { \"./formatting\": 3, \"./globalState\": 4, \
\"./loading\": 5, \"./manipulating\": 6, \"./parsing\": 8, \
\"./unformatting\": 9, \"./validating\": 10 }], 8: [function(e, t, r) {\n     \
   \"use strict\";\n        t.exports = { parseFormat: function(e2) {\n       \
   var t2, r2, n, i, a, o, u, c, s, l, f, p, g, h, d, v, m, y, b, w, O = 1 < \
arguments.length && void 0 !== arguments[1] ? arguments[1] : {};\n          \
return \"string\" != typeof e2 ? e2 : (r2 = O, e2 = (n = (t2 = \
e2).match(/^{([^}]*)}/)) ? (r2.prefix = n[1], t2.slice(n[0].length)) : t2, a \
= O, function(e3, t3) {\n            if (-1 === e3.indexOf(\"$\")) {\n        \
      if (-1 === e3.indexOf(\"%\"))\n                return -1 !== \
e3.indexOf(\"bd\") ? (t3.output = \"byte\", t3.base = \"general\") : -1 !== \
e3.indexOf(\"b\") ? (t3.output = \"byte\", t3.base = \"binary\") : -1 !== \
e3.indexOf(\"d\") ? (t3.output = \"byte\", t3.base = \"decimal\") : -1 === \
e3.indexOf(\":\") ? -1 !== e3.indexOf(\"o\") && (t3.output = \"ordinal\") : \
t3.output = \"time\";\n              t3.output = \"percent\";\n            } \
else\n              t3.output = \"currency\";\n          }(e2 = (o = (i = \
e2).match(/{([^}]*)}$/)) ? (a.postfix = o[1], i.slice(0, -o[0].length)) : i, \
O), u = O, (c = e2.match(/[1-9]+[0-9]*/)) && (u.totalLength = +c[0]), s = O, \
(l = e2.split(\".\")[0].match(/0+/)) && (s.characteristic = l[0].length), \
function(e3, t3) {\n            if (-1 !== e3.indexOf(\".\")) {\n             \
 var r3 = e3.split(\".\")[0];\n              t3.optionalCharacteristic = -1 \
=== r3.indexOf(\"0\");\n            }\n          }(e2, O), f = O, -1 !== \
e2.indexOf(\"a\") && (f.average = true), g = O, -1 !== (p = \
e2).indexOf(\"K\") ? g.forceAverage = \"thousand\" : -1 !== p.indexOf(\"M\") \
? g.forceAverage = \"million\" : -1 !== p.indexOf(\"B\") ? g.forceAverage = \
\"billion\" : -1 !== p.indexOf(\"T\") && (g.forceAverage = \"trillion\"), \
function(e3, t3) {\n            var r3 = e3.split(\".\")[1];\n            if \
(r3) {\n              var n2 = r3.match(/0+/);\n              n2 && \
(t3.mantissa = n2[0].length);\n            }\n          }(e2, O), d = O, (h = \
e2).match(/\\[\\.]/) ? d.optionalMantissa = true : h.match(/\\./) && \
(d.optionalMantissa = false), v = O, -1 !== e2.indexOf(\",\") && \
(v.thousandSeparated = true), m = O, -1 !== e2.indexOf(\" \") && \
(m.spaceSeparated = true), b = O, (y = e2).match(/^\\+?\\([^)]*\\)$/) && \
(b.negative = \"parenthesis\"), y.match(/^\\+?-/) && (b.negative = \"sign\"), \
w = O, e2.match(/^\\+/) && (w.forceSign = true), O);\n        } };\n      }, \
{}], 9: [function(p, e, t) {\n        \"use strict\";\n        var O = [{ \
key: \"ZiB\", factor: Math.pow(1024, 7) }, { key: \"ZB\", factor: \
Math.pow(1e3, 7) }, { key: \"YiB\", factor: Math.pow(1024, 8) }, { key: \
\"YB\", factor: Math.pow(1e3, 8) }, { key: \"TiB\", factor: Math.pow(1024, 4) \
}, { key: \"TB\", factor: Math.pow(1e3, 4) }, { key: \"PiB\", factor: \
Math.pow(1024, 5) }, { key: \"PB\", factor: Math.pow(1e3, 5) }, { key: \
\"MiB\", factor: Math.pow(1024, 2) }, { key: \"MB\", factor: Math.pow(1e3, 2) \
}, { key: \"KiB\", factor: Math.pow(1024, 1) }, { key: \"KB\", factor: \
Math.pow(1e3, 1) }, { key: \"GiB\", factor: Math.pow(1024, 3) }, { key: \
\"GB\", factor: Math.pow(1e3, 3) }, { key: \"EiB\", factor: Math.pow(1024, 6) \
}, { key: \"EB\", factor: Math.pow(1e3, 6) }, { key: \"B\", factor: 1 }];\n   \
     function x(e2) {\n          return \
e2.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n        }\n        \
function g(e2, t2) {\n          var r = 2 < arguments.length && void 0 !== \
arguments[2] ? arguments[2] : \"\", n = 3 < arguments.length ? arguments[3] : \
void 0, i = 4 < arguments.length ? arguments[4] : void 0, a = 5 < \
arguments.length ? arguments[5] : void 0, o = 6 < arguments.length ? \
arguments[6] : void 0;\n          if (\"\" !== e2)\n            return e2 === \
i ? 0 : function e3(t3, r2) {\n              var n2 = 2 < arguments.length && \
void 0 !== arguments[2] ? arguments[2] : \"\", i2 = 3 < arguments.length ? \
arguments[3] : void 0, a2 = 4 < arguments.length ? arguments[4] : void 0, o2 \
= 5 < arguments.length ? arguments[5] : void 0, u = 6 < arguments.length ? \
arguments[6] : void 0;\n              if (!isNaN(+t3))\n                \
return +t3;\n              var c = \"\", s = \
t3.replace(/(^[^(]*)\\((.*)\\)([^)]*$)/, \"$1$2$3\");\n              if (s \
!== t3)\n                return -1 * e3(s, r2, n2, i2, a2, o2, u);\n          \
    for (var l = 0; l < O.length; l++) {\n                var f = O[l];\n     \
           if ((c = t3.replace(f.key, \"\")) !== t3)\n                  \
return e3(c, r2, n2, i2, a2, o2, u) * f.factor;\n              }\n            \
  if ((c = t3.replace(\"%\", \"\")) !== t3)\n                return e3(c, r2, \
n2, i2, a2, o2, u) / 100;\n              var p2 = parseFloat(t3);\n           \
   if (!isNaN(p2)) {\n                var g2 = i2(p2);\n                if \
(g2 && \".\" !== g2 && (c = t3.replace(new RegExp(\"\".concat(x(g2), \"$\")), \
\"\")) !== t3)\n                  return e3(c, r2, n2, i2, a2, o2, u);\n      \
          var h = {};\n                Object.keys(o2).forEach(function(e4) \
{\n                  h[o2[e4]] = e4;\n                });\n                \
for (var d = Object.keys(h).sort().reverse(), v = d.length, m = 0; m < v; \
m++) {\n                  var y = d[m], b = h[y];\n                  if ((c = \
t3.replace(y, \"\")) !== t3) {\n                    var w = void 0;\n         \
           switch (b) {\n                      case \"thousand\":\n           \
             w = Math.pow(10, 3);\n                        break;\n           \
           case \"million\":\n                        w = Math.pow(10, 6);\n  \
                      break;\n                      case \"billion\":\n       \
                 w = Math.pow(10, 9);\n                        break;\n       \
               case \"trillion\":\n                        w = Math.pow(10, \
12);\n                    }\n                    return e3(c, r2, n2, i2, a2, \
o2, u) * w;\n                  }\n                }\n              }\n        \
    }(function(e3, t3) {\n              var r2 = 2 < arguments.length && void \
0 !== arguments[2] ? arguments[2] : \"\", n2 = e3.replace(r2, \"\");\n        \
      return n2 = (n2 = n2.replace(new \
RegExp(\"([0-9])\".concat(x(t3.thousands), \"([0-9])\"), \"g\"), \
\"$1$2\")).replace(t3.decimal, \".\");\n            }(e2, t2, r), t2, r, n, \
i, a, o);\n        }\n        e.exports = { unformat: function(e2, t2) {\n    \
      var r, n, i, a = p(\"./globalState\"), o = a.currentDelimiters(), u = \
a.currentCurrency().symbol, c = a.currentOrdinal(), s = a.getZeroFormat(), l \
= a.currentAbbreviations(), f = void 0;\n          if (\"string\" == typeof \
e2)\n            f = function(e3, t3) {\n              if (!e3.indexOf(\":\") \
|| \":\" === t3.thousands)\n                return false;\n              var \
r2 = e3.split(\":\");\n              if (3 !== r2.length)\n                \
return false;\n              var n2 = +r2[0], i2 = +r2[1], a2 = +r2[2];\n     \
         return !isNaN(n2) && !isNaN(i2) && !isNaN(a2);\n            }(e2, o) \
? (r = e2.split(\":\"), n = +r[0], i = +r[1], +r[2] + 60 * i + 3600 * n) : \
g(e2, o, u, c, s, l, t2);\n          else {\n            if (\"number\" != \
typeof e2)\n              return;\n            f = e2;\n          }\n         \
 if (void 0 !== f)\n            return f;\n        } };\n      }, { \
\"./globalState\": 4 }], 10: [function(e, t, r) {\n        \"use strict\";\n  \
      function n(e2) {\n          return function(e3) {\n            if \
(Array.isArray(e3)) {\n              for (var t2 = 0, r2 = new \
Array(e3.length); t2 < e3.length; t2++)\n                r2[t2] = e3[t2];\n   \
           return r2;\n            }\n          }(e2) || function(e3) {\n     \
       if (Symbol.iterator in Object(e3) || \"[object Arguments]\" === \
Object.prototype.toString.call(e3))\n              return Array.from(e3);\n   \
       }(e2) || function() {\n            throw new TypeError(\"Invalid \
attempt to spread non-iterable instance\");\n          }();\n        }\n      \
  function f(e2) {\n          return (f = \"function\" == typeof Symbol && \
\"symbol\" == typeof Symbol.iterator ? function(e3) {\n            return \
typeof e3;\n          } : function(e3) {\n            return e3 && \
\"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== \
Symbol.prototype ? \"symbol\" : typeof e3;\n          })(e2);\n        }\n    \
    var i = e(\"./unformatting\"), a = \
/^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/, p = { output: { type: \
\"string\", validValues: [\"currency\", \"percent\", \"byte\", \"time\", \
\"ordinal\", \"number\"] }, base: { type: \"string\", validValues: \
[\"decimal\", \"binary\", \"general\"], restriction: function(e2, t2) {\n     \
     return \"byte\" === t2.output;\n        }, message: \"`base` must be \
provided only when the output is `byte`\", mandatory: function(e2) {\n        \
  return \"byte\" === e2.output;\n        } }, characteristic: { type: \
\"number\", restriction: function(e2) {\n          return 0 <= e2;\n        \
}, message: \"value must be positive\" }, prefix: \"string\", postfix: \
\"string\", forceAverage: { type: \"string\", validValues: [\"trillion\", \
\"billion\", \"million\", \"thousand\"] }, average: \"boolean\", \
currencyPosition: { type: \"string\", validValues: [\"prefix\", \"infix\", \
\"postfix\"] }, currencySymbol: \"string\", totalLength: { type: \"number\", \
restrictions: [{ restriction: function(e2) {\n          return 0 <= e2;\n     \
   }, message: \"value must be positive\" }, { restriction: function(e2, t2) \
{\n          return !t2.exponential;\n        }, message: \"`totalLength` is \
incompatible with `exponential`\" }] }, mantissa: { type: \"number\", \
restriction: function(e2) {\n          return 0 <= e2;\n        }, message: \
\"value must be positive\" }, optionalMantissa: \"boolean\", trimMantissa: \
\"boolean\", optionalCharacteristic: \"boolean\", thousandSeparated: \
\"boolean\", spaceSeparated: \"boolean\", abbreviations: { type: \"object\", \
children: { thousand: \"string\", million: \"string\", billion: \"string\", \
trillion: \"string\" } }, negative: { type: \"string\", validValues: \
[\"sign\", \"parenthesis\"] }, forceSign: \"boolean\", exponential: { type: \
\"boolean\" }, prefixSymbol: { type: \"boolean\", restriction: function(e2, \
t2) {\n          return \"percent\" === t2.output;\n        }, message: \
\"`prefixSymbol` can be provided only when the output is `percent`\" } }, o = \
{ languageTag: { type: \"string\", mandatory: true, restriction: function(e2) \
{\n          return e2.match(a);\n        }, message: \"the language tag must \
follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)\" }, \
delimiters: { type: \"object\", children: { thousands: \"string\", decimal: \
\"string\", thousandsSize: \"number\" }, mandatory: true }, abbreviations: { \
type: \"object\", children: { thousand: { type: \"string\", mandatory: true \
}, million: { type: \"string\", mandatory: true }, billion: { type: \
\"string\", mandatory: true }, trillion: { type: \"string\", mandatory: true \
} }, mandatory: true }, spaceSeparated: \"boolean\", ordinal: { type: \
\"function\", mandatory: true }, currency: { type: \"object\", children: { \
symbol: \"string\", position: \"string\", code: \"string\" }, mandatory: true \
}, defaults: \"format\", ordinalFormat: \"format\", byteFormat: \"format\", \
percentageFormat: \"format\", currencyFormat: \"format\", timeDefaults: \
\"format\", formats: { type: \"object\", children: { fourDigits: { type: \
\"format\", mandatory: true }, fullWithTwoDecimals: { type: \"format\", \
mandatory: true }, fullWithTwoDecimalsNoCurrency: { type: \"format\", \
mandatory: true }, fullWithNoDecimals: { type: \"format\", mandatory: true } \
} } };\n        function u(e2) {\n          return !!i.unformat(e2);\n        \
}\n        function g(c2, s, l) {\n          var e2 = 3 < arguments.length && \
void 0 !== arguments[3] && arguments[3], t2 = \
Object.keys(c2).map(function(e3) {\n            if (!s[e3])\n              \
return console.error(\"\".concat(l, \" Invalid key: \").concat(e3)), false;\n \
           var t3 = c2[e3], r2 = s[e3];\n            if (\"string\" == typeof \
r2 && (r2 = { type: r2 }), \"format\" === r2.type) {\n              if \
(!g(t3, p, \"[Validate \".concat(e3, \"]\"), true))\n                return \
false;\n            } else if (f(t3) !== r2.type)\n              return \
console.error(\"\".concat(l, \" \").concat(e3, ' type mismatched: \
\"').concat(r2.type, '\" expected, \"').concat(f(t3), '\" provided')), \
false;\n            if (r2.restrictions && r2.restrictions.length)\n          \
    for (var n2 = r2.restrictions.length, i2 = 0; i2 < n2; i2++) {\n          \
      var a2 = r2.restrictions[i2], o2 = a2.restriction, u2 = a2.message;\n   \
             if (!o2(t3, c2))\n                  return \
console.error(\"\".concat(l, \" \").concat(e3, \" invalid value: \
\").concat(u2)), false;\n              }\n            if (r2.restriction && \
!r2.restriction(t3, c2))\n              return console.error(\"\".concat(l, \
\" \").concat(e3, \" invalid value: \").concat(r2.message)), false;\n         \
   if (r2.validValues && -1 === r2.validValues.indexOf(t3))\n              \
return console.error(\"\".concat(l, \" \").concat(e3, \" invalid value: must \
be among \").concat(JSON.stringify(r2.validValues), ', \"').concat(t3, '\" \
provided')), false;\n            if (r2.children && !g(t3, r2.children, \
\"[Validate \".concat(e3, \"]\")))\n              return false;\n            \
return true;\n          });\n          return e2 || t2.push.apply(t2, \
n(Object.keys(s).map(function(e3) {\n            var t3 = s[e3];\n            \
if (\"string\" == typeof t3 && (t3 = { type: t3 }), t3.mandatory) {\n         \
     var r2 = t3.mandatory;\n              if (\"function\" == typeof r2 && \
(r2 = r2(c2)), r2 && void 0 === c2[e3])\n                return \
console.error(\"\".concat(l, ' Missing mandatory key \"').concat(e3, '\"')), \
false;\n            }\n            return true;\n          }))), \
t2.reduce(function(e3, t3) {\n            return e3 && t3;\n          }, \
true);\n        }\n        function c(e2) {\n          return g(e2, p, \
\"[Validate format]\");\n        }\n        t.exports = { validate: \
function(e2, t2) {\n          var r2 = u(e2), n2 = c(t2);\n          return \
r2 && n2;\n        }, validateFormat: c, validateInput: u, validateLanguage: \
function(e2) {\n          return g(e2, o, \"[Validate language]\");\n        \
} };\n      }, { \"./unformatting\": 9 }] }, {}, [7])(7);\n    });\n  \
}\n});\n\n// node_modules/core-js/internals/delete-property-or-throw.js\nvar \
require_delete_property_or_throw = __commonJS({\n  \
\"node_modules/core-js/internals/delete-property-or-throw.js\"(exports, \
module2) {\n    \"use strict\";\n    var tryToString = \
require_try_to_string();\n    var $TypeError = TypeError;\n    \
module2.exports = function(O, P) {\n      if (!delete O[P])\n        throw \
new $TypeError(\"Cannot delete property \" + tryToString(P) + \" of \" + \
tryToString(O));\n    };\n  }\n});\n\n// \
node_modules/core-js/modules/es.array.push.js\nvar $ = require_export();\nvar \
toObject = require_to_object();\nvar lengthOfArrayLike = \
require_length_of_array_like();\nvar setArrayLength = \
require_array_set_length();\nvar doesNotExceedSafeInteger = \
require_does_not_exceed_safe_integer();\nvar fails = require_fails();\nvar \
INCORRECT_TO_LENGTH = fails(function() {\n  return [].push.call({ length: \
4294967296 }, 1) !== 4294967297;\n});\nvar properErrorOnNonWritableLength = \
function() {\n  try {\n    Object.defineProperty([], \"length\", { writable: \
false }).push();\n  } catch (error2) {\n    return error2 instanceof \
TypeError;\n  }\n};\nvar FORCED = INCORRECT_TO_LENGTH || \
!properErrorOnNonWritableLength();\n$({ target: \"Array\", proto: true, \
arity: 1, forced: FORCED }, {\n  // eslint-disable-next-line no-unused-vars \
-- required for `.length`\n  push: function push(item) {\n    var O = \
toObject(this);\n    var len = lengthOfArrayLike(O);\n    var argCount = \
arguments.length;\n    doesNotExceedSafeInteger(len + argCount);\n    for \
(var i = 0; i < argCount; i++) {\n      O[len] = arguments[i];\n      \
len++;\n    }\n    setArrayLength(O, len);\n    return len;\n  }\n});\n\n// \
node_modules/core-js/modules/es.error.cause.js\nvar $2 = \
require_export();\nvar global2 = require_global();\nvar apply = \
require_function_apply();\nvar wrapErrorConstructorWithCause = \
require_wrap_error_constructor_with_cause();\nvar WEB_ASSEMBLY = \
\"WebAssembly\";\nvar WebAssembly = global2[WEB_ASSEMBLY];\nvar FORCED2 = new \
Error(\"e\", { cause: 7 }).cause !== 7;\nvar exportGlobalErrorCauseWrapper = \
function(ERROR_NAME, wrapper) {\n  var O = {};\n  O[ERROR_NAME] = \
wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED2);\n  $2({ global: \
true, constructor: true, arity: 1, forced: FORCED2 }, O);\n};\nvar \
exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {\n  if \
(WebAssembly && WebAssembly[ERROR_NAME]) {\n    var O = {};\n    \
O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + \".\" + \
ERROR_NAME, wrapper, FORCED2);\n    $2({ target: WEB_ASSEMBLY, stat: true, \
constructor: true, arity: 1, forced: FORCED2 }, O);\n  \
}\n};\nexportGlobalErrorCauseWrapper(\"Error\", function(init) {\n  return \
function Error2(message) {\n    return apply(init, this, arguments);\n  \
};\n});\nexportGlobalErrorCauseWrapper(\"EvalError\", function(init) {\n  \
return function EvalError(message) {\n    return apply(init, this, \
arguments);\n  };\n});\nexportGlobalErrorCauseWrapper(\"RangeError\", \
function(init) {\n  return function RangeError(message) {\n    return \
apply(init, this, arguments);\n  \
};\n});\nexportGlobalErrorCauseWrapper(\"ReferenceError\", function(init) {\n \
 return function ReferenceError2(message) {\n    return apply(init, this, \
arguments);\n  };\n});\nexportGlobalErrorCauseWrapper(\"SyntaxError\", \
function(init) {\n  return function SyntaxError(message) {\n    return \
apply(init, this, arguments);\n  \
};\n});\nexportGlobalErrorCauseWrapper(\"TypeError\", function(init) {\n  \
return function TypeError2(message) {\n    return apply(init, this, \
arguments);\n  };\n});\nexportGlobalErrorCauseWrapper(\"URIError\", \
function(init) {\n  return function URIError(message) {\n    return \
apply(init, this, arguments);\n  \
};\n});\nexportWebAssemblyErrorCauseWrapper(\"CompileError\", function(init) \
{\n  return function CompileError(message) {\n    return apply(init, this, \
arguments);\n  };\n});\nexportWebAssemblyErrorCauseWrapper(\"LinkError\", \
function(init) {\n  return function LinkError(message) {\n    return \
apply(init, this, arguments);\n  \
};\n});\nexportWebAssemblyErrorCauseWrapper(\"RuntimeError\", function(init) \
{\n  return function RuntimeError(message) {\n    return apply(init, this, \
arguments);\n  };\n});\n\n// \
node_modules/core-js/modules/web.immediate.js\nrequire_web_clear_immediate();\
\nrequire_web_set_immediate();\n\n// \
node_modules/handsontable/helpers/dom/element.mjs\nvar element_exports = \
{};\n__export(element_exports, {\n  HTML_CHARACTERS: () => HTML_CHARACTERS,\n \
 addClass: () => addClass,\n  addEvent: () => addEvent,\n  \
clearTextSelection: () => clearTextSelection,\n  closest: () => closest,\n  \
closestDown: () => closestDown,\n  empty: () => empty,\n  fastInnerHTML: () \
=> fastInnerHTML,\n  fastInnerText: () => fastInnerText,\n  getCaretPosition: \
() => getCaretPosition,\n  getComputedStyle: () => getComputedStyle,\n  \
getCssTransform: () => getCssTransform,\n  getFrameElement: () => \
getFrameElement,\n  getParent: () => getParent,\n  getParentWindow: () => \
getParentWindow,\n  getScrollLeft: () => getScrollLeft,\n  getScrollTop: () \
=> getScrollTop,\n  getScrollableElement: () => getScrollableElement,\n  \
getScrollbarWidth: () => getScrollbarWidth,\n  getSelectionEndPosition: () => \
getSelectionEndPosition,\n  getSelectionText: () => getSelectionText,\n  \
getStyle: () => getStyle,\n  getTrimmingContainer: () => \
getTrimmingContainer,\n  getWindowScrollLeft: () => getWindowScrollLeft,\n  \
getWindowScrollTop: () => getWindowScrollTop,\n  hasAccessToParentWindow: () \
=> hasAccessToParentWindow,\n  hasClass: () => hasClass,\n  \
hasHorizontalScrollbar: () => hasHorizontalScrollbar,\n  \
hasVerticalScrollbar: () => hasVerticalScrollbar,\n  index: () => index,\n  \
innerHeight: () => innerHeight,\n  innerWidth: () => innerWidth,\n  \
isChildOf: () => isChildOf,\n  isDetached: () => isDetached,\n  isInput: () \
=> isInput,\n  isOutsideInput: () => isOutsideInput,\n  isVisible: () => \
isVisible,\n  matchesCSSRules: () => matchesCSSRules,\n  \
observeVisibilityChangeOnce: () => observeVisibilityChangeOnce,\n  offset: () \
=> offset,\n  outerHeight: () => outerHeight,\n  outerWidth: () => \
outerWidth,\n  overlayContainsElement: () => overlayContainsElement,\n  \
removeClass: () => removeClass,\n  removeEvent: () => removeEvent,\n  \
removeTextNodes: () => removeTextNodes,\n  resetCssTransform: () => \
resetCssTransform,\n  selectElementIfAllowed: () => selectElementIfAllowed,\n \
 setCaretPosition: () => setCaretPosition,\n  setOverlayPosition: () => \
setOverlayPosition\n});\n\n// \
node_modules/handsontable/helpers/string.mjs\nvar string_exports = \
{};\n__export(string_exports, {\n  equalsIgnoreCase: () => \
equalsIgnoreCase,\n  isPercentValue: () => isPercentValue,\n  randomString: \
() => randomString,\n  sanitize: () => sanitize,\n  stripTags: () => \
stripTags,\n  substitute: () => substitute,\n  toUpperCaseFirst: () => \
toUpperCaseFirst\n});\nvar import_dompurify = __toESM(require_purify(), \
1);\n\n// node_modules/handsontable/helpers/mixed.mjs\nvar mixed_exports = \
{};\n__export(mixed_exports, {\n  _injectProductInfo: () => \
_injectProductInfo,\n  isDefined: () => isDefined,\n  isEmpty: () => \
isEmpty,\n  isRegExp: () => isRegExp,\n  isUndefined: () => isUndefined,\n  \
stringify: () => stringify\n});\nvar import_moment = \
__toESM(require_moment(), 1);\n\n// \
node_modules/handsontable/helpers/array.mjs\nvar array_exports = \
{};\n__export(array_exports, {\n  arrayAvg: () => arrayAvg,\n  arrayEach: () \
=> arrayEach,\n  arrayFilter: () => arrayFilter,\n  arrayFlatten: () => \
arrayFlatten,\n  arrayMap: () => arrayMap,\n  arrayMax: () => arrayMax,\n  \
arrayMin: () => arrayMin,\n  arrayReduce: () => arrayReduce,\n  arraySum: () \
=> arraySum,\n  arrayUnique: () => arrayUnique,\n  extendArray: () => \
extendArray,\n  getDifferenceOfArrays: () => getDifferenceOfArrays,\n  \
getIntersectionOfArrays: () => getIntersectionOfArrays,\n  getUnionOfArrays: \
() => getUnionOfArrays,\n  pivot: () => pivot,\n  stringToArray: () => \
stringToArray,\n  to2dArray: () => to2dArray\n});\nfunction to2dArray(arr) \
{\n  const ilen = arr.length;\n  let i = 0;\n  while (i < ilen) {\n    arr[i] \
= [arr[i]];\n    i += 1;\n  }\n}\nfunction extendArray(arr, extension) {\n  \
const ilen = extension.length;\n  let i = 0;\n  while (i < ilen) {\n    \
arr.push(extension[i]);\n    i += 1;\n  }\n}\nfunction pivot(arr) {\n  const \
pivotedArr = [];\n  if (!arr || arr.length === 0 || !arr[0] || arr[0].length \
=== 0) {\n    return pivotedArr;\n  }\n  const rowCount = arr.length;\n  \
const colCount = arr[0].length;\n  for (let i = 0; i < rowCount; i++) {\n    \
for (let j = 0; j < colCount; j++) {\n      if (!pivotedArr[j]) {\n        \
pivotedArr[j] = [];\n      }\n      pivotedArr[j][i] = arr[i][j];\n    }\n  \
}\n  return pivotedArr;\n}\nfunction arrayReduce(array, iteratee, \
accumulator, initFromArray) {\n  let index2 = -1;\n  let iterable = array;\n  \
let result = accumulator;\n  if (!Array.isArray(array)) {\n    iterable = \
Array.from(array);\n  }\n  const length = iterable.length;\n  if \
(initFromArray && length) {\n    index2 += 1;\n    result = \
iterable[index2];\n  }\n  index2 += 1;\n  while (index2 < length) {\n    \
result = iteratee(result, iterable[index2], index2, iterable);\n    index2 += \
1;\n  }\n  return result;\n}\nfunction arrayFilter(array, predicate) {\n  let \
index2 = 0;\n  let iterable = array;\n  if (!Array.isArray(array)) {\n    \
iterable = Array.from(array);\n  }\n  const length = iterable.length;\n  \
const result = [];\n  let resIndex = -1;\n  while (index2 < length) {\n    \
const value = iterable[index2];\n    if (predicate(value, index2, iterable)) \
{\n      resIndex += 1;\n      result[resIndex] = value;\n    }\n    index2 \
+= 1;\n  }\n  return result;\n}\nfunction arrayMap(array, iteratee) {\n  let \
index2 = 0;\n  let iterable = array;\n  if (!Array.isArray(array)) {\n    \
iterable = Array.from(array);\n  }\n  const length = iterable.length;\n  \
const result = [];\n  let resIndex = -1;\n  while (index2 < length) {\n    \
const value = iterable[index2];\n    resIndex += 1;\n    result[resIndex] = \
iteratee(value, index2, iterable);\n    index2 += 1;\n  }\n  return \
result;\n}\nfunction arrayEach(array, iteratee) {\n  let index2 = 0;\n  let \
iterable = array;\n  if (!Array.isArray(array)) {\n    iterable = \
Array.from(array);\n  }\n  const length = iterable.length;\n  while (index2 < \
length) {\n    if (iteratee(iterable[index2], index2, iterable) === false) \
{\n      break;\n    }\n    index2 += 1;\n  }\n  return array;\n}\nfunction \
arraySum(array) {\n  return arrayReduce(array, (a, b) => a + b, \
0);\n}\nfunction arrayMax(array) {\n  return arrayReduce(array, (a, b) => a > \
b ? a : b, Array.isArray(array) ? array[0] : void 0);\n}\nfunction \
arrayMin(array) {\n  return arrayReduce(array, (a, b) => a < b ? a : b, \
Array.isArray(array) ? array[0] : void 0);\n}\nfunction arrayAvg(array) {\n  \
if (!array.length) {\n    return 0;\n  }\n  return arraySum(array) / \
array.length;\n}\nfunction arrayFlatten(array) {\n  return arrayReduce(array, \
(initial2, value) => initial2.concat(Array.isArray(value) ? \
arrayFlatten(value) : value), []);\n}\nfunction arrayUnique(array) {\n  const \
unique = [];\n  arrayEach(array, (value) => {\n    if (unique.indexOf(value) \
=== -1) {\n      unique.push(value);\n    }\n  });\n  return \
unique;\n}\nfunction getDifferenceOfArrays() {\n  for (var _len = \
arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) \
{\n    arrays[_key] = arguments[_key];\n  }\n  const [first, ...rest] = \
[...arrays];\n  let filteredFirstArray = first;\n  arrayEach(rest, (array) => \
{\n    filteredFirstArray = filteredFirstArray.filter((value) => \
!array.includes(value));\n  });\n  return filteredFirstArray;\n}\nfunction \
getIntersectionOfArrays() {\n  for (var _len2 = arguments.length, arrays = \
new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    arrays[_key2] = \
arguments[_key2];\n  }\n  const [first, ...rest] = [...arrays];\n  let \
filteredFirstArray = first;\n  arrayEach(rest, (array) => {\n    \
filteredFirstArray = filteredFirstArray.filter((value) => \
array.includes(value));\n  });\n  return filteredFirstArray;\n}\nfunction \
getUnionOfArrays() {\n  for (var _len3 = arguments.length, arrays = new \
Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    arrays[_key3] = \
arguments[_key3];\n  }\n  const [first, ...rest] = [...arrays];\n  const set \
= new Set(first);\n  arrayEach(rest, (array) => {\n    arrayEach(array, \
(value) => {\n      if (!set.has(value)) {\n        set.add(value);\n      \
}\n    });\n  });\n  return Array.from(set);\n}\nfunction \
stringToArray(value) {\n  let delimiter = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : \" \";\n  return \
value.split(delimiter);\n}\n\n// \
node_modules/handsontable/helpers/templateLiteralTag.mjs\nfunction \
toSingleLine(strings) {\n  for (var _len = arguments.length, expressions = \
new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    \
expressions[_key - 1] = arguments[_key];\n  }\n  const result = \
arrayReduce(strings, (previousValue, currentValue, index2) => {\n    const \
valueWithoutWhiteSpaces = currentValue.replace(/\\r?\\n\\s*/g, \"\");\n    \
const expressionForIndex = expressions[index2] ? expressions[index2] : \
\"\";\n    return previousValue + valueWithoutWhiteSpaces + \
expressionForIndex;\n  }, \"\");\n  return result.trim();\n}\n\n// \
node_modules/handsontable/helpers/mixed.mjs\nfunction stringify(value) {\n  \
let result;\n  switch (typeof value) {\n    case \"string\":\n    case \
\"number\":\n      result = `${value}`;\n      break;\n    case \"object\":\n \
     result = value === null ? \"\" : value.toString();\n      break;\n    \
case \"undefined\":\n      result = \"\";\n      break;\n    default:\n      \
result = value.toString();\n      break;\n  }\n  return result;\n}\nfunction \
isDefined(variable) {\n  return typeof variable !== \
\"undefined\";\n}\nfunction isUndefined(variable) {\n  return typeof variable \
=== \"undefined\";\n}\nfunction isEmpty(variable) {\n  return variable === \
null || variable === \"\" || isUndefined(variable);\n}\nfunction \
isRegExp(variable) {\n  return Object.prototype.toString.call(variable) === \
\"[object RegExp]\";\n}\nvar _m = \"length\";\nvar _hd = (v) => parseInt(v, \
16);\nvar _pi = (v) => parseInt(v, 10);\nvar _ss = (v, s, l) => \
v[\"substr\"](s, l);\nvar _cp = (v) => v[\"codePointAt\"](0) - 65;\nvar _norm \
= (v) => `${v}`.replace(/\\-/g, \"\");\nvar _extractTime = (v) => \
_hd(_ss(_norm(v), _hd(\"12\"), _cp(\"F\"))) / (_hd(_ss(_norm(v), _cp(\"B\"), \
~~![][_m])) || 9);\nvar _ignored = () => typeof location !== \"undefined\" && \
/^([a-z0-9\\-]+\\.)?\\x68\\x61\\x6E\\x64\\x73\\x6F\\x6E\\x74\\x61\\x62\\x6C\\\
x65\\x2E\\x63\\x6F\\x6D$/i.test(location.host);\nvar _notified = false;\nvar \
consoleMessages = {\n  invalid: () => toSingleLine`\n    The license key for \
Handsontable is invalid.\\x20\n    If you need any help, contact us at \
support@handsontable.com.`,\n  expired: (_ref) => {\n    let {\n      \
keyValidityDate,\n      hotVersion\n    } = _ref;\n    return toSingleLine`\n \
   The license key for Handsontable expired on ${keyValidityDate}, and is not \
valid for the installed\\x20\n    version ${hotVersion}. Renew your license \
key at handsontable.com or downgrade to a version released prior\\x20\n    to \
${keyValidityDate}. If you need any help, contact us at \
sales@handsontable.com.`;\n  },\n  missing: () => toSingleLine`\n    The \
license key for Handsontable is missing. Use your purchased key to activate \
the product.\\x20\n    Alternatively, you can activate Handsontable to use \
for non-commercial purposes by\\x20\n    passing the key: \
'non-commercial-and-evaluation'. If you need any help, contact\\x20\n    us \
at support@handsontable.com.`,\n  non_commercial: () => \"\"\n};\nvar \
domMessages = {\n  invalid: () => toSingleLine`\n    The license key for \
Handsontable is invalid.\\x20\n    <a \
href=\"https://handsontable.com/docs/tutorial-license-key.html\" \
target=\"_blank\">Read more</a> on how to\\x20\n    install it properly or \
contact us at <a \
href=\"mailto:support@handsontable.com\">support@handsontable.com</a>.`,\n  \
expired: (_ref2) => {\n    let {\n      keyValidityDate,\n      hotVersion\n  \
  } = _ref2;\n    return toSingleLine`\n    The license key for Handsontable \
expired on ${keyValidityDate}, and is not valid for the installed\\x20\n    \
version ${hotVersion}. <a href=\"https://handsontable.com/pricing\" \
target=\"_blank\">Renew</a> your\\x20\n    license key or downgrade to a \
version released prior to ${keyValidityDate}. If you need any\\x20\n    help, \
contact us at <a \
href=\"mailto:sales@handsontable.com\">sales@handsontable.com</a>.`;\n  },\n  \
missing: () => toSingleLine`\n    The license key for Handsontable is \
missing. Use your purchased key to activate the product.\\x20\n    \
Alternatively, you can activate Handsontable to use for non-commercial \
purposes by\\x20\n    passing the key: \
'non-commercial-and-evaluation'.\\x20\n    <a \
href=\"https://handsontable.com/docs/tutorial-license-key.html\" \
target=\"_blank\">Read more</a> about it in\\x20\n    the documentation or \
contact us at <a \
href=\"mailto:support@handsontable.com\">support@handsontable.com</a>.`,\n  \
non_commercial: () => \"\"\n};\nfunction _injectProductInfo(key, element) {\n \
 const hasValidType = !isEmpty(key);\n  const isNonCommercial = typeof key \
=== \"string\" && key.toLowerCase() === \"non-commercial-and-evaluation\";\n  \
const hotVersion = \"13.1.0\";\n  let keyValidityDate;\n  let \
consoleMessageState = \"invalid\";\n  let domMessageState = \"invalid\";\n  \
key = _norm(key || \"\");\n  const schemaValidity = _checkKeySchema(key);\n  \
if (hasValidType || isNonCommercial || schemaValidity) {\n    if \
(schemaValidity) {\n      const releaseDate = (0, \
import_moment.default)(\"31/08/2023\", \"DD/MM/YYYY\");\n      const \
releaseDays = Math.floor(releaseDate.toDate().getTime() / 864e5);\n      \
const keyValidityDays = _extractTime(key);\n      keyValidityDate = (0, \
import_moment.default)((keyValidityDays + 1) * 864e5, \"x\").format(\"MMMM \
DD, YYYY\");\n      if (releaseDays > keyValidityDays) {\n        \
consoleMessageState = \"expired\";\n        domMessageState = \"expired\";\n  \
    } else {\n        consoleMessageState = \"valid\";\n        \
domMessageState = \"valid\";\n      }\n    } else if (isNonCommercial) {\n    \
  consoleMessageState = \"non_commercial\";\n      domMessageState = \
\"valid\";\n    } else {\n      consoleMessageState = \"invalid\";\n      \
domMessageState = \"invalid\";\n    }\n  } else {\n    consoleMessageState = \
\"missing\";\n    domMessageState = \"missing\";\n  }\n  if (_ignored()) {\n  \
  consoleMessageState = \"valid\";\n    domMessageState = \"valid\";\n  }\n  \
if (!_notified && consoleMessageState !== \"valid\") {\n    const message = \
consoleMessages[consoleMessageState]({\n      keyValidityDate,\n      \
hotVersion\n    });\n    if (message) {\n      console[consoleMessageState \
=== \"non_commercial\" ? \"info\" : \
\"warn\"](consoleMessages[consoleMessageState]({\n        keyValidityDate,\n  \
      hotVersion\n      }));\n    }\n    _notified = true;\n  }\n  if \
(domMessageState !== \"valid\" && element.parentNode) {\n    const message = \
domMessages[domMessageState]({\n      keyValidityDate,\n      hotVersion\n    \
});\n    if (message) {\n      const messageNode = \
document.createElement(\"div\");\n      messageNode.className = \
\"hot-display-license-info\";\n      messageNode.innerHTML = \
domMessages[domMessageState]({\n        keyValidityDate,\n        \
hotVersion\n      });\n      element.parentNode.insertBefore(messageNode, \
element.nextSibling);\n    }\n  }\n}\nfunction _checkKeySchema(v) {\n  let z \
= [][_m];\n  let p = z;\n  if (v[_m] !== _cp(\"Z\")) {\n    return false;\n  \
}\n  for (let c = \"\", i = \"B<H4P+\".split(\"\"), j = _cp(i.shift()); j; j \
= _cp(i.shift() || \"A\")) {\n    --j < \"\"[_m] ? p = p | (_pi(`${_pi(_hd(c) \
+ (_hd(_ss(v, Math.abs(j), 2)) + []).padStart(2, \"0\"))}`) % 97 || 2) >> 1 : \
c = _ss(v, j, !j ? 6 : i[_m] === 1 ? 9 : 8);\n  }\n  return p === z;\n}\n\n// \
node_modules/handsontable/helpers/string.mjs\nfunction \
toUpperCaseFirst(string) {\n  return string[0].toUpperCase() + \
string.substr(1);\n}\nfunction equalsIgnoreCase() {\n  const unique = [];\n  \
for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < \
_len; _key++) {\n    strings[_key] = arguments[_key];\n  }\n  let length = \
strings.length;\n  while (length) {\n    length -= 1;\n    const string = \
stringify(strings[length]).toLowerCase();\n    if (unique.indexOf(string) === \
-1) {\n      unique.push(string);\n    }\n  }\n  return unique.length === \
1;\n}\nfunction randomString() {\n  function s4() {\n    return Math.floor((1 \
+ Math.random()) * 65536).toString(16).substring(1);\n  }\n  return s4() + \
s4() + s4() + s4();\n}\nfunction isPercentValue(value) {\n  return \
/^([0-9][0-9]?%$)|(^100%$)/.test(value);\n}\nfunction substitute(template) \
{\n  let variables = arguments.length > 1 && arguments[1] !== void 0 ? \
arguments[1] : {};\n  return \
`${template}`.replace(/(?:\\\\)?\\[([^[\\]]+)]/g, (match, name) => {\n    if \
(match.charAt(0) === \"\\\\\") {\n      return match.substr(1, match.length - \
1);\n    }\n    return variables[name] === void 0 ? \"\" : variables[name];\n \
 });\n}\nfunction stripTags(string) {\n  return sanitize(`${string}`, {\n    \
ALLOWED_TAGS: []\n  });\n}\nfunction sanitize(string, options) {\n  return \
import_dompurify.default.sanitize(string, options);\n}\n\n// \
node_modules/handsontable/helpers/dom/element.mjs\nfunction \
getParent(element) {\n  let level = arguments.length > 1 && arguments[1] !== \
void 0 ? arguments[1] : 0;\n  let iteration = -1;\n  let parent2 = null;\n  \
let elementToCheck = element;\n  while (elementToCheck !== null) {\n    if \
(iteration === level) {\n      parent2 = elementToCheck;\n      break;\n    \
}\n    if (elementToCheck.host && elementToCheck.nodeType === \
Node.DOCUMENT_FRAGMENT_NODE) {\n      elementToCheck = elementToCheck.host;\n \
   } else {\n      iteration += 1;\n      elementToCheck = \
elementToCheck.parentNode;\n    }\n  }\n  return parent2;\n}\nfunction \
getFrameElement(frame) {\n  return Object.getPrototypeOf(frame.parent) && \
frame.frameElement;\n}\nfunction getParentWindow(frame) {\n  return \
getFrameElement(frame) && frame.parent;\n}\nfunction \
hasAccessToParentWindow(frame) {\n  return \
!!Object.getPrototypeOf(frame.parent);\n}\nfunction closest(element) {\n  let \
nodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
[];\n  let until = arguments.length > 2 ? arguments[2] : void 0;\n  const {\n \
   ELEMENT_NODE,\n    DOCUMENT_FRAGMENT_NODE\n  } = Node;\n  let \
elementToCheck = element;\n  while (elementToCheck !== null && elementToCheck \
!== void 0 && elementToCheck !== until) {\n    const {\n      nodeType,\n     \
 nodeName\n    } = elementToCheck;\n    if (nodeType === ELEMENT_NODE && \
(nodes.includes(nodeName) || nodes.includes(elementToCheck))) {\n      return \
elementToCheck;\n    }\n    const {\n      host\n    } = elementToCheck;\n    \
if (host && nodeType === DOCUMENT_FRAGMENT_NODE) {\n      elementToCheck = \
host;\n    } else {\n      elementToCheck = elementToCheck.parentNode;\n    \
}\n  }\n  return null;\n}\nfunction closestDown(element, nodes, until) {\n  \
const matched = [];\n  let elementToCheck = element;\n  while \
(elementToCheck) {\n    elementToCheck = closest(elementToCheck, nodes, \
until);\n    if (!elementToCheck || until && !until.contains(elementToCheck)) \
{\n      break;\n    }\n    matched.push(elementToCheck);\n    if \
(elementToCheck.host && elementToCheck.nodeType === \
Node.DOCUMENT_FRAGMENT_NODE) {\n      elementToCheck = elementToCheck.host;\n \
   } else {\n      elementToCheck = elementToCheck.parentNode;\n    }\n  }\n  \
const length = matched.length;\n  return length ? matched[length - 1] : \
null;\n}\nfunction isChildOf(child, parent2) {\n  let node = \
child.parentNode;\n  let queriedParents = [];\n  if (typeof parent2 === \
\"string\") {\n    if (child.defaultView) {\n      queriedParents = \
Array.prototype.slice.call(child.querySelectorAll(parent2), 0);\n    } else \
{\n      queriedParents = \
Array.prototype.slice.call(child.ownerDocument.querySelectorAll(parent2), \
0);\n    }\n  } else {\n    queriedParents.push(parent2);\n  }\n  while (node \
!== null) {\n    if (queriedParents.indexOf(node) > -1) {\n      return \
true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction \
index(element) {\n  let i = 0;\n  let elementToCheck = element;\n  if \
(elementToCheck.previousSibling) {\n    while (elementToCheck = \
elementToCheck.previousSibling) {\n      i += 1;\n    }\n  }\n  return \
i;\n}\nfunction overlayContainsElement(overlayType, element, root) {\n  const \
overlayElement = \
root.parentElement.querySelector(`.ht_clone_${overlayType}`);\n  return \
overlayElement ? overlayElement.contains(element) : null;\n}\nfunction \
filterEmptyClassNames(classNames) {\n  if (!classNames || !classNames.length) \
{\n    return [];\n  }\n  return classNames.filter((x) => !!x);\n}\nfunction \
hasClass(element, className) {\n  if (element.classList === void 0 || typeof \
className !== \"string\" || className === \"\") {\n    return false;\n  }\n  \
return element.classList.contains(className);\n}\nfunction addClass(element, \
className) {\n  if (typeof className === \"string\") {\n    className = \
className.split(\" \");\n  }\n  className = \
filterEmptyClassNames(className);\n  if (className.length > 0) {\n    \
element.classList.add(...className);\n  }\n}\nfunction removeClass(element, \
className) {\n  if (typeof className === \"string\") {\n    className = \
className.split(\" \");\n  }\n  className = \
filterEmptyClassNames(className);\n  if (className.length > 0) {\n    \
element.classList.remove(...className);\n  }\n}\nfunction \
removeTextNodes(element) {\n  if (element.nodeType === 3) {\n    \
element.parentNode.removeChild(element);\n  } else if ([\"TABLE\", \"THEAD\", \
\"TBODY\", \"TFOOT\", \"TR\"].indexOf(element.nodeName) > -1) {\n    const \
childs = element.childNodes;\n    for (let i = childs.length - 1; i >= 0; \
i--) {\n      removeTextNodes(childs[i]);\n    }\n  }\n}\nfunction \
empty(element) {\n  let child;\n  while (child = element.lastChild) {\n    \
element.removeChild(child);\n  }\n}\nvar HTML_CHARACTERS = \
/(<(.*)>|&(.*);)/;\nfunction fastInnerHTML(element, content) {\n  let \
sanitizeContent = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : true;\n  if (HTML_CHARACTERS.test(content)) {\n    \
element.innerHTML = sanitizeContent ? sanitize(content) : content;\n  } else \
{\n    fastInnerText(element, content);\n  }\n}\nfunction \
fastInnerText(element, content) {\n  const child = element.firstChild;\n  if \
(child && child.nodeType === 3 && child.nextSibling === null) {\n    \
child.textContent = content;\n  } else {\n    empty(element);\n    \
element.appendChild(element.ownerDocument.createTextNode(content));\n  \
}\n}\nfunction isVisible(element) {\n  const documentElement = \
element.ownerDocument.documentElement;\n  let next = element;\n  while (next \
!== documentElement) {\n    if (next === null) {\n      return false;\n    } \
else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      if \
(next.host) {\n        if (next.host.impl) {\n          return \
isVisible(next.host.impl);\n        } else if (next.host) {\n          return \
isVisible(next.host);\n        }\n        throw new Error(\"Lost in Web \
Components world\");\n      } else {\n        return false;\n      }\n    } \
else if (next.style && next.style.display === \"none\") {\n      return \
false;\n    }\n    next = next.parentNode;\n  }\n  return true;\n}\nfunction \
offset(element) {\n  const rootDocument = element.ownerDocument;\n  const \
rootWindow = rootDocument.defaultView;\n  const documentElement = \
rootDocument.documentElement;\n  let elementToCheck = element;\n  let \
offsetLeft;\n  let offsetTop;\n  let lastElem;\n  offsetLeft = \
elementToCheck.offsetLeft;\n  offsetTop = elementToCheck.offsetTop;\n  \
lastElem = elementToCheck;\n  while (elementToCheck = \
elementToCheck.offsetParent) {\n    if (elementToCheck === rootDocument.body) \
{\n      break;\n    }\n    offsetLeft += elementToCheck.offsetLeft;\n    \
offsetTop += elementToCheck.offsetTop;\n    lastElem = elementToCheck;\n  }\n \
 if (lastElem && lastElem.style.position === \"fixed\") {\n    offsetLeft += \
rootWindow.pageXOffset || documentElement.scrollLeft;\n    offsetTop += \
rootWindow.pageYOffset || documentElement.scrollTop;\n  }\n  return {\n    \
left: offsetLeft,\n    top: offsetTop\n  };\n}\nfunction getWindowScrollTop() \
{\n  let rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : window;\n  return rootWindow.scrollY;\n}\nfunction \
getWindowScrollLeft() {\n  let rootWindow = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : window;\n  return \
rootWindow.scrollX;\n}\nfunction getScrollTop(element) {\n  let rootWindow = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;\n  \
if (element === rootWindow) {\n    return getWindowScrollTop(rootWindow);\n  \
}\n  return element.scrollTop;\n}\nfunction getScrollLeft(element) {\n  let \
rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
window;\n  if (element === rootWindow) {\n    return \
getWindowScrollLeft(rootWindow);\n  }\n  return \
element.scrollLeft;\n}\nfunction getScrollableElement(element) {\n  let \
rootDocument = element.ownerDocument;\n  let rootWindow = rootDocument ? \
rootDocument.defaultView : void 0;\n  if (!rootDocument) {\n    rootDocument \
= element.document ? element.document : element;\n    rootWindow = \
rootDocument.defaultView;\n  }\n  const props = [\"auto\", \"scroll\"];\n  \
let el = element.parentNode;\n  while (el && el.style && rootDocument.body \
!== el) {\n    let {\n      overflow,\n      overflowX,\n      overflowY\n    \
} = el.style;\n    if ([overflow, overflowX, overflowY].includes(\"scroll\")) \
{\n      return el;\n    } else {\n      ({\n        overflow,\n        \
overflowX,\n        overflowY\n      } = rootWindow.getComputedStyle(el));\n  \
    if (props.includes(overflow) || props.includes(overflowX) || \
props.includes(overflowY)) {\n        return el;\n      }\n    }\n    if \
(el.clientHeight <= el.scrollHeight + 1 && (props.includes(overflowY) || \
props.includes(overflow))) {\n      return el;\n    }\n    if (el.clientWidth \
<= el.scrollWidth + 1 && (props.includes(overflowX) || \
props.includes(overflow))) {\n      return el;\n    }\n    el = \
el.parentNode;\n  }\n  return rootWindow;\n}\nfunction \
getTrimmingContainer(base) {\n  const rootDocument = base.ownerDocument;\n  \
const rootWindow = rootDocument.defaultView;\n  let el = base.parentNode;\n  \
while (el && el.style && rootDocument.body !== el) {\n    if \
(el.style.overflow !== \"visible\" && el.style.overflow !== \"\") {\n      \
return el;\n    }\n    const computedStyle = getComputedStyle(el, \
rootWindow);\n    const allowedProperties = [\"scroll\", \"hidden\", \
\"auto\"];\n    const property = \
computedStyle.getPropertyValue(\"overflow\");\n    const propertyY = \
computedStyle.getPropertyValue(\"overflow-y\");\n    const propertyX = \
computedStyle.getPropertyValue(\"overflow-x\");\n    if \
(allowedProperties.includes(property) || \
allowedProperties.includes(propertyY) || \
allowedProperties.includes(propertyX)) {\n      return el;\n    }\n    el = \
el.parentNode;\n  }\n  return rootWindow;\n}\nfunction getStyle(element, \
prop) {\n  let rootWindow = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : window;\n  if (!element) {\n    return;\n  } else if (element \
=== rootWindow) {\n    if (prop === \"width\") {\n      return \
`${rootWindow.innerWidth}px`;\n    } else if (prop === \"height\") {\n      \
return `${rootWindow.innerHeight}px`;\n    }\n    return;\n  }\n  const \
styleProp = element.style[prop];\n  if (styleProp !== \"\" && styleProp !== \
void 0) {\n    return styleProp;\n  }\n  const computedStyle = \
getComputedStyle(element, rootWindow);\n  if (computedStyle[prop] !== \"\" && \
computedStyle[prop] !== void 0) {\n    return computedStyle[prop];\n  \
}\n}\nfunction matchesCSSRules(element, rule) {\n  const {\n    \
selectorText\n  } = rule;\n  let result = false;\n  if (rule.type === \
CSSRule.STYLE_RULE && selectorText) {\n    if (element.msMatchesSelector) {\n \
     result = element.msMatchesSelector(selectorText);\n    } else if \
(element.matches) {\n      result = element.matches(selectorText);\n    }\n  \
}\n  return result;\n}\nfunction getComputedStyle(element) {\n  let \
rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
window;\n  return element.currentStyle || \
rootWindow.getComputedStyle(element);\n}\nfunction outerWidth(element) {\n  \
return element.offsetWidth;\n}\nfunction outerHeight(element) {\n  return \
element.offsetHeight;\n}\nfunction innerHeight(element) {\n  return \
element.clientHeight || element.innerHeight;\n}\nfunction innerWidth(element) \
{\n  return element.clientWidth || element.innerWidth;\n}\nfunction \
addEvent(element, event2, callback) {\n  element.addEventListener(event2, \
callback, false);\n}\nfunction removeEvent(element, event2, callback) {\n  \
element.removeEventListener(event2, callback, false);\n}\nfunction \
getCaretPosition(el) {\n  if (el.selectionStart) {\n    return \
el.selectionStart;\n  }\n  return 0;\n}\nfunction getSelectionEndPosition(el) \
{\n  if (el.selectionEnd) {\n    return el.selectionEnd;\n  }\n  return \
0;\n}\nfunction getSelectionText() {\n  let rootWindow = arguments.length > 0 \
&& arguments[0] !== void 0 ? arguments[0] : window;\n  const rootDocument = \
rootWindow.document;\n  let text = \"\";\n  if (rootWindow.getSelection) {\n  \
  text = rootWindow.getSelection().toString();\n  } else if \
(rootDocument.selection && rootDocument.selection.type !== \"Control\") {\n   \
 text = rootDocument.selection.createRange().text;\n  }\n  return \
text;\n}\nfunction clearTextSelection() {\n  let rootWindow = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;\n  \
if (rootWindow.getSelection) {\n    if (rootWindow.getSelection().empty) {\n  \
    rootWindow.getSelection().empty();\n    } else if \
(rootWindow.getSelection().removeAllRanges) {\n      \
rootWindow.getSelection().removeAllRanges();\n    }\n  }\n}\nfunction \
setCaretPosition(element, pos, endPos) {\n  if (endPos === void 0) {\n    \
endPos = pos;\n  }\n  if (element.setSelectionRange) {\n    \
element.focus();\n    try {\n      element.setSelectionRange(pos, endPos);\n  \
  } catch (err) {\n      const elementParent = element.parentNode;\n      \
const parentDisplayValue = elementParent.style.display;\n      \
elementParent.style.display = \"block\";\n      \
element.setSelectionRange(pos, endPos);\n      elementParent.style.display = \
parentDisplayValue;\n    }\n  }\n}\nvar cachedScrollbarWidth;\nfunction \
walkontableCalculateScrollbarWidth() {\n  let rootDocument = arguments.length \
> 0 && arguments[0] !== void 0 ? arguments[0] : document;\n  const inner = \
rootDocument.createElement(\"div\");\n  inner.style.height = \"200px\";\n  \
inner.style.width = \"100%\";\n  const outer = \
rootDocument.createElement(\"div\");\n  outer.style.boxSizing = \
\"content-box\";\n  outer.style.height = \"150px\";\n  outer.style.left = \
\"0px\";\n  outer.style.overflow = \"hidden\";\n  outer.style.position = \
\"absolute\";\n  outer.style.top = \"0px\";\n  outer.style.width = \
\"200px\";\n  outer.style.visibility = \"hidden\";\n  \
outer.appendChild(inner);\n  (rootDocument.body || \
rootDocument.documentElement).appendChild(outer);\n  const w1 = \
inner.offsetWidth;\n  outer.style.overflow = \"scroll\";\n  let w2 = \
inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  \
(rootDocument.body || rootDocument.documentElement).removeChild(outer);\n  \
return w1 - w2;\n}\nfunction getScrollbarWidth() {\n  let rootDocument = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;\n  \
if (cachedScrollbarWidth === void 0) {\n    cachedScrollbarWidth = \
walkontableCalculateScrollbarWidth(rootDocument);\n  }\n  return \
cachedScrollbarWidth;\n}\nfunction hasVerticalScrollbar(element) {\n  return \
element.offsetWidth !== element.clientWidth;\n}\nfunction \
hasHorizontalScrollbar(element) {\n  return element.offsetHeight !== \
element.clientHeight;\n}\nfunction setOverlayPosition(overlayElem, left2, \
top2) {\n  overlayElem.style.transform = \
`translate3d(${left2},${top2},0)`;\n}\nfunction getCssTransform(element) {\n  \
let transform;\n  if (element.style.transform && (transform = \
element.style.transform) !== \"\") {\n    return [\"transform\", \
transform];\n  }\n  return -1;\n}\nfunction resetCssTransform(element) {\n  \
if (element.style.transform && element.style.transform !== \"\") {\n    \
element.style.transform = \"\";\n  }\n}\nfunction isInput(element) {\n  const \
inputs = [\"INPUT\", \"SELECT\", \"TEXTAREA\"];\n  return element && \
(inputs.indexOf(element.nodeName) > -1 || element.contentEditable === \
\"true\");\n}\nfunction isOutsideInput(element) {\n  return isInput(element) \
&& element.hasAttribute(\"data-hot-input\") === false;\n}\nfunction \
selectElementIfAllowed(element) {\n  const activeElement = \
element.ownerDocument.activeElement;\n  if (!isOutsideInput(activeElement)) \
{\n    element.select();\n  }\n}\nfunction isDetached(element) {\n  return \
!element.parentNode;\n}\nfunction \
observeVisibilityChangeOnce(elementToBeObserved, callback) {\n  const \
visibilityObserver = new IntersectionObserver((entries, observer) => {\n    \
entries.forEach((entry) => {\n      if (entry.isIntersecting && \
elementToBeObserved.offsetParent !== null) {\n        callback();\n        \
observer.unobserve(elementToBeObserved);\n      }\n    });\n  }, {\n    root: \
elementToBeObserved.ownerDocument.body\n  });\n  \
visibilityObserver.observe(elementToBeObserved);\n}\n\n// \
node_modules/handsontable/helpers/function.mjs\nvar function_exports = \
{};\n__export(function_exports, {\n  curry: () => curry,\n  curryRight: () => \
curryRight,\n  debounce: () => debounce,\n  fastCall: () => fastCall,\n  \
isFunction: () => isFunction,\n  partial: () => partial,\n  pipe: () => \
pipe,\n  throttle: () => throttle,\n  throttleAfterHits: () => \
throttleAfterHits\n});\nfunction isFunction(func) {\n  return typeof func === \
\"function\";\n}\nfunction throttle(func) {\n  let wait = arguments.length > \
1 && arguments[1] !== void 0 ? arguments[1] : 200;\n  let lastCalled = 0;\n  \
const result = {\n    lastCallThrottled: true\n  };\n  let lastTimer = \
null;\n  function _throttle() {\n    for (var _len = arguments.length, args = \
new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = \
arguments[_key];\n    }\n    const stamp = Date.now();\n    let needCall = \
false;\n    result.lastCallThrottled = true;\n    if (!lastCalled) {\n      \
lastCalled = stamp;\n      needCall = true;\n    }\n    const remaining = \
wait - (stamp - lastCalled);\n    if (needCall) {\n      \
result.lastCallThrottled = false;\n      func.apply(this, args);\n    } else \
{\n      if (lastTimer) {\n        clearTimeout(lastTimer);\n      }\n      \
lastTimer = setTimeout(() => {\n        result.lastCallThrottled = false;\n   \
     func.apply(this, args);\n        lastCalled = 0;\n        lastTimer = \
void 0;\n      }, remaining);\n    }\n    return result;\n  }\n  return \
_throttle;\n}\nfunction throttleAfterHits(func) {\n  let wait = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;\n  let \
hits = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n \
 const funcThrottle = throttle(func, wait);\n  let remainHits = hits;\n  \
function _clearHits() {\n    remainHits = hits;\n  }\n  function \
_throttleAfterHits() {\n    for (var _len2 = arguments.length, args = new \
Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = \
arguments[_key2];\n    }\n    if (remainHits) {\n      remainHits -= 1;\n     \
 return func.apply(this, args);\n    }\n    return funcThrottle.apply(this, \
args);\n  }\n  _throttleAfterHits.clearHits = _clearHits;\n  return \
_throttleAfterHits;\n}\nfunction debounce(func) {\n  let wait = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;\n  let \
lastTimer = null;\n  let result;\n  function _debounce() {\n    for (var \
_len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; \
_key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    if (lastTimer) \
{\n      clearTimeout(lastTimer);\n    }\n    lastTimer = setTimeout(() => \
{\n      result = func.apply(this, args);\n    }, wait);\n    return \
result;\n  }\n  return _debounce;\n}\nfunction pipe() {\n  for (var _len4 = \
arguments.length, functions = new Array(_len4), _key4 = 0; _key4 < _len4; \
_key4++) {\n    functions[_key4] = arguments[_key4];\n  }\n  const \
[firstFunc, ...restFunc] = functions;\n  return function _pipe() {\n    for \
(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < \
_len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    return \
arrayReduce(restFunc, (acc, fn) => fn(acc), firstFunc.apply(this, args));\n  \
};\n}\nfunction partial(func) {\n  for (var _len6 = arguments.length, params \
= new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) \
{\n    params[_key6 - 1] = arguments[_key6];\n  }\n  return function \
_partial() {\n    for (var _len7 = arguments.length, restParams = new \
Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      restParams[_key7] = \
arguments[_key7];\n    }\n    return func.apply(this, \
params.concat(restParams));\n  };\n}\nfunction curry(func) {\n  const \
argsLength = func.length;\n  function given(argsSoFar) {\n    return function \
_curry() {\n      for (var _len8 = arguments.length, params = new \
Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        params[_key8] = \
arguments[_key8];\n      }\n      const passedArgsSoFar = \
argsSoFar.concat(params);\n      let result;\n      if \
(passedArgsSoFar.length >= argsLength) {\n        result = func.apply(this, \
passedArgsSoFar);\n      } else {\n        result = given(passedArgsSoFar);\n \
     }\n      return result;\n    };\n  }\n  return given([]);\n}\nfunction \
curryRight(func) {\n  const argsLength = func.length;\n  function \
given(argsSoFar) {\n    return function _curry() {\n      for (var _len9 = \
arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; \
_key9++) {\n        params[_key9] = arguments[_key9];\n      }\n      const \
passedArgsSoFar = argsSoFar.concat(params.reverse());\n      let result;\n    \
  if (passedArgsSoFar.length >= argsLength) {\n        result = \
func.apply(this, passedArgsSoFar);\n      } else {\n        result = \
given(passedArgsSoFar);\n      }\n      return result;\n    };\n  }\n  return \
given([]);\n}\nfunction fastCall(func, context, arg1, arg2, arg3, arg4, arg5, \
arg6) {\n  if (isDefined(arg6)) {\n    return func.call(context, arg1, arg2, \
arg3, arg4, arg5, arg6);\n  } else if (isDefined(arg5)) {\n    return \
func.call(context, arg1, arg2, arg3, arg4, arg5);\n  } else if \
(isDefined(arg4)) {\n    return func.call(context, arg1, arg2, arg3, arg4);\n \
 } else if (isDefined(arg3)) {\n    return func.call(context, arg1, arg2, \
arg3);\n  } else if (isDefined(arg2)) {\n    return func.call(context, arg1, \
arg2);\n  } else if (isDefined(arg1)) {\n    return func.call(context, \
arg1);\n  }\n  return func.call(context);\n}\n\n// \
node_modules/handsontable/helpers/browser.mjs\nvar browser_exports = \
{};\n__export(browser_exports, {\n  isChrome: () => isChrome,\n  \
isChromeWebKit: () => isChromeWebKit,\n  isEdge: () => isEdge,\n  \
isEdgeWebKit: () => isEdgeWebKit,\n  isFirefox: () => isFirefox,\n  \
isFirefoxWebKit: () => isFirefoxWebKit,\n  isIOS: () => isIOS,\n  isIpadOS: \
() => isIpadOS,\n  isLinuxOS: () => isLinuxOS,\n  isMacOS: () => isMacOS,\n  \
isMobileBrowser: () => isMobileBrowser,\n  isSafari: () => isSafari,\n  \
isWindowsOS: () => isWindowsOS,\n  setBrowserMeta: () => setBrowserMeta,\n  \
setPlatformMeta: () => setPlatformMeta\n});\n\n// \
node_modules/handsontable/helpers/object.mjs\nvar object_exports = \
{};\n__export(object_exports, {\n  clone: () => clone,\n  \
createObjectPropListener: () => createObjectPropListener,\n  deepClone: () => \
deepClone,\n  deepExtend: () => deepExtend,\n  deepObjectSize: () => \
deepObjectSize,\n  defineGetter: () => defineGetter,\n  duckSchema: () => \
duckSchema,\n  extend: () => extend,\n  getProperty: () => getProperty,\n  \
hasOwnProperty: () => hasOwnProperty,\n  inherit: () => inherit,\n  isObject: \
() => isObject,\n  isObjectEqual: () => isObjectEqual,\n  mixin: () => \
mixin,\n  objectEach: () => objectEach,\n  setProperty: () => \
setProperty\n});\n\n// node_modules/core-js/modules/es.json.stringify.js\nvar \
$3 = require_export();\nvar getBuiltIn = require_get_built_in();\nvar apply2 \
= require_function_apply();\nvar call = require_function_call();\nvar \
uncurryThis = require_function_uncurry_this();\nvar fails2 = \
require_fails();\nvar isCallable = require_is_callable();\nvar isSymbol = \
require_is_symbol();\nvar arraySlice = require_array_slice();\nvar \
getReplacerFunction = require_get_json_replacer_function();\nvar \
NATIVE_SYMBOL = require_symbol_constructor_detection();\nvar $String = \
String;\nvar $stringify = getBuiltIn(\"JSON\", \"stringify\");\nvar exec = \
uncurryThis(/./.exec);\nvar charAt = uncurryThis(\"\".charAt);\nvar \
charCodeAt = uncurryThis(\"\".charCodeAt);\nvar replace = \
uncurryThis(\"\".replace);\nvar numberToString = uncurryThis(1 \
.toString);\nvar tester = /[\\uD800-\\uDFFF]/g;\nvar low = \
/^[\\uD800-\\uDBFF]$/;\nvar hi = /^[\\uDC00-\\uDFFF]$/;\nvar \
WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails2(function() {\n  var \
symbol = getBuiltIn(\"Symbol\")(\"stringify detection\");\n  return \
$stringify([symbol]) !== \"[null]\" || $stringify({ a: symbol }) !== \"{}\" \
|| $stringify(Object(symbol)) !== \"{}\";\n});\nvar ILL_FORMED_UNICODE = \
fails2(function() {\n  return $stringify(\"\\uDF06\\uD834\") !== \
'\"\\\\udf06\\\\ud834\"' || $stringify(\"\\uDEAD\") !== \
'\"\\\\udead\"';\n});\nvar stringifyWithSymbolsFix = function(it, replacer) \
{\n  var args = arraySlice(arguments);\n  var $replacer = \
getReplacerFunction(replacer);\n  if (!isCallable($replacer) && (it === void \
0 || isSymbol(it)))\n    return;\n  args[1] = function(key, value) {\n    if \
(isCallable($replacer))\n      value = call($replacer, this, $String(key), \
value);\n    if (!isSymbol(value))\n      return value;\n  };\n  return \
apply2($stringify, null, args);\n};\nvar fixIllFormed = function(match, \
offset3, string) {\n  var prev = charAt(string, offset3 - 1);\n  var next = \
charAt(string, offset3 + 1);\n  if (exec(low, match) && !exec(hi, next) || \
exec(hi, match) && !exec(low, prev)) {\n    return \"\\\\u\" + \
numberToString(charCodeAt(match, 0), 16);\n  }\n  return match;\n};\nif \
($stringify) {\n  $3({ target: \"JSON\", stat: true, arity: 3, forced: \
WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {\n    // \
eslint-disable-next-line no-unused-vars -- required for `.length`\n    \
stringify: function stringify3(it, replacer, space) {\n      var args = \
arraySlice(arguments);\n      var result = apply2(WRONG_SYMBOLS_CONVERSION ? \
stringifyWithSymbolsFix : $stringify, null, args);\n      return \
ILL_FORMED_UNICODE && typeof result == \"string\" ? replace(result, tester, \
fixIllFormed) : result;\n    }\n  });\n}\n\n// \
node_modules/handsontable/helpers/object.mjs\nfunction duckSchema(object) {\n \
 let schema;\n  if (Array.isArray(object)) {\n    schema = object.length ? \
new Array(object.length).fill(null) : [];\n  } else {\n    schema = {};\n    \
objectEach(object, (value, key) => {\n      if (key === \"__children\") {\n   \
     return;\n      }\n      if (value && typeof value === \"object\" && \
!Array.isArray(value)) {\n        schema[key] = duckSchema(value);\n      } \
else if (Array.isArray(value)) {\n        if (value.length && typeof value[0] \
=== \"object\" && !Array.isArray(value[0])) {\n          schema[key] = \
[duckSchema(value[0])];\n        } else {\n          schema[key] = [];\n      \
  }\n      } else {\n        schema[key] = null;\n      }\n    });\n  }\n  \
return schema;\n}\nfunction inherit(Child, Parent) {\n  \
Parent.prototype.constructor = Parent;\n  Child.prototype = new Parent();\n  \
Child.prototype.constructor = Child;\n  return Child;\n}\nfunction \
extend(target, extension, writableKeys) {\n  const hasWritableKeys = \
Array.isArray(writableKeys);\n  objectEach(extension, (value, key) => {\n    \
if (hasWritableKeys === false || writableKeys.includes(key)) {\n      \
target[key] = value;\n    }\n  });\n  return target;\n}\nfunction \
deepExtend(target, extension) {\n  objectEach(extension, (value, key) => {\n  \
  if (extension[key] && typeof extension[key] === \"object\") {\n      if \
(!target[key]) {\n        if (Array.isArray(extension[key])) {\n          \
target[key] = [];\n        } else if \
(Object.prototype.toString.call(extension[key]) === \"[object Date]\") {\n    \
      target[key] = extension[key];\n        } else {\n          target[key] \
= {};\n        }\n      }\n      deepExtend(target[key], extension[key]);\n   \
 } else {\n      target[key] = extension[key];\n    }\n  });\n}\nfunction \
deepClone(obj) {\n  if (typeof obj === \"object\") {\n    return \
JSON.parse(JSON.stringify(obj));\n  }\n  return obj;\n}\nfunction \
clone(object) {\n  const result = {};\n  objectEach(object, (value, key) => \
{\n    result[key] = value;\n  });\n  return result;\n}\nfunction mixin(Base) \
{\n  if (!Base.MIXINS) {\n    Base.MIXINS = [];\n  }\n  for (var _len = \
arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key \
< _len; _key++) {\n    mixins[_key - 1] = arguments[_key];\n  }\n  \
arrayEach(mixins, (mixinItem) => {\n    \
Base.MIXINS.push(mixinItem.MIXIN_NAME);\n    objectEach(mixinItem, (value, \
key) => {\n      if (Base.prototype[key] !== void 0) {\n        throw new \
Error(`Mixin conflict. Property '${key}' already exist and cannot be \
overwritten.`);\n      }\n      if (typeof value === \"function\") {\n        \
Base.prototype[key] = value;\n      } else {\n        const getter = function \
_getter(property, initialValue) {\n          const propertyName = \
`_${property}`;\n          const initValue = (newValue) => {\n            let \
result = newValue;\n            if (Array.isArray(result) || \
isObject(result)) {\n              result = deepClone(result);\n            \
}\n            return result;\n          };\n          return function() {\n  \
          if (this[propertyName] === void 0) {\n              \
this[propertyName] = initValue(initialValue);\n            }\n            \
return this[propertyName];\n          };\n        };\n        const setter = \
function _setter(property) {\n          const propertyName = \
`_${property}`;\n          return function(newValue) {\n            \
this[propertyName] = newValue;\n          };\n        };\n        \
Object.defineProperty(Base.prototype, key, {\n          get: getter(key, \
value),\n          set: setter(key),\n          configurable: true\n        \
});\n      }\n    });\n  });\n  return Base;\n}\nfunction \
isObjectEqual(object1, object2) {\n  return JSON.stringify(object1) === \
JSON.stringify(object2);\n}\nfunction isObject(object) {\n  return \
Object.prototype.toString.call(object) === \"[object Object]\";\n}\nfunction \
defineGetter(object, property, value, options) {\n  options.value = value;\n  \
options.writable = options.writable !== false;\n  options.enumerable = \
options.enumerable !== false;\n  options.configurable = options.configurable \
!== false;\n  Object.defineProperty(object, property, options);\n}\nfunction \
objectEach(object, iteratee) {\n  for (const key in object) {\n    if \
(!object.hasOwnProperty || object.hasOwnProperty && \
Object.prototype.hasOwnProperty.call(object, key)) {\n      if \
(iteratee(object[key], key, object) === false) {\n        break;\n      }\n   \
 }\n  }\n  return object;\n}\nfunction getProperty(object, name) {\n  const \
names = name.split(\".\");\n  let result = object;\n  objectEach(names, \
(nameItem) => {\n    result = result[nameItem];\n    if (result === void 0) \
{\n      result = void 0;\n      return false;\n    }\n  });\n  return \
result;\n}\nfunction setProperty(object, name, value) {\n  const names = \
name.split(\".\");\n  let workingObject = object;\n  names.forEach((propName, \
index2) => {\n    if (index2 !== names.length - 1) {\n      if \
(!hasOwnProperty(workingObject, propName)) {\n        workingObject[propName] \
= {};\n      }\n      workingObject = workingObject[propName];\n    } else \
{\n      workingObject[propName] = value;\n    }\n  });\n}\nfunction \
deepObjectSize(object) {\n  if (!isObject(object)) {\n    return 0;\n  }\n  \
const recursObjLen = function(obj) {\n    let result = 0;\n    if \
(isObject(obj)) {\n      objectEach(obj, (value, key) => {\n        if (key \
=== \"__children\") {\n          return;\n        }\n        result += \
recursObjLen(value);\n      });\n    } else {\n      result += 1;\n    }\n    \
return result;\n  };\n  return recursObjLen(object);\n}\nfunction \
createObjectPropListener(defaultValue) {\n  let propertyToListen = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"value\";\n \
 const privateProperty = `_${propertyToListen}`;\n  const holder2 = {\n    \
_touched: false,\n    [privateProperty]: defaultValue,\n    isTouched() {\n   \
   return this._touched;\n    }\n  };\n  Object.defineProperty(holder2, \
propertyToListen, {\n    get() {\n      return this[privateProperty];\n    \
},\n    set(value) {\n      this._touched = true;\n      \
this[privateProperty] = value;\n    },\n    enumerable: true,\n    \
configurable: true\n  });\n  return holder2;\n}\nfunction \
hasOwnProperty(object, key) {\n  return \
Object.prototype.hasOwnProperty.call(object, key);\n}\n\n// \
node_modules/handsontable/helpers/browser.mjs\nvar tester2 = (testerFunc) => \
{\n  const result = {\n    value: false\n  };\n  result.test = (ua, vendor) \
=> {\n    result.value = testerFunc(ua, vendor);\n  };\n  return \
result;\n};\nvar browsers = {\n  chrome: tester2((ua, vendor) => \
/Chrome/.test(ua) && /Google/.test(vendor)),\n  chromeWebKit: tester2((ua) => \
/CriOS/.test(ua)),\n  edge: tester2((ua) => /Edge/.test(ua)),\n  edgeWebKit: \
tester2((ua) => /EdgiOS/.test(ua)),\n  firefox: tester2((ua) => \
/Firefox/.test(ua)),\n  firefoxWebKit: tester2((ua) => /FxiOS/.test(ua)),\n  \
mobile: tester2((ua) => \
/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua)),\n \
 safari: tester2((ua, vendor) => /Safari/.test(ua) && /Apple \
Computer/.test(vendor))\n};\nvar platforms = {\n  mac: tester2((platform) => \
/^Mac/.test(platform)),\n  win: tester2((platform) => \
/^Win/.test(platform)),\n  linux: tester2((platform) => \
/^Linux/.test(platform)),\n  ios: tester2((ua) => \
/iPhone|iPad|iPod/i.test(ua))\n};\nfunction setBrowserMeta() {\n  let {\n    \
userAgent = navigator.userAgent,\n    vendor = navigator.vendor\n  } = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n  \
objectEach(browsers, (_ref) => {\n    let {\n      test\n    } = _ref;\n    \
return void test(userAgent, vendor);\n  });\n}\nfunction setPlatformMeta() \
{\n  let {\n    platform = navigator.platform\n  } = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : {};\n  objectEach(platforms, (_ref2) \
=> {\n    let {\n      test\n    } = _ref2;\n    return void \
test(platform);\n  });\n}\nsetBrowserMeta();\nsetPlatformMeta();\nfunction \
isChrome() {\n  return browsers.chrome.value;\n}\nfunction isChromeWebKit() \
{\n  return browsers.chromeWebKit.value;\n}\nfunction isFirefox() {\n  return \
browsers.firefox.value;\n}\nfunction isFirefoxWebKit() {\n  return \
browsers.firefoxWebKit.value;\n}\nfunction isSafari() {\n  return \
browsers.safari.value;\n}\nfunction isEdge() {\n  return \
browsers.edge.value;\n}\nfunction isEdgeWebKit() {\n  return \
browsers.edgeWebKit.value;\n}\nfunction isMobileBrowser() {\n  return \
browsers.mobile.value;\n}\nfunction isIOS() {\n  return \
platforms.ios.value;\n}\nfunction isIpadOS() {\n  let {\n    maxTouchPoints\n \
 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
navigator;\n  return maxTouchPoints > 2 && platforms.mac.value;\n}\nfunction \
isWindowsOS() {\n  return platforms.win.value;\n}\nfunction isMacOS() {\n  \
return platforms.mac.value;\n}\nfunction isLinuxOS() {\n  return \
platforms.linux.value;\n}\n\n// \
node_modules/handsontable/helpers/unicode.mjs\nvar unicode_exports = \
{};\n__export(unicode_exports, {\n  KEY_CODES: () => KEY_CODES,\n  isCtrlKey: \
() => isCtrlKey,\n  isCtrlMetaKey: () => isCtrlMetaKey,\n  isFunctionKey: () \
=> isFunctionKey,\n  isKey: () => isKey,\n  isPrintableChar: () => \
isPrintableChar\n});\nvar KEY_CODES = {\n  ALT: 18,\n  ARROW_DOWN: 40,\n  \
ARROW_LEFT: 37,\n  ARROW_RIGHT: 39,\n  ARROW_UP: 38,\n  AUDIO_DOWN: \
isFirefox() ? 182 : 174,\n  AUDIO_MUTE: isFirefox() ? 181 : 173,\n  AUDIO_UP: \
isFirefox() ? 183 : 175,\n  BACKSPACE: 8,\n  CAPS_LOCK: 20,\n  COMMA: 188,\n  \
COMMAND_LEFT: 91,\n  COMMAND_RIGHT: 93,\n  COMMAND_FIREFOX: 224,\n  CONTROL: \
17,\n  DELETE: 46,\n  END: 35,\n  ENTER: 13,\n  ESCAPE: 27,\n  F1: 112,\n  \
F2: 113,\n  F3: 114,\n  F4: 115,\n  F5: 116,\n  F6: 117,\n  F7: 118,\n  F8: \
119,\n  F9: 120,\n  F10: 121,\n  F11: 122,\n  F12: 123,\n  F13: 124,\n  F14: \
125,\n  F15: 126,\n  F16: 127,\n  F17: 128,\n  F18: 129,\n  F19: 130,\n  \
HOME: 36,\n  INSERT: 45,\n  MEDIA_NEXT: 176,\n  MEDIA_PLAY_PAUSE: 179,\n  \
MEDIA_PREV: 177,\n  MEDIA_STOP: 178,\n  NULL: 0,\n  NUM_LOCK: 144,\n  \
PAGE_DOWN: 34,\n  PAGE_UP: 33,\n  PAUSE: 19,\n  PERIOD: 190,\n  SCROLL_LOCK: \
145,\n  SHIFT: 16,\n  SPACE: 32,\n  TAB: 9,\n  A: 65,\n  C: 67,\n  D: 68,\n  \
F: 70,\n  L: 76,\n  O: 79,\n  P: 80,\n  S: 83,\n  V: 86,\n  X: 88,\n  Y: \
89,\n  Z: 90\n};\nvar FUNCTION_KEYS = [KEY_CODES.ALT, KEY_CODES.ARROW_DOWN, \
KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_UP, \
KEY_CODES.AUDIO_DOWN, KEY_CODES.AUDIO_MUTE, KEY_CODES.AUDIO_UP, \
KEY_CODES.BACKSPACE, KEY_CODES.CAPS_LOCK, KEY_CODES.DELETE, KEY_CODES.END, \
KEY_CODES.ENTER, KEY_CODES.ESCAPE, KEY_CODES.F1, KEY_CODES.F2, KEY_CODES.F3, \
KEY_CODES.F4, KEY_CODES.F5, KEY_CODES.F6, KEY_CODES.F7, KEY_CODES.F8, \
KEY_CODES.F9, KEY_CODES.F10, KEY_CODES.F11, KEY_CODES.F12, KEY_CODES.F13, \
KEY_CODES.F14, KEY_CODES.F15, KEY_CODES.F16, KEY_CODES.F17, KEY_CODES.F18, \
KEY_CODES.F19, KEY_CODES.HOME, KEY_CODES.INSERT, KEY_CODES.MEDIA_NEXT, \
KEY_CODES.MEDIA_PLAY_PAUSE, KEY_CODES.MEDIA_PREV, KEY_CODES.MEDIA_STOP, \
KEY_CODES.NULL, KEY_CODES.NUM_LOCK, KEY_CODES.PAGE_DOWN, KEY_CODES.PAGE_UP, \
KEY_CODES.PAUSE, KEY_CODES.SCROLL_LOCK, KEY_CODES.SHIFT, \
KEY_CODES.TAB];\nfunction isPrintableChar(keyCode) {\n  return keyCode === 32 \
|| // space\n  keyCode >= 48 && keyCode <= 57 || // 0-9\n  keyCode >= 96 && \
keyCode <= 111 || // numpad\n  keyCode >= 186 && keyCode <= 192 || // \
;=,-./`\n  keyCode >= 219 && keyCode <= 222 || // []{}\\|\"'\n  keyCode >= \
226 || // special chars (229 for Asian chars)\n  keyCode >= 65 && keyCode <= \
90;\n}\nfunction isFunctionKey(keyCode) {\n  return \
FUNCTION_KEYS.includes(keyCode);\n}\nfunction isCtrlKey(keyCode) {\n  const \
keys = [];\n  if (isMacOS()) {\n    keys.push(KEY_CODES.COMMAND_LEFT, \
KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX);\n  } else {\n    \
keys.push(KEY_CODES.CONTROL);\n  }\n  return \
keys.includes(keyCode);\n}\nfunction isCtrlMetaKey(keyCode) {\n  return \
[KEY_CODES.CONTROL, KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, \
KEY_CODES.COMMAND_FIREFOX].includes(keyCode);\n}\nfunction isKey(keyCode, \
baseCode) {\n  const keys = baseCode.split(\"|\");\n  let result = false;\n  \
arrayEach(keys, (key) => {\n    if (keyCode === KEY_CODES[key]) {\n      \
result = true;\n      return false;\n    }\n  });\n  return result;\n}\n\n// \
node_modules/handsontable/helpers/dom/event.mjs\nvar event_exports = \
{};\n__export(event_exports, {\n  isImmediatePropagationStopped: () => \
isImmediatePropagationStopped,\n  isLeftClick: () => isLeftClick,\n  \
isRightClick: () => isRightClick,\n  stopImmediatePropagation: () => \
stopImmediatePropagation\n});\nfunction stopImmediatePropagation(event2) {\n  \
event2.isImmediatePropagationEnabled = false;\n  event2.cancelBubble = \
true;\n}\nfunction isImmediatePropagationStopped(event2) {\n  return \
event2.isImmediatePropagationEnabled === false;\n}\nfunction \
isRightClick(event2) {\n  return event2.button === 2;\n}\nfunction \
isLeftClick(event2) {\n  return event2.button === 0;\n}\n\n// \
node_modules/handsontable/helpers/console.mjs\nfunction warn() {\n  if \
(isDefined(console)) {\n    console.warn(...arguments);\n  }\n}\nfunction \
error() {\n  if (isDefined(console)) {\n    console.error(...arguments);\n  \
}\n}\n\n// node_modules/handsontable/pluginHooks.mjs\nvar REGISTERED_HOOKS = \
[\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  \
/**\n   * Fired after resetting a cell's meta. This happens when the {@link \
Core#updateSettings} method is called.\n   *\n   * @event \
Hooks#afterCellMetaReset\n   */\n  \"afterCellMetaReset\",\n  /**\n   * Fired \
after one or more cells has been changed. The changes are triggered in any \
situation when the\n   * value is entered using an editor or changed using \
API (e.q setDataAtCell).\n   *\n   * __Note:__ For performance reasons, the \
`changes` array is null for `\"loadData\"` source.\n   *\n   * @event \
Hooks#afterChange\n   * @param {Array[]} changes 2D array containing \
information about each of the edited cells `[[row, prop, oldVal, newVal], \
...]`. `row` is a visual row index.\n   * @param {string} [source] String \
that identifies source of hook call ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   * @example\n   * ::: only-for javascript\n   * ```js\n   * new \
Handsontable(element, {\n   *   afterChange: (changes) => {\n   *     \
changes?.forEach(([row, prop, oldValue, newValue]) => {\n   *       // Some \
logic...\n   *     });\n   *   }\n   * })\n   * ```\n   * :::\n   *\n   * ::: \
only-for react\n   * ```jsx\n   * <HotTable\n   *   afterChange={(changes, \
source) => {\n   *     changes?.forEach(([row, prop, oldValue, newValue]) => \
{\n   *       // Some logic...\n   *     });\n   *   }}\n   * />\n   * ```\n  \
 * :::\n   */\n  \"afterChange\",\n  /**\n   * Fired each time user opens \
{@link ContextMenu} and after setting up the Context Menu's default options. \
These options are a collection\n   * which user can select by setting an \
array of keys or an array of objects in {@link Options#contextMenu} option.\n \
  *\n   * @event Hooks#afterContextMenuDefaultOptions\n   * @param {Array} \
predefinedItems An array of objects containing information about the \
pre-defined Context Menu items.\n   */\n  \
\"afterContextMenuDefaultOptions\",\n  /**\n   * Fired each time user opens \
{@link ContextMenu} plugin before setting up the Context Menu's items but \
after filtering these options by\n   * user (`contextMenu` option). This hook \
can by helpful to determine if user use specified menu item or to set up\n   \
* one of the menu item to by always visible.\n   *\n   * @event \
Hooks#beforeContextMenuSetItems\n   * @param {object[]} menuItems An array of \
objects containing information about to generated Context Menu items.\n   \
*/\n  \"beforeContextMenuSetItems\",\n  /**\n   * Fired by {@link \
DropdownMenu} plugin after setting up the Dropdown Menu's default options. \
These options are a\n   * collection which user can select by setting an \
array of keys or an array of objects in {@link Options#dropdownMenu}\n   * \
option.\n   *\n   * @event Hooks#afterDropdownMenuDefaultOptions\n   * @param \
{object[]} predefinedItems An array of objects containing information about \
the pre-defined Context Menu items.\n   */\n  \
\"afterDropdownMenuDefaultOptions\",\n  /**\n   * Fired by {@link \
DropdownMenu} plugin before setting up the Dropdown Menu's items but after \
filtering these options\n   * by user (`dropdownMenu` option). This hook can \
by helpful to determine if user use specified menu item or to set\n   * up \
one of the menu item to by always visible.\n   *\n   * @event \
Hooks#beforeDropdownMenuSetItems\n   * @param {object[]} menuItems An array \
of objects containing information about to generated Dropdown Menu items.\n   \
*/\n  \"beforeDropdownMenuSetItems\",\n  /**\n   * Fired by {@link \
ContextMenu} plugin after hiding the Context Menu. This hook is fired when \
{@link Options#contextMenu}\n   * option is enabled.\n   *\n   * @event \
Hooks#afterContextMenuHide\n   * @param {object} context The Context Menu \
plugin instance.\n   */\n  \"afterContextMenuHide\",\n  /**\n   * Fired by \
{@link ContextMenu} plugin before opening the Context Menu. This hook is \
fired when {@link Options#contextMenu}\n   * option is enabled.\n   *\n   * \
@event Hooks#beforeContextMenuShow\n   * @param {object} context The Context \
Menu instance.\n   */\n  \"beforeContextMenuShow\",\n  /**\n   * Fired by \
{@link ContextMenu} plugin after opening the Context Menu. This hook is fired \
when {@link Options#contextMenu}\n   * option is enabled.\n   *\n   * @event \
Hooks#afterContextMenuShow\n   * @param {object} context The Context Menu \
plugin instance.\n   */\n  \"afterContextMenuShow\",\n  /**\n   * Fired by \
{@link CopyPaste} plugin after reaching the copy limit while copying data. \
This hook is fired when\n   * {@link Options#copyPaste} option is enabled.\n  \
 *\n   * @event Hooks#afterCopyLimit\n   * @param {number} selectedRows Count \
of selected copyable rows.\n   * @param {number} selectedColumns Count of \
selected copyable columns.\n   * @param {number} copyRowsLimit Current copy \
rows limit.\n   * @param {number} copyColumnsLimit Current copy columns \
limit.\n   */\n  \"afterCopyLimit\",\n  /**\n   * Fired before created a new \
column.\n   *\n   * @event Hooks#beforeCreateCol\n   * @param {number} index \
Represents the visual index of first newly created column in the data source \
array.\n   * @param {number} amount Number of newly created columns in the \
data source array.\n   * @param {string} [source] String that identifies \
source of hook call\n   *                          ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   * @returns {*} If `false` then creating columns is \
cancelled.\n   * @example\n   * ::: only-for javascript\n   * ```js\n   * // \
Return `false` to cancel column inserting.\n   * new Handsontable(element, \
{\n   *   beforeCreateCol: function(data, coords) {\n   *     return false;\n \
  *   }\n   * });\n   * ```\n   * :::\n   *\n   * ::: only-for react\n   * \
```jsx\n   * // Return `false` to cancel column inserting.\n   * <HotTable\n  \
 *   beforeCreateCol={(data, coords) => {\n   *     return false;\n   *   \
}}\n   * />\n   * ```\n   * :::\n   */\n  \"beforeCreateCol\",\n  /**\n   * \
Fired after the order of columns has changed.\n   * This hook is fired by \
changing column indexes of any type supported by the {@link IndexMapper}.\n   \
*\n   * @event Hooks#afterColumnSequenceChange\n   * @param \
{'init'|'remove'|'insert'|'move'|'update'} [source] A string that indicates \
what caused the change to the order of columns.\n   */\n  \
\"afterColumnSequenceChange\",\n  /**\n   * Fired after created a new \
column.\n   *\n   * @event Hooks#afterCreateCol\n   * @param {number} index \
Represents the visual index of first newly created column in the data \
source.\n   * @param {number} amount Number of newly created columns in the \
data source.\n   * @param {string} [source] String that identifies source of \
hook call\n   *                          ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   */\n  \"afterCreateCol\",\n  /**\n   * Fired before created a \
new row.\n   *\n   * @event Hooks#beforeCreateRow\n   * @param {number} index \
Represents the visual index of first newly created row in the data source \
array.\n   * @param {number} amount Number of newly created rows in the data \
source array.\n   * @param {string} [source] String that identifies source of \
hook call\n   *                          ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   * @returns {*|boolean} If false is returned the action is \
canceled.\n   */\n  \"beforeCreateRow\",\n  /**\n   * Fired after created a \
new row.\n   *\n   * @event Hooks#afterCreateRow\n   * @param {number} index \
Represents the visual index of first newly created row in the data source \
array.\n   * @param {number} amount Number of newly created rows in the data \
source array.\n   * @param {string} [source] String that identifies source of \
hook call\n   *                          ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   */\n  \"afterCreateRow\",\n  /**\n   * Fired after all \
selected cells are deselected.\n   *\n   * @event Hooks#afterDeselect\n   \
*/\n  \"afterDeselect\",\n  /**\n   * Fired after destroying the Handsontable \
instance.\n   *\n   * @event Hooks#afterDestroy\n   */\n  \"afterDestroy\",\n \
 /**\n   * Hook fired after keydown event is handled.\n   *\n   * @event \
Hooks#afterDocumentKeyDown\n   * @param {Event} event A native `keydown` \
event object.\n   */\n  \"afterDocumentKeyDown\",\n  /**\n   * Fired inside \
the Walkontable's selection `draw` method. Can be used to add additional \
class names to cells, depending on the current selection.\n   *\n   * @event \
Hooks#afterDrawSelection\n   * @param {number} currentRow Row index of the \
currently processed cell.\n   * @param {number} currentColumn Column index of \
the currently cell.\n   * @param {number[]} cornersOfSelection Array of the \
current selection in a form of `[startRow, startColumn, endRow, \
endColumn]`.\n   * @param {number|undefined} layerLevel Number indicating \
which layer of selection is currently processed.\n   * @since 0.38.1\n   * \
@returns {string|undefined} Can return a `String`, which will act as an \
additional `className` to be added to the currently processed cell.\n   */\n  \
\"afterDrawSelection\",\n  /**\n   * Fired inside the Walkontable's \
`refreshSelections` method. Can be used to remove additional class names from \
all cells in the table.\n   *\n   * @event Hooks#beforeRemoveCellClassNames\n \
  * @since 0.38.1\n   * @returns {string[]|undefined} Can return an `Array` \
of `String`s. Each of these strings will act like class names to be removed \
from all the cells in the table.\n   */\n  \"beforeRemoveCellClassNames\",\n  \
/**\n   * Fired after getting the cell settings.\n   *\n   * @event \
Hooks#afterGetCellMeta\n   * @param {number} row Visual row index.\n   * \
@param {number} column Visual column index.\n   * @param {object} \
cellProperties Object containing the cell properties.\n   */\n  \
\"afterGetCellMeta\",\n  /**\n   * Fired after retrieving information about a \
column header and appending it to the table header.\n   *\n   * @event \
Hooks#afterGetColHeader\n   * @param {number} column Visual column index.\n   \
* @param {HTMLTableCellElement} TH Header's TH element.\n   * @param {number} \
[headerLevel=0] (Since 12.2.0) Header level index. Accepts positive (0 to \
n)\n   *                                 and negative (-1 to -n) values. For \
positive values, 0 points to the\n   *                                 \
topmost header. For negative values, -1 points to the bottom-most\n   *       \
                          header (the header closest to the cells).\n   */\n  \
\"afterGetColHeader\",\n  /**\n   * Fired after retrieving information about \
a row header and appending it to the table header.\n   *\n   * @event \
Hooks#afterGetRowHeader\n   * @param {number} row Visual row index.\n   * \
@param {HTMLTableCellElement} TH Header's TH element.\n   */\n  \
\"afterGetRowHeader\",\n  /**\n   * Fired after the Handsontable instance is \
initiated.\n   *\n   * @event Hooks#afterInit\n   */\n  \"afterInit\",\n  \
/**\n   * Fired after Handsontable's [`data`](@/api/options.md#data)\n   * \
gets modified by the [`loadData()`](@/api/core.md#loaddata) method\n   * or \
the [`updateSettings()`](@/api/core.md#updatesettings) method.\n   *\n   * \
Read more:\n   * - [Binding to \
data](@/guides/getting-started/binding-to-data.md)\n   * - [Saving \
data](@/guides/getting-started/saving-data.md)\n   *\n   * @event \
Hooks#afterLoadData\n   * @param {Array} sourceData An [array of \
arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an \
[array of \
objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that \
contains Handsontable's data\n   * @param {boolean} initialLoad A flag that \
indicates whether the data was loaded at Handsontable's initialization \
(`true`) or later (`false`)\n   * @param {string} source The source of the \
call\n   */\n  \"afterLoadData\",\n  /**\n   * Fired after the \
[`updateData()`](@/api/core.md#updatedata) method\n   * modifies \
Handsontable's [`data`](@/api/options.md#data).\n   *\n   * Read more:\n   * \
- [Binding to data](@/guides/getting-started/binding-to-data.md)\n   * - \
[Saving data](@/guides/getting-started/saving-data.md)\n   *\n   * @event \
Hooks#afterUpdateData\n   * @since 11.1.0\n   * @param {Array} sourceData An \
[array of \
arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an \
[array of \
objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that \
contains Handsontable's data\n   * @param {boolean} initialLoad A flag that \
indicates whether the data was loaded at Handsontable's initialization \
(`true`) or later (`false`)\n   * @param {string} source The source of the \
call\n   */\n  \"afterUpdateData\",\n  /**\n   * Fired after a scroll event, \
which is identified as a momentum scroll (e.g. On an iPad).\n   *\n   * \
@event Hooks#afterMomentumScroll\n   */\n  \"afterMomentumScroll\",\n  /**\n  \
 * Fired after a `mousedown` event is triggered on the cell corner (the drag \
handle).\n   *\n   * @event Hooks#afterOnCellCornerMouseDown\n   * @param \
{Event} event `mousedown` event object.\n   */\n  \
\"afterOnCellCornerMouseDown\",\n  /**\n   * Fired after a `dblclick` event \
is triggered on the cell corner (the drag handle).\n   *\n   * @event \
Hooks#afterOnCellCornerDblClick\n   * @param {Event} event `dblclick` event \
object.\n   */\n  \"afterOnCellCornerDblClick\",\n  /**\n   * Fired after \
clicking on a cell or row/column header. In case the row/column header was \
clicked, the coordinate\n   * indexes are negative.\n   *\n   * For example \
clicking on the row header of cell (0, 0) results with `afterOnCellMouseDown` \
called\n   * with coordinates `{row: 0, col: -1}`.\n   *\n   * @event \
Hooks#afterOnCellMouseDown\n   * @param {Event} event `mousedown` event \
object.\n   * @param {CellCoords} coords Coordinates object containing the \
visual row and visual column indexes of the clicked cell.\n   * @param \
{HTMLTableCellElement} TD Cell's TD (or TH) element.\n   */\n  \
\"afterOnCellMouseDown\",\n  /**\n   * Fired after clicking on a cell or \
row/column header. In case the row/column header was clicked, the \
coordinate\n   * indexes are negative.\n   *\n   * For example clicking on \
the row header of cell (0, 0) results with `afterOnCellMouseUp` called\n   * \
with coordinates `{row: 0, col: -1}`.\n   *\n   * @event \
Hooks#afterOnCellMouseUp\n   * @param {Event} event `mouseup` event object.\n \
  * @param {CellCoords} coords Coordinates object containing the visual row \
and visual column indexes of the clicked cell.\n   * @param \
{HTMLTableCellElement} TD Cell's TD (or TH) element.\n   */\n  \
\"afterOnCellMouseUp\",\n  /**\n   * Fired after clicking right mouse button \
on a cell or row/column header.\n   *\n   * For example clicking on the row \
header of cell (0, 0) results with `afterOnCellContextMenu` called\n   * with \
coordinates `{row: 0, col: -1}`.\n   *\n   * @event \
Hooks#afterOnCellContextMenu\n   * @since 4.1.0\n   * @param {Event} event \
`contextmenu` event object.\n   * @param {CellCoords} coords Coordinates \
object containing the visual row and visual column indexes of the clicked \
cell.\n   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.\n   \
*/\n  \"afterOnCellContextMenu\",\n  /**\n   * Fired after hovering a cell or \
row/column header with the mouse cursor. In case the row/column header was\n  \
 * hovered, the index is negative.\n   *\n   * For example, hovering over the \
row header of cell (0, 0) results with `afterOnCellMouseOver` called\n   * \
with coords `{row: 0, col: -1}`.\n   *\n   * @event \
Hooks#afterOnCellMouseOver\n   * @param {Event} event `mouseover` event \
object.\n   * @param {CellCoords} coords Hovered cell's visual coordinate \
object.\n   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.\n   \
*/\n  \"afterOnCellMouseOver\",\n  /**\n   * Fired after leaving a cell or \
row/column header with the mouse cursor.\n   *\n   * @event \
Hooks#afterOnCellMouseOut\n   * @param {Event} event `mouseout` event \
object.\n   * @param {CellCoords} coords Leaved cell's visual coordinate \
object.\n   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.\n   \
*/\n  \"afterOnCellMouseOut\",\n  /**\n   * Fired after one or more columns \
are removed.\n   *\n   * @event Hooks#afterRemoveCol\n   * @param {number} \
index Visual index of starter column.\n   * @param {number} amount An amount \
of removed columns.\n   * @param {number[]} physicalColumns An array of \
physical columns removed from the data source.\n   * @param {string} [source] \
String that identifies source of hook call\n   *                          \
([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   */\n  \"afterRemoveCol\",\n  /**\n   * Fired after one or more \
rows are removed.\n   *\n   * @event Hooks#afterRemoveRow\n   * @param \
{number} index Visual index of starter row.\n   * @param {number} amount An \
amount of removed rows.\n   * @param {number[]} physicalRows An array of \
physical rows removed from the data source.\n   * @param {string} [source] \
String that identifies source of hook call\n   *                          \
([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   */\n  \"afterRemoveRow\",\n  /**\n   * Fired before starting \
rendering the cell.\n   *\n   * @event Hooks#beforeRenderer\n   * @param \
{HTMLTableCellElement} TD Currently rendered cell's TD element.\n   * @param \
{number} row Visual row index.\n   * @param {number} column Visual column \
index.\n   * @param {string|number} prop Column property name or a column \
index, if datasource is an array of arrays.\n   * @param {*} value Value of \
the rendered cell.\n   * @param {object} cellProperties Object containing the \
cell's properties.\n   */\n  \"beforeRenderer\",\n  /**\n   * Fired after \
finishing rendering the cell (after the renderer finishes).\n   *\n   * \
@event Hooks#afterRenderer\n   * @param {HTMLTableCellElement} TD Currently \
rendered cell's TD element.\n   * @param {number} row Visual row index.\n   * \
@param {number} column Visual column index.\n   * @param {string|number} prop \
Column property name or a column index, if datasource is an array of \
arrays.\n   * @param {*} value Value of the rendered cell.\n   * @param \
{object} cellProperties Object containing the cell's properties.\n   */\n  \
\"afterRenderer\",\n  /**\n   * Fired after the order of rows has changed.\n  \
 * This hook is fired by changing row indexes of any type supported by the \
{@link IndexMapper}.\n   *\n   * @event Hooks#afterRowSequenceChange\n   * \
@param {'init'|'remove'|'insert'|'move'|'update'} [source] A string that \
indicates what caused the change to the order of rows.\n   */\n  \
\"afterRowSequenceChange\",\n  /**\n   * Fired after the horizontal scroll \
event.\n   *\n   * @event Hooks#afterScrollHorizontally\n   */\n  \
\"afterScrollHorizontally\",\n  /**\n   * Fired after the vertical scroll \
event.\n   *\n   * @event Hooks#afterScrollVertically\n   */\n  \
\"afterScrollVertically\",\n  /**\n   * Fired after one or more cells are \
selected (e.g. During mouse move).\n   *\n   * @event Hooks#afterSelection\n  \
 * @param {number} row Selection start visual row index.\n   * @param \
{number} column Selection start visual column index.\n   * @param {number} \
row2 Selection end visual row index.\n   * @param {number} column2 Selection \
end visual column index.\n   * @param {object} preventScrolling A reference \
to the observable object with the `value` property.\n   *                     \
             Property `preventScrolling.value` expects a boolean value that\n \
  *                                  Handsontable uses to control scroll \
behavior after selection.\n   * @param {object} preventScrolling Object with \
`value` property where its value change will be observed.\n   * @param \
{number} selectionLayerLevel The number which indicates what selection layer \
is currently modified.\n   * @example\n   * ::: only-for javascript\n   * \
```js\n   * new Handsontable(element, {\n   *   afterSelection: (row, column, \
row2, column2, preventScrolling, selectionLayerLevel) => {\n   *     // If \
set to `false` (default): when cell selection is outside the viewport,\n   *  \
   // Handsontable scrolls the viewport to cell selection's end corner.\n   * \
    // If set to `true`: when cell selection is outside the viewport,\n   *   \
  // Handsontable doesn't scroll to cell selection's end corner.\n   *     \
preventScrolling.value = true;\n   *   }\n   * })\n   * ```\n   * :::\n   *\n \
  * ::: only-for react\n   * ```jsx\n   * <HotTable\n   *   \
afterSelection={(row, column, row2, column2, preventScrolling, \
selectionLayerLevel) => {\n   *     // If set to `false` (default): when cell \
selection is outside the viewport,\n   *     // Handsontable scrolls the \
viewport to cell selection's end corner.\n   *     // If set to `true`: when \
cell selection is outside the viewport,\n   *     // Handsontable doesn't \
scroll to cell selection's end corner.\n   *     preventScrolling.value = \
true;\n   *   }}\n   * />\n   * ```\n   * :::\n   */\n  \"afterSelection\",\n \
 /**\n   * Fired after one or more cells are selected.\n   *\n   * The `prop` \
and `prop2` arguments represent the source object property name instead of \
the column number.\n   *\n   * @event Hooks#afterSelectionByProp\n   * @param \
{number} row Selection start visual row index.\n   * @param {string} prop \
Selection start data source object property name.\n   * @param {number} row2 \
Selection end visual row index.\n   * @param {string} prop2 Selection end \
data source object property name.\n   * @param {object} preventScrolling \
Object with `value` property where its value change will be observed.\n   * \
@param {number} selectionLayerLevel The number which indicates what selection \
layer is currently modified.\n   * @example\n   * ```js\n   * ::: only-for \
javascript\n   * new Handsontable(element, {\n   *   afterSelectionByProp: \
(row, column, row2, column2, preventScrolling, selectionLayerLevel) => {\n   \
*     // setting if prevent scrolling after selection\n   *     \
preventScrolling.value = true;\n   *   }\n   * })\n   * ```\n   * :::\n   *\n \
  * ::: only-for react\n   * ```jsx\n   * <HotTable\n   *   \
afterSelectionByProp={(row, column, row2, column2, preventScrolling, \
selectionLayerLevel) => {\n   *     // setting if prevent scrolling after \
selection\n   *     preventScrolling.value = true;\n   *   }}\n   * />\n   * \
```\n   * :::\n   */\n  \"afterSelectionByProp\",\n  /**\n   * Fired after \
one or more cells are selected (e.g. On mouse up).\n   *\n   * @event \
Hooks#afterSelectionEnd\n   * @param {number} row Selection start visual row \
index.\n   * @param {number} column Selection start visual column index.\n   \
* @param {number} row2 Selection end visual row index.\n   * @param {number} \
column2 Selection end visual column index.\n   * @param {number} \
selectionLayerLevel The number which indicates what selection layer is \
currently modified.\n   */\n  \"afterSelectionEnd\",\n  /**\n   * Fired after \
one or more cells are selected (e.g. On mouse up).\n   *\n   * The `prop` and \
`prop2` arguments represent the source object property name instead of the \
column number.\n   *\n   * @event Hooks#afterSelectionEndByProp\n   * @param \
{number} row Selection start visual row index.\n   * @param {string} prop \
Selection start data source object property index.\n   * @param {number} row2 \
Selection end visual row index.\n   * @param {string} prop2 Selection end \
data source object property index.\n   * @param {number} selectionLayerLevel \
The number which indicates what selection layer is currently modified.\n   \
*/\n  \"afterSelectionEndByProp\",\n  /**\n   * Fired after cell meta is \
changed.\n   *\n   * @event Hooks#afterSetCellMeta\n   * @param {number} row \
Visual row index.\n   * @param {number} column Visual column index.\n   * \
@param {string} key The updated meta key.\n   * @param {*} value The updated \
meta value.\n   */\n  \"afterSetCellMeta\",\n  /**\n   * Fired after cell \
meta is removed.\n   *\n   * @event Hooks#afterRemoveCellMeta\n   * @param \
{number} row Visual row index.\n   * @param {number} column Visual column \
index.\n   * @param {string} key The removed meta key.\n   * @param {*} value \
Value which was under removed key of cell meta.\n   */\n  \
\"afterRemoveCellMeta\",\n  /**\n   * Fired after cell data was changed.\n   \
*\n   * @event Hooks#afterSetDataAtCell\n   * @param {Array} changes An array \
of changes in format `[[row, column, oldValue, value], ...]`.\n   * @param \
{string} [source] String that identifies source of hook call\n   *            \
              ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   */\n  \"afterSetDataAtCell\",\n  /**\n   * Fired after cell \
data was changed.\n   * Called only when `setDataAtRowProp` was executed.\n   \
*\n   * @event Hooks#afterSetDataAtRowProp\n   * @param {Array} changes An \
array of changes in format `[[row, prop, oldValue, value], ...]`.\n   * \
@param {string} [source] String that identifies source of hook call\n   *     \
                     ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   */\n  \"afterSetDataAtRowProp\",\n  /**\n   * Fired after cell \
source data was changed.\n   *\n   * @event Hooks#afterSetSourceDataAtCell\n  \
 * @since 8.0.0\n   * @param {Array} changes An array of changes in format \
`[[row, column, oldValue, value], ...]`.\n   * @param {string} [source] \
String that identifies source of hook call.\n   */\n  \
\"afterSetSourceDataAtCell\",\n  /**\n   * Fired after calling the \
`updateSettings` method.\n   *\n   * @event Hooks#afterUpdateSettings\n   * \
@param {object} newSettings New settings object.\n   */\n  \
\"afterUpdateSettings\",\n  /**\n   * @description\n   * A plugin hook \
executed after validator function, only if validator function is defined.\n   \
* Validation result is the first parameter. This can be used to determinate \
if validation passed successfully or not.\n   *\n   * __Returning false from \
the callback will mark the cell as invalid__.\n   *\n   * @event \
Hooks#afterValidate\n   * @param {boolean} isValid `true` if valid, `false` \
if not.\n   * @param {*} value The value in question.\n   * @param {number} \
row Visual row index.\n   * @param {string|number} prop Property name / \
visual column index.\n   * @param {string} [source] String that identifies \
source of hook call\n   *                          ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   * @returns {undefined | boolean} If `false` the cell will be \
marked as invalid, `true` otherwise.\n   */\n  \"afterValidate\",\n  /**\n   \
* Fired before successful change of language (when proper language code was \
set).\n   *\n   * @event Hooks#beforeLanguageChange\n   * @since 0.35.0\n   * \
@param {string} languageCode New language code.\n   */\n  \
\"beforeLanguageChange\",\n  /**\n   * Fired after successful change of \
language (when proper language code was set).\n   *\n   * @event \
Hooks#afterLanguageChange\n   * @since 0.35.0\n   * @param {string} \
languageCode New language code.\n   */\n  \"afterLanguageChange\",\n  /**\n   \
* Fired by {@link Autofill} plugin before populating the data in the autofill \
feature. This hook is fired when\n   * {@link Options#fillHandle} option is \
enabled.\n   *\n   * @event Hooks#beforeAutofill\n   * @param {Array[]} \
selectionData Data the autofill operation will start from.\n   * @param \
{CellRange} sourceRange The range values will be filled from.\n   * @param \
{CellRange} targetRange The range new values will be filled into.\n   * \
@param {string} direction Declares the direction of the autofill. Possible \
values: `up`, `down`, `left`, `right`.\n   *\n   * @returns {boolean|Array[]} \
If false, the operation is cancelled. If array of arrays, the returned data\n \
  *                              will be passed into `populateFromArray` \
instead of the default autofill\n   *                              \
algorithm's result.\n   */\n  \"beforeAutofill\",\n  /**\n   * Fired by \
{@link Autofill} plugin after populating the data in the autofill feature. \
This hook is fired when\n   * {@link Options#fillHandle} option is enabled.\n \
  *\n   * @event Hooks#afterAutofill\n   * @since 8.0.0\n   * @param \
{Array[]} fillData The data that was used to fill the `targetRange`. If \
`beforeAutofill` was used\n   *                            and returned \
`[[]]`, this will be the same object that was returned from \
`beforeAutofill`.\n   * @param {CellRange} sourceRange The range values will \
be filled from.\n   * @param {CellRange} targetRange The range new values \
will be filled into.\n   * @param {string} direction Declares the direction \
of the autofill. Possible values: `up`, `down`, `left`, `right`.\n   */\n  \
\"afterAutofill\",\n  /**\n   * Fired before aligning the cell contents.\n   \
*\n   * @event Hooks#beforeCellAlignment\n   * @param {object} stateBefore An \
object with class names defining the cell alignment.\n   * @param \
{CellRange[]} range An array of CellRange coordinates where the alignment \
will be applied.\n   * @param {string} type Type of the alignment - either \
`horizontal` or `vertical`.\n   * @param {string} alignmentClass String \
defining the alignment class added to the cell.\n   * Possible values:\n   * \
* `htLeft`\n   * * `htCenter`\n   * * `htRight`\n   * * `htJustify`\n   * * \
`htTop`\n   * * `htMiddle`\n   * * `htBottom`.\n   */\n  \
\"beforeCellAlignment\",\n  /**\n   * Fired before one or more cells are \
changed.\n   *\n   * Use this hook to silently alter the user's changes \
before Handsontable re-renders.\n   *\n   * To ignore the user's changes, use \
a nullified array or return `false`.\n   *\n   * @event Hooks#beforeChange\n  \
 * @param {Array[]} changes 2D array containing information about each of the \
edited cells `[[row, prop, oldVal, newVal], ...]`. `row` is a visual row \
index.\n   * @param {string} [source] String that identifies source of hook \
call\n   *                          ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   * @returns {undefined | boolean} If `false` all changes were \
cancelled, `true` otherwise.\n   * @example\n   * ::: only-for javascript\n   \
* ```js\n   * // to alter a single change, overwrite the value with \
`changes[i][3]`\n   * new Handsontable(element, {\n   *   beforeChange: \
(changes, source) => {\n   *     // [[row, prop, oldVal, newVal], ...]\n   *  \
   changes[0][3] = 10;\n   *   }\n   * });\n   *\n   * // to ignore a single \
change, set `changes[i]` to `null`\n   * // or remove `changes[i]` from the \
array, by using `changes.splice(i, 1)`\n   * new Handsontable(element, {\n   \
*   beforeChange: (changes, source) => {\n   *     // [[row, prop, oldVal, \
newVal], ...]\n   *     changes[0] = null;\n   *   }\n   * });\n   *\n   * // \
to ignore all changes, return `false`\n   * // or set the array's length to \
0, by using `changes.length = 0`\n   * new Handsontable(element, {\n   *   \
beforeChange: (changes, source) => {\n   *     // [[row, prop, oldVal, \
newVal], ...]\n   *     return false;\n   *   }\n   * });\n   * ```\n   * \
:::\n   *\n   * ::: only-for react\n   * ```jsx\n   * // to alter a single \
change, overwrite the desired value with `changes[i][3]`\n   * <HotTable\n   \
*   beforeChange={(changes, source) => {\n   *     // [[row, prop, oldVal, \
newVal], ...]\n   *     changes[0][3] = 10;\n   *   }}\n   * />\n   *\n   * \
// to ignore a single change, set `changes[i]` to `null`\n   * // or remove \
`changes[i]` from the array, by using changes.splice(i, 1).\n   * <HotTable\n \
  *   beforeChange={(changes, source) => {\n   *     // [[row, prop, oldVal, \
newVal], ...]\n   *     changes[0] = null;\n   *   }}\n   * />\n   *\n   * // \
to ignore all changes, return `false`\n   * // or set the array's length to 0 \
(`changes.length = 0`)\n   * <HotTable\n   *   beforeChange={(changes, \
source) => {\n   *     // [[row, prop, oldVal, newVal], ...]\n   *     return \
false;\n   *   }}\n   * />\n   * ```\n   * :::\n   */\n  \"beforeChange\",\n  \
/**\n   * Fired right before rendering the changes.\n   *\n   * @event \
Hooks#beforeChangeRender\n   * @param {Array[]} changes Array in form of \
`[row, prop, oldValue, newValue]`.\n   * @param {string} [source] String that \
identifies source of hook call\n   *                          ([list of all \
available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   */\n  \"beforeChangeRender\",\n  /**\n   * Fired before \
drawing the borders.\n   *\n   * @event Hooks#beforeDrawBorders\n   * @param \
{Array} corners Array specifying the current selection borders.\n   * @param \
{string} borderClassName Specifies the border class name.\n   */\n  \
\"beforeDrawBorders\",\n  /**\n   * Fired before getting cell settings.\n   \
*\n   * @event Hooks#beforeGetCellMeta\n   * @param {number} row Visual row \
index.\n   * @param {number} column Visual column index.\n   * @param \
{object} cellProperties Object containing the cell's properties.\n   */\n  \
\"beforeGetCellMeta\",\n  /**\n   * Fired before cell meta is removed.\n   \
*\n   * @event Hooks#beforeRemoveCellMeta\n   * @param {number} row Visual \
row index.\n   * @param {number} column Visual column index.\n   * @param \
{string} key The removed meta key.\n   * @param {*} value Value which is \
under removed key of cell meta.\n   * @returns {*|boolean} If false is \
returned the action is canceled.\n   */\n  \"beforeRemoveCellMeta\",\n  /**\n \
  * Fired before the Handsontable instance is initiated.\n   *\n   * @event \
Hooks#beforeInit\n   */\n  \"beforeInit\",\n  /**\n   * Fired before the \
Walkontable instance is initiated.\n   *\n   * @event \
Hooks#beforeInitWalkontable\n   * @param {object} walkontableConfig \
Walkontable configuration object.\n   */\n  \"beforeInitWalkontable\",\n  \
/**\n   * Fired before Handsontable's [`data`](@/api/options.md#data)\n   * \
gets modified by the [`loadData()`](@/api/core.md#loaddata) method\n   * or \
the [`updateSettings()`](@/api/core.md#updatesettings) method.\n   *\n   * \
Read more:\n   * - [Binding to \
data](@/guides/getting-started/binding-to-data.md)\n   * - [Saving \
data](@/guides/getting-started/saving-data.md)\n   *\n   * @event \
Hooks#beforeLoadData\n   * @since 8.0.0\n   * @param {Array} sourceData An \
[array of \
arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an \
[array of \
objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that \
contains Handsontable's data\n   * @param {boolean} initialLoad A flag that \
indicates whether the data was loaded at Handsontable's initialization \
(`true`) or later (`false`)\n   * @param {string} source The source of the \
call\n   * @returns {Array} The returned array will be used as Handsontable's \
new dataset.\n   */\n  \"beforeLoadData\",\n  /**\n   * Fired before the \
[`updateData()`](@/api/core.md#updatedata) method\n   * modifies \
Handsontable's [`data`](@/api/options.md#data).\n   *\n   * Read more:\n   * \
- [Binding to data](@/guides/getting-started/binding-to-data.md)\n   * - \
[Saving data](@/guides/getting-started/saving-data.md)\n   *\n   * @event \
Hooks#beforeUpdateData\n   * @since 11.1.0\n   * @param {Array} sourceData An \
[array of \
arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an \
[array of \
objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that \
contains Handsontable's data\n   * @param {boolean} initialLoad A flag that \
indicates whether the data was loaded at Handsontable's initialization \
(`true`) or later (`false`)\n   * @param {string} source The source of the \
call\n   * @returns {Array} The returned array will be used as Handsontable's \
new dataset.\n   */\n  \"beforeUpdateData\",\n  /**\n   * Hook fired before \
keydown event is handled. It can be used to stop default key bindings.\n   \
*\n   * __Note__: To prevent default behavior you need to call `false` in \
your `beforeKeyDown` handler.\n   *\n   * @event Hooks#beforeKeyDown\n   * \
@param {Event} event Original DOM event.\n   */\n  \"beforeKeyDown\",\n  \
/**\n   * Fired after the user clicked a cell, but before all the \
calculations related with it.\n   *\n   * @event \
Hooks#beforeOnCellMouseDown\n   * @param {Event} event The `mousedown` event \
object.\n   * @param {CellCoords} coords Cell coords object containing the \
visual coordinates of the clicked cell.\n   * @param {HTMLTableCellElement} \
TD TD element.\n   * @param {object} controller An object with properties \
`row`, `column` and `cell`. Each property contains\n   *                      \
      a boolean value that allows or disallows changing the selection for \
that particular area.\n   */\n  \"beforeOnCellMouseDown\",\n  /**\n   * Fired \
after the user clicked a cell.\n   *\n   * @event Hooks#beforeOnCellMouseUp\n \
  * @param {Event} event The `mouseup` event object.\n   * @param \
{CellCoords} coords Cell coords object containing the visual coordinates of \
the clicked cell.\n   * @param {HTMLTableCellElement} TD TD element.\n   */\n \
 \"beforeOnCellMouseUp\",\n  /**\n   * Fired after the user clicked a cell, \
but before all the calculations related with it.\n   *\n   * @event \
Hooks#beforeOnCellContextMenu\n   * @since 4.1.0\n   * @param {Event} event \
The `contextmenu` event object.\n   * @param {CellCoords} coords Cell coords \
object containing the visual coordinates of the clicked cell.\n   * @param \
{HTMLTableCellElement} TD TD element.\n   */\n  \
\"beforeOnCellContextMenu\",\n  /**\n   * Fired after the user moved cursor \
over a cell, but before all the calculations related with it.\n   *\n   * \
@event Hooks#beforeOnCellMouseOver\n   * @param {Event} event The `mouseover` \
event object.\n   * @param {CellCoords} coords CellCoords object containing \
the visual coordinates of the clicked cell.\n   * @param \
{HTMLTableCellElement} TD TD element.\n   * @param {object} controller An \
object with properties `row`, `column` and `cell`. Each property contains\n   \
*                            a boolean value that allows or disallows \
changing the selection for that particular area.\n   */\n  \
\"beforeOnCellMouseOver\",\n  /**\n   * Fired after the user moved cursor out \
from a cell, but before all the calculations related with it.\n   *\n   * \
@event Hooks#beforeOnCellMouseOut\n   * @param {Event} event The `mouseout` \
event object.\n   * @param {CellCoords} coords CellCoords object containing \
the visual coordinates of the leaved cell.\n   * @param \
{HTMLTableCellElement} TD TD element.\n   */\n  \"beforeOnCellMouseOut\",\n  \
/**\n   * Fired before one or more columns are about to be removed.\n   *\n   \
* @event Hooks#beforeRemoveCol\n   * @param {number} index Visual index of \
starter column.\n   * @param {number} amount Amount of columns to be \
removed.\n   * @param {number[]} physicalColumns An array of physical columns \
removed from the data source.\n   * @param {string} [source] String that \
identifies source of hook call\n   *                          ([list of all \
available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   * @returns {*|boolean} If false is returned the action is \
canceled.\n   */\n  \"beforeRemoveCol\",\n  /**\n   * Fired when one or more \
rows are about to be removed.\n   *\n   * @event Hooks#beforeRemoveRow\n   * \
@param {number} index Visual index of starter row.\n   * @param {number} \
amount Amount of rows to be removed.\n   * @param {number[]} physicalRows An \
array of physical rows removed from the data source.\n   * @param {string} \
[source] String that identifies source of hook call\n   *                     \
     ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   * @returns {*|boolean} If false is returned the action is \
canceled.\n   */\n  \"beforeRemoveRow\",\n  /**\n   * Fired before \
Handsontable's view-rendering engine is rendered.\n   *\n   * __Note:__ In \
Handsontable 9.x and earlier, the `beforeViewRender` hook was named \
`beforeRender`.\n   *\n   * @event Hooks#beforeViewRender\n   * @since \
10.0.0\n   * @param {boolean} isForced If set to `true`, the rendering gets \
triggered by a change of settings, a change of\n   *                          \
 data, or a logic that needs a full Handsontable render cycle.\n   *          \
                 If set to `false`, the rendering gets triggered by scrolling \
or moving the selection.\n   * @param {object} skipRender Object with \
`skipRender` property, if it is set to `true ` the next rendering cycle will \
be skipped.\n   */\n  \"beforeViewRender\",\n  /**\n   * Fired after \
Handsontable's view-rendering engine is rendered,\n   * but before redrawing \
the selection borders and before scroll syncing.\n   *\n   * __Note:__ In \
Handsontable 9.x and earlier, the `afterViewRender` hook was named \
`afterRender`.\n   *\n   * @event Hooks#afterViewRender\n   * @since 10.0.0\n \
  * @param {boolean} isForced If set to `true`, the rendering gets triggered \
by a change of settings, a change of\n   *                           data, or \
a logic that needs a full Handsontable render cycle.\n   *                    \
       If set to `false`, the rendering gets triggered by scrolling or moving \
the selection.\n   */\n  \"afterViewRender\",\n  /**\n   * Fired before \
Handsontable's view-rendering engine updates the view.\n   *\n   * The \
`beforeRender` event is fired right after the Handsontable\n   * business \
logic is executed and right before the rendering engine starts calling\n   * \
the Core logic, renderers, cell meta objects etc. to update the view.\n   *\n \
  * @event Hooks#beforeRender\n   * @param {boolean} isForced If set to \
`true`, the rendering gets triggered by a change of settings, a change of\n   \
*                           data, or a logic that needs a full Handsontable \
render cycle.\n   *                           If set to `false`, the \
rendering gets triggered by scrolling or moving the selection.\n   */\n  \
\"beforeRender\",\n  /**\n   * Fired after Handsontable's view-rendering \
engine updates the view.\n   *\n   * @event Hooks#afterRender\n   * @param \
{boolean} isForced If set to `true`, the rendering gets triggered by a change \
of settings, a change of\n   *                           data, or a logic \
that needs a full Handsontable render cycle.\n   *                           \
If set to `false`, the rendering gets triggered by scrolling or moving the \
selection.\n   */\n  \"afterRender\",\n  /**\n   * Fired before cell meta is \
changed.\n   *\n   * @event Hooks#beforeSetCellMeta\n   * @since 8.0.0\n   * \
@param {number} row Visual row index.\n   * @param {number} column Visual \
column index.\n   * @param {string} key The updated meta key.\n   * @param \
{*} value The updated meta value.\n   * @returns {boolean|undefined} If false \
is returned the action is canceled.\n   */\n  \"beforeSetCellMeta\",\n  /**\n \
  * Fired before setting range is started but not finished yet.\n   *\n   * \
@event Hooks#beforeSetRangeStartOnly\n   * @param {CellCoords} coords \
CellCoords instance.\n   */\n  \"beforeSetRangeStartOnly\",\n  /**\n   * \
Fired before setting range is started.\n   *\n   * @event \
Hooks#beforeSetRangeStart\n   * @param {CellCoords} coords CellCoords \
instance.\n   */\n  \"beforeSetRangeStart\",\n  /**\n   * Fired before \
setting range is ended.\n   *\n   * @event Hooks#beforeSetRangeEnd\n   * \
@param {CellCoords} coords CellCoords instance.\n   */\n  \
\"beforeSetRangeEnd\",\n  /**\n   * Fired before the logic of handling a \
touch scroll, when user started scrolling on a touch-enabled device.\n   *\n  \
 * @event Hooks#beforeTouchScroll\n   */\n  \"beforeTouchScroll\",\n  /**\n   \
* Fired before cell validation, only if validator function is defined. This \
can be used to manipulate the value\n   * of changed cell before it is \
applied to the validator function.\n   *\n   * __Note:__ this will not affect \
values of changes. This will change value *ONLY* for validation.\n   *\n   * \
@event Hooks#beforeValidate\n   * @param {*} value Value of the cell.\n   * \
@param {number} row Visual row index.\n   * @param {string|number} prop \
Property name / column index.\n   * @param {string} [source] String that \
identifies source of hook call\n   *                          ([list of all \
available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   */\n  \"beforeValidate\",\n  /**\n   * Fired before cell value \
is rendered into the DOM (through renderer function). This can be used to \
manipulate the\n   * value which is passed to the renderer without modifying \
the renderer itself.\n   *\n   * @event Hooks#beforeValueRender\n   * @param \
{*} value Cell value to render.\n   * @param {object} cellProperties An \
object containing the cell properties.\n   */\n  \"beforeValueRender\",\n  \
/**\n   * Fired after Handsontable instance is constructed (using `new` \
operator).\n   *\n   * @event Hooks#construct\n   */\n  \"construct\",\n  \
/**\n   * Fired after Handsontable instance is initiated but before table is \
rendered.\n   *\n   * @event Hooks#init\n   */\n  \"init\",\n  /**\n   * \
Fired when a column header index is about to be modified by a callback \
function.\n   *\n   * @event Hooks#modifyColHeader\n   * @param {number} \
column Visual column header index.\n   */\n  \"modifyColHeader\",\n  /**\n   \
* Fired when a column width is about to be modified by a callback function.\n \
  *\n   * @event Hooks#modifyColWidth\n   * @param {number} width Current \
column width.\n   * @param {number} column Visual column index.\n   */\n  \
\"modifyColWidth\",\n  /**\n   * Fired when a row header index is about to be \
modified by a callback function.\n   *\n   * @event Hooks#modifyRowHeader\n   \
* @param {number} row Visual row header index.\n   */\n  \
\"modifyRowHeader\",\n  /**\n   * Fired when a row height is about to be \
modified by a callback function.\n   *\n   * @event Hooks#modifyRowHeight\n   \
* @param {number} height Row height.\n   * @param {number} row Visual row \
index.\n   */\n  \"modifyRowHeight\",\n  /**\n   * Fired when a data was \
retrieved or modified.\n   *\n   * @event Hooks#modifyData\n   * @param \
{number} row Physical row index.\n   * @param {number} column Visual column \
index.\n   * @param {object} valueHolder Object which contains original value \
which can be modified by overwriting `.value` property.\n   * @param {string} \
ioMode String which indicates for what operation hook is fired (`get` or \
`set`).\n   */\n  \"modifyData\",\n  /**\n   * Fired when a data was \
retrieved or modified from the source data set.\n   *\n   * @event \
Hooks#modifySourceData\n   * @since 8.0.0\n   * @param {number} row Physical \
row index.\n   * @param {number} column Physical column index or property \
name.\n   * @param {object} valueHolder Object which contains original value \
which can be modified by overwriting `.value` property.\n   * @param {string} \
ioMode String which indicates for what operation hook is fired (`get` or \
`set`).\n   */\n  \"modifySourceData\",\n  /**\n   * Fired when a data was \
retrieved or modified.\n   *\n   * @event Hooks#modifyRowData\n   * @param \
{number} row Physical row index.\n   */\n  \"modifyRowData\",\n  /**\n   * \
Used to modify the cell coordinates when using the `getCell` method, opening \
editor, getting value from the editor\n   * and saving values from the closed \
editor.\n   *\n   * @event Hooks#modifyGetCellCoords\n   * @since 0.36.0\n   \
* @param {number} row Visual row index.\n   * @param {number} column Visual \
column index.\n   * @param {boolean} topmost If set to `true`, it returns the \
TD element from the topmost overlay. For example,\n   *                       \
   if the wanted cell is in the range of fixed rows, it will return a TD \
element\n   *                          from the `top` overlay.\n   * @returns \
{undefined|number[]}\n   */\n  \"modifyGetCellCoords\",\n  /**\n   * Allows \
modify the visual row index that is used to retrieve the row header element \
(TH) before it's\n   * highlighted (proper CSS class names are added). \
Modifying the visual row index allows building a custom\n   * implementation \
of the nested headers feature or other features that require highlighting \
other DOM\n   * elements than that the rendering engine, by default, would \
have highlighted.\n   *\n   * @event Hooks#beforeHighlightingRowHeader\n   * \
@since 8.4.0\n   * @param {number} row Visual row index.\n   * @param \
{number} headerLevel Column header level (0 = most distant to the table).\n   \
* @param {object} highlightMeta An object that contains additional \
information about processed selection.\n   * @returns {number|undefined}\n   \
*/\n  \"beforeHighlightingRowHeader\",\n  /**\n   * Allows modify the visual \
column index that is used to retrieve the column header element (TH) before \
it's\n   * highlighted (proper CSS class names are added). Modifying the \
visual column index allows building a custom\n   * implementation of the \
nested headers feature or other features that require highlighting other \
DOM\n   * elements than that the rendering engine, by default, would have \
highlighted.\n   *\n   * @event Hooks#beforeHighlightingColumnHeader\n   * \
@since 8.4.0\n   * @param {number} column Visual column index.\n   * @param \
{number} headerLevel Row header level (0 = most distant to the table).\n   * \
@param {object} highlightMeta An object that contains additional information \
about processed selection.\n   * @returns {number|undefined}\n   */\n  \
\"beforeHighlightingColumnHeader\",\n  /**\n   * Fired by {@link \
PersistentState} plugin, after loading value, saved under given key, from \
browser local storage.\n   *\n   * The `persistentStateLoad` hook is fired \
even when the {@link Options#persistentState} option is disabled.\n   *\n   * \
@event Hooks#persistentStateLoad\n   * @param {string} key Key.\n   * @param \
{object} valuePlaceholder Object containing the loaded value under \
`valuePlaceholder.value` (if no value have been saved, `value` key will be \
undefined).\n   */\n  \"persistentStateLoad\",\n  /**\n   * Fired by {@link \
PersistentState} plugin after resetting data from local storage. If no key is \
given, all values associated with table will be cleared.\n   * This hook is \
fired when {@link Options#persistentState} option is enabled.\n   *\n   * \
@event Hooks#persistentStateReset\n   * @param {string} [key] Key.\n   */\n  \
\"persistentStateReset\",\n  /**\n   * Fired by {@link PersistentState} \
plugin, after saving value under given key in browser local storage.\n   *\n  \
 * The `persistentStateSave` hook is fired even when the {@link \
Options#persistentState} option is disabled.\n   *\n   * @event \
Hooks#persistentStateSave\n   * @param {string} key Key.\n   * @param {Mixed} \
value Value to save.\n   */\n  \"persistentStateSave\",\n  /**\n   * Fired by \
{@link ColumnSorting} and {@link MultiColumnSorting} plugins before sorting \
the column. If you return `false` value inside callback for hook, then \
sorting\n   * will be not applied by the Handsontable (useful for server-side \
sorting).\n   *\n   * This hook is fired when {@link Options#columnSorting} \
or {@link Options#multiColumnSorting} option is enabled.\n   *\n   * @event \
Hooks#beforeColumnSort\n   * @param {Array} currentSortConfig Current sort \
configuration (for all sorted columns).\n   * @param {Array} \
destinationSortConfigs Destination sort configuration (for all sorted \
columns).\n   * @returns {boolean | undefined} If `false` the column will not \
be sorted, `true` otherwise.\n   */\n  \"beforeColumnSort\",\n  /**\n   * \
Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins after \
sorting the column. This hook is fired when {@link Options#columnSorting}\n   \
* or {@link Options#multiColumnSorting} option is enabled.\n   *\n   * @event \
Hooks#afterColumnSort\n   * @param {Array} currentSortConfig Current sort \
configuration (for all sorted columns).\n   * @param {Array} \
destinationSortConfigs Destination sort configuration (for all sorted \
columns).\n   */\n  \"afterColumnSort\",\n  /**\n   * Fired by {@link \
Autofill} plugin after setting range of autofill. This hook is fired when \
{@link Options#fillHandle}\n   * option is enabled.\n   *\n   * @event \
Hooks#modifyAutofillRange\n   * @param {Array} startArea Array of visual \
coordinates of the starting point for the drag-down operation (`[startRow, \
startColumn, endRow, endColumn]`).\n   * @param {Array} entireArea Array of \
visual coordinates of the entire area of the drag-down operation (`[startRow, \
startColumn, endRow, endColumn]`).\n   */\n  \"modifyAutofillRange\",\n  \
/**\n   * Fired to allow modifying the copyable range with a callback \
function.\n   *\n   * @event Hooks#modifyCopyableRange\n   * @param {Array[]} \
copyableRanges Array of objects defining copyable cells.\n   */\n  \
\"modifyCopyableRange\",\n  /**\n   * Fired by {@link CopyPaste} plugin \
before copying the values to the clipboard and before clearing values of\n   \
* the selected cells. This hook is fired when {@link Options#copyPaste} \
option is enabled.\n   *\n   * @event Hooks#beforeCut\n   * @param {Array[]} \
data An array of arrays which contains data to cut.\n   * @param {object[]} \
coords An array of objects with ranges of the visual indexes (`startRow`, \
`startCol`, `endRow`, `endCol`)\n   *                       which will be cut \
out.\n   * @returns {*} If returns `false` then operation of the cutting out \
is canceled.\n   * @example\n   * ::: only-for javascript\n   * ```js\n   * \
// To disregard a single row, remove it from the array using data.splice(i, \
1).\n   * new Handsontable(element, {\n   *   beforeCut: function(data, \
coords) {\n   *     // data -> [[1, 2, 3], [4, 5, 6]]\n   *     \
data.splice(0, 1);\n   *     // data -> [[4, 5, 6]]\n   *     // coords -> \
[{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]\n   *   }\n   * });\n   * \
// To cancel a cutting action, just return `false`.\n   * new \
Handsontable(element, {\n   *   beforeCut: function(data, coords) {\n   *     \
return false;\n   *   }\n   * });\n   * ```\n   * :::\n   *\n   * ::: \
only-for react\n   * ```jsx\n   * // To disregard a single row, remove it \
from the array using data.splice(i, 1).\n   * <HotTable\n   *   \
beforeCut={(data, coords) => {\n   *     // data -> [[1, 2, 3], [4, 5, 6]]\n  \
 *     data.splice(0, 1);\n   *     // data -> [[4, 5, 6]]\n   *     // \
coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]\n   *   }}\n   * \
/>\n   * // To cancel a cutting action, just return `false`.\n   * \
<HotTable\n   *   beforeCut={(data, coords) => {\n   *     return false;\n   \
*   }}\n   * />\n   * ```\n   * :::\n   */\n  \"beforeCut\",\n  /**\n   * \
Fired by {@link CopyPaste} plugin after data was cut out from the table. This \
hook is fired when\n   * {@link Options#copyPaste} option is enabled.\n   *\n \
  * @event Hooks#afterCut\n   * @param {Array[]} data An array of arrays with \
the cut data.\n   * @param {object[]} coords An array of objects with ranges \
of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n   *      \
                 which was cut out.\n   */\n  \"afterCut\",\n  /**\n   * \
Fired before values are copied to the clipboard.\n   *\n   * @event \
Hooks#beforeCopy\n   * @param {Array[]} data An array of arrays which \
contains data to copied.\n   * @param {object[]} coords An array of objects \
with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, \
`endCol`)\n   *                         which will copied.\n   * @param {{ \
columnHeadersCount: number }} copiedHeadersCount (Since 12.3.0) The number of \
copied column headers.\n   * @returns {*} If returns `false` then copying is \
canceled.\n   *\n   * @example\n   * ::: only-for javascript\n   * ```js\n   \
* // To disregard a single row, remove it from array using data.splice(i, \
1).\n   * ...\n   * new Handsontable(document.getElementById('example'), {\n  \
 *   beforeCopy: (data, coords) => {\n   *     // data -> [[1, 2, 3], [4, 5, \
6]]\n   *     data.splice(0, 1);\n   *     // data -> [[4, 5, 6]]\n   *     \
// coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]\n   *   }\n   \
* });\n   * ...\n   *\n   * // To cancel copying, return false from the \
callback.\n   * ...\n   * new \
Handsontable(document.getElementById('example'), {\n   *   beforeCopy: (data, \
coords) => {\n   *     return false;\n   *   }\n   * });\n   * ...\n   * \
```\n   * :::\n   *\n   * ::: only-for react\n   * ```jsx\n   * // To \
disregard a single row, remove it from array using data.splice(i, 1).\n   * \
...\n   * <HotTable\n   *   beforeCopy={(data, coords) => {\n   *     // data \
-> [[1, 2, 3], [4, 5, 6]]\n   *     data.splice(0, 1);\n   *     // data -> \
[[4, 5, 6]]\n   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, \
endCol: 2}]\n   *   }}\n   * />\n   * ...\n   *\n   * // To cancel copying, \
return false from the callback.\n   * ...\n   * <HotTable\n   *   \
beforeCopy={(data, coords) => {\n   *     return false;\n   *   }}\n   * />\n \
  * ...\n   * ```\n   * :::\n   */\n  \"beforeCopy\",\n  /**\n   * Fired by \
{@link CopyPaste} plugin after data are pasted into table. This hook is fired \
when {@link Options#copyPaste}\n   * option is enabled.\n   *\n   * @event \
Hooks#afterCopy\n   * @param {Array[]} data An array of arrays which contains \
the copied data.\n   * @param {object[]} coords An array of objects with \
ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n   \
*                         which was copied.\n   * @param {{ \
columnHeadersCount: number }} copiedHeadersCount (Since 12.3.0) The number of \
copied column headers.\n   */\n  \"afterCopy\",\n  /**\n   * Fired by {@link \
CopyPaste} plugin before values are pasted into table. This hook is fired \
when\n   * {@link Options#copyPaste} option is enabled.\n   *\n   * @event \
Hooks#beforePaste\n   * @param {Array[]} data An array of arrays which \
contains data to paste.\n   * @param {object[]} coords An array of objects \
with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, \
`endCol`)\n   *                       that correspond to the previously \
selected area.\n   * @returns {*} If returns `false` then pasting is \
canceled.\n   * @example\n   * ```js\n   * ::: only-for javascript\n   * // \
To disregard a single row, remove it from array using data.splice(i, 1).\n   \
* new Handsontable(example, {\n   *   beforePaste: (data, coords) => {\n   *  \
   // data -> [[1, 2, 3], [4, 5, 6]]\n   *     data.splice(0, 1);\n   *     \
// data -> [[4, 5, 6]]\n   *     // coords -> [{startRow: 0, startCol: 0, \
endRow: 1, endCol: 2}]\n   *   }\n   * });\n   * // To cancel pasting, return \
false from the callback.\n   * new Handsontable(example, {\n   *   \
beforePaste: (data, coords) => {\n   *     return false;\n   *   }\n   * \
});\n   * ```\n   * :::\n   *\n   * ::: only-for react\n   * ```jsx\n   * // \
To disregard a single row, remove it from array using data.splice(i, 1).\n   \
* <HotTable\n   *   beforePaste={(data, coords) => {\n   *     // data -> \
[[1, 2, 3], [4, 5, 6]]\n   *     data.splice(0, 1);\n   *     // data -> [[4, \
5, 6]]\n   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: \
2}]\n   *   }}\n   * />\n   * // To cancel pasting, return false from the \
callback.\n   * <HotTable\n   *   beforePaste={(data, coords) => {\n   *     \
return false;\n   *   }}\n   * />\n   * ```\n   * :::\n   */\n  \
\"beforePaste\",\n  /**\n   * Fired by {@link CopyPaste} plugin after values \
are pasted into table. This hook is fired when\n   * {@link \
Options#copyPaste} option is enabled.\n   *\n   * @event Hooks#afterPaste\n   \
* @param {Array[]} data An array of arrays with the pasted data.\n   * @param \
{object[]} coords An array of objects with ranges of the visual indexes \
(`startRow`, `startCol`, `endRow`, `endCol`)\n   *                       that \
correspond to the previously selected area.\n   */\n  \"afterPaste\",\n  \
/**\n   * Fired by the {@link ManualColumnFreeze} plugin, before freezing a \
column.\n   *\n   * @event Hooks#beforeColumnFreeze\n   * @since 12.1.0\n   * \
@param {number} column The visual index of the column that is going to \
freeze.\n   * @param {boolean} freezePerformed If `true`: the column is going \
to freeze. If `false`: the column is not going to freeze (which might happen \
if the column is already frozen).\n   * @returns {boolean|undefined} If \
`false`: the column is not going to freeze, and the `afterColumnFreeze` hook \
won't fire.\n   */\n  \"beforeColumnFreeze\",\n  /**\n   * Fired by the \
{@link ManualColumnFreeze} plugin, right after freezing a column.\n   *\n   * \
@event Hooks#afterColumnFreeze\n   * @since 12.1.0\n   * @param {number} \
column The visual index of the frozen column.\n   * @param {boolean} \
freezePerformed If `true`: the column got successfully frozen. If `false`: \
the column didn't get frozen.\n   */\n  \"afterColumnFreeze\",\n  /**\n   * \
Fired by {@link ManualColumnMove} plugin before change order of the visual \
indexes. This hook is fired when\n   * {@link Options#manualColumnMove} \
option is enabled.\n   *\n   * @event Hooks#beforeColumnMove\n   * @param \
{Array} movedColumns Array of visual column indexes to be moved.\n   * @param \
{number} finalIndex Visual column index, being a start index for the moved \
columns.\n   *                            Points to where the elements will \
be placed after the moving action.\n   *                            To check \
visualization of final index please take a look at\n   *                      \
      [documentation](@/guides/columns/column-moving.md).\n   * @param \
{number|undefined} dropIndex Visual column index, being a drop index for the \
moved columns.\n   *                                     Points to where we \
are going to drop the moved elements. To check\n   *                          \
           visualization of drop index please take a look at\n   *            \
                         \
[documentation](@/guides/columns/column-moving.md).\n   *                     \
                It's `undefined` when `dragColumns` function wasn't called.\n \
  * @param {boolean} movePossible Indicates if it's possible to move rows to \
the desired position.\n   * @returns {undefined | boolean} If `false` the \
column will not be moved, `true` otherwise.\n   */\n  \"beforeColumnMove\",\n \
 /**\n   * Fired by {@link ManualColumnMove} plugin after changing order of \
the visual indexes.\n   * This hook is fired when {@link \
Options#manualColumnMove} option is enabled.\n   *\n   * @event \
Hooks#afterColumnMove\n   * @param {Array} movedColumns Array of visual \
column indexes to be moved.\n   * @param {number} finalIndex Visual column \
index, being a start index for the moved columns.\n   *                       \
     Points to where the elements will be placed after the moving action.\n   \
*                            To check visualization of final index please \
take a look at\n   *                            \
[documentation](@/guides/columns/column-moving.md).\n   * @param \
{number|undefined} dropIndex Visual column index, being a drop index for the \
moved columns.\n   *                                     Points to where we \
are going to drop the moved elements.\n   *                                   \
  To check visualization of drop index please take a look at\n   *            \
                         \
[documentation](@/guides/columns/column-moving.md).\n   *                     \
                It's `undefined` when `dragColumns` function wasn't called.\n \
  * @param {boolean} movePossible Indicates if it was possible to move \
columns to the desired position.\n   * @param {boolean} orderChanged \
Indicates if order of columns was changed by move.\n   */\n  \
\"afterColumnMove\",\n  /**\n   * Fired by the {@link ManualColumnFreeze} \
plugin, before unfreezing a column.\n   *\n   * @event \
Hooks#beforeColumnUnfreeze\n   * @since 12.1.0\n   * @param {number} column \
The visual index of the column that is going to unfreeze.\n   * @param \
{boolean} unfreezePerformed If `true`: the column is going to unfreeze. If \
`false`: the column is not going to unfreeze (which might happen if the \
column is already unfrozen).\n   * @returns {boolean|undefined} If `false`: \
the column is not going to unfreeze, and the `afterColumnUnfreeze` hook won't \
fire.\n   */\n  \"beforeColumnUnfreeze\",\n  /**\n   * Fired by the {@link \
ManualColumnFreeze} plugin, right after unfreezing a column.\n   *\n   * \
@event Hooks#afterColumnUnfreeze\n   * @since 12.1.0\n   * @param {number} \
column The visual index of the unfrozen column.\n   * @param {boolean} \
unfreezePerformed If `true`: the column got successfully unfrozen. If \
`false`: the column didn't get unfrozen.\n   */\n  \"afterColumnUnfreeze\",\n \
 /**\n   * Fired by {@link ManualRowMove} plugin before changing the order of \
the visual indexes. This hook is fired when\n   * {@link \
Options#manualRowMove} option is enabled.\n   *\n   * @event \
Hooks#beforeRowMove\n   * @param {Array} movedRows Array of visual row \
indexes to be moved.\n   * @param {number} finalIndex Visual row index, being \
a start index for the moved rows.\n   *                            Points to \
where the elements will be placed after the moving action.\n   *              \
              To check visualization of final index please take a look at\n   \
*                            [documentation](@/guides/rows/row-moving.md).\n  \
 * @param {number|undefined} dropIndex Visual row index, being a drop index \
for the moved rows.\n   *                                     Points to where \
we are going to drop the moved elements.\n   *                                \
     To check visualization of drop index please take a look at\n   *         \
                            [documentation](@/guides/rows/row-moving.md).\n   \
*                                     It's `undefined` when `dragRows` \
function wasn't called.\n   * @param {boolean} movePossible Indicates if it's \
possible to move rows to the desired position.\n   * @returns {*|boolean} If \
false is returned the action is canceled.\n   */\n  \"beforeRowMove\",\n  \
/**\n   * Fired by {@link ManualRowMove} plugin after changing the order of \
the visual indexes.\n   * This hook is fired when {@link \
Options#manualRowMove} option is enabled.\n   *\n   * @event \
Hooks#afterRowMove\n   * @param {Array} movedRows Array of visual row indexes \
to be moved.\n   * @param {number} finalIndex Visual row index, being a start \
index for the moved rows.\n   *                            Points to where \
the elements will be placed after the moving action.\n   *                    \
        To check visualization of final index please take a look at\n   *     \
                       [documentation](@/guides/rows/row-moving.md).\n   * \
@param {number|undefined} dropIndex Visual row index, being a drop index for \
the moved rows.\n   *                                     Points to where we \
are going to drop the moved elements.\n   *                                   \
  To check visualization of drop index please take a look at\n   *            \
                         [documentation](@/guides/rows/row-moving.md).\n   *  \
                                   It's `undefined` when `dragRows` function \
wasn't called.\n   * @param {boolean} movePossible Indicates if it was \
possible to move rows to the desired position.\n   * @param {boolean} \
orderChanged Indicates if order of rows was changed by move.\n   */\n  \
\"afterRowMove\",\n  /**\n   * Fired by {@link ManualColumnResize} plugin \
before rendering the table with modified column sizes. This hook is\n   * \
fired when {@link Options#manualColumnResize} option is enabled.\n   *\n   * \
@event Hooks#beforeColumnResize\n   * @param {number} newSize Calculated new \
column width.\n   * @param {number} column Visual index of the resized \
column.\n   * @param {boolean} isDoubleClick Flag that determines whether \
there was a double-click.\n   * @returns {number} Returns a new column size \
or `undefined`, if column size should be calculated automatically.\n   */\n  \
\"beforeColumnResize\",\n  /**\n   * Fired by {@link ManualColumnResize} \
plugin after rendering the table with modified column sizes. This hook is\n   \
* fired when {@link Options#manualColumnResize} option is enabled.\n   *\n   \
* @event Hooks#afterColumnResize\n   * @param {number} newSize Calculated new \
column width.\n   * @param {number} column Visual index of the resized \
column.\n   * @param {boolean} isDoubleClick Flag that determines whether \
there was a double-click.\n   */\n  \"afterColumnResize\",\n  /**\n   * Fired \
by {@link ManualRowResize} plugin before rendering the table with modified \
row sizes. This hook is\n   * fired when {@link Options#manualRowResize} \
option is enabled.\n   *\n   * @event Hooks#beforeRowResize\n   * @param \
{number} newSize Calculated new row height.\n   * @param {number} row Visual \
index of the resized row.\n   * @param {boolean} isDoubleClick Flag that \
determines whether there was a double-click.\n   * @returns \
{number|undefined} Returns the new row size or `undefined` if row size should \
be calculated automatically.\n   */\n  \"beforeRowResize\",\n  /**\n   * \
Fired by {@link ManualRowResize} plugin after rendering the table with \
modified row sizes. This hook is\n   * fired when {@link \
Options#manualRowResize} option is enabled.\n   *\n   * @event \
Hooks#afterRowResize\n   * @param {number} newSize Calculated new row \
height.\n   * @param {number} row Visual index of the resized row.\n   * \
@param {boolean} isDoubleClick Flag that determines whether there was a \
double-click.\n   */\n  \"afterRowResize\",\n  /**\n   * Fired after getting \
the column header renderers.\n   *\n   * @event \
Hooks#afterGetColumnHeaderRenderers\n   * @param {Function[]} renderers An \
array of the column header renderers.\n   */\n  \
\"afterGetColumnHeaderRenderers\",\n  /**\n   * Fired after getting the row \
header renderers.\n   *\n   * @event Hooks#afterGetRowHeaderRenderers\n   * \
@param {Function[]} renderers An array of the row header renderers.\n   */\n  \
\"afterGetRowHeaderRenderers\",\n  /**\n   * Fired before applying stretched \
column width to column.\n   *\n   * @event \
Hooks#beforeStretchingColumnWidth\n   * @param {number} stretchedWidth \
Calculated width.\n   * @param {number} column Visual column index.\n   * \
@returns {number|undefined} Returns new width which will be applied to the \
column element.\n   */\n  \"beforeStretchingColumnWidth\",\n  /**\n   * Fired \
by the [`Filters`](@/api/filters.md) plugin,\n   * before a [column \
filter](@/guides/columns/column-filter.md) gets applied.\n   *\n   * \
[`beforeFilter`](#beforefilter) takes one argument (`conditionsStack`), which \
is an array of objects.\n   * Each object represents one of your [column \
filters](@/api/filters.md#addcondition),\n   * and consists of the following \
properties:\n   *\n   * | Property     | Possible values                      \
                                   | Description                              \
                                                                              \
  |\n   * | ------------ | \
----------------------------------------------------------------------- | \
-----------------------------------------------------------------------------\
------------------------------------------- |\n   * | `column`     | Number   \
                                                               | A visual \
index of the column to which the filter will be applied.                      \
                                  |\n   * | `conditions` | Array of objects   \
                                                     | Each object represents \
one condition. For details, see \
[`addCondition()`](@/api/filters.md#addcondition).                |\n   * | \
`operation`  | `'conjunction'` \\| `'disjunction'` \\| \
`'disjunctionWithExtraCondition'` | An operation to perform on your set of \
`conditions`. For details, see \
[`addCondition()`](@/api/filters.md#addcondition). |\n   *\n   * An example \
of the format of the `conditionsStack` argument:\n   *\n   * ```js\n   * [\n  \
 *   {\n   *     column: 2,\n   *     conditions: [\n   *       {name: \
'begins_with', args: [['S']]}\n   *     ],\n   *     operation: \
'conjunction'\n   *   },\n   *   {\n   *     column: 4,\n   *     conditions: \
[\n   *       {name: 'not_empty', args: []}\n   *     ],\n   *     operation: \
'conjunction'\n   *   },\n   * ]\n   * ```\n   *\n   * To perform server-side \
filtering (i.e., to not apply filtering to Handsontable's UI),\n   * set \
[`beforeFilter`](#beforefilter) to return `false`:\n   *\n   * ```js\n   * \
new Handsontable(document.getElementById('example'), {\n   *   beforeFilter: \
(conditionsStack) => {\n   *     return false;\n   *   }\n   * });\n   *```\n \
  *\n   * Read more:\n   * - [Guides: Column \
filter](@/guides/columns/column-filter.md)\n   * - [Hooks: \
`afterFilter`](#afterfilter)\n   * - [Options: \
`filters`](@/api/options.md#filters)\n   * - [Plugins: \
`Filters`](@/api/filters.md)\n   * \[AHat]\200\223 [Plugin methods: \
`addCondition()`](@/api/filters.md#addcondition)\n   *\n   * @event \
Hooks#beforeFilter\n   * @param {object[]} conditionsStack An array of \
objects with your [column filters](@/api/filters.md#addcondition).\n   * \
@returns {boolean} To perform server-side filtering (i.e., to not apply \
filtering to Handsontable's UI), return `false`.\n   */\n  \
\"beforeFilter\",\n  /**\n   * Fired by the [`Filters`](@/api/filters.md) \
plugin,\n   * after a [column filter](@/guides/columns/column-filter.md) gets \
applied.\n   *\n   * [`afterFilter`](#afterfilter) takes one argument \
(`conditionsStack`), which is an array of objects.\n   * Each object \
represents one of your [column filters](@/api/filters.md#addcondition),\n   * \
and consists of the following properties:\n   *\n   * | Property     | \
Possible values                                                         | \
Description                                                                   \
                                           |\n   * | ------------ | \
----------------------------------------------------------------------- | \
-----------------------------------------------------------------------------\
------------------------------------------- |\n   * | `column`     | Number   \
                                                               | A visual \
index of the column to which the filter was applied.                          \
                                  |\n   * | `conditions` | Array of objects   \
                                                     | Each object represents \
one condition. For details, see \
[`addCondition()`](@/api/filters.md#addcondition).                |\n   * | \
`operation`  | `'conjunction'` \\| `'disjunction'` \\| \
`'disjunctionWithExtraCondition'` | An operation to perform on your set of \
`conditions`. For details, see \
[`addCondition()`](@/api/filters.md#addcondition). |\n   *\n   * An example \
of the format of the `conditionsStack` argument:\n   *\n   * ```js\n   * [\n  \
 *   {\n   *     column: 2,\n   *     conditions: [\n   *       {name: \
'begins_with', args: [['S']]}\n   *     ],\n   *     operation: \
'conjunction'\n   *   },\n   *   {\n   *     column: 4,\n   *     conditions: \
[\n   *       {name: 'not_empty', args: []}\n   *     ],\n   *     operation: \
'conjunction'\n   *   },\n   * ]\n   * ```\n   *\n   * Read more:\n   * - \
[Guides: Column filter](@/guides/columns/column-filter.md)\n   * - [Hooks: \
`beforeFilter`](#beforefilter)\n   * - [Options: \
`filters`](@/api/options.md#filters)\n   * - [Plugins: \
`Filters`](@/api/filters.md)\n   * \[AHat]\200\223 [Plugin methods: \
`addCondition()`](@/api/filters.md#addcondition)\n   *\n   * @event \
Hooks#afterFilter\n   * @param {object[]} conditionsStack An array of objects \
with your [column filters](@/api/filters.md#addcondition).\n   */\n  \
\"afterFilter\",\n  /**\n   * Fired by the {@link Formulas} plugin, when any \
cell value changes.\n   *\n   * Returns an array of objects that contains:\n  \
 * - The addresses (`sheet`, `row`, `col`) and new values (`newValue`) of the \
changed cells.\n   * - The addresses and new values of any cells that had to \
be recalculated (because their formulas depend on the cells that changed).\n  \
 *\n   * This hook gets also fired on Handsontable's initialization, \
returning the addresses and values of all cells.\n   *\n   * Read more:\n   * \
- [Guides: Formula calculation](@/guides/formulas/formula-calculation.md)\n   \
* - [HyperFormula documentation: \
`valuesUpdated`](https://hyperformula.handsontable.com/api/interfaces/listene\
rs.html#valuesupdated)\n   *\n   * @since 9.0.0\n   * @event \
Hooks#afterFormulasValuesUpdate\n   * @param {Array} changes The addresses \
and new values of all the changed and recalculated cells.\n   */\n  \
\"afterFormulasValuesUpdate\",\n  /**\n   * Fired when a named expression is \
added to the Formulas' engine instance.\n   *\n   * @since 9.0.0\n   * @event \
Hooks#afterNamedExpressionAdded\n   * @param {string} namedExpressionName The \
name of the added expression.\n   * @param {Array} changes The values and \
location of applied changes.\n   */\n  \"afterNamedExpressionAdded\",\n  \
/**\n   * Fired when a named expression is removed from the Formulas' engine \
instance.\n   *\n   * @since 9.0.0\n   * @event \
Hooks#afterNamedExpressionRemoved\n   * @param {string} namedExpressionName \
The name of the removed expression.\n   * @param {Array} changes The values \
and location of applied changes.\n   */\n  \"afterNamedExpressionRemoved\",\n \
 /**\n   * Fired when a new sheet is added to the Formulas' engine \
instance.\n   *\n   * @since 9.0.0\n   * @event Hooks#afterSheetAdded\n   * \
@param {string} addedSheetDisplayName The name of the added sheet.\n   */\n  \
\"afterSheetAdded\",\n  /**\n   * Fired when a sheet in the Formulas' engine \
instance is renamed.\n   *\n   * @since 9.0.0\n   * @event \
Hooks#afterSheetRenamed\n   * @param {string} oldDisplayName The old name of \
the sheet.\n   * @param {string} newDisplayName The new name of the sheet.\n  \
 */\n  \"afterSheetRenamed\",\n  /**\n   * Fired when a sheet is removed from \
the Formulas' engine instance.\n   *\n   * @since 9.0.0\n   * @event \
Hooks#afterSheetRemoved\n   * @param {string} removedSheetDisplayName The \
removed sheet name.\n   * @param {Array} changes The values and location of \
applied changes.\n   */\n  \"afterSheetRemoved\",\n  /**\n   * Fired while \
retrieving the column header height.\n   *\n   * @event \
Hooks#modifyColumnHeaderHeight\n   */\n  \"modifyColumnHeaderHeight\",\n  \
/**\n   * Fired while retrieving a column header's value.\n   *\n   * @since \
12.3.0\n   * @event Hooks#modifyColumnHeaderValue\n   * @param {string} value \
A column header value.\n   * @param {number} visualColumnIndex A visual \
column index.\n   * @param {number} [headerLevel=0] Header level index. \
Accepts positive (0 to n)\n   *                                 and negative \
(-1 to -n) values. For positive values, 0 points to the\n   *                 \
                topmost header. For negative values, -1 points to the \
bottom-most\n   *                                 header (the header closest \
to the cells).\n   * @returns {string} The column header value to be \
updated.\n   */\n  \"modifyColumnHeaderValue\",\n  /**\n   * Fired by {@link \
UndoRedo} plugin before the undo action. Contains information about the \
action that is being undone.\n   * This hook is fired when {@link \
Options#undo} option is enabled.\n   *\n   * @event Hooks#beforeUndo\n   * \
@param {object} action The action object. Contains information about the \
action being undone. The `actionType`\n   *                        property \
of the object specifies the type of the action in a String format. (e.g. \
`'remove_row'`).\n   * @returns {*|boolean} If false is returned the action \
is canceled.\n   */\n  \"beforeUndo\",\n  /**\n   * Fired by {@link UndoRedo} \
plugin before changing undo stack.\n   *\n   * @event \
Hooks#beforeUndoStackChange\n   * @since 8.4.0\n   * @param {Array} \
doneActions Stack of actions which may be undone.\n   * @param {string} \
[source] String that identifies source of action\n   *                        \
  ([list of all available \
sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-a\
rgument)).\n   * @returns {*|boolean} If false is returned the action of \
changing undo stack is canceled.\n   */\n  \"beforeUndoStackChange\",\n  \
/**\n   * Fired by {@link UndoRedo} plugin after the undo action. Contains \
information about the action that is being undone.\n   * This hook is fired \
when {@link Options#undo} option is enabled.\n   *\n   * @event \
Hooks#afterUndo\n   * @param {object} action The action object. Contains \
information about the action being undone. The `actionType`\n   *             \
           property of the object specifies the type of the action in a \
String format. (e.g. `'remove_row'`).\n   */\n  \"afterUndo\",\n  /**\n   * \
Fired by {@link UndoRedo} plugin after changing undo stack.\n   *\n   * \
@event Hooks#afterUndoStackChange\n   * @since 8.4.0\n   * @param {Array} \
doneActionsBefore Stack of actions which could be undone before performing \
new action.\n   * @param {Array} doneActionsAfter Stack of actions which can \
be undone after performing new action.\n   */\n  \"afterUndoStackChange\",\n  \
/**\n   * Fired by {@link UndoRedo} plugin before the redo action. Contains \
information about the action that is being redone.\n   * This hook is fired \
when {@link Options#undo} option is enabled.\n   *\n   * @event \
Hooks#beforeRedo\n   * @param {object} action The action object. Contains \
information about the action being redone. The `actionType`\n   *             \
           property of the object specifies the type of the action in a \
String format (e.g. `'remove_row'`).\n   * @returns {*|boolean} If false is \
returned the action is canceled.\n   */\n  \"beforeRedo\",\n  /**\n   * Fired \
by {@link UndoRedo} plugin before changing redo stack.\n   *\n   * @event \
Hooks#beforeRedoStackChange\n   * @since 8.4.0\n   * @param {Array} \
undoneActions Stack of actions which may be redone.\n   */\n  \
\"beforeRedoStackChange\",\n  /**\n   * Fired by {@link UndoRedo} plugin \
after the redo action. Contains information about the action that is being \
redone.\n   * This hook is fired when {@link Options#undo} option is \
enabled.\n   *\n   * @event Hooks#afterRedo\n   * @param {object} action The \
action object. Contains information about the action being redone. The \
`actionType`\n   *                        property of the object specifies \
the type of the action in a String format (e.g. `'remove_row'`).\n   */\n  \
\"afterRedo\",\n  /**\n   * Fired by {@link UndoRedo} plugin after changing \
redo stack.\n   *\n   * @event Hooks#afterRedoStackChange\n   * @since \
8.4.0\n   * @param {Array} undoneActionsBefore Stack of actions which could \
be redone before performing new action.\n   * @param {Array} \
undoneActionsAfter Stack of actions which can be redone after performing new \
action.\n   */\n  \"afterRedoStackChange\",\n  /**\n   * Fired while \
retrieving the row header width.\n   *\n   * @event \
Hooks#modifyRowHeaderWidth\n   * @param {number} rowHeaderWidth Row header \
width.\n   */\n  \"modifyRowHeaderWidth\",\n  /**\n   * Fired when the start \
of the selection is being modified (e.g. Moving the selection with the arrow \
keys).\n   *\n   * @event Hooks#modifyTransformStart\n   * @param \
{CellCoords} delta Cell coords object declaring the delta of the new \
selection relative to the previous one.\n   */\n  \"modifyTransformStart\",\n \
 /**\n   * Fired when the end of the selection is being modified (e.g. Moving \
the selection with the arrow keys).\n   *\n   * @event \
Hooks#modifyTransformEnd\n   * @param {CellCoords} delta Cell coords object \
declaring the delta of the new selection relative to the previous one.\n   \
*/\n  \"modifyTransformEnd\",\n  /**\n   * Fired after the start of the \
selection is being modified (e.g. Moving the selection with the arrow \
keys).\n   *\n   * @event Hooks#afterModifyTransformStart\n   * @param \
{CellCoords} coords Coords of the freshly selected cell.\n   * @param \
{number} rowTransformDir `-1` if trying to select a cell with a negative row \
index. `0` otherwise.\n   * @param {number} colTransformDir `-1` if trying to \
select a cell with a negative column index. `0` otherwise.\n   */\n  \
\"afterModifyTransformStart\",\n  /**\n   * Fired after the end of the \
selection is being modified (e.g. Moving the selection with the arrow \
keys).\n   *\n   * @event Hooks#afterModifyTransformEnd\n   * @param \
{CellCoords} coords Visual coords of the freshly selected cell.\n   * @param \
{number} rowTransformDir `-1` if trying to select a cell with a negative row \
index. `0` otherwise.\n   * @param {number} colTransformDir `-1` if trying to \
select a cell with a negative column index. `0` otherwise.\n   */\n  \
\"afterModifyTransformEnd\",\n  /**\n   * Fired inside the \
`viewportRowCalculatorOverride` method. Allows modifying the row calculator \
parameters.\n   *\n   * @event Hooks#afterViewportRowCalculatorOverride\n   * \
@param {object} calc The row calculator.\n   */\n  \
\"afterViewportRowCalculatorOverride\",\n  /**\n   * Fired inside the \
`viewportColumnCalculatorOverride` method. Allows modifying the row \
calculator parameters.\n   *\n   * @event \
Hooks#afterViewportColumnCalculatorOverride\n   * @param {object} calc The \
row calculator.\n   */\n  \"afterViewportColumnCalculatorOverride\",\n  /**\n \
  * Fired after initializing all the plugins.\n   * This hook should be added \
before Handsontable is initialized.\n   *\n   * @event \
Hooks#afterPluginsInitialized\n   *\n   * @example\n   * ```js\n   * \
Handsontable.hooks.add('afterPluginsInitialized', myCallback);\n   * ```\n   \
*/\n  \"afterPluginsInitialized\",\n  /**\n   * Fired by {@link HiddenRows} \
plugin before marking the rows as hidden. Fired only if the {@link \
Options#hiddenRows} option is enabled.\n   * Returning `false` in the \
callback will prevent the hiding action from completing.\n   *\n   * @event \
Hooks#beforeHideRows\n   * @param {Array} currentHideConfig Current hide \
configuration - a list of hidden physical row indexes.\n   * @param {Array} \
destinationHideConfig Destination hide configuration - a list of hidden \
physical row indexes.\n   * @param {boolean} actionPossible `true`, if \
provided row indexes are valid, `false` otherwise.\n   * @returns \
{undefined|boolean} If the callback returns `false`, the hiding action will \
not be completed.\n   */\n  \"beforeHideRows\",\n  /**\n   * Fired by {@link \
HiddenRows} plugin after marking the rows as hidden. Fired only if the {@link \
Options#hiddenRows} option is enabled.\n   *\n   * @event \
Hooks#afterHideRows\n   * @param {Array} currentHideConfig Current hide \
configuration - a list of hidden physical row indexes.\n   * @param {Array} \
destinationHideConfig Destination hide configuration - a list of hidden \
physical row indexes.\n   * @param {boolean} actionPossible `true`, if \
provided row indexes are valid, `false` otherwise.\n   * @param {boolean} \
stateChanged `true`, if the action affected any non-hidden rows, `false` \
otherwise.\n   */\n  \"afterHideRows\",\n  /**\n   * Fired by {@link \
HiddenRows} plugin before marking the rows as not hidden. Fired only if the \
{@link Options#hiddenRows} option is enabled.\n   * Returning `false` in the \
callback will prevent the row revealing action from completing.\n   *\n   * \
@event Hooks#beforeUnhideRows\n   * @param {Array} currentHideConfig Current \
hide configuration - a list of hidden physical row indexes.\n   * @param \
{Array} destinationHideConfig Destination hide configuration - a list of \
hidden physical row indexes.\n   * @param {boolean} actionPossible `true`, if \
provided row indexes are valid, `false` otherwise.\n   * @returns \
{undefined|boolean} If the callback returns `false`, the revealing action \
will not be completed.\n   */\n  \"beforeUnhideRows\",\n  /**\n   * Fired by \
{@link HiddenRows} plugin after marking the rows as not hidden. Fired only if \
the {@link Options#hiddenRows} option is enabled.\n   *\n   * @event \
Hooks#afterUnhideRows\n   * @param {Array} currentHideConfig Current hide \
configuration - a list of hidden physical row indexes.\n   * @param {Array} \
destinationHideConfig Destination hide configuration - a list of hidden \
physical row indexes.\n   * @param {boolean} actionPossible `true`, if \
provided row indexes are valid, `false` otherwise.\n   * @param {boolean} \
stateChanged `true`, if the action affected any hidden rows, `false` \
otherwise.\n   */\n  \"afterUnhideRows\",\n  /**\n   * Fired by {@link \
HiddenColumns} plugin before marking the columns as hidden. Fired only if the \
{@link Options#hiddenColumns} option is enabled.\n   * Returning `false` in \
the callback will prevent the hiding action from completing.\n   *\n   * \
@event Hooks#beforeHideColumns\n   * @param {Array} currentHideConfig Current \
hide configuration - a list of hidden physical column indexes.\n   * @param \
{Array} destinationHideConfig Destination hide configuration - a list of \
hidden physical column indexes.\n   * @param {boolean} actionPossible `true`, \
if the provided column indexes are valid, `false` otherwise.\n   * @returns \
{undefined|boolean} If the callback returns `false`, the hiding action will \
not be completed.\n   */\n  \"beforeHideColumns\",\n  /**\n   * Fired by \
{@link HiddenColumns} plugin after marking the columns as hidden. Fired only \
if the {@link Options#hiddenColumns} option is enabled.\n   *\n   * @event \
Hooks#afterHideColumns\n   * @param {Array} currentHideConfig Current hide \
configuration - a list of hidden physical column indexes.\n   * @param \
{Array} destinationHideConfig Destination hide configuration - a list of \
hidden physical column indexes.\n   * @param {boolean} actionPossible `true`, \
if the provided column indexes are valid, `false` otherwise.\n   * @param \
{boolean} stateChanged `true`, if the action affected any non-hidden columns, \
`false` otherwise.\n   */\n  \"afterHideColumns\",\n  /**\n   * Fired by \
{@link HiddenColumns} plugin before marking the columns as not hidden. Fired \
only if the {@link Options#hiddenColumns} option is enabled.\n   * Returning \
`false` in the callback will prevent the column revealing action from \
completing.\n   *\n   * @event Hooks#beforeUnhideColumns\n   * @param {Array} \
currentHideConfig Current hide configuration - a list of hidden physical \
column indexes.\n   * @param {Array} destinationHideConfig Destination hide \
configuration - a list of hidden physical column indexes.\n   * @param \
{boolean} actionPossible `true`, if the provided column indexes are valid, \
`false` otherwise.\n   * @returns {undefined|boolean} If the callback returns \
`false`, the hiding action will not be completed.\n   */\n  \
\"beforeUnhideColumns\",\n  /**\n   * Fired by {@link HiddenColumns} plugin \
after marking the columns as not hidden. Fired only if the {@link \
Options#hiddenColumns} option is enabled.\n   *\n   * @event \
Hooks#afterUnhideColumns\n   * @param {Array} currentHideConfig Current hide \
configuration - a list of hidden physical column indexes.\n   * @param \
{Array} destinationHideConfig Destination hide configuration - a list of \
hidden physical column indexes.\n   * @param {boolean} actionPossible `true`, \
if the provided column indexes are valid, `false` otherwise.\n   * @param \
{boolean} stateChanged `true`, if the action affected any hidden columns, \
`false` otherwise.\n   */\n  \"afterUnhideColumns\",\n  /**\n   * Fired by \
{@link TrimRows} plugin before trimming rows. This hook is fired when {@link \
Options#trimRows} option is enabled.\n   *\n   * @event Hooks#beforeTrimRow\n \
  * @param {Array} currentTrimConfig Current trim configuration - a list of \
trimmed physical row indexes.\n   * @param {Array} destinationTrimConfig \
Destination trim configuration - a list of trimmed physical row indexes.\n   \
* @param {boolean} actionPossible `true`, if all of the row indexes are \
withing the bounds of the table, `false` otherwise.\n   * @returns \
{undefined|boolean} If the callback returns `false`, the trimming action will \
not be completed.\n   */\n  \"beforeTrimRow\",\n  /**\n   * Fired by {@link \
TrimRows} plugin after trimming rows. This hook is fired when {@link \
Options#trimRows} option is enabled.\n   *\n   * @event Hooks#afterTrimRow\n  \
 * @param {Array} currentTrimConfig Current trim configuration - a list of \
trimmed physical row indexes.\n   * @param {Array} destinationTrimConfig \
Destination trim configuration - a list of trimmed physical row indexes.\n   \
* @param {boolean} actionPossible `true`, if all of the row indexes are \
withing the bounds of the table, `false` otherwise.\n   * @param {boolean} \
stateChanged `true`, if the action affected any non-trimmed rows, `false` \
otherwise.\n   * @returns {undefined|boolean} If the callback returns \
`false`, the trimming action will not be completed.\n   */\n  \
\"afterTrimRow\",\n  /**\n   * Fired by {@link TrimRows} plugin before \
untrimming rows. This hook is fired when {@link Options#trimRows} option is \
enabled.\n   *\n   * @event Hooks#beforeUntrimRow\n   * @param {Array} \
currentTrimConfig Current trim configuration - a list of trimmed physical row \
indexes.\n   * @param {Array} destinationTrimConfig Destination trim \
configuration - a list of trimmed physical row indexes.\n   * @param \
{boolean} actionPossible `true`, if all of the row indexes are withing the \
bounds of the table, `false` otherwise.\n   * @returns {undefined|boolean} If \
the callback returns `false`, the untrimming action will not be completed.\n  \
 */\n  \"beforeUntrimRow\",\n  /**\n   * Fired by {@link TrimRows} plugin \
after untrimming rows. This hook is fired when {@link Options#trimRows} \
option is enabled.\n   *\n   * @event Hooks#afterUntrimRow\n   * @param \
{Array} currentTrimConfig Current trim configuration - a list of trimmed \
physical row indexes.\n   * @param {Array} destinationTrimConfig Destination \
trim configuration - a list of trimmed physical row indexes.\n   * @param \
{boolean} actionPossible `true`, if all of the row indexes are withing the \
bounds of the table, `false` otherwise.\n   * @param {boolean} stateChanged \
`true`, if the action affected any trimmed rows, `false` otherwise.\n   * \
@returns {undefined|boolean} If the callback returns `false`, the untrimming \
action will not be completed.\n   */\n  \"afterUntrimRow\",\n  /**\n   * \
Fired by {@link DropdownMenu} plugin before opening the dropdown menu. This \
hook is fired when {@link Options#dropdownMenu}\n   * option is enabled.\n   \
*\n   * @event Hooks#beforeDropdownMenuShow\n   * @param {DropdownMenu} \
dropdownMenu The DropdownMenu instance.\n   */\n  \
\"beforeDropdownMenuShow\",\n  /**\n   * Fired by {@link DropdownMenu} plugin \
after opening the Dropdown Menu. This hook is fired when {@link \
Options#dropdownMenu}\n   * option is enabled.\n   *\n   * @event \
Hooks#afterDropdownMenuShow\n   * @param {DropdownMenu} dropdownMenu The \
DropdownMenu instance.\n   */\n  \"afterDropdownMenuShow\",\n  /**\n   * \
Fired by {@link DropdownMenu} plugin after hiding the Dropdown Menu. This \
hook is fired when {@link Options#dropdownMenu}\n   * option is enabled.\n   \
*\n   * @event Hooks#afterDropdownMenuHide\n   * @param {DropdownMenu} \
instance The DropdownMenu instance.\n   */\n  \"afterDropdownMenuHide\",\n  \
/**\n   * Fired by {@link NestedRows} plugin before adding a children to the \
NestedRows structure. This hook is fired when\n   * {@link \
Options#nestedRows} option is enabled.\n   *\n   * @event \
Hooks#beforeAddChild\n   * @param {object} parent The parent object.\n   * \
@param {object|undefined} element The element added as a child. If \
`undefined`, a blank child was added.\n   * @param {number|undefined} index \
The index within the parent where the new child was added. If `undefined`, \
the element was added as the last child.\n   */\n  \"beforeAddChild\",\n  \
/**\n   * Fired by {@link NestedRows} plugin after adding a children to the \
NestedRows structure. This hook is fired when\n   * {@link \
Options#nestedRows} option is enabled.\n   *\n   * @event \
Hooks#afterAddChild\n   * @param {object} parent The parent object.\n   * \
@param {object|undefined} element The element added as a child. If \
`undefined`, a blank child was added.\n   * @param {number|undefined} index \
The index within the parent where the new child was added. If `undefined`, \
the element was added as the last child.\n   */\n  \"afterAddChild\",\n  \
/**\n   * Fired by {@link NestedRows} plugin before detaching a child from \
its parent. This hook is fired when\n   * {@link Options#nestedRows} option \
is enabled.\n   *\n   * @event Hooks#beforeDetachChild\n   * @param {object} \
parent An object representing the parent from which the element is to be \
detached.\n   * @param {object} element The detached element.\n   */\n  \
\"beforeDetachChild\",\n  /**\n   * Fired by {@link NestedRows} plugin after \
detaching a child from its parent. This hook is fired when\n   * {@link \
Options#nestedRows} option is enabled.\n   *\n   * @event \
Hooks#afterDetachChild\n   * @param {object} parent An object representing \
the parent from which the element was detached.\n   * @param {object} element \
The detached element.\n   * @param {number} finalElementPosition The final \
row index of the detached element.\n   */\n  \"afterDetachChild\",\n  /**\n   \
* Fired after the editor is opened and rendered.\n   *\n   * @event \
Hooks#afterBeginEditing\n   * @param {number} row Visual row index of the \
edited cell.\n   * @param {number} column Visual column index of the edited \
cell.\n   */\n  \"afterBeginEditing\",\n  /**\n   * Fired by {@link \
MergeCells} plugin before cell merging. This hook is fired when {@link \
Options#mergeCells}\n   * option is enabled.\n   *\n   * @event \
Hooks#beforeMergeCells\n   * @param {CellRange} cellRange Selection cell \
range.\n   * @param {boolean} [auto=false] `true` if called automatically by \
the plugin.\n   */\n  \"beforeMergeCells\",\n  /**\n   * Fired by {@link \
MergeCells} plugin after cell merging. This hook is fired when {@link \
Options#mergeCells}\n   * option is enabled.\n   *\n   * @event \
Hooks#afterMergeCells\n   * @param {CellRange} cellRange Selection cell \
range.\n   * @param {object} mergeParent The parent collection of the \
provided cell range.\n   * @param {boolean} [auto=false] `true` if called \
automatically by the plugin.\n   */\n  \"afterMergeCells\",\n  /**\n   * \
Fired by {@link MergeCells} plugin before unmerging the cells. This hook is \
fired when {@link Options#mergeCells}\n   * option is enabled.\n   *\n   * \
@event Hooks#beforeUnmergeCells\n   * @param {CellRange} cellRange Selection \
cell range.\n   * @param {boolean} [auto=false] `true` if called \
automatically by the plugin.\n   */\n  \"beforeUnmergeCells\",\n  /**\n   * \
Fired by {@link MergeCells} plugin after unmerging the cells. This hook is \
fired when {@link Options#mergeCells}\n   * option is enabled.\n   *\n   * \
@event Hooks#afterUnmergeCells\n   * @param {CellRange} cellRange Selection \
cell range.\n   * @param {boolean} [auto=false] `true` if called \
automatically by the plugin.\n   */\n  \"afterUnmergeCells\",\n  /**\n   * \
Fired after the table was switched into listening mode. This allows \
Handsontable to capture keyboard events and\n   * respond in the right way.\n \
  *\n   * @event Hooks#afterListen\n   */\n  \"afterListen\",\n  /**\n   * \
Fired after the table was switched off from the listening mode. This makes \
the Handsontable inert for any\n   * keyboard events.\n   *\n   * @event \
Hooks#afterUnlisten\n   */\n  \"afterUnlisten\",\n  /**\n   * Fired after the \
window was resized or the size of the Handsontable root element was \
changed.\n   *\n   * @event Hooks#afterRefreshDimensions\n   * @param \
{object} previousDimensions Previous dimensions of the container.\n   * \
@param {object} currentDimensions Current dimensions of the container.\n   * \
@param {boolean} stateChanged `true`, if the container was re-render, `false` \
otherwise.\n   */\n  \"afterRefreshDimensions\",\n  /**\n   * Cancellable \
hook, called after resizing a window or after detecting size change of the\n  \
 * Handsontable root element, but before redrawing a table.\n   *\n   * \
@event Hooks#beforeRefreshDimensions\n   * @param {object} previousDimensions \
Previous dimensions of the container.\n   * @param {object} currentDimensions \
Current dimensions of the container.\n   * @param {boolean} actionPossible \
`true`, if current and previous dimensions are different, `false` \
otherwise.\n   * @returns {undefined|boolean} If the callback returns \
`false`, the refresh action will not be completed.\n   */\n  \
\"beforeRefreshDimensions\",\n  /**\n   * Fired by {@link CollapsibleColumns} \
plugin before columns collapse. This hook is fired when {@link \
Options#collapsibleColumns} option is enabled.\n   *\n   * @event \
Hooks#beforeColumnCollapse\n   * @since 8.0.0\n   * @param {Array} \
currentCollapsedColumns Current collapsible configuration - a list of \
collapsible physical column indexes.\n   * @param {Array} \
destinationCollapsedColumns Destination collapsible configuration - a list of \
collapsible physical column indexes.\n   * @param {boolean} collapsePossible \
`true`, if all of the column indexes are withing the bounds of the collapsed \
sections, `false` otherwise.\n   * @returns {undefined|boolean} If the \
callback returns `false`, the collapsing action will not be completed.\n   \
*/\n  \"beforeColumnCollapse\",\n  /**\n   * Fired by {@link \
CollapsibleColumns} plugin before columns collapse. This hook is fired when \
{@link Options#collapsibleColumns} option is enabled.\n   *\n   * @event \
Hooks#afterColumnCollapse\n   * @since 8.0.0\n   * @param {Array} \
currentCollapsedColumns Current collapsible configuration - a list of \
collapsible physical column indexes.\n   * @param {Array} \
destinationCollapsedColumns Destination collapsible configuration - a list of \
collapsible physical column indexes.\n   * @param {boolean} collapsePossible \
`true`, if all of the column indexes are withing the bounds of the collapsed \
sections, `false` otherwise.\n   * @param {boolean} successfullyCollapsed \
`true`, if the action affected any non-collapsible column, `false` \
otherwise.\n   */\n  \"afterColumnCollapse\",\n  /**\n   * Fired by {@link \
CollapsibleColumns} plugin before columns expand. This hook is fired when \
{@link Options#collapsibleColumns} option is enabled.\n   *\n   * @event \
Hooks#beforeColumnExpand\n   * @since 8.0.0\n   * @param {Array} \
currentCollapsedColumns Current collapsible configuration - a list of \
collapsible physical column indexes.\n   * @param {Array} \
destinationCollapsedColumns Destination collapsible configuration - a list of \
collapsible physical column indexes.\n   * @param {boolean} expandPossible \
`true`, if all of the column indexes are withing the bounds of the collapsed \
sections, `false` otherwise.\n   * @returns {undefined|boolean} If the \
callback returns `false`, the expanding action will not be completed.\n   \
*/\n  \"beforeColumnExpand\",\n  /**\n   * Fired by {@link \
CollapsibleColumns} plugin before columns expand. This hook is fired when \
{@link Options#collapsibleColumns} option is enabled.\n   *\n   * @event \
Hooks#afterColumnExpand\n   * @since 8.0.0\n   * @param {Array} \
currentCollapsedColumns Current collapsible configuration - a list of \
collapsible physical column indexes.\n   * @param {Array} \
destinationCollapsedColumns Destination collapsible configuration - a list of \
collapsible physical column indexes.\n   * @param {boolean} expandPossible \
`true`, if all of the column indexes are withing the bounds of the collapsed \
sections, `false` otherwise.\n   * @param {boolean} successfullyExpanded \
`true`, if the action affected any non-collapsible column, `false` \
otherwise.\n   */\n  \"afterColumnExpand\",\n  /**\n   * Fired by {@link \
AutoColumnSize} plugin within SampleGenerator utility.\n   *\n   * @event \
Hooks#modifyAutoColumnSizeSeed\n   * @since 8.4.0\n   * @param \
{string|undefined} seed Seed ID, unique name to categorize samples.\n   * \
@param {object} cellProperties Object containing the cell properties.\n   * \
@param {*} cellValue Value of the cell.\n   */\n  \
\"modifyAutoColumnSizeSeed\"\n];\nvar REMOVED_MESSAGE = toSingleLine`The \
plugin hook \"[hookName]\" was removed in Handsontable \
[removedInVersion].\\x20\n  Please consult release notes \
https://github.com/handsontable/handsontable/releases/tag/[removedInVersion] \
to\\x20\n  learn about the migration path.`;\nvar REMOVED_HOOKS = /* \
@__PURE__ */ new Map([[\"modifyRow\", \"8.0.0\"], [\"modifyCol\", \"8.0.0\"], \
[\"unmodifyRow\", \"8.0.0\"], [\"unmodifyCol\", \"8.0.0\"], \
[\"skipLengthCache\", \"8.0.0\"], [\"hiddenColumn\", \"8.0.0\"], \
[\"hiddenRow\", \"8.0.0\"]]);\nvar DEPRECATED_HOOKS = /* @__PURE__ */ new \
Map([]);\nvar Hooks = class {\n  static getSingleton() {\n    return \
getGlobalSingleton();\n  }\n  /**\n   *\n   */\n  constructor() {\n    \
this.globalBucket = this.createEmptyBucket();\n  }\n  /**\n   * Returns a new \
object with empty handlers related to every registered hook name.\n   *\n   * \
@returns {object} The empty bucket object.\n   *\n   * @example\n   * ```js\n \
  * Handsontable.hooks.createEmptyBucket();\n   * // Results:\n   * {\n   * \
...\n   * afterCreateCol: [],\n   * afterCreateRow: [],\n   * beforeInit: \
[],\n   * ...\n   * }\n   * ```\n   */\n  createEmptyBucket() {\n    const \
bucket = /* @__PURE__ */ Object.create(null);\n    \
arrayEach(REGISTERED_HOOKS, (hook2) => bucket[hook2] = []);\n    return \
bucket;\n  }\n  /**\n   * Get hook bucket based on the context of the object \
or if argument is `undefined`, get the global hook bucket.\n   *\n   * @param \
{object} [context=null] A Handsontable instance.\n   * @returns {object} \
Returns a global or Handsontable instance bucket.\n   */\n  getBucket() {\n   \
 let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] \
: null;\n    if (context) {\n      if (!context.pluginHookBucket) {\n        \
context.pluginHookBucket = this.createEmptyBucket();\n      }\n      return \
context.pluginHookBucket;\n    }\n    return this.globalBucket;\n  }\n  /**\n \
  * Adds a listener (globally or locally) to a specified hook name.\n   * If \
the `context` parameter is provided, the hook will be added only to the \
instance it references.\n   * Otherwise, the callback will be used everytime \
the hook fires on any Handsontable instance.\n   * You can provide an array \
of callback functions as the `callback` argument, this way they will all be \
fired\n   * once the hook is triggered.\n   *\n   * @see Core#addHook\n   * \
@param {string} key Hook name.\n   * @param {Function|Array} callback \
Callback function or an array of functions.\n   * @param {object} \
[context=null] The context for the hook callback to be added - a Handsontable \
instance or leave empty.\n   * @returns {Hooks} Instance of Hooks.\n   *\n   \
* @example\n   * ```js\n   * // single callback, added locally\n   * \
Handsontable.hooks.add('beforeInit', myCallback, hotInstance);\n   *\n   * // \
single callback, added globally\n   * Handsontable.hooks.add('beforeInit', \
myCallback);\n   *\n   * // multiple callbacks, added locally\n   * \
Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback], \
hotInstance);\n   *\n   * // multiple callbacks, added globally\n   * \
Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback]);\n   * \
```\n   */\n  add(key, callback) {\n    let context = arguments.length > 2 && \
arguments[2] !== void 0 ? arguments[2] : null;\n    if \
(Array.isArray(callback)) {\n      arrayEach(callback, (c) => this.add(key, \
c, context));\n    } else {\n      if (REMOVED_HOOKS.has(key)) {\n        \
warn(substitute(REMOVED_MESSAGE, {\n          hookName: key,\n          \
removedInVersion: REMOVED_HOOKS.get(key)\n        }));\n      }\n      if \
(DEPRECATED_HOOKS.has(key)) {\n        warn(DEPRECATED_HOOKS.get(key));\n     \
 }\n      const bucket = this.getBucket(context);\n      if (typeof \
bucket[key] === \"undefined\") {\n        this.register(key);\n        \
bucket[key] = [];\n      }\n      callback.skip = false;\n      if \
(bucket[key].indexOf(callback) === -1) {\n        let foundInitialHook = \
false;\n        if (callback.initialHook) {\n          arrayEach(bucket[key], \
(cb, i) => {\n            if (cb.initialHook) {\n              bucket[key][i] \
= callback;\n              foundInitialHook = true;\n              return \
false;\n            }\n          });\n        }\n        if \
(!foundInitialHook) {\n          bucket[key].push(callback);\n        }\n     \
 }\n    }\n    return this;\n  }\n  /**\n   * Adds a listener to a specified \
hook. After the hook runs this listener will be automatically removed from \
the bucket.\n   *\n   * @see Core#addHookOnce\n   * @param {string} key \
Hook/Event name.\n   * @param {Function|Array} callback Callback function.\n  \
 * @param {object} [context=null] A Handsontable instance.\n   *\n   * \
@example\n   * ```js\n   * Handsontable.hooks.once('beforeInit', myCallback, \
hotInstance);\n   * ```\n   */\n  once(key, callback) {\n    let context = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n    \
if (Array.isArray(callback)) {\n      arrayEach(callback, (c) => \
this.once(key, c, context));\n    } else {\n      callback.runOnce = true;\n  \
    this.add(key, callback, context);\n    }\n  }\n  /**\n   * Removes a \
listener from a hook with a given name. If the `context` argument is \
provided, it removes a listener from a local hook assigned to the given \
Handsontable instance.\n   *\n   * @see Core#removeHook\n   * @param {string} \
key Hook/Event name.\n   * @param {Function} callback Callback function \
(needs the be the function that was previously added to the hook).\n   * \
@param {object} [context=null] Handsontable instance.\n   * @returns \
{boolean} Returns `true` if hook was removed, `false` otherwise.\n   *\n   * \
@example\n   * ```js\n   * Handsontable.hooks.remove('beforeInit', \
myCallback);\n   * ```\n   */\n  remove(key, callback) {\n    let context = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n    \
const bucket = this.getBucket(context);\n    if (typeof bucket[key] !== \
\"undefined\") {\n      if (bucket[key].indexOf(callback) >= 0) {\n        \
callback.skip = true;\n        return true;\n      }\n    }\n    return \
false;\n  }\n  /**\n   * Checks whether there are any registered listeners \
for the provided hook name.\n   * If the `context` parameter is provided, it \
only checks for listeners assigned to the given Handsontable instance.\n   \
*\n   * @param {string} key Hook name.\n   * @param {object} [context=null] A \
Handsontable instance.\n   * @returns {boolean} `true` for success, `false` \
otherwise.\n   */\n  has(key) {\n    let context = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : null;\n    const bucket = \
this.getBucket(context);\n    return !!(bucket[key] !== void 0 && \
bucket[key].length);\n  }\n  /**\n   * Runs all local and global callbacks \
assigned to the hook identified by the `key` parameter.\n   * It returns \
either a return value from the last called callback or the first parameter \
(`p1`) passed to the `run` function.\n   *\n   * @see Core#runHooks\n   * \
@param {object} context Handsontable instance.\n   * @param {string} key \
Hook/Event name.\n   * @param {*} [p1] Parameter to be passed as an argument \
to the callback function.\n   * @param {*} [p2] Parameter to be passed as an \
argument to the callback function.\n   * @param {*} [p3] Parameter to be \
passed as an argument to the callback function.\n   * @param {*} [p4] \
Parameter to be passed as an argument to the callback function.\n   * @param \
{*} [p5] Parameter to be passed as an argument to the callback function.\n   \
* @param {*} [p6] Parameter to be passed as an argument to the callback \
function.\n   * @returns {*} Either a return value from the last called \
callback or `p1`.\n   *\n   * @example\n   * ```js\n   * \
Handsontable.hooks.run(hot, 'beforeInit');\n   * ```\n   */\n  run(context, \
key, p1, p2, p3, p4, p5, p6) {\n    {\n      const globalHandlers = \
this.globalBucket[key];\n      const length = globalHandlers ? \
globalHandlers.length : 0;\n      let index2 = 0;\n      if (length) {\n      \
  while (index2 < length) {\n          if (!globalHandlers[index2] || \
globalHandlers[index2].skip) {\n            index2 += 1;\n            \
continue;\n          }\n          const res = \
fastCall(globalHandlers[index2], context, p1, p2, p3, p4, p5, p6);\n          \
if (res !== void 0) {\n            p1 = res;\n          }\n          if \
(globalHandlers[index2] && globalHandlers[index2].runOnce) {\n            \
this.remove(key, globalHandlers[index2]);\n          }\n          index2 += \
1;\n        }\n      }\n    }\n    {\n      const localHandlers = \
this.getBucket(context)[key];\n      const length = localHandlers ? \
localHandlers.length : 0;\n      let index2 = 0;\n      if (length) {\n       \
 while (index2 < length) {\n          if (!localHandlers[index2] || \
localHandlers[index2].skip) {\n            index2 += 1;\n            \
continue;\n          }\n          const res = fastCall(localHandlers[index2], \
context, p1, p2, p3, p4, p5, p6);\n          if (res !== void 0) {\n          \
  p1 = res;\n          }\n          if (localHandlers[index2] && \
localHandlers[index2].runOnce) {\n            this.remove(key, \
localHandlers[index2], context);\n          }\n          index2 += 1;\n       \
 }\n      }\n    }\n    return p1;\n  }\n  /**\n   * Destroy all listeners \
connected to the context. If no context is provided, the global listeners \
will be destroyed.\n   *\n   * @param {object} [context=null] A Handsontable \
instance.\n   * @example\n   * ```js\n   * // destroy the global listeners\n  \
 * Handsontable.hooks.destroy();\n   *\n   * // destroy the local listeners\n \
  * Handsontable.hooks.destroy(hotInstance);\n   * ```\n   */\n  destroy() \
{\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : null;\n    objectEach(this.getBucket(context), (value, key, \
bucket) => bucket[key].length = 0);\n  }\n  /**\n   * Registers a hook name \
(adds it to the list of the known hook names). Used by plugins.\n   * It is \
not necessary to call register, but if you use it, your plugin hook will be \
used returned by\n   * the `getRegistered` method. (which itself is used in \
the [demo](@/guides/getting-started/events-and-hooks.md)).\n   *\n   * @param \
{string} key The hook name.\n   *\n   * @example\n   * ```js\n   * \
Handsontable.hooks.register('myHook');\n   * ```\n   */\n  register(key) {\n  \
  if (!this.isRegistered(key)) {\n      REGISTERED_HOOKS.push(key);\n    }\n  \
}\n  /**\n   * Deregisters a hook name (removes it from the list of known \
hook names).\n   *\n   * @param {string} key The hook name.\n   *\n   * \
@example\n   * ```js\n   * Handsontable.hooks.deregister('myHook');\n   * \
```\n   */\n  deregister(key) {\n    if (this.isRegistered(key)) {\n      \
REGISTERED_HOOKS.splice(REGISTERED_HOOKS.indexOf(key), 1);\n    }\n  }\n  \
/**\n   * Returns a boolean value depending on if a hook by such name has \
been removed or deprecated.\n   *\n   * @param {string} hookName The hook \
name to check.\n   * @returns {boolean} Returns `true` if the provided hook \
name was marked as deprecated or\n   * removed from API, `false` otherwise.\n \
  * @example\n   * ```js\n   * \
Handsontable.hooks.isDeprecated('skipLengthCache');\n   *\n   * // Results:\n \
  * true\n   * ```\n   */\n  isDeprecated(hookName) {\n    return \
DEPRECATED_HOOKS.has(hookName) || REMOVED_HOOKS.has(hookName);\n  }\n  /**\n  \
 * Returns a boolean depending on if a hook by such name has been \
registered.\n   *\n   * @param {string} hookName The hook name to check.\n   \
* @returns {boolean} `true` for success, `false` otherwise.\n   * @example\n  \
 * ```js\n   * Handsontable.hooks.isRegistered('beforeInit');\n   *\n   * // \
Results:\n   * true\n   * ```\n   */\n  isRegistered(hookName) {\n    return \
REGISTERED_HOOKS.indexOf(hookName) >= 0;\n  }\n  /**\n   * Returns an array \
of registered hooks.\n   *\n   * @returns {Array} An array of registered \
hooks.\n   *\n   * @example\n   * ```js\n   * \
Handsontable.hooks.getRegistered();\n   *\n   * // Results:\n   * [\n   * \
...\n   *   'beforeInit',\n   *   'beforeRender',\n   *   \
'beforeSetRangeEnd',\n   *   'beforeDrawBorders',\n   *   'beforeChange',\n   \
* ...\n   * ]\n   * ```\n   */\n  getRegistered() {\n    return \
REGISTERED_HOOKS;\n  }\n};\nvar globalSingleton = new Hooks();\nfunction \
getGlobalSingleton() {\n  return globalSingleton;\n}\nvar pluginHooks_default \
= Hooks;\n\n// node_modules/handsontable/utils/staticRegister.mjs\nvar \
collection = /* @__PURE__ */ new Map();\nfunction staticRegister() {\n  let \
namespace = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
\"common\";\n  if (!collection.has(namespace)) {\n    \
collection.set(namespace, /* @__PURE__ */ new Map());\n  }\n  const \
subCollection = collection.get(namespace);\n  function register7(name, item) \
{\n    subCollection.set(name, item);\n  }\n  function getItem6(name) {\n    \
return subCollection.get(name);\n  }\n  function hasItem5(name) {\n    return \
subCollection.has(name);\n  }\n  function getNames5() {\n    return \
[...subCollection.keys()];\n  }\n  function getValues5() {\n    return \
[...subCollection.values()];\n  }\n  return {\n    register: register7,\n    \
getItem: getItem6,\n    hasItem: hasItem5,\n    getNames: getNames5,\n    \
getValues: getValues5\n  };\n}\n\n// \
node_modules/handsontable/editors/registry.mjs\nvar registeredEditorClasses = \
/* @__PURE__ */ new WeakMap();\nvar {\n  register,\n  getItem,\n  hasItem,\n  \
getNames,\n  getValues\n} = staticRegister(\"editors\");\nfunction \
RegisteredEditor(editorClass) {\n  const instances2 = {};\n  const Clazz = \
editorClass;\n  this.getConstructor = function() {\n    return editorClass;\n \
 };\n  this.getInstance = function(hotInstance) {\n    if (!(hotInstance.guid \
in instances2)) {\n      instances2[hotInstance.guid] = new \
Clazz(hotInstance);\n    }\n    return instances2[hotInstance.guid];\n  };\n  \
pluginHooks_default.getSingleton().add(\"afterDestroy\", function() {\n    \
instances2[this.guid] = null;\n  });\n}\nfunction _getEditorInstance(name, \
hotInstance) {\n  let editor;\n  if (typeof name === \"function\") {\n    if \
(!registeredEditorClasses.get(name)) {\n      _register(null, name);\n    }\n \
   editor = registeredEditorClasses.get(name);\n  } else if (typeof name === \
\"string\") {\n    editor = getItem(name);\n  } else {\n    throw Error('Only \
strings and functions can be passed as \"editor\" parameter');\n  }\n  if \
(!editor) {\n    throw Error(`No editor registered under name \
\"${name}\"`);\n  }\n  return editor.getInstance(hotInstance);\n}\nfunction \
_getItem(name) {\n  if (typeof name === \"function\") {\n    return name;\n  \
}\n  if (!hasItem(name)) {\n    throw Error(`No registered editor found under \
\"${name}\" name`);\n  }\n  return \
getItem(name).getConstructor();\n}\nfunction _register(name, editorClass) {\n \
 if (name && typeof name !== \"string\") {\n    editorClass = name;\n    name \
= editorClass.EDITOR_TYPE;\n  }\n  const editorWrapper = new \
RegisteredEditor(editorClass);\n  if (typeof name === \"string\") {\n    \
register(name, editorWrapper);\n  }\n  \
registeredEditorClasses.set(editorClass, editorWrapper);\n}\n\n// \
node_modules/handsontable/eventManager.mjs\nvar listenersCounter = 0;\nvar \
EventManager = class {\n  /**\n   * @param {object} [context=null] An object \
to which event listeners will be stored.\n   * @private\n   */\n  \
constructor() {\n    let context = arguments.length > 0 && arguments[0] !== \
void 0 ? arguments[0] : null;\n    this.context = context || this;\n    if \
(!this.context.eventListeners) {\n      this.context.eventListeners = [];\n   \
 }\n  }\n  /**\n   * Register specified listener (`eventName`) to the \
element.\n   *\n   * @param {Element} element Target element.\n   * @param \
{string} eventName Event name.\n   * @param {Function} callback Function \
which will be called after event occur.\n   * @param \
{AddEventListenerOptions|boolean} [options] Listener options if object or \
useCapture if boolean.\n   * @returns {Function} Returns function which you \
can easily call to remove that event.\n   */\n  addEventListener(element, \
eventName, callback) {\n    let options = arguments.length > 3 && \
arguments[3] !== void 0 ? arguments[3] : false;\n    function \
callbackProxy(event2) {\n      callback.call(this, extendEvent(event2));\n    \
}\n    this.context.eventListeners.push({\n      element,\n      event: \
eventName,\n      callback,\n      callbackProxy,\n      options,\n      \
eventManager: this\n    });\n    element.addEventListener(eventName, \
callbackProxy, options);\n    listenersCounter += 1;\n    return () => {\n    \
  this.removeEventListener(element, eventName, callback);\n    };\n  }\n  \
/**\n   * Remove the event listener previously registered.\n   *\n   * @param \
{Element} element Target element.\n   * @param {string} eventName Event \
name.\n   * @param {Function} callback Function to remove from the event \
target. It must be the same as during registration listener.\n   * @param \
{boolean} [onlyOwnEvents] Whether whould remove only events registered using \
this instance of EventManager.\n   */\n  removeEventListener(element, \
eventName, callback) {\n    let onlyOwnEvents = arguments.length > 3 && \
arguments[3] !== void 0 ? arguments[3] : false;\n    let len = \
this.context.eventListeners.length;\n    let tmpEvent;\n    while (len) {\n   \
   len -= 1;\n      tmpEvent = this.context.eventListeners[len];\n      if \
(tmpEvent.event === eventName && tmpEvent.element === element) {\n        if \
(callback && callback !== tmpEvent.callback) {\n          continue;\n        \
}\n        if (onlyOwnEvents && tmpEvent.eventManager !== this) {\n          \
continue;\n        }\n        this.context.eventListeners.splice(len, 1);\n   \
     tmpEvent.element.removeEventListener(tmpEvent.event, \
tmpEvent.callbackProxy, tmpEvent.options);\n        listenersCounter -= 1;\n  \
    }\n    }\n  }\n  /**\n   * Clear all previously registered events.\n   \
*\n   * @private\n   * @since 0.15.0-beta3\n   * @param {boolean} \
[onlyOwnEvents] Whether whould remove only events registered using this \
instance of EventManager.\n   */\n  clearEvents() {\n    let onlyOwnEvents = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    \
if (!this.context) {\n      return;\n    }\n    let len = \
this.context.eventListeners.length;\n    while (len) {\n      len -= 1;\n     \
 const event2 = this.context.eventListeners[len];\n      if (onlyOwnEvents && \
event2.eventManager !== this) {\n        continue;\n      }\n      \
this.context.eventListeners.splice(len, 1);\n      \
event2.element.removeEventListener(event2.event, event2.callbackProxy, \
event2.options);\n      listenersCounter -= 1;\n    }\n  }\n  /**\n   * Clear \
all previously registered events.\n   */\n  clear() {\n    \
this.clearEvents();\n  }\n  /**\n   * Destroy instance of EventManager, \
clearing all events of the context.\n   */\n  destroy() {\n    \
this.clearEvents();\n    this.context = null;\n  }\n  /**\n   * Destroy \
instance of EventManager, clearing only the own events.\n   */\n  \
destroyWithOwnEventsOnly() {\n    this.clearEvents(true);\n    this.context = \
null;\n  }\n  /**\n   * Trigger event at the specified target element.\n   \
*\n   * @param {Element} element Target element.\n   * @param {string} \
eventName Event name.\n   */\n  fireEvent(element, eventName) {\n    let \
rootDocument = element.document;\n    let rootWindow = element;\n    if \
(!rootDocument) {\n      rootDocument = element.ownerDocument ? \
element.ownerDocument : element;\n      rootWindow = \
rootDocument.defaultView;\n    }\n    const options = {\n      bubbles: \
true,\n      cancelable: eventName !== \"mousemove\",\n      view: \
rootWindow,\n      detail: 0,\n      screenX: 0,\n      screenY: 0,\n      \
clientX: 1,\n      clientY: 1,\n      ctrlKey: false,\n      altKey: false,\n \
     shiftKey: false,\n      metaKey: false,\n      button: 0,\n      \
relatedTarget: void 0\n    };\n    let event2;\n    if \
(rootDocument.createEvent) {\n      event2 = \
rootDocument.createEvent(\"MouseEvents\");\n      \
event2.initMouseEvent(eventName, options.bubbles, options.cancelable, \
options.view, options.detail, options.screenX, options.screenY, \
options.clientX, options.clientY, options.ctrlKey, options.altKey, \
options.shiftKey, options.metaKey, options.button, options.relatedTarget || \
rootDocument.body.parentNode);\n    } else {\n      event2 = \
rootDocument.createEventObject();\n    }\n    if (element.dispatchEvent) {\n  \
    element.dispatchEvent(event2);\n    } else {\n      \
element.fireEvent(`on${eventName}`, event2);\n    }\n  }\n};\nfunction \
extendEvent(event2) {\n  const nativeStopImmediatePropagation = \
event2.stopImmediatePropagation;\n  event2.stopImmediatePropagation = \
function() {\n    nativeStopImmediatePropagation.apply(this);\n    \
stopImmediatePropagation(this);\n  };\n  return event2;\n}\nvar \
eventManager_default = EventManager;\nfunction getListenersCounter() {\n  \
return listenersCounter;\n}\n\n// \
node_modules/handsontable/editorManager.mjs\nvar SHORTCUTS_GROUP_NAVIGATION = \
\"editorManager.navigation\";\nvar SHORTCUTS_GROUP_EDITOR = \
\"editorManager.handlingEditor\";\nvar EditorManager = class {\n  /**\n   * \
@param {Core} instance The Handsontable instance.\n   * @param {TableMeta} \
tableMeta The table meta instance.\n   * @param {Selection} selection The \
selection instance.\n   */\n  constructor(instance, tableMeta, selection) {\n \
   this.instance = instance;\n    this.tableMeta = tableMeta;\n    \
this.selection = selection;\n    this.eventManager = new \
eventManager_default(instance);\n    this.destroyed = false;\n    this.lock = \
false;\n    this.activeEditor = void 0;\n    this.cellProperties = void 0;\n  \
  const shortcutManager = this.instance.getShortcutManager();\n    \
shortcutManager.addContext(\"editor\");\n    this.registerShortcuts();\n    \
this.instance.addHook(\"afterDocumentKeyDown\", (event2) => \
this.onAfterDocumentKeyDown(event2));\n    \
this.eventManager.addEventListener(this.instance.rootDocument.documentElement\
, \"compositionstart\", (event2) => {\n      if (!this.destroyed && \
this.instance.isListening()) {\n        this.openEditor(\"\", event2);\n      \
}\n    });\n    this.instance.view._wt.update(\"onCellDblClick\", (event2, \
coords, elem) => this.onCellDblClick(event2, coords, elem));\n  }\n  /**\n   \
* Register shortcuts responsible for handling some actions related to an \
editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const \
shortcutManager = this.instance.getShortcutManager();\n    const gridContext \
= shortcutManager.getContext(\"grid\");\n    const editorContext = \
shortcutManager.getContext(\"editor\");\n    const config = {\n      group: \
SHORTCUTS_GROUP_EDITOR\n    };\n    editorContext.addShortcuts([{\n      \
keys: [[\"Enter\"], [\"Enter\", \"Shift\"], [\"Enter\", \"Control/Meta\"], \
[\"Enter\", \"Control/Meta\", \"Shift\"]],\n      callback: (event2, keys) => \
{\n        this.closeEditorAndSaveChanges(shortcutManager.isCtrlPressed());\n \
       this.moveSelectionAfterEnter(keys.includes(\"shift\"));\n      }\n    \
}, {\n      keys: [[\"Escape\"], [\"Escape\", \"Control/Meta\"]],\n      \
callback: () => {\n        \
this.closeEditorAndRestoreOriginalValue(shortcutManager.isCtrlPressed());\n   \
     this.activeEditor.focus();\n      }\n    }], config);\n    \
gridContext.addShortcuts([{\n      keys: [[\"F2\"]],\n      callback: \
(event2) => {\n        this.openEditor(null, event2, true);\n      }\n    }, \
{\n      keys: [[\"Backspace\"], [\"Delete\"]],\n      callback: () => {\n    \
    this.instance.emptySelectedCells();\n        this.prepareEditor();\n      \
}\n    }, {\n      keys: [[\"Enter\"], [\"Enter\", \"Shift\"]],\n      \
callback: (event2, keys) => {\n        if \
(this.instance.getSettings().enterBeginsEditing) {\n          if \
(this.cellProperties.readOnly) {\n            \
this.moveSelectionAfterEnter();\n          } else {\n            \
this.openEditor(null, event2, true);\n          }\n        } else {\n         \
 this.moveSelectionAfterEnter(keys.includes(\"shift\"));\n        }\n        \
stopImmediatePropagation(event2);\n      }\n    }], {\n      ...config,\n     \
 runOnlyIf: () => isDefined(this.instance.getSelected())\n    });\n  }\n  \
/**\n   * Lock the editor from being prepared and closed. Locking the editor \
prevents its closing and\n   * reinitialized after selecting the new cell. \
This feature is necessary for a mobile editor.\n   */\n  lockEditor() {\n    \
this.lock = true;\n  }\n  /**\n   * Unlock the editor from being prepared and \
closed. This method restores the original behavior of\n   * the editors where \
for every new selection its instances are closed.\n   */\n  unlockEditor() \
{\n    this.lock = false;\n  }\n  /**\n   * Destroy current editor, if \
exists.\n   *\n   * @param {boolean} revertOriginal If `false` and the cell \
using allowInvalid option,\n   *                                 then an \
editor won't be closed until validation is passed.\n   */\n  \
destroyEditor(revertOriginal) {\n    if (!this.lock) {\n      \
this.closeEditor(revertOriginal);\n    }\n  }\n  /**\n   * Get active \
editor.\n   *\n   * @returns {BaseEditor}\n   */\n  getActiveEditor() {\n    \
return this.activeEditor;\n  }\n  /**\n   * Prepare text input to be \
displayed at given grid cell.\n   */\n  prepareEditor() {\n    if (this.lock) \
{\n      return;\n    }\n    if (this.activeEditor && \
this.activeEditor.isWaiting()) {\n      this.closeEditor(false, false, \
(dataSaved) => {\n        if (dataSaved) {\n          this.prepareEditor();\n \
       }\n      });\n      return;\n    }\n    const {\n      row,\n      \
col\n    } = this.instance.getSelectedRangeLast().highlight;\n    const \
modifiedCellCoords = this.instance.runHooks(\"modifyGetCellCoords\", row, \
col);\n    let visualRowToCheck = row;\n    let visualColumnToCheck = col;\n  \
  if (Array.isArray(modifiedCellCoords)) {\n      [visualRowToCheck, \
visualColumnToCheck] = modifiedCellCoords;\n    }\n    this.cellProperties = \
this.instance.getCellMeta(visualRowToCheck, visualColumnToCheck);\n    const \
{\n      activeElement\n    } = this.instance.rootDocument;\n    if \
(activeElement && isOutsideInput(activeElement)) {\n      \
activeElement.blur();\n    }\n    if (!this.isCellEditable()) {\n      \
this.clearActiveEditor();\n      return;\n    }\n    const td = \
this.instance.getCell(row, col, true);\n    if (td) {\n      const \
editorClass = this.instance.getCellEditor(this.cellProperties);\n      const \
prop = this.instance.colToProp(visualColumnToCheck);\n      const \
originalValue = \
this.instance.getSourceDataAtCell(this.instance.toPhysicalRow(visualRowToChec\
k), visualColumnToCheck);\n      this.activeEditor = \
_getEditorInstance(editorClass, this.instance);\n      \
this.activeEditor.prepare(row, col, prop, td, originalValue, \
this.cellProperties);\n    }\n  }\n  /**\n   * Check is editor is \
opened/showed.\n   *\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n  \
  return this.activeEditor && this.activeEditor.isOpened();\n  }\n  /**\n   * \
Open editor with initial value.\n   *\n   * @param {null|string} \
newInitialValue New value from which editor will start if handled property \
it's not the `null`.\n   * @param {Event} event The event object.\n   * \
@param {boolean} [enableFullEditMode=false] When true, an editor works in \
full editing mode. Mode disallows closing an editor\n   *                     \
                        when arrow keys are pressed.\n   */\n  \
openEditor(newInitialValue, event2) {\n    let enableFullEditMode = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    \
if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      \
return;\n    }\n    if (!this.activeEditor) {\n      const {\n        row,\n  \
      col\n      } = this.instance.getSelectedRangeLast().highlight;\n      \
const renderableRowIndex = \
this.instance.rowIndexMapper.getRenderableFromVisualIndex(row);\n      const \
renderableColumnIndex = \
this.instance.columnIndexMapper.getRenderableFromVisualIndex(col);\n      \
this.instance.view.scrollViewport(this.instance._createCellCoords(renderableR\
owIndex, renderableColumnIndex));\n      this.instance.view.render();\n      \
this.prepareEditor();\n    }\n    if (this.activeEditor) {\n      if \
(enableFullEditMode) {\n        this.activeEditor.enableFullEditMode();\n     \
 }\n      this.activeEditor.beginEditing(newInitialValue, event2);\n    }\n  \
}\n  /**\n   * Close editor, finish editing cell.\n   *\n   * @param \
{boolean} restoreOriginalValue If `true`, then closes editor without saving \
value from the editor into a cell.\n   * @param {boolean} isCtrlPressed If \
`true`, then editor will save value to each cell in the last selected \
range.\n   * @param {Function} callback The callback function, fired after \
editor closing.\n   */\n  closeEditor(restoreOriginalValue, isCtrlPressed, \
callback) {\n    if (this.activeEditor) {\n      \
this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, \
callback);\n    } else if (callback) {\n      callback(false);\n    }\n  }\n  \
/**\n   * Close editor and save changes.\n   *\n   * @param {boolean} \
isCtrlPressed If `true`, then editor will save value to each cell in the last \
selected range.\n   */\n  closeEditorAndSaveChanges(isCtrlPressed) {\n    \
this.closeEditor(false, isCtrlPressed);\n  }\n  /**\n   * Close editor and \
restore original value.\n   *\n   * @param {boolean} isCtrlPressed Indication \
of whether the CTRL button is pressed.\n   */\n  \
closeEditorAndRestoreOriginalValue(isCtrlPressed) {\n    \
this.closeEditor(true, isCtrlPressed);\n  }\n  /**\n   * Clears reference to \
an instance of the active editor.\n   *\n   * @private\n   */\n  \
clearActiveEditor() {\n    this.activeEditor = void 0;\n  }\n  /**\n   * \
Checks if the currently selected cell (pointed by selection highlight coords) \
is editable.\n   * Editable cell is when:\n   *   - the cell has defined an \
editor type;\n   *   - the cell is not marked as read-only;\n   *   - the \
cell is not hidden.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  \
isCellEditable() {\n    const editorClass = \
this.instance.getCellEditor(this.cellProperties);\n    const {\n      row,\n  \
    col\n    } = this.instance.getSelectedRangeLast().highlight;\n    const \
{\n      rowIndexMapper,\n      columnIndexMapper\n    } = this.instance;\n   \
 const isCellHidden = \
rowIndexMapper.isHidden(this.instance.toPhysicalRow(row)) || \
columnIndexMapper.isHidden(this.instance.toPhysicalColumn(col));\n    if \
(this.cellProperties.readOnly || !editorClass || isCellHidden) {\n      \
return false;\n    }\n    return true;\n  }\n  /**\n   * Controls selection's \
behaviour after clicking `Enter`.\n   *\n   * @private\n   * @param {boolean} \
isShiftPressed If `true`, then the selection will move up after hit enter.\n  \
 */\n  moveSelectionAfterEnter(isShiftPressed) {\n    const enterMoves = \
typeof this.tableMeta.enterMoves === \"function\" ? \
this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves;\n    if \
(isShiftPressed) {\n      this.selection.transformStart(-enterMoves.row, \
-enterMoves.col);\n    } else {\n      \
this.selection.transformStart(enterMoves.row, enterMoves.col, true);\n    }\n \
 }\n  /**\n   * OnAfterDocumentKeyDown callback.\n   *\n   * @private\n   * \
@param {KeyboardEvent} event The keyboard event object.\n   */\n  \
onAfterDocumentKeyDown(event2) {\n    if (!this.instance.isListening()) {\n   \
   return;\n    }\n    const {\n      keyCode\n    } = event2;\n    if \
(!this.selection.isSelected()) {\n      return;\n    }\n    const \
isCtrlPressed = (event2.ctrlKey || event2.metaKey) && !event2.altKey;\n    if \
(!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) \
{\n      if (!isFunctionKey(keyCode) && !isCtrlMetaKey(keyCode) && \
!isCtrlPressed && !this.isEditorOpened()) {\n        const shortcutManager = \
this.instance.getShortcutManager();\n        const editorContext = \
shortcutManager.getContext(\"editor\");\n        const runOnlySelectedConfig \
= {\n          runOnlyIf: () => isDefined(this.instance.getSelected()),\n     \
     group: SHORTCUTS_GROUP_NAVIGATION\n        };\n        \
editorContext.addShortcuts([{\n          keys: [[\"ArrowUp\"]],\n          \
callback: () => {\n            this.instance.selection.transformStart(-1, \
0);\n          }\n        }, {\n          keys: [[\"ArrowDown\"]],\n          \
callback: () => {\n            this.instance.selection.transformStart(1, \
0);\n          }\n        }, {\n          keys: [[\"ArrowLeft\"]],\n          \
callback: () => {\n            this.instance.selection.transformStart(0, -1 * \
this.instance.getDirectionFactor());\n          }\n        }, {\n          \
keys: [[\"ArrowRight\"]],\n          callback: () => {\n            \
this.instance.selection.transformStart(0, \
this.instance.getDirectionFactor());\n          }\n        }], \
runOnlySelectedConfig);\n        this.openEditor(\"\", event2);\n      }\n    \
}\n  }\n  /**\n   * OnCellDblClick callback.\n   *\n   * @private\n   * \
@param {MouseEvent} event The mouse event object.\n   * @param {object} \
coords The cell coordinates.\n   * @param \
{HTMLTableCellElement|HTMLTableHeaderCellElement} elem The element which \
triggers the action.\n   */\n  onCellDblClick(event2, coords, elem) {\n    if \
(elem.nodeName === \"TD\") {\n      this.openEditor(null, event2, true);\n    \
}\n  }\n  /**\n   * Destroy the instance.\n   */\n  destroy() {\n    \
this.destroyed = true;\n    this.eventManager.destroy();\n  }\n};\nvar \
instances = /* @__PURE__ */ new WeakMap();\nEditorManager.getInstance = \
function(hotInstance, tableMeta, selection) {\n  let editorManager = \
instances.get(hotInstance);\n  if (!editorManager) {\n    editorManager = new \
EditorManager(hotInstance, tableMeta, selection);\n    \
instances.set(hotInstance, editorManager);\n  }\n  return \
editorManager;\n};\nvar editorManager_default = EditorManager;\n\n// \
node_modules/handsontable/utils/parseTable.mjs\nvar parseTable_exports = \
{};\n__export(parseTable_exports, {\n  _dataToHTML: () => _dataToHTML,\n  \
htmlToGridSettings: () => htmlToGridSettings,\n  instanceToHTML: () => \
instanceToHTML\n});\nvar ESCAPED_HTML_CHARS = {\n  \"&nbsp;\": \" \",\n  \
\"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\"\n};\nvar \
regEscapedChars = new RegExp(Object.keys(ESCAPED_HTML_CHARS).map((key) => \
`(${key})`).join(\"|\"), \"gi\");\nfunction isHTMLTable(element) {\n  return \
(element && element.nodeName || \"\") === \"TABLE\";\n}\nfunction \
instanceToHTML(instance) {\n  const hasColumnHeaders = \
instance.hasColHeaders();\n  const hasRowHeaders = \
instance.hasRowHeaders();\n  const coords = [hasColumnHeaders ? -1 : 0, \
hasRowHeaders ? -1 : 0, instance.countRows() - 1, instance.countCols() - \
1];\n  const data2 = instance.getData(...coords);\n  const countRows = \
data2.length;\n  const countCols = countRows > 0 ? data2[0].length : 0;\n  \
const TABLE = [\"<table>\", \"</table>\"];\n  const THEAD = hasColumnHeaders \
? [\"<thead>\", \"</thead>\"] : [];\n  const TBODY = [\"<tbody>\", \
\"</tbody>\"];\n  const rowModifier = hasRowHeaders ? 1 : 0;\n  const \
columnModifier = hasColumnHeaders ? 1 : 0;\n  for (let row = 0; row < \
countRows; row += 1) {\n    const isColumnHeadersRow = hasColumnHeaders && \
row === 0;\n    const CELLS = [];\n    for (let column = 0; column < \
countCols; column += 1) {\n      const isRowHeadersColumn = \
!isColumnHeadersRow && hasRowHeaders && column === 0;\n      let cell = \
\"\";\n      if (isColumnHeadersRow) {\n        cell = \
`<th>${instance.getColHeader(column - rowModifier)}</th>`;\n      } else if \
(isRowHeadersColumn) {\n        cell = `<th>${instance.getRowHeader(row - \
columnModifier)}</th>`;\n      } else {\n        const cellData = \
data2[row][column];\n        const {\n          hidden,\n          rowspan,\n \
         colspan\n        } = instance.getCellMeta(row - columnModifier, \
column - rowModifier);\n        if (!hidden) {\n          const attrs = [];\n \
         if (rowspan) {\n            attrs.push(`rowspan=\"${rowspan}\"`);\n  \
        }\n          if (colspan) {\n            \
attrs.push(`colspan=\"${colspan}\"`);\n          }\n          if \
(isEmpty(cellData)) {\n            cell = `<td ${attrs.join(\" \")}></td>`;\n \
         } else {\n            const value = \
cellData.toString().replace(\"<\", \"&lt;\").replace(\">\", \
\"&gt;\").replace(/(<br(\\s*|\\/)>(\\r\\n|\\n)?|\\r\\n|\\n)/g, \
\"<br>\\r\\n\").replace(/\\x20/gi, \"&nbsp;\").replace(/\\t/gi, \"&#9;\");\n  \
          cell = `<td ${attrs.join(\" \")}>${value}</td>`;\n          }\n     \
   }\n      }\n      CELLS.push(cell);\n    }\n    const TR = [\"<tr>\", \
...CELLS, \"</tr>\"].join(\"\");\n    if (isColumnHeadersRow) {\n      \
THEAD.splice(1, 0, TR);\n    } else {\n      TBODY.splice(-1, 0, TR);\n    \
}\n  }\n  TABLE.splice(1, 0, THEAD.join(\"\"), TBODY.join(\"\"));\n  return \
TABLE.join(\"\");\n}\nfunction _dataToHTML(input) {\n  const inputLen = \
input.length;\n  const result = [\"<table>\"];\n  for (let row = 0; row < \
inputLen; row += 1) {\n    const rowData = input[row];\n    const columnsLen \
= rowData.length;\n    const columnsResult = [];\n    if (row === 0) {\n      \
result.push(\"<tbody>\");\n    }\n    for (let column = 0; column < \
columnsLen; column += 1) {\n      const cellData = rowData[column];\n      \
const parsedCellData = isEmpty(cellData) ? \"\" : \
cellData.toString().replace(/</g, \"&lt;\").replace(/>/g, \
\"&gt;\").replace(/(<br(\\s*|\\/)>(\\r\\n|\\n)?|\\r\\n|\\n)/g, \
\"<br>\\r\\n\").replace(/\\x20{2,}/gi, (substring) => {\n        return \
`<span style=\"mso-spacerun: yes\">${\"&nbsp;\".repeat(substring.length - 1)} \
</span>`;\n      }).replace(/\\t/gi, \"&#9;\");\n      \
columnsResult.push(`<td>${parsedCellData}</td>`);\n    }\n    \
result.push(\"<tr>\", ...columnsResult, \"</tr>\");\n    if (row + 1 === \
inputLen) {\n      result.push(\"</tbody>\");\n    }\n  }\n  \
result.push(\"</table>\");\n  return result.join(\"\");\n}\nfunction \
htmlToGridSettings(element) {\n  let rootDocument = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : document;\n  const settingsObj = \
{};\n  const fragment = rootDocument.createDocumentFragment();\n  const \
tempElem = rootDocument.createElement(\"div\");\n  \
fragment.appendChild(tempElem);\n  let checkElement = element;\n  if (typeof \
checkElement === \"string\") {\n    const escapedAdjacentHTML = \
checkElement.replace(/<td\\b[^>]*?>([\\s\\S]*?)<\\/\\s*td>/g, (cellFragment) \
=> {\n      const openingTag = cellFragment.match(/<td\\b[^>]*?>/g)[0];\n     \
 const cellValue = cellFragment.substring(openingTag.length, \
cellFragment.lastIndexOf(\"<\")).replace(/(<(?!br)([^>]+)>)/gi, \"\");\n      \
const closingTag = \"</td>\";\n      return \
`${openingTag}${cellValue}${closingTag}`;\n    });\n    \
tempElem.insertAdjacentHTML(\"afterbegin\", `${escapedAdjacentHTML}`);\n    \
checkElement = tempElem.querySelector(\"table\");\n  }\n  if (!checkElement \
|| !isHTMLTable(checkElement)) {\n    return;\n  }\n  const generator = \
tempElem.querySelector('meta[name$=\"enerator\"]');\n  const hasRowHeaders = \
checkElement.querySelector(\"tbody th\") !== null;\n  const trElement = \
checkElement.querySelector(\"tr\");\n  const countCols = !trElement ? 0 : \
Array.from(trElement.cells).reduce((cols, cell) => cols + cell.colSpan, 0) - \
(hasRowHeaders ? 1 : 0);\n  const fixedRowsBottom = checkElement.tFoot && \
Array.from(checkElement.tFoot.rows) || [];\n  const fixedRowsTop = [];\n  let \
hasColHeaders = false;\n  let thRowsLen = 0;\n  let countRows = 0;\n  if \
(checkElement.tHead) {\n    const thRows = \
Array.from(checkElement.tHead.rows).filter((tr) => {\n      const isDataRow = \
tr.querySelector(\"td\") !== null;\n      if (isDataRow) {\n        \
fixedRowsTop.push(tr);\n      }\n      return !isDataRow;\n    });\n    \
thRowsLen = thRows.length;\n    hasColHeaders = thRowsLen > 0;\n    if \
(thRowsLen > 1) {\n      settingsObj.nestedHeaders = \
Array.from(thRows).reduce((rows, row) => {\n        const headersRow = \
Array.from(row.cells).reduce((headers, header, currentIndex) => {\n          \
if (hasRowHeaders && currentIndex === 0) {\n            return headers;\n     \
     }\n          const {\n            colSpan: colspan,\n            \
innerHTML\n          } = header;\n          const nextHeader = colspan > 1 ? \
{\n            label: innerHTML,\n            colspan\n          } : \
innerHTML;\n          headers.push(nextHeader);\n          return headers;\n  \
      }, []);\n        rows.push(headersRow);\n        return rows;\n      }, \
[]);\n    } else if (hasColHeaders) {\n      settingsObj.colHeaders = \
Array.from(thRows[0].children).reduce((headers, header, index2) => {\n        \
if (hasRowHeaders && index2 === 0) {\n          return headers;\n        }\n  \
      headers.push(header.innerHTML);\n        return headers;\n      }, \
[]);\n    }\n  }\n  if (fixedRowsTop.length) {\n    settingsObj.fixedRowsTop \
= fixedRowsTop.length;\n  }\n  if (fixedRowsBottom.length) {\n    \
settingsObj.fixedRowsBottom = fixedRowsBottom.length;\n  }\n  const dataRows \
= [...fixedRowsTop, ...Array.from(checkElement.tBodies).reduce((sections, \
section) => {\n    sections.push(...Array.from(section.rows));\n    return \
sections;\n  }, []), ...fixedRowsBottom];\n  countRows = dataRows.length;\n  \
const dataArr = new Array(countRows);\n  for (let r = 0; r < countRows; r++) \
{\n    dataArr[r] = new Array(countCols);\n  }\n  const mergeCells = [];\n  \
const rowHeaders = [];\n  for (let row = 0; row < countRows; row++) {\n    \
const tr = dataRows[row];\n    const cells = Array.from(tr.cells);\n    const \
cellsLen = cells.length;\n    for (let cellId = 0; cellId < cellsLen; \
cellId++) {\n      const cell = cells[cellId];\n      const {\n        \
nodeName,\n        innerHTML,\n        rowSpan: rowspan,\n        colSpan: \
colspan\n      } = cell;\n      const col = dataArr[row].findIndex((value) => \
value === void 0);\n      if (nodeName === \"TD\") {\n        if (rowspan > 1 \
|| colspan > 1) {\n          for (let rstart = row; rstart < row + rowspan; \
rstart++) {\n            if (rstart < countRows) {\n              for (let \
cstart = col; cstart < col + colspan; cstart++) {\n                \
dataArr[rstart][cstart] = null;\n              }\n            }\n          \
}\n          const styleAttr = cell.getAttribute(\"style\");\n          const \
ignoreMerge = styleAttr && styleAttr.includes(\"mso-ignore:colspan\");\n      \
    if (!ignoreMerge) {\n            mergeCells.push({\n              col,\n  \
            row,\n              rowspan,\n              colspan\n            \
});\n          }\n        }\n        let cellValue = \"\";\n        if \
(generator && /excel/gi.test(generator.content)) {\n          cellValue = \
innerHTML.replace(/[\\r\\n][\\x20]{0,2}/g, \" \
\").replace(/<br(\\s*|\\/)>[\\r\\n]?[\\x20]{0,3}/gim, \"\\r\\n\");\n        } \
else {\n          cellValue = innerHTML.replace(/<br(\\s*|\\/)>[\\r\\n]?/gim, \
\"\\r\\n\");\n        }\n        dataArr[row][col] = \
cellValue.replace(regEscapedChars, (match) => ESCAPED_HTML_CHARS[match]);\n   \
   } else {\n        rowHeaders.push(innerHTML);\n      }\n    }\n  }\n  if \
(mergeCells.length) {\n    settingsObj.mergeCells = mergeCells;\n  }\n  if \
(rowHeaders.length) {\n    settingsObj.rowHeaders = rowHeaders;\n  }\n  if \
(dataArr.length) {\n    settingsObj.data = dataArr;\n  }\n  return \
settingsObj;\n}\n\n// node_modules/handsontable/helpers/number.mjs\nvar \
number_exports = {};\n__export(number_exports, {\n  isNumeric: () => \
isNumeric,\n  isNumericLike: () => isNumericLike,\n  rangeEach: () => \
rangeEach,\n  rangeEachReverse: () => rangeEachReverse,\n  \
valueAccordingPercent: () => valueAccordingPercent\n});\nfunction \
isNumeric(value) {\n  let additionalDelimiters = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : [];\n  const type = typeof value;\n  \
if (type === \"number\") {\n    return !isNaN(value) && isFinite(value);\n  } \
else if (type === \"string\") {\n    if (value.length === 0) {\n      return \
false;\n    } else if (value.length === 1) {\n      return \
/\\d/.test(value);\n    }\n    const delimiter = Array.from(/* @__PURE__ */ \
new Set([\".\", ...additionalDelimiters])).map((d) => \
`\\\\${d}`).join(\"|\");\n    return new \
RegExp(`^[+-]?\\\\s*(((${delimiter})?\\\\d+((${delimiter})\\\\d+)?(e[+-]?\\\\\
d+)?)|(0x[a-f\\\\d]+))$`, \"i\").test(value.trim());\n  } else if (type === \
\"object\") {\n    return !!value && typeof value.valueOf() === \"number\" && \
!(value instanceof Date);\n  }\n  return false;\n}\nfunction \
isNumericLike(value) {\n  return isNumeric(value, [\",\"]);\n}\nfunction \
rangeEach(rangeFrom, rangeTo, iteratee) {\n  let index2 = -1;\n  if (typeof \
rangeTo === \"function\") {\n    iteratee = rangeTo;\n    rangeTo = \
rangeFrom;\n  } else {\n    index2 = rangeFrom - 1;\n  }\n  while (++index2 \
<= rangeTo) {\n    if (iteratee(index2) === false) {\n      break;\n    }\n  \
}\n}\nfunction rangeEachReverse(rangeFrom, rangeTo, iteratee) {\n  let index2 \
= rangeFrom + 1;\n  if (typeof rangeTo === \"function\") {\n    iteratee = \
rangeTo;\n    rangeTo = 0;\n  }\n  while (--index2 >= rangeTo) {\n    if \
(iteratee(index2) === false) {\n      break;\n    }\n  }\n}\nfunction \
valueAccordingPercent(value, percent) {\n  percent = \
parseInt(percent.toString().replace(\"%\", \"\"), 10);\n  percent = \
isNaN(percent) ? 0 : percent;\n  return parseInt(value * percent / 100, \
10);\n}\n\n// \
node_modules/handsontable/utils/dataStructures/priorityMap.mjs\nvar ASC = \
\"asc\";\nvar DESC = \"desc\";\nvar ORDER_MAP = /* @__PURE__ */ new \
Map([[ASC, [-1, 1]], [DESC, [1, -1]]]);\nvar DEFAULT_ERROR_PRIORITY_EXISTS = \
(priority) => `The priority '${priority}' is already declared in a \
map.`;\nvar DEFAULT_ERROR_PRIORITY_NAN = (priority) => `The priority \
'${priority}' is not a number.`;\nfunction createPriorityMap() {\n  let {\n   \
 errorPriorityExists,\n    errorPriorityNaN\n  } = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : {};\n  const priorityMap = /* \
@__PURE__ */ new Map();\n  errorPriorityExists = \
isFunction(errorPriorityExists) ? errorPriorityExists : \
DEFAULT_ERROR_PRIORITY_EXISTS;\n  errorPriorityNaN = \
isFunction(errorPriorityNaN) ? errorPriorityNaN : \
DEFAULT_ERROR_PRIORITY_NAN;\n  function addItem(priority, item) {\n    if \
(!isNumeric(priority)) {\n      throw new \
Error(errorPriorityNaN(priority));\n    }\n    if (priorityMap.has(priority)) \
{\n      throw new Error(errorPriorityExists(priority));\n    }\n    \
priorityMap.set(priority, item);\n  }\n  function getItems2() {\n    let \
order = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
ASC;\n    const [left2, right2] = ORDER_MAP.get(order) || \
ORDER_MAP.get(ASC);\n    return [...priorityMap].sort((a, b) => a[0] < b[0] ? \
left2 : right2).map((item) => item[1]);\n  }\n  return {\n    addItem,\n    \
getItems: getItems2\n  };\n}\n\n// \
node_modules/handsontable/utils/dataStructures/uniqueMap.mjs\nvar \
DEFAULT_ERROR_ID_EXISTS = (id) => `The id '${id}' is already declared in a \
map.`;\nfunction createUniqueMap() {\n  let {\n    errorIdExists\n  } = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n  const \
uniqueMap = /* @__PURE__ */ new Map();\n  errorIdExists = \
isFunction(errorIdExists) ? errorIdExists : DEFAULT_ERROR_ID_EXISTS;\n  \
function addItem(id, item) {\n    if (hasItem5(id)) {\n      throw new \
Error(errorIdExists(id));\n    }\n    uniqueMap.set(id, item);\n  }\n  \
function removeItem(id) {\n    return uniqueMap.delete(id);\n  }\n  function \
clear() {\n    uniqueMap.clear();\n  }\n  function getId(item) {\n    const \
[itemId] = getItems2().find((_ref) => {\n      let [id, element] = _ref;\n    \
  if (item === element) {\n        return id;\n      }\n      return false;\n \
   }) || [null];\n    return itemId;\n  }\n  function getItem6(id) {\n    \
return uniqueMap.get(id);\n  }\n  function getItems2() {\n    return \
[...uniqueMap];\n  }\n  function hasItem5(id) {\n    return \
uniqueMap.has(id);\n  }\n  return {\n    addItem,\n    clear,\n    getId,\n   \
 getItem: getItem6,\n    getItems: getItems2,\n    hasItem: hasItem5,\n    \
removeItem\n  };\n}\n\n// \
node_modules/handsontable/utils/dataStructures/uniqueSet.mjs\nvar \
DEFAULT_ERROR_ITEM_EXISTS = (item) => `'${item}' value is already declared in \
a unique set.`;\nfunction createUniqueSet() {\n  let {\n    errorItemExists\n \
 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n  \
const uniqueSet = /* @__PURE__ */ new Set();\n  errorItemExists = \
isFunction(errorItemExists) ? errorItemExists : DEFAULT_ERROR_ITEM_EXISTS;\n  \
function addItem(item) {\n    if (uniqueSet.has(item)) {\n      throw new \
Error(errorItemExists(item));\n    }\n    uniqueSet.add(item);\n  }\n  \
function getItems2() {\n    return [...uniqueSet];\n  }\n  function clear() \
{\n    uniqueSet.clear();\n  }\n  return {\n    addItem,\n    clear,\n    \
getItems: getItems2\n  };\n}\n\n// \
node_modules/handsontable/plugins/registry.mjs\nvar ERROR_PLUGIN_REGISTERED = \
(pluginName) => `There is already registered \"${pluginName}\" plugin.`;\nvar \
ERROR_PRIORITY_REGISTERED = (priority) => `There is already registered plugin \
on priority \"${priority}\".`;\nvar ERROR_PRIORITY_NAN = (priority) => `The \
priority \"${priority}\" is not a number.`;\nvar priorityPluginsQueue = \
createPriorityMap({\n  errorPriorityExists: ERROR_PRIORITY_REGISTERED,\n  \
errorPriorityNaN: ERROR_PRIORITY_NAN\n});\nvar uniquePluginsQueue = \
createUniqueSet({\n  errorItemExists: ERROR_PLUGIN_REGISTERED\n});\nvar \
uniquePluginsList = createUniqueMap({\n  errorIdExists: \
ERROR_PLUGIN_REGISTERED\n});\nfunction getPluginsNames() {\n  return \
[...priorityPluginsQueue.getItems(), \
...uniquePluginsQueue.getItems()];\n}\nfunction getPlugin(pluginName) {\n  \
const unifiedPluginName = toUpperCaseFirst(pluginName);\n  return \
uniquePluginsList.getItem(unifiedPluginName);\n}\nfunction \
hasPlugin(pluginName) {\n  return getPlugin(pluginName) ? true : \
false;\n}\nfunction registerPlugin(pluginName, pluginClass, priority) {\n  \
[pluginName, pluginClass, priority] = unifyPluginArguments(pluginName, \
pluginClass, priority);\n  if (getPlugin(pluginName) === void 0) {\n    \
_registerPlugin(pluginName, pluginClass, priority);\n  }\n}\nfunction \
_registerPlugin(pluginName, pluginClass, priority) {\n  const \
unifiedPluginName = toUpperCaseFirst(pluginName);\n  if \
(uniquePluginsList.hasItem(unifiedPluginName)) {\n    throw new \
Error(ERROR_PLUGIN_REGISTERED(unifiedPluginName));\n  }\n  if (priority === \
void 0) {\n    uniquePluginsQueue.addItem(unifiedPluginName);\n  } else {\n   \
 priorityPluginsQueue.addItem(priority, unifiedPluginName);\n  }\n  \
uniquePluginsList.addItem(unifiedPluginName, pluginClass);\n}\nfunction \
unifyPluginArguments(pluginName, pluginClass, priority) {\n  if (typeof \
pluginName === \"function\") {\n    pluginClass = pluginName;\n    pluginName \
= pluginClass.PLUGIN_KEY;\n    priority = pluginClass.PLUGIN_PRIORITY;\n  }\n \
 return [pluginName, pluginClass, priority];\n}\n\n// \
node_modules/handsontable/renderers/registry.mjs\nvar {\n  register: \
register2,\n  getItem: getItem2,\n  hasItem: hasItem2,\n  getNames: \
getNames2,\n  getValues: getValues2\n} = \
staticRegister(\"renderers\");\nfunction _getItem2(name) {\n  if (typeof name \
=== \"function\") {\n    return name;\n  }\n  if (!hasItem2(name)) {\n    \
throw Error(`No registered renderer found under \"${name}\" name`);\n  }\n  \
return getItem2(name);\n}\nfunction _register2(name, renderer) {\n  if \
(typeof name !== \"string\") {\n    renderer = name;\n    name = \
renderer.RENDERER_TYPE;\n  }\n  register2(name, renderer);\n}\n\n// \
node_modules/handsontable/validators/registry.mjs\nvar {\n  register: \
register3,\n  getItem: getItem3,\n  hasItem: hasItem3,\n  getNames: \
getNames3,\n  getValues: getValues3\n} = \
staticRegister(\"validators\");\nfunction _getItem3(name) {\n  if (typeof \
name === \"function\") {\n    return name;\n  }\n  if (!hasItem3(name)) {\n   \
 throw Error(`No registered validator found under \"${name}\" name`);\n  }\n  \
return getItem3(name);\n}\nfunction _register3(name, validator) {\n  if \
(typeof name !== \"string\") {\n    validator = name;\n    name = \
validator.VALIDATOR_TYPE;\n  }\n  register3(name, validator);\n}\n\n// \
node_modules/core-js/modules/es.array.at.js\nvar $4 = require_export();\nvar \
toObject2 = require_to_object();\nvar lengthOfArrayLike2 = \
require_length_of_array_like();\nvar toIntegerOrInfinity = \
require_to_integer_or_infinity();\nvar addToUnscopables = \
require_add_to_unscopables();\n$4({ target: \"Array\", proto: true }, {\n  \
at: function at(index2) {\n    var O = toObject2(this);\n    var len = \
lengthOfArrayLike2(O);\n    var relativeIndex = \
toIntegerOrInfinity(index2);\n    var k = relativeIndex >= 0 ? relativeIndex \
: len + relativeIndex;\n    return k < 0 || k >= len ? void 0 : O[k];\n  \
}\n});\naddToUnscopables(\"at\");\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/calculator/constants.mjs\n\
var RENDER_TYPE = 1;\nvar FULLY_VISIBLE_TYPE = 2;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/calculator/viewportColumns\
.mjs\nvar privatePool = /* @__PURE__ */ new WeakMap();\nvar \
ViewportColumnsCalculator = class _ViewportColumnsCalculator {\n  /**\n   * \
Default column width.\n   *\n   * @type {number}\n   */\n  static get \
DEFAULT_WIDTH() {\n    return 50;\n  }\n  /**\n   * @param {object} options \
Object with all options specified for column viewport calculation.\n   * \
@param {number} options.viewportSize Width of the viewport.\n   * @param \
{number} options.scrollOffset Current horizontal scroll position of the \
viewport.\n   * @param {number} options.totalItems Total number of columns.\n \
  * @param {Function} options.itemSizeFn Function that returns the width of \
the column at a given index (in px).\n   * @param {Function} \
options.overrideFn Function that changes calculated this.startRow, \
this.endRow (used by\n   *   MergeCells plugin).\n   * @param {string} \
options.calculationType String which describes types of calculation which \
will be performed.\n   * @param {string} options.inlineStartOffset \
Inline-start offset of the parent container.\n   * @param {string} \
[options.stretchMode] Stretch mode 'all' or 'last'.\n   * @param {Function} \
[options.stretchingItemWidthFn] Function that returns the new width of the \
stretched column.\n   */\n  constructor() {\n    let {\n      viewportSize,\n \
     scrollOffset,\n      totalItems,\n      itemSizeFn,\n      overrideFn,\n \
     calculationType,\n      stretchMode,\n      stretchingItemWidthFn = \
(width) => width,\n      inlineStartOffset\n    } = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : {};\n    privatePool.set(this, {\n   \
   viewportWidth: viewportSize,\n      scrollOffset,\n      totalColumns: \
totalItems,\n      columnWidthFn: itemSizeFn,\n      overrideFn,\n      \
calculationType,\n      stretchingColumnWidthFn: stretchingItemWidthFn,\n     \
 inlineStartOffset\n    });\n    this.count = 0;\n    this.startColumn = \
null;\n    this.endColumn = null;\n    this.startPosition = null;\n    \
this.isVisibleInTrimmingContainer = false;\n    this.stretchAllRatio = 0;\n   \
 this.stretchLastWidth = 0;\n    this.stretch = stretchMode;\n    \
this.totalTargetWidth = 0;\n    this.needVerifyLastColumnWidth = true;\n    \
this.stretchAllColumnsWidth = [];\n    this.calculate();\n  }\n  /**\n   * \
Calculates viewport.\n   */\n  calculate() {\n    let sum = 0;\n    let \
needReverse = true;\n    const startPositions = [];\n    let columnWidth;\n   \
 let firstVisibleColumnWidth = 0;\n    let lastVisibleColumnWidth = 0;\n    \
const priv = privatePool.get(this);\n    const calculationType = \
priv.calculationType;\n    const overrideFn = priv.overrideFn;\n    const \
scrollOffset = priv.scrollOffset;\n    const zeroBasedScrollOffset = \
Math.max(priv.scrollOffset, 0);\n    const totalColumns = \
priv.totalColumns;\n    const viewportWidth = priv.viewportWidth;\n    const \
compensatedViewportWidth = zeroBasedScrollOffset > 0 ? viewportWidth + 1 : \
viewportWidth;\n    for (let i = 0; i < totalColumns; i++) {\n      \
columnWidth = this._getColumnWidth(i);\n      if (sum <= \
zeroBasedScrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\n        \
this.startColumn = i;\n        firstVisibleColumnWidth = columnWidth;\n      \
}\n      if (sum >= zeroBasedScrollOffset && sum + (calculationType === \
FULLY_VISIBLE_TYPE ? columnWidth : 0) <= zeroBasedScrollOffset + \
compensatedViewportWidth) {\n        if (this.startColumn === null || \
this.startColumn === void 0) {\n          this.startColumn = i;\n          \
firstVisibleColumnWidth = columnWidth;\n        }\n        this.endColumn = \
i;\n      }\n      startPositions.push(sum);\n      sum += columnWidth;\n     \
 lastVisibleColumnWidth = columnWidth;\n      if (calculationType !== \
FULLY_VISIBLE_TYPE) {\n        this.endColumn = i;\n      }\n      if (sum >= \
zeroBasedScrollOffset + viewportWidth) {\n        needReverse = false;\n      \
  break;\n      }\n    }\n    const mostRightScrollOffset = scrollOffset + \
viewportWidth - compensatedViewportWidth;\n    const inlineEndColumnOffset = \
calculationType === FULLY_VISIBLE_TYPE ? 0 : lastVisibleColumnWidth;\n    \
const inlineStartColumnOffset = calculationType === FULLY_VISIBLE_TYPE ? \
firstVisibleColumnWidth : 0;\n    if (\n      // the table is to the left of \
the viewport\n      mostRightScrollOffset < -1 * priv.inlineStartOffset || \
scrollOffset > startPositions.at(-1) + inlineEndColumnOffset || // the table \
is to the right of the viewport\n      -1 * priv.scrollOffset - \
priv.viewportWidth > -1 * inlineStartColumnOffset\n    ) {\n      \
this.isVisibleInTrimmingContainer = false;\n    } else {\n      \
this.isVisibleInTrimmingContainer = true;\n    }\n    if (this.endColumn === \
totalColumns - 1 && needReverse) {\n      this.startColumn = \
this.endColumn;\n      while (this.startColumn > 0) {\n        const \
viewportSum = startPositions[this.endColumn] + columnWidth - \
startPositions[this.startColumn - 1];\n        if (viewportSum <= \
viewportWidth || calculationType !== FULLY_VISIBLE_TYPE) {\n          \
this.startColumn -= 1;\n        }\n        if (viewportSum > viewportWidth) \
{\n          break;\n        }\n      }\n    }\n    if (calculationType === \
RENDER_TYPE && this.startColumn !== null && overrideFn) {\n      \
overrideFn(this);\n    }\n    this.startPosition = \
startPositions[this.startColumn];\n    if (this.startPosition === void 0) {\n \
     this.startPosition = null;\n    }\n    if (totalColumns < \
this.endColumn) {\n      this.endColumn = totalColumns - 1;\n    }\n    if \
(this.startColumn !== null) {\n      this.count = this.endColumn - \
this.startColumn + 1;\n    }\n  }\n  /**\n   * Recalculate columns \
stretching.\n   *\n   * @param {number} totalWidth The total width of the \
table.\n   */\n  refreshStretching(totalWidth) {\n    if (this.stretch === \
\"none\") {\n      return;\n    }\n    let totalColumnsWidth = totalWidth;\n  \
  this.totalTargetWidth = totalColumnsWidth;\n    const priv = \
privatePool.get(this);\n    const totalColumns = priv.totalColumns;\n    let \
sumAll = 0;\n    for (let i = 0; i < totalColumns; i++) {\n      const \
columnWidth = this._getColumnWidth(i);\n      const permanentColumnWidth = \
priv.stretchingColumnWidthFn(void 0, i);\n      if (typeof \
permanentColumnWidth === \"number\") {\n        totalColumnsWidth -= \
permanentColumnWidth;\n      } else {\n        sumAll += columnWidth;\n      \
}\n    }\n    const remainingSize = totalColumnsWidth - sumAll;\n    if \
(this.stretch === \"all\" && remainingSize > 0) {\n      this.stretchAllRatio \
= totalColumnsWidth / sumAll;\n      this.stretchAllColumnsWidth = [];\n      \
this.needVerifyLastColumnWidth = true;\n    } else if (this.stretch === \
\"last\" && totalColumnsWidth !== Infinity) {\n      const columnWidth = \
this._getColumnWidth(totalColumns - 1);\n      const lastColumnWidth = \
remainingSize + columnWidth;\n      this.stretchLastWidth = lastColumnWidth \
>= 0 ? lastColumnWidth : columnWidth;\n    }\n  }\n  /**\n   * Get stretched \
column width based on stretchH (all or last) setting passed in handsontable \
instance.\n   *\n   * @param {number} column The visual column index.\n   * \
@param {number} baseWidth The default column width.\n   * @returns \
{number|null}\n   */\n  getStretchedColumnWidth(column, baseWidth) {\n    let \
result = null;\n    if (this.stretch === \"all\" && this.stretchAllRatio !== \
0) {\n      result = this._getStretchedAllColumnWidth(column, baseWidth);\n   \
 } else if (this.stretch === \"last\" && this.stretchLastWidth !== 0) {\n     \
 result = this._getStretchedLastColumnWidth(column);\n    }\n    return \
result;\n  }\n  /**\n   * @param {number} column The visual column index.\n   \
* @param {number} baseWidth The default column width.\n   * @returns \
{number}\n   * @private\n   */\n  _getStretchedAllColumnWidth(column, \
baseWidth) {\n    let sumRatioWidth = 0;\n    const priv = \
privatePool.get(this);\n    const totalColumns = priv.totalColumns;\n    if \
(!this.stretchAllColumnsWidth[column]) {\n      const stretchedWidth = \
Math.round(baseWidth * this.stretchAllRatio);\n      const newStretchedWidth \
= priv.stretchingColumnWidthFn(stretchedWidth, column);\n      if \
(newStretchedWidth === void 0) {\n        this.stretchAllColumnsWidth[column] \
= stretchedWidth;\n      } else {\n        \
this.stretchAllColumnsWidth[column] = isNaN(newStretchedWidth) ? \
this._getColumnWidth(column) : newStretchedWidth;\n      }\n    }\n    if \
(this.stretchAllColumnsWidth.length === totalColumns && \
this.needVerifyLastColumnWidth) {\n      this.needVerifyLastColumnWidth = \
false;\n      for (let i = 0; i < this.stretchAllColumnsWidth.length; i++) \
{\n        sumRatioWidth += this.stretchAllColumnsWidth[i];\n      }\n      \
if (sumRatioWidth !== this.totalTargetWidth) {\n        \
this.stretchAllColumnsWidth[this.stretchAllColumnsWidth.length - 1] += \
this.totalTargetWidth - sumRatioWidth;\n      }\n    }\n    return \
this.stretchAllColumnsWidth[column];\n  }\n  /**\n   * @param {number} column \
The visual column index.\n   * @returns {number|null}\n   * @private\n   */\n \
 _getStretchedLastColumnWidth(column) {\n    const priv = \
privatePool.get(this);\n    const totalColumns = priv.totalColumns;\n    if \
(column === totalColumns - 1) {\n      return this.stretchLastWidth;\n    }\n \
   return null;\n  }\n  /**\n   * @param {number} column The visual column \
index.\n   * @returns {number}\n   * @private\n   */\n  \
_getColumnWidth(column) {\n    let width = \
privatePool.get(this).columnWidthFn(column);\n    if (isNaN(width)) {\n      \
width = _ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n    return width;\n \
 }\n};\nvar viewportColumns_default = ViewportColumnsCalculator;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/calculator/viewportRows.mj\
s\nvar privatePool2 = /* @__PURE__ */ new WeakMap();\nvar \
ViewportRowsCalculator = class _ViewportRowsCalculator {\n  /**\n   * Default \
row height.\n   *\n   * @type {number}\n   */\n  static get DEFAULT_HEIGHT() \
{\n    return 23;\n  }\n  /**\n   * @param {object} options Object with all \
options specified for row viewport calculation.\n   * @param {number} \
options.viewportSize Height of the viewport.\n   * @param {number} \
options.scrollOffset Current vertical scroll position of the viewport.\n   * \
@param {number} options.totalItems Total number of rows.\n   * @param \
{Function} options.itemSizeFn Function that returns the height of the row at \
a given index (in px).\n   * @param {Function} options.overrideFn Function \
that changes calculated this.startRow, this.endRow (used by MergeCells \
plugin).\n   * @param {string} options.calculationType String which describes \
types of calculation which will be performed.\n   * @param {number} \
options.scrollbarHeight The scrollbar height.\n   */\n  constructor() {\n    \
let {\n      viewportSize,\n      scrollOffset,\n      totalItems,\n      \
itemSizeFn,\n      overrideFn,\n      calculationType,\n      \
scrollbarHeight\n    } = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : {};\n    privatePool2.set(this, {\n      viewportHeight: \
viewportSize,\n      scrollOffset,\n      totalRows: totalItems,\n      \
rowHeightFn: itemSizeFn,\n      overrideFn,\n      calculationType,\n      \
horizontalScrollbarHeight: scrollbarHeight\n    });\n    this.count = 0;\n    \
this.startRow = null;\n    this.endRow = null;\n    this.startPosition = \
null;\n    this.isVisibleInTrimmingContainer = false;\n    \
this.calculate();\n  }\n  /**\n   * Calculates viewport.\n   */\n  \
calculate() {\n    const priv = privatePool2.get(this);\n    const \
calculationType = priv.calculationType;\n    const overrideFn = \
priv.overrideFn;\n    const rowHeightFn = priv.rowHeightFn;\n    const \
scrollOffset = priv.scrollOffset;\n    const zeroBasedScrollOffset = \
Math.max(priv.scrollOffset, 0);\n    const totalRows = priv.totalRows;\n    \
const viewportHeight = priv.viewportHeight;\n    const \
horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;\n    let sum \
= 0;\n    let needReverse = true;\n    const startPositions = [];\n    let \
rowHeight;\n    let firstVisibleRowHeight = 0;\n    let lastVisibleRowHeight \
= 0;\n    for (let i = 0; i < totalRows; i++) {\n      rowHeight = \
rowHeightFn(i);\n      if (isNaN(rowHeight)) {\n        rowHeight = \
_ViewportRowsCalculator.DEFAULT_HEIGHT;\n      }\n      if (sum <= \
zeroBasedScrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\n        \
this.startRow = i;\n        firstVisibleRowHeight = rowHeight;\n      }\n     \
 if (sum >= zeroBasedScrollOffset && sum + (calculationType === \
FULLY_VISIBLE_TYPE ? rowHeight : 0) <= zeroBasedScrollOffset + viewportHeight \
- horizontalScrollbarHeight) {\n        if (this.startRow === null) {\n       \
   this.startRow = i;\n          firstVisibleRowHeight = rowHeight;\n        \
}\n        this.endRow = i;\n      }\n      startPositions.push(sum);\n      \
sum += rowHeight;\n      lastVisibleRowHeight = rowHeight;\n      if \
(calculationType !== FULLY_VISIBLE_TYPE) {\n        this.endRow = i;\n      \
}\n      if (sum >= zeroBasedScrollOffset + viewportHeight - \
horizontalScrollbarHeight) {\n        needReverse = false;\n        break;\n  \
    }\n    }\n    const mostBottomScrollOffset = scrollOffset + \
viewportHeight - horizontalScrollbarHeight;\n    const topRowOffset = \
calculationType === FULLY_VISIBLE_TYPE ? firstVisibleRowHeight : 0;\n    \
const bottomRowOffset = calculationType === FULLY_VISIBLE_TYPE ? 0 : \
lastVisibleRowHeight;\n    if (mostBottomScrollOffset < topRowOffset || \
scrollOffset > startPositions.at(-1) + bottomRowOffset) {\n      \
this.isVisibleInTrimmingContainer = false;\n    } else {\n      \
this.isVisibleInTrimmingContainer = true;\n    }\n    if (this.endRow === \
totalRows - 1 && needReverse) {\n      this.startRow = this.endRow;\n      \
while (this.startRow > 0) {\n        const viewportSum = \
startPositions[this.endRow] + rowHeight - startPositions[this.startRow - \
1];\n        if (viewportSum <= viewportHeight - horizontalScrollbarHeight || \
calculationType !== FULLY_VISIBLE_TYPE) {\n          this.startRow -= 1;\n    \
    }\n        if (viewportSum >= viewportHeight - horizontalScrollbarHeight) \
{\n          break;\n        }\n      }\n    }\n    if (calculationType === \
RENDER_TYPE && this.startRow !== null && overrideFn) {\n      \
overrideFn(this);\n    }\n    this.startPosition = \
startPositions[this.startRow];\n    if (this.startPosition === void 0) {\n    \
  this.startPosition = null;\n    }\n    if (totalRows < this.endRow) {\n     \
 this.endRow = totalRows - 1;\n    }\n    if (this.startRow !== null) {\n     \
 this.count = this.endRow - this.startRow + 1;\n    }\n  }\n};\nvar \
viewportRows_default = ViewportRowsCalculator;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/cell/coords.mjs\nfunction \
_classPrivateFieldInitSpec(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  \
if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key \
in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: true, \
configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  \
}\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = \
_toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \
\"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  \
var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \
\"get\");\n  return _classApplyDescriptorGet(receiver, \
descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  \
if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  \
return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, \
privateMap, value) {\n  var descriptor = \
_classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  \
_classApplyDescriptorSet(receiver, descriptor, value);\n  return \
value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, \
action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorSet(receiver, descriptor, value) {\n  if \
(descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n   \
 if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set \
read only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\nvar _isRtl = /* @__PURE__ */ new WeakMap();\nvar CellCoords = class \
_CellCoords {\n  constructor(row, column) {\n    let isRtl = arguments.length \
> 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    \
_defineProperty(this, \"row\", null);\n    _defineProperty(this, \"col\", \
null);\n    _classPrivateFieldInitSpec(this, _isRtl, {\n      writable: \
true,\n      value: false\n    });\n    _classPrivateFieldSet(this, _isRtl, \
isRtl);\n    if (typeof row !== \"undefined\" && typeof column !== \
\"undefined\") {\n      this.row = row;\n      this.col = column;\n    }\n  \
}\n  /**\n   * Checks if the coordinates in your `CellCoords` instance are \
valid\n   * in the context of a given Walkontable instance.\n   *\n   * The \
`row` index:\n   * - Can't be negative.\n   * - Can't be higher than the \
total number of rows in the Walkontable instance.\n   *\n   * The `col` \
index:\n   * - Can't be negative.\n   * - Can't be higher than the total \
number of columns in the Walkontable instance.\n   *\n   * @param \
{Walkontable} wot A Walkontable instance.\n   * @returns {boolean} `true`: \
The coordinates are valid.\n   */\n  isValid(wot) {\n    if (this.row < 0 || \
this.col < 0) {\n      return false;\n    }\n    if (this.row >= \
wot.getSetting(\"totalRows\") || this.col >= \
wot.getSetting(\"totalColumns\")) {\n      return false;\n    }\n    return \
true;\n  }\n  /**\n   * Checks if another set of coordinates (`cellCoords`)\n \
  * is equal to the coordinates in your `CellCoords` instance.\n   *\n   * \
@param {CellCoords} cellCoords Coordinates to check.\n   * @returns \
{boolean}\n   */\n  isEqual(cellCoords) {\n    if (cellCoords === this) {\n   \
   return true;\n    }\n    return this.row === cellCoords.row && this.col \
=== cellCoords.col;\n  }\n  /**\n   * Checks if another set of coordinates \
(`testedCoords`)\n   * is south-east of the coordinates in your `CellCoords` \
instance.\n   *\n   * @param {CellCoords} testedCoords Coordinates to \
check.\n   * @returns {boolean}\n   */\n  isSouthEastOf(testedCoords) {\n    \
return this.row >= testedCoords.row && (_classPrivateFieldGet(this, _isRtl) ? \
this.col <= testedCoords.col : this.col >= testedCoords.col);\n  }\n  /**\n   \
* Checks if another set of coordinates (`testedCoords`)\n   * is north-west \
of the coordinates in your `CellCoords` instance.\n   *\n   * @param \
{CellCoords} testedCoords Coordinates to check.\n   * @returns {boolean}\n   \
*/\n  isNorthWestOf(testedCoords) {\n    return this.row <= testedCoords.row \
&& (_classPrivateFieldGet(this, _isRtl) ? this.col >= testedCoords.col : \
this.col <= testedCoords.col);\n  }\n  /**\n   * Checks if another set of \
coordinates (`testedCoords`)\n   * is south-west of the coordinates in your \
`CellCoords` instance.\n   *\n   * @param {CellCoords} testedCoords \
Coordinates to check.\n   * @returns {boolean}\n   */\n  \
isSouthWestOf(testedCoords) {\n    return this.row >= testedCoords.row && \
(_classPrivateFieldGet(this, _isRtl) ? this.col >= testedCoords.col : \
this.col <= testedCoords.col);\n  }\n  /**\n   * Checks if another set of \
coordinates (`testedCoords`)\n   * is north-east of the coordinates in your \
`CellCoords` instance.\n   *\n   * @param {CellCoords} testedCoords \
Coordinates to check.\n   * @returns {boolean}\n   */\n  \
isNorthEastOf(testedCoords) {\n    return this.row <= testedCoords.row && \
(_classPrivateFieldGet(this, _isRtl) ? this.col <= testedCoords.col : \
this.col >= testedCoords.col);\n  }\n  /**\n   * Normalizes the coordinates \
in your `CellCoords` instance to the nearest valid position.\n   *\n   * \
Coordinates that point to headers (negative values) are normalized to `0`.\n  \
 *\n   * @returns {CellCoords}\n   */\n  normalize() {\n    this.row = \
this.row === null ? this.row : Math.max(this.row, 0);\n    this.col = \
this.col === null ? this.col : Math.max(this.col, 0);\n    return this;\n  \
}\n  /**\n   * Clones your `CellCoords` instance.\n   *\n   * @returns \
{CellCoords}\n   */\n  clone() {\n    return new _CellCoords(this.row, \
this.col, _classPrivateFieldGet(this, _isRtl));\n  }\n  /**\n   * Converts \
your `CellCoords` instance into an object literal with `row` and `col` \
properties.\n   *\n   * @returns {{row: number, col: number}} An object \
literal with `row` and `col` properties.\n   */\n  toObject() {\n    return \
{\n      row: this.row,\n      col: this.col\n    };\n  }\n};\nvar \
coords_default = CellCoords;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/cell/range.mjs\nfunction \
_classPrivateFieldInitSpec2(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration2(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration2(obj, privateCollection) {\n  \
if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_defineProperty2(obj, key, value) {\n  key = _toPropertyKey2(key);\n  if (key \
in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: true, \
configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  \
}\n  return obj;\n}\nfunction _toPropertyKey2(arg) {\n  var key = \
_toPrimitive2(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive2(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nfunction _classPrivateFieldGet2(receiver, privateMap) {\n \
 var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, \
\"get\");\n  return _classApplyDescriptorGet2(receiver, \
descriptor);\n}\nfunction _classApplyDescriptorGet2(receiver, descriptor) {\n \
 if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  \
return descriptor.value;\n}\nfunction _classPrivateFieldSet2(receiver, \
privateMap, value) {\n  var descriptor = \
_classExtractFieldDescriptor2(receiver, privateMap, \"set\");\n  \
_classApplyDescriptorSet2(receiver, descriptor, value);\n  return \
value;\n}\nfunction _classExtractFieldDescriptor2(receiver, privateMap, \
action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorSet2(receiver, descriptor, value) {\n  if \
(descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n   \
 if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set \
read only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\nvar _isRtl2 = /* @__PURE__ */ new WeakMap();\nvar CellRange = class \
_CellRange {\n  constructor(highlight) {\n    let from = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : highlight;\n    let to = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : highlight;\n \
   let isRtl = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] \
: false;\n    _defineProperty2(this, \"highlight\", null);\n    \
_defineProperty2(this, \"from\", null);\n    _defineProperty2(this, \"to\", \
null);\n    _classPrivateFieldInitSpec2(this, _isRtl2, {\n      writable: \
true,\n      value: false\n    });\n    this.highlight = \
highlight.clone().normalize();\n    this.from = from.clone();\n    this.to = \
to.clone();\n    _classPrivateFieldSet2(this, _isRtl2, isRtl);\n  }\n  /**\n  \
 * Highlights cell selection at the `coords` coordinates.\n   *\n   * @param \
{CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  \
setHighlight(coords) {\n    this.highlight = coords.clone().normalize();\n    \
return this;\n  }\n  /**\n   * Sets the `coords` coordinates as the start of \
your range.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * \
@returns {CellRange}\n   */\n  setFrom(coords) {\n    this.from = \
coords.clone();\n    return this;\n  }\n  /**\n   * Sets the `coords` \
coordinates as the end of your range.\n   *\n   * @param {CellCoords} coords \
Coordinates to use.\n   * @returns {CellRange}\n   */\n  setTo(coords) {\n    \
this.to = coords.clone();\n    return this;\n  }\n  /**\n   * Checks if the \
coordinates in your `CellRange` instance are valid\n   * in the context of a \
given Walkontable instance.\n   *\n   * See the \
[`isValid()`](@/api/cellCoords.md#isvalid) method of the \
[`CellCoords`](@/api/cellCoords.md) class.\n   *\n   * @param {Walkontable} \
wot A Walkontable instance.\n   * @returns {boolean}\n   */\n  isValid(wot) \
{\n    return this.from.isValid(wot) && this.to.isValid(wot);\n  }\n  /**\n   \
* Checks if your range is just a single cell.\n   *\n   * @returns \
{boolean}\n   */\n  isSingle() {\n    return this.from.row >= 0 && \
this.from.row === this.to.row && this.from.col >= 0 && this.from.col === \
this.to.col;\n  }\n  /**\n   * Returns the height of your range (as a number \
of rows, including row headers).\n   *\n   * @returns {number}\n   */\n  \
getOuterHeight() {\n    return Math.max(this.from.row, this.to.row) - \
Math.min(this.from.row, this.to.row) + 1;\n  }\n  /**\n   * Returns the width \
of your range (as a number of columns, including column headers).\n   *\n   * \
@returns {number}\n   */\n  getOuterWidth() {\n    return \
Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + \
1;\n  }\n  /**\n   * Returns the height of your range (as a number of rows, \
excluding row headers).\n   *\n   * @returns {number}\n   */\n  getHeight() \
{\n    if (this.from.row < 0 && this.to.row < 0) {\n      return 0;\n    }\n  \
  const fromRow = Math.max(this.from.row, 0);\n    const toRow = \
Math.max(this.to.row, 0);\n    return Math.max(fromRow, toRow) - \
Math.min(fromRow, toRow) + 1;\n  }\n  /**\n   * Returns the width of your \
range (as a number of columns, excluding column headers).\n   *\n   * \
@returns {number}\n   */\n  getWidth() {\n    if (this.from.col < 0 && \
this.to.col < 0) {\n      return 0;\n    }\n    const fromCol = \
Math.max(this.from.col, 0);\n    const toCol = Math.max(this.to.col, 0);\n    \
return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n  }\n  /**\n \
  * Returns the number of cells within your range (excluding column and row \
headers).\n   *\n   * @returns {number}\n   */\n  getCellsCount() {\n    \
return this.getWidth() * this.getHeight();\n  }\n  /**\n   * Checks if \
another set of coordinates (`cellCoords`)\n   * is within the `from` and `to` \
coordinates of your range.\n   *\n   * @param {CellCoords} cellCoords \
Coordinates to check.\n   * @returns {boolean}\n   */\n  includes(cellCoords) \
{\n    const {\n      row,\n      col\n    } = cellCoords;\n    const \
topStart = this.getOuterTopStartCorner();\n    const bottomEnd = \
this.getOuterBottomEndCorner();\n    return topStart.row <= row && \
bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;\n  }\n  \
/**\n   * Checks if another range (`cellRange`) is within your range.\n   *\n \
  * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n \
  */\n  includesRange(cellRange) {\n    return \
this.includes(cellRange.getOuterTopStartCorner()) && \
this.includes(cellRange.getOuterBottomEndCorner());\n  }\n  /**\n   * Checks \
if another range (`cellRange`) is equal to your range.\n   *\n   * @param \
{CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  \
isEqual(cellRange) {\n    return Math.min(this.from.row, this.to.row) === \
Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, \
this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && \
Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, \
cellRange.to.col) && Math.max(this.from.col, this.to.col) === \
Math.max(cellRange.from.col, cellRange.to.col);\n  }\n  /**\n   * Checks if \
another range (`cellRange`) overlaps your range.\n   *\n   * Range A overlaps \
range B if the intersection of A and B (or B and A) is not empty.\n   *\n   * \
@param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   \
*/\n  overlaps(cellRange) {\n    return \
cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && \
cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n  }\n  /**\n   * \
Checks if another range (`cellRange`) is south-east of your range.\n   *\n   \
* @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   \
*/\n  isSouthEastOf(cellRange) {\n    return \
this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || \
this.getOuterBottomRightCorner().isSouthEastOf(cellRange);\n  }\n  /**\n   * \
Checks if another range (`cellRange`) is north-west of your range.\n   *\n   \
* @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   \
*/\n  isNorthWestOf(cellRange) {\n    return \
this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || \
this.getOuterBottomRightCorner().isNorthWestOf(cellRange);\n  }\n  /**\n   * \
Checks if another range (`cellRange`) overlaps your range horizontally.\n   \
*\n   * For example: returns `true` if the last column of your range is `5`\n \
  * and the first column of the `cellRange` range is `3`.\n   *\n   * @param \
{CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  \
isOverlappingHorizontally(cellRange) {\n    return \
this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && \
this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col \
|| this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col \
&& this.getOuterTopLeftCorner().col >= \
cellRange.getOuterTopLeftCorner().col;\n  }\n  /**\n   * Checks if another \
range (`cellRange`) overlaps your range vertically.\n   *\n   * For example: \
returns `true` if the last row of your range is `5`\n   * and the first row \
of the `cellRange` range is `3`.\n   *\n   * @param {CellRange} cellRange A \
range to check.\n   * @returns {boolean}\n   */\n  \
isOverlappingVertically(cellRange) {\n    return \
this.getOuterBottomRightCorner().row >= \
cellRange.getOuterTopRightCorner().row && \
this.getOuterBottomRightCorner().row <= \
cellRange.getOuterBottomRightCorner().row || \
this.getOuterTopRightCorner().row <= \
cellRange.getOuterBottomRightCorner().row && \
this.getOuterTopRightCorner().row >= \
cellRange.getOuterTopRightCorner().row;\n  }\n  /**\n   * Adds a cell to your \
range, at `cellCoords` coordinates.\n   *\n   * The `cellCoords` coordinates \
must exceed a corner of your range.\n   *\n   * @param {CellCoords} \
cellCoords A new cell's coordinates.\n   * @returns {boolean}\n   */\n  \
expand(cellCoords) {\n    const topStart = this.getOuterTopStartCorner();\n   \
 const bottomEnd = this.getOuterBottomEndCorner();\n    if (cellCoords.row < \
topStart.row || cellCoords.col < topStart.col || cellCoords.row > \
bottomEnd.row || cellCoords.col > bottomEnd.col) {\n      this.from = \
this._createCellCoords(Math.min(topStart.row, cellCoords.row), \
Math.min(topStart.col, cellCoords.col));\n      this.to = \
this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), \
Math.max(bottomEnd.col, cellCoords.col));\n      return true;\n    }\n    \
return false;\n  }\n  /**\n   * Expand your range with another range \
(`expandingRange`).\n   *\n   * @param {CellRange} expandingRange A new \
range.\n   * @returns {boolean}\n   */\n  expandByRange(expandingRange) {\n   \
 if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) \
{\n      return false;\n    }\n    const topStart = \
this.getOuterTopStartCorner();\n    const bottomEnd = \
this.getOuterBottomEndCorner();\n    const initialDirection = \
this.getDirection();\n    const expandingTopStart = \
expandingRange.getOuterTopStartCorner();\n    const expandingBottomEnd = \
expandingRange.getOuterBottomEndCorner();\n    const resultTopRow = \
Math.min(topStart.row, expandingTopStart.row);\n    const resultTopCol = \
Math.min(topStart.col, expandingTopStart.col);\n    const resultBottomRow = \
Math.max(bottomEnd.row, expandingBottomEnd.row);\n    const resultBottomCol = \
Math.max(bottomEnd.col, expandingBottomEnd.col);\n    const finalFrom = \
this._createCellCoords(resultTopRow, resultTopCol);\n    const finalTo = \
this._createCellCoords(resultBottomRow, resultBottomCol);\n    this.from = \
finalFrom;\n    this.to = finalTo;\n    \
this.setDirection(initialDirection);\n    if (this.highlight.row === \
this.getOuterBottomRightCorner().row && this.getVerticalDirection() === \
\"N-S\") {\n      this.flipDirectionVertically();\n    }\n    if \
(this.highlight.col === this.getOuterTopRightCorner().col && \
this.getHorizontalDirection() === \"W-E\") {\n      \
this.flipDirectionHorizontally();\n    }\n    return true;\n  }\n  /**\n   * \
Gets the direction of the selection.\n   *\n   * @returns {string} Returns \
one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n   */\n  \
getDirection() {\n    if (this.from.isNorthWestOf(this.to)) {\n      return \
\"NW-SE\";\n    } else if (this.from.isNorthEastOf(this.to)) {\n      return \
\"NE-SW\";\n    } else if (this.from.isSouthEastOf(this.to)) {\n      return \
\"SE-NW\";\n    } else if (this.from.isSouthWestOf(this.to)) {\n      return \
\"SW-NE\";\n    }\n  }\n  /**\n   * Sets the direction of the selection.\n   \
*\n   * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, \
`'SE-NW'`, `'SW-NE'`.\n   */\n  setDirection(direction) {\n    switch \
(direction) {\n      case \"NW-SE\":\n        [this.from, this.to] = \
[this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n        \
break;\n      case \"NE-SW\":\n        [this.from, this.to] = \
[this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n        \
break;\n      case \"SE-NW\":\n        [this.from, this.to] = \
[this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n        \
break;\n      case \"SW-NE\":\n        [this.from, this.to] = \
[this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n        \
break;\n      default:\n        break;\n    }\n  }\n  /**\n   * Gets the \
vertical direction of the selection.\n   *\n   * @returns {string} Returns \
one of the values: `N-S` (north->south), `S-N` (south->north).\n   */\n  \
getVerticalDirection() {\n    return [\"NE-SW\", \
\"NW-SE\"].indexOf(this.getDirection()) > -1 ? \"N-S\" : \"S-N\";\n  }\n  \
/**\n   * Gets the horizontal direction of the selection.\n   *\n   * \
@returns {string} Returns one of the values: `W-E` (west->east), `E-W` \
(east->west).\n   */\n  getHorizontalDirection() {\n    return [\"NW-SE\", \
\"SW-NE\"].indexOf(this.getDirection()) > -1 ? \"W-E\" : \"E-W\";\n  }\n  \
/**\n   * Flips the direction of your range vertically (e.g., `NW-SE` changes \
to `SW-NE`).\n   */\n  flipDirectionVertically() {\n    const direction = \
this.getDirection();\n    switch (direction) {\n      case \"NW-SE\":\n       \
 this.setDirection(\"SW-NE\");\n        break;\n      case \"NE-SW\":\n       \
 this.setDirection(\"SE-NW\");\n        break;\n      case \"SE-NW\":\n       \
 this.setDirection(\"NE-SW\");\n        break;\n      case \"SW-NE\":\n       \
 this.setDirection(\"NW-SE\");\n        break;\n      default:\n        \
break;\n    }\n  }\n  /**\n   * Flips the direction of your range \
horizontally (e.g., `NW-SE` changes to `NE-SW`).\n   */\n  \
flipDirectionHorizontally() {\n    const direction = this.getDirection();\n   \
 switch (direction) {\n      case \"NW-SE\":\n        \
this.setDirection(\"NE-SW\");\n        break;\n      case \"NE-SW\":\n        \
this.setDirection(\"NW-SE\");\n        break;\n      case \"SE-NW\":\n        \
this.setDirection(\"SW-NE\");\n        break;\n      case \"SW-NE\":\n        \
this.setDirection(\"SE-NW\");\n        break;\n      default:\n        \
break;\n    }\n  }\n  /**\n   * Gets the top-left (in LTR) or top-right (in \
RTL) corner coordinates of your range.\n   *\n   * If the corner contains \
header coordinates (negative values),\n   * the corner coordinates are \
normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  \
getTopStartCorner() {\n    return \
this._createCellCoords(Math.min(this.from.row, this.to.row), \
Math.min(this.from.col, this.to.col)).normalize();\n  }\n  /**\n   * Gets the \
top-left corner coordinates of your range,\n   * both in the LTR and RTL \
layout direction.\n   *\n   * If the corner contains header coordinates \
(negative values),\n   * the corner coordinates are normalized to `0`.\n   \
*\n   * @returns {CellCoords}\n   */\n  getTopLeftCorner() {\n    return \
_classPrivateFieldGet2(this, _isRtl2) ? this.getTopEndCorner() : \
this.getTopStartCorner();\n  }\n  /**\n   * Gets the bottom right (in LTR) or \
bottom left (in RTL) corner coordinates of your range.\n   *\n   * If the \
corner contains header coordinates (negative values),\n   * the corner \
coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n \
 getBottomEndCorner() {\n    return \
this._createCellCoords(Math.max(this.from.row, this.to.row), \
Math.max(this.from.col, this.to.col)).normalize();\n  }\n  /**\n   * Gets the \
bottom right corner coordinates of your range,\n   * both in the LTR and RTL \
layout direction.\n   *\n   * If the corner contains header coordinates \
(negative values),\n   * the corner coordinates are normalized to `0`.\n   \
*\n   * @returns {CellCoords}\n   */\n  getBottomRightCorner() {\n    return \
_classPrivateFieldGet2(this, _isRtl2) ? this.getBottomStartCorner() : \
this.getBottomEndCorner();\n  }\n  /**\n   * Gets the top right (in LTR) or \
top left (in RTL) corner coordinates of your range.\n   *\n   * If the corner \
contains header coordinates (negative values),\n   * the corner coordinates \
are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  \
getTopEndCorner() {\n    return \
this._createCellCoords(Math.min(this.from.row, this.to.row), \
Math.max(this.from.col, this.to.col)).normalize();\n  }\n  /**\n   * Gets the \
top right corner coordinates of your range,\n   * both in the LTR and RTL \
layout direction.\n   *\n   * If the corner contains header coordinates \
(negative values),\n   * the corner coordinates are normalized to `0`.\n   \
*\n   * @returns {CellCoords}\n   */\n  getTopRightCorner() {\n    return \
_classPrivateFieldGet2(this, _isRtl2) ? this.getTopStartCorner() : \
this.getTopEndCorner();\n  }\n  /**\n   * Gets the bottom left (in LTR) or \
bottom right (in RTL) corner coordinates of your range.\n   *\n   * If the \
corner contains header coordinates (negative values),\n   * the corner \
coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n \
 getBottomStartCorner() {\n    return \
this._createCellCoords(Math.max(this.from.row, this.to.row), \
Math.min(this.from.col, this.to.col)).normalize();\n  }\n  /**\n   * Gets the \
bottom left corner coordinates of your range,\n   * both in the LTR and RTL \
layout direction.\n   *\n   * If the corner contains header coordinates \
(negative values),\n   * the corner coordinates are normalized to `0`.\n   \
*\n   * @returns {CellCoords}\n   */\n  getBottomLeftCorner() {\n    return \
_classPrivateFieldGet2(this, _isRtl2) ? this.getBottomEndCorner() : \
this.getBottomStartCorner();\n  }\n  /**\n   * Gets the top left (in LTR) or \
top right (in RTL) corner coordinates of your range.\n   *\n   * If the \
corner contains header coordinates (negative values),\n   * the top and start \
coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   \
*/\n  getOuterTopStartCorner() {\n    return \
this._createCellCoords(Math.min(this.from.row, this.to.row), \
Math.min(this.from.col, this.to.col));\n  }\n  /**\n   * Gets the top left \
corner coordinates of your range,\n   * both in the LTR and RTL layout \
direction.\n   *\n   * If the corner contains header coordinates (negative \
values),\n   * the top and left coordinates are pointed to that header.\n   \
*\n   * @returns {CellCoords}\n   */\n  getOuterTopLeftCorner() {\n    return \
_classPrivateFieldGet2(this, _isRtl2) ? this.getOuterTopEndCorner() : \
this.getOuterTopStartCorner();\n  }\n  /**\n   * Gets the bottom right (in \
LTR) or bottom left (in RTL) corner coordinates of your range.\n   *\n   * If \
the corner contains header coordinates (negative values),\n   * the top and \
start coordinates are pointed to that header.\n   *\n   * @returns \
{CellCoords}\n   */\n  getOuterBottomEndCorner() {\n    return \
this._createCellCoords(Math.max(this.from.row, this.to.row), \
Math.max(this.from.col, this.to.col));\n  }\n  /**\n   * Gets the bottom \
right corner coordinates of your range,\n   * both in the LTR and RTL layout \
direction.\n   *\n   * If the corner contains header coordinates (negative \
values),\n   * the top and left coordinates are pointed to that header.\n   \
*\n   * @returns {CellCoords}\n   */\n  getOuterBottomRightCorner() {\n    \
return _classPrivateFieldGet2(this, _isRtl2) ? \
this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();\n  }\n  \
/**\n   * Gets the top right (in LTR) or top left (in RTL) corner coordinates \
of your range.\n   *\n   * If the corner contains header coordinates \
(negative values),\n   * the top and start coordinates are pointed to that \
header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopEndCorner() \
{\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), \
Math.max(this.from.col, this.to.col));\n  }\n  /**\n   * Gets the top right \
corner coordinates of your range,\n   * both in the LTR and RTL layout \
direction.\n   *\n   * If the corner contains header coordinates (negative \
values),\n   * the top and left coordinates are pointed to that header.\n   \
*\n   * @returns {CellCoords}\n   */\n  getOuterTopRightCorner() {\n    \
return _classPrivateFieldGet2(this, _isRtl2) ? this.getOuterTopStartCorner() \
: this.getOuterTopEndCorner();\n  }\n  /**\n   * Gets the bottom left (in \
LTR) or bottom right (in RTL) corner coordinates of your range.\n   *\n   * \
If the corner contains header coordinates (negative values),\n   * the top \
and start coordinates are pointed to that header.\n   *\n   * @returns \
{CellCoords}\n   */\n  getOuterBottomStartCorner() {\n    return \
this._createCellCoords(Math.max(this.from.row, this.to.row), \
Math.min(this.from.col, this.to.col));\n  }\n  /**\n   * Gets the bottom left \
corner coordinates of your range,\n   * both in the LTR and RTL layout \
direction.\n   *\n   * If the corner contains header coordinates (negative \
values),\n   * the top and left coordinates are pointed to that header.\n   \
*\n   * @returns {CellCoords}\n   */\n  getOuterBottomLeftCorner() {\n    \
return _classPrivateFieldGet2(this, _isRtl2) ? this.getOuterBottomEndCorner() \
: this.getOuterBottomStartCorner();\n  }\n  /**\n   * Checks if a set of \
coordinates (`coords`) matches one of the 4 corners of your range.\n   *\n   \
* @param {CellCoords} coords Coordinates to check.\n   * @param {CellRange} \
[expandedRange] A range to compare with.\n   * @returns {boolean}\n   */\n  \
isCorner(coords, expandedRange) {\n    if (expandedRange && \
expandedRange.includes(coords) && \
(this.getOuterTopLeftCorner().isEqual(this._createCellCoords(expandedRange.fr\
om.row, expandedRange.from.col)) || \
this.getOuterTopRightCorner().isEqual(this._createCellCoords(expandedRange.fr\
om.row, expandedRange.to.col)) || \
this.getOuterBottomLeftCorner().isEqual(this._createCellCoords(expandedRange.\
to.row, expandedRange.from.col)) || \
this.getOuterBottomRightCorner().isEqual(this._createCellCoords(expandedRange\
.to.row, expandedRange.to.col)))) {\n      return true;\n    }\n    return \
coords.isEqual(this.getOuterTopLeftCorner()) || \
coords.isEqual(this.getOuterTopRightCorner()) || \
coords.isEqual(this.getOuterBottomLeftCorner()) || \
coords.isEqual(this.getOuterBottomRightCorner());\n  }\n  /**\n   * Gets the \
coordinates of a range corner opposite to the provided `coords`.\n   *\n   * \
For example: if the `coords` coordinates match the bottom-right corner of \
your range,\n   * the coordinates of the top-left corner of your range are \
returned.\n   *\n   * @param {CellCoords} coords Coordinates to check.\n   * \
@param {CellRange} [expandedRange] A range to compare with.\n   * @returns \
{CellCoords}\n   */\n  getOppositeCorner(coords, expandedRange) {\n    if \
(!(coords instanceof coords_default)) {\n      return false;\n    }\n    if \
(expandedRange) {\n      const {\n        from,\n        to\n      } = \
expandedRange;\n      if (expandedRange.includes(coords)) {\n        if \
(this.getOuterTopStartCorner().isEqual(this._createCellCoords(from.row, \
from.col))) {\n          return this.getOuterBottomEndCorner();\n        }\n  \
      if \
(this.getOuterTopEndCorner().isEqual(this._createCellCoords(from.row, \
to.col))) {\n          return this.getOuterBottomStartCorner();\n        }\n  \
      if \
(this.getOuterBottomStartCorner().isEqual(this._createCellCoords(to.row, \
from.col))) {\n          return this.getOuterTopEndCorner();\n        }\n     \
   if (this.getOuterBottomEndCorner().isEqual(this._createCellCoords(to.row, \
to.col))) {\n          return this.getOuterTopStartCorner();\n        }\n     \
 }\n    }\n    if (coords.isEqual(this.getOuterBottomEndCorner())) {\n      \
return this.getOuterTopStartCorner();\n    } else if \
(coords.isEqual(this.getOuterTopStartCorner())) {\n      return \
this.getOuterBottomEndCorner();\n    } else if \
(coords.isEqual(this.getOuterTopEndCorner())) {\n      return \
this.getOuterBottomStartCorner();\n    } else if \
(coords.isEqual(this.getOuterBottomStartCorner())) {\n      return \
this.getOuterTopEndCorner();\n    }\n  }\n  /**\n   * Indicates which borders \
(top, right, bottom, left) are shared between\n   * your `CellRange`instance \
and another `range` that's within your range.\n   *\n   * @param {CellRange} \
range A range to compare with.\n   * @returns {Array<'top' | 'right' | \
'bottom' | 'left'>}\n   */\n  getBordersSharedWith(range) {\n    if \
(!this.includesRange(range)) {\n      return [];\n    }\n    const \
thisBorders = {\n      top: Math.min(this.from.row, this.to.row),\n      \
bottom: Math.max(this.from.row, this.to.row),\n      left: \
Math.min(this.from.col, this.to.col),\n      right: Math.max(this.from.col, \
this.to.col)\n    };\n    const rangeBorders = {\n      top: \
Math.min(range.from.row, range.to.row),\n      bottom: \
Math.max(range.from.row, range.to.row),\n      left: Math.min(range.from.col, \
range.to.col),\n      right: Math.max(range.from.col, range.to.col)\n    };\n \
   const result = [];\n    if (thisBorders.top === rangeBorders.top) {\n      \
result.push(\"top\");\n    }\n    if (thisBorders.right === \
rangeBorders.right) {\n      result.push(\"right\");\n    }\n    if \
(thisBorders.bottom === rangeBorders.bottom) {\n      \
result.push(\"bottom\");\n    }\n    if (thisBorders.left === \
rangeBorders.left) {\n      result.push(\"left\");\n    }\n    return \
result;\n  }\n  /**\n   * Gets the coordinates of the inner cells of your \
range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getInner() {\n    const \
topStart = this.getOuterTopStartCorner();\n    const bottomEnd = \
this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = \
topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c \
<= bottomEnd.col; c++) {\n        if (!(this.from.row === r && this.from.col \
=== c) && !(this.to.row === r && this.to.col === c)) {\n          \
out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n    \
return out;\n  }\n  /**\n   * Gets the coordinates of all cells of your \
range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getAll() {\n    const \
topStart = this.getOuterTopStartCorner();\n    const bottomEnd = \
this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = \
topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c \
<= bottomEnd.col; c++) {\n        if (topStart.row === r && topStart.col === \
c) {\n          out.push(topStart);\n        } else if (bottomEnd.row === r \
&& bottomEnd.col === c) {\n          out.push(bottomEnd);\n        } else {\n \
         out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n \
   return out;\n  }\n  /**\n   * Runs a callback function on all cells within \
your range.\n   *\n   * You can break the iteration by returning `false` in \
the callback function.\n   *\n   * @param {function(number, number): boolean} \
callback A callback function.\n   */\n  forAll(callback) {\n    const \
topStart = this.getOuterTopStartCorner();\n    const bottomEnd = \
this.getOuterBottomEndCorner();\n    for (let r = topStart.row; r <= \
bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; \
c++) {\n        const breakIteration = callback(r, c);\n        if \
(breakIteration === false) {\n          return;\n        }\n      }\n    }\n  \
}\n  /**\n   * Clones your `CellRange` instance.\n   *\n   * @returns \
{CellRange}\n   */\n  clone() {\n    return new _CellRange(this.highlight, \
this.from, this.to, _classPrivateFieldGet2(this, _isRtl2));\n  }\n  /**\n   * \
Converts your `CellRange` instance into an object literal with the following \
properties:\n   *\n   * - `from`\n   *    - `row`\n   *    - `col`\n   * - \
`to`\n   *    - `row`\n   *    - `col`\n   *\n   * @returns {{from: {row: \
number, col: number}, to: {row: number, col: number}}} An object literal with \
`from` and `to` properties.\n   */\n  toObject() {\n    return {\n      from: \
this.from.toObject(),\n      to: this.to.toObject()\n    };\n  }\n  /**\n   * \
Creates and returns a new instance of the `CellCoords` class.\n   *\n   * The \
new `CellCoords` instance automatically inherits the LTR/RTL flag\n   * from \
your `CellRange` instance.\n   *\n   * @private\n   * @param {number} row A \
row index.\n   * @param {number} column A column index.\n   * @returns \
{CellCoords}\n   */\n  _createCellCoords(row, column) {\n    return new \
coords_default(row, column, _classPrivateFieldGet2(this, _isRtl2));\n  \
}\n};\nvar range_default = CellRange;\n\n// \
node_modules/handsontable/helpers/feature.mjs\nvar feature_exports = \
{};\n__export(feature_exports, {\n  cancelAnimationFrame: () => \
cancelAnimationFrame,\n  getComparisonFunction: () => \
getComparisonFunction,\n  isTouchSupported: () => isTouchSupported,\n  \
requestAnimationFrame: () => requestAnimationFrame\n});\nfunction \
requestAnimationFrame(callback) {\n  return \
window.requestAnimationFrame(callback);\n}\nfunction cancelAnimationFrame(id) \
{\n  window.cancelAnimationFrame(id);\n}\nfunction isTouchSupported() {\n  \
return \"ontouchstart\" in window;\n}\nvar comparisonFunction;\nfunction \
getComparisonFunction(language) {\n  let options = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : {};\n  if (comparisonFunction) {\n   \
 return comparisonFunction;\n  }\n  if (typeof Intl === \"object\") {\n    \
comparisonFunction = new Intl.Collator(language, options).compare;\n  } else \
if (typeof String.prototype.localeCompare === \"function\") {\n    \
comparisonFunction = (a, b) => `${a}`.localeCompare(b);\n  } else {\n    \
comparisonFunction = (a, b) => {\n      if (a === b) {\n        return 0;\n   \
   }\n      return a > b ? -1 : 1;\n    };\n  }\n  return \
comparisonFunction;\n}\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/event.mjs\nvar \
privatePool3 = /* @__PURE__ */ new WeakMap();\nvar Event2 = class {\n  /**\n  \
 * @param {FacadeGetter} facadeGetter Gets an instance facade.\n   * @param \
{DomBindings} domBindings Bindings into dom.\n   * @param {Settings} \
wtSettings The walkontable settings.\n   * @param {EventManager} eventManager \
The walkontable event manager.\n   * @param {Table} wtTable The table.\n   * \
@param {Selections} selections Selections.\n   * @param {Event} [parent=null] \
The main Event instance.\n   */\n  constructor(facadeGetter, domBindings, \
wtSettings, eventManager, wtTable, selections) {\n    let parent2 = \
arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;\n    \
this.wtSettings = wtSettings;\n    this.domBindings = domBindings;\n    \
this.wtTable = wtTable;\n    this.selections = selections;\n    this.parent = \
parent2;\n    this.eventManager = eventManager;\n    this.facadeGetter = \
facadeGetter;\n    privatePool3.set(this, {\n      \
selectedCellBeforeTouchEnd: void 0,\n      dblClickTimeout: [null, null],\n   \
   dblClickOrigin: [null, null]\n    });\n    this.registerEvents();\n  }\n  \
/**\n   * Adds listeners for mouse and touch events.\n   *\n   * @private\n   \
*/\n  registerEvents() {\n    \
this.eventManager.addEventListener(this.wtTable.holder, \"contextmenu\", \
(event2) => this.onContextMenu(event2));\n    \
this.eventManager.addEventListener(this.wtTable.TABLE, \"mouseover\", \
(event2) => this.onMouseOver(event2));\n    \
this.eventManager.addEventListener(this.wtTable.TABLE, \"mouseout\", (event2) \
=> this.onMouseOut(event2));\n    const initTouchEvents = () => {\n      \
this.eventManager.addEventListener(this.wtTable.holder, \"touchstart\", \
(event2) => this.onTouchStart(event2));\n      \
this.eventManager.addEventListener(this.wtTable.holder, \"touchend\", \
(event2) => this.onTouchEnd(event2));\n      if (!this.momentumScrolling) {\n \
       this.momentumScrolling = {};\n      }\n      \
this.eventManager.addEventListener(this.wtTable.holder, \"scroll\", () => {\n \
       clearTimeout(this.momentumScrolling._timeout);\n        if \
(!this.momentumScrolling.ongoing) {\n          \
this.wtSettings.getSetting(\"onBeforeTouchScroll\");\n        }\n        \
this.momentumScrolling.ongoing = true;\n        \
this.momentumScrolling._timeout = setTimeout(() => {\n          if \
(!this.touchApplied) {\n            this.momentumScrolling.ongoing = false;\n \
           this.wtSettings.getSetting(\"onAfterMomentumScroll\");\n          \
}\n        }, 200);\n      });\n    };\n    const initMouseEvents = () => {\n \
     this.eventManager.addEventListener(this.wtTable.holder, \"mouseup\", \
(event2) => this.onMouseUp(event2));\n      \
this.eventManager.addEventListener(this.wtTable.holder, \"mousedown\", \
(event2) => this.onMouseDown(event2));\n    };\n    if (isMobileBrowser()) \
{\n      initTouchEvents();\n    } else {\n      if (isTouchSupported()) {\n  \
      initTouchEvents();\n      }\n      initMouseEvents();\n    }\n  }\n  \
/**\n   * Checks if an element is already selected.\n   *\n   * @private\n   \
* @param {Element} touchTarget An element to check.\n   * @returns \
{boolean}\n   */\n  selectedCellWasTouched(touchTarget) {\n    const priv = \
privatePool3.get(this);\n    const cellUnderFinger = \
this.parentCell(touchTarget);\n    const coordsOfCellUnderFinger = \
cellUnderFinger.coords;\n    if (priv.selectedCellBeforeTouchEnd && \
coordsOfCellUnderFinger) {\n      const [rowTouched, rowSelected] = \
[coordsOfCellUnderFinger.row, priv.selectedCellBeforeTouchEnd.from.row];\n    \
  const [colTouched, colSelected] = [coordsOfCellUnderFinger.col, \
priv.selectedCellBeforeTouchEnd.from.col];\n      return rowTouched === \
rowSelected && colTouched === colSelected;\n    }\n    return false;\n  }\n  \
/**\n   * Gets closest TD or TH element.\n   *\n   * @private\n   * @param \
{Element} elem An element from the traversing starts.\n   * @returns {object} \
Contains coordinates and reference to TD or TH if it exists. Otherwise it's \
empty object.\n   */\n  parentCell(elem) {\n    const cell = {};\n    const \
TABLE = this.wtTable.TABLE;\n    const TD = closestDown(elem, [\"TD\", \
\"TH\"], TABLE);\n    if (TD) {\n      cell.coords = \
this.wtTable.getCoords(TD);\n      cell.TD = TD;\n    } else if \
(hasClass(elem, \"wtBorder\") && hasClass(elem, \"current\")) {\n      \
cell.coords = this.selections.getCell().cellRange.highlight;\n      cell.TD = \
this.wtTable.getCell(cell.coords);\n    } else if (hasClass(elem, \
\"wtBorder\") && hasClass(elem, \"area\")) {\n      if \
(this.selections.createOrGetArea().cellRange) {\n        cell.coords = \
this.selections.createOrGetArea().cellRange.to;\n        cell.TD = \
this.wtTable.getCell(cell.coords);\n      }\n    }\n    return cell;\n  }\n  \
/**\n   * OnMouseDown callback.\n   *\n   * @private\n   * @param \
{MouseEvent} event The mouse event object.\n   */\n  onMouseDown(event2) {\n  \
  const priv = privatePool3.get(this);\n    const activeElement = \
this.domBindings.rootDocument.activeElement;\n    const getParentNode = \
partial(getParent, event2.target);\n    const realTarget = event2.target;\n   \
 if (realTarget === activeElement || getParentNode(0) === activeElement || \
getParentNode(1) === activeElement) {\n      return;\n    }\n    const cell = \
this.parentCell(realTarget);\n    if (hasClass(realTarget, \"corner\")) {\n   \
   this.wtSettings.getSetting(\"onCellCornerMouseDown\", event2, \
realTarget);\n    } else if (cell.TD && \
this.wtSettings.has(\"onCellMouseDown\")) {\n      \
this.callListener(\"onCellMouseDown\", event2, cell.coords, cell.TD);\n    \
}\n    if ((event2.button === 0 || this.touchApplied) && cell.TD) {\n      \
priv.dblClickOrigin[0] = cell.TD;\n      \
clearTimeout(priv.dblClickTimeout[0]);\n      priv.dblClickTimeout[0] = \
setTimeout(() => {\n        priv.dblClickOrigin[0] = null;\n      }, 1e3);\n  \
  }\n  }\n  /**\n   * OnContextMenu callback.\n   *\n   * @private\n   * \
@param {MouseEvent} event The mouse event object.\n   */\n  \
onContextMenu(event2) {\n    if (this.wtSettings.has(\"onCellContextMenu\")) \
{\n      const cell = this.parentCell(event2.target);\n      if (cell.TD) {\n \
       this.callListener(\"onCellContextMenu\", event2, cell.coords, \
cell.TD);\n      }\n    }\n  }\n  /**\n   * OnMouseOver callback.\n   *\n   * \
@private\n   * @param {MouseEvent} event The mouse event object.\n   */\n  \
onMouseOver(event2) {\n    if (!this.wtSettings.has(\"onCellMouseOver\")) {\n \
     return;\n    }\n    const table = this.wtTable.TABLE;\n    const td = \
closestDown(event2.target, [\"TD\", \"TH\"], table);\n    const parent2 = \
this.parent || this;\n    if (td && td !== parent2.lastMouseOver && \
isChildOf(td, table)) {\n      parent2.lastMouseOver = td;\n      \
this.callListener(\"onCellMouseOver\", event2, this.wtTable.getCoords(td), \
td);\n    }\n  }\n  /**\n   * OnMouseOut callback.\n   *\n   * @private\n   * \
@param {MouseEvent} event The mouse event object.\n   */\n  \
onMouseOut(event2) {\n    if (!this.wtSettings.has(\"onCellMouseOut\")) {\n   \
   return;\n    }\n    const table = this.wtTable.TABLE;\n    const lastTD = \
closestDown(event2.target, [\"TD\", \"TH\"], table);\n    const nextTD = \
closestDown(event2.relatedTarget, [\"TD\", \"TH\"], table);\n    const \
parent2 = this.parent || this;\n    if (lastTD && lastTD !== nextTD && \
isChildOf(lastTD, table)) {\n      this.callListener(\"onCellMouseOut\", \
event2, this.wtTable.getCoords(lastTD), lastTD);\n      if (nextTD === null) \
{\n        parent2.lastMouseOver = null;\n      }\n    }\n  }\n  /**\n   * \
OnMouseUp callback.\n   *\n   * @private\n   * @param {MouseEvent} event The \
mouse event object.\n   */\n  onMouseUp(event2) {\n    const priv = \
privatePool3.get(this);\n    const cell = this.parentCell(event2.target);\n   \
 if (cell.TD && this.wtSettings.has(\"onCellMouseUp\")) {\n      \
this.callListener(\"onCellMouseUp\", event2, cell.coords, cell.TD);\n    }\n  \
  if (event2.button !== 0 && !this.touchApplied) {\n      return;\n    }\n    \
if (cell.TD === priv.dblClickOrigin[0] && cell.TD === priv.dblClickOrigin[1]) \
{\n      if (hasClass(event2.target, \"corner\")) {\n        \
this.callListener(\"onCellCornerDblClick\", event2, cell.coords, cell.TD);\n  \
    } else {\n        this.callListener(\"onCellDblClick\", event2, \
cell.coords, cell.TD);\n      }\n      priv.dblClickOrigin[0] = null;\n      \
priv.dblClickOrigin[1] = null;\n    } else if (cell.TD === \
priv.dblClickOrigin[0]) {\n      priv.dblClickOrigin[1] = cell.TD;\n      \
clearTimeout(priv.dblClickTimeout[1]);\n      priv.dblClickTimeout[1] = \
setTimeout(() => {\n        priv.dblClickOrigin[1] = null;\n      }, 500);\n  \
  }\n  }\n  /**\n   * OnTouchStart callback. Simulates mousedown event.\n   \
*\n   * @private\n   * @param {MouseEvent} event The mouse event object.\n   \
*/\n  onTouchStart(event2) {\n    const priv = privatePool3.get(this);\n    \
priv.selectedCellBeforeTouchEnd = this.selections.getCell().cellRange;\n    \
this.touchApplied = true;\n    this.onMouseDown(event2);\n  }\n  /**\n   * \
OnTouchEnd callback. Simulates mouseup event.\n   *\n   * @private\n   * \
@param {MouseEvent} event The mouse event object.\n   */\n  \
onTouchEnd(event2) {\n    var _this$parentCell;\n    const target = \
event2.target;\n    const parentCellCoords = (_this$parentCell = \
this.parentCell(target)) === null || _this$parentCell === void 0 ? void 0 : \
_this$parentCell.coords;\n    const isCellsRange = \
isDefined(parentCellCoords) && parentCellCoords.row >= 0 && \
parentCellCoords.col >= 0;\n    const isEventCancelable = event2.cancelable \
&& isCellsRange && this.wtSettings.getSetting(\"isDataViewInstance\");\n    \
if (isEventCancelable) {\n      const interactiveElements = [\"A\", \
\"BUTTON\", \"INPUT\"];\n      if (isIOS() && (isChromeWebKit() || \
isFirefoxWebKit()) && this.selectedCellWasTouched(target) && \
!interactiveElements.includes(target.tagName)) {\n        \
event2.preventDefault();\n      } else if \
(!this.selectedCellWasTouched(target)) {\n        event2.preventDefault();\n  \
    }\n    }\n    this.onMouseUp(event2);\n    this.touchApplied = false;\n  \
}\n  /**\n   * Call listener with backward compatibility.\n   *\n   * \
@private\n   * @param {string} name Name of listener.\n   * @param \
{MouseEvent} event The event object.\n   * @param {CellCoords} coords \
Coordinates.\n   * @param {HTMLElement} target Event target.\n   */\n  \
callListener(name, event2, coords, target) {\n    const listener = \
this.wtSettings.getSettingPure(name);\n    if (listener) {\n      \
listener(event2, coords, target, this.facadeGetter());\n    }\n  }\n  /**\n   \
* Clears double-click timeouts and destroys the internal eventManager \
instance.\n   */\n  destroy() {\n    const priv = privatePool3.get(this);\n   \
 clearTimeout(priv.dblClickTimeout[0]);\n    \
clearTimeout(priv.dblClickTimeout[1]);\n    this.eventManager.destroy();\n  \
}\n};\nvar event_default = Event2;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/filter/column.mjs\nvar \
ColumnFilter = class {\n  /**\n   * @param {number} offset The scroll \
horizontal offset.\n   * @param {number} total The total width of the \
table.\n   * @param {number} countTH The number of rendered row headers.\n   \
*/\n  constructor(offset3, total, countTH) {\n    this.offset = offset3;\n    \
this.total = total;\n    this.countTH = countTH;\n  }\n  /**\n   * @param \
{number} index The visual column index.\n   * @returns {number}\n   */\n  \
offsetted(index2) {\n    return index2 + this.offset;\n  }\n  /**\n   * \
@param {number} index The visual column index.\n   * @returns {number}\n   \
*/\n  unOffsetted(index2) {\n    return index2 - this.offset;\n  }\n  /**\n   \
* @param {number} index The visual column index.\n   * @returns {number}\n   \
*/\n  renderedToSource(index2) {\n    return this.offsetted(index2);\n  }\n  \
/**\n   * @param {number} index The visual column index.\n   * @returns \
{number}\n   */\n  sourceToRendered(index2) {\n    return \
this.unOffsetted(index2);\n  }\n  /**\n   * @param {number} index The visual \
column index.\n   * @returns {number}\n   */\n  offsettedTH(index2) {\n    \
return index2 - this.countTH;\n  }\n  /**\n   * @param {number} index The \
visual column index.\n   * @returns {number}\n   */\n  unOffsettedTH(index2) \
{\n    return index2 + this.countTH;\n  }\n  /**\n   * @param {number} index \
The visual column index.\n   * @returns {number}\n   */\n  \
visibleRowHeadedColumnToSourceColumn(index2) {\n    return \
this.renderedToSource(this.offsettedTH(index2));\n  }\n  /**\n   * @param \
{number} index The visual column index.\n   * @returns {number}\n   */\n  \
sourceColumnToVisibleRowHeadedColumn(index2) {\n    return \
this.unOffsettedTH(this.sourceToRendered(index2));\n  }\n};\nvar \
column_default = ColumnFilter;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/filter/row.mjs\nvar \
RowFilter = class {\n  /**\n   * @param {number} offset The scroll vertical \
offset.\n   * @param {number} total The total height of the table.\n   * \
@param {number} countTH The number of rendered column headers.\n   */\n  \
constructor(offset3, total, countTH) {\n    this.offset = offset3;\n    \
this.total = total;\n    this.countTH = countTH;\n  }\n  /**\n   * @param \
{number} index The visual row index.\n   * @returns {number}\n   */\n  \
offsetted(index2) {\n    return index2 + this.offset;\n  }\n  /**\n   * \
@param {number} index The visual row index.\n   * @returns {number}\n   */\n  \
unOffsetted(index2) {\n    return index2 - this.offset;\n  }\n  /**\n   * \
@param {number} index The visual row index.\n   * @returns {number}\n   */\n  \
renderedToSource(index2) {\n    return this.offsetted(index2);\n  }\n  /**\n  \
 * @param {number} index The visual row index.\n   * @returns {number}\n   \
*/\n  sourceToRendered(index2) {\n    return this.unOffsetted(index2);\n  }\n \
 /**\n   * @param {number} index The visual row index.\n   * @returns \
{number}\n   */\n  offsettedTH(index2) {\n    return index2 - this.countTH;\n \
 }\n  /**\n   * @param {number} index The visual row index.\n   * @returns \
{number}\n   */\n  unOffsettedTH(index2) {\n    return index2 + \
this.countTH;\n  }\n  /**\n   * @param {number} index The visual row index.\n \
  * @returns {number}\n   */\n  visibleColHeadedRowToSourceRow(index2) {\n    \
return this.renderedToSource(this.offsettedTH(index2));\n  }\n  /**\n   * \
@param {number} index The visual row index.\n   * @returns {number}\n   */\n  \
sourceRowToVisibleColHeadedRow(index2) {\n    return \
this.unOffsettedTH(this.sourceToRendered(index2));\n  }\n};\nvar row_default \
= RowFilter;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/constants.\
mjs\nvar WORKING_SPACE_ALL = 0;\nvar WORKING_SPACE_TOP = 1;\nvar \
WORKING_SPACE_BOTTOM = 2;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/viewSize.m\
js\nvar ViewSize = class {\n  constructor() {\n    this.currentSize = 0;\n    \
this.nextSize = 0;\n    this.currentOffset = 0;\n    this.nextOffset = 0;\n  \
}\n  /**\n   * Sets new size of the rendered DOM elements.\n   *\n   * @param \
{number} size The size.\n   */\n  setSize(size) {\n    this.currentSize = \
this.nextSize;\n    this.nextSize = size;\n  }\n  /**\n   * Sets new \
offset.\n   *\n   * @param {number} offset The offset.\n   */\n  \
setOffset(offset3) {\n    this.currentOffset = this.nextOffset;\n    \
this.nextOffset = offset3;\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/viewSizeSe\
t.mjs\nvar ViewSizeSet = class {\n  constructor() {\n    this.size = new \
ViewSize();\n    this.workingSpace = WORKING_SPACE_ALL;\n    this.sharedSize \
= null;\n  }\n  /**\n   * Sets the size for rendered elements. It can be a \
size for rows, cells or size for row\n   * headers etc.\n   *\n   * @param \
{number} size The size.\n   */\n  setSize(size) {\n    \
this.size.setSize(size);\n  }\n  /**\n   * Sets the offset for rendered \
elements. The offset describes the shift between 0 and\n   * the first \
rendered element according to the scroll position.\n   *\n   * @param \
{number} offset The offset.\n   */\n  setOffset(offset3) {\n    \
this.size.setOffset(offset3);\n  }\n  /**\n   * Returns ViewSize instance.\n  \
 *\n   * @returns {ViewSize}\n   */\n  getViewSize() {\n    return \
this.size;\n  }\n  /**\n   * Checks if this ViewSizeSet is sharing the size \
with another instance.\n   *\n   * @returns {boolean}\n   */\n  isShared() \
{\n    return this.sharedSize instanceof ViewSize;\n  }\n  /**\n   * Checks \
what working space describes this size instance.\n   *\n   * @param {number} \
workingSpace The number which describes the type of the working space (see \
constants.js).\n   * @returns {boolean}\n   */\n  isPlaceOn(workingSpace) {\n \
   return this.workingSpace === workingSpace;\n  }\n  /**\n   * Appends the \
ViewSizeSet instance to this instance that turns it into a shared mode.\n   \
*\n   * @param {ViewSizeSet} viewSize The instance of the ViewSizeSet \
class.\n   */\n  append(viewSize) {\n    this.workingSpace = \
WORKING_SPACE_TOP;\n    viewSize.workingSpace = WORKING_SPACE_BOTTOM;\n    \
this.sharedSize = viewSize.getViewSize();\n  }\n  /**\n   * Prepends the \
ViewSize instance to this instance that turns it into a shared mode.\n   *\n  \
 * @param {ViewSizeSet} viewSize The instance of the ViewSizeSet class.\n   \
*/\n  prepend(viewSize) {\n    this.workingSpace = WORKING_SPACE_BOTTOM;\n    \
viewSize.workingSpace = WORKING_SPACE_TOP;\n    this.sharedSize = \
viewSize.getViewSize();\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/view.mjs\n\
var OrderView = class {\n  constructor(rootNode, nodesPool, childNodeType) \
{\n    this.rootNode = rootNode;\n    this.nodesPool = nodesPool;\n    \
this.sizeSet = new ViewSizeSet();\n    this.childNodeType = \
childNodeType.toUpperCase();\n    this.visualIndex = 0;\n    \
this.collectedNodes = [];\n  }\n  /**\n   * Sets the size for rendered \
elements. It can be a size for rows, cells or size for row\n   * headers etc. \
It depends for what table renderer this instance was created.\n   *\n   * \
@param {number} size The size.\n   * @returns {OrderView}\n   */\n  \
setSize(size) {\n    this.sizeSet.setSize(size);\n    return this;\n  }\n  \
/**\n   * Sets the offset for rendered elements. The offset describes the \
shift between 0 and\n   * the first rendered element according to the scroll \
position.\n   *\n   * @param {number} offset The offset.\n   * @returns \
{OrderView}\n   */\n  setOffset(offset3) {\n    \
this.sizeSet.setOffset(offset3);\n    return this;\n  }\n  /**\n   * Checks \
if this instance of the view shares the root node with another instance. This \
happens only once when\n   * a row (TR) as a root node is managed by two \
OrderView instances. If this happens another DOM injection\n   * algorithm is \
performed to achieve consistent order.\n   *\n   * @returns {boolean}\n   \
*/\n  isSharedViewSet() {\n    return this.sizeSet.isShared();\n  }\n  /**\n  \
 * Returns rendered DOM element based on visual index.\n   *\n   * @param \
{number} visualIndex The visual index.\n   * @returns {HTMLElement}\n   */\n  \
getNode(visualIndex) {\n    return visualIndex < this.collectedNodes.length ? \
this.collectedNodes[visualIndex] : null;\n  }\n  /**\n   * Returns currently \
processed DOM element.\n   *\n   * @returns {HTMLElement}\n   */\n  \
getCurrentNode() {\n    const length = this.collectedNodes.length;\n    \
return length > 0 ? this.collectedNodes[length - 1] : null;\n  }\n  /**\n   * \
Returns rendered child count for this instance.\n   *\n   * @returns \
{number}\n   */\n  getRenderedChildCount() {\n    const {\n      rootNode,\n  \
    sizeSet\n    } = this;\n    let childElementCount = 0;\n    if \
(this.isSharedViewSet()) {\n      let element = rootNode.firstElementChild;\n \
     while (element) {\n        if (element.tagName === this.childNodeType) \
{\n          childElementCount += 1;\n        } else if \
(sizeSet.isPlaceOn(WORKING_SPACE_TOP)) {\n          break;\n        }\n       \
 element = element.nextElementSibling;\n      }\n    } else {\n      \
childElementCount = rootNode.childElementCount;\n    }\n    return \
childElementCount;\n  }\n  /**\n   * Setups and prepares all necessary \
properties and start the rendering process.\n   * This method has to be \
called only once (at the start) for the render cycle.\n   */\n  start() {\n   \
 this.collectedNodes.length = 0;\n    this.visualIndex = 0;\n    const {\n    \
  rootNode,\n      sizeSet\n    } = this;\n    const isShared = \
this.isSharedViewSet();\n    const {\n      nextSize\n    } = \
sizeSet.getViewSize();\n    let childElementCount = \
this.getRenderedChildCount();\n    while (childElementCount < nextSize) {\n   \
   const newNode = this.nodesPool();\n      if (!isShared || isShared && \
sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\n        \
rootNode.appendChild(newNode);\n      } else {\n        \
rootNode.insertBefore(newNode, rootNode.firstChild);\n      }\n      \
childElementCount += 1;\n    }\n    const isSharedPlacedOnTop = isShared && \
sizeSet.isPlaceOn(WORKING_SPACE_TOP);\n    while (childElementCount > \
nextSize) {\n      rootNode.removeChild(isSharedPlacedOnTop ? \
rootNode.firstChild : rootNode.lastChild);\n      childElementCount -= 1;\n   \
 }\n  }\n  /**\n   * Renders the DOM element based on visual index (which is \
calculated internally).\n   * This method has to be called as many times as \
the size count is met (to cover all previously rendered DOM elements).\n   \
*/\n  render() {\n    const {\n      rootNode,\n      sizeSet\n    } = \
this;\n    let visualIndex = this.visualIndex;\n    if \
(this.isSharedViewSet() && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\n      \
visualIndex += sizeSet.sharedSize.nextSize;\n    }\n    let node = \
rootNode.childNodes[visualIndex];\n    if (node.tagName !== \
this.childNodeType) {\n      const newNode = this.nodesPool();\n      \
rootNode.replaceChild(newNode, node);\n      node = newNode;\n    }\n    \
this.collectedNodes.push(node);\n    this.visualIndex += 1;\n  }\n  /**\n   * \
Ends the render process.\n   * This method has to be called only once (at the \
end) for the render cycle.\n   */\n  end() {\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/sharedView\
.mjs\nvar SharedOrderView = class extends OrderView {\n  /**\n   * The method \
results in merging external order view into the current order. This happens \
only for order views which\n   * operate on the same root node.\n   *\n   * \
In the table, there is only one scenario when this happens. TR root element\n \
  * has a common root node with cells order view and row headers order view. \
Both classes have to share\n   * information about their order sizes to make \
proper diff calculations.\n   *\n   * @param {OrderView} orderView The order \
view to merging with. The view will be added at the beginning of the list.\n  \
 * @returns {SharedOrderView}\n   */\n  prependView(orderView) {\n    \
this.sizeSet.prepend(orderView.sizeSet);\n    \
orderView.sizeSet.append(this.sizeSet);\n    return this;\n  }\n  /**\n   * \
The method results in merging external order view into the current order. \
This happens only for order views which\n   * operate on the same root \
node.\n   *\n   * In the table, there is only one scenario when this happens. \
TR root element\n   * has a common root node with cells order view and row \
headers order view. Both classes have to share\n   * information about their \
order sizes to make proper diff calculations.\n   *\n   * @param {OrderView} \
orderView The order view to merging with. The view will be added at the end \
of the list.\n   * @returns {SharedOrderView}\n   */\n  appendView(orderView) \
{\n    this.sizeSet.append(orderView.sizeSet);\n    \
orderView.sizeSet.prepend(this.sizeSet);\n    return this;\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/utils/nodesPool.mjs\nvar \
NodesPool = class {\n  constructor(nodeType) {\n    this.nodeType = \
nodeType.toUpperCase();\n  }\n  /**\n   * Set document owner for this \
instance.\n   *\n   * @param {HTMLDocument} rootDocument The document window \
owner.\n   */\n  setRootDocument(rootDocument) {\n    this.rootDocument = \
rootDocument;\n  }\n  /**\n   * Obtains an element. The returned elements in \
the feature can be cached.\n   *\n   * @returns {HTMLElement}\n   */\n  \
obtain() {\n    return this.rootDocument.createElement(this.nodeType);\n  \
}\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/renderer/_base.mjs\nvar \
BaseRenderer = class {\n  constructor(nodeType, rootNode) {\n    \
this.nodesPool = typeof nodeType === \"string\" ? new NodesPool(nodeType) : \
null;\n    this.nodeType = nodeType;\n    this.rootNode = rootNode;\n    \
this.table = null;\n    this.renderedNodes = 0;\n  }\n  /**\n   * Sets the \
table renderer instance to the current renderer.\n   *\n   * @param \
{TableRenderer} table The TableRenderer instance.\n   */\n  setTable(table) \
{\n    if (this.nodesPool) {\n      \
this.nodesPool.setRootDocument(table.rootDocument);\n    }\n    this.table = \
table;\n  }\n  /**\n   * Adjusts the number of rendered nodes.\n   */\n  \
adjust() {\n  }\n  /**\n   * Renders the contents to the elements.\n   */\n  \
render() {\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/renderer/rowHeaders.mjs\nv\
ar RowHeadersRenderer = class extends BaseRenderer {\n  constructor() {\n    \
super(\"TH\");\n    this.orderViews = /* @__PURE__ */ new WeakMap();\n    \
this.sourceRowIndex = 0;\n  }\n  /**\n   * Obtains the instance of the \
SharedOrderView class which is responsible for rendering the nodes to the \
root node.\n   *\n   * @param {HTMLTableRowElement} rootNode The TR element, \
which is root element for row headers (TH).\n   * @returns \
{SharedOrderView}\n   */\n  obtainOrderView(rootNode) {\n    let orderView;\n \
   if (this.orderViews.has(rootNode)) {\n      orderView = \
this.orderViews.get(rootNode);\n    } else {\n      orderView = new \
SharedOrderView(rootNode, (sourceColumnIndex) => \
this.nodesPool.obtain(this.sourceRowIndex, sourceColumnIndex), \
this.nodeType);\n      this.orderViews.set(rootNode, orderView);\n    }\n    \
return orderView;\n  }\n  /**\n   * Renders the cells.\n   */\n  render() {\n \
   const {\n      rowsToRender,\n      rowHeaderFunctions,\n      \
rowHeadersCount,\n      rows,\n      cells\n    } = this.table;\n    for (let \
visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n   \
   const sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);\n  \
    const TR = rows.getRenderedNode(visibleRowIndex);\n      \
this.sourceRowIndex = sourceRowIndex;\n      const orderView = \
this.obtainOrderView(TR);\n      const cellsView = \
cells.obtainOrderView(TR);\n      \
orderView.appendView(cellsView).setSize(rowHeadersCount).setOffset(this.table\
.renderedColumnToSource(0)).start();\n      for (let visibleColumnIndex = 0; \
visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {\n        \
orderView.render();\n        const TH = orderView.getCurrentNode();\n        \
TH.className = \"\";\n        TH.removeAttribute(\"style\");\n        \
rowHeaderFunctions[visibleColumnIndex](sourceRowIndex, TH, \
visibleColumnIndex);\n      }\n      orderView.end();\n    }\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/renderer/columnHeaders.mjs\
\nvar ColumnHeadersRenderer = class extends BaseRenderer {\n  \
constructor(rootNode) {\n    super(null, rootNode);\n  }\n  /**\n   * Adjusts \
the number of the rendered elements.\n   */\n  adjust() {\n    const {\n      \
columnHeadersCount,\n      rowHeadersCount\n    } = this.table;\n    let TR = \
this.rootNode.firstChild;\n    if (columnHeadersCount) {\n      const {\n     \
   columnsToRender\n      } = this.table;\n      const allColumnsToRender = \
columnsToRender + rowHeadersCount;\n      for (let i = 0, len = \
columnHeadersCount; i < len; i++) {\n        TR = \
this.rootNode.childNodes[i];\n        if (!TR) {\n          TR = \
this.table.rootDocument.createElement(\"tr\");\n          \
this.rootNode.appendChild(TR);\n        }\n        this.renderedNodes = \
TR.childNodes.length;\n        while (this.renderedNodes < \
allColumnsToRender) {\n          \
TR.appendChild(this.table.rootDocument.createElement(\"th\"));\n          \
this.renderedNodes += 1;\n        }\n        while (this.renderedNodes > \
allColumnsToRender) {\n          TR.removeChild(TR.lastChild);\n          \
this.renderedNodes -= 1;\n        }\n      }\n      const theadChildrenLength \
= this.rootNode.childNodes.length;\n      if (theadChildrenLength > \
columnHeadersCount) {\n        for (let i = columnHeadersCount; i < \
theadChildrenLength; i++) {\n          \
this.rootNode.removeChild(this.rootNode.lastChild);\n        }\n      }\n    \
} else if (TR) {\n      empty(TR);\n    }\n  }\n  /**\n   * Renders the TH \
elements.\n   */\n  render() {\n    const {\n      columnHeadersCount\n    } \
= this.table;\n    for (let rowHeaderIndex = 0; rowHeaderIndex < \
columnHeadersCount; rowHeaderIndex += 1) {\n      const {\n        \
columnHeaderFunctions,\n        columnsToRender,\n        rowHeadersCount\n   \
   } = this.table;\n      const TR = \
this.rootNode.childNodes[rowHeaderIndex];\n      for (let renderedColumnIndex \
= -1 * rowHeadersCount; renderedColumnIndex < columnsToRender; \
renderedColumnIndex += 1) {\n        const sourceColumnIndex = \
this.table.renderedColumnToSource(renderedColumnIndex);\n        const TH = \
TR.childNodes[renderedColumnIndex + rowHeadersCount];\n        TH.className = \
\"\";\n        TH.removeAttribute(\"style\");\n        \
columnHeaderFunctions[rowHeaderIndex](sourceColumnIndex, TH, \
rowHeaderIndex);\n      }\n    }\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/renderer/colGroup.mjs\nvar \
ColGroupRenderer = class extends BaseRenderer {\n  constructor(rootNode) {\n  \
  super(null, rootNode);\n  }\n  /**\n   * Adjusts the number of the rendered \
elements.\n   */\n  adjust() {\n    const {\n      columnsToRender,\n      \
rowHeadersCount\n    } = this.table;\n    const allColumnsToRender = \
columnsToRender + rowHeadersCount;\n    while (this.renderedNodes < \
allColumnsToRender) {\n      \
this.rootNode.appendChild(this.table.rootDocument.createElement(\"col\"));\n  \
    this.renderedNodes += 1;\n    }\n    while (this.renderedNodes > \
allColumnsToRender) {\n      \
this.rootNode.removeChild(this.rootNode.lastChild);\n      this.renderedNodes \
-= 1;\n    }\n  }\n  /**\n   * Renders the col group elements.\n   */\n  \
render() {\n    this.adjust();\n    const {\n      columnsToRender,\n      \
rowHeadersCount\n    } = this.table;\n    for (let visibleColumnIndex = 0; \
visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {\n      const \
sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);\n  \
    const width = this.table.columnUtils.getHeaderWidth(sourceColumnIndex);\n \
     this.rootNode.childNodes[visibleColumnIndex].style.width = \
`${width}px`;\n    }\n    for (let visibleColumnIndex = 0; visibleColumnIndex \
< columnsToRender; visibleColumnIndex++) {\n      const sourceColumnIndex = \
this.table.renderedColumnToSource(visibleColumnIndex);\n      const width = \
this.table.columnUtils.getStretchedColumnWidth(sourceColumnIndex);\n      \
this.rootNode.childNodes[visibleColumnIndex + rowHeadersCount].style.width = \
`${width}px`;\n    }\n    const firstChild = this.rootNode.firstChild;\n    \
if (firstChild) {\n      addClass(firstChild, \"rowHeader\");\n    }\n  \
}\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/renderer/rows.mjs\nvar \
performanceWarningAppeared = false;\nvar RowsRenderer = class extends \
BaseRenderer {\n  constructor(rootNode) {\n    super(\"TR\", rootNode);\n    \
this.orderView = new OrderView(rootNode, (sourceRowIndex) => \
this.nodesPool.obtain(sourceRowIndex), this.nodeType);\n  }\n  /**\n   * \
Returns currently rendered node.\n   *\n   * @param {string} visualIndex \
Visual index of the rendered node (it always goeas from 0 to N).\n   * \
@returns {HTMLTableRowElement}\n   */\n  getRenderedNode(visualIndex) {\n    \
return this.orderView.getNode(visualIndex);\n  }\n  /**\n   * Renders the \
cells.\n   */\n  render() {\n    const {\n      rowsToRender\n    } = \
this.table;\n    if (!performanceWarningAppeared && rowsToRender > 1e3) {\n   \
   performanceWarningAppeared = true;\n      warn(toSingleLine`Performance \
tip: Handsontable rendered more than 1000 visible rows. Consider \
limiting\\x20\n        the number of rendered rows by specifying the table \
height and/or turning off the \"renderAllRows\" option.`);\n    }\n    \
this.orderView.setSize(rowsToRender).setOffset(this.table.renderedRowToSource\
(0)).start();\n    for (let visibleRowIndex = 0; visibleRowIndex < \
rowsToRender; visibleRowIndex++) {\n      this.orderView.render();\n    }\n   \
 this.orderView.end();\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/renderer/cells.mjs\nvar \
CellsRenderer = class extends BaseRenderer {\n  constructor() {\n    \
super(\"TD\");\n    this.orderViews = /* @__PURE__ */ new WeakMap();\n    \
this.sourceRowIndex = 0;\n  }\n  /**\n   * Obtains the instance of the \
SharedOrderView class which is responsible for rendering the nodes to the \
root node.\n   *\n   * @param {HTMLTableRowElement} rootNode The TR element, \
which is root element for cells (TD).\n   * @returns {SharedOrderView}\n   \
*/\n  obtainOrderView(rootNode) {\n    let orderView;\n    if \
(this.orderViews.has(rootNode)) {\n      orderView = \
this.orderViews.get(rootNode);\n    } else {\n      orderView = new \
SharedOrderView(rootNode, (sourceColumnIndex) => \
this.nodesPool.obtain(this.sourceRowIndex, sourceColumnIndex), \
this.nodeType);\n      this.orderViews.set(rootNode, orderView);\n    }\n    \
return orderView;\n  }\n  /**\n   * Renders the cells.\n   */\n  render() {\n \
   const {\n      rowsToRender,\n      columnsToRender,\n      rows,\n      \
rowHeaders\n    } = this.table;\n    for (let visibleRowIndex = 0; \
visibleRowIndex < rowsToRender; visibleRowIndex++) {\n      const \
sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);\n      \
const TR = rows.getRenderedNode(visibleRowIndex);\n      this.sourceRowIndex \
= sourceRowIndex;\n      const orderView = this.obtainOrderView(TR);\n      \
const rowHeadersView = rowHeaders.obtainOrderView(TR);\n      \
orderView.prependView(rowHeadersView).setSize(columnsToRender).setOffset(this\
.table.renderedColumnToSource(0)).start();\n      for (let visibleColumnIndex \
= 0; visibleColumnIndex < columnsToRender; visibleColumnIndex++) {\n        \
orderView.render();\n        const TD = orderView.getCurrentNode();\n        \
const sourceColumnIndex = \
this.table.renderedColumnToSource(visibleColumnIndex);\n        if \
(!hasClass(TD, \"hide\")) {\n          TD.className = \"\";\n        }\n      \
  TD.removeAttribute(\"style\");\n        TD.removeAttribute(\"dir\");\n      \
  this.table.cellRenderer(sourceRowIndex, sourceColumnIndex, TD);\n      }\n  \
    orderView.end();\n    }\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/renderer/table.mjs\nvar \
TableRenderer = class {\n  constructor(rootNode) {\n    let {\n      \
cellRenderer\n    } = arguments.length > 1 && arguments[1] !== void 0 ? \
arguments[1] : {};\n    this.rootNode = rootNode;\n    this.rootDocument = \
this.rootNode.ownerDocument;\n    this.rowHeaders = null;\n    \
this.columnHeaders = null;\n    this.colGroup = null;\n    this.rows = \
null;\n    this.cells = null;\n    this.rowFilter = null;\n    \
this.columnFilter = null;\n    this.rowUtils = null;\n    this.columnUtils = \
null;\n    this.rowsToRender = 0;\n    this.columnsToRender = 0;\n    \
this.rowHeaderFunctions = [];\n    this.rowHeadersCount = 0;\n    \
this.columnHeaderFunctions = [];\n    this.columnHeadersCount = 0;\n    \
this.cellRenderer = cellRenderer;\n  }\n  /**\n   * Set row and column util \
classes.\n   *\n   * @param {RowUtils} rowUtils RowUtils instance which \
provides useful methods related to row sizes.\n   * @param {ColumnUtils} \
columnUtils ColumnUtils instance which provides useful methods related to row \
sizes.\n   */\n  setAxisUtils(rowUtils, columnUtils) {\n    this.rowUtils = \
rowUtils;\n    this.columnUtils = columnUtils;\n  }\n  /**\n   * Sets \
viewport size of the table.\n   *\n   * @param {number} rowsCount An amount \
of rows to render.\n   * @param {number} columnsCount An amount of columns to \
render.\n   */\n  setViewportSize(rowsCount, columnsCount) {\n    \
this.rowsToRender = rowsCount;\n    this.columnsToRender = columnsCount;\n  \
}\n  /**\n   * Sets row and column filter instances.\n   *\n   * @param \
{RowFilter} rowFilter Row filter instance which contains all necessary \
information about row index transformation.\n   * @param {ColumnFilter} \
columnFilter Column filter instance which contains all necessary information \
about row\n   * index transformation.\n   */\n  setFilters(rowFilter, \
columnFilter) {\n    this.rowFilter = rowFilter;\n    this.columnFilter = \
columnFilter;\n  }\n  /**\n   * Sets row and column header functions.\n   *\n \
  * @param {Function[]} rowHeaders Row header functions. Factories for \
creating content for row headers.\n   * @param {Function[]} columnHeaders \
Column header functions. Factories for creating content for column headers.\n \
  */\n  setHeaderContentRenderers(rowHeaders, columnHeaders) {\n    \
this.rowHeaderFunctions = rowHeaders;\n    this.rowHeadersCount = \
rowHeaders.length;\n    this.columnHeaderFunctions = columnHeaders;\n    \
this.columnHeadersCount = columnHeaders.length;\n  }\n  /**\n   * Sets table \
renderers.\n   *\n   * @param {renderers} renderers The renderer units.\n   * \
@param {RowHeadersRenderer} renderers.rowHeaders Row headers renderer.\n   * \
@param {ColumnHeadersRenderer} renderers.columnHeaders Column headers \
renderer.\n   * @param {ColGroupRenderer} renderers.colGroup Col group \
renderer.\n   * @param {RowsRenderer} renderers.rows Rows renderer.\n   * \
@param {CellsRenderer} renderers.cells Cells renderer.\n   */\n  \
setRenderers() {\n    let {\n      rowHeaders,\n      columnHeaders,\n      \
colGroup,\n      rows,\n      cells\n    } = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : {};\n    \
rowHeaders.setTable(this);\n    columnHeaders.setTable(this);\n    \
colGroup.setTable(this);\n    rows.setTable(this);\n    \
cells.setTable(this);\n    this.rowHeaders = rowHeaders;\n    \
this.columnHeaders = columnHeaders;\n    this.colGroup = colGroup;\n    \
this.rows = rows;\n    this.cells = cells;\n  }\n  /**\n   * Transforms \
visual/rendered row index to source index.\n   *\n   * @param {number} \
rowIndex Rendered index.\n   * @returns {number}\n   */\n  \
renderedRowToSource(rowIndex) {\n    return \
this.rowFilter.renderedToSource(rowIndex);\n  }\n  /**\n   * Transforms \
visual/rendered column index to source index.\n   *\n   * @param {number} \
columnIndex Rendered index.\n   * @returns {number}\n   */\n  \
renderedColumnToSource(columnIndex) {\n    return \
this.columnFilter.renderedToSource(columnIndex);\n  }\n  /**\n   * Renders \
the table.\n   */\n  render() {\n    this.colGroup.adjust();\n    \
this.columnHeaders.adjust();\n    this.rows.adjust();\n    \
this.rowHeaders.adjust();\n    this.columnHeaders.render();\n    \
this.rows.render();\n    this.rowHeaders.render();\n    \
this.cells.render();\n    this.columnUtils.calculateWidths();\n    \
this.colGroup.render();\n    const {\n      rowsToRender,\n      rows\n    } \
= this;\n    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; \
visibleRowIndex++) {\n      const TR = \
rows.getRenderedNode(visibleRowIndex);\n      if (TR.firstChild) {\n        \
const sourceRowIndex = this.renderedRowToSource(visibleRowIndex);\n        \
const rowHeight = this.rowUtils.getHeight(sourceRowIndex);\n        if \
(rowHeight) {\n          TR.firstChild.style.height = `${rowHeight - 1}px`;\n \
       } else {\n          TR.firstChild.style.height = \"\";\n        }\n    \
  }\n    }\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/renderer/index.mjs\nvar \
Renderer = class {\n  constructor() {\n    let {\n      TABLE,\n      \
THEAD,\n      COLGROUP,\n      TBODY,\n      rowUtils,\n      columnUtils,\n  \
    cellRenderer\n    } = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : {};\n    this.renderer = new TableRenderer(TABLE, {\n      \
cellRenderer\n    });\n    this.renderer.setRenderers({\n      rowHeaders: \
new RowHeadersRenderer(),\n      columnHeaders: new \
ColumnHeadersRenderer(THEAD),\n      colGroup: new \
ColGroupRenderer(COLGROUP),\n      rows: new RowsRenderer(TBODY),\n      \
cells: new CellsRenderer()\n    });\n    this.renderer.setAxisUtils(rowUtils, \
columnUtils);\n  }\n  /**\n   * Sets filter calculators for newly calculated \
row and column position. The filters are used to transform visual\n   * \
indexes (0 to N) to source indexes provided by Handsontable.\n   *\n   * \
@param {RowFilter} rowFilter The row filter instance.\n   * @param \
{ColumnFilter} columnFilter The column filter instance.\n   * @returns \
{Renderer}\n   */\n  setFilters(rowFilter, columnFilter) {\n    \
this.renderer.setFilters(rowFilter, columnFilter);\n    return this;\n  }\n  \
/**\n   * Sets the viewport size of the rendered table.\n   *\n   * @param \
{number} rowsCount An amount of rows to render.\n   * @param {number} \
columnsCount An amount of columns to render.\n   * @returns {Renderer}\n   \
*/\n  setViewportSize(rowsCount, columnsCount) {\n    \
this.renderer.setViewportSize(rowsCount, columnsCount);\n    return this;\n  \
}\n  /**\n   * Sets row and column header functions.\n   *\n   * @param \
{Function[]} rowHeaders Row header functions. Factories for creating content \
for row headers.\n   * @param {Function[]} columnHeaders Column header \
functions. Factories for creating content for column headers.\n   * @returns \
{Renderer}\n   */\n  setHeaderContentRenderers(rowHeaders, columnHeaders) {\n \
   this.renderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n    \
return this;\n  }\n  /**\n   * Adjusts the table (preparing for render).\n   \
*/\n  adjust() {\n    this.renderer.adjust();\n  }\n  /**\n   * Renders the \
table.\n   */\n  render() {\n    this.renderer.render();\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/utils/column.mjs\nvar \
ColumnUtils = class {\n  /**\n   * @param {TableDao} dataAccessObject The \
table Data Access Object.\n   * @param {Settings} wtSettings The walkontable \
settings.\n   */\n  constructor(dataAccessObject, wtSettings) {\n    \
this.dataAccessObject = dataAccessObject;\n    this.wtSettings = \
wtSettings;\n    this.headerWidths = /* @__PURE__ */ new Map();\n  }\n  /**\n \
  * Returns column width based on passed source index.\n   *\n   * @param \
{number} sourceIndex Column source index.\n   * @returns {number}\n   */\n  \
getWidth(sourceIndex) {\n    return \
this.wtSettings.getSetting(\"columnWidth\", sourceIndex) || \
this.wtSettings.getSetting(\"defaultColumnWidth\");\n  }\n  /**\n   * Returns \
stretched column width based on passed source index.\n   *\n   * @param \
{number} sourceIndex Column source index.\n   * @returns {number}\n   */\n  \
getStretchedColumnWidth(sourceIndex) {\n    const calculator = \
this.dataAccessObject.wtViewport.columnsRenderCalculator;\n    let width = \
this.getWidth(sourceIndex);\n    if (calculator) {\n      const \
stretchedWidth = calculator.getStretchedColumnWidth(sourceIndex, width);\n    \
  if (stretchedWidth) {\n        width = stretchedWidth;\n      }\n    }\n    \
return width;\n  }\n  /**\n   * Returns column header height based on passed \
header level.\n   *\n   * @param {number} level Column header level.\n   * \
@returns {number}\n   */\n  getHeaderHeight(level) {\n    let height = \
this.wtSettings.getSetting(\"defaultRowHeight\");\n    const oversizedHeight \
= this.dataAccessObject.wtViewport.oversizedColumnHeaders[level];\n    if \
(oversizedHeight !== void 0) {\n      height = height ? Math.max(height, \
oversizedHeight) : oversizedHeight;\n    }\n    return height;\n  }\n  /**\n  \
 * Returns column header width based on passed source index.\n   *\n   * \
@param {number} sourceIndex Column source index.\n   * @returns {number}\n   \
*/\n  getHeaderWidth(sourceIndex) {\n    return \
this.headerWidths.get(this.dataAccessObject.wtTable.columnFilter.sourceToRend\
ered(sourceIndex));\n  }\n  /**\n   * Calculates column header widths that \
can be retrieved from the cache.\n   */\n  calculateWidths() {\n    const {\n \
     wtSettings\n    } = this;\n    const {\n      wtTable,\n      \
wtViewport,\n      cloneSource\n    } = this.dataAccessObject;\n    const \
mainHolder = cloneSource ? cloneSource.wtTable.holder : wtTable.holder;\n    \
const scrollbarCompensation = mainHolder.offsetHeight < \
mainHolder.scrollHeight ? getScrollbarWidth() : 0;\n    let \
rowHeaderWidthSetting = wtSettings.getSetting(\"rowHeaderWidth\");\n    \
wtViewport.columnsRenderCalculator.refreshStretching(wtViewport.getViewportWi\
dth() - scrollbarCompensation);\n    rowHeaderWidthSetting = \
wtSettings.getSetting(\"onModifyRowHeaderWidth\", rowHeaderWidthSetting);\n   \
 if (rowHeaderWidthSetting !== null && rowHeaderWidthSetting !== void 0) {\n  \
    const rowHeadersCount = wtSettings.getSetting(\"rowHeaders\").length;\n   \
   const defaultColumnWidth = \
wtSettings.getSetting(\"defaultColumnWidth\");\n      for (let \
visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; \
visibleColumnIndex++) {\n        let width = \
Array.isArray(rowHeaderWidthSetting) ? \
rowHeaderWidthSetting[visibleColumnIndex] : rowHeaderWidthSetting;\n        \
width = width === null || width === void 0 ? defaultColumnWidth : width;\n    \
    this.headerWidths.set(visibleColumnIndex, width);\n      }\n    }\n  \
}\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/utils/row.mjs\nvar \
RowUtils = class {\n  /**\n   * @param {TableDao} dataAccessObject The table \
Data Access Object.\n   * @param {Settings} wtSettings The walkontable \
settings.\n   */\n  constructor(dataAccessObject, wtSettings) {\n    \
this.dataAccessObject = dataAccessObject;\n    this.wtSettings = \
wtSettings;\n  }\n  /**\n   * Returns row height based on passed source \
index.\n   *\n   * @param {number} sourceIndex Row source index.\n   * \
@returns {number}\n   */\n  getHeight(sourceIndex) {\n    let height = \
this.wtSettings.getSetting(\"rowHeight\", sourceIndex);\n    const \
oversizedHeight = \
this.dataAccessObject.wtViewport.oversizedRows[sourceIndex];\n    if \
(oversizedHeight !== void 0) {\n      height = height === void 0 ? \
oversizedHeight : Math.max(height, oversizedHeight);\n    }\n    return \
height;\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table.mjs\nfunction \
_defineProperty3(obj, key, value) {\n  key = _toPropertyKey3(key);\n  if (key \
in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: true, \
configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  \
}\n  return obj;\n}\nfunction _toPropertyKey3(arg) {\n  var key = \
_toPrimitive3(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive3(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar Table = class {\n  /**\n   *\n   * @abstract\n   * \
@param {TableDao} dataAccessObject The data access object.\n   * @param \
{FacadeGetter} facadeGetter Function which return proper facade.\n   * @param \
{DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} \
wtSettings The Walkontable settings.\n   * @param {'master'|CLONE_TYPES_ENUM} \
name Overlay name.\n   */\n  constructor(dataAccessObject, facadeGetter, \
domBindings, wtSettings, name) {\n    _defineProperty3(this, \"wtSettings\", \
null);\n    _defineProperty3(this, \"domBindings\", void 0);\n    \
_defineProperty3(this, \"TBODY\", null);\n    _defineProperty3(this, \
\"THEAD\", null);\n    _defineProperty3(this, \"COLGROUP\", null);\n    \
_defineProperty3(this, \"hasTableHeight\", true);\n    _defineProperty3(this, \
\"hasTableWidth\", true);\n    _defineProperty3(this, \"isTableVisible\", \
false);\n    _defineProperty3(this, \"tableOffset\", 0);\n    \
_defineProperty3(this, \"holderOffset\", 0);\n    this.domBindings = \
domBindings;\n    this.isMaster = name === \"master\";\n    this.name = \
name;\n    this.dataAccessObject = dataAccessObject;\n    this.facadeGetter = \
facadeGetter;\n    this.wtSettings = wtSettings;\n    this.instance = \
this.dataAccessObject.wot;\n    this.wot = this.dataAccessObject.wot;\n    \
this.TABLE = domBindings.rootTable;\n    removeTextNodes(this.TABLE);\n    \
this.spreader = this.createSpreader(this.TABLE);\n    this.hider = \
this.createHider(this.spreader);\n    this.holder = \
this.createHolder(this.hider);\n    this.wtRootElement = \
this.holder.parentNode;\n    if (this.isMaster) {\n      \
this.alignOverlaysWithTrimmingContainer();\n    }\n    \
this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = \
null;\n    this.correctHeaderWidth = false;\n    const origRowHeaderWidth = \
this.wtSettings.getSettingPure(\"rowHeaderWidth\");\n    \
this.wtSettings.update(\"rowHeaderWidth\", () => \
this._modifyRowHeaderWidth(origRowHeaderWidth));\n    this.rowUtils = new \
RowUtils(this.dataAccessObject, this.wtSettings);\n    this.columnUtils = new \
ColumnUtils(this.dataAccessObject, this.wtSettings);\n    this.tableRenderer \
= new Renderer({\n      // TODO refactoring, It can be passed through IOC.\n  \
    TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: \
this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n    \
  columnUtils: this.columnUtils,\n      cellRenderer: \
this.wtSettings.getSettingPure(\"cellRenderer\")\n    });\n  }\n  /**\n   * \
Returns a boolean that is true if this Table represents a specific overlay, \
identified by the overlay name.\n   * For MasterTable, it returns false.\n   \
*\n   * @param {string} overlayTypeName The overlay type.\n   * @returns \
{boolean}\n   */\n  is(overlayTypeName) {\n    return this.name === \
overlayTypeName;\n  }\n  /**\n   *\n   */\n  fixTableDomTree() {\n    const \
rootDocument = this.domBindings.rootDocument;\n    this.TBODY = \
this.TABLE.querySelector(\"tbody\");\n    if (!this.TBODY) {\n      \
this.TBODY = rootDocument.createElement(\"tbody\");\n      \
this.TABLE.appendChild(this.TBODY);\n    }\n    this.THEAD = \
this.TABLE.querySelector(\"thead\");\n    if (!this.THEAD) {\n      \
this.THEAD = rootDocument.createElement(\"thead\");\n      \
this.TABLE.insertBefore(this.THEAD, this.TBODY);\n    }\n    this.COLGROUP = \
this.TABLE.querySelector(\"colgroup\");\n    if (!this.COLGROUP) {\n      \
this.COLGROUP = rootDocument.createElement(\"colgroup\");\n      \
this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n    }\n  }\n  /**\n   * \
@param {HTMLTableElement} table An element to process.\n   * @returns \
{HTMLElement}\n   */\n  createSpreader(table) {\n    const parent2 = \
table.parentNode;\n    let spreader;\n    if (!parent2 || parent2.nodeType \
!== Node.ELEMENT_NODE || !hasClass(parent2, \"wtHolder\")) {\n      spreader \
= this.domBindings.rootDocument.createElement(\"div\");\n      \
spreader.className = \"wtSpreader\";\n      if (parent2) {\n        \
parent2.insertBefore(spreader, table);\n      }\n      \
spreader.appendChild(table);\n    }\n    spreader.style.position = \
\"relative\";\n    return spreader;\n  }\n  /**\n   * @param {HTMLElement} \
spreader An element to the hider element is injected.\n   * @returns \
{HTMLElement}\n   */\n  createHider(spreader) {\n    const parent2 = \
spreader.parentNode;\n    let hider;\n    if (!parent2 || parent2.nodeType \
!== Node.ELEMENT_NODE || !hasClass(parent2, \"wtHolder\")) {\n      hider = \
this.domBindings.rootDocument.createElement(\"div\");\n      hider.className \
= \"wtHider\";\n      if (parent2) {\n        parent2.insertBefore(hider, \
spreader);\n      }\n      hider.appendChild(spreader);\n    }\n    return \
hider;\n  }\n  /**\n   *\n   * @param {HTMLElement} hider An element to the \
holder element is injected.\n   * @returns {HTMLElement}\n   */\n  \
createHolder(hider) {\n    const parent2 = hider.parentNode;\n    let \
holder2;\n    if (!parent2 || parent2.nodeType !== Node.ELEMENT_NODE || \
!hasClass(parent2, \"wtHolder\")) {\n      holder2 = \
this.domBindings.rootDocument.createElement(\"div\");\n      \
holder2.style.position = \"relative\";\n      holder2.className = \
\"wtHolder\";\n      if (parent2) {\n        parent2.insertBefore(holder2, \
hider);\n      }\n      if (this.isMaster) {\n        \
holder2.parentNode.className += \"ht_master handsontable\";\n        \
holder2.parentNode.setAttribute(\"dir\", \
this.wtSettings.getSettingPure(\"rtlMode\") ? \"rtl\" : \"ltr\");\n      }\n  \
    holder2.appendChild(hider);\n    }\n    return holder2;\n  }\n  /**\n   * \
Redraws the table.\n   *\n   * @param {boolean} [fastDraw=false] If TRUE, \
will try to avoid full redraw and only update the border positions.\n   *     \
                              If FALSE or UNDEFINED, will perform a full \
redraw.\n   * @returns {Table}\n   */\n  draw() {\n    let fastDraw = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    \
const {\n      wtSettings\n    } = this;\n    const {\n      wtOverlays,\n    \
  wtViewport\n    } = this.dataAccessObject;\n    const totalRows = \
wtSettings.getSetting(\"totalRows\");\n    const totalColumns = \
wtSettings.getSetting(\"totalColumns\");\n    const rowHeaders = \
wtSettings.getSetting(\"rowHeaders\");\n    const rowHeadersCount = \
rowHeaders.length;\n    const columnHeaders = \
wtSettings.getSetting(\"columnHeaders\");\n    const columnHeadersCount = \
columnHeaders.length;\n    let syncScroll = false;\n    let runFastDraw = \
fastDraw;\n    if (this.isMaster) {\n      this.holderOffset = \
offset(this.holder);\n      runFastDraw = \
wtViewport.createRenderCalculators(runFastDraw);\n      if (rowHeadersCount \
&& !wtSettings.getSetting(\"fixedColumnsStart\")) {\n        const \
leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();\n        \
const previousState = this.correctHeaderWidth;\n        \
this.correctHeaderWidth = leftScrollPos !== 0;\n        if (previousState !== \
this.correctHeaderWidth) {\n          runFastDraw = false;\n        }\n      \
}\n    }\n    if (this.isMaster) {\n      syncScroll = \
wtOverlays.updateStateOfRendering();\n    }\n    if (runFastDraw) {\n      if \
(this.isMaster) {\n        wtViewport.createVisibleCalculators();\n      }\n  \
    if (wtOverlays) {\n        wtOverlays.refresh(true);\n      }\n    } else \
{\n      if (this.isMaster) {\n        this.tableOffset = \
offset(this.TABLE);\n      } else {\n        this.tableOffset = \
this.dataAccessObject.parentTableOffset;\n      }\n      const startRow = \
totalRows > 0 ? this.getFirstRenderedRow() : 0;\n      const startColumn = \
totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n      this.rowFilter = \
new row_default(startRow, totalRows, columnHeadersCount);\n      \
this.columnFilter = new column_default(startColumn, totalColumns, \
rowHeadersCount);\n      let performRedraw = true;\n      if (this.isMaster) \
{\n        this.alignOverlaysWithTrimmingContainer();\n        const \
skipRender = {};\n        this.wtSettings.getSetting(\"beforeDraw\", true, \
skipRender);\n        performRedraw = skipRender.skipRender !== true;\n      \
}\n      if (performRedraw) {\n        \
this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n    \
    if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_INLINE_START_CORNER)) \
{\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n  \
      }\n        this.resetOversizedRows();\n        \
this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), \
this.getRenderedColumnsCount()).setFilters(this.rowFilter, \
this.columnFilter).render();\n        let workspaceWidth;\n        if \
(this.isMaster) {\n          workspaceWidth = \
this.dataAccessObject.workspaceWidth;\n          \
this.dataAccessObject.wtViewport.containerWidth = null;\n          \
this.markOversizedColumnHeaders();\n        }\n        \
this.adjustColumnHeaderHeights();\n        if (this.isMaster || \
this.is(CLONE_BOTTOM)) {\n          this.markOversizedRows();\n        }\n    \
    if (this.isMaster) {\n          \
this.dataAccessObject.wtViewport.createVisibleCalculators();\n          \
this.dataAccessObject.wtOverlays.refresh(false);\n          \
this.dataAccessObject.wtOverlays.applyToDOM();\n          const hiderWidth = \
outerWidth(this.hider);\n          const tableWidth = \
outerWidth(this.TABLE);\n          if (hiderWidth !== 0 && tableWidth !== \
hiderWidth) {\n            this.columnUtils.calculateWidths();\n            \
this.tableRenderer.renderer.colGroup.render();\n          }\n          if \
(workspaceWidth !== this.dataAccessObject.wtViewport.getWorkspaceWidth()) {\n \
           this.dataAccessObject.wtViewport.containerWidth = null;\n          \
  this.columnUtils.calculateWidths();\n            \
this.tableRenderer.renderer.colGroup.render();\n          }\n          \
this.wtSettings.getSetting(\"onDraw\", true);\n        } else if \
(this.is(CLONE_BOTTOM)) {\n          \
this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();\n        \
}\n      }\n    }\n    let positionChanged = false;\n    if (this.isMaster) \
{\n      positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n      \
if (wtOverlays.bottomOverlay.clone) {\n        positionChanged = \
wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n      }\n  \
    positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || \
positionChanged;\n      if (wtOverlays.topInlineStartCornerOverlay) {\n       \
 wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();\n      }\n      \
if (wtOverlays.bottomInlineStartCornerOverlay && \
wtOverlays.bottomInlineStartCornerOverlay.clone) {\n        \
wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();\n      }\n    \
}\n    if (positionChanged) {\n      wtOverlays.refreshAll();\n      \
wtOverlays.adjustElementsSize();\n    } else {\n      \
this.refreshSelections(runFastDraw);\n    }\n    if (syncScroll) {\n      \
wtOverlays.syncScrollWithMaster();\n    }\n    this.dataAccessObject.drawn = \
true;\n    return this;\n  }\n  /**\n   * @param {number} col The visual \
column index.\n   */\n  markIfOversizedColumnHeader(col) {\n    const \
sourceColIndex = this.columnFilter.renderedToSource(col);\n    let level = \
this.wtSettings.getSetting(\"columnHeaders\").length;\n    const \
defaultRowHeight = this.wtSettings.getSetting(\"defaultRowHeight\");\n    let \
previousColHeaderHeight;\n    let currentHeader;\n    let \
currentHeaderHeight;\n    const columnHeaderHeightSetting = \
this.wtSettings.getSetting(\"columnHeaderHeight\") || [];\n    while (level) \
{\n      level -= 1;\n      previousColHeaderHeight = \
this.getColumnHeaderHeight(level);\n      currentHeader = \
this.getColumnHeader(sourceColIndex, level);\n      if (!currentHeader) {\n   \
     continue;\n      }\n      currentHeaderHeight = \
innerHeight(currentHeader);\n      if (!previousColHeaderHeight && \
defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < \
currentHeaderHeight) {\n        \
this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = \
currentHeaderHeight;\n      }\n      if \
(Array.isArray(columnHeaderHeightSetting)) {\n        if \
(columnHeaderHeightSetting[level] !== null && \
columnHeaderHeightSetting[level] !== void 0) {\n          \
this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = \
columnHeaderHeightSetting[level];\n        }\n      } else if \
(!isNaN(columnHeaderHeightSetting)) {\n        \
this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = \
columnHeaderHeightSetting;\n      }\n      if \
(this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < \
(columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n        \
this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = \
columnHeaderHeightSetting[level] || columnHeaderHeightSetting;\n      }\n    \
}\n  }\n  /**\n   *\n   */\n  adjustColumnHeaderHeights() {\n    const {\n    \
  wtSettings\n    } = this;\n    const children = this.THEAD.childNodes;\n    \
const oversizedColumnHeaders = \
this.dataAccessObject.wtViewport.oversizedColumnHeaders;\n    const \
columnHeaders = wtSettings.getSetting(\"columnHeaders\");\n    for (let i = \
0, len = columnHeaders.length; i < len; i++) {\n      if \
(oversizedColumnHeaders[i]) {\n        if (!children[i] || \
children[i].childNodes.length === 0) {\n          return;\n        }\n        \
children[i].childNodes[0].style.height = `${oversizedColumnHeaders[i]}px`;\n  \
    }\n    }\n  }\n  /**\n   * Resets cache of row heights. The cache should \
be cached for each render cycle in a case\n   * when new cell values have \
content which increases/decreases cell height.\n   */\n  resetOversizedRows() \
{\n    const {\n      wtSettings\n    } = this;\n    const {\n      \
wtViewport\n    } = this.dataAccessObject;\n    if (!this.isMaster && \
!this.is(CLONE_BOTTOM)) {\n      return;\n    }\n    if \
(!wtSettings.getSetting(\"externalRowCalculator\")) {\n      const \
rowsToRender = this.getRenderedRowsCount();\n      for (let visibleRowIndex = \
0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n        const \
sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n        if \
(wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {\n         \
 wtViewport.oversizedRows[sourceRow] = void 0;\n        }\n      }\n    }\n  \
}\n  /**\n   * @param {string} className The CSS class name to remove from \
the table cells.\n   */\n  removeClassFromCells(className) {\n    const nodes \
= this.TABLE.querySelectorAll(`.${className}`);\n    for (let i = 0, len = \
nodes.length; i < len; i++) {\n      removeClass(nodes[i], className);\n    \
}\n  }\n  /**\n   * Refresh the table selection by re-rendering Selection \
instances connected with that instance.\n   *\n   * @param {boolean} fastDraw \
If fast drawing is enabled than additionally className clearing is applied.\n \
  */\n  refreshSelections(fastDraw) {\n    const {\n      wtSettings\n    } = \
this;\n    const {\n      selections\n    } = this.dataAccessObject;\n    if \
(!selections) {\n      return;\n    }\n    const highlights = \
Array.from(selections);\n    const len = highlights.length;\n    if \
(fastDraw) {\n      const classesToRemove = [];\n      for (let i = 0; i < \
len; i++) {\n        const {\n          highlightHeaderClassName,\n          \
highlightRowClassName,\n          highlightColumnClassName\n        } = \
highlights[i].settings;\n        const classNames = \
highlights[i].classNames;\n        const classNamesLength = \
classNames.length;\n        for (let j = 0; j < classNamesLength; j++) {\n    \
      if (!classesToRemove.includes(classNames[j])) {\n            \
classesToRemove.push(classNames[j]);\n          }\n        }\n        if \
(highlightHeaderClassName && \
!classesToRemove.includes(highlightHeaderClassName)) {\n          \
classesToRemove.push(highlightHeaderClassName);\n        }\n        if \
(highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) \
{\n          classesToRemove.push(highlightRowClassName);\n        }\n        \
if (highlightColumnClassName && \
!classesToRemove.includes(highlightColumnClassName)) {\n          \
classesToRemove.push(highlightColumnClassName);\n        }\n      }\n      \
const additionalClassesToRemove = \
wtSettings.getSetting(\"onBeforeRemoveCellClassNames\");\n      if \
(Array.isArray(additionalClassesToRemove)) {\n        for (let i = 0; i < \
additionalClassesToRemove.length; i++) {\n          \
classesToRemove.push(additionalClassesToRemove[i]);\n        }\n      }\n     \
 const classesToRemoveLength = classesToRemove.length;\n      for (let i = 0; \
i < classesToRemoveLength; i++) {\n        \
this.removeClassFromCells(classesToRemove[i]);\n      }\n    }\n    for (let \
i = 0; i < len; i++) {\n      highlights[i].draw(this.facadeGetter(), \
fastDraw);\n    }\n  }\n  /**\n   * Get cell element at coords.\n   * \
Negative coords.row or coords.col are used to retrieve header cells. If there \
are multiple header levels, the\n   * negative value corresponds to the \
distance from the working area. For example, when there are 3 levels of \
column\n   * headers, coords.col=-1 corresponds to the most inner header \
element, while coords.col=-3 corresponds to the\n   * outmost header \
element.\n   *\n   * In case an element for the coords is not rendered, the \
method returns an error code.\n   * To produce the error code, the input \
parameters are validated in the order in which they\n   * are given. Thus, if \
both the row and the column coords are out of the rendered bounds,\n   * the \
method returns the error code for the row.\n   *\n   * @param {CellCoords} \
coords The cell coordinates.\n   * @returns {HTMLElement|number} HTMLElement \
on success or Number one of the exit codes on error:\n   *  -1 row before \
viewport\n   *  -2 row after viewport\n   *  -3 column before viewport\n   *  \
-4 column after viewport.\n   */\n  getCell(coords) {\n    let row = \
coords.row;\n    let column = coords.col;\n    const hookResult = \
this.wtSettings.getSetting(\"onModifyGetCellCoords\", row, column);\n    if \
(hookResult && Array.isArray(hookResult)) {\n      [row, column] = \
hookResult;\n    }\n    if (this.isRowBeforeRenderedRows(row)) {\n      \
return -1;\n    } else if (this.isRowAfterRenderedRows(row)) {\n      return \
-2;\n    } else if (this.isColumnBeforeRenderedColumns(column)) {\n      \
return -3;\n    } else if (this.isColumnAfterRenderedColumns(column)) {\n     \
 return -4;\n    }\n    const TR = this.getRow(row);\n    if (!TR && row >= \
0) {\n      throw new Error(\"TR was expected to be rendered but is not\");\n \
   }\n    const TD = \
TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)]\
;\n    if (!TD && column >= 0) {\n      throw new Error(\"TD or TH was \
expected to be rendered but is not\");\n    }\n    return TD;\n  }\n  /**\n   \
* Get the DOM element of the row with the provided index.\n   *\n   * @param \
{number} rowIndex Row index.\n   * @returns {HTMLTableRowElement|boolean} \
Return the row's DOM element or `false` if the row with the provided\n   * \
index doesn't exist.\n   */\n  getRow(rowIndex) {\n    let renderedRowIndex = \
null;\n    let parentElement = null;\n    if (rowIndex < 0) {\n      var \
_this$rowFilter;\n      renderedRowIndex = (_this$rowFilter = this.rowFilter) \
=== null || _this$rowFilter === void 0 ? void 0 : \
_this$rowFilter.sourceRowToVisibleColHeadedRow(rowIndex);\n      \
parentElement = this.THEAD;\n    } else {\n      var _this$rowFilter2;\n      \
renderedRowIndex = (_this$rowFilter2 = this.rowFilter) === null || \
_this$rowFilter2 === void 0 ? void 0 : \
_this$rowFilter2.sourceToRendered(rowIndex);\n      parentElement = \
this.TBODY;\n    }\n    if (renderedRowIndex !== void 0 && parentElement !== \
void 0) {\n      if (parentElement.childNodes.length < renderedRowIndex + 1) \
{\n        return false;\n      } else {\n        return \
parentElement.childNodes[renderedRowIndex];\n      }\n    } else {\n      \
return false;\n    }\n  }\n  /**\n   * GetColumnHeader.\n   *\n   * @param \
{number} col Column index.\n   * @param {number} [level=0] Header level (0 = \
most distant to the table).\n   * @returns {object} HTMLElement on success or \
undefined on error.\n   */\n  getColumnHeader(col) {\n    let level = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    \
const TR = this.THEAD.childNodes[level];\n    return TR === null || TR === \
void 0 ? void 0 : \
TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n \
 }\n  /**\n   * Gets all columns headers (TH elements) from the table.\n   \
*\n   * @param {number} column A source column index.\n   * @returns \
{HTMLTableCellElement[]}\n   */\n  getColumnHeaders(column) {\n    const THs \
= [];\n    const visibleColumn = \
this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n    \
this.THEAD.childNodes.forEach((TR) => {\n      const TH = \
TR.childNodes[visibleColumn];\n      if (TH) {\n        THs.push(TH);\n      \
}\n    });\n    return THs;\n  }\n  /**\n   * GetRowHeader.\n   *\n   * \
@param {number} row Row index.\n   * @param {number} [level=0] Header level \
(0 = most distant to the table).\n   * @returns {HTMLElement} HTMLElement on \
success or Number one of the exit codes on error: `null table doesn't have\n  \
 *   row headers`.\n   */\n  getRowHeader(row) {\n    let level = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    if \
(this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n      \
return;\n    }\n    const rowHeadersCount = \
this.wtSettings.getSetting(\"rowHeaders\").length;\n    if (level >= \
rowHeadersCount) {\n      return;\n    }\n    const TR = \
this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    return TR \
=== null || TR === void 0 ? void 0 : TR.childNodes[level];\n  }\n  /**\n   * \
Gets all rows headers (TH elements) from the table.\n   *\n   * @param \
{number} row A source row index.\n   * @returns {HTMLTableCellElement[]}\n   \
*/\n  getRowHeaders(row) {\n    if \
(this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n      \
return [];\n    }\n    const THs = [];\n    const rowHeadersCount = \
this.wtSettings.getSetting(\"rowHeaders\").length;\n    for (let \
renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) \
{\n      const TR = \
this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      const TH \
= TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n  \
    if (TH) {\n        THs.push(TH);\n      }\n    }\n    return THs;\n  }\n  \
/**\n   * Returns cell coords object for a given TD (or a child element of a \
TD element).\n   *\n   * @param {HTMLTableCellElement} TD A cell DOM element \
(or a child of one).\n   * @returns {CellCoords|null} The coordinates of the \
provided TD element (or the closest TD element) or null, if the\n   *   \
provided element is not applicable.\n   */\n  getCoords(TD) {\n    let \
cellElement = TD;\n    if (cellElement.nodeName !== \"TD\" && \
cellElement.nodeName !== \"TH\") {\n      cellElement = closest(cellElement, \
[\"TD\", \"TH\"]);\n    }\n    if (cellElement === null) {\n      return \
null;\n    }\n    const TR = cellElement.parentNode;\n    const CONTAINER = \
TR.parentNode;\n    let row = index(TR);\n    let col = \
cellElement.cellIndex;\n    if \
(overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, \
this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, \
this.wtRootElement)) {\n      if (CONTAINER.nodeName === \"THEAD\") {\n       \
 row -= CONTAINER.childNodes.length;\n      }\n    } else if \
(overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, \
this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, \
this.wtRootElement)) {\n      const totalRows = \
this.wtSettings.getSetting(\"totalRows\");\n      row = totalRows - \
CONTAINER.childNodes.length + row;\n    } else if (CONTAINER === this.THEAD) \
{\n      row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n    } \
else {\n      row = this.rowFilter.renderedToSource(row);\n    }\n    if \
(overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, \
this.wtRootElement) || overlayContainsElement(CLONE_INLINE_START, \
cellElement, this.wtRootElement) || \
overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, \
this.wtRootElement)) {\n      col = this.columnFilter.offsettedTH(col);\n    \
} else {\n      col = \
this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n    }\n    \
return this.wot.createCellCoords(row, col);\n  }\n  /**\n   * Check if any of \
the rendered rows is higher than expected, and if so, cache them.\n   */\n  \
markOversizedRows() {\n    if \
(this.wtSettings.getSetting(\"externalRowCalculator\")) {\n      return;\n    \
}\n    let rowCount = this.TBODY.childNodes.length;\n    const \
expectedTableHeight = rowCount * \
this.wtSettings.getSetting(\"defaultRowHeight\");\n    const \
actualTableHeight = innerHeight(this.TBODY) - 1;\n    let \
previousRowHeight;\n    let rowInnerHeight;\n    let sourceRowIndex;\n    let \
currentTr;\n    let rowHeader;\n    if (expectedTableHeight === \
actualTableHeight && !this.wtSettings.getSetting(\"fixedRowsBottom\")) {\n    \
  return;\n    }\n    while (rowCount) {\n      rowCount -= 1;\n      \
sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n      \
previousRowHeight = this.getRowHeight(sourceRowIndex);\n      currentTr = \
this.getTrForRow(sourceRowIndex);\n      rowHeader = \
currentTr.querySelector(\"th\");\n      if (rowHeader) {\n        \
rowInnerHeight = innerHeight(rowHeader);\n      } else {\n        \
rowInnerHeight = innerHeight(currentTr) - 1;\n      }\n      if \
(!previousRowHeight && this.wtSettings.getSetting(\"defaultRowHeight\") < \
rowInnerHeight || previousRowHeight < rowInnerHeight) {\n        \
rowInnerHeight += 1;\n        \
this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = \
rowInnerHeight;\n      }\n    }\n  }\n  /**\n   * @param {number} row The \
visual row index.\n   * @returns {HTMLTableElement}\n   */\n  \
getTrForRow(row) {\n    return \
this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n  }\n  /**\n   \
* Checks if the column index (negative value from -1 to N) is rendered.\n   \
*\n   * @param {number} column The column index (negative value from -1 to \
N).\n   * @returns {boolean}\n   */\n  isColumnHeaderRendered(column) {\n    \
if (column >= 0) {\n      return false;\n    }\n    const rowHeaders = \
this.wtSettings.getSetting(\"rowHeaders\");\n    const rowHeadersCount = \
rowHeaders.length;\n    return Math.abs(column) <= rowHeadersCount;\n  }\n  \
/**\n   * Checks if the row index (negative value from -1 to N) is \
rendered.\n   *\n   * @param {number} row The row index (negative value from \
-1 to N).\n   * @returns {boolean}\n   */\n  isRowHeaderRendered(row) {\n    \
if (row >= 0) {\n      return false;\n    }\n    const columnHeaders = \
this.wtSettings.getSetting(\"columnHeaders\");\n    const columnHeadersCount \
= columnHeaders.length;\n    return Math.abs(row) <= columnHeadersCount;\n  \
}\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  \
/**\n   * Check if the given row index is lower than the index of the first \
row that\n   * is currently rendered and return TRUE in that case, or FALSE \
otherwise.\n   *\n   * Negative row index is used to check the columns' \
headers.\n   *\n   *  Headers\n   *           +--------------+                \
                     \[AHat]\224\202\n   *       -3  \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202                         \
            \[AHat]\224\202\n   *           +--------------+                  \
                   \[AHat]\224\202\n   *       -2  \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202                         \
            \[AHat]\224\202 TRUE\n   *           +--------------+             \
                        \[AHat]\224\202\n   *       -1  \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202                         \
            \[AHat]\224\202\n   *  Cells  +==================+                \
                   \[AHat]\224\202\n   *        0  \[AHat]\224\207    \
\[AHat]\224\207    \[AHat]\224\207    \[AHat]\224\207 <--- For fixedRowsTop: \
1            \[AHat]\224\202\n   *           +--------------+      the master \
overlay do       ---+ first rendered row (index 1)\n   *        1  \
\[AHat]\224\202 A2 \[AHat]\224\202 B2 \[AHat]\224\202 C2 \[AHat]\224\202      \
not render the first row.      \[AHat]\224\202\n   *           \
+--------------+                                     \[AHat]\224\202 FALSE\n  \
 *        2  \[AHat]\224\202 A3 \[AHat]\224\202 B3 \[AHat]\224\202 C3 \
\[AHat]\224\202                                     \[AHat]\224\202\n   *     \
      +--------------+                                  ---+ last rendered \
row\n   *                                                                \
\[AHat]\224\202\n   *                                                         \
       \[AHat]\224\202 FALSE\n   *\n   * @param {number} row The visual row \
index.\n   * @memberof Table#\n   * @function isRowBeforeRenderedRows\n   * \
@returns {boolean}\n   */\n  /* eslint-enable \
jsdoc/require-description-complete-sentence */\n  \
isRowBeforeRenderedRows(row) {\n    const first = \
this.getFirstRenderedRow();\n    if (row < 0 && first <= 0) {\n      return \
!this.isRowHeaderRendered(row);\n    }\n    return row < first;\n  }\n  /* \
eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * \
Check if the given column index is greater than the index of the last column \
that\n   * is currently rendered and return TRUE in that case, or FALSE \
otherwise.\n   *\n   * The negative row index is used to check the columns' \
headers. However,\n   * keep in mind that for negative indexes, the method \
always returns FALSE as\n   * it is not possible to render headers partially. \
The \"after\" index can not be\n   * lower than -1.\n   *\n   *  Headers\n   \
*           +--------------+                                     \
\[AHat]\224\202\n   *       -3  \[AHat]\224\202    \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202                                     \
\[AHat]\224\202\n   *           +--------------+                              \
       \[AHat]\224\202\n   *       -2  \[AHat]\224\202    \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202                                     \
\[AHat]\224\202 FALSE\n   *           +--------------+                        \
             \[AHat]\224\202\n   *       -1  \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202                         \
            \[AHat]\224\202\n   *  Cells  +==================+                \
                   \[AHat]\224\202\n   *        0  \[AHat]\224\207    \
\[AHat]\224\207    \[AHat]\224\207    \[AHat]\224\207 <--- For fixedRowsTop: \
1            \[AHat]\224\202\n   *           +--------------+      the master \
overlay do       ---+ first rendered row (index 1)\n   *        1  \
\[AHat]\224\202 A2 \[AHat]\224\202 B2 \[AHat]\224\202 C2 \[AHat]\224\202      \
not render the first rows      \[AHat]\224\202\n   *           \
+--------------+                                     \[AHat]\224\202 FALSE\n  \
 *        2  \[AHat]\224\202 A3 \[AHat]\224\202 B3 \[AHat]\224\202 C3 \
\[AHat]\224\202                                     \[AHat]\224\202\n   *     \
      +--------------+                                  ---+ last rendered \
row\n   *                                                                \
\[AHat]\224\202\n   *                                                         \
       \[AHat]\224\202 TRUE\n   *\n   * @param {number} row The visual row \
index.\n   * @memberof Table#\n   * @function isRowAfterRenderedRows\n   * \
@returns {boolean}\n   */\n  /* eslint-enable \
jsdoc/require-description-complete-sentence */\n  isRowAfterRenderedRows(row) \
{\n    return row > this.getLastRenderedRow();\n  }\n  /* eslint-disable \
jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the \
given column index is lower than the index of the first column that\n   * is \
currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n  \
 * Negative column index is used to check the rows' headers.\n   *\n   *      \
                      For fixedColumnsStart: 1 the master overlay\n   *       \
                     do not render this first columns.\n   *  Headers    -3   \
-2   -1    |\n   *           +----+----+----\[AHat]\225\221\[AHat]\224\204 \
\[AHat]\224\204 +------+------+\n   *           \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\225\221    \[AHat]\224\202  B1  \
\[AHat]\224\202  C1  \[AHat]\224\202\n   *           \
+--------------\[AHat]\225\221\[AHat]\224\204 \[AHat]\224\204 \
--------------\[AHat]\224\202\n   *           \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\225\221    \[AHat]\224\202  B2  \
\[AHat]\224\202  C2  \[AHat]\224\202\n   *           \
+--------------\[AHat]\225\221\[AHat]\224\204 \[AHat]\224\204 \
--------------\[AHat]\224\202\n   *           \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\225\221    \[AHat]\224\202  B3  \
\[AHat]\224\202  C3  \[AHat]\224\202\n   *           \
+----+----+----\[AHat]\225\221\[AHat]\224\204 \[AHat]\224\204 \
+------+------+\n   *                               \[AHat]\225\[CenterDot]   \
          \[AHat]\225\[CenterDot]\n   *      \
-------------------------+-------------+---------------->\n   *          TRUE \
            first    FALSE   last         FALSE\n   *                         \
  rendered         rendered\n   *                           column           \
column\n   *\n   * @param {number} column The visual column index.\n   * \
@memberof Table#\n   * @function isColumnBeforeRenderedColumns\n   * @returns \
{boolean}\n   */\n  /* eslint-enable \
jsdoc/require-description-complete-sentence */\n  \
isColumnBeforeRenderedColumns(column) {\n    const first = \
this.getFirstRenderedColumn();\n    if (column < 0 && first <= 0) {\n      \
return !this.isColumnHeaderRendered(column);\n    }\n    return column < \
first;\n  }\n  /* eslint-disable jsdoc/require-description-complete-sentence \
*/\n  /**\n   * Check if the given column index is greater than the index of \
the last column that\n   * is currently rendered and return TRUE in that \
case, or FALSE otherwise.\n   *\n   * The negative column index is used to \
check the rows' headers. However,\n   * keep in mind that for negative \
indexes, the method always returns FALSE as\n   * it is not possible to \
render headers partially. The \"after\" index can not be\n   * lower than \
-1.\n   *\n   *                            For fixedColumnsStart: 1 the \
master overlay\n   *                            do not render this first \
columns.\n   *  Headers    -3   -2   -1    |\n   *           \
+----+----+----\[AHat]\225\221\[AHat]\224\204 \[AHat]\224\204 \
+------+------+\n   *           \[AHat]\224\202    \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\225\221    \[AHat]\224\202  B1  \[AHat]\224\202  \
C1  \[AHat]\224\202\n   *           \
+--------------\[AHat]\225\221\[AHat]\224\204 \[AHat]\224\204 \
--------------\[AHat]\224\202\n   *           \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\225\221    \[AHat]\224\202  B2  \
\[AHat]\224\202  C2  \[AHat]\224\202\n   *           \
+--------------\[AHat]\225\221\[AHat]\224\204 \[AHat]\224\204 \
--------------\[AHat]\224\202\n   *           \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\225\221    \[AHat]\224\202  B3  \
\[AHat]\224\202  C3  \[AHat]\224\202\n   *           \
+----+----+----\[AHat]\225\221\[AHat]\224\204 \[AHat]\224\204 \
+------+------+\n   *                               \[AHat]\225\[CenterDot]   \
          \[AHat]\225\[CenterDot]\n   *      \
-------------------------+-------------+---------------->\n   *          \
FALSE             first    FALSE   last         TRUE\n   *                    \
       rendered         rendered\n   *                           column       \
    column\n   *\n   * @param {number} column The visual column index.\n   * \
@memberof Table#\n   * @function isColumnAfterRenderedColumns\n   * @returns \
{boolean}\n   */\n  /* eslint-enable \
jsdoc/require-description-complete-sentence */\n  \
isColumnAfterRenderedColumns(column) {\n    return this.columnFilter && \
column > this.getLastRenderedColumn();\n  }\n  isColumnAfterViewport(column) \
{\n    return this.columnFilter && column > this.getLastVisibleColumn();\n  \
}\n  isRowAfterViewport(row) {\n    return this.rowFilter && row > \
this.getLastVisibleRow();\n  }\n  isColumnBeforeViewport(column) {\n    \
return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && \
column >= 0;\n  }\n  isLastRowFullyVisible() {\n    return \
this.getLastVisibleRow() === this.getLastRenderedRow();\n  }\n  \
isLastColumnFullyVisible() {\n    return this.getLastVisibleColumn() === \
this.getLastRenderedColumn();\n  }\n  allRowsInViewport() {\n    return \
this.wtSettings.getSetting(\"totalRows\") === this.getVisibleRowsCount();\n  \
}\n  allColumnsInViewport() {\n    return \
this.wtSettings.getSetting(\"totalColumns\") === \
this.getVisibleColumnsCount();\n  }\n  /**\n   * Checks if any of the row's \
cells content exceeds its initial height, and if so, returns the oversized \
height.\n   *\n   * @param {number} sourceRow The physical row index.\n   * \
@returns {number}\n   */\n  getRowHeight(sourceRow) {\n    return \
this.rowUtils.getHeight(sourceRow);\n  }\n  /**\n   * @param {number} level \
The column level.\n   * @returns {number}\n   */\n  \
getColumnHeaderHeight(level) {\n    return \
this.columnUtils.getHeaderHeight(level);\n  }\n  /**\n   * @param {number} \
sourceColumn The physical column index.\n   * @returns {number}\n   */\n  \
getColumnWidth(sourceColumn) {\n    return \
this.columnUtils.getWidth(sourceColumn);\n  }\n  /**\n   * @param {number} \
sourceColumn The physical column index.\n   * @returns {number}\n   */\n  \
getStretchedColumnWidth(sourceColumn) {\n    return \
this.columnUtils.getStretchedColumnWidth(sourceColumn);\n  }\n  /**\n   * \
Checks if the table has defined size. It returns `true` when the table has \
width and height\n   * set bigger than `0px`.\n   *\n   * @returns \
{boolean}\n   */\n  hasDefinedSize() {\n    return this.hasTableHeight && \
this.hasTableWidth;\n  }\n  /**\n   * Gets table's width. The returned width \
is the width of the rendered cells that fit in the\n   * current viewport. \
The value may change depends on the viewport position (scroll position).\n   \
*\n   * @returns {number}\n   */\n  getWidth() {\n    return \
outerWidth(this.TABLE);\n  }\n  /**\n   * Gets table's height. The returned \
height is the height of the rendered cells that fit in the\n   * current \
viewport. The value may change depends on the viewport position (scroll \
position).\n   *\n   * @returns {number}\n   */\n  getHeight() {\n    return \
outerHeight(this.TABLE);\n  }\n  /**\n   * Gets table's total width. The \
returned width is the width of all rendered cells (including headers)\n   * \
that can be displayed in the table.\n   *\n   * @returns {number}\n   */\n  \
getTotalWidth() {\n    const width = outerWidth(this.hider);\n    return \
width !== 0 ? width : this.getWidth();\n  }\n  /**\n   * Gets table's total \
height. The returned height is the height of all rendered cells (including \
headers)\n   * that can be displayed in the table.\n   *\n   * @returns \
{number}\n   */\n  getTotalHeight() {\n    const height = \
outerHeight(this.hider);\n    return height !== 0 ? height : \
this.getHeight();\n  }\n  /**\n   * Checks if the table is visible. It \
returns `true` when the holder element (or its parents)\n   * has CSS \
'display' property different than 'none'.\n   *\n   * @returns {boolean}\n   \
*/\n  isVisible() {\n    return isVisible(this.TABLE);\n  }\n  /**\n   * \
Modify row header widths provided by user in class contructor.\n   *\n   * \
@private\n   * @param {Function} rowHeaderWidthFactory The function which can \
provide default width values for rows..\n   * @returns {number}\n   */\n  \
_modifyRowHeaderWidth(rowHeaderWidthFactory) {\n    let widths = \
isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n    if \
(Array.isArray(widths)) {\n      widths = [...widths];\n      \
widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length \
- 1]);\n    } else {\n      widths = this._correctRowHeaderWidth(widths);\n   \
 }\n    return widths;\n  }\n  /**\n   * Correct row header width if \
necessary.\n   *\n   * @private\n   * @param {number} width The width to \
process.\n   * @returns {number}\n   */\n  _correctRowHeaderWidth(width) {\n  \
  let rowHeaderWidth = width;\n    if (typeof width !== \"number\") {\n      \
rowHeaderWidth = this.wtSettings.getSetting(\"defaultColumnWidth\");\n    }\n \
   if (this.correctHeaderWidth) {\n      rowHeaderWidth += 1;\n    }\n    \
return rowHeaderWidth;\n  }\n};\nvar table_default = Table;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/mixin/stickyRowsBott\
om.mjs\nvar MIXIN_NAME = \"stickyRowsBottom\";\nvar stickyRowsBottom = {\n  \
/**\n   * Get the source index of the first rendered row. If no rows are \
rendered, returns an error code: -1.\n   *\n   * @returns {number}\n   * \
@this Table\n   */\n  getFirstRenderedRow() {\n    const totalRows = \
this.wtSettings.getSetting(\"totalRows\");\n    const fixedRowsBottom = \
this.wtSettings.getSetting(\"fixedRowsBottom\");\n    const index2 = \
totalRows - fixedRowsBottom;\n    if (totalRows === 0 || fixedRowsBottom === \
0) {\n      return -1;\n    }\n    if (index2 < 0) {\n      return 0;\n    \
}\n    return index2;\n  },\n  /**\n   * Get the source index of the first \
row fully visible in the viewport. If no rows are fully visible, returns an \
error code: -1.\n   * Assumes that all rendered rows are fully visible.\n   \
*\n   * @returns {number}\n   * @this Table\n   */\n  getFirstVisibleRow() \
{\n    return this.getFirstRenderedRow();\n  },\n  /**\n   * Get the source \
index of the last rendered row. If no rows are rendered, returns an error \
code: -1.\n   *\n   * @returns {number}\n   * @this Table\n   */\n  \
getLastRenderedRow() {\n    return this.wtSettings.getSetting(\"totalRows\") \
- 1;\n  },\n  /**\n   * Get the source index of the last row fully visible in \
the viewport. If no rows are fully visible, returns an error code: -1.\n   * \
Assumes that all rendered rows are fully visible.\n   *\n   * @returns \
{number}\n   * @this Table\n   */\n  getLastVisibleRow() {\n    return \
this.getLastRenderedRow();\n  },\n  /**\n   * Get the number of rendered \
rows.\n   *\n   * @returns {number}\n   * @this Table\n   */\n  \
getRenderedRowsCount() {\n    const totalRows = \
this.wtSettings.getSetting(\"totalRows\");\n    return \
Math.min(this.wtSettings.getSetting(\"fixedRowsBottom\"), totalRows);\n  },\n \
 /**\n   * Get the number of fully visible rows in the viewport.\n   * \
Assumes that all rendered rows are fully visible.\n   *\n   * @returns \
{number}\n   * @this Table\n   */\n  getVisibleRowsCount() {\n    return \
this.getRenderedRowsCount();\n  }\n};\ndefineGetter(stickyRowsBottom, \
\"MIXIN_NAME\", MIXIN_NAME, {\n  writable: false,\n  enumerable: \
false\n});\nvar stickyRowsBottom_default = stickyRowsBottom;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/mixin/stickyColumnsS\
tart.mjs\nvar MIXIN_NAME2 = \"stickyColumnsStart\";\nvar stickyColumnsStart = \
{\n  /**\n   * Get the source index of the first rendered column. If no \
columns are rendered, returns an error code: -1.\n   *\n   * @returns \
{number}\n   * @this Table\n   */\n  getFirstRenderedColumn() {\n    const \
totalColumns = this.wtSettings.getSetting(\"totalColumns\");\n    if \
(totalColumns === 0) {\n      return -1;\n    }\n    return 0;\n  },\n  /**\n \
  * Get the source index of the first column fully visible in the viewport. \
If no columns are fully visible, returns an error code: -1.\n   * Assumes \
that all rendered columns are fully visible.\n   *\n   * @returns {number}\n  \
 * @this Table\n   */\n  getFirstVisibleColumn() {\n    return \
this.getFirstRenderedColumn();\n  },\n  /**\n   * Get the source index of the \
last rendered column. If no columns are rendered, returns an error code: \
-1.\n   *\n   * @returns {number}\n   * @this Table\n   */\n  \
getLastRenderedColumn() {\n    return this.getRenderedColumnsCount() - 1;\n  \
},\n  /**\n   * Get the source index of the last column fully visible in the \
viewport. If no columns are fully visible, returns an error code: -1.\n   * \
Assumes that all rendered columns are fully visible.\n   *\n   * @returns \
{number}\n   * @this Table\n   */\n  getLastVisibleColumn() {\n    return \
this.getLastRenderedColumn();\n  },\n  /**\n   * Get the number of rendered \
columns.\n   *\n   * @returns {number}\n   * @this Table\n   */\n  \
getRenderedColumnsCount() {\n    const totalColumns = \
this.wtSettings.getSetting(\"totalColumns\");\n    return \
Math.min(this.wtSettings.getSetting(\"fixedColumnsStart\"), totalColumns);\n  \
},\n  /**\n   * Get the number of fully visible columns in the viewport.\n   \
* Assumes that all rendered columns are fully visible.\n   *\n   * @returns \
{number}\n   * @this Table\n   */\n  getVisibleColumnsCount() {\n    return \
this.getRenderedColumnsCount();\n  }\n};\ndefineGetter(stickyColumnsStart, \
\"MIXIN_NAME\", MIXIN_NAME2, {\n  writable: false,\n  enumerable: \
false\n});\nvar stickyColumnsStart_default = stickyColumnsStart;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/bottomInlineStartCor\
ner.mjs\nvar BottomInlineStartCornerOverlayTable = class extends \
table_default {\n  /**\n   * @param {TableDao} dataAccessObject The data \
access object.\n   * @param {FacadeGetter} facadeGetter Function which return \
proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   \
* @param {Settings} wtSettings The Walkontable settings.\n   */\n  \
constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {\n    \
super(dataAccessObject, facadeGetter, domBindings, wtSettings, \
CLONE_BOTTOM_INLINE_START_CORNER);\n  \
}\n};\nmixin(BottomInlineStartCornerOverlayTable, \
stickyRowsBottom_default);\nmixin(BottomInlineStartCornerOverlayTable, \
stickyColumnsStart_default);\nvar bottomInlineStartCorner_default = \
BottomInlineStartCornerOverlayTable;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/overlay/constants.mjs\nvar \
CLONE_TOP = \"top\";\nvar CLONE_BOTTOM = \"bottom\";\nvar CLONE_INLINE_START \
= \"inline_start\";\nvar CLONE_TOP_INLINE_START_CORNER = \
\"top_inline_start_corner\";\nvar CLONE_BOTTOM_INLINE_START_CORNER = \
\"bottom_inline_start_corner\";\nvar CLONE_TYPES = [CLONE_TOP, CLONE_BOTTOM, \
CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, \
CLONE_BOTTOM_INLINE_START_CORNER];\nvar CLONE_CLASS_NAMES = /* @__PURE__ */ \
new Map([[CLONE_TOP, `ht_clone_${CLONE_TOP}`], [CLONE_BOTTOM, \
`ht_clone_${CLONE_BOTTOM}`], [CLONE_INLINE_START, \
`ht_clone_${CLONE_INLINE_START} ht_clone_left`], \
[CLONE_TOP_INLINE_START_CORNER, `ht_clone_${CLONE_TOP_INLINE_START_CORNER} \
ht_clone_top_left_corner`], [CLONE_BOTTOM_INLINE_START_CORNER, \
`ht_clone_${CLONE_BOTTOM_INLINE_START_CORNER} \
ht_clone_bottom_left_corner`]]);\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/scroll.mjs\nfunction \
_defineProperty4(obj, key, value) {\n  key = _toPropertyKey4(key);\n  if (key \
in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: true, \
configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  \
}\n  return obj;\n}\nfunction _toPropertyKey4(arg) {\n  var key = \
_toPrimitive4(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive4(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar Scroll = class {\n  /**\n   * @param {ScrollDao} \
dataAccessObject Tha data access object.\n   */\n  \
constructor(dataAccessObject) {\n    _defineProperty4(this, \
\"dataAccessObject\", void 0);\n    _defineProperty4(this, \
\"lastScrolledColumnPos\", -1);\n    _defineProperty4(this, \
\"lastScrolledRowPos\", -1);\n    this.dataAccessObject = dataAccessObject;\n \
 }\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} \
coords The cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, \
viewport is scrolled to show the cell on the top of the table.\n   * @param \
{boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on \
the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, \
viewport is scrolled to show the cell on the bottom of the table.\n   * \
@param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the \
cell on the left of the table.\n   * @returns {boolean}\n   */\n  \
scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n  \
  const scrolledHorizontally = this.scrollViewportHorizontally(coords.col, \
snapToRight, snapToLeft);\n    const scrolledVertically = \
this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n    \
return scrolledHorizontally || scrolledVertically;\n  }\n  /**\n   * Scrolls \
viewport to a column.\n   *\n   * @param {number} column Visual column \
index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled \
to show the cell on the right of the table.\n   * @param {boolean} \
[snapToLeft] If `true`, viewport is scrolled to show the cell on the left of \
the table.\n   * @returns {boolean}\n   */\n  \
scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    const {\n  \
    drawn,\n      totalColumns\n    } = this.dataAccessObject;\n    if \
(!drawn || !Number.isInteger(column) || column < 0 || column > totalColumns) \
{\n      return false;\n    }\n    const firstVisibleColumn = \
this.getFirstVisibleColumn();\n    const lastVisibleColumn = \
this.getLastVisibleColumn();\n    const autoSnapping = snapToRight === void 0 \
&& snapToLeft === void 0;\n    const {\n      fixedColumnsStart,\n      \
inlineStartOverlay\n    } = this.dataAccessObject;\n    if (autoSnapping && \
column < fixedColumnsStart) {\n      return false;\n    }\n    let result = \
false;\n    if (firstVisibleColumn === -1) {\n      result = \
inlineStartOverlay.scrollTo(column, autoSnapping ? column > \
this.lastScrolledColumnPos : snapToRight);\n    } else if (autoSnapping && \
(column < firstVisibleColumn || column > lastVisibleColumn) || !autoSnapping) \
{\n      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > \
lastVisibleColumn : snapToRight);\n    }\n    if (result) {\n      \
this.lastScrolledColumnPos = column;\n    }\n    return result;\n  }\n  /**\n \
  * Scrolls viewport to a row.\n   *\n   * @param {number} row Visual row \
index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to \
show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] \
If `true`, viewport is scrolled to show the cell on the bottom of the \
table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, \
snapToTop, snapToBottom) {\n    const {\n      drawn,\n      totalRows\n    } \
= this.dataAccessObject;\n    if (!drawn || !Number.isInteger(row) || row < 0 \
|| row > totalRows) {\n      return false;\n    }\n    const firstVisibleRow \
= this.getFirstVisibleRow();\n    const lastVisibleRow = \
this.getLastVisibleRow();\n    const autoSnapping = snapToTop === void 0 && \
snapToBottom === void 0;\n    const {\n      fixedRowsBottom,\n      \
fixedRowsTop,\n      topOverlay\n    } = this.dataAccessObject;\n    if \
(autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - \
1)) {\n      return false;\n    }\n    let result = false;\n    if \
(firstVisibleRow === -1) {\n      result = topOverlay.scrollTo(row, \
autoSnapping ? row > this.lastScrolledRowPos : snapToBottom);\n    } else if \
(autoSnapping && (row < firstVisibleRow || row > lastVisibleRow) || \
!autoSnapping) {\n      result = topOverlay.scrollTo(row, autoSnapping ? row \
> lastVisibleRow : snapToBottom);\n    }\n    if (result) {\n      \
this.lastScrolledRowPos = row;\n    }\n    return result;\n  }\n  /**\n   * \
Get first visible row based on virtual dom and how table is visible in \
browser window viewport.\n   *\n   * @returns {number}\n   */\n  \
getFirstVisibleRow() {\n    const {\n      topOverlay,\n      wtTable,\n      \
wtViewport,\n      totalRows,\n      fixedRowsTop,\n      rootWindow\n    } = \
this.dataAccessObject;\n    let firstVisibleRow = \
wtTable.getFirstVisibleRow();\n    if (topOverlay.mainTableScrollableElement \
=== rootWindow) {\n      const rootElementOffset = \
offset(wtTable.wtRootElement);\n      const totalTableHeight = \
innerHeight(wtTable.hider);\n      const windowHeight = \
innerHeight(rootWindow);\n      const windowScrollTop = \
getScrollTop(rootWindow, rootWindow);\n      if (rootElementOffset.top + \
totalTableHeight - windowHeight <= windowScrollTop) {\n        let rowsHeight \
= wtViewport.getColumnHeaderHeight();\n        rowsHeight += \
topOverlay.sumCellSizes(0, fixedRowsTop);\n        for (let row = totalRows; \
row > 0; row--) {\n          rowsHeight += topOverlay.sumCellSizes(row - 1, \
row);\n          if (rootElementOffset.top + totalTableHeight - rowsHeight <= \
windowScrollTop) {\n            firstVisibleRow = row;\n            break;\n  \
        }\n        }\n      }\n    }\n    return firstVisibleRow;\n  }\n  \
/**\n   * Get last visible row based on virtual dom and how table is visible \
in browser window viewport.\n   *\n   * @returns {number}\n   */\n  \
getLastVisibleRow() {\n    const {\n      topOverlay,\n      wtTable,\n      \
wtViewport,\n      totalRows,\n      rootWindow\n    } = \
this.dataAccessObject;\n    let lastVisibleRow = \
wtTable.getLastVisibleRow();\n    if (topOverlay.mainTableScrollableElement \
=== rootWindow) {\n      const rootElementOffset = \
offset(wtTable.wtRootElement);\n      const windowScrollTop = \
getScrollTop(rootWindow, rootWindow);\n      if (rootElementOffset.top > \
windowScrollTop) {\n        const windowHeight = innerHeight(rootWindow);\n   \
     let rowsHeight = wtViewport.getColumnHeaderHeight();\n        for (let \
row = 1; row <= totalRows; row++) {\n          rowsHeight += \
topOverlay.sumCellSizes(row - 1, row);\n          if (rootElementOffset.top + \
rowsHeight - windowScrollTop >= windowHeight) {\n            lastVisibleRow = \
row - 2;\n            break;\n          }\n        }\n      }\n    }\n    \
return lastVisibleRow;\n  }\n  /**\n   * Get first visible column based on \
virtual dom and how table is visible in browser window viewport.\n   *\n   * \
@returns {number}\n   */\n  getFirstVisibleColumn() {\n    const {\n      \
inlineStartOverlay,\n      wtTable,\n      wtViewport,\n      totalColumns,\n \
     rootWindow\n    } = this.dataAccessObject;\n    let firstVisibleColumn = \
wtTable.getFirstVisibleColumn();\n    if \
(inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n      const \
rootElementOffset = offset(wtTable.wtRootElement);\n      const \
totalTableWidth = innerWidth(wtTable.hider);\n      const windowWidth = \
innerWidth(rootWindow);\n      const windowScrollLeft = \
Math.abs(getScrollLeft(rootWindow, rootWindow));\n      if \
(rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) \
{\n        let columnsWidth = wtViewport.getRowHeaderWidth();\n        for \
(let column = totalColumns; column > 0; column--) {\n          columnsWidth \
+= inlineStartOverlay.sumCellSizes(column - 1, column);\n          if \
(rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) \
{\n            firstVisibleColumn = column;\n            break;\n          \
}\n        }\n      }\n    }\n    return firstVisibleColumn;\n  }\n  /**\n   \
* Get last visible column based on virtual dom and how table is visible in \
browser window viewport.\n   *\n   * @returns {number}\n   */\n  \
getLastVisibleColumn() {\n    const {\n      wtSettings,\n      \
inlineStartOverlay,\n      wtTable,\n      wtViewport,\n      totalColumns,\n \
     rootWindow\n    } = this.dataAccessObject;\n    let lastVisibleColumn = \
wtTable.getLastVisibleColumn();\n    if \
(inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n      const \
isRtl = wtSettings.getSetting(\"rtlMode\");\n      let \
inlineStartRootElementOffset = null;\n      if (isRtl) {\n        const \
tableRect = wtTable.TABLE.getBoundingClientRect();\n        const \
rootDocument = this.dataAccessObject.rootWindow.document;\n        const \
docOffsetWidth = rootDocument.documentElement.offsetWidth;\n        \
inlineStartRootElementOffset = Math.abs(tableRect.right - docOffsetWidth);\n  \
    } else {\n        const rootElementOffset = \
offset(wtTable.wtRootElement);\n        inlineStartRootElementOffset = \
rootElementOffset.left;\n      }\n      const windowScrollLeft = \
Math.abs(getScrollLeft(rootWindow, rootWindow));\n      if \
(inlineStartRootElementOffset > windowScrollLeft) {\n        const \
windowWidth = innerWidth(rootWindow);\n        let columnsWidth = \
wtViewport.getRowHeaderWidth();\n        for (let column = 1; column <= \
totalColumns; column++) {\n          columnsWidth += \
inlineStartOverlay.sumCellSizes(column - 1, column);\n          if \
(inlineStartRootElementOffset + columnsWidth - windowScrollLeft >= \
windowWidth) {\n            lastVisibleColumn = column - 2;\n            \
break;\n          }\n        }\n      }\n    }\n    return \
lastVisibleColumn;\n  }\n};\nvar scroll_default = Scroll;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/core/_base.mjs\nfunction \
_defineProperty5(obj, key, value) {\n  key = _toPropertyKey5(key);\n  if (key \
in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: true, \
configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  \
}\n  return obj;\n}\nfunction _toPropertyKey5(arg) {\n  var key = \
_toPrimitive5(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive5(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar CoreAbstract = class {\n  get eventManager() {\n    \
return new eventManager_default(this);\n  }\n  /**\n   * @param \
{HTMLTableElement} table Main table.\n   * @param {Settings} settings The \
Walkontable settings.\n   */\n  constructor(table, settings) {\n    \
_defineProperty5(this, \"wtTable\", void 0);\n    _defineProperty5(this, \
\"wtScroll\", void 0);\n    _defineProperty5(this, \"wtViewport\", void 0);\n \
   _defineProperty5(this, \"wtOverlays\", void 0);\n    \
_defineProperty5(this, \"selections\", void 0);\n    _defineProperty5(this, \
\"wtEvent\", void 0);\n    _defineProperty5(this, \"guid\", \
`wt_${randomString()}`);\n    _defineProperty5(this, \"drawInterrupted\", \
false);\n    _defineProperty5(this, \"drawn\", false);\n    \
_defineProperty5(this, \"domBindings\", void 0);\n    _defineProperty5(this, \
\"wtSettings\", void 0);\n    this.domBindings = {\n      rootTable: table,\n \
     rootDocument: table.ownerDocument,\n      rootWindow: \
table.ownerDocument.defaultView\n    };\n    this.wtSettings = settings;\n    \
this.wtScroll = new scroll_default(this.createScrollDao());\n  }\n  \
findOriginalHeaders() {\n    const originalHeaders = [];\n    if \
(this.wtTable.THEAD.childNodes.length && \
this.wtTable.THEAD.childNodes[0].childNodes.length) {\n      for (let c = 0, \
clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\n \
       \
originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML\
);\n      }\n      if (!this.wtSettings.getSetting(\"columnHeaders\").length) \
{\n        this.wtSettings.update(\"columnHeaders\", [function(column, TH) \
{\n          fastInnerText(TH, originalHeaders[column]);\n        }]);\n      \
}\n    }\n  }\n  /**\n   * Creates and returns the CellCoords object.\n   *\n \
  * @param {*} row The row index.\n   * @param {*} column The column index.\n \
  * @returns {CellCoords}\n   */\n  createCellCoords(row, column) {\n    \
return new coords_default(row, column, \
this.wtSettings.getSetting(\"rtlMode\"));\n  }\n  /**\n   * Creates and \
returns the CellRange object.\n   *\n   * @param {CellCoords} highlight The \
highlight coordinates.\n   * @param {CellCoords} from The from coordinates.\n \
  * @param {CellCoords} to The to coordinates.\n   * @returns {CellRange}\n   \
*/\n  createCellRange(highlight, from, to) {\n    return new \
range_default(highlight, from, to, \
this.wtSettings.getSetting(\"rtlMode\"));\n  }\n  /**\n   * Force rerender of \
Walkontable.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try \
to refresh only the positions of borders without rerendering\n   *            \
                       the data. It will only work if Table.draw() does not \
force\n   *                                   rendering anyway.\n   * \
@returns {Walkontable}\n   */\n  draw() {\n    let fastDraw = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    \
this.drawInterrupted = false;\n    if (!fastDraw && \
!this.wtTable.isVisible()) {\n      this.drawInterrupted = true;\n    } else \
{\n      this.wtTable.draw(fastDraw);\n    }\n    return this;\n  }\n  /**\n  \
 * Returns the TD at coords. If topmost is set to true, returns TD from the \
topmost overlay layer,\n   * if not set or set to false, returns TD from the \
master table.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n  \
 * @param {boolean} [topmost=false] If set to `true`, it returns the TD \
element from the topmost overlay. For example,\n   *                          \
        if the wanted cell is in the range of fixed rows, it will return a TD \
element\n   *                                  from the top overlay.\n   * \
@returns {HTMLElement}\n   */\n  getCell(coords) {\n    let topmost = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    \
if (!topmost) {\n      return this.wtTable.getCell(coords);\n    }\n    const \
totalRows = this.wtSettings.getSetting(\"totalRows\");\n    const \
fixedRowsTop = this.wtSettings.getSetting(\"fixedRowsTop\");\n    const \
fixedRowsBottom = this.wtSettings.getSetting(\"fixedRowsBottom\");\n    const \
fixedColumnsStart = this.wtSettings.getSetting(\"fixedColumnsStart\");\n    \
if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {\n      \
return \
this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n  \
  } else if (coords.row < fixedRowsTop) {\n      return \
this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);\n    } else if \
(coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) \
{\n      if (this.wtOverlays.bottomInlineStartCornerOverlay && \
this.wtOverlays.bottomInlineStartCornerOverlay.clone) {\n        return \
this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);\
\n      }\n    } else if (coords.col < fixedColumnsStart) {\n      return \
this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);\n    } else \
if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {\n  \
    if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) \
{\n        return \
this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);\n      }\n    \
}\n    return this.wtTable.getCell(coords);\n  }\n  /**\n   * Scrolls the \
viewport to a cell (rerenders if needed).\n   *\n   * @param {CellCoords} \
coords The cell coordinates to scroll to.\n   * @param {boolean} [snapToTop] \
If `true`, viewport is scrolled to show the cell on the top of the table.\n   \
* @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the \
cell on the right of the table.\n   * @param {boolean} [snapToBottom] If \
`true`, viewport is scrolled to show the cell on the bottom of the table.\n   \
* @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the \
cell on the left of the table.\n   * @returns {boolean}\n   */\n  \
scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n  \
  if (coords.col < 0 || coords.row < 0) {\n      return false;\n    }\n    \
return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, \
snapToBottom, snapToLeft);\n  }\n  /**\n   * Scrolls the viewport to a column \
(rerenders if needed).\n   *\n   * @param {number} column Visual column \
index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled \
to show the cell on the right of the table.\n   * @param {boolean} \
[snapToLeft] If `true`, viewport is scrolled to show the cell on the left of \
the table.\n   * @returns {boolean}\n   */\n  \
scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    if (column \
< 0) {\n      return false;\n    }\n    return \
this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n  \
}\n  /**\n   * Scrolls the viewport to a row (rerenders if needed).\n   *\n   \
* @param {number} row Visual row index.\n   * @param {boolean} [snapToTop] If \
`true`, viewport is scrolled to show the cell on the top of the table.\n   * \
@param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the \
cell on the bottom of the table.\n   * @returns {boolean}\n   */\n  \
scrollViewportVertically(row, snapToTop, snapToBottom) {\n    if (row < 0) \
{\n      return false;\n    }\n    return \
this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);\n  }\n  \
/**\n   * @returns {Array}\n   */\n  getViewport() {\n    return \
[this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), \
this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];\n  \
}\n  /**\n   * Destroy instance.\n   */\n  destroy() {\n    \
this.wtOverlays.destroy();\n    this.wtEvent.destroy();\n  }\n  /**\n   * \
Create data access object for scroll.\n   *\n   * @protected\n   * @returns \
{ScrollDao}\n   */\n  createScrollDao() {\n    const wot = this;\n    return \
{\n      get drawn() {\n        return wot.drawn;\n      },\n      get \
topOverlay() {\n        return wot.wtOverlays.topOverlay;\n      },\n      \
get inlineStartOverlay() {\n        return \
wot.wtOverlays.inlineStartOverlay;\n      },\n      get wtTable() {\n        \
return wot.wtTable;\n      },\n      get wtViewport() {\n        return \
wot.wtViewport;\n      },\n      get wtSettings() {\n        return \
wot.wtSettings;\n      },\n      get rootWindow() {\n        return \
wot.domBindings.rootWindow;\n      },\n      // TODO refactoring, consider \
about using injecting wtSettings into scroll (it'll enables remove dao \
layer)\n      get totalRows() {\n        return \
wot.wtSettings.getSetting(\"totalRows\");\n      },\n      get totalColumns() \
{\n        return wot.wtSettings.getSetting(\"totalColumns\");\n      },\n    \
  get fixedRowsTop() {\n        return \
wot.wtSettings.getSetting(\"fixedRowsTop\");\n      },\n      get \
fixedRowsBottom() {\n        return \
wot.wtSettings.getSetting(\"fixedRowsBottom\");\n      },\n      get \
fixedColumnsStart() {\n        return \
wot.wtSettings.getSetting(\"fixedColumnsStart\");\n      }\n    };\n  }\n  // \
TODO refactoring: it will be much better to not use DAO objects. They are \
needed for now to provide\n  // dynamically access to related objects\n  \
/**\n   * Create data access object for wtTable.\n   *\n   * @protected\n   * \
@returns {TableDao}\n   */\n  getTableDao() {\n    const wot = this;\n    \
return {\n      get wot() {\n        return wot;\n      },\n      get \
parentTableOffset() {\n        return wot.cloneSource.wtTable.tableOffset;\n  \
    },\n      get cloneSource() {\n        return wot.cloneSource;\n      \
},\n      get workspaceWidth() {\n        return \
wot.wtViewport.getWorkspaceWidth();\n      },\n      get wtViewport() {\n     \
   return wot.wtViewport;\n      },\n      get wtOverlays() {\n        return \
wot.wtOverlays;\n      },\n      get selections() {\n        return \
wot.selections;\n      },\n      get drawn() {\n        return wot.drawn;\n   \
   },\n      set drawn(v) {\n        wot.drawn = v;\n      },\n      get \
wtTable() {\n        return wot.wtTable;\n      },\n      get \
startColumnRendered() {\n        return \
wot.wtViewport.columnsRenderCalculator.startColumn;\n      },\n      get \
startColumnVisible() {\n        return \
wot.wtViewport.columnsVisibleCalculator.startColumn;\n      },\n      get \
endColumnRendered() {\n        return \
wot.wtViewport.columnsRenderCalculator.endColumn;\n      },\n      get \
endColumnVisible() {\n        return \
wot.wtViewport.columnsVisibleCalculator.endColumn;\n      },\n      get \
countColumnsRendered() {\n        return \
wot.wtViewport.columnsRenderCalculator.count;\n      },\n      get \
countColumnsVisible() {\n        return \
wot.wtViewport.columnsVisibleCalculator.count;\n      },\n      get \
startRowRendered() {\n        return \
wot.wtViewport.rowsRenderCalculator.startRow;\n      },\n      get \
startRowVisible() {\n        return \
wot.wtViewport.rowsVisibleCalculator.startRow;\n      },\n      get \
endRowRendered() {\n        return \
wot.wtViewport.rowsRenderCalculator.endRow;\n      },\n      get \
endRowVisible() {\n        return \
wot.wtViewport.rowsVisibleCalculator.endRow;\n      },\n      get \
countRowsRendered() {\n        return \
wot.wtViewport.rowsRenderCalculator.count;\n      },\n      get \
countRowsVisible() {\n        return \
wot.wtViewport.rowsVisibleCalculator.count;\n      }\n    };\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/core/clone.mjs\nfunction \
_defineProperty6(obj, key, value) {\n  key = _toPropertyKey6(key);\n  if (key \
in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: true, \
configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  \
}\n  return obj;\n}\nfunction _toPropertyKey6(arg) {\n  var key = \
_toPrimitive6(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive6(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar Clone = class extends CoreAbstract {\n  /**\n   * \
@param {HTMLTableElement} table Main table.\n   * @param \
{SettingsPure|Settings} settings The Walkontable settings.\n   * @param \
{WalkontableCloneOptions} clone Clone data.\n   */\n  constructor(table, \
settings, clone2) {\n    super(table, settings);\n    _defineProperty6(this, \
\"cloneSource\", void 0);\n    _defineProperty6(this, \"cloneOverlay\", void \
0);\n    const facadeGetter = this.wtSettings.getSetting(\"facade\", this);\n \
   this.cloneSource = clone2.source;\n    this.cloneOverlay = \
clone2.overlay;\n    this.wtTable = \
this.cloneOverlay.createTable(this.getTableDao(), facadeGetter, \
this.domBindings, this.wtSettings);\n    this.wtViewport = clone2.viewport;\n \
   this.selections = clone2.selections;\n    this.wtEvent = new \
event_default(facadeGetter, this.domBindings, this.wtSettings, \
this.eventManager, this.wtTable, this.selections, clone2.event);\n    \
this.findOriginalHeaders();\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/overlay/_base.mjs\nfunctio\
n _defineProperty7(obj, key, value) {\n  key = _toPropertyKey7(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey7(arg) {\n  var key = \
_toPrimitive7(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive7(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar Overlay = class {\n  /**\n   * @param {Walkontable} \
wotInstance The Walkontable instance. @TODO refactoring: check if can be \
deleted.\n   * @param {FacadeGetter} facadeGetter Function which return \
proper facade.\n   * @param {CLONE_TYPES_ENUM} type The overlay type name \
(clone name).\n   * @param {Settings} wtSettings The Walkontable settings.\n  \
 * @param {DomBindings} domBindings Dom elements bound to the current \
instance.\n   */\n  constructor(wotInstance, facadeGetter, type, wtSettings, \
domBindings) {\n    _defineProperty7(this, \"wtSettings\", null);\n    \
defineGetter(this, \"wot\", wotInstance, {\n      writable: false\n    });\n  \
  this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    \
this.wtSettings = wtSettings;\n    const {\n      TABLE,\n      hider,\n      \
spreader,\n      holder: holder2,\n      wtRootElement\n    } = \
this.wot.wtTable;\n    this.instance = this.wot;\n    this.type = type;\n    \
this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    \
this.hider = hider;\n    this.spreader = spreader;\n    this.holder = \
holder2;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer \
= getTrimmingContainer(this.hider.parentNode.parentNode);\n    \
this.updateStateOfRendering();\n    this.clone = this.makeClone();\n  }\n  \
/**\n   * Update internal state of object with an information about the need \
of full rendering of the overlay.\n   *\n   * @returns {boolean} Returns \
`true` if the state has changed since the last check.\n   */\n  \
updateStateOfRendering() {\n    const previousState = this.needFullRender;\n  \
  this.needFullRender = this.shouldBeRendered();\n    const changed = \
previousState !== this.needFullRender;\n    if (changed && \
!this.needFullRender) {\n      this.reset();\n    }\n    return changed;\n  \
}\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * \
@returns {boolean}\n   */\n  shouldBeRendered() {\n    return true;\n  }\n  \
/**\n   * Update the trimming container.\n   */\n  updateTrimmingContainer() \
{\n    this.trimmingContainer = \
getTrimmingContainer(this.hider.parentNode.parentNode);\n  }\n  /**\n   * \
Update the main scrollable element.\n   */\n  updateMainScrollableElement() \
{\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      \
rootWindow\n    } = this.domBindings;\n    if \
(rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyVal\
ue(\"overflow\") === \"hidden\") {\n      this.mainTableScrollableElement = \
this.wot.wtTable.holder;\n    } else {\n      this.mainTableScrollableElement \
= getScrollableElement(wtTable.TABLE);\n    }\n  }\n  /**\n   * Calculates \
coordinates of the provided element, relative to the root Handsontable \
element.\n   * NOTE: The element needs to be a child of the overlay in order \
for the method to work correctly.\n   *\n   * @param {HTMLElement} element \
The cell element to calculate the position for.\n   * @param {number} \
rowIndex Visual row index.\n   * @param {number} columnIndex Visual column \
index.\n   * @returns {{top: number, start: number}|undefined}\n   */\n  \
getRelativeCellPosition(element, rowIndex, columnIndex) {\n    if \
(this.clone.wtTable.holder.contains(element) === false) {\n      warn(`The \
provided element is not a child of the ${this.type} overlay`);\n      \
return;\n    }\n    const windowScroll = this.mainTableScrollableElement === \
this.domBindings.rootWindow;\n    const fixedColumnStart = columnIndex < \
this.wtSettings.getSetting(\"fixedColumnsStart\");\n    const fixedRowTop = \
rowIndex < this.wtSettings.getSetting(\"fixedRowsTop\");\n    const \
fixedRowBottom = rowIndex >= this.wtSettings.getSetting(\"totalRows\") - \
this.wtSettings.getSetting(\"fixedRowsBottom\");\n    const spreader = \
this.clone.wtTable.spreader;\n    const spreaderOffset = {\n      start: \
this.getRelativeStartPosition(spreader),\n      top: spreader.offsetTop\n    \
};\n    const elementOffset = {\n      start: \
this.getRelativeStartPosition(element),\n      top: element.offsetTop\n    \
};\n    let offsetObject = null;\n    if (windowScroll) {\n      offsetObject \
= this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, \
elementOffset, spreaderOffset);\n    } else {\n      offsetObject = \
this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, \
fixedColumnStart, elementOffset, spreaderOffset);\n    }\n    return \
offsetObject;\n  }\n  /**\n   * Get inline start value depending of \
direction.\n   *\n   * @param {HTMLElement} el Element.\n   * @returns \
{number}\n   */\n  getRelativeStartPosition(el) {\n    return this.isRtl() ? \
el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : \
el.offsetLeft;\n  }\n  /**\n   * Calculates coordinates of the provided \
element, relative to the root Handsontable element within a table with \
window\n   * as a scrollable element.\n   *\n   * @private\n   * @param \
{boolean} onFixedRowTop `true` if the coordinates point to a place within the \
top fixed rows.\n   * @param {boolean} onFixedColumn `true` if the \
coordinates point to a place within the fixed columns.\n   * @param {number} \
elementOffset Offset position of the cell element.\n   * @param {number} \
spreaderOffset Offset position of the spreader element.\n   * @returns {{top: \
number, left: number}}\n   */\n  \
getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, \
elementOffset, spreaderOffset) {\n    const absoluteRootElementPosition = \
this.wot.wtTable.wtRootElement.getBoundingClientRect();\n    let \
horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) \
{\n      horizontalOffset = spreaderOffset.start;\n    } else {\n      let \
absoluteRootElementStartPosition = absoluteRootElementPosition.left;\n      \
if (this.isRtl()) {\n        absoluteRootElementStartPosition = \
this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + \
absoluteRootElementPosition.width + getScrollbarWidth());\n      }\n      \
horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * \
absoluteRootElementStartPosition : 0;\n    }\n    if (onFixedRowTop) {\n      \
const absoluteOverlayPosition = \
this.clone.wtTable.TABLE.getBoundingClientRect();\n      verticalOffset = \
absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n    } else \
{\n      verticalOffset = spreaderOffset.top;\n    }\n    return {\n      \
start: elementOffset.start + horizontalOffset,\n      top: elementOffset.top \
+ verticalOffset\n    };\n  }\n  /**\n   * Calculates coordinates of the \
provided element, relative to the root Handsontable element within a table \
with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param \
{boolean} onFixedRowTop `true` if the coordinates point to a place within the \
top fixed rows.\n   * @param {boolean} onFixedRowBottom `true` if the \
coordinates point to a place within the bottom fixed rows.\n   * @param \
{boolean} onFixedColumn `true` if the coordinates point to a place within the \
fixed columns.\n   * @param {number} elementOffset Offset position of the \
cell element.\n   * @param {number} spreaderOffset Offset position of the \
spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  \
getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, \
onFixedColumn, elementOffset, spreaderOffset) {\n    const \
tableScrollPosition = {\n      horizontal: \
this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),\n      vertical: \
this.wot.wtOverlays.topOverlay.getScrollPosition()\n    };\n    let \
horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) \
{\n      horizontalOffset = tableScrollPosition.horizontal - \
spreaderOffset.start;\n    }\n    if (onFixedRowBottom) {\n      const \
absoluteRootElementPosition = \
this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      const \
absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n \
     verticalOffset = absoluteOverlayPosition.top * -1 + \
absoluteRootElementPosition.top;\n    } else if (!onFixedRowTop) {\n      \
verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n    }\n  \
  return {\n      start: elementOffset.start - horizontalOffset,\n      top: \
elementOffset.top - verticalOffset\n    };\n  }\n  /**\n   * Make a clone of \
table for overlay.\n   *\n   * @returns {Clone}\n   */\n  makeClone() {\n    \
if (CLONE_TYPES.indexOf(this.type) === -1) {\n      throw new Error(`Clone \
type \"${this.type}\" is not supported.`);\n    }\n    const {\n      \
wtTable\n    } = this.wot;\n    const {\n      rootDocument,\n      \
rootWindow\n    } = this.domBindings;\n    const clone2 = \
rootDocument.createElement(\"DIV\");\n    const clonedTable = \
rootDocument.createElement(\"TABLE\");\n    const tableParent = \
wtTable.wtRootElement.parentNode;\n    clone2.className = \
`${CLONE_CLASS_NAMES.get(this.type)} handsontable`;\n    \
clone2.setAttribute(\"dir\", this.isRtl() ? \"rtl\" : \"ltr\");\n    \
clone2.style.position = \"absolute\";\n    clone2.style.top = 0;\n    \
clone2.style.overflow = \"visible\";\n    if (this.isRtl()) {\n      \
clone2.style.right = 0;\n    } else {\n      clone2.style.left = 0;\n    }\n  \
  clonedTable.className = wtTable.TABLE.className;\n    \
clone2.appendChild(clonedTable);\n    tableParent.appendChild(clone2);\n    \
const preventOverflow = this.wtSettings.getSetting(\"preventOverflow\");\n    \
if (preventOverflow === true || preventOverflow === \"horizontal\" && \
this.type === CLONE_TOP || preventOverflow === \"vertical\" && this.type === \
CLONE_INLINE_START) {\n      this.mainTableScrollableElement = rootWindow;\n  \
  } else if \
(rootWindow.getComputedStyle(tableParent).getPropertyValue(\"overflow\") === \
\"hidden\") {\n      this.mainTableScrollableElement = wtTable.holder;\n    } \
else {\n      this.mainTableScrollableElement = \
getScrollableElement(wtTable.TABLE);\n    }\n    return new \
Clone(clonedTable, this.wtSettings, {\n      // todo ioc factory\n      \
source: this.wot,\n      overlay: this,\n      viewport: \
this.wot.wtViewport,\n      // todo ioc , or factor func if used only here\n  \
    event: this.wot.wtEvent,\n      // todo ioc , or factory func if used \
only here\n      selections: this.wot.selections\n      // todo ioc , or \
factory func if used only here\n    });\n  }\n  /**\n   * Refresh/Redraw \
overlay.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to \
refresh only the positions of borders without rerendering\n   *               \
                    the data. It will only work if Table.draw() does not \
force\n   *                                   rendering anyway.\n   */\n  \
refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== void \
0 ? arguments[0] : false;\n    const nextCycleRenderFlag = \
this.shouldBeRendered();\n    if (this.clone && (this.needFullRender || \
nextCycleRenderFlag)) {\n      this.clone.draw(fastDraw);\n    }\n    \
this.needFullRender = nextCycleRenderFlag;\n  }\n  /**\n   * Reset overlay \
styles to initial values.\n   */\n  reset() {\n    if (!this.clone) {\n      \
return;\n    }\n    const holder2 = this.clone.wtTable.holder;\n    const \
hider = this.clone.wtTable.hider;\n    const holderStyle = holder2.style;\n   \
 const hiderStyle = hider.style;\n    const rootStyle = \
holder2.parentNode.style;\n    arrayEach([holderStyle, hiderStyle, \
rootStyle], (style) => {\n      style.width = \"\";\n      style.height = \
\"\";\n    });\n  }\n  /**\n   * Determine if Walkontable is running in RTL \
mode.\n   *\n   * @returns {boolean}\n   */\n  isRtl() {\n    return \
this.wtSettings.getSetting(\"rtlMode\");\n  }\n  /**\n   * Destroy overlay \
instance.\n   */\n  destroy() {\n    this.clone.eventManager.destroy();\n  \
}\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/overlay/bottomInlineStartC\
orner.mjs\nvar BottomInlineStartCornerOverlay = class extends Overlay {\n  \
/**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO \
refactoring: check if can be deleted.\n   * @param {FacadeGetter} \
facadeGetter Function which return proper facade.\n   * @param {Settings} \
wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings \
Dom elements bound to the current instance.\n   * @param {BottomOverlay} \
bottomOverlay The instance of the Top overlay.\n   * @param \
{InlineStartOverlay} inlineStartOverlay The instance of the InlineStart \
overlay.\n   */\n  constructor(wotInstance, facadeGetter, wtSettings, \
domBindings, bottomOverlay, inlineStartOverlay) {\n    super(wotInstance, \
facadeGetter, CLONE_BOTTOM_INLINE_START_CORNER, wtSettings, domBindings);\n   \
 this.bottomOverlay = bottomOverlay;\n    this.inlineStartOverlay = \
inlineStartOverlay;\n  }\n  /**\n   * Factory method to create a subclass of \
`Table` that is relevant to this overlay.\n   *\n   * @see \
Table#constructor\n   * @param {...*} args Parameters that will be forwarded \
to the `Table` constructor.\n   * @returns \
{BottomInlineStartCornerOverlayTable}\n   */\n  createTable() {\n    for (var \
_len = arguments.length, args = new Array(_len), _key = 0; _key < _len; \
_key++) {\n      args[_key] = arguments[_key];\n    }\n    return new \
bottomInlineStartCorner_default(...args);\n  }\n  /**\n   * Checks if overlay \
should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  \
shouldBeRendered() {\n    return \
this.wtSettings.getSetting(\"shouldRenderBottomOverlay\") && \
this.wtSettings.getSetting(\"shouldRenderInlineStartOverlay\");\n  }\n  /**\n \
  * Updates the corner overlay position.\n   *\n   * @returns {boolean}\n   \
*/\n  resetFixedPosition() {\n    const {\n      wot\n    } = this;\n    \
this.updateTrimmingContainer();\n    if (!wot.wtTable.holder.parentNode) {\n  \
    return false;\n    }\n    const overlayRoot = \
this.clone.wtTable.holder.parentNode;\n    overlayRoot.style.top = \"\";\n    \
if (this.trimmingContainer === this.domBindings.rootWindow) {\n      const \
inlineStartOffset = this.inlineStartOverlay.getOverlayOffset();\n      const \
bottom2 = this.bottomOverlay.getOverlayOffset();\n      \
overlayRoot.style[this.isRtl() ? \"right\" : \"left\"] = \
`${inlineStartOffset}px`;\n      overlayRoot.style.bottom = `${bottom2}px`;\n \
   } else {\n      resetCssTransform(overlayRoot);\n      \
this.repositionOverlay();\n    }\n    let tableHeight = \
outerHeight(this.clone.wtTable.TABLE);\n    const tableWidth = \
outerWidth(this.clone.wtTable.TABLE);\n    if \
(!this.wot.wtTable.hasDefinedSize()) {\n      tableHeight = 0;\n    }\n    \
overlayRoot.style.height = `${tableHeight}px`;\n    overlayRoot.style.width = \
`${tableWidth}px`;\n    return false;\n  }\n  /**\n   * Reposition the \
overlay.\n   */\n  repositionOverlay() {\n    const {\n      wtTable,\n      \
wtViewport\n    } = this.wot;\n    const {\n      rootDocument\n    } = \
this.domBindings;\n    const cloneRoot = \
this.clone.wtTable.holder.parentNode;\n    let bottomOffset = 0;\n    if \
(!wtViewport.hasVerticalScroll()) {\n      bottomOffset += \
wtViewport.getWorkspaceHeight() - wtTable.getTotalHeight();\n    }\n    if \
(wtViewport.hasVerticalScroll() && wtViewport.hasHorizontalScroll()) {\n      \
bottomOffset += getScrollbarWidth(rootDocument);\n    }\n    \
cloneRoot.style.bottom = `${bottomOffset}px`;\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/mixin/calculatedColu\
mns.mjs\nvar MIXIN_NAME3 = \"calculatedColumns\";\nvar calculatedColumns = \
{\n  /**\n   * Get the source index of the first rendered column. If no \
columns are rendered, returns an error code: -1.\n   *\n   * @returns \
{number}\n   * @this Table\n   */\n  getFirstRenderedColumn() {\n    const \
startColumn = this.dataAccessObject.startColumnRendered;\n    if (startColumn \
=== null) {\n      return -1;\n    }\n    return startColumn;\n  },\n  /**\n  \
 * Get the source index of the first column fully visible in the viewport. If \
no columns are fully visible, returns an error code: -1.\n   *\n   * @returns \
{number}\n   * @this Table\n   */\n  getFirstVisibleColumn() {\n    const \
startColumn = this.dataAccessObject.startColumnVisible;\n    if (startColumn \
=== null) {\n      return -1;\n    }\n    return startColumn;\n  },\n  /**\n  \
 * Get the source index of the last rendered column. If no columns are \
rendered, returns an error code: -1.\n   *\n   * @returns {number}\n   * \
@this Table\n   */\n  getLastRenderedColumn() {\n    const endColumn = \
this.dataAccessObject.endColumnRendered;\n    if (endColumn === null) {\n     \
 return -1;\n    }\n    return endColumn;\n  },\n  /**\n   * Get the source \
index of the last column fully visible in the viewport. If no columns are \
fully visible, returns an error code: -1.\n   *\n   * @returns {number}\n   * \
@this Table\n   */\n  getLastVisibleColumn() {\n    const endColumn = \
this.dataAccessObject.endColumnVisible;\n    if (endColumn === null) {\n      \
return -1;\n    }\n    return endColumn;\n  },\n  /**\n   * Get the number of \
rendered columns.\n   *\n   * @returns {number}\n   * @this Table\n   */\n  \
getRenderedColumnsCount() {\n    return \
this.dataAccessObject.countColumnsRendered;\n  },\n  /**\n   * Get the number \
of fully visible columns in the viewport.\n   *\n   * @returns {number}\n   * \
@this Table\n   */\n  getVisibleColumnsCount() {\n    return \
this.dataAccessObject.countColumnsVisible;\n  \
}\n};\ndefineGetter(calculatedColumns, \"MIXIN_NAME\", MIXIN_NAME3, {\n  \
writable: false,\n  enumerable: false\n});\nvar calculatedColumns_default = \
calculatedColumns;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/bottom.mjs\nvar \
BottomOverlayTable = class extends table_default {\n  /**\n   * @param \
{TableDao} dataAccessObject The data access object.\n   * @param \
{FacadeGetter} facadeGetter Function which return proper facade.\n   * @param \
{DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} \
wtSettings The Walkontable settings.\n   */\n  constructor(dataAccessObject, \
facadeGetter, domBindings, wtSettings) {\n    super(dataAccessObject, \
facadeGetter, domBindings, wtSettings, CLONE_BOTTOM);\n  \
}\n};\nmixin(BottomOverlayTable, \
stickyRowsBottom_default);\nmixin(BottomOverlayTable, \
calculatedColumns_default);\nvar bottom_default = BottomOverlayTable;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/overlay/bottom.mjs\nfuncti\
on _defineProperty8(obj, key, value) {\n  key = _toPropertyKey8(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey8(arg) {\n  var key = \
_toPrimitive8(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive8(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar BottomOverlay = class extends Overlay {\n  /**\n   * \
@param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: \
check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function \
which return proper facade.\n   * @param {Settings} wtSettings The \
Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements \
bound to the current instance.\n   */\n  constructor(wotInstance, \
facadeGetter, wtSettings, domBindings) {\n    super(wotInstance, \
facadeGetter, CLONE_BOTTOM, wtSettings, domBindings);\n    \
_defineProperty8(this, \"cachedFixedRowsBottom\", -1);\n    \
this.cachedFixedRowsBottom = \
this.wtSettings.getSetting(\"fixedRowsBottom\");\n  }\n  /**\n   * Factory \
method to create a subclass of `Table` that is relevant to this overlay.\n   \
*\n   * @see Table#constructor\n   * @param {...*} args Parameters that will \
be forwarded to the `Table` constructor.\n   * @returns \
{BottomOverlayTable}\n   */\n  createTable() {\n    for (var _len = \
arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n  \
    args[_key] = arguments[_key];\n    }\n    return new \
bottom_default(...args);\n  }\n  /**\n   * Checks if overlay should be fully \
rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    \
return this.wtSettings.getSetting(\"shouldRenderBottomOverlay\");\n  }\n  \
/**\n   * Updates the top overlay position.\n   *\n   * @returns {boolean}\n  \
 */\n  resetFixedPosition() {\n    if (!this.needFullRender || \
!this.wot.wtTable.holder.parentNode) {\n      return false;\n    }\n    const \
{\n      rootWindow\n    } = this.domBindings;\n    const overlayRoot = \
this.clone.wtTable.holder.parentNode;\n    overlayRoot.style.top = \"\";\n    \
let overlayPosition = 0;\n    const preventOverflow = \
this.wtSettings.getSetting(\"preventOverflow\");\n    if \
(this.trimmingContainer === rootWindow && (!preventOverflow || \
preventOverflow !== \"vertical\")) {\n      overlayPosition = \
this.getOverlayOffset();\n      overlayRoot.style.bottom = \
`${overlayPosition}px`;\n    } else {\n      overlayPosition = \
this.getScrollPosition();\n      this.repositionOverlay();\n    }\n    const \
positionChanged = this.adjustHeaderBordersPosition(overlayPosition);\n    \
this.adjustElementsSize();\n    return positionChanged;\n  }\n  /**\n   * \
Updates the bottom overlay position.\n   */\n  repositionOverlay() {\n    \
const {\n      wtTable,\n      wtViewport\n    } = this.wot;\n    const {\n   \
   rootDocument\n    } = this.domBindings;\n    const cloneRoot = \
this.clone.wtTable.holder.parentNode;\n    let bottomOffset = 0;\n    if \
(!wtViewport.hasVerticalScroll()) {\n      bottomOffset += \
wtViewport.getWorkspaceHeight() - wtTable.getTotalHeight();\n    }\n    if \
(wtViewport.hasVerticalScroll() && wtViewport.hasHorizontalScroll()) {\n      \
bottomOffset += getScrollbarWidth(rootDocument);\n    }\n    \
cloneRoot.style.bottom = `${bottomOffset}px`;\n  }\n  /**\n   * Sets the main \
overlay's vertical scroll position.\n   *\n   * @param {number} pos The \
scroll position.\n   * @returns {boolean}\n   */\n  setScrollPosition(pos) \
{\n    const {\n      rootWindow\n    } = this.domBindings;\n    let result = \
false;\n    if (this.mainTableScrollableElement === rootWindow) {\n      \
rootWindow.scrollTo(getWindowScrollLeft(rootWindow), pos);\n      result = \
true;\n    } else if (this.mainTableScrollableElement.scrollTop !== pos) {\n  \
    this.mainTableScrollableElement.scrollTop = pos;\n      result = true;\n  \
  }\n    return result;\n  }\n  /**\n   * Triggers onScroll hook callback.\n  \
 */\n  onScroll() {\n    \
this.wtSettings.getSetting(\"onScrollHorizontally\");\n  }\n  /**\n   * \
Calculates total sum cells height.\n   *\n   * @param {number} from Row index \
which calculates started from.\n   * @param {number} to Row index where \
calculation is finished.\n   * @returns {number} Height sum.\n   */\n  \
sumCellSizes(from, to) {\n    const {\n      wtTable,\n      wtSettings\n    \
} = this.wot;\n    const defaultRowHeight = \
wtSettings.getSetting(\"defaultRowHeight\");\n    let row = from;\n    let \
sum = 0;\n    while (row < to) {\n      const height = \
wtTable.getRowHeight(row);\n      sum += height === void 0 ? defaultRowHeight \
: height;\n      row += 1;\n    }\n    return sum;\n  }\n  /**\n   * Adjust \
overlay root element, childs and master table element sizes (width, \
height).\n   *\n   * @param {boolean} [force=false] When `true`, it adjusts \
the DOM nodes sizes for that overlay.\n   */\n  adjustElementsSize() {\n    \
let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
false;\n    this.updateTrimmingContainer();\n    if (this.needFullRender || \
force) {\n      this.adjustRootElementSize();\n      \
this.adjustRootChildrenSize();\n    }\n  }\n  /**\n   * Adjust overlay root \
element size (width and height).\n   */\n  adjustRootElementSize() {\n    \
const {\n      wtTable,\n      wtViewport\n    } = this.wot;\n    const {\n   \
   rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const \
scrollbarWidth = getScrollbarWidth(rootDocument);\n    const overlayRoot = \
this.clone.wtTable.holder.parentNode;\n    const overlayRootStyle = \
overlayRoot.style;\n    const preventOverflow = \
this.wtSettings.getSetting(\"preventOverflow\");\n    if \
(this.trimmingContainer !== rootWindow || preventOverflow === \"horizontal\") \
{\n      let width = wtViewport.getWorkspaceWidth();\n      if \
(this.wot.wtOverlays.hasScrollbarRight) {\n        width -= scrollbarWidth;\n \
     }\n      width = Math.min(width, wtTable.wtRootElement.scrollWidth);\n   \
   overlayRootStyle.width = `${width}px`;\n    } else {\n      \
overlayRootStyle.width = \"\";\n    }\n    \
this.clone.wtTable.holder.style.width = overlayRootStyle.width;\n    let \
tableHeight = outerHeight(this.clone.wtTable.TABLE);\n    if \
(!this.wot.wtTable.hasDefinedSize()) {\n      tableHeight = 0;\n    }\n    \
overlayRootStyle.height = `${tableHeight}px`;\n  }\n  /**\n   * Adjust \
overlay root childs size.\n   */\n  adjustRootChildrenSize() {\n    const {\n \
     holder: holder2\n    } = this.clone.wtTable;\n    \
this.clone.wtTable.hider.style.width = this.hider.style.width;\n    \
holder2.style.width = holder2.parentNode.style.width;\n    \
holder2.style.height = holder2.parentNode.style.height;\n  }\n  /**\n   * \
Adjust the overlay dimensions and position.\n   */\n  applyToDOM() {\n    \
const total = this.wtSettings.getSetting(\"totalRows\");\n    if (typeof \
this.wot.wtViewport.rowsRenderCalculator.startPosition === \"number\") {\n    \
  this.spreader.style.top = \
`${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;\n    } else if \
(total === 0) {\n      this.spreader.style.top = \"0\";\n    } else {\n      \
throw new Error(\"Incorrect value of the rowsRenderCalculator\");\n    }\n    \
this.spreader.style.bottom = \"\";\n    if (this.needFullRender) {\n      \
this.syncOverlayOffset();\n    }\n  }\n  /**\n   * Synchronize calculated \
left position to an element.\n   */\n  syncOverlayOffset() {\n    const \
styleProperty = this.isRtl() ? \"right\" : \"left\";\n    const {\n      \
spreader\n    } = this.clone.wtTable;\n    if (typeof \
this.wot.wtViewport.columnsRenderCalculator.startPosition === \"number\") {\n \
     spreader.style[styleProperty] = \
`${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;\n    } else \
{\n      spreader.style[styleProperty] = \"\";\n    }\n  }\n  /**\n   * \
Scrolls vertically to a row.\n   *\n   * @param {number} sourceRow Row index \
which you want to scroll to.\n   * @param {boolean} [bottomEdge=false] If \
`true`, scrolls according to the bottom edge (top edge is by default).\n   \
*/\n  scrollTo(sourceRow, bottomEdge) {\n    let newY = \
this.getTableParentOffset();\n    const sourceInstance = this.wot.cloneSource \
? this.wot.cloneSource : this.wot;\n    const mainHolder = \
sourceInstance.wtTable.holder;\n    let scrollbarCompensation = 0;\n    if \
(bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {\n      \
scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);\n   \
 }\n    if (bottomEdge) {\n      newY += this.sumCellSizes(0, sourceRow + \
1);\n      newY -= this.wot.wtViewport.getViewportHeight();\n      newY += \
1;\n    } else {\n      newY += \
this.sumCellSizes(this.wtSettings.getSetting(\"fixedRowsBottom\"), \
sourceRow);\n    }\n    newY += scrollbarCompensation;\n    \
this.setScrollPosition(newY);\n  }\n  /**\n   * Gets table parent top \
position.\n   *\n   * @returns {number}\n   */\n  getTableParentOffset() {\n  \
  if (this.mainTableScrollableElement === this.domBindings.rootWindow) {\n    \
  return this.wot.wtTable.holderOffset.top;\n    }\n    return 0;\n  }\n  \
/**\n   * Gets the main overlay's vertical scroll position.\n   *\n   * \
@returns {number} Main table's vertical scroll position.\n   */\n  \
getScrollPosition() {\n    return \
getScrollTop(this.mainTableScrollableElement, this.domBindings.rootWindow);\n \
 }\n  /**\n   * Gets the main overlay's vertical overlay offset.\n   *\n   * \
@returns {number} Main table's vertical overlay offset.\n   */\n  \
getOverlayOffset() {\n    const {\n      rootWindow\n    } = \
this.domBindings;\n    const preventOverflow = \
this.wtSettings.getSetting(\"preventOverflow\");\n    let overlayOffset = \
0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || \
preventOverflow !== \"vertical\")) {\n      const rootHeight = \
this.wot.wtTable.getTotalHeight();\n      const overlayRootHeight = \
this.clone.wtTable.getTotalHeight();\n      const maxOffset = rootHeight - \
overlayRootHeight;\n      const docClientHeight = \
this.domBindings.rootDocument.documentElement.clientHeight;\n      \
overlayOffset = Math.max(this.getTableParentOffset() - \
this.getScrollPosition() - docClientHeight + rootHeight, 0);\n      if \
(overlayOffset > maxOffset) {\n        overlayOffset = 0;\n      }\n    }\n   \
 return overlayOffset;\n  }\n  /**\n   * Adds css classes to hide the header \
border's header (cell-selection border hiding issue).\n   *\n   * @param \
{number} position Header Y position if trimming container is window or scroll \
top if not.\n   * @returns {boolean}\n   */\n  \
adjustHeaderBordersPosition(position) {\n    const fixedRowsBottom = \
this.wtSettings.getSetting(\"fixedRowsBottom\");\n    const \
areFixedRowsBottomChanged = this.cachedFixedRowsBottom !== fixedRowsBottom;\n \
   const columnHeaders = this.wtSettings.getSetting(\"columnHeaders\");\n    \
let positionChanged = false;\n    if ((areFixedRowsBottomChanged || \
fixedRowsBottom === 0) && columnHeaders.length > 0) {\n      const \
masterParent = this.wot.wtTable.holder.parentNode;\n      const previousState \
= hasClass(masterParent, \"innerBorderBottom\");\n      \
this.cachedFixedRowsBottom = \
this.wtSettings.getSetting(\"fixedRowsBottom\");\n      if (position || \
this.wtSettings.getSetting(\"totalRows\") === 0) {\n        \
addClass(masterParent, \"innerBorderBottom\");\n        positionChanged = \
!previousState;\n      } else {\n        removeClass(masterParent, \
\"innerBorderBottom\");\n        positionChanged = previousState;\n      }\n  \
  }\n    return positionChanged;\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/mixin/calculatedRows\
.mjs\nvar MIXIN_NAME4 = \"calculatedRows\";\nvar calculatedRows = {\n  /**\n  \
 * Get the source index of the first rendered row. If no rows are rendered, \
returns an error code: -1.\n   *\n   * @returns {number}\n   * @this Table\n  \
 */\n  getFirstRenderedRow() {\n    const startRow = \
this.dataAccessObject.startRowRendered;\n    if (startRow === null) {\n      \
return -1;\n    }\n    return startRow;\n  },\n  /**\n   * Get the source \
index of the first row fully visible in the viewport. If no rows are fully \
visible, returns an error code: -1.\n   *\n   * @returns {number}\n   * @this \
Table\n   */\n  getFirstVisibleRow() {\n    const startRow = \
this.dataAccessObject.startRowVisible;\n    if (startRow === null) {\n      \
return -1;\n    }\n    return startRow;\n  },\n  /**\n   * Get the source \
index of the last rendered row. If no rows are rendered, returns an error \
code: -1.\n   *\n   * @returns {number}\n   * @this Table\n   */\n  \
getLastRenderedRow() {\n    const endRow = \
this.dataAccessObject.endRowRendered;\n    if (endRow === null) {\n      \
return -1;\n    }\n    return endRow;\n  },\n  /**\n   * Get the source index \
of the last row fully visible in the viewport. If no rows are fully visible, \
returns an error code: -1.\n   *\n   * @returns {number}\n   * @this Table\n  \
 */\n  getLastVisibleRow() {\n    const endRow = \
this.dataAccessObject.endRowVisible;\n    if (endRow === null) {\n      \
return -1;\n    }\n    return endRow;\n  },\n  /**\n   * Get the number of \
rendered rows.\n   *\n   * @returns {number}\n   * @this Table\n   */\n  \
getRenderedRowsCount() {\n    return \
this.dataAccessObject.countRowsRendered;\n  },\n  /**\n   * Get the number of \
fully visible rows in the viewport.\n   *\n   * @returns {number}\n   * @this \
Table\n   */\n  getVisibleRowsCount() {\n    return \
this.dataAccessObject.countRowsVisible;\n  \
}\n};\ndefineGetter(calculatedRows, \"MIXIN_NAME\", MIXIN_NAME4, {\n  \
writable: false,\n  enumerable: false\n});\nvar calculatedRows_default = \
calculatedRows;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/inlineStart.mjs\nvar \
InlineStartOverlayTable = class extends table_default {\n  /**\n   * @param \
{TableDao} dataAccessObject The data access object.\n   * @param \
{FacadeGetter} facadeGetter Function which return proper facade.\n   * @param \
{DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} \
wtSettings The Walkontable settings.\n   */\n  constructor(dataAccessObject, \
facadeGetter, domBindings, wtSettings) {\n    super(dataAccessObject, \
facadeGetter, domBindings, wtSettings, CLONE_INLINE_START);\n  \
}\n};\nmixin(InlineStartOverlayTable, \
calculatedRows_default);\nmixin(InlineStartOverlayTable, \
stickyColumnsStart_default);\nvar inlineStart_default = \
InlineStartOverlayTable;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/overlay/inlineStart.mjs\nv\
ar InlineStartOverlay = class extends Overlay {\n  /**\n   * @param \
{Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check \
if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which \
return proper facade.\n   * @param {Settings} wtSettings The Walkontable \
settings.\n   * @param {DomBindings} domBindings Dom elements bound to the \
current instance.\n   */\n  constructor(wotInstance, facadeGetter, \
wtSettings, domBindings) {\n    super(wotInstance, facadeGetter, \
CLONE_INLINE_START, wtSettings, domBindings);\n  }\n  /**\n   * Factory \
method to create a subclass of `Table` that is relevant to this overlay.\n   \
*\n   * @see Table#constructor\n   * @param {...*} args Parameters that will \
be forwarded to the `Table` constructor.\n   * @returns \
{InlineStartOverlayTable}\n   */\n  createTable() {\n    for (var _len = \
arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n  \
    args[_key] = arguments[_key];\n    }\n    return new \
inlineStart_default(...args);\n  }\n  /**\n   * Checks if overlay should be \
fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() \
{\n    return \
this.wtSettings.getSetting(\"shouldRenderInlineStartOverlay\");\n  }\n  /**\n \
  * Updates the left overlay position.\n   *\n   * @returns {boolean}\n   \
*/\n  resetFixedPosition() {\n    const {\n      wtTable\n    } = this.wot;\n \
   if (!this.needFullRender || !wtTable.holder.parentNode) {\n      return \
false;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    \
const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const \
preventOverflow = this.wtSettings.getSetting(\"preventOverflow\");\n    let \
overlayPosition = 0;\n    if (this.trimmingContainer === rootWindow && \
(!preventOverflow || preventOverflow !== \"horizontal\")) {\n      \
overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);\n      \
setOverlayPosition(overlayRoot, `${overlayPosition}px`, \"0px\");\n    } else \
{\n      overlayPosition = this.getScrollPosition();\n      \
resetCssTransform(overlayRoot);\n    }\n    const positionChanged = \
this.adjustHeaderBordersPosition(overlayPosition);\n    \
this.adjustElementsSize();\n    return positionChanged;\n  }\n  /**\n   * \
Sets the main overlay's horizontal scroll position.\n   *\n   * @param \
{number} pos The scroll position.\n   * @returns {boolean}\n   */\n  \
setScrollPosition(pos) {\n    const {\n      rootWindow\n    } = \
this.domBindings;\n    let result = false;\n    if (this.isRtl()) {\n      \
pos = -pos;\n    }\n    if (this.mainTableScrollableElement === rootWindow && \
rootWindow.scrollX !== pos) {\n      rootWindow.scrollTo(pos, \
getWindowScrollTop(rootWindow));\n      result = true;\n    } else if \
(this.mainTableScrollableElement.scrollLeft !== pos) {\n      \
this.mainTableScrollableElement.scrollLeft = pos;\n      result = true;\n    \
}\n    return result;\n  }\n  /**\n   * Triggers onScroll hook callback.\n   \
*/\n  onScroll() {\n    this.wtSettings.getSetting(\"onScrollVertically\");\n \
 }\n  /**\n   * Calculates total sum cells width.\n   *\n   * @param {number} \
from Column index which calculates started from.\n   * @param {number} to \
Column index where calculation is finished.\n   * @returns {number} Width \
sum.\n   */\n  sumCellSizes(from, to) {\n    const defaultColumnWidth = \
this.wtSettings.getSetting(\"defaultColumnWidth\");\n    let column = from;\n \
   let sum = 0;\n    while (column < to) {\n      sum += \
this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;\n     \
 column += 1;\n    }\n    return sum;\n  }\n  /**\n   * Adjust overlay root \
element, childs and master table element sizes (width, height).\n   *\n   * \
@param {boolean} [force=false] When `true`, it adjusts the DOM nodes sizes \
for that overlay.\n   */\n  adjustElementsSize() {\n    let force = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    \
this.updateTrimmingContainer();\n    if (this.needFullRender || force) {\n    \
  this.adjustRootElementSize();\n      this.adjustRootChildrenSize();\n    \
}\n  }\n  /**\n   * Adjust overlay root element size (width and height).\n   \
*/\n  adjustRootElementSize() {\n    const {\n      wtTable\n    } = \
this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = \
this.domBindings;\n    const scrollbarHeight = \
getScrollbarWidth(rootDocument);\n    const overlayRoot = \
this.clone.wtTable.holder.parentNode;\n    const overlayRootStyle = \
overlayRoot.style;\n    const preventOverflow = \
this.wtSettings.getSetting(\"preventOverflow\");\n    if \
(this.trimmingContainer !== rootWindow || preventOverflow === \"vertical\") \
{\n      let height = this.wot.wtViewport.getWorkspaceHeight();\n      if \
(this.wot.wtOverlays.hasScrollbarBottom) {\n        height -= \
scrollbarHeight;\n      }\n      height = Math.min(height, \
wtTable.wtRootElement.scrollHeight);\n      overlayRootStyle.height = \
`${height}px`;\n    } else {\n      overlayRootStyle.height = \"\";\n    }\n  \
  this.clone.wtTable.holder.style.height = overlayRootStyle.height;\n    \
const tableWidth = outerWidth(this.clone.wtTable.TABLE);\n    \
overlayRootStyle.width = `${tableWidth}px`;\n  }\n  /**\n   * Adjust overlay \
root childs size.\n   */\n  adjustRootChildrenSize() {\n    var \
_selections$getCell$g;\n    const {\n      holder: holder2\n    } = \
this.clone.wtTable;\n    const {\n      selections\n    } = this.wot;\n    \
const facade = this.facadeGetter();\n    const selectionCornerOffset = \
Math.abs((_selections$getCell$g = selections === null || selections === void \
0 ? void 0 : selections.getCell().getBorder(facade).cornerCenterPointOffset) \
!== null && _selections$getCell$g !== void 0 ? _selections$getCell$g : 0);\n  \
  this.clone.wtTable.hider.style.height = this.hider.style.height;\n    \
holder2.style.height = holder2.parentNode.style.height;\n    \
holder2.style.width = `${parseInt(holder2.parentNode.style.width, 10) + \
selectionCornerOffset}px`;\n  }\n  /**\n   * Adjust the overlay dimensions \
and position.\n   */\n  applyToDOM() {\n    const total = \
this.wtSettings.getSetting(\"totalColumns\");\n    const styleProperty = \
this.isRtl() ? \"right\" : \"left\";\n    if (typeof \
this.wot.wtViewport.columnsRenderCalculator.startPosition === \"number\") {\n \
     this.spreader.style[styleProperty] = \
`${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;\n    } else \
if (total === 0) {\n      this.spreader.style[styleProperty] = \"0\";\n    } \
else {\n      throw new Error(\"Incorrect value of the \
columnsRenderCalculator\");\n    }\n    if (this.isRtl()) {\n      \
this.spreader.style.left = \"\";\n    } else {\n      \
this.spreader.style.right = \"\";\n    }\n    if (this.needFullRender) {\n    \
  this.syncOverlayOffset();\n    }\n  }\n  /**\n   * Synchronize calculated \
top position to an element.\n   */\n  syncOverlayOffset() {\n    if (typeof \
this.wot.wtViewport.rowsRenderCalculator.startPosition === \"number\") {\n    \
  this.clone.wtTable.spreader.style.top = \
`${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;\n    } else \
{\n      this.clone.wtTable.spreader.style.top = \"\";\n    }\n  }\n  /**\n   \
* Scrolls horizontally to a column at the left edge of the viewport.\n   *\n  \
 * @param {number} sourceCol  Column index which you want to scroll to.\n   * \
@param {boolean} [beyondRendered]  If `true`, scrolls according to the \
right\n   *                                    edge (left edge is by \
default).\n   * @returns {boolean}\n   */\n  scrollTo(sourceCol, \
beyondRendered) {\n    let newX = this.getTableParentOffset();\n    const \
sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;\n    \
const mainHolder = sourceInstance.wtTable.holder;\n    let \
scrollbarCompensation = 0;\n    if (beyondRendered) {\n      const \
columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);\n      const \
viewportWidth = this.wot.wtViewport.getViewportWidth();\n      if \
(columnWidth > viewportWidth) {\n        beyondRendered = false;\n      }\n   \
 }\n    if (beyondRendered && mainHolder.offsetWidth !== \
mainHolder.clientWidth) {\n      scrollbarCompensation = \
getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    if \
(beyondRendered) {\n      newX += this.sumCellSizes(0, sourceCol + 1);\n      \
newX -= this.wot.wtViewport.getViewportWidth();\n    } else {\n      newX += \
this.sumCellSizes(this.wtSettings.getSetting(\"fixedColumnsStart\"), \
sourceCol);\n    }\n    newX += scrollbarCompensation;\n    return \
this.setScrollPosition(newX);\n  }\n  /**\n   * Gets table parent left \
position.\n   *\n   * @returns {number}\n   */\n  getTableParentOffset() {\n  \
  const preventOverflow = this.wtSettings.getSetting(\"preventOverflow\");\n  \
  let offset3 = 0;\n    if (!preventOverflow && this.trimmingContainer === \
this.domBindings.rootWindow) {\n      offset3 = \
this.wot.wtTable.holderOffset.left;\n    }\n    return offset3;\n  }\n  /**\n \
  * Gets the main overlay's horizontal scroll position.\n   *\n   * @returns \
{number} Main table's horizontal scroll position.\n   */\n  \
getScrollPosition() {\n    return \
Math.abs(getScrollLeft(this.mainTableScrollableElement, \
this.domBindings.rootWindow));\n  }\n  /**\n   * Gets the main overlay's \
horizontal overlay offset.\n   *\n   * @returns {number} Main table's \
horizontal overlay offset.\n   */\n  getOverlayOffset() {\n    const {\n      \
rootWindow\n    } = this.domBindings;\n    const preventOverflow = \
this.wtSettings.getSetting(\"preventOverflow\");\n    let overlayOffset = \
0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || \
preventOverflow !== \"horizontal\")) {\n      if (this.isRtl()) {\n        \
overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - \
this.getScrollPosition(), 0));\n      } else {\n        overlayOffset = \
Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);\n      \
}\n      const rootWidth = this.wot.wtTable.getTotalWidth();\n      const \
overlayRootWidth = this.clone.wtTable.getTotalWidth();\n      const maxOffset \
= rootWidth - overlayRootWidth;\n      if (overlayOffset > maxOffset) {\n     \
   overlayOffset = 0;\n      }\n    }\n    return overlayOffset;\n  }\n  \
/**\n   * Adds css classes to hide the header border's header (cell-selection \
border hiding issue).\n   *\n   * @param {number} position Header X position \
if trimming container is window or scroll top if not.\n   * @returns \
{boolean}\n   */\n  adjustHeaderBordersPosition(position) {\n    const \
masterParent = this.wot.wtTable.holder.parentNode;\n    const rowHeaders = \
this.wtSettings.getSetting(\"rowHeaders\");\n    const fixedColumnsStart = \
this.wtSettings.getSetting(\"fixedColumnsStart\");\n    const totalRows = \
this.wtSettings.getSetting(\"totalRows\");\n    if (totalRows) {\n      \
removeClass(masterParent, \"emptyRows\");\n    } else {\n      \
addClass(masterParent, \"emptyRows\");\n    }\n    let positionChanged = \
false;\n    if (fixedColumnsStart && !rowHeaders.length) {\n      \
addClass(masterParent, \"innerBorderLeft innerBorderInlineStart\");\n    } \
else if (!fixedColumnsStart && rowHeaders.length) {\n      const \
previousState = hasClass(masterParent, \"innerBorderInlineStart\");\n      if \
(position) {\n        addClass(masterParent, \"innerBorderLeft \
innerBorderInlineStart\");\n        positionChanged = !previousState;\n      \
} else {\n        removeClass(masterParent, \"innerBorderLeft \
innerBorderInlineStart\");\n        positionChanged = previousState;\n      \
}\n    }\n    return positionChanged;\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/mixin/stickyRowsTop.\
mjs\nvar MIXIN_NAME5 = \"stickyRowsTop\";\nvar stickyRowsTop = {\n  /**\n   * \
Get the source index of the first rendered row. If no rows are rendered, \
returns an error code: -1.\n   *\n   * @returns {number}\n   * @this Table\n  \
 */\n  getFirstRenderedRow() {\n    const totalRows = \
this.wtSettings.getSetting(\"totalRows\");\n    if (totalRows === 0) {\n      \
return -1;\n    }\n    return 0;\n  },\n  /**\n   * Get the source index of \
the first row fully visible in the viewport. If no rows are fully visible, \
returns an error code: -1.\n   * Assumes that all rendered rows are fully \
visible.\n   *\n   * @returns {number}\n   * @this Table\n   */\n  \
getFirstVisibleRow() {\n    return this.getFirstRenderedRow();\n  },\n  /**\n \
  * Get the source index of the last rendered row. If no rows are rendered, \
returns an error code: -1.\n   *\n   * @returns {number}\n   * @this Table\n  \
 */\n  getLastRenderedRow() {\n    return this.getRenderedRowsCount() - 1;\n  \
},\n  /**\n   * Get the source index of the last row fully visible in the \
viewport. If no rows are fully visible, returns an error code: -1.\n   * \
Assumes that all rendered rows are fully visible.\n   *\n   * @returns \
{number}\n   * @this Table\n   */\n  getLastVisibleRow() {\n    return \
this.getLastRenderedRow();\n  },\n  /**\n   * Get the number of rendered \
rows.\n   *\n   * @returns {number}\n   * @this Table\n   */\n  \
getRenderedRowsCount() {\n    const totalRows = \
this.wtSettings.getSetting(\"totalRows\");\n    return \
Math.min(this.wtSettings.getSetting(\"fixedRowsTop\"), totalRows);\n  },\n  \
/**\n   * Get the number of fully visible rows in the viewport.\n   * Assumes \
that all rendered rows are fully visible.\n   *\n   * @returns {number}\n   * \
@this Table\n   */\n  getVisibleRowsCount() {\n    return \
this.getRenderedRowsCount();\n  }\n};\ndefineGetter(stickyRowsTop, \
\"MIXIN_NAME\", MIXIN_NAME5, {\n  writable: false,\n  enumerable: \
false\n});\nvar stickyRowsTop_default = stickyRowsTop;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/topInlineStartCorner\
.mjs\nvar TopInlineStartCornerOverlayTable = class extends table_default {\n  \
/**\n   * @param {TableDao} dataAccessObject The data access object.\n   * \
@param {FacadeGetter} facadeGetter Function which return proper facade.\n   * \
@param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} \
wtSettings The Walkontable settings.\n   */\n  constructor(dataAccessObject, \
facadeGetter, domBindings, wtSettings) {\n    super(dataAccessObject, \
facadeGetter, domBindings, wtSettings, CLONE_TOP_INLINE_START_CORNER);\n  \
}\n};\nmixin(TopInlineStartCornerOverlayTable, \
stickyRowsTop_default);\nmixin(TopInlineStartCornerOverlayTable, \
stickyColumnsStart_default);\nvar topInlineStartCorner_default = \
TopInlineStartCornerOverlayTable;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/overlay/topInlineStartCorn\
er.mjs\nfunction _defineProperty9(obj, key, value) {\n  key = \
_toPropertyKey9(key);\n  if (key in obj) {\n    Object.defineProperty(obj, \
key, { value, enumerable: true, configurable: true, writable: true });\n  } \
else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction \
_toPropertyKey9(arg) {\n  var key = _toPrimitive9(arg, \"string\");\n  return \
typeof key === \"symbol\" ? key : String(key);\n}\nfunction \
_toPrimitive9(input, hint) {\n  if (typeof input !== \"object\" || input === \
null)\n    return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim \
!== void 0) {\n    var res = prim.call(input, hint || \"default\");\n    if \
(typeof res !== \"object\")\n      return res;\n    throw new \
TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return \
(hint === \"string\" ? String : Number)(input);\n}\nvar \
TopInlineStartCornerOverlay = class extends Overlay {\n  /**\n   * @param \
{Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check \
if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which \
return proper facade.\n   * @param {Settings} wtSettings The Walkontable \
settings.\n   * @param {DomBindings} domBindings Dom elements bound to the \
current instance.\n   * @param {TopOverlay} topOverlay The instance of the \
Top overlay.\n   * @param {InlineStartOverlay} inlineStartOverlay The \
instance of the InlineStart overlay.\n   */\n  constructor(wotInstance, \
facadeGetter, wtSettings, domBindings, topOverlay, inlineStartOverlay) {\n    \
super(wotInstance, facadeGetter, CLONE_TOP_INLINE_START_CORNER, wtSettings, \
domBindings);\n    _defineProperty9(this, \"topOverlay\", void 0);\n    \
_defineProperty9(this, \"inlineStartOverlay\", void 0);\n    this.topOverlay \
= topOverlay;\n    this.inlineStartOverlay = inlineStartOverlay;\n  }\n  \
/**\n   * Factory method to create a subclass of `Table` that is relevant to \
this overlay.\n   *\n   * @see Table#constructor\n   * @param {...*} args \
Parameters that will be forwarded to the `Table` constructor.\n   * @returns \
{TopInlineStartCornerOverlayTable}\n   */\n  createTable() {\n    for (var \
_len = arguments.length, args = new Array(_len), _key = 0; _key < _len; \
_key++) {\n      args[_key] = arguments[_key];\n    }\n    return new \
topInlineStartCorner_default(...args);\n  }\n  /**\n   * Checks if overlay \
should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  \
shouldBeRendered() {\n    return \
this.wtSettings.getSetting(\"shouldRenderTopOverlay\") && \
this.wtSettings.getSetting(\"shouldRenderInlineStartOverlay\");\n  }\n  /**\n \
  * Updates the corner overlay position.\n   *\n   * @returns {boolean}\n   \
*/\n  resetFixedPosition() {\n    this.updateTrimmingContainer();\n    if \
(!this.wot.wtTable.holder.parentNode) {\n      return false;\n    }\n    \
const overlayRoot = this.clone.wtTable.holder.parentNode;\n    if \
(this.trimmingContainer === this.domBindings.rootWindow) {\n      const left2 \
= this.inlineStartOverlay.getOverlayOffset() * (this.isRtl() ? -1 : 1);\n     \
 const top2 = this.topOverlay.getOverlayOffset();\n      \
setOverlayPosition(overlayRoot, `${left2}px`, `${top2}px`);\n    } else {\n   \
   resetCssTransform(overlayRoot);\n    }\n    let tableHeight = \
outerHeight(this.clone.wtTable.TABLE);\n    const tableWidth = \
outerWidth(this.clone.wtTable.TABLE);\n    if \
(!this.wot.wtTable.hasDefinedSize()) {\n      tableHeight = 0;\n    }\n    \
overlayRoot.style.height = `${tableHeight}px`;\n    overlayRoot.style.width = \
`${tableWidth}px`;\n    return false;\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/top.mjs\nvar \
TopOverlayTable = class extends table_default {\n  /**\n   * @param \
{TableDao} dataAccessObject The data access object.\n   * @param \
{FacadeGetter} facadeGetter Function which return proper facade.\n   * @param \
{DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} \
wtSettings The Walkontable settings.\n   */\n  constructor(dataAccessObject, \
facadeGetter, domBindings, wtSettings) {\n    super(dataAccessObject, \
facadeGetter, domBindings, wtSettings, CLONE_TOP);\n  \
}\n};\nmixin(TopOverlayTable, stickyRowsTop_default);\nmixin(TopOverlayTable, \
calculatedColumns_default);\nvar top_default = TopOverlayTable;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/overlay/top.mjs\nfunction \
_defineProperty10(obj, key, value) {\n  key = _toPropertyKey10(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey10(arg) {\n  var key = \
_toPrimitive10(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive10(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar TopOverlay = class extends Overlay {\n  /**\n   * \
@param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: \
check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function \
which return proper facade.\n   * @param {Settings} wtSettings The \
Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements \
bound to the current instance.\n   */\n  constructor(wotInstance, \
facadeGetter, wtSettings, domBindings) {\n    super(wotInstance, \
facadeGetter, CLONE_TOP, wtSettings, domBindings);\n    \
_defineProperty10(this, \"cachedFixedRowsTop\", -1);\n    \
this.cachedFixedRowsTop = this.wtSettings.getSetting(\"fixedRowsTop\");\n  \
}\n  /**\n   * Factory method to create a subclass of `Table` that is \
relevant to this overlay.\n   *\n   * @see Table#constructor\n   * @param \
{...*} args Parameters that will be forwarded to the `Table` constructor.\n   \
* @returns {TopOverlayTable}\n   */\n  createTable() {\n    for (var _len = \
arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n  \
    args[_key] = arguments[_key];\n    }\n    return new \
top_default(...args);\n  }\n  /**\n   * Checks if overlay should be fully \
rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    \
return this.wtSettings.getSetting(\"shouldRenderTopOverlay\");\n  }\n  /**\n  \
 * Updates the top overlay position.\n   *\n   * @returns {boolean}\n   */\n  \
resetFixedPosition() {\n    if (!this.needFullRender || \
!this.wot.wtTable.holder.parentNode) {\n      return false;\n    }\n    const \
overlayRoot = this.clone.wtTable.holder.parentNode;\n    const {\n      \
rootWindow\n    } = this.domBindings;\n    const preventOverflow = \
this.wtSettings.getSetting(\"preventOverflow\");\n    let overlayPosition = \
0;\n    let skipInnerBorderAdjusting = false;\n    if (this.trimmingContainer \
=== rootWindow && (!preventOverflow || preventOverflow !== \"vertical\")) {\n \
     const {\n        wtTable\n      } = this.wot;\n      const hiderRect = \
wtTable.hider.getBoundingClientRect();\n      const bottom2 = \
Math.ceil(hiderRect.bottom);\n      const rootHeight = \
overlayRoot.offsetHeight;\n      skipInnerBorderAdjusting = bottom2 === \
rootHeight;\n      overlayPosition = this.getOverlayOffset();\n      \
setOverlayPosition(overlayRoot, \"0px\", `${overlayPosition}px`);\n    } else \
{\n      overlayPosition = this.getScrollPosition();\n      \
resetCssTransform(overlayRoot);\n    }\n    const positionChanged = \
this.adjustHeaderBordersPosition(overlayPosition, \
skipInnerBorderAdjusting);\n    this.adjustElementsSize();\n    return \
positionChanged;\n  }\n  /**\n   * Sets the main overlay's vertical scroll \
position.\n   *\n   * @param {number} pos The scroll position.\n   * @returns \
{boolean}\n   */\n  setScrollPosition(pos) {\n    const rootWindow = \
this.domBindings.rootWindow;\n    let result = false;\n    if \
(this.mainTableScrollableElement === rootWindow && rootWindow.scrollY !== \
pos) {\n      rootWindow.scrollTo(getWindowScrollLeft(rootWindow), pos);\n    \
  result = true;\n    } else if (this.mainTableScrollableElement.scrollTop \
!== pos) {\n      this.mainTableScrollableElement.scrollTop = pos;\n      \
result = true;\n    }\n    return result;\n  }\n  /**\n   * Triggers onScroll \
hook callback.\n   */\n  onScroll() {\n    \
this.wtSettings.getSetting(\"onScrollHorizontally\");\n  }\n  /**\n   * \
Calculates total sum cells height.\n   *\n   * @param {number} from Row index \
which calculates started from.\n   * @param {number} to Row index where \
calculation is finished.\n   * @returns {number} Height sum.\n   */\n  \
sumCellSizes(from, to) {\n    const defaultRowHeight = \
this.wtSettings.getSetting(\"defaultRowHeight\");\n    let row = from;\n    \
let sum = 0;\n    while (row < to) {\n      const height = \
this.wot.wtTable.getRowHeight(row);\n      sum += height === void 0 ? \
defaultRowHeight : height;\n      row += 1;\n    }\n    return sum;\n  }\n  \
/**\n   * Adjust overlay root element, childs and master table element sizes \
(width, height).\n   *\n   * @param {boolean} [force=false] When `true`, it \
adjusts the DOM nodes sizes for that overlay.\n   */\n  adjustElementsSize() \
{\n    let force = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : false;\n    this.updateTrimmingContainer();\n    if \
(this.needFullRender || force) {\n      this.adjustRootElementSize();\n      \
this.adjustRootChildrenSize();\n    }\n  }\n  /**\n   * Adjust overlay root \
element size (width and height).\n   */\n  adjustRootElementSize() {\n    \
const {\n      wtTable\n    } = this.wot;\n    const {\n      rootDocument,\n \
     rootWindow\n    } = this.domBindings;\n    const scrollbarWidth = \
getScrollbarWidth(rootDocument);\n    const overlayRoot = \
this.clone.wtTable.holder.parentNode;\n    const overlayRootStyle = \
overlayRoot.style;\n    const preventOverflow = \
this.wtSettings.getSetting(\"preventOverflow\");\n    if \
(this.trimmingContainer !== rootWindow || preventOverflow === \"horizontal\") \
{\n      let width = this.wot.wtViewport.getWorkspaceWidth();\n      if \
(this.wot.wtOverlays.hasScrollbarRight) {\n        width -= scrollbarWidth;\n \
     }\n      width = Math.min(width, wtTable.wtRootElement.scrollWidth);\n   \
   overlayRootStyle.width = `${width}px`;\n    } else {\n      \
overlayRootStyle.width = \"\";\n    }\n    \
this.clone.wtTable.holder.style.width = overlayRootStyle.width;\n    let \
tableHeight = outerHeight(this.clone.wtTable.TABLE);\n    if \
(!this.wot.wtTable.hasDefinedSize()) {\n      tableHeight = 0;\n    }\n    \
overlayRootStyle.height = `${tableHeight}px`;\n  }\n  /**\n   * Adjust \
overlay root childs size.\n   */\n  adjustRootChildrenSize() {\n    var \
_selections$getCell$g;\n    const {\n      holder: holder2\n    } = \
this.clone.wtTable;\n    const {\n      selections\n    } = this.wot;\n    \
const facade = this.facadeGetter();\n    const selectionCornerOffset = \
Math.abs((_selections$getCell$g = selections === null || selections === void \
0 ? void 0 : selections.getCell().getBorder(facade).cornerCenterPointOffset) \
!== null && _selections$getCell$g !== void 0 ? _selections$getCell$g : 0);\n  \
  this.clone.wtTable.hider.style.width = this.hider.style.width;\n    \
holder2.style.width = holder2.parentNode.style.width;\n    \
holder2.style.height = `${parseInt(holder2.parentNode.style.height, 10) + \
selectionCornerOffset}px`;\n  }\n  /**\n   * Adjust the overlay dimensions \
and position.\n   */\n  applyToDOM() {\n    const total = \
this.wtSettings.getSetting(\"totalRows\");\n    if (typeof \
this.wot.wtViewport.rowsRenderCalculator.startPosition === \"number\") {\n    \
  this.spreader.style.top = \
`${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;\n    } else if \
(total === 0) {\n      this.spreader.style.top = \"0\";\n    } else {\n      \
throw new Error(\"Incorrect value of the rowsRenderCalculator\");\n    }\n    \
this.spreader.style.bottom = \"\";\n    if (this.needFullRender) {\n      \
this.syncOverlayOffset();\n    }\n  }\n  /**\n   * Synchronize calculated \
left position to an element.\n   */\n  syncOverlayOffset() {\n    const \
styleProperty = this.isRtl() ? \"right\" : \"left\";\n    const {\n      \
spreader\n    } = this.clone.wtTable;\n    if (typeof \
this.wot.wtViewport.columnsRenderCalculator.startPosition === \"number\") {\n \
     spreader.style[styleProperty] = \
`${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;\n    } else \
{\n      spreader.style[styleProperty] = \"\";\n    }\n  }\n  /**\n   * \
Scrolls vertically to a row.\n   *\n   * @param {number} sourceRow Row index \
which you want to scroll to.\n   * @param {boolean} [bottomEdge] If `true`, \
scrolls according to the bottom edge (top edge is by default).\n   * @returns \
{boolean}\n   */\n  scrollTo(sourceRow, bottomEdge) {\n    const {\n      \
wot,\n      wtSettings\n    } = this;\n    const sourceInstance = \
wot.cloneSource ? wot.cloneSource : wot;\n    const mainHolder = \
sourceInstance.wtTable.holder;\n    let newY = this.getTableParentOffset();\n \
   let scrollbarCompensation = 0;\n    if (bottomEdge) {\n      const \
rowHeight = this.wot.wtTable.getRowHeight(sourceRow);\n      const \
viewportHeight = this.wot.wtViewport.getViewportHeight();\n      if \
(rowHeight > viewportHeight) {\n        bottomEdge = false;\n      }\n    }\n \
   if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {\n \
     scrollbarCompensation = \
getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    if (bottomEdge) \
{\n      const fixedRowsBottom = \
wtSettings.getSetting(\"fixedRowsBottom\");\n      const totalRows = \
wtSettings.getSetting(\"totalRows\");\n      newY += this.sumCellSizes(0, \
sourceRow + 1);\n      newY -= wot.wtViewport.getViewportHeight() - \
this.sumCellSizes(totalRows - fixedRowsBottom, totalRows);\n      newY += \
1;\n    } else {\n      newY += \
this.sumCellSizes(wtSettings.getSetting(\"fixedRowsTop\"), sourceRow);\n    \
}\n    newY += scrollbarCompensation;\n    return \
this.setScrollPosition(newY);\n  }\n  /**\n   * Gets table parent top \
position.\n   *\n   * @returns {number}\n   */\n  getTableParentOffset() {\n  \
  if (this.mainTableScrollableElement === this.domBindings.rootWindow) {\n    \
  return this.wot.wtTable.holderOffset.top;\n    }\n    return 0;\n  }\n  \
/**\n   * Gets the main overlay's vertical scroll position.\n   *\n   * \
@returns {number} Main table's vertical scroll position.\n   */\n  \
getScrollPosition() {\n    return \
getScrollTop(this.mainTableScrollableElement, this.domBindings.rootWindow);\n \
 }\n  /**\n   * Gets the main overlay's vertical overlay offset.\n   *\n   * \
@returns {number} Main table's vertical overlay offset.\n   */\n  \
getOverlayOffset() {\n    const {\n      rootWindow\n    } = \
this.domBindings;\n    const preventOverflow = \
this.wtSettings.getSetting(\"preventOverflow\");\n    let overlayOffset = \
0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || \
preventOverflow !== \"vertical\")) {\n      const rootHeight = \
this.wot.wtTable.getTotalHeight();\n      const overlayRootHeight = \
this.clone.wtTable.getTotalHeight();\n      const maxOffset = rootHeight - \
overlayRootHeight;\n      overlayOffset = Math.max(this.getScrollPosition() - \
this.getTableParentOffset(), 0);\n      if (overlayOffset > maxOffset) {\n    \
    overlayOffset = 0;\n      }\n    }\n    return overlayOffset;\n  }\n  \
/**\n   * Adds css classes to hide the header border's header (cell-selection \
border hiding issue).\n   *\n   * @param {number} position Header Y position \
if trimming container is window or scroll top if not.\n   * @param {boolean} \
[skipInnerBorderAdjusting=false] If `true` the inner border adjusting will be \
skipped.\n   * @returns {boolean}\n   */\n  \
adjustHeaderBordersPosition(position) {\n    let skipInnerBorderAdjusting = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    \
const masterParent = this.wot.wtTable.holder.parentNode;\n    const \
totalColumns = this.wtSettings.getSetting(\"totalColumns\");\n    if \
(totalColumns) {\n      removeClass(masterParent, \"emptyColumns\");\n    } \
else {\n      addClass(masterParent, \"emptyColumns\");\n    }\n    let \
positionChanged = false;\n    if (!skipInnerBorderAdjusting) {\n      const \
fixedRowsTop = this.wtSettings.getSetting(\"fixedRowsTop\");\n      const \
areFixedRowsTopChanged = this.cachedFixedRowsTop !== fixedRowsTop;\n      \
const columnHeaders = this.wtSettings.getSetting(\"columnHeaders\");\n      \
if ((areFixedRowsTopChanged || fixedRowsTop === 0) && columnHeaders.length > \
0) {\n        const previousState = hasClass(masterParent, \
\"innerBorderTop\");\n        this.cachedFixedRowsTop = \
this.wtSettings.getSetting(\"fixedRowsTop\");\n        if (position || \
this.wtSettings.getSetting(\"totalRows\") === 0) {\n          \
addClass(masterParent, \"innerBorderTop\");\n          positionChanged = \
!previousState;\n        } else {\n          removeClass(masterParent, \
\"innerBorderTop\");\n          positionChanged = previousState;\n        }\n \
     }\n    }\n    return positionChanged;\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/overlays.mjs\nfunction \
_defineProperty11(obj, key, value) {\n  key = _toPropertyKey11(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey11(arg) {\n  var key = \
_toPrimitive11(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive11(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar Overlays = class {\n  /**\n   * @param {Walkontable} \
wotInstance The Walkontable instance. @todo refactoring remove.\n   * @param \
{FacadeGetter} facadeGetter Function which return proper facade.\n   * @param \
{DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} \
wtSettings The Walkontable settings.\n   * @param {EventManager} eventManager \
The walkontable event manager.\n   * @param {MasterTable} wtTable The master \
table.\n   */\n  constructor(wotInstance, facadeGetter, domBindings, \
wtSettings, eventManager, wtTable) {\n    _defineProperty11(this, \"wot\", \
null);\n    _defineProperty11(this, \"topOverlay\", null);\n    \
_defineProperty11(this, \"bottomOverlay\", null);\n    \
_defineProperty11(this, \"inlineStartOverlay\", null);\n    \
_defineProperty11(this, \"topInlineStartCornerOverlay\", null);\n    \
_defineProperty11(this, \"bottomInlineStartCornerOverlay\", null);\n    \
_defineProperty11(this, \"browserLineHeight\", void 0);\n    \
_defineProperty11(this, \"wtSettings\", null);\n    _defineProperty11(this, \
\"resizeObserver\", new ResizeObserver((entries) => {\n      \
requestAnimationFrame(() => {\n        if (!Array.isArray(entries) || \
!entries.length) {\n          return;\n        }\n        \
this.wtSettings.getSetting(\"onContainerElementResize\");\n      });\n    \
}));\n    this.wot = wotInstance;\n    this.wtSettings = wtSettings;\n    \
this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    \
this.wtTable = wtTable;\n    const {\n      rootDocument,\n      rootWindow\n \
   } = this.domBindings;\n    this.instance = this.wot;\n    \
this.eventManager = eventManager;\n    this.scrollbarSize = \
getScrollbarWidth(rootDocument);\n    const isOverflowHidden = \
rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValu\
e(\"overflow\") === \"hidden\";\n    this.scrollableElement = \
isOverflowHidden ? wtTable.holder : getScrollableElement(wtTable.TABLE);\n    \
this.initOverlays();\n    this.hasScrollbarBottom = false;\n    \
this.hasScrollbarRight = false;\n    this.destroyed = false;\n    \
this.keyPressed = false;\n    this.spreaderLastSize = {\n      width: null,\n \
     height: null\n    };\n    this.verticalScrolling = false;\n    \
this.horizontalScrolling = false;\n    this.initBrowserLineHeight();\n    \
this.registerListeners();\n    this.lastScrollX = rootWindow.scrollX;\n    \
this.lastScrollY = rootWindow.scrollY;\n  }\n  /**\n   * Get the list of \
references to all overlays.\n   *\n   * @param {boolean} [includeMaster = \
false] If set to `true`, the list will contain the master table as the last\n \
  * element.\n   * @returns \
{(TopOverlay|TopInlineStartCornerOverlay|InlineStartOverlay|BottomOverlay|Bot\
tomInlineStartCornerOverlay)[]}\n   */\n  getOverlays() {\n    let \
includeMaster = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : false;\n    const overlays = [this.topOverlay, \
this.topInlineStartCornerOverlay, this.inlineStartOverlay, \
this.bottomOverlay, this.bottomInlineStartCornerOverlay];\n    if \
(includeMaster) {\n      overlays.push(this.wtTable);\n    }\n    return \
overlays;\n  }\n  /**\n   * Retrieve browser line height and apply its value \
to `browserLineHeight`.\n   *\n   * @private\n   */\n  \
initBrowserLineHeight() {\n    const {\n      rootWindow,\n      \
rootDocument\n    } = this.domBindings;\n    const computedStyle = \
rootWindow.getComputedStyle(rootDocument.body);\n    const lineHeight = \
parseInt(computedStyle.lineHeight, 10);\n    const lineHeightFalback = \
parseInt(computedStyle.fontSize, 10) * 1.2;\n    this.browserLineHeight = \
lineHeight || lineHeightFalback;\n  }\n  /**\n   * Prepare overlays based on \
user settings.\n   *\n   * @private\n   */\n  initOverlays() {\n    const \
args = [this.wot, this.facadeGetter, this.wtSettings, this.domBindings];\n    \
this.topOverlay = new TopOverlay(...args);\n    this.bottomOverlay = new \
BottomOverlay(...args);\n    this.inlineStartOverlay = new \
InlineStartOverlay(...args);\n    this.topInlineStartCornerOverlay = new \
TopInlineStartCornerOverlay(...args, this.topOverlay, \
this.inlineStartOverlay);\n    this.bottomInlineStartCornerOverlay = new \
BottomInlineStartCornerOverlay(...args, this.bottomOverlay, \
this.inlineStartOverlay);\n  }\n  /**\n   * Update state of rendering, check \
if changed.\n   *\n   * @package\n   * @returns {boolean} Returns `true` if \
changes applied to overlay needs scroll synchronization.\n   */\n  \
updateStateOfRendering() {\n    let syncScroll = \
this.topOverlay.updateStateOfRendering();\n    syncScroll = \
this.bottomOverlay.updateStateOfRendering() || syncScroll;\n    syncScroll = \
this.inlineStartOverlay.updateStateOfRendering() || syncScroll;\n    if \
(this.inlineStartOverlay.needFullRender) {\n      if \
(this.topOverlay.needFullRender) {\n        syncScroll = \
this.topInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;\n    \
  }\n      if (this.bottomOverlay.needFullRender) {\n        syncScroll = \
this.bottomInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;\n \
     }\n    }\n    return syncScroll;\n  }\n  /**\n   * Refresh and redraw \
table.\n   */\n  refreshAll() {\n    if (!this.wot.drawn) {\n      return;\n  \
  }\n    if (!this.wtTable.holder.parentNode) {\n      this.destroy();\n      \
return;\n    }\n    this.wot.draw(true);\n    if (this.verticalScrolling) {\n \
     this.inlineStartOverlay.onScroll();\n    }\n    if \
(this.horizontalScrolling) {\n      this.topOverlay.onScroll();\n    }\n    \
this.verticalScrolling = false;\n    this.horizontalScrolling = false;\n  }\n \
 /**\n   * Register all necessary event listeners.\n   */\n  \
registerListeners() {\n    const {\n      rootDocument,\n      rootWindow\n   \
 } = this.domBindings;\n    const {\n      mainTableScrollableElement: \
topOverlayScrollableElement\n    } = this.topOverlay;\n    const {\n      \
mainTableScrollableElement: inlineStartOverlayScrollableElement\n    } = \
this.inlineStartOverlay;\n    \
this.eventManager.addEventListener(rootDocument.documentElement, \"keydown\", \
(event2) => this.onKeyDown(event2));\n    \
this.eventManager.addEventListener(rootDocument.documentElement, \"keyup\", \
() => this.onKeyUp());\n    this.eventManager.addEventListener(rootDocument, \
\"visibilitychange\", () => this.onKeyUp());\n    \
this.eventManager.addEventListener(topOverlayScrollableElement, \"scroll\", \
(event2) => this.onTableScroll(event2), {\n      passive: true\n    });\n    \
if (topOverlayScrollableElement !== inlineStartOverlayScrollableElement) {\n  \
    this.eventManager.addEventListener(inlineStartOverlayScrollableElement, \
\"scroll\", (event2) => this.onTableScroll(event2), {\n        passive: \
true\n      });\n    }\n    const isHighPixelRatio = \
rootWindow.devicePixelRatio && rootWindow.devicePixelRatio > 1;\n    const \
isScrollOnWindow = this.scrollableElement === rootWindow;\n    const \
preventWheel = this.wtSettings.getSetting(\"preventWheel\");\n    const \
wheelEventOptions = {\n      passive: isScrollOnWindow\n    };\n    if \
(preventWheel || isHighPixelRatio || !isChrome()) {\n      \
this.eventManager.addEventListener(this.wtTable.wtRootElement, \"wheel\", \
(event2) => this.onCloneWheel(event2, preventWheel), wheelEventOptions);\n    \
}\n    const overlays = [this.topOverlay, this.bottomOverlay, \
this.inlineStartOverlay, this.topInlineStartCornerOverlay, \
this.bottomInlineStartCornerOverlay];\n    overlays.forEach((overlay) => {\n  \
    if (overlay && overlay.needFullRender) {\n        const {\n          \
holder: holder2\n        } = overlay.clone.wtTable;\n        \
this.eventManager.addEventListener(holder2, \"wheel\", (event2) => \
this.onCloneWheel(event2, preventWheel), wheelEventOptions);\n      }\n    \
});\n    let resizeTimeout;\n    \
this.eventManager.addEventListener(rootWindow, \"resize\", () => {\n      \
clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n      \
  this.wtSettings.getSetting(\"onWindowResize\");\n      }, 200);\n    });\n  \
  if (!isScrollOnWindow) {\n      \
this.resizeObserver.observe(this.wtTable.wtRootElement.parentElement);\n    \
}\n  }\n  /**\n   * Deregister all previously registered listeners.\n   */\n  \
deregisterListeners() {\n    this.eventManager.clearEvents(true);\n  }\n  \
/**\n   * Scroll listener.\n   *\n   * @param {Event} event The mouse event \
object.\n   */\n  onTableScroll(event2) {\n    const rootWindow = \
this.domBindings.rootWindow;\n    const masterHorizontal = \
this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical \
= this.topOverlay.mainTableScrollableElement;\n    const target = \
event2.target;\n    if (this.keyPressed) {\n      if (masterVertical !== \
rootWindow && target !== rootWindow && \
!event2.target.contains(masterVertical) || masterHorizontal !== rootWindow && \
target !== rootWindow && !event2.target.contains(masterHorizontal)) {\n       \
 return;\n      }\n    }\n    this.syncScrollPositions(event2);\n  }\n  /**\n \
  * Wheel listener for cloned overlays.\n   *\n   * @param {Event} event The \
mouse event object.\n   * @param {boolean} preventDefault If `true`, the \
`preventDefault` will be called on event object.\n   */\n  \
onCloneWheel(event2, preventDefault) {\n    const {\n      rootWindow\n    } \
= this.domBindings;\n    const masterHorizontal = \
this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical \
= this.topOverlay.mainTableScrollableElement;\n    const target = \
event2.target;\n    const shouldNotWheelVertically = masterVertical !== \
rootWindow && target !== rootWindow && !target.contains(masterVertical);\n    \
const shouldNotWheelHorizontally = masterHorizontal !== rootWindow && target \
!== rootWindow && !target.contains(masterHorizontal);\n    if \
(this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally)) \
{\n      return;\n    }\n    const isScrollPossible = \
this.translateMouseWheelToScroll(event2);\n    if (preventDefault || \
this.scrollableElement !== rootWindow && isScrollPossible) {\n      \
event2.preventDefault();\n    }\n  }\n  /**\n   * Key down listener.\n   *\n  \
 * @param {Event} event The keyboard event object.\n   */\n  \
onKeyDown(event2) {\n    this.keyPressed = isKey(event2.keyCode, \
\"ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT\");\n  }\n  /**\n   * Key up \
listener.\n   */\n  onKeyUp() {\n    this.keyPressed = false;\n  }\n  /**\n   \
* Translate wheel event into scroll event and sync scroll overlays \
position.\n   *\n   * @private\n   * @param {Event} event The mouse event \
object.\n   * @returns {boolean}\n   */\n  \
translateMouseWheelToScroll(event2) {\n    let deltaY = isNaN(event2.deltaY) \
? -1 * event2.wheelDeltaY : event2.deltaY;\n    let deltaX = \
isNaN(event2.deltaX) ? -1 * event2.wheelDeltaX : event2.deltaX;\n    if \
(event2.deltaMode === 1) {\n      deltaX += deltaX * \
this.browserLineHeight;\n      deltaY += deltaY * this.browserLineHeight;\n   \
 }\n    const isScrollVerticallyPossible = this.scrollVertically(deltaY);\n   \
 const isScrollHorizontallyPossible = this.scrollHorizontally(deltaX);\n    \
return isScrollVerticallyPossible || isScrollHorizontallyPossible;\n  }\n  \
/**\n   * Scrolls main scrollable element horizontally.\n   *\n   * @param \
{number} delta Relative value to scroll.\n   * @returns {boolean}\n   */\n  \
scrollVertically(delta) {\n    const previousScroll = \
this.scrollableElement.scrollTop;\n    this.scrollableElement.scrollTop += \
delta;\n    return previousScroll !== this.scrollableElement.scrollTop;\n  \
}\n  /**\n   * Scrolls main scrollable element horizontally.\n   *\n   * \
@param {number} delta Relative value to scroll.\n   * @returns {boolean}\n   \
*/\n  scrollHorizontally(delta) {\n    const previousScroll = \
this.scrollableElement.scrollLeft;\n    this.scrollableElement.scrollLeft += \
delta;\n    return previousScroll !== this.scrollableElement.scrollLeft;\n  \
}\n  /**\n   * Synchronize scroll position between master table and overlay \
table.\n   *\n   * @private\n   */\n  syncScrollPositions() {\n    if \
(this.destroyed) {\n      return;\n    }\n    const {\n      rootWindow\n    \
} = this.domBindings;\n    const topHolder = \
this.topOverlay.clone.wtTable.holder;\n    const leftHolder = \
this.inlineStartOverlay.clone.wtTable.holder;\n    const [scrollLeft, \
scrollTop] = [this.scrollableElement.scrollLeft, \
this.scrollableElement.scrollTop];\n    this.horizontalScrolling = \
topHolder.scrollLeft !== scrollLeft || this.lastScrollX !== \
rootWindow.scrollX;\n    this.verticalScrolling = leftHolder.scrollTop !== \
scrollTop || this.lastScrollY !== rootWindow.scrollY;\n    this.lastScrollX = \
rootWindow.scrollX;\n    this.lastScrollY = rootWindow.scrollY;\n    if \
(this.horizontalScrolling) {\n      topHolder.scrollLeft = scrollLeft;\n      \
const bottomHolder = this.bottomOverlay.needFullRender ? \
this.bottomOverlay.clone.wtTable.holder : null;\n      if (bottomHolder) {\n  \
      bottomHolder.scrollLeft = scrollLeft;\n      }\n    }\n    if \
(this.verticalScrolling) {\n      leftHolder.scrollTop = scrollTop;\n    }\n  \
  this.refreshAll();\n  }\n  /**\n   * Synchronize overlay scrollbars with \
the master scrollbar.\n   */\n  syncScrollWithMaster() {\n    const master = \
this.topOverlay.mainTableScrollableElement;\n    const {\n      scrollLeft,\n \
     scrollTop\n    } = master;\n    if (this.topOverlay.needFullRender) {\n  \
    this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;\n    }\n    \
if (this.bottomOverlay.needFullRender) {\n      \
this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;\n    }\n    \
if (this.inlineStartOverlay.needFullRender) {\n      \
this.inlineStartOverlay.clone.wtTable.holder.scrollTop = scrollTop;\n    }\n  \
}\n  /**\n   * Update the main scrollable elements for all the overlays.\n   \
*/\n  updateMainScrollableElements() {\n    this.deregisterListeners();\n    \
this.inlineStartOverlay.updateMainScrollableElement();\n    \
this.topOverlay.updateMainScrollableElement();\n    if \
(this.bottomOverlay.needFullRender) {\n      \
this.bottomOverlay.updateMainScrollableElement();\n    }\n    const {\n      \
wtTable\n    } = this;\n    const {\n      rootWindow\n    } = \
this.domBindings;\n    if \
(rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyVal\
ue(\"overflow\") === \"hidden\") {\n      this.scrollableElement = \
wtTable.holder;\n    } else {\n      this.scrollableElement = \
getScrollableElement(wtTable.TABLE);\n    }\n    this.registerListeners();\n  \
}\n  /**\n   *\n   */\n  destroy() {\n    this.resizeObserver.disconnect();\n \
   this.eventManager.destroy();\n    this.topOverlay.destroy();\n    if \
(this.bottomOverlay.clone) {\n      this.bottomOverlay.destroy();\n    }\n    \
this.inlineStartOverlay.destroy();\n    if (this.topInlineStartCornerOverlay) \
{\n      this.topInlineStartCornerOverlay.destroy();\n    }\n    if \
(this.bottomInlineStartCornerOverlay && \
this.bottomInlineStartCornerOverlay.clone) {\n      \
this.bottomInlineStartCornerOverlay.destroy();\n    }\n    this.destroyed = \
true;\n  }\n  /**\n   * @param {boolean} [fastDraw=false] When `true`, try to \
refresh only the positions of borders without rerendering\n   *               \
                    the data. It will only work if Table.draw() does not \
force\n   *                                   rendering anyway.\n   */\n  \
refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== void \
0 ? arguments[0] : false;\n    const wasSpreaderSizeUpdated = \
this.updateLastSpreaderSize();\n    if (wasSpreaderSizeUpdated) {\n      \
this.adjustElementsSize();\n    }\n    if (this.bottomOverlay.clone) {\n      \
this.bottomOverlay.refresh(fastDraw);\n    }\n    \
this.inlineStartOverlay.refresh(fastDraw);\n    \
this.topOverlay.refresh(fastDraw);\n    if (this.topInlineStartCornerOverlay) \
{\n      this.topInlineStartCornerOverlay.refresh(fastDraw);\n    }\n    if \
(this.bottomInlineStartCornerOverlay && \
this.bottomInlineStartCornerOverlay.clone) {\n      \
this.bottomInlineStartCornerOverlay.refresh(fastDraw);\n    }\n  }\n  /**\n   \
* Update the last cached spreader size with the current size.\n   *\n   * \
@returns {boolean} `true` if the lastSpreaderSize cache was updated, `false` \
otherwise.\n   */\n  updateLastSpreaderSize() {\n    const spreader = \
this.wtTable.spreader;\n    const width = spreader.clientWidth;\n    const \
height = spreader.clientHeight;\n    const needsUpdating = width !== \
this.spreaderLastSize.width || height !== this.spreaderLastSize.height;\n    \
if (needsUpdating) {\n      this.spreaderLastSize.width = width;\n      \
this.spreaderLastSize.height = height;\n    }\n    return needsUpdating;\n  \
}\n  /**\n   * Adjust overlays elements size and master table size.\n   *\n   \
* @param {boolean} [force=false] When `true`, it adjust the DOM nodes sizes \
for all overlays.\n   */\n  adjustElementsSize() {\n    let force = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    \
const {\n      wtViewport\n    } = this.wot;\n    const {\n      wtTable\n    \
} = this;\n    const totalColumns = \
this.wtSettings.getSetting(\"totalColumns\");\n    const totalRows = \
this.wtSettings.getSetting(\"totalRows\");\n    const headerRowSize = \
wtViewport.getRowHeaderWidth();\n    const headerColumnSize = \
wtViewport.getColumnHeaderHeight();\n    const hiderStyle = \
wtTable.hider.style;\n    hiderStyle.width = `${headerRowSize + \
this.inlineStartOverlay.sumCellSizes(0, totalColumns)}px`;\n    \
hiderStyle.height = `${headerColumnSize + this.topOverlay.sumCellSizes(0, \
totalRows) + 1}px`;\n    if (this.scrollbarSize > 0) {\n      const {\n       \
 scrollHeight: rootElemScrollHeight,\n        scrollWidth: \
rootElemScrollWidth\n      } = wtTable.wtRootElement;\n      const {\n        \
scrollHeight: holderScrollHeight,\n        scrollWidth: holderScrollWidth\n   \
   } = wtTable.holder;\n      this.hasScrollbarRight = rootElemScrollHeight < \
holderScrollHeight;\n      this.hasScrollbarBottom = rootElemScrollWidth < \
holderScrollWidth;\n      if (this.hasScrollbarRight && \
wtTable.hider.scrollWidth + this.scrollbarSize > rootElemScrollWidth) {\n     \
   this.hasScrollbarBottom = true;\n      } else if (this.hasScrollbarBottom \
&& wtTable.hider.scrollHeight + this.scrollbarSize > rootElemScrollHeight) \
{\n        this.hasScrollbarRight = true;\n      }\n    }\n    \
this.topOverlay.adjustElementsSize(force);\n    \
this.inlineStartOverlay.adjustElementsSize(force);\n    \
this.bottomOverlay.adjustElementsSize(force);\n  }\n  /**\n   *\n   */\n  \
applyToDOM() {\n    if (!this.wtTable.isVisible()) {\n      return;\n    }\n  \
  this.topOverlay.applyToDOM();\n    if (this.bottomOverlay.clone) {\n      \
this.bottomOverlay.applyToDOM();\n    }\n    \
this.inlineStartOverlay.applyToDOM();\n  }\n  /**\n   * Get the parent \
overlay of the provided element.\n   *\n   * @param {HTMLElement} element An \
element to process.\n   * @returns {object|null}\n   */\n  \
getParentOverlay(element) {\n    if (!element) {\n      return null;\n    }\n \
   const overlays = [this.topOverlay, this.inlineStartOverlay, \
this.bottomOverlay, this.topInlineStartCornerOverlay, \
this.bottomInlineStartCornerOverlay];\n    let result = null;\n    \
arrayEach(overlays, (overlay) => {\n      if (!overlay) {\n        return;\n  \
    }\n      if (overlay.clone && \
overlay.clone.wtTable.TABLE.contains(element)) {\n        result = \
overlay.clone;\n      }\n    });\n    return result;\n  }\n  /**\n   * \
Synchronize the class names between the main overlay table and the tables on \
the other overlays.\n   *\n   */\n  syncOverlayTableClassNames() {\n    const \
masterTable = this.wtTable.TABLE;\n    const overlays = [this.topOverlay, \
this.inlineStartOverlay, this.bottomOverlay, \
this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    \
arrayEach(overlays, (elem) => {\n      if (!elem) {\n        return;\n      \
}\n      elem.clone.wtTable.TABLE.className = masterTable.className;\n    \
});\n  }\n};\nvar overlays_default = Overlays;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/settings.mjs\nfunction \
_defineProperty12(obj, key, value) {\n  key = _toPropertyKey12(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey12(arg) {\n  var key = \
_toPrimitive12(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive12(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar Settings = class {\n  /**\n   * @param {SettingsPure} \
settings The user defined settings.\n   */\n  constructor(settings) {\n    \
_defineProperty12(this, \"settings\", {});\n    _defineProperty12(this, \
\"defaults\", Object.freeze(this.getDefaults()));\n    \
objectEach(this.defaults, (value, key) => {\n      if (settings[key] !== void \
0) {\n        this.settings[key] = settings[key];\n      } else if (value === \
void 0) {\n        throw new Error(`A required setting \"${key}\" was not \
provided`);\n      } else {\n        this.settings[key] = value;\n      }\n   \
 });\n  }\n  /**\n   * Generate defaults for a settings.\n   * Void 0 means \
it is required, null means it can be empty.\n   *\n   * @private\n   * \
@returns {SettingsPure}\n   */\n  getDefaults() {\n    return {\n      \
facade: void 0,\n      table: void 0,\n      // Determines whether the \
Walkontable instance is used as dataset viewer. When its instance is used \
as\n      // a context menu, autocomplete list, etc, the returned value is \
`false`.\n      isDataViewInstance: true,\n      // presentation mode\n      \
externalRowCalculator: false,\n      stretchH: \"none\",\n      // values: \
all, last, none\n      currentRowClassName: null,\n      \
currentColumnClassName: null,\n      preventOverflow() {\n        return \
false;\n      },\n      preventWheel: false,\n      // data source\n      \
data: void 0,\n      freezeOverlays: false,\n      // Number of renderable \
columns for the left overlay.\n      fixedColumnsStart: 0,\n      // Number \
of renderable rows for the top overlay.\n      fixedRowsTop: 0,\n      // \
Number of renderable rows for the bottom overlay.\n      fixedRowsBottom: \
0,\n      // Enable the inline start overlay when conditions are met (left \
for LTR and right for RTL document mode).\n      \
shouldRenderInlineStartOverlay: () => {\n        return \
this.getSetting(\"fixedColumnsStart\") > 0 || \
this.getSetting(\"rowHeaders\").length > 0;\n      },\n      // Enable the \
top overlay when conditions are met.\n      shouldRenderTopOverlay: () => {\n \
       return this.getSetting(\"fixedRowsTop\") > 0 || \
this.getSetting(\"columnHeaders\").length > 0;\n      },\n      // Enable the \
bottom overlay when conditions are met.\n      shouldRenderBottomOverlay: () \
=> {\n        return this.getSetting(\"fixedRowsBottom\") > 0;\n      },\n    \
  minSpareRows: 0,\n      // this must be array of functions: [function (row, \
TH) {}]\n      rowHeaders() {\n        return [];\n      },\n      // this \
must be array of functions: [function (column, TH) {}]\n      columnHeaders() \
{\n        return [];\n      },\n      totalRows: void 0,\n      \
totalColumns: void 0,\n      cellRenderer: (row, column, TD) => {\n        \
const cellData = this.getSetting(\"data\", row, column);\n        \
fastInnerText(TD, cellData === void 0 || cellData === null ? \"\" : \
cellData);\n      },\n      // columnWidth: 50,\n      columnWidth() {\n      \
},\n      rowHeight() {\n      },\n      defaultRowHeight: 23,\n      \
defaultColumnWidth: 50,\n      selections: null,\n      \
hideBorderOnMouseDownOver: false,\n      viewportRowCalculatorOverride: \
null,\n      viewportColumnCalculatorOverride: null,\n      // callbacks\n    \
  onCellMouseDown: null,\n      onCellContextMenu: null,\n      \
onCellMouseOver: null,\n      onCellMouseOut: null,\n      onCellMouseUp: \
null,\n      //    onCellMouseOut: null,\n      onCellDblClick: null,\n      \
onCellCornerMouseDown: null,\n      onCellCornerDblClick: null,\n      \
beforeDraw: null,\n      onDraw: null,\n      onBeforeRemoveCellClassNames: \
null,\n      onAfterDrawSelection: null,\n      onBeforeDrawBorders: null,\n  \
    onScrollVertically: null,\n      onScrollHorizontally: null,\n      \
onBeforeTouchScroll: null,\n      onAfterMomentumScroll: null,\n      \
onBeforeStretchingColumnWidth: (width) => width,\n      \
onModifyRowHeaderWidth: null,\n      onModifyGetCellCoords: null,\n      \
onBeforeHighlightingRowHeader: (sourceRow) => sourceRow,\n      \
onBeforeHighlightingColumnHeader: (sourceCol) => sourceCol,\n      \
onWindowResize: null,\n      onContainerElementResize: null,\n      \
renderAllRows: false,\n      groups: false,\n      rowHeaderWidth: null,\n    \
  columnHeaderHeight: null,\n      headerClassName: null,\n      rtlMode: \
false\n    };\n  }\n  /**\n   * Update settings.\n   *\n   * @param {object} \
settings The singular settings to update or if passed as object to merge \
with.\n   * @param {*} value The value to set if the first argument is passed \
as string.\n   * @returns {Settings}\n   */\n  update(settings, value) {\n    \
if (value === void 0) {\n      objectEach(settings, (settingValue, key) => \
{\n        this.settings[key] = settingValue;\n      });\n    } else {\n      \
this.settings[settings] = value;\n    }\n    return this;\n  }\n  /**\n   * \
Get setting by name.\n   *\n   * @param {$Keys<SettingsPure>} key The \
settings key to retrieve.\n   * @param {*} [param1] Additional parameter \
passed to the options defined as function.\n   * @param {*} [param2] \
Additional parameter passed to the options defined as function.\n   * @param \
{*} [param3] Additional parameter passed to the options defined as \
function.\n   * @param {*} [param4] Additional parameter passed to the \
options defined as function.\n   * @returns {*}\n   */\n  getSetting(key, \
param1, param2, param3, param4) {\n    if (typeof this.settings[key] === \
\"function\") {\n      return this.settings[key](param1, param2, param3, \
param4);\n    } else if (param1 !== void 0 && \
Array.isArray(this.settings[key])) {\n      return \
this.settings[key][param1];\n    }\n    return this.settings[key];\n  }\n  \
/**\n   * Get a setting value without any evaluation.\n   *\n   * @param \
{string} key The settings key to retrieve.\n   * @returns {*}\n   */\n  \
getSettingPure(key) {\n    return this.settings[key];\n  }\n  /**\n   * \
Checks if setting exists.\n   *\n   * @param {boolean} key The settings key \
to check.\n   * @returns {boolean}\n   */\n  has(key) {\n    return \
!!this.settings[key];\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/table/master.mjs\nvar \
MasterTable = class extends table_default {\n  /**\n   * @param {TableDao} \
dataAccessObject The data access object.\n   * @param {FacadeGetter} \
facadeGetter Function which return proper facade.\n   * @param {DomBindings} \
domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The \
Walkontable settings.\n   */\n  constructor(dataAccessObject, facadeGetter, \
domBindings, wtSettings) {\n    super(dataAccessObject, facadeGetter, \
domBindings, wtSettings, \"master\");\n  }\n  \
alignOverlaysWithTrimmingContainer() {\n    const trimmingElement = \
getTrimmingContainer(this.wtRootElement);\n    const {\n      rootWindow\n    \
} = this.domBindings;\n    if (trimmingElement === rootWindow) {\n      const \
preventOverflow = this.wtSettings.getSetting(\"preventOverflow\");\n      if \
(!preventOverflow) {\n        this.holder.style.overflow = \"visible\";\n     \
   this.wtRootElement.style.overflow = \"visible\";\n      }\n    } else {\n  \
    const trimmingElementParent = trimmingElement.parentElement;\n      const \
trimmingHeight = getStyle(trimmingElement, \"height\", rootWindow);\n      \
const trimmingOverflow = getStyle(trimmingElement, \"overflow\", \
rootWindow);\n      const holderStyle = this.holder.style;\n      const {\n   \
     scrollWidth,\n        scrollHeight\n      } = trimmingElement;\n      \
let {\n        width,\n        height\n      } = \
trimmingElement.getBoundingClientRect();\n      const overflow = [\"auto\", \
\"hidden\", \"scroll\"];\n      if (trimmingElementParent && \
overflow.includes(trimmingOverflow)) {\n        const cloneNode = \
trimmingElement.cloneNode(false);\n        cloneNode.style.overflow = \
\"auto\";\n        cloneNode.style.position = \"absolute\";\n        if \
(trimmingElement.nextElementSibling) {\n          \
trimmingElementParent.insertBefore(cloneNode, \
trimmingElement.nextElementSibling);\n        } else {\n          \
trimmingElementParent.appendChild(cloneNode);\n        }\n        const \
cloneHeight = parseInt(getComputedStyle(cloneNode, rootWindow).height, 10);\n \
       trimmingElementParent.removeChild(cloneNode);\n        if (cloneHeight \
=== 0) {\n          height = 0;\n        }\n      }\n      height = \
Math.min(height, scrollHeight);\n      holderStyle.height = trimmingHeight \
=== \"auto\" ? \"auto\" : `${height}px`;\n      width = Math.min(width, \
scrollWidth);\n      holderStyle.width = `${width}px`;\n      \
holderStyle.overflow = \"\";\n      this.hasTableHeight = holderStyle.height \
=== \"auto\" ? true : height > 0;\n      this.hasTableWidth = width > 0;\n    \
}\n    this.isTableVisible = isVisible(this.TABLE);\n  }\n  \
markOversizedColumnHeaders() {\n    const {\n      wtSettings\n    } = \
this;\n    const {\n      wtViewport\n    } = this.dataAccessObject;\n    \
const overlayName = \"master\";\n    const columnHeaders = \
wtSettings.getSetting(\"columnHeaders\");\n    const columnHeadersCount = \
columnHeaders.length;\n    if (columnHeadersCount && \
!wtViewport.hasOversizedColumnHeadersMarked[overlayName]) {\n      const \
rowHeaders = wtSettings.getSetting(\"rowHeaders\");\n      const \
rowHeaderCount = rowHeaders.length;\n      const columnCount = \
this.getRenderedColumnsCount();\n      for (let i = 0; i < \
columnHeadersCount; i++) {\n        for (let renderedColumnIndex = -1 * \
rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {\n \
         this.markIfOversizedColumnHeader(renderedColumnIndex);\n        }\n  \
    }\n      wtViewport.hasOversizedColumnHeadersMarked[overlayName] = \
true;\n    }\n  }\n};\nmixin(MasterTable, \
calculatedRows_default);\nmixin(MasterTable, calculatedColumns_default);\nvar \
master_default = MasterTable;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/viewport.mjs\nvar Viewport \
= class {\n  /**\n   * @param {ViewportDao} dataAccessObject The Walkontable \
instance.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * \
@param {Settings} wtSettings The Walkontable settings.\n   * @param \
{EventManager} eventManager The instance event manager.\n   * @param {Table} \
wtTable The table.\n   */\n  constructor(dataAccessObject, domBindings, \
wtSettings, eventManager, wtTable) {\n    this.dataAccessObject = \
dataAccessObject;\n    this.wot = dataAccessObject.wot;\n    this.instance = \
this.wot;\n    this.domBindings = domBindings;\n    this.wtSettings = \
wtSettings;\n    this.wtTable = wtTable;\n    this.oversizedRows = [];\n    \
this.oversizedColumnHeaders = [];\n    this.hasOversizedColumnHeadersMarked = \
{};\n    this.clientHeight = 0;\n    this.containerWidth = NaN;\n    \
this.rowHeaderWidth = NaN;\n    this.rowsVisibleCalculator = null;\n    \
this.columnsVisibleCalculator = null;\n    this.eventManager = \
eventManager;\n    \
this.eventManager.addEventListener(this.domBindings.rootWindow, \"resize\", \
() => {\n      this.clientHeight = this.getWorkspaceHeight();\n    });\n  }\n \
 /**\n   * @returns {number}\n   */\n  getWorkspaceHeight() {\n    const \
currentDocument = this.domBindings.rootDocument;\n    const trimmingContainer \
= this.dataAccessObject.topOverlayTrimmingContainer;\n    let height = 0;\n   \
 if (trimmingContainer === this.domBindings.rootWindow) {\n      height = \
currentDocument.documentElement.clientHeight;\n    } else {\n      const \
elemHeight = outerHeight(trimmingContainer);\n      height = elemHeight > 0 \
&& trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : \
Infinity;\n    }\n    return height;\n  }\n  getWorkspaceWidth() {\n    const \
{\n      wtSettings\n    } = this;\n    const {\n      rootDocument,\n      \
rootWindow\n    } = this.domBindings;\n    const trimmingContainer = \
this.dataAccessObject.inlineStartOverlayTrimmingContainer;\n    const \
docOffsetWidth = rootDocument.documentElement.offsetWidth;\n    const \
totalColumns = wtSettings.getSetting(\"totalColumns\");\n    const \
preventOverflow = wtSettings.getSetting(\"preventOverflow\");\n    const \
isRtl = wtSettings.getSetting(\"rtlMode\");\n    const tableRect = \
this.wtTable.TABLE.getBoundingClientRect();\n    const inlineStart = isRtl ? \
tableRect.right - docOffsetWidth : tableRect.left;\n    const tableOffset = \
docOffsetWidth - inlineStart;\n    let width;\n    let overflow;\n    if \
(preventOverflow) {\n      return outerWidth(this.wtTable.wtRootElement);\n   \
 }\n    if (wtSettings.getSetting(\"freezeOverlays\")) {\n      width = \
Math.min(tableOffset, docOffsetWidth);\n    } else {\n      width = \
Math.min(this.getContainerFillWidth(), tableOffset, docOffsetWidth);\n    }\n \
   if (trimmingContainer === rootWindow && totalColumns > 0 && \
this.sumColumnWidths(0, totalColumns - 1) > width) {\n      return \
rootDocument.documentElement.clientWidth;\n    }\n    if (trimmingContainer \
!== rootWindow) {\n      overflow = \
getStyle(this.dataAccessObject.inlineStartOverlayTrimmingContainer, \
\"overflow\", rootWindow);\n      if (overflow === \"scroll\" || overflow === \
\"hidden\" || overflow === \"auto\") {\n        return Math.max(width, \
trimmingContainer.clientWidth);\n      }\n    }\n    const stretchSetting = \
wtSettings.getSetting(\"stretchH\");\n    if (stretchSetting === \"none\" || \
!stretchSetting) {\n      return Math.max(width, \
outerWidth(this.wtTable.TABLE));\n    }\n    return width;\n  }\n  /**\n   * \
Checks if viewport has vertical scroll.\n   *\n   * @returns {boolean}\n   \
*/\n  hasVerticalScroll() {\n    return this.wtTable.hider.offsetHeight > \
this.getWorkspaceHeight();\n  }\n  /**\n   * Checks if viewport has \
horizontal scroll.\n   *\n   * @returns {boolean}\n   */\n  \
hasHorizontalScroll() {\n    return this.wtTable.hider.offsetWidth > \
this.getWorkspaceWidth();\n  }\n  /**\n   * @param {number} from The visual \
column index from the width sum is start calculated.\n   * @param {number} \
length The length of the column to traverse.\n   * @returns {number}\n   */\n \
 sumColumnWidths(from, length) {\n    let sum = 0;\n    let column = from;\n  \
  while (column < length) {\n      sum += \
this.wtTable.getColumnWidth(column);\n      column += 1;\n    }\n    return \
sum;\n  }\n  /**\n   * @returns {number}\n   */\n  getContainerFillWidth() \
{\n    if (this.containerWidth) {\n      return this.containerWidth;\n    }\n \
   const mainContainer = this.wtTable.holder;\n    const dummyElement = \
this.domBindings.rootDocument.createElement(\"div\");\n    \
dummyElement.style.width = \"100%\";\n    dummyElement.style.height = \
\"1px\";\n    mainContainer.appendChild(dummyElement);\n    const fillWidth = \
dummyElement.offsetWidth;\n    this.containerWidth = fillWidth;\n    \
mainContainer.removeChild(dummyElement);\n    return fillWidth;\n  }\n  /**\n \
  * @returns {number}\n   */\n  getWorkspaceOffset() {\n    return \
offset(this.wtTable.TABLE);\n  }\n  /**\n   * @returns {number}\n   */\n  \
getColumnHeaderHeight() {\n    const columnHeaders = \
this.wtSettings.getSetting(\"columnHeaders\");\n    if \
(!columnHeaders.length) {\n      this.columnHeaderHeight = 0;\n    } else if \
(isNaN(this.columnHeaderHeight)) {\n      this.columnHeaderHeight = \
outerHeight(this.wtTable.THEAD);\n    }\n    return \
this.columnHeaderHeight;\n  }\n  /**\n   * @returns {number}\n   */\n  \
getViewportHeight() {\n    let containerHeight = this.getWorkspaceHeight();\n \
   if (containerHeight === Infinity) {\n      return containerHeight;\n    \
}\n    const columnHeaderHeight = this.getColumnHeaderHeight();\n    if \
(columnHeaderHeight > 0) {\n      containerHeight -= columnHeaderHeight;\n    \
}\n    return containerHeight;\n  }\n  /**\n   * @returns {number}\n   */\n  \
getRowHeaderWidth() {\n    const rowHeadersWidthSetting = \
this.wtSettings.getSetting(\"rowHeaderWidth\");\n    const rowHeaders = \
this.wtSettings.getSetting(\"rowHeaders\");\n    if (rowHeadersWidthSetting) \
{\n      this.rowHeaderWidth = 0;\n      for (let i = 0, len = \
rowHeaders.length; i < len; i++) {\n        this.rowHeaderWidth += \
rowHeadersWidthSetting[i] || rowHeadersWidthSetting;\n      }\n    }\n    if \
(isNaN(this.rowHeaderWidth)) {\n      if (rowHeaders.length) {\n        let \
TH = this.wtTable.TABLE.querySelector(\"TH\");\n        this.rowHeaderWidth = \
0;\n        for (let i = 0, len = rowHeaders.length; i < len; i++) {\n        \
  if (TH) {\n            this.rowHeaderWidth += outerWidth(TH);\n            \
TH = TH.nextSibling;\n          } else {\n            this.rowHeaderWidth += \
50;\n          }\n        }\n      } else {\n        this.rowHeaderWidth = \
0;\n      }\n    }\n    this.rowHeaderWidth = \
this.wtSettings.getSetting(\"onModifyRowHeaderWidth\", this.rowHeaderWidth) \
|| this.rowHeaderWidth;\n    return this.rowHeaderWidth;\n  }\n  /**\n   * \
@returns {number}\n   */\n  getViewportWidth() {\n    const containerWidth = \
this.getWorkspaceWidth();\n    if (containerWidth === Infinity) {\n      \
return containerWidth;\n    }\n    const rowHeaderWidth = \
this.getRowHeaderWidth();\n    if (rowHeaderWidth > 0) {\n      return \
containerWidth - rowHeaderWidth;\n    }\n    return containerWidth;\n  }\n  \
/**\n   * Creates:\n   * - rowsRenderCalculator (before draw, to qualify rows \
for rendering)\n   * - rowsVisibleCalculator (after draw, to measure which \
rows are actually visible).\n   *\n   * @param {number} calculationType The \
render type ID, which determines for what type of\n   *                       \
          calculation calculator is created.\n   * @returns \
{ViewportRowsCalculator}\n   */\n  createRowsCalculator() {\n    let \
calculationType = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : RENDER_TYPE;\n    const {\n      wtSettings,\n      wtTable\n  \
  } = this;\n    let height;\n    let scrollbarHeight;\n    let \
fixedRowsHeight;\n    this.rowHeaderWidth = NaN;\n    if \
(wtSettings.getSetting(\"renderAllRows\") && calculationType === RENDER_TYPE) \
{\n      height = Infinity;\n    } else {\n      height = \
this.getViewportHeight();\n    }\n    let pos = \
this.dataAccessObject.topScrollPosition - \
this.dataAccessObject.topParentOffset;\n    const fixedRowsTop = \
wtSettings.getSetting(\"fixedRowsTop\");\n    const fixedRowsBottom = \
wtSettings.getSetting(\"fixedRowsBottom\");\n    const totalRows = \
wtSettings.getSetting(\"totalRows\");\n    if (fixedRowsTop && pos >= 0) {\n  \
    fixedRowsHeight = this.dataAccessObject.topOverlay.sumCellSizes(0, \
fixedRowsTop);\n      pos += fixedRowsHeight;\n      height -= \
fixedRowsHeight;\n    }\n    if (fixedRowsBottom && \
this.dataAccessObject.bottomOverlay.clone) {\n      fixedRowsHeight = \
this.dataAccessObject.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, \
totalRows);\n      height -= fixedRowsHeight;\n    }\n    if \
(wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {\n      \
scrollbarHeight = 0;\n    } else {\n      scrollbarHeight = \
getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    return new \
viewportRows_default({\n      viewportSize: height,\n      scrollOffset: \
pos,\n      totalItems: wtSettings.getSetting(\"totalRows\"),\n      \
itemSizeFn: (sourceRow) => wtTable.getRowHeight(sourceRow),\n      \
overrideFn: wtSettings.getSettingPure(\"viewportRowCalculatorOverride\"),\n   \
   calculationType,\n      scrollbarHeight\n    });\n  }\n  /**\n   * \
Creates:\n   * - columnsRenderCalculator (before draw, to qualify columns for \
rendering)\n   * - columnsVisibleCalculator (after draw, to measure which \
columns are actually visible).\n   *\n   * @param {number} calculationType \
The render type ID, which determines for what type of\n   *                   \
              calculation calculator is created.\n   * @returns \
{ViewportColumnsCalculator}\n   */\n  createColumnsCalculator() {\n    let \
calculationType = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : RENDER_TYPE;\n    const {\n      wtSettings,\n      wtTable\n  \
  } = this;\n    let width = this.getViewportWidth();\n    let pos = \
Math.abs(this.dataAccessObject.inlineStartScrollPosition) - \
this.dataAccessObject.inlineStartParentOffset;\n    this.columnHeaderHeight = \
NaN;\n    const fixedColumnsStart = \
wtSettings.getSetting(\"fixedColumnsStart\");\n    if (fixedColumnsStart && \
pos >= 0) {\n      const fixedColumnsWidth = \
this.dataAccessObject.inlineStartOverlay.sumCellSizes(0, \
fixedColumnsStart);\n      pos += fixedColumnsWidth;\n      width -= \
fixedColumnsWidth;\n    }\n    if (wtTable.holder.clientWidth !== \
wtTable.holder.offsetWidth) {\n      width -= \
getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    return new \
viewportColumns_default({\n      viewportSize: width,\n      scrollOffset: \
pos,\n      totalItems: wtSettings.getSetting(\"totalColumns\"),\n      \
itemSizeFn: (sourceCol) => wtTable.getColumnWidth(sourceCol),\n      \
overrideFn: \
wtSettings.getSettingPure(\"viewportColumnCalculatorOverride\"),\n      \
calculationType,\n      stretchMode: wtSettings.getSetting(\"stretchH\"),\n   \
   stretchingItemWidthFn: (stretchedWidth, column) => {\n        return \
wtSettings.getSetting(\"onBeforeStretchingColumnWidth\", stretchedWidth, \
column);\n      },\n      inlineStartOffset: \
this.dataAccessObject.inlineStartParentOffset\n    });\n  }\n  /**\n   * \
Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to \
determine what rows and\n   * cols should be rendered).\n   *\n   * @param \
{boolean} fastDraw If `true`, will try to avoid full redraw and only update \
the border positions.\n   *                           If `false` or \
`undefined`, will perform a full redraw.\n   * @returns {boolean} The \
fastDraw value, possibly modified.\n   */\n  createRenderCalculators() {\n    \
let fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] \
: false;\n    let runFastDraw = fastDraw;\n    if (runFastDraw) {\n      \
const proposedRowsVisibleCalculator = \
this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n      const \
proposedColumnsVisibleCalculator = \
this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n      if \
(!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculato\
r) && \
this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalcul\
ator))) {\n        runFastDraw = false;\n      }\n    }\n    if \
(!runFastDraw) {\n      this.rowsRenderCalculator = \
this.createRowsCalculator(RENDER_TYPE);\n      this.columnsRenderCalculator = \
this.createColumnsCalculator(RENDER_TYPE);\n    }\n    \
this.rowsVisibleCalculator = null;\n    this.columnsVisibleCalculator = \
null;\n    return runFastDraw;\n  }\n  /**\n   * Creates \
rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine \
what are\n   * the actually fully visible rows and columns).\n   */\n  \
createVisibleCalculators() {\n    this.rowsVisibleCalculator = \
this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n    \
this.columnsVisibleCalculator = \
this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n  }\n  /**\n   * Returns \
information whether proposedRowsVisibleCalculator viewport\n   * is contained \
inside rows rendered in previous draw (cached in rowsRenderCalculator).\n   \
*\n   * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The \
instance of the viewport calculator to compare with.\n   * @returns {boolean} \
Returns `true` if all proposed visible rows are already rendered (meaning: \
redraw is not needed).\n   *                    Returns `false` if at least \
one proposed visible row is not already rendered (meaning: redraw is \
needed).\n   */\n  \
areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {\n   \
 if (!this.rowsVisibleCalculator) {\n      return false;\n    }\n    const \
{\n      startRow,\n      endRow,\n      isVisibleInTrimmingContainer\n    } \
= proposedRowsVisibleCalculator;\n    if (startRow === null && endRow === \
null) {\n      return !isVisibleInTrimmingContainer;\n    }\n    const {\n    \
  startRow: renderedStartRow,\n      endRow: renderedEndRow\n    } = \
this.rowsRenderCalculator;\n    if (startRow < renderedStartRow || startRow \
=== renderedStartRow && startRow > 0) {\n      return false;\n    } else if \
(endRow > renderedEndRow || endRow === renderedEndRow && endRow < \
this.wtSettings.getSetting(\"totalRows\") - 1) {\n      return false;\n    \
}\n    return true;\n  }\n  /**\n   * Returns information whether \
proposedColumnsVisibleCalculator viewport\n   * is contained inside column \
rendered in previous draw (cached in columnsRenderCalculator).\n   *\n   * \
@param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance \
of the viewport calculator to compare with.\n   * @returns {boolean} Returns \
`true` if all proposed visible columns are already rendered (meaning: redraw \
is not needed).\n   *                    Returns `false` if at least one \
proposed visible column is not already rendered (meaning: redraw is \
needed).\n   */\n  \
areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) \
{\n    if (!this.columnsVisibleCalculator) {\n      return false;\n    }\n    \
const {\n      startColumn,\n      endColumn,\n      \
isVisibleInTrimmingContainer\n    } = proposedColumnsVisibleCalculator;\n    \
if (startColumn === null && endColumn === null) {\n      return \
!isVisibleInTrimmingContainer;\n    }\n    const {\n      startColumn: \
renderedStartColumn,\n      endColumn: renderedEndColumn\n    } = \
this.columnsRenderCalculator;\n    if (startColumn < renderedStartColumn || \
startColumn === renderedStartColumn && startColumn > 0) {\n      return \
false;\n    } else if (endColumn > renderedEndColumn || endColumn === \
renderedEndColumn && endColumn < this.wtSettings.getSetting(\"totalColumns\") \
- 1) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Resets \
values in keys of the hasOversizedColumnHeadersMarked object after \
updateSettings.\n   */\n  resetHasOversizedColumnHeadersMarked() {\n    \
objectEach(this.hasOversizedColumnHeadersMarked, (value, key, object) => {\n  \
    object[key] = void 0;\n    });\n  }\n};\nvar viewport_default = \
Viewport;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/core/core.mjs\nvar \
Walkontable = class extends CoreAbstract {\n  /**\n   * @param \
{HTMLTableElement} table Main table.\n   * @param {SettingsPure} settings The \
Walkontable settings.\n   */\n  constructor(table, settings) {\n    \
super(table, new Settings(settings));\n    const facadeGetter = \
this.wtSettings.getSetting(\"facade\", this);\n    this.wtTable = new \
master_default(this.getTableDao(), facadeGetter, this.domBindings, \
this.wtSettings);\n    this.wtViewport = new \
viewport_default(this.getViewportDao(), this.domBindings, this.wtSettings, \
this.eventManager, this.wtTable);\n    this.selections = \
this.wtSettings.getSetting(\"selections\");\n    this.wtEvent = new \
event_default(facadeGetter, this.domBindings, this.wtSettings, \
this.eventManager, this.wtTable, this.selections);\n    this.wtOverlays = new \
overlays_default(\n      // TODO create DAO and remove reference to the \
Walkontable instance.\n      this,\n      facadeGetter,\n      \
this.domBindings,\n      this.wtSettings,\n      this.eventManager,\n      \
this.wtTable\n    );\n    this.exportSettingsAsClassNames();\n    \
this.findOriginalHeaders();\n  }\n  /**\n   * Export settings as class names \
added to the parent element of the table.\n   */\n  \
exportSettingsAsClassNames() {\n    const toExport = {\n      rowHeaders: \
\"htRowHeaders\",\n      columnHeaders: \"htColumnHeaders\"\n    };\n    \
const allClassNames = [];\n    const newClassNames = [];\n    \
objectEach(toExport, (className, key) => {\n      if \
(this.wtSettings.getSetting(key).length) {\n        \
newClassNames.push(className);\n      }\n      \
allClassNames.push(className);\n    });\n    \
removeClass(this.wtTable.wtRootElement.parentNode, allClassNames);\n    \
addClass(this.wtTable.wtRootElement.parentNode, newClassNames);\n  }\n  /**\n \
  * @returns {ViewportDao}\n   */\n  getViewportDao() {\n    const wot = \
this;\n    return {\n      get wot() {\n        return wot;\n      },\n      \
get topOverlayTrimmingContainer() {\n        return \
wot.wtOverlays.topOverlay.trimmingContainer;\n      },\n      get \
inlineStartOverlayTrimmingContainer() {\n        return \
wot.wtOverlays.inlineStartOverlay.trimmingContainer;\n      },\n      get \
topScrollPosition() {\n        return \
wot.wtOverlays.topOverlay.getScrollPosition();\n      },\n      get \
topParentOffset() {\n        return \
wot.wtOverlays.topOverlay.getTableParentOffset();\n      },\n      get \
inlineStartScrollPosition() {\n        return \
wot.wtOverlays.inlineStartOverlay.getScrollPosition();\n      },\n      get \
inlineStartParentOffset() {\n        return \
wot.wtOverlays.inlineStartOverlay.getTableParentOffset();\n      },\n      \
get topOverlay() {\n        return wot.wtOverlays.topOverlay;\n      },\n     \
 get inlineStartOverlay() {\n        return \
wot.wtOverlays.inlineStartOverlay;\n      },\n      get bottomOverlay() {\n   \
     return wot.wtOverlays.bottomOverlay;\n      }\n    };\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/facade/core.mjs\nvar \
WalkontableFacade = class _WalkontableFacade {\n  /**\n   * @param \
{SettingsPure|Walkontable} settingsOrInstance The Walkontable settings.\n   \
*/\n  constructor(settingsOrInstance) {\n    if (settingsOrInstance \
instanceof CoreAbstract) {\n      this._wot = settingsOrInstance;\n    } else \
{\n      this._initFromSettings(settingsOrInstance);\n    }\n  }\n  \
_initFromSettings(settings) {\n    settings.facade = (instance) => {\n      \
const facade = new _WalkontableFacade(instance);\n      return () => \
facade;\n    };\n    this._wot = new Walkontable(settings.table, settings);\n \
 }\n  get guid() {\n    return this._wot.guid;\n  }\n  get rootDocument() {\n \
   return this._wot.domBindings.rootDocument;\n  }\n  get rootWindow() {\n    \
return this._wot.domBindings.rootWindow;\n  }\n  get wtSettings() {\n    \
return this._wot.wtSettings;\n  }\n  get cloneSource() {\n    return \
this._wot.cloneSource;\n  }\n  get cloneOverlay() {\n    return \
this._wot.cloneOverlay;\n  }\n  get selections() {\n    return \
this._wot.selections;\n  }\n  get wtViewport() {\n    return \
this._wot.wtViewport;\n  }\n  get wtOverlays() {\n    return \
this._wot.wtOverlays;\n  }\n  get wtTable() {\n    return \
this._wot.wtTable;\n  }\n  get wtEvent() {\n    return this._wot.wtEvent;\n  \
}\n  get wtScroll() {\n    return this._wot.wtScroll;\n  }\n  get drawn() {\n \
   return this._wot.drawn;\n  }\n  set drawn(value) {\n    this._wot.drawn = \
value;\n  }\n  get drawInterrupted() {\n    return \
this._wot.drawInterrupted;\n  }\n  set drawInterrupted(value) {\n    \
this._wot.drawInterrupted = value;\n  }\n  get lastMouseOver() {\n    return \
this._wot.lastMouseOver;\n  }\n  set lastMouseOver(value) {\n    \
this._wot.lastMouseOver = value;\n  }\n  get momentumScrolling() {\n    \
return this._wot.momentumScrolling;\n  }\n  set momentumScrolling(value) {\n  \
  this._wot.momentumScrolling = value;\n  }\n  get touchApplied() {\n    \
return this._wot.touchApplied;\n  }\n  set touchApplied(value) {\n    \
this._wot.touchApplied = value;\n  }\n  get domBindings() {\n    return \
this._wot.domBindings;\n  }\n  get eventListeners() {\n    return \
this._wot.eventListeners;\n  }\n  set eventListeners(value) {\n    \
this._wot.eventListeners = value;\n  }\n  get eventManager() {\n    return \
this._wot.eventManager;\n  }\n  createCellCoords(row, column) {\n    return \
this._wot.createCellCoords(row, column);\n  }\n  createCellRange(highlight, \
from, to) {\n    return this._wot.createCellRange(highlight, from, to);\n  \
}\n  draw() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== \
void 0 ? arguments[0] : false;\n    this._wot.draw(fastDraw);\n    return \
this;\n  }\n  getCell(coords) {\n    let topmost = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : false;\n    return \
this._wot.getCell(coords, topmost);\n  }\n  scrollViewport(coords, snapToTop, \
snapToRight, snapToBottom, snapToLeft) {\n    return \
this._wot.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, \
snapToLeft);\n  }\n  scrollViewportHorizontally(column, snapToRight, \
snapToLeft) {\n    return this._wot.scrollViewportHorizontally(column, \
snapToRight, snapToLeft);\n  }\n  scrollViewportVertically(row, snapToTop, \
snapToBottom) {\n    return this._wot.scrollViewportVertically(row, \
snapToTop, snapToBottom);\n  }\n  getViewport() {\n    return \
this._wot.getViewport();\n  }\n  getOverlayName() {\n    return \
this._wot.cloneOverlay ? this._wot.cloneOverlay.type : \"master\";\n  }\n  \
exportSettingsAsClassNames() {\n    return \
this._wot.exportSettingsAsClassNames();\n  }\n  update(settings, value) {\n   \
 this._wot.wtSettings.update(settings, value);\n    return this;\n  }\n  \
getSetting(key, param1, param2, param3, param4) {\n    return \
this._wot.wtSettings.getSetting(key, param1, param2, param3, param4);\n  }\n  \
hasSetting(key) {\n    return this._wot.wtSettings.hasSetting(key);\n  }\n  \
destroy() {\n    this._wot.destroy();\n  }\n};\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/border.mjs\nvar Border = \
class {\n  // TODO As this is an internal class, should be designed for using \
{Walkontable}. It uses the facade,\n  // TODO Con. Because the class is \
created on place where the instance reference comes from external origin.\n  \
// TODO Imho, the discrimination for handling both, facade and non-facade \
should be handled.\n  /**\n   * @param {WalkontableFacade} wotInstance The \
Walkontable instance.\n   * @param {object} settings The border settings.\n   \
*/\n  constructor(wotInstance, settings) {\n    if (!settings) {\n      \
return;\n    }\n    this.eventManager = wotInstance.eventManager;\n    \
this.instance = wotInstance;\n    this.wot = wotInstance;\n    this.settings \
= settings;\n    this.mouseDown = false;\n    this.main = null;\n    this.top \
= null;\n    this.bottom = null;\n    this.start = null;\n    this.end = \
null;\n    this.topStyle = null;\n    this.bottomStyle = null;\n    \
this.startStyle = null;\n    this.endStyle = null;\n    \
this.cornerDefaultStyle = {\n      width: \"6px\",\n      height: \"6px\",\n  \
    borderWidth: \"1px\",\n      borderStyle: \"solid\",\n      borderColor: \
\"#FFF\"\n    };\n    this.cornerCenterPointOffset = \
-(parseInt(this.cornerDefaultStyle.width, 10) / 2);\n    this.corner = \
null;\n    this.cornerStyle = null;\n    this.createBorders(settings);\n    \
this.registerListeners();\n  }\n  /**\n   * Register all necessary events.\n  \
 */\n  registerListeners() {\n    const documentBody = \
this.wot.rootDocument.body;\n    \
this.eventManager.addEventListener(documentBody, \"mousedown\", () => \
this.onMouseDown());\n    this.eventManager.addEventListener(documentBody, \
\"mouseup\", () => this.onMouseUp());\n    for (let c = 0, len = \
this.main.childNodes.length; c < len; c++) {\n      const element = \
this.main.childNodes[c];\n      this.eventManager.addEventListener(element, \
\"mouseenter\", (event2) => this.onMouseEnter(event2, \
this.main.childNodes[c]));\n    }\n  }\n  /**\n   * Mouse down listener.\n   \
*\n   * @private\n   */\n  onMouseDown() {\n    this.mouseDown = true;\n  }\n \
 /**\n   * Mouse up listener.\n   *\n   * @private\n   */\n  onMouseUp() {\n  \
  this.mouseDown = false;\n  }\n  /**\n   * Mouse enter listener for fragment \
selection functionality.\n   *\n   * @private\n   * @param {Event} event Dom \
event.\n   * @param {HTMLElement} parentElement Part of border element.\n   \
*/\n  onMouseEnter(event2, parentElement) {\n    if (!this.mouseDown || \
!this.wot.getSetting(\"hideBorderOnMouseDownOver\")) {\n      return;\n    \
}\n    event2.preventDefault();\n    stopImmediatePropagation(event2);\n    \
const _this = this;\n    const documentBody = this.wot.rootDocument.body;\n   \
 const bounds = parentElement.getBoundingClientRect();\n    \
parentElement.style.display = \"none\";\n    function isOutside(mouseEvent) \
{\n      if (mouseEvent.clientY < Math.floor(bounds.top)) {\n        return \
true;\n      }\n      if (mouseEvent.clientY > Math.ceil(bounds.top + \
bounds.height)) {\n        return true;\n      }\n      if \
(mouseEvent.clientX < Math.floor(bounds.left)) {\n        return true;\n      \
}\n      if (mouseEvent.clientX > Math.ceil(bounds.left + bounds.width)) {\n  \
      return true;\n      }\n    }\n    function handler(handlerEvent) {\n    \
  if (isOutside(handlerEvent)) {\n        \
_this.eventManager.removeEventListener(documentBody, \"mousemove\", \
handler);\n        parentElement.style.display = \"block\";\n      }\n    }\n \
   this.eventManager.addEventListener(documentBody, \"mousemove\", \
handler);\n  }\n  /**\n   * Create border elements.\n   *\n   * @param \
{object} settings The border settings.\n   */\n  createBorders(settings) {\n  \
  const {\n      rootDocument\n    } = this.wot;\n    this.main = \
rootDocument.createElement(\"div\");\n    const borderDivs = [\"top\", \
\"start\", \"bottom\", \"end\", \"corner\"];\n    let style = \
this.main.style;\n    style.position = \"absolute\";\n    style.top = 0;\n    \
style.left = 0;\n    for (let i = 0; i < 5; i++) {\n      const position = \
borderDivs[i];\n      const div = rootDocument.createElement(\"div\");\n      \
div.className = `wtBorder ${this.settings.className || \"\"}`;\n      if \
(this.settings[position] && this.settings[position].hide) {\n        \
div.className += \" hidden\";\n      }\n      style = div.style;\n      \
style.backgroundColor = this.settings[position] && \
this.settings[position].color ? this.settings[position].color : \
settings.border.color;\n      style.height = this.settings[position] && \
this.settings[position].width ? `${this.settings[position].width}px` : \
`${settings.border.width}px`;\n      style.width = this.settings[position] && \
this.settings[position].width ? `${this.settings[position].width}px` : \
`${settings.border.width}px`;\n      this.main.appendChild(div);\n    }\n    \
this.top = this.main.childNodes[0];\n    this.start = \
this.main.childNodes[1];\n    this.bottom = this.main.childNodes[2];\n    \
this.end = this.main.childNodes[3];\n    this.topStyle = this.top.style;\n    \
this.startStyle = this.start.style;\n    this.bottomStyle = \
this.bottom.style;\n    this.endStyle = this.end.style;\n    this.corner = \
this.main.childNodes[4];\n    this.corner.className += \" corner\";\n    \
this.cornerStyle = this.corner.style;\n    this.cornerStyle.width = \
this.cornerDefaultStyle.width;\n    this.cornerStyle.height = \
this.cornerDefaultStyle.height;\n    this.cornerStyle.border = \
[this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, \
this.cornerDefaultStyle.borderColor].join(\" \");\n    if (isMobileBrowser()) \
{\n      this.createMultipleSelectorHandles();\n    }\n    \
this.disappear();\n    const {\n      wtTable\n    } = this.wot;\n    let \
bordersHolder = wtTable.bordersHolder;\n    if (!bordersHolder) {\n      \
bordersHolder = rootDocument.createElement(\"div\");\n      \
bordersHolder.className = \"htBorders\";\n      wtTable.bordersHolder = \
bordersHolder;\n      wtTable.spreader.appendChild(bordersHolder);\n    }\n   \
 bordersHolder.appendChild(this.main);\n  }\n  /**\n   * Create multiple \
selector handler for mobile devices.\n   */\n  \
createMultipleSelectorHandles() {\n    const {\n      rootDocument\n    } = \
this.wot;\n    this.selectionHandles = {\n      top: \
rootDocument.createElement(\"DIV\"),\n      topHitArea: \
rootDocument.createElement(\"DIV\"),\n      bottom: \
rootDocument.createElement(\"DIV\"),\n      bottomHitArea: \
rootDocument.createElement(\"DIV\")\n    };\n    const width = 10;\n    const \
hitAreaWidth = 40;\n    this.selectionHandles.top.className = \
\"topSelectionHandle topLeftSelectionHandle\";\n    \
this.selectionHandles.topHitArea.className = \"topSelectionHandle-HitArea \
topLeftSelectionHandle-HitArea\";\n    this.selectionHandles.bottom.className \
= \"bottomSelectionHandle bottomRightSelectionHandle\";\n    \
this.selectionHandles.bottomHitArea.className = \
\"bottomSelectionHandle-HitArea bottomRightSelectionHandle-HitArea\";\n    \
this.selectionHandles.styles = {\n      top: \
this.selectionHandles.top.style,\n      topHitArea: \
this.selectionHandles.topHitArea.style,\n      bottom: \
this.selectionHandles.bottom.style,\n      bottomHitArea: \
this.selectionHandles.bottomHitArea.style\n    };\n    const hitAreaStyle = \
{\n      position: \"absolute\",\n      height: `${hitAreaWidth}px`,\n      \
width: `${hitAreaWidth}px`,\n      \"border-radius\": \
`${parseInt(hitAreaWidth / 1.5, 10)}px`\n    };\n    objectEach(hitAreaStyle, \
(value, key) => {\n      this.selectionHandles.styles.bottomHitArea[key] = \
value;\n      this.selectionHandles.styles.topHitArea[key] = value;\n    \
});\n    const handleStyle = {\n      position: \"absolute\",\n      height: \
`${width}px`,\n      width: `${width}px`,\n      \"border-radius\": \
`${parseInt(width / 1.5, 10)}px`,\n      background: \"#F5F5FF\",\n      \
border: \"1px solid #4285c8\"\n    };\n    objectEach(handleStyle, (value, \
key) => {\n      this.selectionHandles.styles.bottom[key] = value;\n      \
this.selectionHandles.styles.top[key] = value;\n    });\n    \
this.main.appendChild(this.selectionHandles.top);\n    \
this.main.appendChild(this.selectionHandles.bottom);\n    \
this.main.appendChild(this.selectionHandles.topHitArea);\n    \
this.main.appendChild(this.selectionHandles.bottomHitArea);\n  }\n  /**\n   * \
@param {number} row The visual row index.\n   * @param {number} col The \
visual column index.\n   * @returns {boolean}\n   */\n  isPartRange(row, col) \
{\n    const areaSelection = this.wot.selections.createOrGetArea();\n    if \
(areaSelection.cellRange) {\n      if (row !== areaSelection.cellRange.to.row \
|| col !== areaSelection.cellRange.to.col) {\n        return true;\n      }\n \
   }\n    return false;\n  }\n  /**\n   * @param {number} row The visual row \
index.\n   * @param {number} col The visual column index.\n   * @param \
{number} top The top position of the handler.\n   * @param {number} left The \
left position of the handler.\n   * @param {number} width The width of the \
handler.\n   * @param {number} height The height of the handler.\n   */\n  \
updateMultipleSelectionHandlesPosition(row, col, top2, left2, width, height) \
{\n    const isRtl = this.wot.wtSettings.getSetting(\"rtlMode\");\n    const \
inlinePosProperty = isRtl ? \"right\" : \"left\";\n    const {\n      top: \
topStyles,\n      topHitArea: topHitAreaStyles,\n      bottom: \
bottomStyles,\n      bottomHitArea: bottomHitAreaStyles\n    } = \
this.selectionHandles.styles;\n    const handleBorderSize = \
parseInt(topStyles.borderWidth, 10);\n    const handleSize = \
parseInt(topStyles.width, 10);\n    const hitAreaSize = \
parseInt(topHitAreaStyles.width, 10);\n    const totalTableWidth = \
this.wot.wtTable.getWidth();\n    const totalTableHeight = \
this.wot.wtTable.getHeight();\n    topStyles.top = `${parseInt(top2 - \
handleSize - 1, 10)}px`;\n    topStyles[inlinePosProperty] = \
`${parseInt(left2 - handleSize - 1, 10)}px`;\n    topHitAreaStyles.top = \
`${parseInt(top2 - hitAreaSize / 4 * 3, 10)}px`;\n    \
topHitAreaStyles[inlinePosProperty] = `${parseInt(left2 - hitAreaSize / 4 * \
3, 10)}px`;\n    const bottomHandlerInline = Math.min(parseInt(left2 + width, \
10), totalTableWidth - handleSize - handleBorderSize * 2);\n    const \
bottomHandlerAreaInline = Math.min(parseInt(left2 + width - hitAreaSize / 4, \
10), totalTableWidth - hitAreaSize - handleBorderSize * 2);\n    \
bottomStyles[inlinePosProperty] = `${bottomHandlerInline}px`;\n    \
bottomHitAreaStyles[inlinePosProperty] = `${bottomHandlerAreaInline}px`;\n    \
const bottomHandlerTop = Math.min(parseInt(top2 + height, 10), \
totalTableHeight - handleSize - handleBorderSize * 2);\n    const \
bottomHandlerAreaTop = Math.min(parseInt(top2 + height - hitAreaSize / 4, \
10), totalTableHeight - hitAreaSize - handleBorderSize * 2);\n    \
bottomStyles.top = `${bottomHandlerTop}px`;\n    bottomHitAreaStyles.top = \
`${bottomHandlerAreaTop}px`;\n    if (this.settings.border.cornerVisible && \
this.settings.border.cornerVisible()) {\n      topStyles.display = \
\"block\";\n      topHitAreaStyles.display = \"block\";\n      if \
(this.isPartRange(row, col)) {\n        bottomStyles.display = \"none\";\n    \
    bottomHitAreaStyles.display = \"none\";\n      } else {\n        \
bottomStyles.display = \"block\";\n        bottomHitAreaStyles.display = \
\"block\";\n      }\n    } else {\n      topStyles.display = \"none\";\n      \
bottomStyles.display = \"none\";\n      topHitAreaStyles.display = \
\"none\";\n      bottomHitAreaStyles.display = \"none\";\n    }\n    if (row \
=== this.wot.wtSettings.getSetting(\"fixedRowsTop\") || col === \
this.wot.wtSettings.getSetting(\"fixedColumnsStart\")) {\n      \
topStyles.zIndex = \"9999\";\n      topHitAreaStyles.zIndex = \"9999\";\n    \
} else {\n      topStyles.zIndex = \"\";\n      topHitAreaStyles.zIndex = \
\"\";\n    }\n  }\n  /**\n   * Show border around one or many cells.\n   *\n  \
 * @param {Array} corners The corner coordinates.\n   */\n  appear(corners) \
{\n    if (this.disabled) {\n      return;\n    }\n    const {\n      \
wtTable,\n      rootDocument,\n      rootWindow\n    } = this.wot;\n    let \
fromRow;\n    let toRow;\n    let fromColumn;\n    let toColumn;\n    let \
rowHeader;\n    let columnHeader;\n    const rowsCount = \
wtTable.getRenderedRowsCount();\n    for (let i = 0; i < rowsCount; i += 1) \
{\n      const s = wtTable.rowFilter.renderedToSource(i);\n      if (s >= \
corners[0] && s <= corners[2]) {\n        fromRow = s;\n        rowHeader = \
corners[0];\n        break;\n      }\n    }\n    for (let i = rowsCount - 1; \
i >= 0; i -= 1) {\n      const s = wtTable.rowFilter.renderedToSource(i);\n   \
   if (s >= corners[0] && s <= corners[2]) {\n        toRow = s;\n        \
break;\n      }\n    }\n    const columnsCount = \
wtTable.getRenderedColumnsCount();\n    for (let i = 0; i < columnsCount; i \
+= 1) {\n      const s = wtTable.columnFilter.renderedToSource(i);\n      if \
(s >= corners[1] && s <= corners[3]) {\n        fromColumn = s;\n        \
columnHeader = corners[1];\n        break;\n      }\n    }\n    for (let i = \
columnsCount - 1; i >= 0; i -= 1) {\n      const s = \
wtTable.columnFilter.renderedToSource(i);\n      if (s >= corners[1] && s <= \
corners[3]) {\n        toColumn = s;\n        break;\n      }\n    }\n    if \
(fromRow === void 0 || fromColumn === void 0) {\n      this.disappear();\n    \
  return;\n    }\n    let fromTD = \
wtTable.getCell(this.wot.createCellCoords(fromRow, fromColumn));\n    const \
isMultiple = fromRow !== toRow || fromColumn !== toColumn;\n    const toTD = \
isMultiple ? wtTable.getCell(this.wot.createCellCoords(toRow, toColumn)) : \
fromTD;\n    const fromOffset = offset(fromTD);\n    const toOffset = \
isMultiple ? offset(toTD) : fromOffset;\n    const containerOffset = \
offset(wtTable.TABLE);\n    const containerWidth = \
outerWidth(wtTable.TABLE);\n    const minTop = fromOffset.top;\n    const \
minLeft = fromOffset.left;\n    const isRtl = \
this.wot.wtSettings.getSetting(\"rtlMode\");\n    let inlineStartPos = 0;\n   \
 let width = 0;\n    if (isRtl) {\n      const fromWidth = \
outerWidth(fromTD);\n      const gridRightPos = rootWindow.innerWidth - \
containerOffset.left - containerWidth;\n      width = minLeft + fromWidth - \
toOffset.left;\n      inlineStartPos = rootWindow.innerWidth - minLeft - \
fromWidth - gridRightPos - 1;\n    } else {\n      width = toOffset.left + \
outerWidth(toTD) - minLeft;\n      inlineStartPos = minLeft - \
containerOffset.left - 1;\n    }\n    if \
(this.isEntireColumnSelected(fromRow, toRow)) {\n      const modifiedValues = \
this.getDimensionsFromHeader(\"columns\", fromColumn, toColumn, rowHeader, \
containerOffset);\n      let fromTH = null;\n      if (modifiedValues) {\n    \
    [fromTH, inlineStartPos, width] = modifiedValues;\n      }\n      if \
(fromTH) {\n        fromTD = fromTH;\n      }\n    }\n    let top2 = minTop - \
containerOffset.top - 1;\n    let height = toOffset.top + outerHeight(toTD) - \
minTop;\n    if (this.isEntireRowSelected(fromColumn, toColumn)) {\n      \
const modifiedValues = this.getDimensionsFromHeader(\"rows\", fromRow, toRow, \
columnHeader, containerOffset);\n      let fromTH = null;\n      if \
(modifiedValues) {\n        [fromTH, top2, height] = modifiedValues;\n      \
}\n      if (fromTH) {\n        fromTD = fromTH;\n      }\n    }\n    const \
style = getComputedStyle(fromTD, rootWindow);\n    if \
(parseInt(style.borderTopWidth, 10) > 0) {\n      top2 += 1;\n      height = \
height > 0 ? height - 1 : 0;\n    }\n    if (parseInt(style[isRtl ? \
\"borderRightWidth\" : \"borderLeftWidth\"], 10) > 0) {\n      inlineStartPos \
+= 1;\n      width = width > 0 ? width - 1 : 0;\n    }\n    const \
inlinePosProperty = isRtl ? \"right\" : \"left\";\n    this.topStyle.top = \
`${top2}px`;\n    this.topStyle[inlinePosProperty] = `${inlineStartPos}px`;\n \
   this.topStyle.width = `${width}px`;\n    this.topStyle.display = \
\"block\";\n    this.startStyle.top = `${top2}px`;\n    \
this.startStyle[inlinePosProperty] = `${inlineStartPos}px`;\n    \
this.startStyle.height = `${height}px`;\n    this.startStyle.display = \
\"block\";\n    const delta = Math.floor(this.settings.border.width / 2);\n   \
 this.bottomStyle.top = `${top2 + height - delta}px`;\n    \
this.bottomStyle[inlinePosProperty] = `${inlineStartPos}px`;\n    \
this.bottomStyle.width = `${width}px`;\n    this.bottomStyle.display = \
\"block\";\n    this.endStyle.top = `${top2}px`;\n    \
this.endStyle[inlinePosProperty] = `${inlineStartPos + width - delta}px`;\n   \
 this.endStyle.height = `${height + 1}px`;\n    this.endStyle.display = \
\"block\";\n    let cornerVisibleSetting = \
this.settings.border.cornerVisible;\n    cornerVisibleSetting = typeof \
cornerVisibleSetting === \"function\" ? \
cornerVisibleSetting(this.settings.layerLevel) : cornerVisibleSetting;\n    \
const hookResult = this.wot.getSetting(\"onModifyGetCellCoords\", toRow, \
toColumn);\n    let [checkRow, checkCol] = [toRow, toColumn];\n    if \
(hookResult && Array.isArray(hookResult)) {\n      [, , checkRow, checkCol] = \
hookResult;\n    }\n    if (isMobileBrowser() || !cornerVisibleSetting || \
this.isPartRange(checkRow, checkCol)) {\n      this.cornerStyle.display = \
\"none\";\n    } else {\n      this.cornerStyle.top = `${top2 + height + \
this.cornerCenterPointOffset - 1}px`;\n      \
this.cornerStyle[inlinePosProperty] = `${inlineStartPos + width + \
this.cornerCenterPointOffset - 1}px`;\n      \
this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;\n    \
  this.cornerStyle.width = this.cornerDefaultStyle.width;\n      \
this.cornerStyle.display = \"none\";\n      let trimmingContainer = \
getTrimmingContainer(wtTable.TABLE);\n      const trimToWindow = \
trimmingContainer === rootWindow;\n      if (trimToWindow) {\n        \
trimmingContainer = rootDocument.documentElement;\n      }\n      const \
cornerHalfWidth = parseInt(this.cornerDefaultStyle.width, 10) / 2;\n      \
const cornerHalfHeight = parseInt(this.cornerDefaultStyle.height, 10) / 2;\n  \
    if (toColumn === this.wot.getSetting(\"totalColumns\") - 1) {\n        \
const toTdOffsetLeft = trimToWindow ? toTD.getBoundingClientRect().left : \
toTD.offsetLeft;\n        let cornerOverlappingContainer = false;\n        \
let cornerEdge = 0;\n        if (isRtl) {\n          cornerEdge = \
toTdOffsetLeft - parseInt(this.cornerDefaultStyle.width, 10) / 2;\n          \
cornerOverlappingContainer = cornerEdge < 0;\n        } else {\n          \
cornerEdge = toTdOffsetLeft + outerWidth(toTD) + \
parseInt(this.cornerDefaultStyle.width, 10) / 2;\n          \
cornerOverlappingContainer = cornerEdge >= innerWidth(trimmingContainer);\n   \
     }\n        if (cornerOverlappingContainer) {\n          \
this.cornerStyle[inlinePosProperty] = `${Math.floor(inlineStartPos + width + \
this.cornerCenterPointOffset - cornerHalfWidth)}px`;\n          \
this.cornerStyle[isRtl ? \"borderLeftWidth\" : \"borderRightWidth\"] = 0;\n   \
     }\n      }\n      if (toRow === this.wot.getSetting(\"totalRows\") - 1) \
{\n        const toTdOffsetTop = trimToWindow ? \
toTD.getBoundingClientRect().top : toTD.offsetTop;\n        const \
cornerBottomEdge = toTdOffsetTop + outerHeight(toTD) + \
parseInt(this.cornerDefaultStyle.height, 10) / 2;\n        const \
cornerOverlappingContainer = cornerBottomEdge >= \
innerHeight(trimmingContainer);\n        if (cornerOverlappingContainer) {\n  \
        this.cornerStyle.top = `${Math.floor(top2 + height + \
this.cornerCenterPointOffset - cornerHalfHeight)}px`;\n          \
this.cornerStyle.borderBottomWidth = 0;\n        }\n      }\n      \
this.cornerStyle.display = \"block\";\n    }\n    if (isMobileBrowser()) {\n  \
    this.updateMultipleSelectionHandlesPosition(toRow, toColumn, top2, \
inlineStartPos, width, height);\n    }\n  }\n  /**\n   * Check whether an \
entire column of cells is selected.\n   *\n   * @private\n   * @param \
{number} startRowIndex Start row index.\n   * @param {number} endRowIndex End \
row index.\n   * @returns {boolean}\n   */\n  \
isEntireColumnSelected(startRowIndex, endRowIndex) {\n    return \
startRowIndex === this.wot.wtTable.getFirstRenderedRow() && endRowIndex === \
this.wot.wtTable.getLastRenderedRow();\n  }\n  /**\n   * Check whether an \
entire row of cells is selected.\n   *\n   * @private\n   * @param {number} \
startColumnIndex Start column index.\n   * @param {number} endColumnIndex End \
column index.\n   * @returns {boolean}\n   */\n  \
isEntireRowSelected(startColumnIndex, endColumnIndex) {\n    return \
startColumnIndex === this.wot.wtTable.getFirstRenderedColumn() && \
endColumnIndex === this.wot.wtTable.getLastRenderedColumn();\n  }\n  /**\n   \
* Get left/top index and width/height depending on the `direction` \
provided.\n   *\n   * @private\n   * @param {string} direction `rows` or \
`columns`, defines if an entire column or row is selected.\n   * @param \
{number} fromIndex Start index of the selection.\n   * @param {number} \
toIndex End index of the selection.\n   * @param {number} headerIndex The \
header index as negative value.\n   * @param {number} containerOffset Offset \
of the container.\n   * @returns {Array|boolean} Returns an array of \
[headerElement, left, width] or [headerElement, top, height], depending on \
`direction` (`false` in case of an error getting the headers).\n   */\n  \
getDimensionsFromHeader(direction, fromIndex, toIndex, headerIndex, \
containerOffset) {\n    const {\n      wtTable\n    } = this.wot;\n    const \
rootHotElement = wtTable.wtRootElement.parentNode;\n    let getHeaderFn = \
null;\n    let dimensionFn = null;\n    let entireSelectionClassname = \
null;\n    let index2 = null;\n    let dimension = null;\n    let \
dimensionProperty = null;\n    let startHeader = null;\n    let endHeader = \
null;\n    switch (direction) {\n      case \"rows\":\n        getHeaderFn = \
function() {\n          return wtTable.getRowHeader(...arguments);\n        \
};\n        dimensionFn = function() {\n          return \
outerHeight(...arguments);\n        };\n        entireSelectionClassname = \
\"ht__selection--rows\";\n        dimensionProperty = \"top\";\n        \
break;\n      case \"columns\":\n        getHeaderFn = function() {\n         \
 return wtTable.getColumnHeader(...arguments);\n        };\n        \
dimensionFn = function() {\n          return outerWidth(...arguments);\n      \
  };\n        entireSelectionClassname = \"ht__selection--columns\";\n        \
dimensionProperty = \"left\";\n        break;\n      default:\n    }\n    if \
(rootHotElement.classList.contains(entireSelectionClassname)) {\n      const \
columnHeaderLevelCount = this.wot.getSetting(\"columnHeaders\").length;\n     \
 startHeader = getHeaderFn(fromIndex, columnHeaderLevelCount - \
headerIndex);\n      endHeader = getHeaderFn(toIndex, columnHeaderLevelCount \
- headerIndex);\n      if (!startHeader || !endHeader) {\n        return \
false;\n      }\n      const startHeaderOffset = offset(startHeader);\n      \
const endOffset = offset(endHeader);\n      if (startHeader && endHeader) {\n \
       index2 = startHeaderOffset[dimensionProperty] - \
containerOffset[dimensionProperty] - 1;\n        dimension = \
endOffset[dimensionProperty] + dimensionFn(endHeader) - \
startHeaderOffset[dimensionProperty];\n      }\n      return [startHeader, \
index2, dimension];\n    }\n    return false;\n  }\n  /**\n   * Change border \
style.\n   *\n   * @private\n   * @param {string} borderElement Coordinate \
where add/remove border: top, bottom, start, end.\n   * @param {object} \
border The border object descriptor.\n   */\n  \
changeBorderStyle(borderElement, border) {\n    const style = \
this[borderElement].style;\n    const borderStyle = border[borderElement];\n  \
  if (!borderStyle || borderStyle.hide) {\n      \
addClass(this[borderElement], \"hidden\");\n    } else {\n      if \
(hasClass(this[borderElement], \"hidden\")) {\n        \
removeClass(this[borderElement], \"hidden\");\n      }\n      \
style.backgroundColor = borderStyle.color;\n      if (borderElement === \
\"top\" || borderElement === \"bottom\") {\n        style.height = \
`${borderStyle.width}px`;\n      }\n      if (borderElement === \"start\" || \
borderElement === \"end\") {\n        style.width = \
`${borderStyle.width}px`;\n      }\n    }\n  }\n  /**\n   * Change border \
style to default.\n   *\n   * @private\n   * @param {string} position The \
position type (\"top\", \"bottom\", \"start\", \"end\") to change.\n   */\n  \
changeBorderToDefaultStyle(position) {\n    const defaultBorder = {\n      \
width: 1,\n      color: \"#000\"\n    };\n    const style = \
this[position].style;\n    style.backgroundColor = defaultBorder.color;\n    \
style.width = `${defaultBorder.width}px`;\n    style.height = \
`${defaultBorder.width}px`;\n  }\n  /**\n   * Toggle class 'hidden' to \
element.\n   *\n   * @private\n   * @param {string} borderElement Coordinate \
where add/remove border: top, bottom, start, end.\n   * @param {boolean} \
[remove] Defines type of the action to perform.\n   */\n  \
toggleHiddenClass(borderElement, remove) {\n    \
this.changeBorderToDefaultStyle(borderElement);\n    if (remove) {\n      \
addClass(this[borderElement], \"hidden\");\n    } else {\n      \
removeClass(this[borderElement], \"hidden\");\n    }\n  }\n  /**\n   * Hide \
border.\n   */\n  disappear() {\n    this.topStyle.display = \"none\";\n    \
this.bottomStyle.display = \"none\";\n    this.startStyle.display = \
\"none\";\n    this.endStyle.display = \"none\";\n    \
this.cornerStyle.display = \"none\";\n    if (isMobileBrowser()) {\n      \
this.selectionHandles.styles.top.display = \"none\";\n      \
this.selectionHandles.styles.topHitArea.display = \"none\";\n      \
this.selectionHandles.styles.bottom.display = \"none\";\n      \
this.selectionHandles.styles.bottomHitArea.display = \"none\";\n    }\n  }\n  \
/**\n   * Cleans up all the DOM state related to a Border instance. Call this \
prior to deleting a Border instance.\n   */\n  destroy() {\n    \
this.eventManager.destroyWithOwnEventsOnly();\n    \
this.main.parentNode.removeChild(this.main);\n  }\n};\nvar border_default = \
Border;\n\n// \
node_modules/handsontable/3rdparty/walkontable/src/selection.mjs\nvar \
Selection = class {\n  /**\n   * @param {object} settings The selection \
settings object. @todo type.\n   * @param {CellRange} cellRange The cell \
range instance.\n   */\n  constructor(settings, cellRange) {\n    \
this.settings = settings;\n    this.cellRange = cellRange || null;\n    \
this.instanceBorders = {};\n    this.classNames = \
[this.settings.className];\n    this.classNameGenerator = \
this.linearClassNameGenerator(this.settings.className, \
this.settings.layerLevel);\n  }\n  /**\n   * Each Walkontable clone requires \
it's own border for every selection. This method creates and returns \
selection\n   * borders per instance.\n   *\n   * @param {WalkontableFacade} \
wotInstance The Walkontable instance.\n   * @returns {Border}\n   */\n  \
getBorder(wotInstance) {\n    if (!this.instanceBorders[wotInstance.guid]) \
{\n      this.instanceBorders[wotInstance.guid] = new \
border_default(wotInstance, this.settings);\n    }\n    return \
this.instanceBorders[wotInstance.guid];\n  }\n  /**\n   * Checks if selection \
is empty.\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return \
this.cellRange === null;\n  }\n  /**\n   * Adds a cell coords to the \
selection.\n   *\n   * @param {CellCoords} coords The cell coordinates to \
add.\n   * @returns {Selection}\n   */\n  add(coords) {\n    if \
(this.isEmpty()) {\n      this.cellRange = \
this.settings.createCellRange(coords);\n    } else {\n      \
this.cellRange.expand(coords);\n    }\n    return this;\n  }\n  /**\n   * If \
selection range from or to property equals oldCoords, replace it with \
newCoords. Return boolean\n   * information about success.\n   *\n   * @param \
{CellCoords} oldCoords An old cell coordinates to replace.\n   * @param \
{CellCoords} newCoords The new cell coordinates.\n   * @returns {boolean}\n   \
*/\n  replace(oldCoords, newCoords) {\n    if (!this.isEmpty()) {\n      if \
(this.cellRange.from.isEqual(oldCoords)) {\n        this.cellRange.from = \
newCoords;\n        return true;\n      }\n      if \
(this.cellRange.to.isEqual(oldCoords)) {\n        this.cellRange.to = \
newCoords;\n        return true;\n      }\n    }\n    return false;\n  }\n  \
/**\n   * Clears selection.\n   *\n   * @returns {Selection}\n   */\n  \
clear() {\n    this.cellRange = null;\n    return this;\n  }\n  /**\n   * \
Returns the top left (or top right in RTL) and bottom right (or bottom left \
in RTL) selection coordinates.\n   *\n   * @returns {Array} Returns array of \
coordinates for example `[1, 1, 5, 5]`.\n   */\n  getCorners() {\n    const \
topStart = this.cellRange.getOuterTopStartCorner();\n    const bottomEnd = \
this.cellRange.getOuterBottomEndCorner();\n    return [topStart.row, \
topStart.col, bottomEnd.row, bottomEnd.col];\n  }\n  /**\n   * Adds class \
name to cell element at given coords.\n   *\n   * @param {WalkontableFacade} \
wotInstance Walkontable instance.\n   * @param {number} sourceRow Cell row \
coord.\n   * @param {number} sourceColumn Cell column coord.\n   * @param \
{string} className Class name.\n   * @param {boolean} \
[markIntersections=false] If `true`, linear className generator will be used \
to add CSS classes\n   *                                            in a \
continuous way.\n   * @returns {Selection}\n   */\n  \
addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {\n    let \
markIntersections = arguments.length > 4 && arguments[4] !== void 0 ? \
arguments[4] : false;\n    const TD = \
wotInstance.wtTable.getCell(this.settings.createCellCoords(sourceRow, \
sourceColumn));\n    if (typeof TD === \"object\") {\n      let cellClassName \
= className;\n      if (markIntersections) {\n        cellClassName = \
this.classNameGenerator(TD);\n        if \
(!this.classNames.includes(cellClassName)) {\n          \
this.classNames.push(cellClassName);\n        }\n      }\n      addClass(TD, \
cellClassName);\n    }\n    return this;\n  }\n  /**\n   * Generate helper \
for calculating classNames based on previously added base className.\n   * \
The generated className is always generated as a continuation of the previous \
className. For example, when\n   * the currently checked element has 'area-2' \
className the generated new className will be 'area-3'. When\n   * the \
element doesn't have any classNames than the base className will be returned \
('area');.\n   *\n   * @param {string} baseClassName Base className to be \
used.\n   * @param {number} layerLevelOwner Layer level which the instance of \
the Selection belongs to.\n   * @returns {Function}\n   */\n  \
linearClassNameGenerator(baseClassName, layerLevelOwner) {\n    return \
function calcClassName(element) {\n      let previousIndex = arguments.length \
> 1 && arguments[1] !== void 0 ? arguments[1] : -1;\n      if \
(layerLevelOwner === 0 || previousIndex === 0) {\n        return \
baseClassName;\n      }\n      let index2 = previousIndex >= 0 ? \
previousIndex : layerLevelOwner;\n      let className = baseClassName;\n      \
index2 -= 1;\n      const previousClassName = index2 === 0 ? baseClassName : \
`${baseClassName}-${index2}`;\n      if (hasClass(element, \
previousClassName)) {\n        const currentLayer = index2 + 1;\n        \
className = `${baseClassName}-${currentLayer}`;\n      } else {\n        \
className = calcClassName(element, index2);\n      }\n      return \
className;\n    };\n  }\n  /**\n   * @param {WalkontableFacade} wotInstance \
The Walkontable instance.\n   */\n  draw(wotInstance) {\n    if \
(this.isEmpty()) {\n      if (this.settings.border) {\n        \
this.getBorder(wotInstance).disappear();\n      }\n      return;\n    }\n    \
const renderedRows = wotInstance.wtTable.getRenderedRowsCount();\n    const \
renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();\n    const \
corners = this.getCorners();\n    const [topRow, topColumn, bottomRow, \
bottomColumn] = corners;\n    const {\n      highlightHeaderClassName,\n      \
highlightColumnClassName,\n      highlightRowClassName,\n      \
highlightOnlyClosestHeader,\n      selectionType\n    } = this.settings;\n    \
const isHeaderSelectionType = selectionType === void 0 || [\"active-header\", \
\"header\"].includes(selectionType);\n    if (isHeaderSelectionType && \
topColumn !== null && bottomColumn !== null) {\n      let \
selectionColumnCursor = 0;\n      for (let column = 0; column < \
renderedColumns; column += 1) {\n        const sourceCol = \
wotInstance.wtTable.columnFilter.renderedToSource(column);\n        if \
(sourceCol >= topColumn && sourceCol <= bottomColumn) {\n          let THs = \
wotInstance.wtTable.getColumnHeaders(sourceCol);\n          const \
closestHeaderLevel = THs.length - 1;\n          if \
(highlightOnlyClosestHeader && THs.length > 1) {\n            THs = \
[THs[closestHeaderLevel]];\n          }\n          for (let headerLevel = 0; \
headerLevel < THs.length; headerLevel += 1) {\n            const newClasses = \
[];\n            let TH = THs[headerLevel];\n            if \
(highlightHeaderClassName) {\n              \
newClasses.push(highlightHeaderClassName);\n            }\n            if \
(highlightColumnClassName) {\n              \
newClasses.push(highlightColumnClassName);\n            }\n            \
headerLevel = highlightOnlyClosestHeader ? closestHeaderLevel : \
headerLevel;\n            const newSourceCol = \
wotInstance.getSetting(\"onBeforeHighlightingColumnHeader\", sourceCol, \
headerLevel, {\n              selectionType,\n              columnCursor: \
selectionColumnCursor,\n              selectionWidth: bottomColumn - \
topColumn + 1,\n              classNames: newClasses\n            });\n       \
     if (newSourceCol !== sourceCol) {\n              TH = \
wotInstance.wtTable.getColumnHeader(newSourceCol, headerLevel);\n            \
}\n            addClass(TH, newClasses);\n          }\n          \
selectionColumnCursor += 1;\n        }\n      }\n    }\n    if (topRow !== \
null && bottomRow !== null) {\n      let selectionRowCursor = 0;\n      for \
(let row = 0; row < renderedRows; row += 1) {\n        const sourceRow = \
wotInstance.wtTable.rowFilter.renderedToSource(row);\n        if \
(isHeaderSelectionType && sourceRow >= topRow && sourceRow <= bottomRow) {\n  \
        let THs = wotInstance.wtTable.getRowHeaders(sourceRow);\n          \
const closestHeaderLevel = THs.length - 1;\n          if \
(highlightOnlyClosestHeader && THs.length > 1) {\n            THs = \
[THs[closestHeaderLevel]];\n          }\n          for (let headerLevel = 0; \
headerLevel < THs.length; headerLevel += 1) {\n            const newClasses = \
[];\n            let TH = THs[headerLevel];\n            if \
(highlightHeaderClassName) {\n              \
newClasses.push(highlightHeaderClassName);\n            }\n            if \
(highlightRowClassName) {\n              \
newClasses.push(highlightRowClassName);\n            }\n            \
headerLevel = highlightOnlyClosestHeader ? closestHeaderLevel : \
headerLevel;\n            const newSourceRow = \
wotInstance.getSetting(\"onBeforeHighlightingRowHeader\", sourceRow, \
headerLevel, {\n              selectionType,\n              rowCursor: \
selectionRowCursor,\n              selectionHeight: bottomRow - topRow + 1,\n \
             classNames: newClasses\n            });\n            if \
(newSourceRow !== sourceRow) {\n              TH = \
wotInstance.wtTable.getRowHeader(newSourceRow, headerLevel);\n            }\n \
           addClass(TH, newClasses);\n          }\n          \
selectionRowCursor += 1;\n        }\n        if (topColumn !== null && \
bottomColumn !== null) {\n          for (let column = 0; column < \
renderedColumns; column += 1) {\n            const sourceCol = \
wotInstance.wtTable.columnFilter.renderedToSource(column);\n            if \
(sourceRow >= topRow && sourceRow <= bottomRow && sourceCol >= topColumn && \
sourceCol <= bottomColumn) {\n              if (this.settings.className) {\n  \
              this.addClassAtCoords(wotInstance, sourceRow, sourceCol, \
this.settings.className, this.settings.markIntersections);\n              }\n \
           } else if (sourceRow >= topRow && sourceRow <= bottomRow) {\n      \
        if (highlightRowClassName) {\n                \
this.addClassAtCoords(wotInstance, sourceRow, sourceCol, \
highlightRowClassName);\n              }\n            } else if (sourceCol >= \
topColumn && sourceCol <= bottomColumn) {\n              if \
(highlightColumnClassName) {\n                \
this.addClassAtCoords(wotInstance, sourceRow, sourceCol, \
highlightColumnClassName);\n              }\n            }\n            const \
additionalSelectionClass = wotInstance.getSetting(\"onAfterDrawSelection\", \
sourceRow, sourceCol, this.settings.layerLevel);\n            if (typeof \
additionalSelectionClass === \"string\") {\n              \
this.addClassAtCoords(wotInstance, sourceRow, sourceCol, \
additionalSelectionClass);\n            }\n          }\n        }\n      }\n  \
  }\n    wotInstance.getSetting(\"onBeforeDrawBorders\", corners, \
this.settings.className);\n    if (this.settings.border) {\n      \
this.getBorder(wotInstance).appear(corners);\n    }\n  }\n  /**\n   * Cleans \
up all the DOM state related to a Selection instance. Call this prior to \
deleting a Selection instance.\n   */\n  destroy() {\n    \
Object.values(this.instanceBorders).forEach((border) => border.destroy());\n  \
}\n};\nvar selection_default = Selection;\n\n// \
node_modules/handsontable/selection/mouseEventHandler.mjs\nfunction \
mouseDown(_ref) {\n  let {\n    isShiftKey,\n    isLeftClick: isLeftClick2,\n \
   isRightClick: isRightClick2,\n    coords,\n    selection,\n    \
controller,\n    cellCoordsFactory\n  } = _ref;\n  const currentSelection = \
selection.isSelected() ? selection.getSelectedRange().current() : null;\n  \
const selectedCorner = selection.isSelectedByCorner();\n  const selectedRow = \
selection.isSelectedByRowHeader();\n  if (isShiftKey && currentSelection) {\n \
   if (coords.row >= 0 && coords.col >= 0 && !controller.cell) {\n      \
selection.setRangeEnd(coords);\n    } else if ((selectedCorner || \
selectedRow) && coords.row >= 0 && coords.col >= 0 && !controller.cell) {\n   \
   selection.setRangeEnd(cellCoordsFactory(coords.row, coords.col));\n    } \
else if (selectedCorner && coords.row < 0 && !controller.column) {\n      \
selection.setRangeEnd(cellCoordsFactory(currentSelection.to.row, \
coords.col));\n    } else if (selectedRow && coords.col < 0 && \
!controller.row) {\n      selection.setRangeEnd(cellCoordsFactory(coords.row, \
currentSelection.to.col));\n    } else if ((!selectedCorner && !selectedRow \
&& coords.col < 0 || selectedCorner && coords.col < 0) && !controller.row) \
{\n      selection.selectRows(Math.max(currentSelection.from.row, 0), \
coords.row, coords.col);\n    } else if ((!selectedCorner && !selectedRow && \
coords.row < 0 || selectedRow && coords.row < 0) && !controller.column) {\n   \
   selection.selectColumns(Math.max(currentSelection.from.col, 0), \
coords.col, coords.row);\n    }\n  } else {\n    const \
allowRightClickSelection = !selection.inInSelection(coords);\n    const \
performSelection = isLeftClick2 || isRightClick2 && \
allowRightClickSelection;\n    if (coords.row < 0 && coords.col >= 0 && \
!controller.column) {\n      if (performSelection) {\n        \
selection.selectColumns(coords.col, coords.col, coords.row);\n      }\n    } \
else if (coords.col < 0 && coords.row >= 0 && !controller.row) {\n      if \
(performSelection) {\n        selection.selectRows(coords.row, coords.row, \
coords.col);\n      }\n    } else if (coords.col >= 0 && coords.row >= 0 && \
!controller.cell) {\n      if (performSelection) {\n        \
selection.setRangeStart(coords);\n      }\n    } else if (coords.col < 0 && \
coords.row < 0) {\n      selection.selectAll(true, true);\n    }\n  \
}\n}\nfunction mouseOver(_ref2) {\n  let {\n    isLeftClick: isLeftClick2,\n  \
  coords,\n    selection,\n    controller,\n    cellCoordsFactory\n  } = \
_ref2;\n  if (!isLeftClick2) {\n    return;\n  }\n  const selectedRow = \
selection.isSelectedByRowHeader();\n  const selectedColumn = \
selection.isSelectedByColumnHeader();\n  const countCols = \
selection.tableProps.countCols();\n  const countRows = \
selection.tableProps.countRows();\n  if (selectedColumn && \
!controller.column) {\n    selection.setRangeEnd(cellCoordsFactory(countRows \
- 1, coords.col));\n  } else if (selectedRow && !controller.row) {\n    \
selection.setRangeEnd(cellCoordsFactory(coords.row, countCols - 1));\n  } \
else if (!controller.cell) {\n    selection.setRangeEnd(coords);\n  }\n}\nvar \
handlers = /* @__PURE__ */ new Map([[\"mousedown\", mouseDown], \
[\"mouseover\", mouseOver], [\"touchstart\", mouseDown]]);\nfunction \
handleMouseEvent(event2, _ref3) {\n  let {\n    coords,\n    selection,\n    \
controller,\n    cellCoordsFactory\n  } = _ref3;\n  \
handlers.get(event2.type)({\n    coords,\n    selection,\n    controller,\n   \
 cellCoordsFactory,\n    isShiftKey: event2.shiftKey,\n    isLeftClick: \
isLeftClick(event2) || event2.type === \"touchstart\",\n    isRightClick: \
isRightClick(event2)\n  });\n}\n\n// \
node_modules/handsontable/utils/rootInstance.mjs\nvar holder = /* @__PURE__ \
*/ new WeakMap();\nvar rootInstanceSymbol = \
Symbol(\"rootInstance\");\nfunction registerAsRootInstance(object) {\n  \
holder.set(object, true);\n}\nfunction hasValidParameter(rootSymbol) {\n  \
return rootSymbol === rootInstanceSymbol;\n}\nfunction isRootInstance(object) \
{\n  return holder.has(object);\n}\n\n// \
node_modules/handsontable/tableView.mjs\nfunction \
_classPrivateFieldInitSpec3(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration3(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration3(obj, privateCollection) {\n  \
if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_defineProperty13(obj, key, value) {\n  key = _toPropertyKey13(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey13(arg) {\n  var key = \
_toPrimitive13(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive13(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nfunction _classPrivateFieldGet3(receiver, privateMap) {\n \
 var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, \
\"get\");\n  return _classApplyDescriptorGet3(receiver, \
descriptor);\n}\nfunction _classApplyDescriptorGet3(receiver, descriptor) {\n \
 if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  \
return descriptor.value;\n}\nfunction _classPrivateFieldSet3(receiver, \
privateMap, value) {\n  var descriptor = \
_classExtractFieldDescriptor3(receiver, privateMap, \"set\");\n  \
_classApplyDescriptorSet3(receiver, descriptor, value);\n  return \
value;\n}\nfunction _classExtractFieldDescriptor3(receiver, privateMap, \
action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorSet3(receiver, descriptor, value) {\n  if \
(descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n   \
 if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set \
read only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\nvar privatePool4 = /* @__PURE__ */ new WeakMap();\nvar \
_columnHeadersCount = /* @__PURE__ */ new WeakMap();\nvar _rowHeadersCount = \
/* @__PURE__ */ new WeakMap();\nvar TableView = class {\n  /**\n   * @param \
{Hanstontable} instance Instance of {@link Handsontable}.\n   */\n  \
constructor(instance) {\n    _defineProperty13(this, \"instance\", void 0);\n \
   _defineProperty13(this, \"eventManager\", void 0);\n    \
_defineProperty13(this, \"settings\", void 0);\n    _defineProperty13(this, \
\"THEAD\", void 0);\n    _defineProperty13(this, \"TBODY\", void 0);\n    \
_defineProperty13(this, \"_wt\", void 0);\n    _defineProperty13(this, \
\"activeWt\", void 0);\n    _classPrivateFieldInitSpec3(this, \
_columnHeadersCount, {\n      writable: true,\n      value: 0\n    });\n    \
_classPrivateFieldInitSpec3(this, _rowHeadersCount, {\n      writable: \
true,\n      value: 0\n    });\n    _defineProperty13(this, \
\"postponedAdjustElementsSize\", false);\n    this.instance = instance;\n    \
this.eventManager = new eventManager_default(this.instance);\n    \
this.settings = this.instance.getSettings();\n    privatePool4.set(this, {\n  \
    /**\n       * Defines if the text should be selected during mousemove.\n  \
     *\n       * @private\n       * @type {boolean}\n       */\n      \
selectionMouseDown: false,\n      /**\n       * @private\n       * @type \
{boolean}\n       */\n      mouseDown: void 0,\n      /**\n       * Main \
<TABLE> element.\n       *\n       * @private\n       * @type \
{HTMLTableElement}\n       */\n      table: void 0,\n      /**\n       * \
Cached width of the rootElement.\n       *\n       * @type {number}\n       \
*/\n      lastWidth: 0,\n      /**\n       * Cached height of the \
rootElement.\n       *\n       * @type {number}\n       */\n      lastHeight: \
0\n    });\n    this.createElements();\n    this.registerEvents();\n    \
this.initializeWalkontable();\n  }\n  /**\n   * Renders WalkontableUI.\n   \
*/\n  render() {\n    if (!this.instance.isRenderSuspended()) {\n      \
this.instance.runHooks(\"beforeRender\", this.instance.forceFullRender);\n    \
  if (this.postponedAdjustElementsSize) {\n        \
this.postponedAdjustElementsSize = false;\n        \
this.adjustElementsSize(true);\n      }\n      \
this._wt.draw(!this.instance.forceFullRender);\n      \
this.instance.runHooks(\"afterRender\", this.instance.forceFullRender);\n     \
 this.instance.forceFullRender = false;\n      this.instance.renderCall = \
false;\n    }\n  }\n  /**\n   * Adjust overlays elements size and master \
table size.\n   *\n   * @param {boolean} [force=false] When `true`, it adjust \
the DOM nodes sizes for all overlays.\n   */\n  adjustElementsSize() {\n    \
let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
false;\n    if (this.instance.isRenderSuspended()) {\n      \
this.postponedAdjustElementsSize = true;\n    } else {\n      \
this._wt.wtOverlays.adjustElementsSize(force);\n    }\n  }\n  /**\n   * \
Returns td object given coordinates.\n   *\n   * @param {CellCoords} coords \
Renderable cell coordinates.\n   * @param {boolean} topmost Indicates whether \
the cell should be calculated from the topmost.\n   * @returns \
{HTMLTableCellElement|null}\n   */\n  getCellAtCoords(coords, topmost) {\n    \
const td = this._wt.getCell(coords, topmost);\n    if (td < 0) {\n      \
return null;\n    }\n    return td;\n  }\n  /**\n   * Scroll viewport to a \
cell.\n   *\n   * @param {CellCoords} coords Renderable cell coordinates.\n   \
* @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the \
cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, \
viewport is scrolled to show the cell on the right side of the table.\n   * \
@param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the \
cell on the bottom side of the table.\n   * @param {boolean} [snapToLeft] If \
`true`, viewport is scrolled to show the cell on the left side of the \
table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, \
snapToRight, snapToBottom, snapToLeft) {\n    return \
this._wt.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, \
snapToLeft);\n  }\n  /**\n   * Scroll viewport to a column.\n   *\n   * \
@param {number} column Renderable column index.\n   * @param {boolean} \
[snapToRight] If `true`, viewport is scrolled to show the cell on the right \
side of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is \
scrolled to show the cell on the left side of the table.\n   * @returns \
{boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, \
snapToLeft) {\n    return this._wt.scrollViewportHorizontally(column, \
snapToRight, snapToLeft);\n  }\n  /**\n   * Scroll viewport to a row.\n   *\n \
  * @param {number} row Renderable row index.\n   * @param {boolean} \
[snapToTop] If `true`, viewport is scrolled to show the cell on the top of \
the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is \
scrolled to show the cell on the bottom side of the table.\n   * @returns \
{boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) \
{\n    return this._wt.scrollViewportVertically(row, snapToTop, \
snapToBottom);\n  }\n  /**\n   * Prepares DOMElements and adds correct \
className to the root element.\n   *\n   * @private\n   */\n  \
createElements() {\n    const priv = privatePool4.get(this);\n    const {\n   \
   rootElement,\n      rootDocument\n    } = this.instance;\n    const \
originalStyle = rootElement.getAttribute(\"style\");\n    if (originalStyle) \
{\n      rootElement.setAttribute(\"data-originalstyle\", originalStyle);\n   \
 }\n    addClass(rootElement, \"handsontable\");\n    priv.table = \
rootDocument.createElement(\"TABLE\");\n    addClass(priv.table, \
\"htCore\");\n    if (this.instance.getSettings().tableClassName) {\n      \
addClass(priv.table, this.instance.getSettings().tableClassName);\n    }\n    \
this.THEAD = rootDocument.createElement(\"THEAD\");\n    \
priv.table.appendChild(this.THEAD);\n    this.TBODY = \
rootDocument.createElement(\"TBODY\");\n    \
priv.table.appendChild(this.TBODY);\n    this.instance.table = priv.table;\n  \
  this.instance.container.insertBefore(priv.table, \
this.instance.container.firstChild);\n  }\n  /**\n   * Attaches necessary \
listeners.\n   *\n   * @private\n   */\n  registerEvents() {\n    const priv \
= privatePool4.get(this);\n    const {\n      rootElement,\n      \
rootDocument,\n      selection\n    } = this.instance;\n    const \
documentElement = rootDocument.documentElement;\n    \
this.eventManager.addEventListener(rootElement, \"mousedown\", (event2) => \
{\n      priv.selectionMouseDown = true;\n      if \
(!this.isTextSelectionAllowed(event2.target)) {\n        const {\n          \
rootWindow\n        } = this.instance;\n        \
clearTextSelection(rootWindow);\n        event2.preventDefault();\n        \
rootWindow.focus();\n      }\n    });\n    \
this.eventManager.addEventListener(rootElement, \"mouseup\", () => {\n      \
priv.selectionMouseDown = false;\n    });\n    \
this.eventManager.addEventListener(rootElement, \"mousemove\", (event2) => \
{\n      if (priv.selectionMouseDown && \
!this.isTextSelectionAllowed(event2.target)) {\n        if \
(this.settings.fragmentSelection) {\n          \
clearTextSelection(this.instance.rootWindow);\n        }\n        \
event2.preventDefault();\n      }\n    });\n    \
this.eventManager.addEventListener(documentElement, \"keyup\", (event2) => \
{\n      if (selection.isInProgress() && !event2.shiftKey) {\n        \
selection.finish();\n      }\n    });\n    \
this.eventManager.addEventListener(documentElement, \"mouseup\", (event2) => \
{\n      if (selection.isInProgress() && isLeftClick(event2)) {\n        \
selection.finish();\n      }\n      priv.mouseDown = false;\n      if \
(isOutsideInput(rootDocument.activeElement) || !selection.isSelected() && \
!selection.isSelectedByAnyHeader() && !rootElement.contains(event2.target) && \
!isRightClick(event2)) {\n        this.instance.unlisten();\n      }\n    \
});\n    this.eventManager.addEventListener(documentElement, \"contextmenu\", \
(event2) => {\n      if (selection.isInProgress() && isRightClick(event2)) \
{\n        selection.finish();\n        priv.mouseDown = false;\n      }\n    \
});\n    this.eventManager.addEventListener(documentElement, \"touchend\", () \
=> {\n      if (selection.isInProgress()) {\n        selection.finish();\n    \
  }\n      priv.mouseDown = false;\n    });\n    \
this.eventManager.addEventListener(documentElement, \"mousedown\", (event2) \
=> {\n      const originalTarget = event2.target;\n      const eventX = \
event2.x || event2.clientX;\n      const eventY = event2.y || \
event2.clientY;\n      let next = event2.target;\n      if (priv.mouseDown || \
!rootElement || !this.instance.view) {\n        return;\n      }\n      const \
{\n        holder: holder2\n      } = this.instance.view._wt.wtTable;\n      \
if (next === holder2) {\n        const scrollbarWidth = \
getScrollbarWidth(rootDocument);\n        if \
(rootDocument.elementFromPoint(eventX + scrollbarWidth, eventY) !== holder2 \
|| rootDocument.elementFromPoint(eventX, eventY + scrollbarWidth) !== \
holder2) {\n          return;\n        }\n      } else {\n        while (next \
!== documentElement) {\n          if (next === null) {\n            if \
(event2.isTargetWebComponent) {\n              break;\n            }\n        \
    return;\n          }\n          if (next === rootElement) {\n            \
return;\n          }\n          next = next.parentNode;\n        }\n      }\n \
     const outsideClickDeselects = typeof this.settings.outsideClickDeselects \
=== \"function\" ? this.settings.outsideClickDeselects(originalTarget) : \
this.settings.outsideClickDeselects;\n      if (outsideClickDeselects) {\n    \
    this.instance.deselectCell();\n      } else {\n        \
this.instance.destroyEditor(false, false);\n      }\n    });\n    \
this.eventManager.addEventListener(priv.table, \"selectstart\", (event2) => \
{\n      if (this.settings.fragmentSelection || isInput(event2.target)) {\n   \
     return;\n      }\n      event2.preventDefault();\n    });\n  }\n  /**\n  \
 * Translate renderable cell coordinates to visual coordinates.\n   *\n   * \
@param {CellCoords} coords The cell coordinates.\n   * @returns \
{CellCoords}\n   */\n  translateFromRenderableToVisualCoords(_ref) {\n    let \
{\n      row,\n      col\n    } = _ref;\n    return \
this.instance._createCellCoords(...this.translateFromRenderableToVisualIndex(\
row, col));\n  }\n  /**\n   * Translate renderable row and column indexes to \
visual row and column indexes.\n   *\n   * @param {number} renderableRow \
Renderable row index.\n   * @param {number} renderableColumn Renderable \
columnIndex.\n   * @returns {number[]}\n   */\n  \
translateFromRenderableToVisualIndex(renderableRow, renderableColumn) {\n    \
let visualRow = renderableRow >= 0 ? \
this.instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : \
renderableRow;\n    let visualColumn = renderableColumn >= 0 ? \
this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn\
) : renderableColumn;\n    if (visualRow === null) {\n      visualRow = \
renderableRow;\n    }\n    if (visualColumn === null) {\n      visualColumn = \
renderableColumn;\n    }\n    return [visualRow, visualColumn];\n  }\n  /**\n \
  * Returns the number of renderable indexes.\n   *\n   * @private\n   * \
@param {IndexMapper} indexMapper The IndexMapper instance for specific \
axis.\n   * @param {number} maxElements Maximum number of elements (rows or \
columns).\n   *\n   * @returns {number|*}\n   */\n  \
countRenderableIndexes(indexMapper, maxElements) {\n    const \
consideredElements = Math.min(indexMapper.getNotTrimmedIndexesLength(), \
maxElements);\n    const firstNotHiddenIndex = \
indexMapper.getNearestNotHiddenIndex(consideredElements - 1, -1);\n    if \
(firstNotHiddenIndex === null) {\n      return 0;\n    }\n    return \
indexMapper.getRenderableFromVisualIndex(firstNotHiddenIndex) + 1;\n  }\n  \
/**\n   * Returns the number of renderable columns.\n   *\n   * @returns \
{number}\n   */\n  countRenderableColumns() {\n    return \
this.countRenderableIndexes(this.instance.columnIndexMapper, \
this.settings.maxCols);\n  }\n  /**\n   * Returns the number of renderable \
rows.\n   *\n   * @returns {number}\n   */\n  countRenderableRows() {\n    \
return this.countRenderableIndexes(this.instance.rowIndexMapper, \
this.settings.maxRows);\n  }\n  /**\n   * Returns number of not hidden row \
indexes counting from the passed starting index.\n   * The counting direction \
can be controlled by `incrementBy` argument.\n   *\n   * @param {number} \
visualIndex The visual index from which the counting begins.\n   * @param \
{number} incrementBy If `-1` then counting is backwards or forward when \
`1`.\n   * @returns {number}\n   */\n  countNotHiddenRowIndexes(visualIndex, \
incrementBy) {\n    return this.countNotHiddenIndexes(visualIndex, \
incrementBy, this.instance.rowIndexMapper, this.countRenderableRows());\n  \
}\n  /**\n   * Returns number of not hidden column indexes counting from the \
passed starting index.\n   * The counting direction can be controlled by \
`incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual \
index from which the counting begins.\n   * @param {number} incrementBy If \
`-1` then counting is backwards or forward when `1`.\n   * @returns \
{number}\n   */\n  countNotHiddenColumnIndexes(visualIndex, incrementBy) {\n  \
  return this.countNotHiddenIndexes(visualIndex, incrementBy, \
this.instance.columnIndexMapper, this.countRenderableColumns());\n  }\n  \
/**\n   * Returns number of not hidden indexes counting from the passed \
starting index.\n   * The counting direction can be controlled by \
`incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual \
index from which the counting begins.\n   * @param {number} incrementBy If \
`-1` then counting is backwards or forward when `1`.\n   * @param \
{IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * \
@param {number} renderableIndexesCount Total count of renderable indexes for \
specific axis.\n   * @returns {number}\n   */\n  \
countNotHiddenIndexes(visualIndex, incrementBy, indexMapper, \
renderableIndexesCount) {\n    if (isNaN(visualIndex) || visualIndex < 0) {\n \
     return 0;\n    }\n    const firstVisibleIndex = \
indexMapper.getNearestNotHiddenIndex(visualIndex, incrementBy);\n    const \
renderableIndex = \
indexMapper.getRenderableFromVisualIndex(firstVisibleIndex);\n    if \
(!Number.isInteger(renderableIndex)) {\n      return 0;\n    }\n    let \
notHiddenIndexes = 0;\n    if (incrementBy < 0) {\n      notHiddenIndexes = \
renderableIndex + 1;\n    } else if (incrementBy > 0) {\n      \
notHiddenIndexes = renderableIndexesCount - renderableIndex;\n    }\n    \
return notHiddenIndexes;\n  }\n  /**\n   * The function returns the number of \
not hidden column indexes that fit between the first and\n   * last fixed \
column in the left (or right in RTL mode) overlay.\n   *\n   * @returns \
{number}\n   */\n  countNotHiddenFixedColumnsStart() {\n    const countCols = \
this.instance.countCols();\n    const visualFixedColumnsStart = \
Math.min(parseInt(this.settings.fixedColumnsStart, 10), countCols) - 1;\n    \
return this.countNotHiddenColumnIndexes(visualFixedColumnsStart, -1);\n  }\n  \
/**\n   * The function returns the number of not hidden row indexes that fit \
between the first and\n   * last fixed row in the top overlay.\n   *\n   * \
@returns {number}\n   */\n  countNotHiddenFixedRowsTop() {\n    const \
countRows = this.instance.countRows();\n    const visualFixedRowsTop = \
Math.min(parseInt(this.settings.fixedRowsTop, 10), countRows) - 1;\n    \
return this.countNotHiddenRowIndexes(visualFixedRowsTop, -1);\n  }\n  /**\n   \
* The function returns the number of not hidden row indexes that fit between \
the first and\n   * last fixed row in the bottom overlay.\n   *\n   * \
@returns {number}\n   */\n  countNotHiddenFixedRowsBottom() {\n    const \
countRows = this.instance.countRows();\n    const visualFixedRowsBottom = \
Math.max(countRows - parseInt(this.settings.fixedRowsBottom, 10), 0);\n    \
return this.countNotHiddenRowIndexes(visualFixedRowsBottom, 1);\n  }\n  /**\n \
  * Checks if at least one cell than belongs to the main table is not covered \
by the top, left or\n   * bottom overlay.\n   *\n   * @returns {boolean}\n   \
*/\n  isMainTableNotFullyCoveredByOverlays() {\n    const fixedAllRows = \
this.countNotHiddenFixedRowsTop() + this.countNotHiddenFixedRowsBottom();\n   \
 const fixedAllColumns = this.countNotHiddenFixedColumnsStart();\n    return \
this.instance.countRenderedRows() > fixedAllRows && \
this.instance.countRenderedCols() > fixedAllColumns;\n  }\n  /**\n   * \
Defines default configuration and initializes WalkOnTable instance.\n   *\n   \
* @private\n   */\n  initializeWalkontable() {\n    const priv = \
privatePool4.get(this);\n    const walkontableConfig = {\n      rtlMode: \
this.instance.isRtl(),\n      externalRowCalculator: \
this.instance.getPlugin(\"autoRowSize\") && \
this.instance.getPlugin(\"autoRowSize\").isEnabled(),\n      table: \
priv.table,\n      isDataViewInstance: () => isRootInstance(this.instance),\n \
     preventOverflow: () => this.settings.preventOverflow,\n      \
preventWheel: () => this.settings.preventWheel,\n      stretchH: () => \
this.settings.stretchH,\n      data: (renderableRow, renderableColumn) => {\n \
       return \
this.instance.getDataAtCell(...this.translateFromRenderableToVisualIndex(rend\
erableRow, renderableColumn));\n      },\n      totalRows: () => \
this.countRenderableRows(),\n      totalColumns: () => \
this.countRenderableColumns(),\n      // Number of renderable columns for the \
left overlay.\n      fixedColumnsStart: () => \
this.countNotHiddenFixedColumnsStart(),\n      // Number of renderable rows \
for the top overlay.\n      fixedRowsTop: () => \
this.countNotHiddenFixedRowsTop(),\n      // Number of renderable rows for \
the bottom overlay.\n      fixedRowsBottom: () => \
this.countNotHiddenFixedRowsBottom(),\n      // Enable the inline start \
overlay when conditions are met.\n      shouldRenderInlineStartOverlay: () => \
{\n        return this.settings.fixedColumnsStart > 0 || \
walkontableConfig.rowHeaders().length > 0;\n      },\n      // Enable the top \
overlay when conditions are met.\n      shouldRenderTopOverlay: () => {\n     \
   return this.settings.fixedRowsTop > 0 || \
walkontableConfig.columnHeaders().length > 0;\n      },\n      // Enable the \
bottom overlay when conditions are met.\n      shouldRenderBottomOverlay: () \
=> {\n        return this.settings.fixedRowsBottom > 0;\n      },\n      \
minSpareRows: () => this.settings.minSpareRows,\n      renderAllRows: \
this.settings.renderAllRows,\n      rowHeaders: () => {\n        const \
headerRenderers = [];\n        if (this.instance.hasRowHeaders()) {\n         \
 headerRenderers.push((renderableRowIndex, TH) => {\n            const \
visualRowIndex = renderableRowIndex >= 0 ? \
this.instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRowIndex) \
: renderableRowIndex;\n            this.appendRowHeader(visualRowIndex, \
TH);\n          });\n        }\n        \
this.instance.runHooks(\"afterGetRowHeaderRenderers\", headerRenderers);\n    \
    _classPrivateFieldSet3(this, _rowHeadersCount, headerRenderers.length);\n \
       return headerRenderers;\n      },\n      columnHeaders: () => {\n      \
  const headerRenderers = [];\n        if (this.instance.hasColHeaders()) {\n \
         headerRenderers.push((renderedColumnIndex, TH) => {\n            \
const visualColumnsIndex = renderedColumnIndex >= 0 ? \
this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIn\
dex) : renderedColumnIndex;\n            \
this.appendColHeader(visualColumnsIndex, TH);\n          });\n        }\n     \
   this.instance.runHooks(\"afterGetColumnHeaderRenderers\", \
headerRenderers);\n        _classPrivateFieldSet3(this, _columnHeadersCount, \
headerRenderers.length);\n        return headerRenderers;\n      },\n      \
columnWidth: (renderedColumnIndex) => {\n        const visualIndex = \
this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIn\
dex);\n        return this.instance.getColWidth(visualIndex === null ? \
renderedColumnIndex : visualIndex);\n      },\n      rowHeight: \
(renderedRowIndex) => {\n        const visualIndex = \
this.instance.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);\
\n        return this.instance.getRowHeight(visualIndex === null ? \
renderedRowIndex : visualIndex);\n      },\n      cellRenderer: \
(renderedRowIndex, renderedColumnIndex, TD) => {\n        const \
[visualRowIndex, visualColumnIndex] = \
this.translateFromRenderableToVisualIndex(renderedRowIndex, \
renderedColumnIndex);\n        const modifiedCellCoords = \
this.instance.runHooks(\"modifyGetCellCoords\", visualRowIndex, \
visualColumnIndex);\n        let visualRowToCheck = visualRowIndex;\n        \
let visualColumnToCheck = visualColumnIndex;\n        if \
(Array.isArray(modifiedCellCoords)) {\n          [visualRowToCheck, \
visualColumnToCheck] = modifiedCellCoords;\n        }\n        const \
cellProperties = this.instance.getCellMeta(visualRowToCheck, \
visualColumnToCheck);\n        const prop = \
this.instance.colToProp(visualColumnToCheck);\n        let value = \
this.instance.getDataAtRowProp(visualRowToCheck, prop);\n        if \
(this.instance.hasHook(\"beforeValueRender\")) {\n          value = \
this.instance.runHooks(\"beforeValueRender\", value, cellProperties);\n       \
 }\n        this.instance.runHooks(\"beforeRenderer\", TD, visualRowIndex, \
visualColumnIndex, prop, value, cellProperties);\n        \
this.instance.getCellRenderer(cellProperties)(this.instance, TD, \
visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n        \
this.instance.runHooks(\"afterRenderer\", TD, visualRowIndex, \
visualColumnIndex, prop, value, cellProperties);\n      },\n      selections: \
this.instance.selection.highlight,\n      hideBorderOnMouseDownOver: () => \
this.settings.fragmentSelection,\n      onWindowResize: () => {\n        if \
(this.instance && !this.instance.isDestroyed) {\n          \
this.instance.refreshDimensions();\n        }\n      },\n      \
onContainerElementResize: () => {\n        if (this.instance && \
!this.instance.isDestroyed) {\n          this.instance.refreshDimensions();\n \
       }\n      },\n      onCellMouseDown: (event2, coords, TD, wt) => {\n    \
    const visualCoords = \
this.translateFromRenderableToVisualCoords(coords);\n        const controller \
= {\n          row: false,\n          column: false,\n          cell: false\n \
       };\n        this.instance.listen();\n        this.activeWt = wt;\n     \
   priv.mouseDown = true;\n        \
this.instance.runHooks(\"beforeOnCellMouseDown\", event2, visualCoords, TD, \
controller);\n        if (isImmediatePropagationStopped(event2)) {\n          \
return;\n        }\n        handleMouseEvent(event2, {\n          coords: \
visualCoords,\n          selection: this.instance.selection,\n          \
controller,\n          cellCoordsFactory: (row, column) => \
this.instance._createCellCoords(row, column)\n        });\n        \
this.instance.runHooks(\"afterOnCellMouseDown\", event2, visualCoords, TD);\n \
       this.activeWt = this._wt;\n      },\n      onCellContextMenu: (event2, \
coords, TD, wt) => {\n        const visualCoords = \
this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = \
wt;\n        priv.mouseDown = false;\n        if \
(this.instance.selection.isInProgress()) {\n          \
this.instance.selection.finish();\n        }\n        \
this.instance.runHooks(\"beforeOnCellContextMenu\", event2, visualCoords, \
TD);\n        if (isImmediatePropagationStopped(event2)) {\n          \
return;\n        }\n        \
this.instance.runHooks(\"afterOnCellContextMenu\", event2, visualCoords, \
TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseOut: \
(event2, coords, TD, wt) => {\n        const visualCoords = \
this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = \
wt;\n        this.instance.runHooks(\"beforeOnCellMouseOut\", event2, \
visualCoords, TD);\n        if (isImmediatePropagationStopped(event2)) {\n    \
      return;\n        }\n        \
this.instance.runHooks(\"afterOnCellMouseOut\", event2, visualCoords, TD);\n  \
      this.activeWt = this._wt;\n      },\n      onCellMouseOver: (event2, \
coords, TD, wt) => {\n        const visualCoords = \
this.translateFromRenderableToVisualCoords(coords);\n        const controller \
= {\n          row: false,\n          column: false,\n          cell: false\n \
       };\n        this.activeWt = wt;\n        \
this.instance.runHooks(\"beforeOnCellMouseOver\", event2, visualCoords, TD, \
controller);\n        if (isImmediatePropagationStopped(event2)) {\n          \
return;\n        }\n        if (priv.mouseDown) {\n          \
handleMouseEvent(event2, {\n            coords: visualCoords,\n            \
selection: this.instance.selection,\n            controller,\n            \
cellCoordsFactory: (row, column) => this.instance._createCellCoords(row, \
column)\n          });\n        }\n        \
this.instance.runHooks(\"afterOnCellMouseOver\", event2, visualCoords, TD);\n \
       this.activeWt = this._wt;\n      },\n      onCellMouseUp: (event2, \
coords, TD, wt) => {\n        const visualCoords = \
this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = \
wt;\n        this.instance.runHooks(\"beforeOnCellMouseUp\", event2, \
visualCoords, TD);\n        if (isImmediatePropagationStopped(event2) || \
this.instance.isDestroyed) {\n          return;\n        }\n        \
this.instance.runHooks(\"afterOnCellMouseUp\", event2, visualCoords, TD);\n   \
     this.activeWt = this._wt;\n      },\n      onCellCornerMouseDown: \
(event2) => {\n        event2.preventDefault();\n        \
this.instance.runHooks(\"afterOnCellCornerMouseDown\", event2);\n      },\n   \
   onCellCornerDblClick: (event2) => {\n        event2.preventDefault();\n    \
    this.instance.runHooks(\"afterOnCellCornerDblClick\", event2);\n      \
},\n      beforeDraw: (force, skipRender) => this.beforeRender(force, \
skipRender),\n      onDraw: (force) => this.afterRender(force),\n      \
onScrollVertically: () => \
this.instance.runHooks(\"afterScrollVertically\"),\n      \
onScrollHorizontally: () => \
this.instance.runHooks(\"afterScrollHorizontally\"),\n      \
onBeforeRemoveCellClassNames: () => \
this.instance.runHooks(\"beforeRemoveCellClassNames\"),\n      \
onBeforeHighlightingRowHeader: (renderableRow, headerLevel, highlightMeta) => \
{\n        const rowMapper = this.instance.rowIndexMapper;\n        const \
visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);\n        \
const newVisualRow = this.instance.runHooks(\"beforeHighlightingRowHeader\", \
visualRow, headerLevel, highlightMeta);\n        return \
rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(new\
VisualRow, 1));\n      },\n      onBeforeHighlightingColumnHeader: \
(renderableColumn, headerLevel, highlightMeta) => {\n        const \
columnMapper = this.instance.columnIndexMapper;\n        const visualColumn = \
columnMapper.getVisualFromRenderableIndex(renderableColumn);\n        const \
newVisualColumn = this.instance.runHooks(\"beforeHighlightingColumnHeader\", \
visualColumn, headerLevel, highlightMeta);\n        return \
columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenInd\
ex(newVisualColumn, 1));\n      },\n      onAfterDrawSelection: (currentRow, \
currentColumn, layerLevel) => {\n        let cornersOfSelection;\n        \
const [visualRowIndex, visualColumnIndex] = \
this.translateFromRenderableToVisualIndex(currentRow, currentColumn);\n       \
 const selectedRange = this.instance.selection.getSelectedRange();\n        \
const selectionRangeSize = selectedRange.size();\n        if \
(selectionRangeSize > 0) {\n          const selectionOffset = (layerLevel !== \
null && layerLevel !== void 0 ? layerLevel : 0) + 1 - selectionRangeSize;\n   \
       const selectionForLayer = \
selectedRange.peekByIndex(selectionOffset);\n          cornersOfSelection = \
[selectionForLayer.from.row, selectionForLayer.from.col, \
selectionForLayer.to.row, selectionForLayer.to.col];\n        }\n        \
return this.instance.runHooks(\"afterDrawSelection\", visualRowIndex, \
visualColumnIndex, cornersOfSelection, layerLevel);\n      },\n      \
onBeforeDrawBorders: (corners, borderClassName) => {\n        const \
[startRenderableRow, startRenderableColumn, endRenderableRow, \
endRenderableColumn] = corners;\n        const visualCorners = \
[this.instance.rowIndexMapper.getVisualFromRenderableIndex(startRenderableRow\
), \
this.instance.columnIndexMapper.getVisualFromRenderableIndex(startRenderableC\
olumn), \
this.instance.rowIndexMapper.getVisualFromRenderableIndex(endRenderableRow), \
this.instance.columnIndexMapper.getVisualFromRenderableIndex(endRenderableCol\
umn)];\n        return this.instance.runHooks(\"beforeDrawBorders\", \
visualCorners, borderClassName);\n      },\n      onBeforeTouchScroll: () => \
this.instance.runHooks(\"beforeTouchScroll\"),\n      onAfterMomentumScroll: \
() => this.instance.runHooks(\"afterMomentumScroll\"),\n      \
onBeforeStretchingColumnWidth: (stretchedWidth, renderedColumnIndex) => {\n   \
     const visualColumnIndex = \
this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIn\
dex);\n        return this.instance.runHooks(\"beforeStretchingColumnWidth\", \
stretchedWidth, visualColumnIndex);\n      },\n      onModifyRowHeaderWidth: \
(rowHeaderWidth) => this.instance.runHooks(\"modifyRowHeaderWidth\", \
rowHeaderWidth),\n      onModifyGetCellCoords: (renderableRowIndex, \
renderableColumnIndex, topmost) => {\n        const rowMapper = \
this.instance.rowIndexMapper;\n        const columnMapper = \
this.instance.columnIndexMapper;\n        const visualColumnIndex = \
renderableColumnIndex >= 0 ? \
columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : \
renderableColumnIndex;\n        const visualRowIndex = renderableRowIndex >= \
0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : \
renderableRowIndex;\n        const visualIndexes = \
this.instance.runHooks(\"modifyGetCellCoords\", visualRowIndex, \
visualColumnIndex, topmost);\n        if (Array.isArray(visualIndexes)) {\n   \
       const [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = \
visualIndexes;\n          return [visualRowFrom >= 0 ? \
rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(vis\
ualRowFrom, 1)) : visualRowFrom, visualColumnFrom >= 0 ? \
columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenInd\
ex(visualColumnFrom, 1)) : visualColumnFrom, visualRowTo >= 0 ? \
rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(vis\
ualRowTo, -1)) : visualRowTo, visualColumnTo >= 0 ? \
columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenInd\
ex(visualColumnTo, -1)) : visualColumnTo];\n        }\n      },\n      \
viewportRowCalculatorOverride: (calc) => {\n        let viewportOffset = \
this.settings.viewportRowRenderingOffset;\n        if (viewportOffset === \
\"auto\" && this.settings.fixedRowsTop) {\n          viewportOffset = 10;\n   \
     }\n        if (viewportOffset > 0 || viewportOffset === \"auto\") {\n    \
      const renderableRows = this.countRenderableRows();\n          const \
firstRenderedRow = calc.startRow;\n          const lastRenderedRow = \
calc.endRow;\n          if (typeof viewportOffset === \"number\") {\n         \
   calc.startRow = Math.max(firstRenderedRow - viewportOffset, 0);\n          \
  calc.endRow = Math.min(lastRenderedRow + viewportOffset, renderableRows - \
1);\n          } else if (viewportOffset === \"auto\") {\n            const \
offset3 = Math.ceil(lastRenderedRow / renderableRows * 12);\n            \
calc.startRow = Math.max(firstRenderedRow - offset3, 0);\n            \
calc.endRow = Math.min(lastRenderedRow + offset3, renderableRows - 1);\n      \
    }\n        }\n        \
this.instance.runHooks(\"afterViewportRowCalculatorOverride\", calc);\n      \
},\n      viewportColumnCalculatorOverride: (calc) => {\n        let \
viewportOffset = this.settings.viewportColumnRenderingOffset;\n        if \
(viewportOffset === \"auto\" && this.settings.fixedColumnsStart) {\n          \
viewportOffset = 10;\n        }\n        if (viewportOffset > 0 || \
viewportOffset === \"auto\") {\n          const renderableColumns = \
this.countRenderableColumns();\n          const firstRenderedColumn = \
calc.startColumn;\n          const lastRenderedColumn = calc.endColumn;\n     \
     if (typeof viewportOffset === \"number\") {\n            \
calc.startColumn = Math.max(firstRenderedColumn - viewportOffset, 0);\n       \
     calc.endColumn = Math.min(lastRenderedColumn + viewportOffset, \
renderableColumns - 1);\n          }\n          if (viewportOffset === \
\"auto\") {\n            const offset3 = Math.ceil(lastRenderedColumn / \
renderableColumns * 6);\n            calc.startColumn = \
Math.max(firstRenderedColumn - offset3, 0);\n            calc.endColumn = \
Math.min(lastRenderedColumn + offset3, renderableColumns - 1);\n          }\n \
       }\n        \
this.instance.runHooks(\"afterViewportColumnCalculatorOverride\", calc);\n    \
  },\n      rowHeaderWidth: () => this.settings.rowHeaderWidth,\n      \
columnHeaderHeight: () => {\n        const columnHeaderHeight = \
this.instance.runHooks(\"modifyColumnHeaderHeight\");\n        return \
this.settings.columnHeaderHeight || columnHeaderHeight;\n      }\n    };\n    \
this.instance.runHooks(\"beforeInitWalkontable\", walkontableConfig);\n    \
this._wt = new WalkontableFacade(walkontableConfig);\n    this.activeWt = \
this._wt;\n    const spreader = this._wt.wtTable.spreader;\n    const {\n     \
 width,\n      height\n    } = \
this.instance.rootElement.getBoundingClientRect();\n    \
this.setLastSize(width, height);\n    \
this.eventManager.addEventListener(spreader, \"mousedown\", (event2) => {\n   \
   if (event2.target === spreader && event2.which === 3) {\n        \
event2.stopPropagation();\n      }\n    });\n    \
this.eventManager.addEventListener(spreader, \"contextmenu\", (event2) => {\n \
     if (event2.target === spreader && event2.which === 3) {\n        \
event2.stopPropagation();\n      }\n    });\n    \
this.eventManager.addEventListener(this.instance.rootDocument.documentElement\
, \"click\", () => {\n      if (this.settings.observeDOMVisibility) {\n       \
 if (this._wt.drawInterrupted) {\n          this.instance.forceFullRender = \
true;\n          this.render();\n        }\n      }\n    });\n  }\n  /**\n   \
* Checks if it's possible to create text selection in element.\n   *\n   * \
@private\n   * @param {HTMLElement} el The element to check.\n   * @returns \
{boolean}\n   */\n  isTextSelectionAllowed(el) {\n    if (isInput(el)) {\n    \
  return true;\n    }\n    const isChildOfTableBody = isChildOf(el, \
this.instance.view._wt.wtTable.spreader);\n    if \
(this.settings.fragmentSelection === true && isChildOfTableBody) {\n      \
return true;\n    }\n    if (this.settings.fragmentSelection === \"cell\" && \
this.isSelectedOnlyCell() && isChildOfTableBody) {\n      return true;\n    \
}\n    if (!this.settings.fragmentSelection && this.isCellEdited() && \
this.isSelectedOnlyCell()) {\n      return true;\n    }\n    return false;\n  \
}\n  /**\n   * Checks if user's been called mousedown.\n   *\n   * @private\n \
  * @returns {boolean}\n   */\n  isMouseDown() {\n    return \
privatePool4.get(this).mouseDown;\n  }\n  /**\n   * Check if selected only \
one cell.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  \
isSelectedOnlyCell() {\n    var _this$instance$getSel, \
_this$instance$getSel2;\n    return (_this$instance$getSel = \
(_this$instance$getSel2 = this.instance.getSelectedRangeLast()) === null || \
_this$instance$getSel2 === void 0 ? void 0 : \
_this$instance$getSel2.isSingle()) !== null && _this$instance$getSel !== void \
0 ? _this$instance$getSel : false;\n  }\n  /**\n   * Checks if active cell is \
editing.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  \
isCellEdited() {\n    const activeEditor = this.instance.getActiveEditor();\n \
   return activeEditor && activeEditor.isOpened();\n  }\n  /**\n   * \
`beforeDraw` callback.\n   *\n   * @private\n   * @param {boolean} force If \
`true` rendering was triggered by a change of settings or data or `false` \
if\n   *                        rendering was triggered by scrolling or \
moving selection.\n   * @param {object} skipRender Object with `skipRender` \
property, if it is set to `true ` the next rendering\n   *                    \
        cycle will be skipped.\n   */\n  beforeRender(force, skipRender) {\n  \
  if (force) {\n      this.instance.runHooks(\"beforeViewRender\", \
this.instance.forceFullRender, skipRender);\n    }\n  }\n  /**\n   * \
`afterRender` callback.\n   *\n   * @private\n   * @param {boolean} force If \
`true` rendering was triggered by a change of settings or data or `false` \
if\n   *                        rendering was triggered by scrolling or \
moving selection.\n   */\n  afterRender(force) {\n    if (force) {\n      \
this.instance.runHooks(\"afterViewRender\", this.instance.forceFullRender);\n \
   }\n  }\n  /**\n   * Append row header to a TH element.\n   *\n   * \
@private\n   * @param {number} visualRowIndex The visual row index.\n   * \
@param {HTMLTableHeaderCellElement} TH The table header element.\n   */\n  \
appendRowHeader(visualRowIndex, TH) {\n    if (TH.firstChild) {\n      const \
container = TH.firstChild;\n      if (!hasClass(container, \"relative\")) {\n \
       empty(TH);\n        this.appendRowHeader(visualRowIndex, TH);\n        \
return;\n      }\n      \
this.updateCellHeader(container.querySelector(\".rowHeader\"), \
visualRowIndex, this.instance.getRowHeader);\n    } else {\n      const {\n   \
     rootDocument,\n        getRowHeader\n      } = this.instance;\n      \
const div = rootDocument.createElement(\"div\");\n      const span = \
rootDocument.createElement(\"span\");\n      div.className = \"relative\";\n  \
    span.className = \"rowHeader\";\n      this.updateCellHeader(span, \
visualRowIndex, getRowHeader);\n      div.appendChild(span);\n      \
TH.appendChild(div);\n    }\n    \
this.instance.runHooks(\"afterGetRowHeader\", visualRowIndex, TH);\n  }\n  \
/**\n   * Append column header to a TH element.\n   *\n   * @private\n   * \
@param {number} visualColumnIndex Visual column index.\n   * @param \
{HTMLTableCellElement} TH The table header element.\n   * @param {Function} \
[label] The function that returns the header label.\n   * @param {number} \
[headerLevel=0] The index of header level counting from the top (positive\n   \
*                                 values counting from 0 to N).\n   */\n  \
appendColHeader(visualColumnIndex, TH) {\n    let label = arguments.length > \
2 && arguments[2] !== void 0 ? arguments[2] : this.instance.getColHeader;\n   \
 let headerLevel = arguments.length > 3 && arguments[3] !== void 0 ? \
arguments[3] : 0;\n    if (TH.firstChild) {\n      const container = \
TH.firstChild;\n      if (hasClass(container, \"relative\")) {\n        \
this.updateCellHeader(container.querySelector(\".colHeader\"), \
visualColumnIndex, label, headerLevel);\n      } else {\n        empty(TH);\n \
       this.appendColHeader(visualColumnIndex, TH, label, headerLevel);\n     \
 }\n    } else {\n      const {\n        rootDocument\n      } = \
this.instance;\n      const div = rootDocument.createElement(\"div\");\n      \
const span = rootDocument.createElement(\"span\");\n      div.className = \
\"relative\";\n      span.className = \"colHeader\";\n      \
this.updateCellHeader(span, visualColumnIndex, label, headerLevel);\n      \
div.appendChild(span);\n      TH.appendChild(div);\n    }\n    \
this.instance.runHooks(\"afterGetColHeader\", visualColumnIndex, TH, \
headerLevel);\n  }\n  /**\n   * Updates header cell content.\n   *\n   * \
@private\n   * @param {HTMLElement} element Element to update.\n   * @param \
{number} index Row index or column index.\n   * @param {Function} content \
Function which should be returns content for this cell.\n   * @param {number} \
[headerLevel=0] The index of header level counting from the top (positive\n   \
*                                 values counting from 0 to N).\n   */\n  \
updateCellHeader(element, index2, content) {\n    let headerLevel = \
arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n    let \
renderedIndex = index2;\n    const parentOverlay = \
this._wt.wtOverlays.getParentOverlay(element) || this._wt;\n    if \
(element.parentNode) {\n      if (hasClass(element, \"colHeader\")) {\n       \
 renderedIndex = \
parentOverlay.wtTable.columnFilter.sourceToRendered(index2);\n      } else if \
(hasClass(element, \"rowHeader\")) {\n        renderedIndex = \
parentOverlay.wtTable.rowFilter.sourceToRendered(index2);\n      }\n    }\n   \
 if (renderedIndex > -1) {\n      fastInnerHTML(element, content(index2, \
headerLevel));\n    } else {\n      fastInnerText(element, \
String.fromCharCode(160));\n      addClass(element, \"cornerHeader\");\n    \
}\n  }\n  /**\n   * Given a element's left (or right in RTL mode) position \
relative to the viewport, returns maximum\n   * element width until the right \
(or left) edge of the viewport (before scrollbar).\n   *\n   * @private\n   * \
@param {number} inlineOffset The left (or right in RTL mode) offset.\n   * \
@returns {number}\n   */\n  maximumVisibleElementWidth(inlineOffset) {\n    \
const workspaceWidth = this._wt.wtViewport.getWorkspaceWidth();\n    const \
maxWidth = workspaceWidth - inlineOffset;\n    return maxWidth > 0 ? maxWidth \
: 0;\n  }\n  /**\n   * Given a element's top position relative to the \
viewport, returns maximum element height until the bottom\n   * edge of the \
viewport (before scrollbar).\n   *\n   * @private\n   * @param {number} \
topOffset The top offset.\n   * @returns {number}\n   */\n  \
maximumVisibleElementHeight(topOffset) {\n    const workspaceHeight = \
this._wt.wtViewport.getWorkspaceHeight();\n    const maxHeight = \
workspaceHeight - topOffset;\n    return maxHeight > 0 ? maxHeight : 0;\n  \
}\n  /**\n   * Sets new dimensions of the container.\n   *\n   * @param \
{number} width The table width.\n   * @param {number} height The table \
height.\n   */\n  setLastSize(width, height) {\n    const priv = \
privatePool4.get(this);\n    [priv.lastWidth, priv.lastHeight] = [width, \
height];\n  }\n  /**\n   * Returns cached dimensions.\n   *\n   * @returns \
{object}\n   */\n  getLastSize() {\n    const priv = \
privatePool4.get(this);\n    return {\n      width: priv.lastWidth,\n      \
height: priv.lastHeight\n    };\n  }\n  /**\n   * Returns the first fully \
visible row in the table viewport.\n   *\n   * @returns {number}\n   */\n  \
getFirstFullyVisibleRow() {\n    return \
this.instance.rowIndexMapper.getVisualFromRenderableIndex(this.instance.view.\
_wt.wtScroll.getFirstVisibleRow());\n  }\n  /**\n   * Returns the last fully \
visible row in the table viewport.\n   *\n   * @returns {number}\n   */\n  \
getLastFullyVisibleRow() {\n    return \
this.instance.rowIndexMapper.getVisualFromRenderableIndex(this.instance.view.\
_wt.wtScroll.getLastVisibleRow());\n  }\n  /**\n   * Returns the first fully \
visible column in the table viewport.\n   *\n   * @returns {number}\n   */\n  \
getFirstFullyVisibleColumn() {\n    return \
this.instance.columnIndexMapper.getVisualFromRenderableIndex(this.instance.vi\
ew._wt.wtScroll.getFirstVisibleColumn());\n  }\n  /**\n   * Returns the last \
fully visible column in the table viewport.\n   *\n   * @returns {number}\n   \
*/\n  getLastFullyVisibleColumn() {\n    return \
this.instance.columnIndexMapper.getVisualFromRenderableIndex(this.instance.vi\
ew._wt.wtScroll.getLastVisibleColumn());\n  }\n  /**\n   * Returns the total \
count of the rendered column headers.\n   *\n   * @returns {number}\n   */\n  \
getColumnHeadersCount() {\n    return _classPrivateFieldGet3(this, \
_columnHeadersCount);\n  }\n  /**\n   * Returns the total count of the \
rendered row headers.\n   *\n   * @returns {number}\n   */\n  \
getRowHeadersCount() {\n    return _classPrivateFieldGet3(this, \
_rowHeadersCount);\n  }\n  /**\n   * Destroys internal WalkOnTable's \
instance. Detaches all of the bonded listeners.\n   *\n   * @private\n   */\n \
 destroy() {\n    this._wt.destroy();\n    this.eventManager.destroy();\n  \
}\n};\nvar tableView_default = TableView;\n\n// \
node_modules/handsontable/helpers/data.mjs\nvar data_exports = \
{};\n__export(data_exports, {\n  countFirstRowKeys: () => \
countFirstRowKeys,\n  createEmptySpreadsheetData: () => \
createEmptySpreadsheetData,\n  createSpreadsheetData: () => \
createSpreadsheetData,\n  createSpreadsheetObjectData: () => \
createSpreadsheetObjectData,\n  dataRowToChangesArray: () => \
dataRowToChangesArray,\n  isArrayOfArrays: () => isArrayOfArrays,\n  \
isArrayOfObjects: () => isArrayOfObjects,\n  spreadsheetColumnIndex: () => \
spreadsheetColumnIndex,\n  spreadsheetColumnLabel: () => \
spreadsheetColumnLabel\n});\nvar COLUMN_LABEL_BASE = \
\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nvar COLUMN_LABEL_BASE_LENGTH = \
COLUMN_LABEL_BASE.length;\nfunction spreadsheetColumnLabel(index2) {\n  let \
dividend = index2 + 1;\n  let columnLabel = \"\";\n  let modulo;\n  while \
(dividend > 0) {\n    modulo = (dividend - 1) % COLUMN_LABEL_BASE_LENGTH;\n   \
 columnLabel = String.fromCharCode(65 + modulo) + columnLabel;\n    dividend \
= parseInt((dividend - modulo) / COLUMN_LABEL_BASE_LENGTH, 10);\n  }\n  \
return columnLabel;\n}\nfunction spreadsheetColumnIndex(label) {\n  let \
result = 0;\n  if (label) {\n    for (let i = 0, j = label.length - 1; i < \
label.length; i += 1, j -= 1) {\n      result += COLUMN_LABEL_BASE_LENGTH ** \
j * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);\n    }\n  }\n  result -= 1;\n  \
return result;\n}\nfunction createSpreadsheetData() {\n  let rows = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;\n  let \
columns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
4;\n  const _rows = [];\n  let i;\n  let j;\n  for (i = 0; i < rows; i++) {\n \
   const row = [];\n    for (j = 0; j < columns; j++) {\n      \
row.push(spreadsheetColumnLabel(j) + (i + 1));\n    }\n    _rows.push(row);\n \
 }\n  return _rows;\n}\nfunction createSpreadsheetObjectData() {\n  let rows \
= arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;\n  \
let colCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] \
: 4;\n  const _rows = [];\n  let i;\n  let j;\n  for (i = 0; i < rows; i++) \
{\n    const row = {};\n    for (j = 0; j < colCount; j++) {\n      \
row[`prop${j}`] = spreadsheetColumnLabel(j) + (i + 1);\n    }\n    \
_rows.push(row);\n  }\n  return _rows;\n}\nfunction \
createEmptySpreadsheetData(rows, columns) {\n  const data2 = [];\n  let \
row;\n  for (let i = 0; i < rows; i++) {\n    row = [];\n    for (let j = 0; \
j < columns; j++) {\n      row.push(\"\");\n    }\n    data2.push(row);\n  \
}\n  return data2;\n}\nfunction dataRowToChangesArray(dataRow) {\n  let \
rowOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
0;\n  let dataRows = dataRow;\n  const changesArray = [];\n  if \
(!Array.isArray(dataRow) || !Array.isArray(dataRow[0])) {\n    dataRows = \
[dataRow];\n  }\n  dataRows.forEach((row, rowIndex) => {\n    if \
(Array.isArray(row)) {\n      row.forEach((value, column) => {\n        \
changesArray.push([rowIndex + rowOffset, column, value]);\n      });\n    } \
else {\n      Object.keys(row).forEach((propName) => {\n        \
changesArray.push([rowIndex + rowOffset, propName, row[propName]]);\n      \
});\n    }\n  });\n  return changesArray;\n}\nfunction \
countFirstRowKeys(data2) {\n  let result = 0;\n  if (Array.isArray(data2)) \
{\n    if (data2[0] && Array.isArray(data2[0])) {\n      result = \
data2[0].length;\n    } else if (data2[0] && isObject(data2[0])) {\n      \
result = deepObjectSize(data2[0]);\n    }\n  }\n  return result;\n}\nfunction \
isArrayOfArrays(data2) {\n  return !!(Array.isArray(data2) && data2.length && \
data2.every((el) => Array.isArray(el)));\n}\nfunction isArrayOfObjects(data2) \
{\n  return !!(Array.isArray(data2) && data2.length && data2.every((el) => \
typeof el === \"object\" && !Array.isArray(el) && el !== null));\n}\n\n// \
node_modules/handsontable/dataMap/dataSource.mjs\nvar DataSource = class {\n  \
constructor(hotInstance) {\n    let dataSource = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : [];\n    this.hot = hotInstance;\n   \
 this.data = dataSource;\n    this.dataType = \"array\";\n    this.colToProp \
= () => {\n    };\n    this.propToCol = () => {\n    };\n  }\n  /**\n   * Run \
the `modifyRowData` hook and return either the modified or the source data \
for the provided row.\n   *\n   * @private\n   * @param {number} rowIndex Row \
index.\n   * @returns {Array|object} Source or modified row of data.\n   */\n \
 modifyRowData(rowIndex) {\n    let modifyRowData;\n    if \
(this.hot.hasHook(\"modifyRowData\")) {\n      modifyRowData = \
this.hot.runHooks(\"modifyRowData\", rowIndex);\n    }\n    return \
modifyRowData !== void 0 && !Number.isInteger(modifyRowData) ? modifyRowData \
: this.data[rowIndex];\n  }\n  /**\n   * Get all data.\n   *\n   * @param \
{boolean} [toArray=false] If `true` return source data as an array of arrays \
even when source data was provided\n   *                                  in \
another format.\n   * @returns {Array}\n   */\n  getData() {\n    let toArray \
= arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n   \
 if (!this.data || this.data.length === 0) {\n      return this.data;\n    \
}\n    return this.getByRange(null, null, toArray);\n  }\n  /**\n   * Set new \
data source.\n   *\n   * @param {Array} data The new data.\n   */\n  \
setData(data2) {\n    this.data = data2;\n  }\n  /**\n   * Returns array of \
column values from the data source. `column` is the index of the row in the \
data source.\n   *\n   * @param {number} column Visual column index.\n   * \
@returns {Array}\n   */\n  getAtColumn(column) {\n    const result = [];\n    \
arrayEach(this.data, (row, rowIndex) => {\n      const value = \
this.getAtCell(rowIndex, column);\n      result.push(value);\n    });\n    \
return result;\n  }\n  /**\n   * Returns a single row of the data or a subset \
of its columns. If a column range or `toArray` arguments are provided, it\n   \
* operates only on the columns declared by the `columns` setting or the data \
schema.\n   *\n   * @param {number} row Physical row index.\n   * @param \
{number} [startColumn] Starting index for the column range (optional).\n   * \
@param {number} [endColumn] Ending index for the column range (optional).\n   \
* @param {boolean} [toArray=false] `true` if the returned value should be \
forced to be presented as an array.\n   * @returns {Array|object}\n   */\n  \
getAtRow(row, startColumn, endColumn) {\n    let toArray = arguments.length > \
3 && arguments[3] !== void 0 ? arguments[3] : false;\n    const getAllProps = \
startColumn === void 0 && endColumn === void 0;\n    let dataRow = null;\n    \
let newDataRow = null;\n    dataRow = this.modifyRowData(row);\n    if \
(Array.isArray(dataRow)) {\n      newDataRow = [];\n      if (getAllProps) \
{\n        dataRow.forEach((cell, column) => {\n          newDataRow[column] \
= this.getAtPhysicalCell(row, column, dataRow);\n        });\n      } else \
{\n        rangeEach(startColumn, endColumn, (column) => {\n          \
newDataRow[column - startColumn] = this.getAtPhysicalCell(row, column, \
dataRow);\n        });\n      }\n    } else if (isObject(dataRow) || \
isFunction(dataRow)) {\n      if (toArray) {\n        newDataRow = [];\n      \
} else {\n        newDataRow = {};\n      }\n      if (!getAllProps || \
toArray) {\n        const rangeStart = 0;\n        const rangeEnd = \
this.countFirstRowKeys() - 1;\n        rangeEach(rangeStart, rangeEnd, \
(column) => {\n          const prop = this.colToProp(column);\n          if \
(column >= (startColumn || rangeStart) && column <= (endColumn || rangeEnd) \
&& !Number.isInteger(prop)) {\n            const cellValue = \
this.getAtPhysicalCell(row, prop, dataRow);\n            if (toArray) {\n     \
         newDataRow.push(cellValue);\n            } else {\n              \
setProperty(newDataRow, prop, cellValue);\n            }\n          }\n       \
 });\n      } else {\n        objectEach(dataRow, (value, prop) => {\n        \
  setProperty(newDataRow, prop, this.getAtPhysicalCell(row, prop, \
dataRow));\n        });\n      }\n    }\n    return newDataRow;\n  }\n  /**\n \
  * Set the provided value in the source data set at the provided \
coordinates.\n   *\n   * @param {number} row Physical row index.\n   * @param \
{number|string} column Property name / physical column index.\n   * @param \
{*} value The value to be set at the provided coordinates.\n   */\n  \
setAtCell(row, column, value) {\n    if (row >= this.countRows() || column >= \
this.countFirstRowKeys()) {\n      return;\n    }\n    if \
(this.hot.hasHook(\"modifySourceData\")) {\n      const valueHolder = \
createObjectPropListener(value);\n      \
this.hot.runHooks(\"modifySourceData\", row, column, valueHolder, \"set\");\n \
     if (valueHolder.isTouched()) {\n        value = valueHolder.value;\n     \
 }\n    }\n    if (!Number.isInteger(column)) {\n      \
setProperty(this.data[row], column, value);\n    } else {\n      \
this.data[row][column] = value;\n    }\n  }\n  /**\n   * Get data from the \
source data set using the physical indexes.\n   *\n   * @private\n   * @param \
{number} row Physical row index.\n   * @param {string|number|Function} column \
Physical column index / property / function.\n   * @param {Array|object} \
dataRow A representation of a data row.\n   * @returns {*} Value at the \
provided coordinates.\n   */\n  getAtPhysicalCell(row, column, dataRow) {\n   \
 let result = null;\n    if (dataRow) {\n      if (typeof column === \
\"string\") {\n        result = getProperty(dataRow, column);\n      } else \
if (typeof column === \"function\") {\n        result = column(dataRow);\n    \
  } else {\n        result = dataRow[column];\n      }\n    }\n    if \
(this.hot.hasHook(\"modifySourceData\")) {\n      const valueHolder = \
createObjectPropListener(result);\n      \
this.hot.runHooks(\"modifySourceData\", row, column, valueHolder, \"get\");\n \
     if (valueHolder.isTouched()) {\n        result = valueHolder.value;\n    \
  }\n    }\n    return result;\n  }\n  /**\n   * Returns a single value from \
the data.\n   *\n   * @param {number} row Physical row index.\n   * @param \
{number} columnOrProp Visual column index or property.\n   * @returns {*}\n   \
*/\n  getAtCell(row, columnOrProp) {\n    const dataRow = \
this.modifyRowData(row);\n    return this.getAtPhysicalCell(row, \
this.colToProp(columnOrProp), dataRow);\n  }\n  /**\n   * Returns source data \
by passed range.\n   *\n   * @param {object} [start] Object with physical \
`row` and `col` keys (or visual column index, if data type is an array of \
objects).\n   * @param {object} [end] Object with physical `row` and `col` \
keys (or visual column index, if data type is an array of objects).\n   * \
@param {boolean} [toArray=false] If `true` return source data as an array of \
arrays even when source data was provided\n   *                               \
   in another format.\n   * @returns {Array}\n   */\n  getByRange() {\n    \
let start = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
null;\n    let end = arguments.length > 1 && arguments[1] !== void 0 ? \
arguments[1] : null;\n    let toArray = arguments.length > 2 && arguments[2] \
!== void 0 ? arguments[2] : false;\n    let getAllProps = false;\n    let \
startRow = null;\n    let startCol = null;\n    let endRow = null;\n    let \
endCol = null;\n    if (start === null || end === null) {\n      getAllProps \
= true;\n      startRow = 0;\n      endRow = this.countRows() - 1;\n    } \
else {\n      startRow = Math.min(start.row, end.row);\n      startCol = \
Math.min(start.col, end.col);\n      endRow = Math.max(start.row, end.row);\n \
     endCol = Math.max(start.col, end.col);\n    }\n    const result = [];\n  \
  rangeEach(startRow, endRow, (currentRow) => {\n      \
result.push(getAllProps ? this.getAtRow(currentRow, void 0, void 0, toArray) \
: this.getAtRow(currentRow, startCol, endCol, toArray));\n    });\n    return \
result;\n  }\n  /**\n   * Count number of rows.\n   *\n   * @returns \
{number}\n   */\n  countRows() {\n    if \
(this.hot.hasHook(\"modifySourceLength\")) {\n      const \
modifiedSourceLength = this.hot.runHooks(\"modifySourceLength\");\n      if \
(Number.isInteger(modifiedSourceLength)) {\n        return \
modifiedSourceLength;\n      }\n    }\n    return this.data.length;\n  }\n  \
/**\n   * Count number of columns.\n   *\n   * @returns {number}\n   */\n  \
countFirstRowKeys() {\n    return countFirstRowKeys(this.data);\n  }\n  /**\n \
  * Destroy instance.\n   */\n  destroy() {\n    this.data = null;\n    \
this.hot = null;\n  }\n};\nvar dataSource_default = DataSource;\n\n// \
node_modules/handsontable/mixins/localHooks.mjs\nvar MIXIN_NAME6 = \
\"localHooks\";\nvar localHooks = {\n  /**\n   * Internal hooks storage.\n   \
*/\n  _localHooks: /* @__PURE__ */ Object.create(null),\n  /**\n   * Add hook \
to the collection.\n   *\n   * @param {string} key The hook name.\n   * \
@param {Function} callback The hook callback.\n   * @returns {object}\n   \
*/\n  addLocalHook(key, callback) {\n    if (!this._localHooks[key]) {\n      \
this._localHooks[key] = [];\n    }\n    \
this._localHooks[key].push(callback);\n    return this;\n  },\n  /**\n   * \
Run hooks.\n   *\n   * @param {string} key The name of the hook to run.\n   * \
@param {*} [arg1] An additional parameter passed to the callback function.\n  \
 * @param {*} [arg2] An additional parameter passed to the callback \
function.\n   * @param {*} [arg3] An additional parameter passed to the \
callback function.\n   * @param {*} [arg4] An additional parameter passed to \
the callback function.\n   * @param {*} [arg5] An additional parameter passed \
to the callback function.\n   * @param {*} [arg6] An additional parameter \
passed to the callback function.\n   */\n  runLocalHooks(key, arg1, arg2, \
arg3, arg4, arg5, arg6) {\n    if (this._localHooks[key]) {\n      const \
length = this._localHooks[key].length;\n      for (let i = 0; i < length; \
i++) {\n        fastCall(this._localHooks[key][i], this, arg1, arg2, arg3, \
arg4, arg5, arg6);\n      }\n    }\n  },\n  /**\n   * Clear all added \
hooks.\n   *\n   * @returns {object}\n   */\n  clearLocalHooks() {\n    \
this._localHooks = {};\n    return this;\n  }\n};\ndefineGetter(localHooks, \
\"MIXIN_NAME\", MIXIN_NAME6, {\n  writable: false,\n  enumerable: \
false\n});\nvar localHooks_default = localHooks;\n\n// \
node_modules/handsontable/translations/maps/indexMap.mjs\nvar IndexMap = \
class {\n  constructor() {\n    let initValueOrFn = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : null;\n    this.indexedValues = \
[];\n    this.initValueOrFn = initValueOrFn;\n  }\n  /**\n   * Get full list \
of values for particular indexes.\n   *\n   * @returns {Array}\n   */\n  \
getValues() {\n    return this.indexedValues;\n  }\n  /**\n   * Get value for \
the particular index.\n   *\n   * @param {number} index Index for which value \
is got.\n   * @returns {*}\n   */\n  getValueAtIndex(index2) {\n    const \
values = this.indexedValues;\n    if (index2 < values.length) {\n      return \
values[index2];\n    }\n  }\n  /**\n   * Set new values for particular \
indexes.\n   *\n   * Note: Please keep in mind that `change` hook triggered \
by the method may not update cache of a collection immediately.\n   *\n   * \
@param {Array} values List of set values.\n   */\n  setValues(values) {\n    \
this.indexedValues = values.slice();\n    this.runLocalHooks(\"change\");\n  \
}\n  /**\n   * Set new value for the particular index.\n   *\n   * @param \
{number} index The index.\n   * @param {*} value The value to save.\n   *\n   \
* Note: Please keep in mind that it is not possible to set value beyond the \
map (not respecting already set\n   * map's size). Please use the `setValues` \
method when you would like to extend the map.\n   * Note: Please keep in mind \
that `change` hook triggered by the method may not update cache of a \
collection immediately.\n   *\n   * @returns {boolean}\n   */\n  \
setValueAtIndex(index2, value) {\n    if (index2 < this.indexedValues.length) \
{\n      this.indexedValues[index2] = value;\n      \
this.runLocalHooks(\"change\");\n      return true;\n    }\n    return \
false;\n  }\n  /**\n   * Clear all values to the defaults.\n   */\n  clear() \
{\n    this.setDefaultValues();\n  }\n  /**\n   * Get length of the index \
map.\n   *\n   * @returns {number}\n   */\n  getLength() {\n    return \
this.getValues().length;\n  }\n  /**\n   * Set default values for elements \
from `0` to `n`, where `n` is equal to the handled variable.\n   *\n   * \
Note: Please keep in mind that `change` hook triggered by the method may not \
update cache of a collection immediately.\n   *\n   * @private\n   * @param \
{number} [length] Length of list.\n   */\n  setDefaultValues() {\n    let \
length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
this.indexedValues.length;\n    this.indexedValues.length = 0;\n    if \
(isFunction(this.initValueOrFn)) {\n      rangeEach(length - 1, (index2) => \
this.indexedValues.push(this.initValueOrFn(index2)));\n    } else {\n      \
rangeEach(length - 1, () => this.indexedValues.push(this.initValueOrFn));\n   \
 }\n    this.runLocalHooks(\"change\");\n  }\n  /**\n   * Initialize list \
with default values for particular indexes.\n   *\n   * @private\n   * @param \
{number} length New length of indexed list.\n   * @returns {IndexMap}\n   \
*/\n  init(length) {\n    this.setDefaultValues(length);\n    \
this.runLocalHooks(\"init\");\n    return this;\n  }\n  /**\n   * Add values \
to the list.\n   *\n   * Note: Please keep in mind that `change` hook \
triggered by the method may not update cache of a collection immediately.\n   \
*\n   * @private\n   */\n  insert() {\n    this.runLocalHooks(\"change\");\n  \
}\n  /**\n   * Remove values from the list.\n   *\n   * Note: Please keep in \
mind that `change` hook triggered by the method may not update cache of a \
collection immediately.\n   *\n   * @private\n   */\n  remove() {\n    \
this.runLocalHooks(\"change\");\n  }\n  /**\n   * Destroys the Map \
instance.\n   */\n  destroy() {\n    this.clearLocalHooks();\n    \
this.indexedValues = null;\n    this.initValueOrFn = null;\n  \
}\n};\nmixin(IndexMap, localHooks_default);\n\n// \
node_modules/handsontable/translations/maps/utils/physicallyIndexed.mjs\nfunc\
tion getListWithInsertedItems(indexedValues, insertionIndex, insertedIndexes, \
insertedValuesMapping) {\n  const firstInsertedIndex = insertedIndexes.length \
? insertedIndexes[0] : void 0;\n  return [...indexedValues.slice(0, \
firstInsertedIndex), ...insertedIndexes.map((insertedIndex, ordinalNumber) => \
{\n    if (isFunction(insertedValuesMapping)) {\n      return \
insertedValuesMapping(insertedIndex, ordinalNumber);\n    }\n    return \
insertedValuesMapping;\n  }), ...firstInsertedIndex === void 0 ? [] : \
indexedValues.slice(firstInsertedIndex)];\n}\nfunction \
getListWithRemovedItems(indexedValues, removedIndexes) {\n  return \
arrayFilter(indexedValues, (_, index2) => removedIndexes.includes(index2) === \
false);\n}\n\n// \
node_modules/handsontable/translations/maps/physicalIndexToValueMap.mjs\nvar \
PhysicalIndexToValueMap = class extends IndexMap {\n  /**\n   * Add values to \
list and reorganize.\n   *\n   * @private\n   * @param {number} \
insertionIndex Position inside the list.\n   * @param {Array} insertedIndexes \
List of inserted indexes.\n   */\n  insert(insertionIndex, insertedIndexes) \
{\n    this.indexedValues = getListWithInsertedItems(this.indexedValues, \
insertionIndex, insertedIndexes, this.initValueOrFn);\n    \
super.insert(insertionIndex, insertedIndexes);\n  }\n  /**\n   * Remove \
values from the list and reorganize.\n   *\n   * @private\n   * @param \
{Array} removedIndexes List of removed indexes.\n   */\n  \
remove(removedIndexes) {\n    this.indexedValues = \
getListWithRemovedItems(this.indexedValues, removedIndexes);\n    \
super.remove(removedIndexes);\n  }\n};\n\n// \
node_modules/handsontable/translations/maps/hidingMap.mjs\nvar HidingMap = \
class extends PhysicalIndexToValueMap {\n  constructor() {\n    let \
initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : false;\n    super(initValueOrFn);\n  }\n  /**\n   * Get \
physical indexes which are hidden.\n   *\n   * Note: Indexes marked as hidden \
are included in a {@link DataMap}, but aren't rendered.\n   *\n   * @returns \
{Array}\n   */\n  getHiddenIndexes() {\n    return \
arrayReduce(this.getValues(), (indexesList, isHidden, physicalIndex) => {\n   \
   if (isHidden) {\n        indexesList.push(physicalIndex);\n      }\n      \
return indexesList;\n    }, []);\n  }\n};\n\n// \
node_modules/handsontable/translations/maps/utils/indexesSequence.mjs\nfuncti\
on getListWithInsertedItems2(indexedValues, insertionIndex, insertedIndexes) \
{\n  return [...indexedValues.slice(0, insertionIndex), ...insertedIndexes, \
...indexedValues.slice(insertionIndex)];\n}\nfunction \
getListWithRemovedItems2(indexedValues, removedIndexes) {\n  return \
arrayFilter(indexedValues, (index2) => {\n    return \
removedIndexes.includes(index2) === false;\n  });\n}\n\n// \
node_modules/handsontable/translations/maps/utils/actionsOnIndexes.mjs\nfunct\
ion getDecreasedIndexes(indexedValues, removedIndexes) {\n  return \
arrayMap(indexedValues, (index2) => index2 - \
removedIndexes.filter((removedIndex) => removedIndex < \
index2).length);\n}\nfunction getIncreasedIndexes(indexedValues, \
insertedIndexes) {\n  const firstInsertedIndex = insertedIndexes[0];\n  const \
amountOfIndexes = insertedIndexes.length;\n  return arrayMap(indexedValues, \
(index2) => {\n    if (index2 >= firstInsertedIndex) {\n      return index2 + \
amountOfIndexes;\n    }\n    return index2;\n  });\n}\n\n// \
node_modules/handsontable/translations/maps/linkedPhysicalIndexToValueMap.mjs\
\nfunction _defineProperty14(obj, key, value) {\n  key = \
_toPropertyKey14(key);\n  if (key in obj) {\n    Object.defineProperty(obj, \
key, { value, enumerable: true, configurable: true, writable: true });\n  } \
else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction \
_toPropertyKey14(arg) {\n  var key = _toPrimitive14(arg, \"string\");\n  \
return typeof key === \"symbol\" ? key : String(key);\n}\nfunction \
_toPrimitive14(input, hint) {\n  if (typeof input !== \"object\" || input === \
null)\n    return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim \
!== void 0) {\n    var res = prim.call(input, hint || \"default\");\n    if \
(typeof res !== \"object\")\n      return res;\n    throw new \
TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return \
(hint === \"string\" ? String : Number)(input);\n}\nvar \
LinkedPhysicalIndexToValueMap = class extends IndexMap {\n  constructor() {\n \
   super(...arguments);\n    _defineProperty14(this, \"orderOfIndexes\", \
[]);\n  }\n  /**\n   * Get full list of ordered values for particular \
indexes.\n   *\n   * @returns {Array}\n   */\n  getValues() {\n    return \
this.orderOfIndexes.map((physicalIndex) => \
this.indexedValues[physicalIndex]);\n  }\n  /**\n   * Set new values for \
particular indexes. Entries are linked and stored in a certain order.\n   *\n \
  * Note: Please keep in mind that `change` hook triggered by the method may \
not update cache of a collection immediately.\n   *\n   * @param {Array} \
values List of set values.\n   */\n  setValues(values) {\n    \
this.orderOfIndexes = [...Array(values.length).keys()];\n    \
super.setValues(values);\n  }\n  /**\n   * Set value at index and add it to \
the linked list of entries. Entries are stored in a certain order.\n   *\n   \
* Note: Value will be added at the end of the queue.\n   *\n   * @param \
{number} index The index.\n   * @param {*} value The value to save.\n   * \
@param {number} position Position to which entry will be added.\n   *\n   * \
@returns {boolean}\n   */\n  setValueAtIndex(index2, value) {\n    let \
position = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \
this.orderOfIndexes.length;\n    if (index2 < this.indexedValues.length) {\n  \
    this.indexedValues[index2] = value;\n      if \
(this.orderOfIndexes.includes(index2) === false) {\n        \
this.orderOfIndexes.splice(position, 0, index2);\n      }\n      \
this.runLocalHooks(\"change\");\n      return true;\n    }\n    return \
false;\n  }\n  /**\n   * Clear value for particular index.\n   *\n   * @param \
{number} physicalIndex Physical index.\n   */\n  clearValue(physicalIndex) \
{\n    this.orderOfIndexes = getListWithRemovedItems2(this.orderOfIndexes, \
[physicalIndex]);\n    if (isFunction(this.initValueOrFn)) {\n      \
super.setValueAtIndex(physicalIndex, this.initValueOrFn(physicalIndex));\n    \
} else {\n      super.setValueAtIndex(physicalIndex, this.initValueOrFn);\n   \
 }\n  }\n  /**\n   * Get length of the index map.\n   *\n   * @returns \
{number}\n   */\n  getLength() {\n    return this.orderOfIndexes.length;\n  \
}\n  /**\n   * Set default values for elements from `0` to `n`, where `n` is \
equal to the handled variable.\n   *\n   * Note: Please keep in mind that \
`change` hook triggered by the method may not update cache of a collection \
immediately.\n   *\n   * @private\n   * @param {number} [length] Length of \
list.\n   */\n  setDefaultValues() {\n    let length = arguments.length > 0 \
&& arguments[0] !== void 0 ? arguments[0] : this.indexedValues.length;\n    \
this.orderOfIndexes.length = 0;\n    super.setDefaultValues(length);\n  }\n  \
/**\n   * Add values to list and reorganize. It updates list of indexes \
related to ordered values.\n   *\n   * @private\n   * @param {number} \
insertionIndex Position inside the list.\n   * @param {Array} insertedIndexes \
List of inserted indexes.\n   */\n  insert(insertionIndex, insertedIndexes) \
{\n    this.indexedValues = getListWithInsertedItems(this.indexedValues, \
insertionIndex, insertedIndexes, this.initValueOrFn);\n    \
this.orderOfIndexes = getIncreasedIndexes(this.orderOfIndexes, \
insertedIndexes);\n    super.insert(insertionIndex, insertedIndexes);\n  }\n  \
/**\n   * Remove values from the list and reorganize. It updates list of \
indexes related to ordered values.\n   *\n   * @private\n   * @param {Array} \
removedIndexes List of removed indexes.\n   */\n  remove(removedIndexes) {\n  \
  this.indexedValues = getListWithRemovedItems(this.indexedValues, \
removedIndexes);\n    this.orderOfIndexes = \
getListWithRemovedItems2(this.orderOfIndexes, removedIndexes);\n    \
this.orderOfIndexes = getDecreasedIndexes(this.orderOfIndexes, \
removedIndexes);\n    super.remove(removedIndexes);\n  }\n  /**\n   * Get \
every entry containing index and value, respecting order of indexes.\n   *\n  \
 * @returns {Array}\n   */\n  getEntries() {\n    return \
this.orderOfIndexes.map((physicalIndex) => [physicalIndex, \
this.getValueAtIndex(physicalIndex)]);\n  }\n};\n\n// \
node_modules/handsontable/translations/maps/trimmingMap.mjs\nvar TrimmingMap \
= class extends PhysicalIndexToValueMap {\n  constructor() {\n    let \
initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : false;\n    super(initValueOrFn);\n  }\n  /**\n   * Get \
physical indexes which are trimmed.\n   *\n   * Note: Indexes marked as \
trimmed aren't included in a {@link DataMap} and aren't rendered.\n   *\n   * \
@returns {Array}\n   */\n  getTrimmedIndexes() {\n    return \
arrayReduce(this.getValues(), (indexesList, isTrimmed, physicalIndex) => {\n  \
    if (isTrimmed) {\n        indexesList.push(physicalIndex);\n      }\n     \
 return indexesList;\n    }, []);\n  }\n};\n\n// \
node_modules/handsontable/translations/maps/utils/index.mjs\nvar \
alterStrategies = /* @__PURE__ */ new Map([[\"indexesSequence\", {\n  \
getListWithInsertedItems: getListWithInsertedItems2,\n  \
getListWithRemovedItems: getListWithRemovedItems2\n}], \
[\"physicallyIndexed\", {\n  getListWithInsertedItems,\n  \
getListWithRemovedItems\n}]]);\nvar alterUtilsFactory = (indexationStrategy) \
=> {\n  if (alterStrategies.has(indexationStrategy) === false) {\n    throw \
new Error(`Alter strategy with ID '${indexationStrategy}' does not \
exist.`);\n  }\n  return alterStrategies.get(indexationStrategy);\n};\n\n// \
node_modules/handsontable/translations/maps/indexesSequence.mjs\nvar \
IndexesSequence = class extends IndexMap {\n  constructor() {\n    \
super((index2) => index2);\n  }\n  /**\n   * Add values to list and \
reorganize.\n   *\n   * @private\n   * @param {number} insertionIndex \
Position inside the list.\n   * @param {Array} insertedIndexes List of \
inserted indexes.\n   */\n  insert(insertionIndex, insertedIndexes) {\n    \
const listAfterUpdate = getIncreasedIndexes(this.indexedValues, \
insertedIndexes);\n    this.indexedValues = \
getListWithInsertedItems2(listAfterUpdate, insertionIndex, \
insertedIndexes);\n    super.insert(insertionIndex, insertedIndexes);\n  }\n  \
/**\n   * Remove values from the list and reorganize.\n   *\n   * @private\n  \
 * @param {Array} removedIndexes List of removed indexes.\n   */\n  \
remove(removedIndexes) {\n    const listAfterUpdate = \
getListWithRemovedItems2(this.indexedValues, removedIndexes);\n    \
this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);\n  \
  super.remove(removedIndexes);\n  }\n};\n\n// \
node_modules/handsontable/translations/maps/index.mjs\nvar \
availableIndexMapTypes = /* @__PURE__ */ new Map([[\"hiding\", HidingMap], \
[\"index\", IndexMap], [\"linkedPhysicalIndexToValue\", \
LinkedPhysicalIndexToValueMap], [\"physicalIndexToValue\", \
PhysicalIndexToValueMap], [\"trimming\", TrimmingMap]]);\nfunction \
createIndexMap(mapType) {\n  let initValueOrFn = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : null;\n  if \
(!availableIndexMapTypes.has(mapType)) {\n    throw new Error(`The provided \
map type (\"${mapType}\") does not exist.`);\n  }\n  return new \
(availableIndexMapTypes.get(mapType))(initValueOrFn);\n}\n\n// \
node_modules/handsontable/translations/mapCollections/mapCollection.mjs\nvar \
registeredMaps = 0;\nvar MapCollection = class {\n  constructor() {\n    \
this.collection = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Register \
custom index map.\n   *\n   * @param {string} uniqueName Unique name of the \
index map.\n   * @param {IndexMap} indexMap Index map containing \
miscellaneous (i.e. Meta data, indexes sequence), updated after remove and \
insert data actions.\n   */\n  register(uniqueName, indexMap) {\n    if \
(this.collection.has(uniqueName) === false) {\n      \
this.collection.set(uniqueName, indexMap);\n      \
indexMap.addLocalHook(\"change\", () => this.runLocalHooks(\"change\", \
indexMap));\n      registeredMaps += 1;\n    }\n  }\n  /**\n   * Unregister \
custom index map.\n   *\n   * @param {string} name Name of the index map.\n   \
*/\n  unregister(name) {\n    const indexMap = this.collection.get(name);\n   \
 if (isDefined(indexMap)) {\n      indexMap.destroy();\n      \
this.collection.delete(name);\n      this.runLocalHooks(\"change\", \
indexMap);\n      registeredMaps -= 1;\n    }\n  }\n  /**\n   * Unregisters \
and destroys all collected index map instances.\n   */\n  unregisterAll() {\n \
   this.collection.forEach((indexMap, name) => this.unregister(name));\n    \
this.collection.clear();\n  }\n  /**\n   * Get index map for the provided \
name.\n   *\n   * @param {string} [name] Name of the index map.\n   * \
@returns {Array|IndexMap}\n   */\n  get(name) {\n    if (isUndefined(name)) \
{\n      return Array.from(this.collection.values());\n    }\n    return \
this.collection.get(name);\n  }\n  /**\n   * Get collection size.\n   *\n   * \
@returns {number}\n   */\n  getLength() {\n    return this.collection.size;\n \
 }\n  /**\n   * Remove some indexes and corresponding mappings and update \
values of the others within all collection's index maps.\n   *\n   * \
@private\n   * @param {Array} removedIndexes List of removed indexes.\n   \
*/\n  removeFromEvery(removedIndexes) {\n    \
this.collection.forEach((indexMap) => {\n      \
indexMap.remove(removedIndexes);\n    });\n  }\n  /**\n   * Insert new \
indexes and corresponding mapping and update values of the others all \
collection's index maps.\n   *\n   * @private\n   * @param {number} \
insertionIndex Position inside the actual list.\n   * @param {Array} \
insertedIndexes List of inserted indexes.\n   */\n  \
insertToEvery(insertionIndex, insertedIndexes) {\n    \
this.collection.forEach((indexMap) => {\n      \
indexMap.insert(insertionIndex, insertedIndexes);\n    });\n  }\n  /**\n   * \
Set default values to index maps within collection.\n   *\n   * @param \
{number} length Destination length for all stored maps.\n   */\n  \
initEvery(length) {\n    this.collection.forEach((indexMap) => {\n      \
indexMap.init(length);\n    });\n  }\n};\nmixin(MapCollection, \
localHooks_default);\nfunction getRegisteredMapsCounter() {\n  return \
registeredMaps;\n}\n\n// \
node_modules/handsontable/translations/mapCollections/aggregatedCollection.mj\
s\nvar AggregatedCollection = class extends MapCollection {\n  \
constructor(aggregationFunction, fallbackValue) {\n    super();\n    \
this.mergedValuesCache = [];\n    this.aggregationFunction = \
aggregationFunction;\n    this.fallbackValue = fallbackValue;\n  }\n  /**\n   \
* Get merged values for all indexes.\n   *\n   * @param {boolean} \
[readFromCache=true] Determine if read results from the cache.\n   * @returns \
{Array}\n   */\n  getMergedValues() {\n    let readFromCache = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n    \
if (readFromCache === true) {\n      return this.mergedValuesCache;\n    }\n  \
  if (this.getLength() === 0) {\n      return [];\n    }\n    const \
mapsValuesMatrix = arrayMap(this.get(), (map) => map.getValues());\n    const \
indexesValuesMatrix = [];\n    const mapsLength = \
isDefined(mapsValuesMatrix[0]) && mapsValuesMatrix[0].length || 0;\n    for \
(let index2 = 0; index2 < mapsLength; index2 += 1) {\n      const \
valuesForIndex = [];\n      for (let mapIndex = 0; mapIndex < \
this.getLength(); mapIndex += 1) {\n        \
valuesForIndex.push(mapsValuesMatrix[mapIndex][index2]);\n      }\n      \
indexesValuesMatrix.push(valuesForIndex);\n    }\n    return \
arrayMap(indexesValuesMatrix, this.aggregationFunction);\n  }\n  /**\n   * \
Get merged value for particular index.\n   *\n   * @param {number} index \
Index for which we calculate single result.\n   * @param {boolean} \
[readFromCache=true] Determine if read results from the cache.\n   * @returns \
{*}\n   */\n  getMergedValueAtIndex(index2, readFromCache) {\n    const \
valueAtIndex = this.getMergedValues(readFromCache)[index2];\n    return \
isDefined(valueAtIndex) ? valueAtIndex : this.fallbackValue;\n  }\n  /**\n   \
* Rebuild cache for the collection.\n   */\n  updateCache() {\n    \
this.mergedValuesCache = this.getMergedValues(false);\n  }\n};\n\n// \
node_modules/handsontable/translations/changesObservable/observer.mjs\nfuncti\
on _classPrivateFieldInitSpec4(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration4(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration4(obj, privateCollection) {\n  \
if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_classPrivateFieldSet4(receiver, privateMap, value) {\n  var descriptor = \
_classExtractFieldDescriptor4(receiver, privateMap, \"set\");\n  \
_classApplyDescriptorSet4(receiver, descriptor, value);\n  return \
value;\n}\nfunction _classApplyDescriptorSet4(receiver, descriptor, value) \
{\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } \
else {\n    if (!descriptor.writable) {\n      throw new \
TypeError(\"attempted to set read only private field\");\n    }\n    \
descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet4(receiver, \
privateMap) {\n  var descriptor = _classExtractFieldDescriptor4(receiver, \
privateMap, \"get\");\n  return _classApplyDescriptorGet4(receiver, \
descriptor);\n}\nfunction _classExtractFieldDescriptor4(receiver, privateMap, \
action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorGet4(receiver, descriptor) {\n  if (descriptor.get) {\n  \
  return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nvar _currentInitialChanges = /* @__PURE__ */ new \
WeakMap();\nvar ChangesObserver = class {\n  constructor() {\n    \
_classPrivateFieldInitSpec4(this, _currentInitialChanges, {\n      writable: \
true,\n      value: []\n    });\n  }\n  /**\n   * Subscribes to the \
observer.\n   *\n   * @param {Function} callback A function that will be \
called when the new changes will appear.\n   * @returns {ChangesObserver}\n   \
*/\n  subscribe(callback) {\n    this.addLocalHook(\"change\", callback);\n   \
 this._write(_classPrivateFieldGet4(this, _currentInitialChanges));\n    \
return this;\n  }\n  /**\n   * Unsubscribes all subscriptions. After the \
method call, the observer would not produce\n   * any new events.\n   *\n   * \
@returns {ChangesObserver}\n   */\n  unsubscribe() {\n    \
this.runLocalHooks(\"unsubscribe\");\n    this.clearLocalHooks();\n    return \
this;\n  }\n  /**\n   * The write method is executed by the ChangesObservable \
module. The module produces all\n   * changes events that are distributed \
further by the observer.\n   *\n   * @private\n   * @param {object} changes \
The chunk of changes produced by the ChangesObservable module.\n   * @returns \
{ChangesObserver}\n   */\n  _write(changes) {\n    if (changes.length > 0) \
{\n      this.runLocalHooks(\"change\", changes);\n    }\n    return this;\n  \
}\n  /**\n   * The write method is executed by the ChangesObservable module. \
The module produces initial\n   * changes that will be used to notify new \
subscribers.\n   *\n   * @private\n   * @param {object} initialChanges The \
chunk of changes produced by the ChangesObservable module.\n   */\n  \
_writeInitialChanges(initialChanges) {\n    _classPrivateFieldSet4(this, \
_currentInitialChanges, initialChanges);\n  }\n};\nmixin(ChangesObserver, \
localHooks_default);\n\n// \
node_modules/handsontable/translations/changesObservable/utils.mjs\nfunction \
arrayDiff(baseArray, newArray) {\n  const changes = [];\n  let i = 0;\n  let \
j = 0;\n  for (; i < baseArray.length && j < newArray.length; i++, j++) {\n   \
 if (baseArray[i] !== newArray[j]) {\n      changes.push({\n        op: \
\"replace\",\n        index: j,\n        oldValue: baseArray[i],\n        \
newValue: newArray[j]\n      });\n    }\n  }\n  for (; i < newArray.length; \
i++) {\n    changes.push({\n      op: \"insert\",\n      index: i,\n      \
oldValue: void 0,\n      newValue: newArray[i]\n    });\n  }\n  for (; j < \
baseArray.length; j++) {\n    changes.push({\n      op: \"remove\",\n      \
index: j,\n      oldValue: baseArray[j],\n      newValue: void 0\n    });\n  \
}\n  return changes;\n}\n\n// \
node_modules/handsontable/translations/changesObservable/observable.mjs\nfunc\
tion _classPrivateFieldInitSpec5(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration5(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration5(obj, privateCollection) {\n  \
if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_classPrivateFieldGet5(receiver, privateMap) {\n  var descriptor = \
_classExtractFieldDescriptor5(receiver, privateMap, \"get\");\n  return \
_classApplyDescriptorGet5(receiver, descriptor);\n}\nfunction \
_classApplyDescriptorGet5(receiver, descriptor) {\n  if (descriptor.get) {\n  \
  return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nfunction _classPrivateFieldSet5(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor5(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet5(receiver, descriptor, \
value);\n  return value;\n}\nfunction _classExtractFieldDescriptor5(receiver, \
privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorSet5(receiver, descriptor, value) {\n  if \
(descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n   \
 if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set \
read only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\nvar _observers = /* @__PURE__ */ new WeakMap();\nvar _indexMatrix = /* \
@__PURE__ */ new WeakMap();\nvar _currentIndexState = /* @__PURE__ */ new \
WeakMap();\nvar _isMatrixIndexesInitialized = /* @__PURE__ */ new \
WeakMap();\nvar _initialIndexValue = /* @__PURE__ */ new WeakMap();\nvar \
ChangesObservable = class {\n  constructor() {\n    let {\n      \
initialIndexValue\n    } = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : {};\n    _classPrivateFieldInitSpec5(this, _observers, {\n     \
 writable: true,\n      value: /* @__PURE__ */ new Set()\n    });\n    \
_classPrivateFieldInitSpec5(this, _indexMatrix, {\n      writable: true,\n    \
  value: []\n    });\n    _classPrivateFieldInitSpec5(this, \
_currentIndexState, {\n      writable: true,\n      value: []\n    });\n    \
_classPrivateFieldInitSpec5(this, _isMatrixIndexesInitialized, {\n      \
writable: true,\n      value: false\n    });\n    \
_classPrivateFieldInitSpec5(this, _initialIndexValue, {\n      writable: \
true,\n      value: false\n    });\n    _classPrivateFieldSet5(this, \
_initialIndexValue, initialIndexValue !== null && initialIndexValue !== void \
0 ? initialIndexValue : false);\n  }\n  /* eslint-disable \
jsdoc/require-description-complete-sentence */\n  /**\n   * Creates and \
returns a new instance of the ChangesObserver object. The resource\n   * \
allows subscribing to the index changes that during the code running may \
change.\n   * Changes are emitted as an array of the index change. Each \
change is represented\n   * separately as an object with `op`, `index`, \
`oldValue`, and `newValue` props.\n   *\n   * For example:\n   * ```\n   * \
[\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   * \
  { op: 'replace', index: 3, oldValue: false, newValue: true },\n   *   { op: \
'insert', index: 4, oldValue: false, newValue: true },\n   * ]\n   * // or \
when the new index map changes have less indexes\n   * [\n   *   { op: \
'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: \
'remove', index: 4, oldValue: false, newValue: true },\n   * ]\n   * ```\n   \
*\n   * @returns {ChangesObserver}\n   */\n  /* eslint-enable \
jsdoc/require-description-complete-sentence */\n  createObserver() {\n    \
const observer = new ChangesObserver();\n    _classPrivateFieldGet5(this, \
_observers).add(observer);\n    observer.addLocalHook(\"unsubscribe\", () => \
{\n      _classPrivateFieldGet5(this, _observers).delete(observer);\n    \
});\n    observer._writeInitialChanges(arrayDiff(_classPrivateFieldGet5(this, \
_indexMatrix), _classPrivateFieldGet5(this, _currentIndexState)));\n    \
return observer;\n  }\n  /**\n   * The method is an entry point for \
triggering new index map changes. Emitting the\n   * changes triggers \
comparing algorithm which compares last saved state with a new\n   * state. \
When there are some differences, the changes are sent to all subscribers.\n   \
*\n   * @param {Array} indexesState An array with index map state.\n   */\n  \
emit(indexesState) {\n    let currentIndexState = \
_classPrivateFieldGet5(this, _currentIndexState);\n    if \
(!_classPrivateFieldGet5(this, _isMatrixIndexesInitialized) || \
_classPrivateFieldGet5(this, _indexMatrix).length !== indexesState.length) \
{\n      if (indexesState.length === 0) {\n        indexesState = new \
Array(currentIndexState.length).fill(_classPrivateFieldGet5(this, \
_initialIndexValue));\n      } else {\n        _classPrivateFieldSet5(this, \
_indexMatrix, new \
Array(indexesState.length).fill(_classPrivateFieldGet5(this, \
_initialIndexValue)));\n      }\n      if (!_classPrivateFieldGet5(this, \
_isMatrixIndexesInitialized)) {\n        _classPrivateFieldSet5(this, \
_isMatrixIndexesInitialized, true);\n        currentIndexState = \
_classPrivateFieldGet5(this, _indexMatrix);\n      }\n    }\n    const \
changes = arrayDiff(currentIndexState, indexesState);\n    \
_classPrivateFieldGet5(this, _observers).forEach((observer) => \
observer._write(changes));\n    _classPrivateFieldSet5(this, \
_currentIndexState, indexesState);\n  }\n};\n\n// \
node_modules/handsontable/translations/indexMapper.mjs\nvar IndexMapper = \
class {\n  constructor() {\n    this.indexesSequence = new \
IndexesSequence();\n    this.trimmingMapsCollection = new \
AggregatedCollection((valuesForIndex) => valuesForIndex.some((value) => value \
=== true), false);\n    this.hidingMapsCollection = new \
AggregatedCollection((valuesForIndex) => valuesForIndex.some((value) => value \
=== true), false);\n    this.variousMapsCollection = new MapCollection();\n   \
 this.hidingChangesObservable = new ChangesObservable({\n      \
initialIndexValue: false\n    });\n    this.notTrimmedIndexesCache = [];\n    \
this.notHiddenIndexesCache = [];\n    this.isBatched = false;\n    \
this.indexesSequenceChanged = false;\n    this.indexesChangeSource = void \
0;\n    this.trimmedIndexesChanged = false;\n    this.hiddenIndexesChanged = \
false;\n    this.renderablePhysicalIndexesCache = [];\n    \
this.fromPhysicalToVisualIndexesCache = /* @__PURE__ */ new Map();\n    \
this.fromVisualToRenderableIndexesCache = /* @__PURE__ */ new Map();\n    \
this.indexesSequence.addLocalHook(\"change\", () => {\n      \
this.indexesSequenceChanged = true;\n      this.updateCache();\n      \
this.runLocalHooks(\"indexesSequenceChange\", this.indexesChangeSource);\n    \
  this.runLocalHooks(\"change\", this.indexesSequence, null);\n    });\n    \
this.trimmingMapsCollection.addLocalHook(\"change\", (changedMap) => {\n      \
this.trimmedIndexesChanged = true;\n      this.updateCache();\n      \
this.runLocalHooks(\"change\", changedMap, this.trimmingMapsCollection);\n    \
});\n    this.hidingMapsCollection.addLocalHook(\"change\", (changedMap) => \
{\n      this.hiddenIndexesChanged = true;\n      this.updateCache();\n      \
this.runLocalHooks(\"change\", changedMap, this.hidingMapsCollection);\n    \
});\n    this.variousMapsCollection.addLocalHook(\"change\", (changedMap) => \
{\n      this.runLocalHooks(\"change\", changedMap, \
this.variousMapsCollection);\n    });\n  }\n  /**\n   * Suspends the cache \
update for this map. The method is helpful to group multiple\n   * \
operations, which affects the cache. In this case, the cache will be updated \
once after\n   * calling the `resumeOperations` method.\n   */\n  \
suspendOperations() {\n    this.isBatched = true;\n  }\n  /**\n   * Resumes \
the cache update for this map. It recalculates the cache and restores the\n   \
* default behavior where each map modification updates the cache.\n   */\n  \
resumeOperations() {\n    this.isBatched = false;\n    this.updateCache();\n  \
}\n  /**\n   * It creates and returns the new instance of the ChangesObserver \
object. The object\n   * allows listening to the index changes that happen \
while the Handsontable is running.\n   *\n   * @param {string} indexMapType \
The index map type which we want to observe.\n   *                            \
  Currently, only the 'hiding' index map types are observable.\n   * @returns \
{ChangesObserver}\n   */\n  createChangesObserver(indexMapType) {\n    if \
(indexMapType !== \"hiding\") {\n      throw new Error(`Unsupported index map \
type \"${indexMapType}\".`);\n    }\n    return \
this.hidingChangesObservable.createObserver();\n  }\n  /**\n   * Creates and \
registers a new `IndexMap` for a specified `IndexMapper` instance.\n   *\n   \
* @param {string} indexName A unique index name.\n   * @param {string} \
mapType The index map type (e.g., \"hiding\", \"trimming\", \
\"physicalIndexToValue\").\n   * @param {*} [initValueOrFn] The initial value \
for the index map.\n   * @returns {IndexMap}\n   */\n  \
createAndRegisterIndexMap(indexName, mapType, initValueOrFn) {\n    return \
this.registerMap(indexName, createIndexMap(mapType, initValueOrFn));\n  }\n  \
/**\n   * Register map which provide some index mappings. Type of map \
determining to which collection it will be added.\n   *\n   * @param {string} \
uniqueName Name of the index map. It should be unique.\n   * @param \
{IndexMap} indexMap Registered index map updated on items removal and \
insertion.\n   * @returns {IndexMap}\n   */\n  registerMap(uniqueName, \
indexMap) {\n    if (this.trimmingMapsCollection.get(uniqueName) || \
this.hidingMapsCollection.get(uniqueName) || \
this.variousMapsCollection.get(uniqueName)) {\n      throw Error(`Map with \
name \"${uniqueName}\" has been already registered.`);\n    }\n    if \
(indexMap instanceof TrimmingMap) {\n      \
this.trimmingMapsCollection.register(uniqueName, indexMap);\n    } else if \
(indexMap instanceof HidingMap) {\n      \
this.hidingMapsCollection.register(uniqueName, indexMap);\n    } else {\n     \
 this.variousMapsCollection.register(uniqueName, indexMap);\n    }\n    const \
numberOfIndexes = this.getNumberOfIndexes();\n    if (numberOfIndexes > 0) \
{\n      indexMap.init(numberOfIndexes);\n    }\n    return indexMap;\n  }\n  \
/**\n   * Unregister a map with given name.\n   *\n   * @param {string} name \
Name of the index map.\n   */\n  unregisterMap(name) {\n    \
this.trimmingMapsCollection.unregister(name);\n    \
this.hidingMapsCollection.unregister(name);\n    \
this.variousMapsCollection.unregister(name);\n  }\n  /**\n   * Unregisters \
all collected index map instances from all map collection types.\n   */\n  \
unregisterAll() {\n    this.trimmingMapsCollection.unregisterAll();\n    \
this.hidingMapsCollection.unregisterAll();\n    \
this.variousMapsCollection.unregisterAll();\n  }\n  /**\n   * Get a physical \
index corresponding to the given visual index.\n   *\n   * @param {number} \
visualIndex Visual index.\n   * @returns {number|null} Returns translated \
index mapped by passed visual index.\n   */\n  \
getPhysicalFromVisualIndex(visualIndex) {\n    const physicalIndex = \
this.notTrimmedIndexesCache[visualIndex];\n    if (isDefined(physicalIndex)) \
{\n      return physicalIndex;\n    }\n    return null;\n  }\n  /**\n   * Get \
a physical index corresponding to the given renderable index.\n   *\n   * \
@param {number} renderableIndex Renderable index.\n   * @returns \
{null|number}\n   */\n  getPhysicalFromRenderableIndex(renderableIndex) {\n   \
 const physicalIndex = \
this.renderablePhysicalIndexesCache[renderableIndex];\n    if \
(isDefined(physicalIndex)) {\n      return physicalIndex;\n    }\n    return \
null;\n  }\n  /**\n   * Get a visual index corresponding to the given \
physical index.\n   *\n   * @param {number} physicalIndex Physical index to \
search.\n   * @returns {number|null} Returns a visual index of the index \
mapper.\n   */\n  getVisualFromPhysicalIndex(physicalIndex) {\n    const \
visualIndex = this.fromPhysicalToVisualIndexesCache.get(physicalIndex);\n    \
if (isDefined(visualIndex)) {\n      return visualIndex;\n    }\n    return \
null;\n  }\n  /**\n   * Get a visual index corresponding to the given \
renderable index.\n   *\n   * @param {number} renderableIndex Renderable \
index.\n   * @returns {null|number}\n   */\n  \
getVisualFromRenderableIndex(renderableIndex) {\n    return \
this.getVisualFromPhysicalIndex(this.getPhysicalFromRenderableIndex(renderabl\
eIndex));\n  }\n  /**\n   * Get a renderable index corresponding to the given \
visual index.\n   *\n   * @param {number} visualIndex Visual index.\n   * \
@returns {null|number}\n   */\n  getRenderableFromVisualIndex(visualIndex) \
{\n    const renderableIndex = \
this.fromVisualToRenderableIndexesCache.get(visualIndex);\n    if \
(isDefined(renderableIndex)) {\n      return renderableIndex;\n    }\n    \
return null;\n  }\n  /**\n   * Search for the nearest not-hidden row or \
column.\n   *\n   * @param {number} fromVisualIndex The visual index of the \
row or column from which the search starts.<br><br>\n   * If the row or \
column from which the search starts is not hidden, the method simply returns \
the `fromVisualIndex` number.\n   * @param {number} searchDirection The \
search direction.<br><br>`1`: search from `fromVisualIndex` to the end of the \
dataset.<br><br>\n   * `-1`: search from `fromVisualIndex` to the beginning \
of the dataset (i.e., to the row or column at visual index `0`).\n   * @param \
{boolean} searchAlsoOtherWayAround `true`: if a search in a first direction \
failed, try the opposite direction.<br><br>\n   * `false`: search in one \
direction only.\n   *\n   * @returns {number|null} A visual index of a row or \
column, or `null`.\n   */\n  getNearestNotHiddenIndex(fromVisualIndex, \
searchDirection) {\n    let searchAlsoOtherWayAround = arguments.length > 2 \
&& arguments[2] !== void 0 ? arguments[2] : false;\n    const physicalIndex = \
this.getPhysicalFromVisualIndex(fromVisualIndex);\n    if (physicalIndex === \
null) {\n      return null;\n    }\n    if \
(this.fromVisualToRenderableIndexesCache.has(fromVisualIndex)) {\n      \
return fromVisualIndex;\n    }\n    const visibleIndexes = \
Array.from(this.fromVisualToRenderableIndexesCache.keys());\n    let index2 = \
-1;\n    if (searchDirection > 0) {\n      index2 = \
visibleIndexes.findIndex((visualIndex) => visualIndex > fromVisualIndex);\n   \
 } else {\n      index2 = visibleIndexes.reverse().findIndex((visualIndex) => \
visualIndex < fromVisualIndex);\n    }\n    if (index2 === -1) {\n      if \
(searchAlsoOtherWayAround) {\n        return \
this.getNearestNotHiddenIndex(fromVisualIndex, -searchDirection, false);\n    \
  }\n      return null;\n    }\n    return visibleIndexes[index2];\n  }\n  \
/**\n   * Set default values for all indexes in registered index maps.\n   \
*\n   * @param {number} [length] Destination length for all stored index \
maps.\n   */\n  initToLength() {\n    let length = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : this.getNumberOfIndexes();\n    \
this.notTrimmedIndexesCache = [...new Array(length).keys()];\n    \
this.notHiddenIndexesCache = [...new Array(length).keys()];\n    \
this.suspendOperations();\n    this.indexesChangeSource = \"init\";\n    \
this.indexesSequence.init(length);\n    this.indexesChangeSource = void 0;\n  \
  this.trimmingMapsCollection.initEvery(length);\n    \
this.resumeOperations();\n    this.suspendOperations();\n    \
this.hidingMapsCollection.initEvery(length);\n    \
this.variousMapsCollection.initEvery(length);\n    this.resumeOperations();\n \
   this.runLocalHooks(\"init\");\n  }\n  /**\n   * Trim/extend the mappers to \
fit the desired length.\n   *\n   * @param {number} length New mapper \
length.\n   */\n  fitToLength(length) {\n    const currentIndexCount = \
this.getNumberOfIndexes();\n    if (length < currentIndexCount) {\n      \
const indexesToBeRemoved = [...Array(this.getNumberOfIndexes() - \
length).keys()].map((i) => i + length);\n      \
this.removeIndexes(indexesToBeRemoved);\n    } else {\n      \
this.insertIndexes(currentIndexCount, length - currentIndexCount);\n    }\n  \
}\n  /**\n   * Get sequence of indexes.\n   *\n   * @returns {Array} Physical \
indexes.\n   */\n  getIndexesSequence() {\n    return \
this.indexesSequence.getValues();\n  }\n  /**\n   * Set completely new \
indexes sequence.\n   *\n   * @param {Array} indexes Physical indexes.\n   \
*/\n  setIndexesSequence(indexes) {\n    if (this.indexesChangeSource === \
void 0) {\n      this.indexesChangeSource = \"update\";\n    }\n    \
this.indexesSequence.setValues(indexes);\n    if (this.indexesChangeSource \
=== \"update\") {\n      this.indexesChangeSource = void 0;\n    }\n  }\n  \
/**\n   * Get all NOT trimmed indexes.\n   *\n   * Note: Indexes marked as \
trimmed aren't included in a {@link DataMap} and aren't rendered.\n   *\n   * \
@param {boolean} [readFromCache=true] Determine if read indexes from cache.\n \
  * @returns {Array} List of physical indexes. Index of this native array is \
a \"visual index\",\n   * value of this native array is a \"physical \
index\".\n   */\n  getNotTrimmedIndexes() {\n    let readFromCache = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n    \
if (readFromCache === true) {\n      return this.notTrimmedIndexesCache;\n    \
}\n    const indexesSequence = this.getIndexesSequence();\n    return \
indexesSequence.filter((physicalIndex) => this.isTrimmed(physicalIndex) === \
false);\n  }\n  /**\n   * Get length of all NOT trimmed indexes.\n   *\n   * \
Note: Indexes marked as trimmed aren't included in a {@link DataMap} and \
aren't rendered.\n   *\n   * @returns {number}\n   */\n  \
getNotTrimmedIndexesLength() {\n    return \
this.getNotTrimmedIndexes().length;\n  }\n  /**\n   * Get all NOT hidden \
indexes.\n   *\n   * Note: Indexes marked as hidden are included in a {@link \
DataMap}, but aren't rendered.\n   *\n   * @param {boolean} \
[readFromCache=true] Determine if read indexes from cache.\n   * @returns \
{Array} List of physical indexes. Please keep in mind that index of this \
native array IS NOT a \"visual index\".\n   */\n  getNotHiddenIndexes() {\n   \
 let readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : true;\n    if (readFromCache === true) {\n      return \
this.notHiddenIndexesCache;\n    }\n    const indexesSequence = \
this.getIndexesSequence();\n    return indexesSequence.filter((physicalIndex) \
=> this.isHidden(physicalIndex) === false);\n  }\n  /**\n   * Get length of \
all NOT hidden indexes.\n   *\n   * Note: Indexes marked as hidden are \
included in a {@link DataMap}, but aren't rendered.\n   *\n   * @returns \
{number}\n   */\n  getNotHiddenIndexesLength() {\n    return \
this.getNotHiddenIndexes().length;\n  }\n  /**\n   * Get list of physical \
indexes (respecting the sequence of indexes) which may be rendered (when they \
are in a viewport).\n   *\n   * @param {boolean} [readFromCache=true] \
Determine if read indexes from cache.\n   * @returns {Array} List of physical \
indexes. Index of this native array is a \"renderable index\",\n   * value of \
this native array is a \"physical index\".\n   */\n  getRenderableIndexes() \
{\n    let readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : true;\n    if (readFromCache === true) {\n      return \
this.renderablePhysicalIndexesCache;\n    }\n    const notTrimmedIndexes = \
this.getNotTrimmedIndexes();\n    return \
notTrimmedIndexes.filter((physicalIndex) => this.isHidden(physicalIndex) === \
false);\n  }\n  /**\n   * Get length of all NOT trimmed and NOT hidden \
indexes.\n   *\n   * @returns {number}\n   */\n  getRenderableIndexesLength() \
{\n    return this.getRenderableIndexes().length;\n  }\n  /**\n   * Get \
number of all indexes.\n   *\n   * @returns {number}\n   */\n  \
getNumberOfIndexes() {\n    return this.getIndexesSequence().length;\n  }\n  \
/**\n   * Move indexes in the index mapper.\n   *\n   * @param {number|Array} \
movedIndexes Visual index(es) to move.\n   * @param {number} finalIndex \
Visual index being a start index for the moved elements.\n   */\n  \
moveIndexes(movedIndexes, finalIndex) {\n    if (typeof movedIndexes === \
\"number\") {\n      movedIndexes = [movedIndexes];\n    }\n    const \
physicalMovedIndexes = arrayMap(movedIndexes, (visualIndex) => \
this.getPhysicalFromVisualIndex(visualIndex));\n    const \
notTrimmedIndexesLength = this.getNotTrimmedIndexesLength();\n    const \
movedIndexesLength = movedIndexes.length;\n    const notMovedIndexes = \
getListWithRemovedItems2(this.getIndexesSequence(), physicalMovedIndexes);\n  \
  const notTrimmedNotMovedItems = notMovedIndexes.filter((index2) => \
this.isTrimmed(index2) === false);\n    let destinationPosition = \
notMovedIndexes.indexOf(notTrimmedNotMovedItems[notTrimmedNotMovedItems.lengt\
h - 1]) + 1;\n    if (finalIndex + movedIndexesLength < \
notTrimmedIndexesLength) {\n      const physicalIndex = \
notTrimmedNotMovedItems[finalIndex];\n      destinationPosition = \
notMovedIndexes.indexOf(physicalIndex);\n    }\n    this.indexesChangeSource \
= \"move\";\n    \
this.setIndexesSequence(getListWithInsertedItems2(notMovedIndexes, \
destinationPosition, physicalMovedIndexes));\n    this.indexesChangeSource = \
void 0;\n  }\n  /**\n   * Get whether index is trimmed. Index marked as \
trimmed isn't included in a {@link DataMap} and isn't rendered.\n   *\n   * \
@param {number} physicalIndex Physical index.\n   * @returns {boolean}\n   \
*/\n  isTrimmed(physicalIndex) {\n    return \
this.trimmingMapsCollection.getMergedValueAtIndex(physicalIndex);\n  }\n  \
/**\n   * Get whether index is hidden. Index marked as hidden is included in \
a {@link DataMap}, but isn't rendered.\n   *\n   * @param {number} \
physicalIndex Physical index.\n   * @returns {boolean}\n   */\n  \
isHidden(physicalIndex) {\n    return \
this.hidingMapsCollection.getMergedValueAtIndex(physicalIndex);\n  }\n  /**\n \
  * Insert new indexes and corresponding mapping and update values of the \
others, for all stored index maps.\n   *\n   * @private\n   * @param {number} \
firstInsertedVisualIndex First inserted visual index.\n   * @param {number} \
amountOfIndexes Amount of inserted indexes.\n   */\n  \
insertIndexes(firstInsertedVisualIndex, amountOfIndexes) {\n    const \
nthVisibleIndex = this.getNotTrimmedIndexes()[firstInsertedVisualIndex];\n    \
const firstInsertedPhysicalIndex = isDefined(nthVisibleIndex) ? \
nthVisibleIndex : this.getNumberOfIndexes();\n    const insertionIndex = \
this.getIndexesSequence().includes(nthVisibleIndex) ? \
this.getIndexesSequence().indexOf(nthVisibleIndex) : \
this.getNumberOfIndexes();\n    const insertedIndexes = arrayMap(new \
Array(amountOfIndexes).fill(firstInsertedPhysicalIndex), (nextIndex, \
stepsFromStart) => nextIndex + stepsFromStart);\n    \
this.suspendOperations();\n    this.indexesChangeSource = \"insert\";\n    \
this.indexesSequence.insert(insertionIndex, insertedIndexes);\n    \
this.indexesChangeSource = void 0;\n    \
this.trimmingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);\n \
   this.hidingMapsCollection.insertToEvery(insertionIndex, \
insertedIndexes);\n    \
this.variousMapsCollection.insertToEvery(insertionIndex, insertedIndexes);\n  \
  this.resumeOperations();\n  }\n  /**\n   * Remove some indexes and \
corresponding mappings and update values of the others, for all stored index \
maps.\n   *\n   * @private\n   * @param {Array} removedIndexes List of \
removed indexes.\n   */\n  removeIndexes(removedIndexes) {\n    \
this.suspendOperations();\n    this.indexesChangeSource = \"remove\";\n    \
this.indexesSequence.remove(removedIndexes);\n    this.indexesChangeSource = \
void 0;\n    this.trimmingMapsCollection.removeFromEvery(removedIndexes);\n   \
 this.hidingMapsCollection.removeFromEvery(removedIndexes);\n    \
this.variousMapsCollection.removeFromEvery(removedIndexes);\n    \
this.resumeOperations();\n  }\n  /**\n   * Rebuild cache for some indexes. \
Every action on indexes sequence or indexes skipped in the process of \
rendering\n   * by default reset cache, thus batching some index maps actions \
is recommended.\n   *\n   * @private\n   * @param {boolean} [force=false] \
Determine if force cache update.\n   */\n  updateCache() {\n    let force = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    \
const anyCachedIndexChanged = this.indexesSequenceChanged || \
this.trimmedIndexesChanged || this.hiddenIndexesChanged;\n    if (force === \
true || this.isBatched === false && anyCachedIndexChanged === true) {\n      \
this.trimmingMapsCollection.updateCache();\n      \
this.hidingMapsCollection.updateCache();\n      this.notTrimmedIndexesCache = \
this.getNotTrimmedIndexes(false);\n      this.notHiddenIndexesCache = \
this.getNotHiddenIndexes(false);\n      this.renderablePhysicalIndexesCache = \
this.getRenderableIndexes(false);\n      \
this.cacheFromPhysicalToVisualIndexes();\n      \
this.cacheFromVisualToRenderableIndexes();\n      if \
(this.hiddenIndexesChanged) {\n        \
this.hidingChangesObservable.emit(this.hidingMapsCollection.getMergedValues()\
);\n      }\n      this.runLocalHooks(\"cacheUpdated\", {\n        \
indexesSequenceChanged: this.indexesSequenceChanged,\n        \
trimmedIndexesChanged: this.trimmedIndexesChanged,\n        \
hiddenIndexesChanged: this.hiddenIndexesChanged\n      });\n      \
this.indexesSequenceChanged = false;\n      this.trimmedIndexesChanged = \
false;\n      this.hiddenIndexesChanged = false;\n    }\n  }\n  /**\n   * \
Update cache for translations from physical to visual indexes.\n   *\n   * \
@private\n   */\n  cacheFromPhysicalToVisualIndexes() {\n    const \
nrOfNotTrimmedIndexes = this.getNotTrimmedIndexesLength();\n    \
this.fromPhysicalToVisualIndexesCache.clear();\n    for (let visualIndex = 0; \
visualIndex < nrOfNotTrimmedIndexes; visualIndex += 1) {\n      const \
physicalIndex = this.getPhysicalFromVisualIndex(visualIndex);\n      \
this.fromPhysicalToVisualIndexesCache.set(physicalIndex, visualIndex);\n    \
}\n  }\n  /**\n   * Update cache for translations from visual to renderable \
indexes.\n   *\n   * @private\n   */\n  cacheFromVisualToRenderableIndexes() \
{\n    const nrOfRenderableIndexes = this.getRenderableIndexesLength();\n    \
this.fromVisualToRenderableIndexesCache.clear();\n    for (let \
renderableIndex = 0; renderableIndex < nrOfRenderableIndexes; renderableIndex \
+= 1) {\n      const physicalIndex = \
this.getPhysicalFromRenderableIndex(renderableIndex);\n      const \
visualIndex = this.getVisualFromPhysicalIndex(physicalIndex);\n      \
this.fromVisualToRenderableIndexesCache.set(visualIndex, renderableIndex);\n  \
  }\n  }\n};\nmixin(IndexMapper, localHooks_default);\n\n// \
node_modules/handsontable/i18n/utils.mjs\nfunction \
extendNotExistingKeys(target, extension) {\n  objectEach(extension, (value, \
key) => {\n    if (isUndefined(target[key])) {\n      target[key] = value;\n  \
  }\n  });\n  return target;\n}\nfunction normalizeLanguageCode(languageCode) \
{\n  const languageCodePattern = /^([a-zA-Z]{2})-([a-zA-Z]{2})$/;\n  const \
partsOfLanguageCode = languageCodePattern.exec(languageCode);\n  if \
(partsOfLanguageCode) {\n    return \
`${partsOfLanguageCode[1].toLowerCase()}-${partsOfLanguageCode[2].toUpperCase\
()}`;\n  }\n  return languageCode;\n}\nfunction \
warnUserAboutLanguageRegistration(languageCode) {\n  if \
(isDefined(languageCode)) {\n    error(toSingleLine`Language with code \
\"${languageCode}\" was not found. You should register particular \
language\\x20\n    before using it. Read more about this issue at: \
https://docs.handsontable.com/i18n/missing-language-code.`);\n  }\n}\n\n// \
node_modules/handsontable/i18n/phraseFormatters/pluralize.mjs\nfunction \
pluralize(phrasePropositions, pluralForm) {\n  const isPluralizable = \
Array.isArray(phrasePropositions) && Number.isInteger(pluralForm);\n  if \
(isPluralizable) {\n    return phrasePropositions[pluralForm];\n  }\n  return \
phrasePropositions;\n}\n\n// \
node_modules/handsontable/i18n/phraseFormatters/index.mjs\nvar {\n  register: \
registerGloballyPhraseFormatter,\n  getValues: getGlobalPhraseFormatters\n} = \
staticRegister(\"phraseFormatters\");\nfunction register4(name, formatterFn) \
{\n  registerGloballyPhraseFormatter(name, formatterFn);\n}\nfunction \
getAll() {\n  return \
getGlobalPhraseFormatters();\n}\nregister4(\"pluralize\", pluralize);\n\n// \
node_modules/handsontable/i18n/constants.mjs\nvar constants_exports = \
{};\n__export(constants_exports, {\n  CONTEXTMENU_ITEMS_ADD_COMMENT: () => \
CONTEXTMENU_ITEMS_ADD_COMMENT,\n  CONTEXTMENU_ITEMS_ALIGNMENT: () => \
CONTEXTMENU_ITEMS_ALIGNMENT,\n  CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM: () => \
CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM,\n  CONTEXTMENU_ITEMS_ALIGNMENT_CENTER: () \
=> CONTEXTMENU_ITEMS_ALIGNMENT_CENTER,\n  \
CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY: () => \
CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY,\n  CONTEXTMENU_ITEMS_ALIGNMENT_LEFT: () \
=> CONTEXTMENU_ITEMS_ALIGNMENT_LEFT,\n  CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE: \
() => CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE,\n  \
CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT: () => CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT,\n \
 CONTEXTMENU_ITEMS_ALIGNMENT_TOP: () => CONTEXTMENU_ITEMS_ALIGNMENT_TOP,\n  \
CONTEXTMENU_ITEMS_BORDERS: () => CONTEXTMENU_ITEMS_BORDERS,\n  \
CONTEXTMENU_ITEMS_BORDERS_BOTTOM: () => CONTEXTMENU_ITEMS_BORDERS_BOTTOM,\n  \
CONTEXTMENU_ITEMS_BORDERS_LEFT: () => CONTEXTMENU_ITEMS_BORDERS_LEFT,\n  \
CONTEXTMENU_ITEMS_BORDERS_RIGHT: () => CONTEXTMENU_ITEMS_BORDERS_RIGHT,\n  \
CONTEXTMENU_ITEMS_BORDERS_TOP: () => CONTEXTMENU_ITEMS_BORDERS_TOP,\n  \
CONTEXTMENU_ITEMS_CLEAR_COLUMN: () => CONTEXTMENU_ITEMS_CLEAR_COLUMN,\n  \
CONTEXTMENU_ITEMS_COPY: () => CONTEXTMENU_ITEMS_COPY,\n  \
CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY: () => \
CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY,\n  \
CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS: () => \
CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS,\n  \
CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS: () => \
CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS,\n  CONTEXTMENU_ITEMS_CUT: () => \
CONTEXTMENU_ITEMS_CUT,\n  CONTEXTMENU_ITEMS_EDIT_COMMENT: () => \
CONTEXTMENU_ITEMS_EDIT_COMMENT,\n  CONTEXTMENU_ITEMS_FREEZE_COLUMN: () => \
CONTEXTMENU_ITEMS_FREEZE_COLUMN,\n  CONTEXTMENU_ITEMS_HIDE_COLUMN: () => \
CONTEXTMENU_ITEMS_HIDE_COLUMN,\n  CONTEXTMENU_ITEMS_HIDE_ROW: () => \
CONTEXTMENU_ITEMS_HIDE_ROW,\n  CONTEXTMENU_ITEMS_INSERT_LEFT: () => \
CONTEXTMENU_ITEMS_INSERT_LEFT,\n  CONTEXTMENU_ITEMS_INSERT_RIGHT: () => \
CONTEXTMENU_ITEMS_INSERT_RIGHT,\n  CONTEXTMENU_ITEMS_MERGE_CELLS: () => \
CONTEXTMENU_ITEMS_MERGE_CELLS,\n  CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD: \
() => CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD,\n  \
CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD: () => \
CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD,\n  CONTEXTMENU_ITEMS_NO_ITEMS: () \
=> CONTEXTMENU_ITEMS_NO_ITEMS,\n  CONTEXTMENU_ITEMS_READ_ONLY: () => \
CONTEXTMENU_ITEMS_READ_ONLY,\n  CONTEXTMENU_ITEMS_READ_ONLY_COMMENT: () => \
CONTEXTMENU_ITEMS_READ_ONLY_COMMENT,\n  CONTEXTMENU_ITEMS_REDO: () => \
CONTEXTMENU_ITEMS_REDO,\n  CONTEXTMENU_ITEMS_REMOVE_BORDERS: () => \
CONTEXTMENU_ITEMS_REMOVE_BORDERS,\n  CONTEXTMENU_ITEMS_REMOVE_COLUMN: () => \
CONTEXTMENU_ITEMS_REMOVE_COLUMN,\n  CONTEXTMENU_ITEMS_REMOVE_COMMENT: () => \
CONTEXTMENU_ITEMS_REMOVE_COMMENT,\n  CONTEXTMENU_ITEMS_REMOVE_ROW: () => \
CONTEXTMENU_ITEMS_REMOVE_ROW,\n  CONTEXTMENU_ITEMS_ROW_ABOVE: () => \
CONTEXTMENU_ITEMS_ROW_ABOVE,\n  CONTEXTMENU_ITEMS_ROW_BELOW: () => \
CONTEXTMENU_ITEMS_ROW_BELOW,\n  CONTEXTMENU_ITEMS_SHOW_COLUMN: () => \
CONTEXTMENU_ITEMS_SHOW_COLUMN,\n  CONTEXTMENU_ITEMS_SHOW_ROW: () => \
CONTEXTMENU_ITEMS_SHOW_ROW,\n  CONTEXTMENU_ITEMS_UNDO: () => \
CONTEXTMENU_ITEMS_UNDO,\n  CONTEXTMENU_ITEMS_UNFREEZE_COLUMN: () => \
CONTEXTMENU_ITEMS_UNFREEZE_COLUMN,\n  CONTEXTMENU_ITEMS_UNMERGE_CELLS: () => \
CONTEXTMENU_ITEMS_UNMERGE_CELLS,\n  CONTEXT_MENU_ITEMS_NAMESPACE: () => \
CONTEXT_MENU_ITEMS_NAMESPACE,\n  FILTERS_BUTTONS_CANCEL: () => \
FILTERS_BUTTONS_CANCEL,\n  FILTERS_BUTTONS_CLEAR: () => \
FILTERS_BUTTONS_CLEAR,\n  FILTERS_BUTTONS_OK: () => FILTERS_BUTTONS_OK,\n  \
FILTERS_BUTTONS_PLACEHOLDER_SEARCH: () => \
FILTERS_BUTTONS_PLACEHOLDER_SEARCH,\n  \
FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE: () => \
FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE,\n  \
FILTERS_BUTTONS_PLACEHOLDER_VALUE: () => FILTERS_BUTTONS_PLACEHOLDER_VALUE,\n \
 FILTERS_BUTTONS_SELECT_ALL: () => FILTERS_BUTTONS_SELECT_ALL,\n  \
FILTERS_CONDITIONS_AFTER: () => FILTERS_CONDITIONS_AFTER,\n  \
FILTERS_CONDITIONS_BEFORE: () => FILTERS_CONDITIONS_BEFORE,\n  \
FILTERS_CONDITIONS_BEGINS_WITH: () => FILTERS_CONDITIONS_BEGINS_WITH,\n  \
FILTERS_CONDITIONS_BETWEEN: () => FILTERS_CONDITIONS_BETWEEN,\n  \
FILTERS_CONDITIONS_BY_VALUE: () => FILTERS_CONDITIONS_BY_VALUE,\n  \
FILTERS_CONDITIONS_CONTAINS: () => FILTERS_CONDITIONS_CONTAINS,\n  \
FILTERS_CONDITIONS_EMPTY: () => FILTERS_CONDITIONS_EMPTY,\n  \
FILTERS_CONDITIONS_ENDS_WITH: () => FILTERS_CONDITIONS_ENDS_WITH,\n  \
FILTERS_CONDITIONS_EQUAL: () => FILTERS_CONDITIONS_EQUAL,\n  \
FILTERS_CONDITIONS_GREATER_THAN: () => FILTERS_CONDITIONS_GREATER_THAN,\n  \
FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL: () => \
FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,\n  FILTERS_CONDITIONS_LESS_THAN: () \
=> FILTERS_CONDITIONS_LESS_THAN,\n  FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL: () \
=> FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,\n  FILTERS_CONDITIONS_NAMESPACE: () \
=> FILTERS_CONDITIONS_NAMESPACE,\n  FILTERS_CONDITIONS_NONE: () => \
FILTERS_CONDITIONS_NONE,\n  FILTERS_CONDITIONS_NOT_BETWEEN: () => \
FILTERS_CONDITIONS_NOT_BETWEEN,\n  FILTERS_CONDITIONS_NOT_CONTAIN: () => \
FILTERS_CONDITIONS_NOT_CONTAIN,\n  FILTERS_CONDITIONS_NOT_EMPTY: () => \
FILTERS_CONDITIONS_NOT_EMPTY,\n  FILTERS_CONDITIONS_NOT_EQUAL: () => \
FILTERS_CONDITIONS_NOT_EQUAL,\n  FILTERS_CONDITIONS_TODAY: () => \
FILTERS_CONDITIONS_TODAY,\n  FILTERS_CONDITIONS_TOMORROW: () => \
FILTERS_CONDITIONS_TOMORROW,\n  FILTERS_CONDITIONS_YESTERDAY: () => \
FILTERS_CONDITIONS_YESTERDAY,\n  FILTERS_DIVS_FILTER_BY_CONDITION: () => \
FILTERS_DIVS_FILTER_BY_CONDITION,\n  FILTERS_DIVS_FILTER_BY_VALUE: () => \
FILTERS_DIVS_FILTER_BY_VALUE,\n  FILTERS_LABELS_CONJUNCTION: () => \
FILTERS_LABELS_CONJUNCTION,\n  FILTERS_LABELS_DISJUNCTION: () => \
FILTERS_LABELS_DISJUNCTION,\n  FILTERS_NAMESPACE: () => FILTERS_NAMESPACE,\n  \
FILTERS_VALUES_BLANK_CELLS: () => FILTERS_VALUES_BLANK_CELLS\n});\nvar \
CONTEXT_MENU_ITEMS_NAMESPACE = \"ContextMenu:items\";\nvar CM_ALIAS = \
CONTEXT_MENU_ITEMS_NAMESPACE;\nvar CONTEXTMENU_ITEMS_NO_ITEMS = \
`${CM_ALIAS}.noItems`;\nvar CONTEXTMENU_ITEMS_ROW_ABOVE = \
`${CM_ALIAS}.insertRowAbove`;\nvar CONTEXTMENU_ITEMS_ROW_BELOW = \
`${CM_ALIAS}.insertRowBelow`;\nvar CONTEXTMENU_ITEMS_INSERT_LEFT = \
`${CM_ALIAS}.insertColumnOnTheLeft`;\nvar CONTEXTMENU_ITEMS_INSERT_RIGHT = \
`${CM_ALIAS}.insertColumnOnTheRight`;\nvar CONTEXTMENU_ITEMS_REMOVE_ROW = \
`${CM_ALIAS}.removeRow`;\nvar CONTEXTMENU_ITEMS_REMOVE_COLUMN = \
`${CM_ALIAS}.removeColumn`;\nvar CONTEXTMENU_ITEMS_UNDO = \
`${CM_ALIAS}.undo`;\nvar CONTEXTMENU_ITEMS_REDO = `${CM_ALIAS}.redo`;\nvar \
CONTEXTMENU_ITEMS_READ_ONLY = `${CM_ALIAS}.readOnly`;\nvar \
CONTEXTMENU_ITEMS_CLEAR_COLUMN = `${CM_ALIAS}.clearColumn`;\nvar \
CONTEXTMENU_ITEMS_COPY = `${CM_ALIAS}.copy`;\nvar \
CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS = \
`${CM_ALIAS}.copyWithHeaders`;\nvar \
CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS = \
`${CM_ALIAS}.copyWithGroupHeaders`;\nvar \
CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY = \
`${CM_ALIAS}.copyHeadersOnly`;\nvar CONTEXTMENU_ITEMS_CUT = \
`${CM_ALIAS}.cut`;\nvar CONTEXTMENU_ITEMS_FREEZE_COLUMN = \
`${CM_ALIAS}.freezeColumn`;\nvar CONTEXTMENU_ITEMS_UNFREEZE_COLUMN = \
`${CM_ALIAS}.unfreezeColumn`;\nvar CONTEXTMENU_ITEMS_MERGE_CELLS = \
`${CM_ALIAS}.mergeCells`;\nvar CONTEXTMENU_ITEMS_UNMERGE_CELLS = \
`${CM_ALIAS}.unmergeCells`;\nvar CONTEXTMENU_ITEMS_ADD_COMMENT = \
`${CM_ALIAS}.addComment`;\nvar CONTEXTMENU_ITEMS_EDIT_COMMENT = \
`${CM_ALIAS}.editComment`;\nvar CONTEXTMENU_ITEMS_REMOVE_COMMENT = \
`${CM_ALIAS}.removeComment`;\nvar CONTEXTMENU_ITEMS_READ_ONLY_COMMENT = \
`${CM_ALIAS}.readOnlyComment`;\nvar CONTEXTMENU_ITEMS_ALIGNMENT = \
`${CM_ALIAS}.align`;\nvar CONTEXTMENU_ITEMS_ALIGNMENT_LEFT = \
`${CM_ALIAS}.align.left`;\nvar CONTEXTMENU_ITEMS_ALIGNMENT_CENTER = \
`${CM_ALIAS}.align.center`;\nvar CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT = \
`${CM_ALIAS}.align.right`;\nvar CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY = \
`${CM_ALIAS}.align.justify`;\nvar CONTEXTMENU_ITEMS_ALIGNMENT_TOP = \
`${CM_ALIAS}.align.top`;\nvar CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE = \
`${CM_ALIAS}.align.middle`;\nvar CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM = \
`${CM_ALIAS}.align.bottom`;\nvar CONTEXTMENU_ITEMS_BORDERS = \
`${CM_ALIAS}.borders`;\nvar CONTEXTMENU_ITEMS_BORDERS_TOP = \
`${CM_ALIAS}.borders.top`;\nvar CONTEXTMENU_ITEMS_BORDERS_RIGHT = \
`${CM_ALIAS}.borders.right`;\nvar CONTEXTMENU_ITEMS_BORDERS_BOTTOM = \
`${CM_ALIAS}.borders.bottom`;\nvar CONTEXTMENU_ITEMS_BORDERS_LEFT = \
`${CM_ALIAS}.borders.left`;\nvar CONTEXTMENU_ITEMS_REMOVE_BORDERS = \
`${CM_ALIAS}.borders.remove`;\nvar CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD \
= `${CM_ALIAS}.nestedHeaders.insertChildRow`;\nvar \
CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD = \
`${CM_ALIAS}.nestedHeaders.detachFromParent`;\nvar \
CONTEXTMENU_ITEMS_HIDE_COLUMN = `${CM_ALIAS}.hideColumn`;\nvar \
CONTEXTMENU_ITEMS_SHOW_COLUMN = `${CM_ALIAS}.showColumn`;\nvar \
CONTEXTMENU_ITEMS_HIDE_ROW = `${CM_ALIAS}.hideRow`;\nvar \
CONTEXTMENU_ITEMS_SHOW_ROW = `${CM_ALIAS}.showRow`;\nvar FILTERS_NAMESPACE = \
\"Filters:\";\nvar FILTERS_CONDITIONS_NAMESPACE = \
`${FILTERS_NAMESPACE}conditions`;\nvar FILTERS_CONDITIONS_NONE = \
`${FILTERS_CONDITIONS_NAMESPACE}.none`;\nvar FILTERS_CONDITIONS_EMPTY = \
`${FILTERS_CONDITIONS_NAMESPACE}.isEmpty`;\nvar FILTERS_CONDITIONS_NOT_EMPTY \
= `${FILTERS_CONDITIONS_NAMESPACE}.isNotEmpty`;\nvar FILTERS_CONDITIONS_EQUAL \
= `${FILTERS_CONDITIONS_NAMESPACE}.isEqualTo`;\nvar \
FILTERS_CONDITIONS_NOT_EQUAL = \
`${FILTERS_CONDITIONS_NAMESPACE}.isNotEqualTo`;\nvar \
FILTERS_CONDITIONS_BEGINS_WITH = \
`${FILTERS_CONDITIONS_NAMESPACE}.beginsWith`;\nvar \
FILTERS_CONDITIONS_ENDS_WITH = \
`${FILTERS_CONDITIONS_NAMESPACE}.endsWith`;\nvar FILTERS_CONDITIONS_CONTAINS \
= `${FILTERS_CONDITIONS_NAMESPACE}.contains`;\nvar \
FILTERS_CONDITIONS_NOT_CONTAIN = \
`${FILTERS_CONDITIONS_NAMESPACE}.doesNotContain`;\nvar \
FILTERS_CONDITIONS_BY_VALUE = `${FILTERS_CONDITIONS_NAMESPACE}.byValue`;\nvar \
FILTERS_CONDITIONS_GREATER_THAN = \
`${FILTERS_CONDITIONS_NAMESPACE}.greaterThan`;\nvar \
FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL = \
`${FILTERS_CONDITIONS_NAMESPACE}.greaterThanOrEqualTo`;\nvar \
FILTERS_CONDITIONS_LESS_THAN = \
`${FILTERS_CONDITIONS_NAMESPACE}.lessThan`;\nvar \
FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL = \
`${FILTERS_CONDITIONS_NAMESPACE}.lessThanOrEqualTo`;\nvar \
FILTERS_CONDITIONS_BETWEEN = \
`${FILTERS_CONDITIONS_NAMESPACE}.isBetween`;\nvar \
FILTERS_CONDITIONS_NOT_BETWEEN = \
`${FILTERS_CONDITIONS_NAMESPACE}.isNotBetween`;\nvar FILTERS_CONDITIONS_AFTER \
= `${FILTERS_CONDITIONS_NAMESPACE}.after`;\nvar FILTERS_CONDITIONS_BEFORE = \
`${FILTERS_CONDITIONS_NAMESPACE}.before`;\nvar FILTERS_CONDITIONS_TODAY = \
`${FILTERS_CONDITIONS_NAMESPACE}.today`;\nvar FILTERS_CONDITIONS_TOMORROW = \
`${FILTERS_CONDITIONS_NAMESPACE}.tomorrow`;\nvar FILTERS_CONDITIONS_YESTERDAY \
= `${FILTERS_CONDITIONS_NAMESPACE}.yesterday`;\nvar \
FILTERS_DIVS_FILTER_BY_CONDITION = \
`${FILTERS_NAMESPACE}labels.filterByCondition`;\nvar \
FILTERS_DIVS_FILTER_BY_VALUE = \
`${FILTERS_NAMESPACE}labels.filterByValue`;\nvar FILTERS_LABELS_CONJUNCTION = \
`${FILTERS_NAMESPACE}labels.conjunction`;\nvar FILTERS_LABELS_DISJUNCTION = \
`${FILTERS_NAMESPACE}labels.disjunction`;\nvar FILTERS_VALUES_BLANK_CELLS = \
`${FILTERS_NAMESPACE}values.blankCells`;\nvar FILTERS_BUTTONS_SELECT_ALL = \
`${FILTERS_NAMESPACE}buttons.selectAll`;\nvar FILTERS_BUTTONS_CLEAR = \
`${FILTERS_NAMESPACE}buttons.clear`;\nvar FILTERS_BUTTONS_OK = \
`${FILTERS_NAMESPACE}buttons.ok`;\nvar FILTERS_BUTTONS_CANCEL = \
`${FILTERS_NAMESPACE}buttons.cancel`;\nvar FILTERS_BUTTONS_PLACEHOLDER_SEARCH \
= `${FILTERS_NAMESPACE}buttons.placeholder.search`;\nvar \
FILTERS_BUTTONS_PLACEHOLDER_VALUE = \
`${FILTERS_NAMESPACE}buttons.placeholder.value`;\nvar \
FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE = \
`${FILTERS_NAMESPACE}buttons.placeholder.secondValue`;\n\n// \
node_modules/handsontable/i18n/languages/en-US.mjs\nvar dictionary = {\n  \
languageCode: \"en-US\",\n  [CONTEXTMENU_ITEMS_NO_ITEMS]: \"No available \
options\",\n  [CONTEXTMENU_ITEMS_ROW_ABOVE]: \"Insert row above\",\n  \
[CONTEXTMENU_ITEMS_ROW_BELOW]: \"Insert row below\",\n  \
[CONTEXTMENU_ITEMS_INSERT_LEFT]: \"Insert column left\",\n  \
[CONTEXTMENU_ITEMS_INSERT_RIGHT]: \"Insert column right\",\n  \
[CONTEXTMENU_ITEMS_REMOVE_ROW]: [\"Remove row\", \"Remove rows\"],\n  \
[CONTEXTMENU_ITEMS_REMOVE_COLUMN]: [\"Remove column\", \"Remove columns\"],\n \
 [CONTEXTMENU_ITEMS_UNDO]: \"Undo\",\n  [CONTEXTMENU_ITEMS_REDO]: \"Redo\",\n \
 [CONTEXTMENU_ITEMS_READ_ONLY]: \"Read only\",\n  \
[CONTEXTMENU_ITEMS_CLEAR_COLUMN]: \"Clear column\",\n  \
[CONTEXTMENU_ITEMS_ALIGNMENT]: \"Alignment\",\n  \
[CONTEXTMENU_ITEMS_ALIGNMENT_LEFT]: \"Left\",\n  \
[CONTEXTMENU_ITEMS_ALIGNMENT_CENTER]: \"Center\",\n  \
[CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT]: \"Right\",\n  \
[CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY]: \"Justify\",\n  \
[CONTEXTMENU_ITEMS_ALIGNMENT_TOP]: \"Top\",\n  \
[CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE]: \"Middle\",\n  \
[CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM]: \"Bottom\",\n  \
[CONTEXTMENU_ITEMS_FREEZE_COLUMN]: \"Freeze column\",\n  \
[CONTEXTMENU_ITEMS_UNFREEZE_COLUMN]: \"Unfreeze column\",\n  \
[CONTEXTMENU_ITEMS_BORDERS]: \"Borders\",\n  [CONTEXTMENU_ITEMS_BORDERS_TOP]: \
\"Top\",\n  [CONTEXTMENU_ITEMS_BORDERS_RIGHT]: \"Right\",\n  \
[CONTEXTMENU_ITEMS_BORDERS_BOTTOM]: \"Bottom\",\n  \
[CONTEXTMENU_ITEMS_BORDERS_LEFT]: \"Left\",\n  \
[CONTEXTMENU_ITEMS_REMOVE_BORDERS]: \"Remove border(s)\",\n  \
[CONTEXTMENU_ITEMS_ADD_COMMENT]: \"Add comment\",\n  \
[CONTEXTMENU_ITEMS_EDIT_COMMENT]: \"Edit comment\",\n  \
[CONTEXTMENU_ITEMS_REMOVE_COMMENT]: \"Delete comment\",\n  \
[CONTEXTMENU_ITEMS_READ_ONLY_COMMENT]: \"Read-only comment\",\n  \
[CONTEXTMENU_ITEMS_MERGE_CELLS]: \"Merge cells\",\n  \
[CONTEXTMENU_ITEMS_UNMERGE_CELLS]: \"Unmerge cells\",\n  \
[CONTEXTMENU_ITEMS_COPY]: \"Copy\",\n  \
[CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS]: [\"Copy with header\", \"Copy \
with headers\"],\n  [CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS]: \
[\"Copy with group header\", \"Copy with group headers\"],\n  \
[CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY]: [\"Copy header only\", \"Copy \
headers only\"],\n  [CONTEXTMENU_ITEMS_CUT]: \"Cut\",\n  \
[CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD]: \"Insert child row\",\n  \
[CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD]: \"Detach from parent\",\n  \
[CONTEXTMENU_ITEMS_HIDE_COLUMN]: [\"Hide column\", \"Hide columns\"],\n  \
[CONTEXTMENU_ITEMS_SHOW_COLUMN]: [\"Show column\", \"Show columns\"],\n  \
[CONTEXTMENU_ITEMS_HIDE_ROW]: [\"Hide row\", \"Hide rows\"],\n  \
[CONTEXTMENU_ITEMS_SHOW_ROW]: [\"Show row\", \"Show rows\"],\n  \
[FILTERS_CONDITIONS_NONE]: \"None\",\n  [FILTERS_CONDITIONS_EMPTY]: \"Is \
empty\",\n  [FILTERS_CONDITIONS_NOT_EMPTY]: \"Is not empty\",\n  \
[FILTERS_CONDITIONS_EQUAL]: \"Is equal to\",\n  \
[FILTERS_CONDITIONS_NOT_EQUAL]: \"Is not equal to\",\n  \
[FILTERS_CONDITIONS_BEGINS_WITH]: \"Begins with\",\n  \
[FILTERS_CONDITIONS_ENDS_WITH]: \"Ends with\",\n  \
[FILTERS_CONDITIONS_CONTAINS]: \"Contains\",\n  \
[FILTERS_CONDITIONS_NOT_CONTAIN]: \"Does not contain\",\n  \
[FILTERS_CONDITIONS_GREATER_THAN]: \"Greater than\",\n  \
[FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL]: \"Greater than or equal to\",\n  \
[FILTERS_CONDITIONS_LESS_THAN]: \"Less than\",\n  \
[FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL]: \"Less than or equal to\",\n  \
[FILTERS_CONDITIONS_BETWEEN]: \"Is between\",\n  \
[FILTERS_CONDITIONS_NOT_BETWEEN]: \"Is not between\",\n  \
[FILTERS_CONDITIONS_AFTER]: \"After\",\n  [FILTERS_CONDITIONS_BEFORE]: \
\"Before\",\n  [FILTERS_CONDITIONS_TODAY]: \"Today\",\n  \
[FILTERS_CONDITIONS_TOMORROW]: \"Tomorrow\",\n  \
[FILTERS_CONDITIONS_YESTERDAY]: \"Yesterday\",\n  \
[FILTERS_VALUES_BLANK_CELLS]: \"Blank cells\",\n  \
[FILTERS_DIVS_FILTER_BY_CONDITION]: \"Filter by condition\",\n  \
[FILTERS_DIVS_FILTER_BY_VALUE]: \"Filter by value\",\n  \
[FILTERS_LABELS_CONJUNCTION]: \"And\",\n  [FILTERS_LABELS_DISJUNCTION]: \
\"Or\",\n  [FILTERS_BUTTONS_SELECT_ALL]: \"Select all\",\n  \
[FILTERS_BUTTONS_CLEAR]: \"Clear\",\n  [FILTERS_BUTTONS_OK]: \"OK\",\n  \
[FILTERS_BUTTONS_CANCEL]: \"Cancel\",\n  \
[FILTERS_BUTTONS_PLACEHOLDER_SEARCH]: \"Search\",\n  \
[FILTERS_BUTTONS_PLACEHOLDER_VALUE]: \"Value\",\n  \
[FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE]: \"Second value\"\n};\nvar \
en_US_default = dictionary;\n\n// \
node_modules/handsontable/i18n/registry.mjs\nvar dictionaryKeys = \
constants_exports;\nvar DEFAULT_LANGUAGE_CODE = \
en_US_default.languageCode;\nvar {\n  register: \
registerGloballyLanguageDictionary,\n  getItem: \
getGlobalLanguageDictionary,\n  hasItem: hasGlobalLanguageDictionary,\n  \
getValues: getGlobalLanguagesDictionaries\n} = \
staticRegister(\"languagesDictionaries\");\nregisterLanguageDictionary(en_US_\
default);\nfunction registerLanguageDictionary(languageCodeOrDictionary, \
dictionary2) {\n  let languageCode = languageCodeOrDictionary;\n  let \
dictionaryObject = dictionary2;\n  if (isObject(languageCodeOrDictionary)) \
{\n    dictionaryObject = languageCodeOrDictionary;\n    languageCode = \
dictionaryObject.languageCode;\n  }\n  extendLanguageDictionary(languageCode, \
dictionaryObject);\n  registerGloballyLanguageDictionary(languageCode, \
deepClone(dictionaryObject));\n  return \
deepClone(dictionaryObject);\n}\nfunction \
extendLanguageDictionary(languageCode, dictionary2) {\n  if (languageCode !== \
DEFAULT_LANGUAGE_CODE) {\n    extendNotExistingKeys(dictionary2, \
getGlobalLanguageDictionary(DEFAULT_LANGUAGE_CODE));\n  }\n}\nfunction \
getLanguageDictionary(languageCode) {\n  if \
(!hasLanguageDictionary(languageCode)) {\n    return null;\n  }\n  return \
deepClone(getGlobalLanguageDictionary(languageCode));\n}\nfunction \
hasLanguageDictionary(languageCode) {\n  return \
hasGlobalLanguageDictionary(languageCode);\n}\nfunction \
getLanguagesDictionaries() {\n  return \
getGlobalLanguagesDictionaries();\n}\nfunction \
getTranslatedPhrase(languageCode, dictionaryKey, argumentsForFormatters) {\n  \
const languageDictionary = getLanguageDictionary(languageCode);\n  if \
(languageDictionary === null) {\n    return null;\n  }\n  const \
phrasePropositions = languageDictionary[dictionaryKey];\n  if \
(isUndefined(phrasePropositions)) {\n    return null;\n  }\n  const \
formattedPhrase = getFormattedPhrase(phrasePropositions, \
argumentsForFormatters);\n  if (Array.isArray(formattedPhrase)) {\n    return \
formattedPhrase[0];\n  }\n  return formattedPhrase;\n}\nfunction \
getFormattedPhrase(phrasePropositions, argumentsForFormatters) {\n  let \
formattedPhrasePropositions = phrasePropositions;\n  arrayEach(getAll(), \
(formatter) => {\n    formattedPhrasePropositions = \
formatter(phrasePropositions, argumentsForFormatters);\n  });\n  return \
formattedPhrasePropositions;\n}\nfunction getValidLanguageCode(languageCode) \
{\n  let normalizedLanguageCode = normalizeLanguageCode(languageCode);\n  if \
(!hasLanguageDictionary(normalizedLanguageCode)) {\n    \
normalizedLanguageCode = DEFAULT_LANGUAGE_CODE;\n    \
warnUserAboutLanguageRegistration(languageCode);\n  }\n  return \
normalizedLanguageCode;\n}\n\n// \
node_modules/handsontable/selection/highlight/constants.mjs\nvar \
ACTIVE_HEADER_TYPE = \"active-header\";\nvar AREA_TYPE = \"area\";\nvar \
CELL_TYPE = \"cell\";\nvar FILL_TYPE = \"fill\";\nvar HEADER_TYPE = \
\"header\";\nvar CUSTOM_SELECTION_TYPE = \"custom-selection\";\n\n// \
node_modules/handsontable/selection/highlight/visualSelection.mjs\nfunction \
_defineProperty15(obj, key, value) {\n  key = _toPropertyKey15(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey15(arg) {\n  var key = \
_toPrimitive15(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive15(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar VisualSelection = class extends selection_default {\n \
 constructor(settings, visualCellRange) {\n    super(settings, null);\n    \
_defineProperty15(this, \"visualCellRange\", null);\n    this.visualCellRange \
= visualCellRange || null;\n    this.commit();\n  }\n  /**\n   * Adds a cell \
coords to the selection.\n   *\n   * @param {CellCoords} coords Visual \
coordinates of a cell.\n   * @returns {VisualSelection}\n   */\n  add(coords) \
{\n    if (this.visualCellRange === null) {\n      this.visualCellRange = \
this.settings.createCellRange(coords);\n    } else {\n      \
this.visualCellRange.expand(coords);\n    }\n    return this;\n  }\n  /**\n   \
* Clears visual and renderable selection.\n   *\n   * @returns \
{VisualSelection}\n   */\n  clear() {\n    this.visualCellRange = null;\n    \
return super.clear();\n  }\n  /**\n   * Trims the passed cell range object by \
removing all coordinates that points to the hidden rows\n   * or columns. The \
result is a new cell range object that points only to the visible indexes or \
`null`.\n   *\n   * @private\n   * @param {CellRange} cellRange Cells range \
object to be trimmed.\n   * @returns {CellRange} Visual non-hidden cells \
range coordinates.\n   */\n  trimToVisibleCellsRangeOnly(_ref) {\n    let {\n \
     from,\n      to\n    } = _ref;\n    let visibleFromCoords = \
this.getNearestNotHiddenCoords(from, 1);\n    let visibleToCoords = \
this.getNearestNotHiddenCoords(to, -1);\n    if (visibleFromCoords === null \
|| visibleToCoords === null) {\n      return null;\n    }\n    if \
(visibleFromCoords.row > visibleToCoords.row || visibleFromCoords.col > \
visibleToCoords.col) {\n      const isHeaderTypeSelection = \
this.settings.type === \"header\" || this.settings.type === \
\"active-header\";\n      if (!isHeaderTypeSelection) {\n        return \
null;\n      }\n      visibleFromCoords = from;\n      visibleToCoords = \
to;\n    }\n    return this.settings.createCellRange(visibleFromCoords, \
visibleFromCoords, visibleToCoords);\n  }\n  /**\n   * Gets nearest \
coordinates that points to the visible row and column indexes. If there are \
no visible\n   * rows and/or columns the `null` value is returned.\n   *\n   \
* @private\n   * @param {CellCoords} coords The coords object as starting \
point for finding the nearest visible coordinates.\n   * @param {1|-1} \
rowSearchDirection The search direction. For value 1, it means searching from \
top to bottom for\n   *                                  rows and from left \
to right for columns. For -1, it is the other way around.\n   * @param {1|-1} \
columnSearchDirection The same as above but for rows.\n   * @returns \
{CellCoords|null} Visual cell coordinates.\n   */\n  \
getNearestNotHiddenCoords(coords, rowSearchDirection) {\n    let \
columnSearchDirection = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : rowSearchDirection;\n    const nextVisibleRow = \
this.getNearestNotHiddenIndex(this.settings.rowIndexMapper(), coords.row, \
rowSearchDirection);\n    if (nextVisibleRow === null) {\n      return \
null;\n    }\n    const nextVisibleColumn = \
this.getNearestNotHiddenIndex(this.settings.columnIndexMapper(), coords.col, \
columnSearchDirection);\n    if (nextVisibleColumn === null) {\n      return \
null;\n    }\n    return this.settings.createCellCoords(nextVisibleRow, \
nextVisibleColumn);\n  }\n  /**\n   * Gets nearest visual index. If there are \
no visible rows or columns the `null` value is returned.\n   *\n   * \
@private\n   * @param {IndexMapper} indexMapper The IndexMapper instance for \
specific axis.\n   * @param {number} visualIndex The index as starting point \
for finding the nearest visible index.\n   * @param {1|-1} searchDirection \
The search direction. For value 1, it means searching from top to bottom \
for\n   *                               rows and from left to right for \
columns. For -1, it is the other way around.\n   * @returns {number|null} \
Visual row/column index.\n   */\n  getNearestNotHiddenIndex(indexMapper, \
visualIndex, searchDirection) {\n    if (visualIndex < 0) {\n      return \
visualIndex;\n    }\n    const nearestVisualIndex = \
indexMapper.getNearestNotHiddenIndex(visualIndex, searchDirection);\n    \
const isHeaderSelectionType = this.settings.type === \"header\" || \
this.settings.type === \"active-header\";\n    if (isHeaderSelectionType && \
nearestVisualIndex === null) {\n      return -1;\n    }\n    return \
nearestVisualIndex;\n  }\n  /**\n   * Override internally stored visual \
indexes added by the Selection's `add` function. It should be executed\n   * \
at the end of process of adding visual selection coordinates.\n   *\n   * \
@returns {VisualSelection}\n   */\n  commit() {\n    if (this.visualCellRange \
=== null) {\n      return this;\n    }\n    const trimmedCellRange = \
this.trimToVisibleCellsRangeOnly(this.visualCellRange);\n    if \
(trimmedCellRange === null) {\n      this.cellRange = null;\n    } else {\n   \
   this.cellRange = this.createRenderableCellRange(trimmedCellRange.from, \
trimmedCellRange.to);\n    }\n    return this;\n  }\n  /**\n   * Some \
selection may be a part of broader cell range. This function sync coordinates \
of current selection\n   * and the broader cell range when needed (current \
selection can't be presented visually).\n   *\n   * @param {CellRange} \
broaderCellRange Visual range. Actual cell range may be contained in the \
broader cell range.\n   * When there is no way to represent some cell range \
visually we try to find range containing just the first visible cell.\n   *\n \
  * Warn: Please keep in mind that this function may change coordinates of \
the handled broader range.\n   *\n   * @returns {VisualSelection}\n   */\n  \
syncWith(broaderCellRange) {\n    const rowDirection = \
broaderCellRange.getVerticalDirection() === \"N-S\" ? 1 : -1;\n    const \
columnDirection = broaderCellRange.getHorizontalDirection() === \"W-E\" ? 1 : \
-1;\n    const singleCellRangeVisual = \
this.getNearestNotHiddenCoords(broaderCellRange.from.clone().normalize(), \
rowDirection, columnDirection);\n    if (singleCellRangeVisual !== null && \
broaderCellRange.overlaps(singleCellRangeVisual)) {\n      if (this.cellRange \
=== null) {\n        const singleCellRangeRenderable = \
this.settings.visualToRenderableCoords(singleCellRangeVisual);\n        \
this.cellRange = this.settings.createCellRange(singleCellRangeRenderable);\n  \
    }\n      broaderCellRange.setHighlight(singleCellRangeVisual);\n      \
return this;\n    }\n    \
broaderCellRange.setHighlight(broaderCellRange.from);\n    return this;\n  \
}\n  /**\n   * Returns the top left (TL) and bottom right (BR) selection \
coordinates (renderable indexes).\n   * The method overwrites the original \
method to support header selection for hidden cells.\n   * To make the header \
selection working, the CellCoords and CellRange have to support not\n   * \
complete coordinates (`null` values for example, `row: null`, `col: 2`).\n   \
*\n   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, \
5]`.\n   */\n  getCorners() {\n    const {\n      from,\n      to\n    } = \
this.cellRange;\n    const isRowUndefined = from.row === null || to.row === \
null;\n    const isColumnUndefined = from.col === null || to.col === null;\n  \
  const topLeftCorner = this.settings.createCellCoords(isRowUndefined ? null \
: Math.min(from.row, to.row), isColumnUndefined ? null : Math.min(from.col, \
to.col));\n    const bottomRightCorner = \
this.settings.createCellCoords(isRowUndefined ? null : Math.max(from.row, \
to.row), isColumnUndefined ? null : Math.max(from.col, to.col));\n    return \
[topLeftCorner.row, topLeftCorner.col, bottomRightCorner.row, \
bottomRightCorner.col];\n  }\n  /**\n   * Returns the top left (or top right \
in RTL) and bottom right (or bottom left in RTL) selection\n   * coordinates \
(visual indexes).\n   *\n   * @returns {Array} Returns array of coordinates \
for example `[1, 1, 5, 5]`.\n   */\n  getVisualCorners() {\n    const \
topStart = \
this.settings.renderableToVisualCoords(this.cellRange.getTopStartCorner());\n \
   const bottomEnd = \
this.settings.renderableToVisualCoords(this.cellRange.getBottomEndCorner());\
\n    return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];\n  \
}\n  /**\n   * Creates a new CellRange object based on visual coordinates \
which before object creation are\n   * translated to renderable indexes.\n   \
*\n   * @param {CellCoords} visualFromCoords The CellCoords object which \
contains coordinates that\n   *                                      points \
to the beginning of the selection.\n   * @param {CellCoords} visualToCoords \
The CellCoords object which contains coordinates that\n   *                   \
                 points to the end of the selection.\n   * @returns \
{CellRange}\n   */\n  createRenderableCellRange(visualFromCoords, \
visualToCoords) {\n    const renderableFromCoords = \
this.settings.visualToRenderableCoords(visualFromCoords);\n    const \
renderableToCoords = \
this.settings.visualToRenderableCoords(visualToCoords);\n    return \
this.settings.createCellRange(renderableFromCoords, renderableFromCoords, \
renderableToCoords);\n  }\n};\nvar visualSelection_default = \
VisualSelection;\n\n// \
node_modules/handsontable/selection/highlight/types/activeHeader.mjs\nfunctio\
n createHighlight(_ref) {\n  let {\n    activeHeaderClassName,\n    \
...restOptions\n  } = _ref;\n  const s = new visualSelection_default({\n    \
highlightHeaderClassName: activeHeaderClassName,\n    ...restOptions,\n    \
selectionType: ACTIVE_HEADER_TYPE\n  });\n  return s;\n}\nvar \
activeHeader_default = createHighlight;\n\n// \
node_modules/handsontable/selection/highlight/types/area.mjs\nfunction \
createHighlight2(_ref) {\n  let {\n    layerLevel,\n    areaCornerVisible,\n  \
  ...restOptions\n  } = _ref;\n  const s = new visualSelection_default({\n    \
className: \"area\",\n    markIntersections: true,\n    layerLevel: \
Math.min(layerLevel, 7),\n    border: {\n      width: 1,\n      color: \
\"#4b89ff\",\n      cornerVisible: areaCornerVisible\n    },\n    \
...restOptions,\n    selectionType: AREA_TYPE\n  });\n  return s;\n}\nvar \
area_default = createHighlight2;\n\n// \
node_modules/handsontable/selection/highlight/types/cell.mjs\nfunction \
createHighlight3(_ref) {\n  let {\n    cellCornerVisible,\n    \
...restOptions\n  } = _ref;\n  const s = new visualSelection_default({\n    \
className: \"current\",\n    border: {\n      width: 2,\n      color: \
\"#4b89ff\",\n      cornerVisible: cellCornerVisible\n    },\n    \
...restOptions,\n    selectionType: CELL_TYPE\n  });\n  return s;\n}\nvar \
cell_default = createHighlight3;\n\n// \
node_modules/handsontable/selection/highlight/types/customSelection.mjs\nfunc\
tion createHighlight4(_ref) {\n  let {\n    border,\n    visualCellRange,\n   \
 ...restOptions\n  } = _ref;\n  const s = new visualSelection_default({\n    \
...border,\n    ...restOptions,\n    selectionType: CUSTOM_SELECTION_TYPE\n  \
}, visualCellRange);\n  return s;\n}\nvar customSelection_default = \
createHighlight4;\n\n// \
node_modules/handsontable/selection/highlight/types/fill.mjs\nfunction \
createHighlight5(_ref) {\n  let {\n    ...restOptions\n  } = _ref;\n  const s \
= new visualSelection_default({\n    className: \"fill\",\n    border: {\n    \
  width: 1,\n      color: \"#ff0000\"\n    },\n    ...restOptions,\n    \
selectionType: FILL_TYPE\n  });\n  return s;\n}\nvar fill_default = \
createHighlight5;\n\n// \
node_modules/handsontable/selection/highlight/types/header.mjs\nfunction \
createHighlight6(_ref) {\n  let {\n    headerClassName,\n    rowClassName,\n  \
  columnClassName,\n    ...restOptions\n  } = _ref;\n  const s = new \
visualSelection_default({\n    className: \"highlight\",\n    \
highlightHeaderClassName: headerClassName,\n    highlightRowClassName: \
rowClassName,\n    highlightColumnClassName: columnClassName,\n    \
...restOptions,\n    highlightOnlyClosestHeader: true,\n    selectionType: \
HEADER_TYPE\n  });\n  return s;\n}\nvar header_default = \
createHighlight6;\n\n// \
node_modules/handsontable/selection/highlight/types/index.mjs\nvar {\n  \
register: register5,\n  getItem: getItem4\n} = \
staticRegister(\"highlight/types\");\nregister5(ACTIVE_HEADER_TYPE, \
activeHeader_default);\nregister5(AREA_TYPE, \
area_default);\nregister5(CELL_TYPE, \
cell_default);\nregister5(CUSTOM_SELECTION_TYPE, \
customSelection_default);\nregister5(FILL_TYPE, \
fill_default);\nregister5(HEADER_TYPE, header_default);\nfunction \
createHighlight7(highlightType, options) {\n  return \
getItem4(highlightType)({\n    type: highlightType,\n    ...options\n  \
});\n}\n\n// node_modules/handsontable/selection/highlight/highlight.mjs\nvar \
Highlight = class {\n  constructor(options) {\n    this.options = options;\n  \
  this.layerLevel = 0;\n    this.cell = createHighlight7(CELL_TYPE, \
options);\n    this.fill = createHighlight7(FILL_TYPE, options);\n    \
this.areas = /* @__PURE__ */ new Map();\n    this.headers = /* @__PURE__ */ \
new Map();\n    this.activeHeaders = /* @__PURE__ */ new Map();\n    \
this.customSelections = [];\n  }\n  /**\n   * Check if highlight cell \
rendering is disabled for specified highlight type.\n   *\n   * @param \
{string} highlightType Highlight type. Possible values are: `cell`, `area`, \
`fill` or `header`.\n   * @param {CellCoords} coords The CellCoords instance \
with defined visual coordinates.\n   * @returns {boolean}\n   */\n  \
isEnabledFor(highlightType, coords) {\n    let type = highlightType;\n    if \
(highlightType === CELL_TYPE) {\n      type = \"current\";\n    }\n    let \
disableHighlight = this.options.disabledCellSelection(coords.row, \
coords.col);\n    if (typeof disableHighlight === \"string\") {\n      \
disableHighlight = [disableHighlight];\n    }\n    return disableHighlight \
=== false || Array.isArray(disableHighlight) && \
!disableHighlight.includes(type);\n  }\n  /**\n   * Set a new layer level to \
make access to the desire `area` and `header` highlights.\n   *\n   * @param \
{number} [level=0] Layer level to use.\n   * @returns {Highlight}\n   */\n  \
useLayerLevel() {\n    let level = arguments.length > 0 && arguments[0] !== \
void 0 ? arguments[0] : 0;\n    this.layerLevel = level;\n    return this;\n  \
}\n  /**\n   * Get Walkontable Selection instance created for controlling \
highlight of the currently selected/edited cell.\n   *\n   * @returns \
{Selection}\n   */\n  getCell() {\n    return this.cell;\n  }\n  /**\n   * \
Get Walkontable Selection instance created for controlling highlight of the \
autofill functionality.\n   *\n   * @returns {Selection}\n   */\n  getFill() \
{\n    return this.fill;\n  }\n  /**\n   * Get or create (if not exist in the \
cache) Walkontable Selection instance created for controlling highlight\n   * \
of the multiple selected cells.\n   *\n   * @returns {Selection}\n   */\n  \
createOrGetArea() {\n    const layerLevel = this.layerLevel;\n    let area;\n \
   if (this.areas.has(layerLevel)) {\n      area = \
this.areas.get(layerLevel);\n    } else {\n      area = \
createHighlight7(AREA_TYPE, {\n        layerLevel,\n        ...this.options\n \
     });\n      this.areas.set(layerLevel, area);\n    }\n    return area;\n  \
}\n  /**\n   * Get all Walkontable Selection instances which describes the \
state of the visual highlight of the cells.\n   *\n   * @returns \
{Selection[]}\n   */\n  getAreas() {\n    return [...this.areas.values()];\n  \
}\n  /**\n   * Get or create (if not exist in the cache) Walkontable \
Selection instance created for controlling highlight\n   * of the multiple \
selected header cells.\n   *\n   * @returns {Selection}\n   */\n  \
createOrGetHeader() {\n    const layerLevel = this.layerLevel;\n    let \
header;\n    if (this.headers.has(layerLevel)) {\n      header = \
this.headers.get(layerLevel);\n    } else {\n      header = \
createHighlight7(HEADER_TYPE, {\n        ...this.options\n      });\n      \
this.headers.set(layerLevel, header);\n    }\n    return header;\n  }\n  \
/**\n   * Get all Walkontable Selection instances which describes the state \
of the visual highlight of the headers.\n   *\n   * @returns {Selection[]}\n  \
 */\n  getHeaders() {\n    return [...this.headers.values()];\n  }\n  /**\n   \
* Get or create (if not exist in the cache) Walkontable Selection instance \
created for controlling highlight\n   * of the multiple selected active \
header cells.\n   *\n   * @returns {Selection}\n   */\n  \
createOrGetActiveHeader() {\n    const layerLevel = this.layerLevel;\n    let \
header;\n    if (this.activeHeaders.has(layerLevel)) {\n      header = \
this.activeHeaders.get(layerLevel);\n    } else {\n      header = \
createHighlight7(ACTIVE_HEADER_TYPE, {\n        ...this.options\n      });\n  \
    this.activeHeaders.set(layerLevel, header);\n    }\n    return header;\n  \
}\n  /**\n   * Get all Walkontable Selection instances which describes the \
state of the visual highlight of the active headers.\n   *\n   * @returns \
{Selection[]}\n   */\n  getActiveHeaders() {\n    return \
[...this.activeHeaders.values()];\n  }\n  /**\n   * Get Walkontable Selection \
instance created for controlling highlight of the custom selection \
functionality.\n   *\n   * @returns {Selection}\n   */\n  \
getCustomSelections() {\n    return [...this.customSelections.values()];\n  \
}\n  /**\n   * Add selection to the custom selection instance. The new \
selection are added to the end of the selection collection.\n   *\n   * \
@param {object} selectionInstance The selection instance.\n   */\n  \
addCustomSelection(selectionInstance) {\n    \
this.customSelections.push(createHighlight7(CUSTOM_SELECTION_TYPE, {\n      \
...this.options,\n      ...selectionInstance\n    }));\n  }\n  /**\n   * \
Perform cleaning visual highlights for the whole table.\n   */\n  clear() {\n \
   this.cell.clear();\n    this.fill.clear();\n    \
arrayEach(this.areas.values(), (highlight) => void highlight.clear());\n    \
arrayEach(this.headers.values(), (highlight) => void highlight.clear());\n    \
arrayEach(this.activeHeaders.values(), (highlight) => void \
highlight.clear());\n  }\n  /**\n   * This object can be iterate over using \
`for of` syntax or using internal `arrayEach` helper.\n   *\n   * @returns \
{Selection[]}\n   */\n  [Symbol.iterator]() {\n    return [this.cell, \
this.fill, ...this.areas.values(), ...this.headers.values(), \
...this.activeHeaders.values(), \
...this.customSelections][Symbol.iterator]();\n  }\n};\nvar highlight_default \
= Highlight;\n\n// node_modules/handsontable/selection/range.mjs\nvar \
SelectionRange = class {\n  constructor(createCellRange) {\n    this.ranges = \
[];\n    this.createCellRange = createCellRange;\n  }\n  /**\n   * Check if \
selected range is empty.\n   *\n   * @returns {boolean}\n   */\n  isEmpty() \
{\n    return this.size() === 0;\n  }\n  /**\n   * Set coordinates to the \
class instance. It clears all previously added coordinates and push \
`coords`\n   * to the collection.\n   *\n   * @param {CellCoords} coords The \
CellCoords instance with defined visual coordinates.\n   * @returns \
{SelectionRange}\n   */\n  set(coords) {\n    this.clear();\n    \
this.ranges.push(this.createCellRange(coords));\n    return this;\n  }\n  \
/**\n   * Add coordinates to the class instance. The new coordinates are \
added to the end of the range collection.\n   *\n   * @param {CellCoords} \
coords The CellCoords instance with defined visual coordinates.\n   * \
@returns {SelectionRange}\n   */\n  add(coords) {\n    \
this.ranges.push(this.createCellRange(coords));\n    return this;\n  }\n  \
/**\n   * Removes from the stack the last added coordinates.\n   *\n   * \
@returns {SelectionRange}\n   */\n  pop() {\n    this.ranges.pop();\n    \
return this;\n  }\n  /**\n   * Get last added coordinates from ranges, it \
returns a CellRange instance.\n   *\n   * @returns {CellRange|undefined}\n   \
*/\n  current() {\n    return this.peekByIndex(0);\n  }\n  /**\n   * Get \
previously added coordinates from ranges, it returns a CellRange instance.\n  \
 *\n   * @returns {CellRange|undefined}\n   */\n  previous() {\n    return \
this.peekByIndex(-1);\n  }\n  /**\n   * Returns `true` if coords is within \
selection coords. This method iterates through all selection layers to check \
if\n   * the coords object is within selection range.\n   *\n   * @param \
{CellCoords} coords The CellCoords instance with defined visual \
coordinates.\n   * @returns {boolean}\n   */\n  includes(coords) {\n    \
return this.ranges.some((cellRange) => cellRange.includes(coords));\n  }\n  \
/**\n   * Clear collection.\n   *\n   * @returns {SelectionRange}\n   */\n  \
clear() {\n    this.ranges.length = 0;\n    return this;\n  }\n  /**\n   * \
Get count of added all coordinates added to the selection.\n   *\n   * \
@returns {number}\n   */\n  size() {\n    return this.ranges.length;\n  }\n  \
/**\n   * Peek the coordinates based on the offset where that coordinate \
resides in the collection.\n   *\n   * @param {number} [offset=0] An offset \
where the coordinate will be retrieved from.\n   * @returns \
{CellRange|undefined}\n   */\n  peekByIndex() {\n    let offset3 = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    \
const rangeIndex = this.size() + offset3 - 1;\n    let cellRange;\n    if \
(rangeIndex >= 0) {\n      cellRange = this.ranges[rangeIndex];\n    }\n    \
return cellRange;\n  }\n  [Symbol.iterator]() {\n    return \
this.ranges[Symbol.iterator]();\n  }\n};\nvar range_default2 = \
SelectionRange;\n\n// \
node_modules/handsontable/selection/transformation.mjs\nvar Transformation = \
class {\n  constructor(range, options) {\n    this.range = range;\n    \
this.options = options;\n  }\n  /**\n   * Selects cell relative to current \
cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, \
value can be passed as negative number.\n   * @param {number} colDelta \
Columns number to move, value can be passed as negative number.\n   * @param \
{boolean} [force=false] If `true` the new rows/columns will be created if \
necessary. Otherwise, row/column will\n   *                        be created \
according to `minSpareRows/minSpareCols` settings of Handsontable.\n   * \
@returns {CellCoords} Visual coordinates after transformation.\n   */\n  \
transformStart(rowDelta, colDelta) {\n    let force = arguments.length > 2 && \
arguments[2] !== void 0 ? arguments[2] : false;\n    const delta = \
this.options.createCellCoords(rowDelta, colDelta);\n    const highlightCoords \
= this.range.current().highlight;\n    const {\n      row: renderableRow,\n   \
   col: renderableColumn\n    } = \
this.options.visualToRenderableCoords(highlightCoords);\n    let visualCoords \
= highlightCoords;\n    let rowTransformDir = 0;\n    let colTransformDir = \
0;\n    this.runLocalHooks(\"beforeTransformStart\", delta);\n    if \
(renderableRow !== null && renderableColumn !== null) {\n      let totalRows \
= this.options.countRows();\n      let totalCols = \
this.options.countCols();\n      const fixedRowsBottom = \
this.options.fixedRowsBottom();\n      const minSpareRows = \
this.options.minSpareRows();\n      const minSpareCols = \
this.options.minSpareCols();\n      const autoWrapRow = \
this.options.autoWrapRow();\n      const autoWrapCol = \
this.options.autoWrapCol();\n      if (renderableRow + rowDelta > totalRows - \
1) {\n        if (force && minSpareRows > 0 && !(fixedRowsBottom && \
renderableRow >= totalRows - fixedRowsBottom - 1)) {\n          \
this.runLocalHooks(\"insertRowRequire\", totalRows);\n          totalRows = \
this.options.countRows();\n        } else if (autoWrapCol) {\n          \
delta.row = 1 - totalRows;\n          delta.col = renderableColumn + \
delta.col === totalCols - 1 ? 1 - totalCols : 1;\n        }\n      } else if \
(autoWrapCol && renderableRow + delta.row < 0 && renderableColumn + delta.col \
>= 0) {\n        delta.row = totalRows - 1;\n        delta.col = \
renderableColumn + delta.col === 0 ? totalCols - 1 : -1;\n      }\n      if \
(renderableColumn + delta.col > totalCols - 1) {\n        if (force && \
minSpareCols > 0) {\n          this.runLocalHooks(\"insertColRequire\", \
totalCols);\n          totalCols = this.options.countCols();\n        } else \
if (autoWrapRow) {\n          delta.row = renderableRow + delta.row === \
totalRows - 1 ? 1 - totalRows : 1;\n          delta.col = 1 - totalCols;\n    \
    }\n      } else if (autoWrapRow && renderableColumn + delta.col < 0 && \
renderableRow + delta.row >= 0) {\n        delta.row = renderableRow + \
delta.row === 0 ? totalRows - 1 : -1;\n        delta.col = totalCols - 1;\n   \
   }\n      const coords = this.options.createCellCoords(renderableRow + \
delta.row, renderableColumn + delta.col);\n      rowTransformDir = 0;\n      \
colTransformDir = 0;\n      if (coords.row < 0) {\n        rowTransformDir = \
-1;\n        coords.row = 0;\n      } else if (coords.row > 0 && coords.row \
>= totalRows) {\n        rowTransformDir = 1;\n        coords.row = totalRows \
- 1;\n      }\n      if (coords.col < 0) {\n        colTransformDir = -1;\n   \
     coords.col = 0;\n      } else if (coords.col > 0 && coords.col >= \
totalCols) {\n        colTransformDir = 1;\n        coords.col = totalCols - \
1;\n      }\n      visualCoords = \
this.options.renderableToVisualCoords(coords);\n    }\n    \
this.runLocalHooks(\"afterTransformStart\", visualCoords, rowTransformDir, \
colTransformDir);\n    return visualCoords;\n  }\n  /**\n   * Sets selection \
end cell relative to current selection end cell (if possible).\n   *\n   * \
@param {number} rowDelta Rows number to move, value can be passed as negative \
number.\n   * @param {number} colDelta Columns number to move, value can be \
passed as negative number.\n   * @returns {CellCoords} Visual coordinates \
after transformation.\n   */\n  transformEnd(rowDelta, colDelta) {\n    const \
delta = this.options.createCellCoords(rowDelta, colDelta);\n    const \
cellRange = this.range.current();\n    let visualCoords = cellRange.to;\n    \
let rowTransformDir = 0;\n    let colTransformDir = 0;\n    \
this.runLocalHooks(\"beforeTransformEnd\", delta);\n    const {\n      row: \
rowHighlight,\n      col: colHighlight\n    } = \
this.options.visualToRenderableCoords(cellRange.highlight);\n    if \
(rowHighlight !== null && colHighlight !== null) {\n      const totalRows = \
this.options.countRows();\n      const totalCols = \
this.options.countCols();\n      const {\n        row: rowTo,\n        col: \
colTo\n      } = this.options.visualToRenderableCoords(cellRange.to);\n      \
const coords = this.options.createCellCoords(rowTo + delta.row, colTo + \
delta.col);\n      rowTransformDir = 0;\n      colTransformDir = 0;\n      if \
(coords.row < 0) {\n        rowTransformDir = -1;\n        coords.row = 0;\n  \
    } else if (coords.row > 0 && coords.row >= totalRows) {\n        \
rowTransformDir = 1;\n        coords.row = totalRows - 1;\n      }\n      if \
(coords.col < 0) {\n        colTransformDir = -1;\n        coords.col = 0;\n  \
    } else if (coords.col > 0 && coords.col >= totalCols) {\n        \
colTransformDir = 1;\n        coords.col = totalCols - 1;\n      }\n      \
visualCoords = this.options.renderableToVisualCoords(coords);\n    }\n    \
this.runLocalHooks(\"afterTransformEnd\", visualCoords, rowTransformDir, \
colTransformDir);\n    return visualCoords;\n  }\n};\nmixin(Transformation, \
localHooks_default);\nvar transformation_default = Transformation;\n\n// \
node_modules/handsontable/selection/utils.mjs\nvar \
SELECTION_TYPE_UNRECOGNIZED = 0;\nvar SELECTION_TYPE_EMPTY = 1;\nvar \
SELECTION_TYPE_ARRAY = 2;\nvar SELECTION_TYPE_OBJECT = 3;\nvar \
SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];\nvar \
ARRAY_TYPE_PATTERN = [[\"number\"], [\"number\", \"string\"], [\"number\", \
\"undefined\"], [\"number\", \"string\", \"undefined\"]];\nvar rootCall = \
Symbol(\"root\");\nvar childCall = Symbol(\"child\");\nfunction \
detectSelectionType(selectionRanges) {\n  let _callSymbol = arguments.length \
> 1 && arguments[1] !== void 0 ? arguments[1] : rootCall;\n  if (_callSymbol \
!== rootCall && _callSymbol !== childCall) {\n    throw new Error(\"The \
second argument is used internally only and cannot be overwritten.\");\n  }\n \
 const isArray = Array.isArray(selectionRanges);\n  const isRootCall = \
_callSymbol === rootCall;\n  let result = SELECTION_TYPE_UNRECOGNIZED;\n  if \
(isArray) {\n    const firstItem = selectionRanges[0];\n    if \
(selectionRanges.length === 0) {\n      result = SELECTION_TYPE_EMPTY;\n    } \
else if (isRootCall && firstItem instanceof range_default) {\n      result = \
SELECTION_TYPE_OBJECT;\n    } else if (isRootCall && \
Array.isArray(firstItem)) {\n      result = detectSelectionType(firstItem, \
childCall);\n    } else if (selectionRanges.length >= 2 && \
selectionRanges.length <= 4) {\n      const isArrayType = \
!selectionRanges.some((value, index2) => \
!ARRAY_TYPE_PATTERN[index2].includes(typeof value));\n      if (isArrayType) \
{\n        result = SELECTION_TYPE_ARRAY;\n      }\n    }\n  }\n  return \
result;\n}\nfunction normalizeSelectionFactory(type) {\n  let {\n    \
keepDirection = false,\n    propToCol\n  } = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : {};\n  if \
(!SELECTION_TYPES.includes(type)) {\n    throw new Error(\"Unsupported \
selection ranges schema type was provided.\");\n  }\n  return \
function(selection) {\n    const isObjectType = type === \
SELECTION_TYPE_OBJECT;\n    let rowStart = isObjectType ? selection.from.row \
: selection[0];\n    let columnStart = isObjectType ? selection.from.col : \
selection[1];\n    let rowEnd = isObjectType ? selection.to.row : \
selection[2];\n    let columnEnd = isObjectType ? selection.to.col : \
selection[3];\n    if (typeof propToCol === \"function\") {\n      if (typeof \
columnStart === \"string\") {\n        columnStart = \
propToCol(columnStart);\n      }\n      if (typeof columnEnd === \"string\") \
{\n        columnEnd = propToCol(columnEnd);\n      }\n    }\n    if \
(isUndefined(rowEnd)) {\n      rowEnd = rowStart;\n    }\n    if \
(isUndefined(columnEnd)) {\n      columnEnd = columnStart;\n    }\n    if \
(!keepDirection) {\n      const origRowStart = rowStart;\n      const \
origColumnStart = columnStart;\n      const origRowEnd = rowEnd;\n      const \
origColumnEnd = columnEnd;\n      rowStart = Math.min(origRowStart, \
origRowEnd);\n      columnStart = Math.min(origColumnStart, origColumnEnd);\n \
     rowEnd = Math.max(origRowStart, origRowEnd);\n      columnEnd = \
Math.max(origColumnStart, origColumnEnd);\n    }\n    return [rowStart, \
columnStart, rowEnd, columnEnd];\n  };\n}\nfunction \
transformSelectionToColumnDistance(selectionRanges) {\n  const selectionType \
= detectSelectionType(selectionRanges);\n  if (selectionType === \
SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    \
return [];\n  }\n  const selectionSchemaNormalizer = \
normalizeSelectionFactory(selectionType);\n  const unorderedIndexes = /* \
@__PURE__ */ new Set();\n  arrayEach(selectionRanges, (selection) => {\n    \
const [, columnStart, , columnEnd] = selectionSchemaNormalizer(selection);\n  \
  const columnNonHeaderStart = Math.max(columnStart, 0);\n    const amount = \
columnEnd - columnNonHeaderStart + 1;\n    arrayEach(Array.from(new \
Array(amount), (_, i) => columnNonHeaderStart + i), (index2) => {\n      if \
(!unorderedIndexes.has(index2)) {\n        unorderedIndexes.add(index2);\n    \
  }\n    });\n  });\n  const orderedIndexes = \
Array.from(unorderedIndexes).sort((a, b) => a - b);\n  const \
normalizedColumnRanges = arrayReduce(orderedIndexes, (acc, visualColumnIndex, \
index2, array) => {\n    if (index2 !== 0 && visualColumnIndex === \
array[index2 - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n  \
    acc.push([visualColumnIndex, 1]);\n    }\n    return acc;\n  }, []);\n  \
return normalizedColumnRanges;\n}\nfunction \
transformSelectionToRowDistance(selectionRanges) {\n  const selectionType = \
detectSelectionType(selectionRanges);\n  if (selectionType === \
SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    \
return [];\n  }\n  const selectionSchemaNormalizer = \
normalizeSelectionFactory(selectionType);\n  const unorderedIndexes = /* \
@__PURE__ */ new Set();\n  arrayEach(selectionRanges, (selection) => {\n    \
const [rowStart, , rowEnd] = selectionSchemaNormalizer(selection);\n    const \
rowNonHeaderStart = Math.max(rowStart, 0);\n    const amount = rowEnd - \
rowNonHeaderStart + 1;\n    arrayEach(Array.from(new Array(amount), (_, i) => \
rowNonHeaderStart + i), (index2) => {\n      if \
(!unorderedIndexes.has(index2)) {\n        unorderedIndexes.add(index2);\n    \
  }\n    });\n  });\n  const orderedIndexes = \
Array.from(unorderedIndexes).sort((a, b) => a - b);\n  const \
normalizedRowRanges = arrayReduce(orderedIndexes, (acc, rowIndex, index2, \
array) => {\n    if (index2 !== 0 && rowIndex === array[index2 - 1] + 1) {\n  \
    acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([rowIndex, \
1]);\n    }\n    return acc;\n  }, []);\n  return \
normalizedRowRanges;\n}\nfunction isValidCoord(coord) {\n  let \
maxTableItemsCount = arguments.length > 1 && arguments[1] !== void 0 ? \
arguments[1] : Infinity;\n  return typeof coord === \"number\" && coord >= 0 \
&& coord < maxTableItemsCount;\n}\n\n// \
node_modules/handsontable/selection/selection.mjs\nvar Selection2 = class {\n \
 constructor(settings, tableProps) {\n    var _this = this;\n    \
this.settings = settings;\n    this.tableProps = tableProps;\n    \
this.inProgress = false;\n    this.selectedByCorner = false;\n    \
this.selectedByRowHeader = /* @__PURE__ */ new Set();\n    \
this.selectedByColumnHeader = /* @__PURE__ */ new Set();\n    \
this.selectedRange = new range_default2((highlight, from, to) => {\n      \
return this.tableProps.createCellRange(highlight, from, to);\n    });\n    \
this.highlight = new highlight_default({\n      headerClassName: \
settings.currentHeaderClassName,\n      activeHeaderClassName: \
settings.activeHeaderClassName,\n      rowClassName: \
settings.currentRowClassName,\n      columnClassName: \
settings.currentColClassName,\n      disabledCellSelection: (row, column) => \
this.tableProps.isDisabledCellSelection(row, column),\n      \
cellCornerVisible: function() {\n        return \
_this.isCellCornerVisible(...arguments);\n      },\n      areaCornerVisible: \
function() {\n        return _this.isAreaCornerVisible(...arguments);\n      \
},\n      visualToRenderableCoords: (coords) => \
this.tableProps.visualToRenderableCoords(coords),\n      \
renderableToVisualCoords: (coords) => \
this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: \
(row, column) => this.tableProps.createCellCoords(row, column),\n      \
createCellRange: (highlight, from, to) => \
this.tableProps.createCellRange(highlight, from, to),\n      rowIndexMapper: \
() => this.tableProps.rowIndexMapper(),\n      columnIndexMapper: () => \
this.tableProps.columnIndexMapper()\n    });\n    this.transformation = new \
transformation_default(this.selectedRange, {\n      countRows: () => \
this.tableProps.countRowsTranslated(),\n      countCols: () => \
this.tableProps.countColsTranslated(),\n      visualToRenderableCoords: \
(coords) => this.tableProps.visualToRenderableCoords(coords),\n      \
renderableToVisualCoords: (coords) => \
this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: \
(row, column) => this.tableProps.createCellCoords(row, column),\n      \
fixedRowsBottom: () => settings.fixedRowsBottom,\n      minSpareRows: () => \
settings.minSpareRows,\n      minSpareCols: () => settings.minSpareCols,\n    \
  autoWrapRow: () => settings.autoWrapRow,\n      autoWrapCol: () => \
settings.autoWrapCol\n    });\n    \
this.transformation.addLocalHook(\"beforeTransformStart\", function() {\n     \
 for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < \
_len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return \
_this.runLocalHooks(\"beforeModifyTransformStart\", ...args);\n    });\n    \
this.transformation.addLocalHook(\"afterTransformStart\", function() {\n      \
for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 \
< _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      \
return _this.runLocalHooks(\"afterModifyTransformStart\", ...args);\n    \
});\n    this.transformation.addLocalHook(\"beforeTransformEnd\", function() \
{\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = \
0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      \
}\n      return _this.runLocalHooks(\"beforeModifyTransformEnd\", ...args);\n \
   });\n    this.transformation.addLocalHook(\"afterTransformEnd\", \
function() {\n      for (var _len4 = arguments.length, args = new \
Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = \
arguments[_key4];\n      }\n      return \
_this.runLocalHooks(\"afterModifyTransformEnd\", ...args);\n    });\n    \
this.transformation.addLocalHook(\"insertRowRequire\", function() {\n      \
for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 \
< _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      \
return _this.runLocalHooks(\"insertRowRequire\", ...args);\n    });\n    \
this.transformation.addLocalHook(\"insertColRequire\", function() {\n      \
for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 \
< _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      \
return _this.runLocalHooks(\"insertColRequire\", ...args);\n    });\n  }\n  \
/**\n   * Get data layer for current selection.\n   *\n   * @returns \
{SelectionRange}\n   */\n  getSelectedRange() {\n    return \
this.selectedRange;\n  }\n  /**\n   * Indicate that selection process began. \
It sets internaly `.inProgress` property to `true`.\n   */\n  begin() {\n    \
this.inProgress = true;\n  }\n  /**\n   * Indicate that selection process \
finished. It sets internaly `.inProgress` property to `false`.\n   */\n  \
finish() {\n    this.runLocalHooks(\"afterSelectionFinished\", \
Array.from(this.selectedRange));\n    this.inProgress = false;\n  }\n  /**\n  \
 * Check if the process of selecting the cell/cells is in progress.\n   *\n   \
* @returns {boolean}\n   */\n  isInProgress() {\n    return \
this.inProgress;\n  }\n  /**\n   * Starts selection range on given coordinate \
object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param \
{boolean} [multipleSelection] If `true`, selection will be worked in \
'multiple' mode. This option works\n   *                                      \
only when 'selectionMode' is set as 'multiple'. If the argument is not \
defined\n   *                                      the default trigger will \
be used.\n   * @param {boolean} [fragment=false] If `true`, the selection \
will be treated as a partial selection where the\n   *                        \
           `setRangeEnd` method won't be called on every `setRangeStart` \
call.\n   */\n  setRangeStart(coords, multipleSelection) {\n    let fragment \
= arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n   \
 const isMultipleMode = this.settings.selectionMode === \"multiple\";\n    \
const isMultipleSelection = isUndefined(multipleSelection) ? \
this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;\n   \
 const isRowNegative = coords.row < 0;\n    const isColumnNegative = \
coords.col < 0;\n    const selectedByCorner = isRowNegative && \
isColumnNegative;\n    const coordsClone = coords.clone();\n    \
this.selectedByCorner = selectedByCorner;\n    \
this.runLocalHooks(`beforeSetRangeStart${fragment ? \"Only\" : \"\"}`, \
coordsClone);\n    if (!isMultipleMode || isMultipleMode && \
!isMultipleSelection && isUndefined(multipleSelection)) {\n      \
this.selectedRange.clear();\n    }\n    \
this.selectedRange.add(coordsClone);\n    if (this.getLayerLevel() === 0) {\n \
     this.selectedByRowHeader.clear();\n      \
this.selectedByColumnHeader.clear();\n    }\n    if (!selectedByCorner && \
isColumnNegative) {\n      \
this.selectedByRowHeader.add(this.getLayerLevel());\n    }\n    if \
(!selectedByCorner && isRowNegative) {\n      \
this.selectedByColumnHeader.add(this.getLayerLevel());\n    }\n    if \
(!fragment) {\n      this.setRangeEnd(coords);\n    }\n  }\n  /**\n   * \
Starts selection range on given coordinate object.\n   *\n   * @param \
{CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] \
If `true`, selection will be worked in 'multiple' mode. This option works\n   \
*                                      only when 'selectionMode' is set as \
'multiple'. If the argument is not defined\n   *                              \
        the default trigger will be used.\n   */\n  setRangeStartOnly(coords, \
multipleSelection) {\n    this.setRangeStart(coords, multipleSelection, \
true);\n  }\n  /**\n   * Ends selection range on given coordinate object.\n   \
*\n   * @param {CellCoords} coords Visual coords.\n   */\n  \
setRangeEnd(coords) {\n    if (this.selectedRange.isEmpty()) {\n      \
return;\n    }\n    const coordsClone = coords.clone();\n    \
this.runLocalHooks(\"beforeSetRangeEnd\", coordsClone);\n    this.begin();\n  \
  const cellRange = this.selectedRange.current();\n    if \
(this.settings.selectionMode !== \"single\") {\n      \
cellRange.setTo(this.tableProps.createCellCoords(coordsClone.row, \
coordsClone.col));\n    }\n    this.highlight.getCell().clear();\n    if \
(this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {\n      \
this.highlight.getCell().add(this.selectedRange.current().highlight).commit()\
.syncWith(cellRange);\n    }\n    const layerLevel = this.getLayerLevel();\n  \
  if (layerLevel < this.highlight.layerLevel) {\n      \
arrayEach(this.highlight.getAreas(), (highlight) => void \
highlight.clear());\n      arrayEach(this.highlight.getHeaders(), (highlight) \
=> void highlight.clear());\n      \
arrayEach(this.highlight.getActiveHeaders(), (highlight) => void \
highlight.clear());\n    }\n    this.highlight.useLayerLevel(layerLevel);\n   \
 const areaHighlight = this.highlight.createOrGetArea();\n    const \
headerHighlight = this.highlight.createOrGetHeader();\n    const \
activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n    \
areaHighlight.clear();\n    headerHighlight.clear();\n    \
activeHeaderHighlight.clear();\n    if \
(this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && \
(this.isMultiple() || layerLevel >= 1)) {\n      \
areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      if \
(layerLevel === 1) {\n        const previousRange = \
this.selectedRange.previous();\n        \
this.highlight.useLayerLevel(layerLevel - \
1).createOrGetArea().add(previousRange.from).commit().syncWith(previousRange)\
;\n        this.highlight.useLayerLevel(layerLevel);\n      }\n    }\n    if \
(this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n      \
const areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;\n     \
 const areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;\n \
     let headerCellRange = cellRange;\n      if (areAnyRowsRendered || \
areAnyColumnsRendered) {\n        headerCellRange = cellRange.clone();\n      \
}\n      if (areAnyRowsRendered) {\n        headerCellRange.from.row = -1;\n  \
    }\n      if (areAnyColumnsRendered) {\n        headerCellRange.from.col = \
-1;\n      }\n      if (this.settings.selectionMode === \"single\") {\n       \
 if (this.isSelectedByAnyHeader()) {\n          \
headerCellRange.from.normalize();\n        }\n        \
headerHighlight.add(headerCellRange.from).commit();\n      } else {\n        \
headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();\n \
     }\n      if (this.isEntireRowSelected()) {\n        const isRowSelected \
= this.tableProps.countCols() === cellRange.getWidth();\n        if \
(isRowSelected) {\n          \
activeHeaderHighlight.add(this.tableProps.createCellCoords(cellRange.from.row\
, -1)).add(this.tableProps.createCellCoords(cellRange.to.row, \
-1)).commit();\n        }\n      }\n      if (this.isEntireColumnSelected()) \
{\n        const isColumnSelected = this.tableProps.countRows() === \
cellRange.getHeight();\n        if (isColumnSelected) {\n          \
activeHeaderHighlight.add(this.tableProps.createCellCoords(-1, \
cellRange.from.col)).add(this.tableProps.createCellCoords(-1, \
cellRange.to.col)).commit();\n        }\n      }\n    }\n    \
this.runLocalHooks(\"afterSetRangeEnd\", coords);\n  }\n  /**\n   * Returns \
information if we have a multiselection. This method check multiselection \
only on the latest layer of\n   * the selection.\n   *\n   * @returns \
{boolean}\n   */\n  isMultiple() {\n    const isMultipleListener = \
createObjectPropListener(!this.selectedRange.current().isSingle());\n    \
this.runLocalHooks(\"afterIsMultipleSelection\", isMultipleListener);\n    \
return isMultipleListener.value;\n  }\n  /**\n   * Selects cell relative to \
the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows \
number to move, value can be passed as negative number.\n   * @param {number} \
colDelta Columns number to move, value can be passed as negative number.\n   \
* @param {boolean} [force=false] If `true` the new rows/columns will be \
created if necessary. Otherwise, row/column will\n   *                        \
be created according to `minSpareRows/minSpareCols` settings of \
Handsontable.\n   */\n  transformStart(rowDelta, colDelta) {\n    let force = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    \
this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, \
force));\n  }\n  /**\n   * Sets selection end cell relative to the current \
selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows \
number to move, value can be passed as negative number.\n   * @param {number} \
colDelta Columns number to move, value can be passed as negative number.\n   \
*/\n  transformEnd(rowDelta, colDelta) {\n    \
this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n  \
}\n  /**\n   * Returns currently used layer level.\n   *\n   * @returns \
{number} Returns layer level starting from 0. If no selection was added to \
the table -1 is returned.\n   */\n  getLayerLevel() {\n    return \
this.selectedRange.size() - 1;\n  }\n  /**\n   * Returns `true` if currently \
there is a selection on the screen, `false` otherwise.\n   *\n   * @returns \
{boolean}\n   */\n  isSelected() {\n    return \
!this.selectedRange.isEmpty();\n  }\n  /**\n   * Returns `true` if the \
selection was applied by clicking to the row header. If the `layerLevel`\n   \
* argument is passed then only that layer will be checked. Otherwise, it \
checks if any row header\n   * was clicked on any selection layer level.\n   \
*\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer \
level to check.\n   * @returns {boolean}\n   */\n  isSelectedByRowHeader() \
{\n    let layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : this.getLayerLevel();\n    return \
!this.isSelectedByCorner(layerLevel) && \
this.isEntireRowSelected(layerLevel);\n  }\n  /**\n   * Returns `true` if the \
selection consists of entire rows (including their headers). If the \
`layerLevel`\n   * argument is passed then only that layer will be checked. \
Otherwise, it checks the selection for all layers.\n   *\n   * @param \
{number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n  \
 * @returns {boolean}\n   */\n  isEntireRowSelected() {\n    let layerLevel = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
this.getLayerLevel();\n    return layerLevel === -1 ? \
this.selectedByRowHeader.size > 0 : \
this.selectedByRowHeader.has(layerLevel);\n  }\n  /**\n   * Returns `true` if \
the selection was applied by clicking to the column header. If the \
`layerLevel`\n   * argument is passed then only that layer will be checked. \
Otherwise, it checks if any column header\n   * was clicked on any selection \
layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] \
Selection layer level to check.\n   * @returns {boolean}\n   */\n  \
isSelectedByColumnHeader() {\n    let layerLevel = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();\n    return \
!this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);\n  }\n \
 /**\n   * Returns `true` if the selection consists of entire columns \
(including their headers). If the `layerLevel`\n   * argument is passed then \
only that layer will be checked. Otherwise, it checks the selection for all \
layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] \
Selection layer level to check.\n   * @returns {boolean}\n   */\n  \
isEntireColumnSelected() {\n    let layerLevel = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();\n    return \
layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : \
this.selectedByColumnHeader.has(layerLevel);\n  }\n  /**\n   * Returns `true` \
if the selection was applied by clicking on the row or column header on any \
layer level.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByAnyHeader() \
{\n    return this.isSelectedByRowHeader(-1) || \
this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n  }\n  /**\n \
  * Returns `true` if the selection was applied by clicking on the left-top \
corner overlay.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByCorner() \
{\n    return this.selectedByCorner;\n  }\n  /**\n   * Returns `true` if \
coords is within selection coords. This method iterates through all selection \
layers to check if\n   * the coords object is within selection range.\n   *\n \
  * @param {CellCoords} coords The CellCoords instance with defined visual \
coordinates.\n   * @returns {boolean}\n   */\n  inInSelection(coords) {\n    \
return this.selectedRange.includes(coords);\n  }\n  /**\n   * Returns `true` \
if the cell corner should be visible.\n   *\n   * @private\n   * @returns \
{boolean} `true` if the corner element has to be visible, `false` \
otherwise.\n   */\n  isCellCornerVisible() {\n    return \
this.settings.fillHandle && !this.tableProps.isEditorOpened() && \
!this.isMultiple();\n  }\n  /**\n   * Returns `true` if the area corner \
should be visible.\n   *\n   * @param {number} layerLevel The layer level.\n  \
 * @returns {boolean} `true` if the corner element has to be visible, `false` \
otherwise.\n   */\n  isAreaCornerVisible(layerLevel) {\n    if \
(Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n     \
 return false;\n    }\n    return this.settings.fillHandle && \
!this.tableProps.isEditorOpened() && this.isMultiple();\n  }\n  /**\n   * \
Clear the selection by resetting the collected ranges and highlights.\n   \
*/\n  clear() {\n    this.selectedRange.clear();\n    \
this.highlight.clear();\n  }\n  /**\n   * Deselects all selected cells.\n   \
*/\n  deselect() {\n    if (!this.isSelected()) {\n      return;\n    }\n    \
this.inProgress = false;\n    this.clear();\n    \
this.runLocalHooks(\"afterDeselect\");\n  }\n  /**\n   * Select all cells.\n  \
 *\n   * @param {boolean} [includeRowHeaders=false] `true` If the selection \
should include the row headers, `false`\n   * otherwise.\n   * @param \
{boolean} [includeColumnHeaders=false] `true` If the selection should include \
the column headers, `false`\n   * otherwise.\n   */\n  selectAll() {\n    let \
includeRowHeaders = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : false;\n    let includeColumnHeaders = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : false;\n    const nrOfRows = \
this.tableProps.countRows();\n    const nrOfColumns = \
this.tableProps.countCols();\n    if (!includeRowHeaders && \
!includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {\n      \
return;\n    }\n    const startCoords = \
this.tableProps.createCellCoords(includeColumnHeaders ? -1 : 0, \
includeRowHeaders ? -1 : 0);\n    const endCoords = \
this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);\n    \
this.clear();\n    this.setRangeStartOnly(startCoords);\n    \
this.selectedByRowHeader.add(this.getLayerLevel());\n    \
this.selectedByColumnHeader.add(this.getLayerLevel());\n    \
this.setRangeEnd(endCoords);\n    this.finish();\n  }\n  /**\n   * Make \
multiple, non-contiguous selection specified by `row` and `column` values or \
a range of cells\n   * finishing at `endRow`, `endColumn`. The method \
supports two input formats, first as an array of arrays such\n   * as \
`[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array \
of CellRange objects.\n   * If the passed ranges have another format the \
exception will be thrown.\n   *\n   * @param {Array[]|CellRange[]} \
selectionRanges The coordinates which define what the cells should be \
selected.\n   * @returns {boolean} Returns `true` if selection was \
successful, `false` otherwise.\n   */\n  selectCells(selectionRanges) {\n    \
const selectionType = detectSelectionType(selectionRanges);\n    if \
(selectionType === SELECTION_TYPE_EMPTY) {\n      return false;\n    } else \
if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n      throw new \
Error(toSingleLine`Unsupported format of the selection ranges was passed. To \
select cells pass\\x20\n        the coordinates as an array of arrays \
([[rowStart, columnStart/columnPropStart, rowEnd,\\x20\n        \
columnEnd/columnPropEnd]]) or as an array of CellRange objects.`);\n    }\n   \
 const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, \
{\n      propToCol: (prop) => this.tableProps.propToCol(prop),\n      \
keepDirection: true\n    });\n    const nrOfRows = \
this.tableProps.countRows();\n    const nrOfColumns = \
this.tableProps.countCols();\n    const isValid = \
!selectionRanges.some((selection) => {\n      const [rowStart, columnStart, \
rowEnd, columnEnd] = selectionSchemaNormalizer(selection);\n      const \
_isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, \
nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, \
nrOfColumns);\n      return !_isValid;\n    });\n    if (isValid) {\n      \
this.clear();\n      arrayEach(selectionRanges, (selection) => {\n        \
const [rowStart, columnStart, rowEnd, columnEnd] = \
selectionSchemaNormalizer(selection);\n        \
this.setRangeStartOnly(this.tableProps.createCellCoords(rowStart, \
columnStart), false);\n        \
this.setRangeEnd(this.tableProps.createCellCoords(rowEnd, columnEnd));\n      \
  this.finish();\n      });\n    }\n    return isValid;\n  }\n  /**\n   * \
Select column specified by `startColumn` visual index or column property or a \
range of columns finishing at\n   * `endColumn`.\n   *\n   * @param \
{number|string} startColumn Visual column index or column property from which \
the selection starts.\n   * @param {number|string} [endColumn] Visual column \
index or column property from to the selection finishes.\n   * @param \
{number} [headerLevel=-1] A row header index that triggers the column \
selection. The value can\n   *                                  take -1 to \
-N, where -1 means the header closest to the cells.\n   *\n   * @returns \
{boolean} Returns `true` if selection was successful, `false` otherwise.\n   \
*/\n  selectColumns(startColumn) {\n    let endColumn = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : startColumn;\n    let headerLevel \
= arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;\n    \
const start = typeof startColumn === \"string\" ? \
this.tableProps.propToCol(startColumn) : startColumn;\n    const end = typeof \
endColumn === \"string\" ? this.tableProps.propToCol(endColumn) : \
endColumn;\n    const nrOfColumns = this.tableProps.countCols();\n    const \
nrOfRows = this.tableProps.countRows();\n    const isValid = \
isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);\n    if \
(isValid) {\n      \
this.setRangeStartOnly(this.tableProps.createCellCoords(headerLevel, \
start));\n      this.setRangeEnd(this.tableProps.createCellCoords(nrOfRows - \
1, end));\n      this.finish();\n    }\n    return isValid;\n  }\n  /**\n   * \
Select row specified by `startRow` visual index or a range of rows finishing \
at `endRow`.\n   *\n   * @param {number} startRow Visual row index from which \
the selection starts.\n   * @param {number} [endRow] Visual row index from to \
the selection finishes.\n   * @param {number} [headerLevel=-1] A column \
header index that triggers the row selection.\n   *                           \
       The value can take -1 to -N, where -1 means the header\n   *           \
                       closest to the cells.\n   * @returns {boolean} Returns \
`true` if selection was successful, `false` otherwise.\n   */\n  \
selectRows(startRow) {\n    let endRow = arguments.length > 1 && arguments[1] \
!== void 0 ? arguments[1] : startRow;\n    let headerLevel = arguments.length \
> 2 && arguments[2] !== void 0 ? arguments[2] : -1;\n    const nrOfRows = \
this.tableProps.countRows();\n    const nrOfColumns = \
this.tableProps.countCols();\n    const isValid = isValidCoord(startRow, \
nrOfRows) && isValidCoord(endRow, nrOfRows);\n    if (isValid) {\n      \
this.setRangeStartOnly(this.tableProps.createCellCoords(startRow, \
headerLevel));\n      \
this.setRangeEnd(this.tableProps.createCellCoords(endRow, nrOfColumns - \
1));\n      this.finish();\n    }\n    return isValid;\n  }\n  /**\n   * \
Rewrite the rendered state of the selection as visual selection may have a \
new representation in the DOM.\n   */\n  refresh() {\n    const \
customSelections = this.highlight.getCustomSelections();\n    \
customSelections.forEach((customSelection) => {\n      \
customSelection.commit();\n    });\n    if (!this.isSelected()) {\n      \
return;\n    }\n    const cellHighlight = this.highlight.getCell();\n    \
const currentLayer = this.getLayerLevel();\n    \
cellHighlight.commit().syncWith(this.selectedRange.current());\n    for (let \
layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n  \
    this.highlight.useLayerLevel(layerLevel);\n      const areaHighlight = \
this.highlight.createOrGetArea();\n      const headerHighlight = \
this.highlight.createOrGetHeader();\n      const activeHeaderHighlight = \
this.highlight.createOrGetActiveHeader();\n      areaHighlight.commit();\n    \
  headerHighlight.commit();\n      activeHeaderHighlight.commit();\n    }\n   \
 this.highlight.useLayerLevel(currentLayer);\n  }\n};\nmixin(Selection2, \
localHooks_default);\nvar selection_default2 = Selection2;\n\n// \
node_modules/handsontable/3rdparty/SheetClip/SheetClip.mjs\nvar \
regUniversalNewLine = /^(\\r\\n|\\n\\r|\\r|\\n)/;\nvar regNextCellNoQuotes = \
/^[^\\t\\r\\n]+/;\nvar regNextEmptyCell = /^\\t/;\nfunction parse(str) {\n  \
const arr = [[\"\"]];\n  if (str.length === 0) {\n    return arr;\n  }\n  let \
column = 0;\n  let row = 0;\n  let lastLength;\n  while (str.length > 0) {\n  \
  if (lastLength === str.length) {\n      break;\n    }\n    lastLength = \
str.length;\n    if (str.match(regNextEmptyCell)) {\n      str = \
str.replace(regNextEmptyCell, \"\");\n      column += 1;\n      \
arr[row][column] = \"\";\n    } else if (str.match(regUniversalNewLine)) {\n  \
    str = str.replace(regUniversalNewLine, \"\");\n      column = 0;\n      \
row += 1;\n      arr[row] = [\"\"];\n    } else {\n      let nextCell = \
\"\";\n      if (str.startsWith('\"')) {\n        let quoteNo = 0;\n        \
let isStillCell = true;\n        while (isStillCell) {\n          const \
nextChar = str.slice(0, 1);\n          if (nextChar === '\"') {\n            \
quoteNo += 1;\n          }\n          nextCell += nextChar;\n          str = \
str.slice(1);\n          if (str.length === 0 || str.match(/^[\\t\\r\\n]/) && \
quoteNo % 2 === 0) {\n            isStillCell = false;\n          }\n        \
}\n        nextCell = nextCell.replace(/^\"/, \"\").replace(/\"$/, \
\"\").replace(/[\"]*/g, (match) => new Array(Math.floor(match.length / \
2)).fill('\"').join(\"\"));\n      } else {\n        const matchedText = \
str.match(regNextCellNoQuotes);\n        nextCell = matchedText ? \
matchedText[0] : \"\";\n        str = str.slice(nextCell.length);\n      }\n  \
    arr[row][column] = nextCell;\n    }\n  }\n  return arr;\n}\nfunction \
stringify2(arr) {\n  let r;\n  let rLen;\n  let c;\n  let cLen;\n  let str = \
\"\";\n  let val;\n  for (r = 0, rLen = arr.length; r < rLen; r += 1) {\n    \
cLen = arr[r].length;\n    for (c = 0; c < cLen; c += 1) {\n      if (c > 0) \
{\n        str += \"\t\";\n      }\n      val = arr[r][c];\n      if (typeof \
val === \"string\") {\n        if (val.indexOf(\"\\n\") > -1) {\n          \
str += `\"${val.replace(/\"/g, '\"\"')}\"`;\n        } else {\n          str \
+= val;\n        }\n      } else if (val === null || val === void 0) {\n      \
  str += \"\";\n      } else {\n        str += val;\n      }\n    }\n    if \
(r !== rLen - 1) {\n      str += \"\\n\";\n    }\n  }\n  return str;\n}\n\n// \
node_modules/handsontable/dataMap/dataMap.mjs\nvar DataMap = class _DataMap \
{\n  /**\n   * @type {number}\n   */\n  static get DESTINATION_RENDERER() {\n \
   return 1;\n  }\n  /**\n   * @type {number}\n   */\n  static get \
DESTINATION_CLIPBOARD_GENERATOR() {\n    return 2;\n  }\n  /**\n   * @param \
{object} instance Instance of Handsontable.\n   * @param {Array} data Array \
of arrays or array of objects containing data.\n   * @param {MetaManager} \
metaManager The meta manager instance.\n   */\n  constructor(instance, data2, \
metaManager) {\n    this.instance = instance;\n    this.metaManager = \
metaManager;\n    this.tableMeta = metaManager.getTableMeta();\n    \
this.dataSource = data2;\n    this.duckSchema = this.createDuckSchema();\n    \
this.colToPropCache = void 0;\n    this.propToColCache = void 0;\n    \
this.createMap();\n  }\n  /**\n   * Generates cache for property to and from \
column addressation.\n   */\n  createMap() {\n    const schema = \
this.getSchema();\n    if (typeof schema === \"undefined\") {\n      throw \
new Error(\"trying to create `columns` definition but you didn't provide \
`schema` nor `data`\");\n    }\n    const columns = this.tableMeta.columns;\n \
   let i;\n    this.colToPropCache = [];\n    this.propToColCache = /* \
@__PURE__ */ new Map();\n    if (columns) {\n      let columnsLen = 0;\n      \
let filteredIndex = 0;\n      let columnsAsFunc = false;\n      if (typeof \
columns === \"function\") {\n        const schemaLen = \
deepObjectSize(schema);\n        columnsLen = schemaLen > 0 ? schemaLen : \
this.countFirstRowKeys();\n        columnsAsFunc = true;\n      } else {\n    \
    const maxCols = this.tableMeta.maxCols;\n        columnsLen = \
Math.min(maxCols, columns.length);\n      }\n      for (i = 0; i < \
columnsLen; i++) {\n        const column = columnsAsFunc ? columns(i) : \
columns[i];\n        if (isObject(column)) {\n          if (typeof \
column.data !== \"undefined\") {\n            const index2 = columnsAsFunc ? \
filteredIndex : i;\n            this.colToPropCache[index2] = column.data;\n  \
          this.propToColCache.set(column.data, index2);\n          }\n        \
  filteredIndex += 1;\n        }\n      }\n    } else {\n      \
this.recursiveDuckColumns(schema);\n    }\n  }\n  /**\n   * Get the amount of \
physical columns in the first data row.\n   *\n   * @returns {number} Amount \
of physical columns in the first data row.\n   */\n  countFirstRowKeys() {\n  \
  return countFirstRowKeys(this.dataSource);\n  }\n  /**\n   * Generates \
columns' translation cache.\n   *\n   * @param {object} schema An object to \
generate schema from.\n   * @param {number} lastCol The column index.\n   * \
@param {number} parent The property cache for recursive calls.\n   * @returns \
{number}\n   */\n  recursiveDuckColumns(schema, lastCol, parent2) {\n    let \
lastColumn = lastCol;\n    let propertyParent = parent2;\n    let prop;\n    \
if (typeof lastColumn === \"undefined\") {\n      lastColumn = 0;\n      \
propertyParent = \"\";\n    }\n    if (typeof schema === \"object\" && \
!Array.isArray(schema)) {\n      objectEach(schema, (value, key) => {\n       \
 if (value === null) {\n          prop = propertyParent + key;\n          \
this.colToPropCache.push(prop);\n          this.propToColCache.set(prop, \
lastColumn);\n          lastColumn += 1;\n        } else {\n          \
lastColumn = this.recursiveDuckColumns(value, lastColumn, `${key}.`);\n       \
 }\n      });\n    }\n    return lastColumn;\n  }\n  /**\n   * Returns \
property name that corresponds with the given column index.\n   *\n   * \
@param {string|number} column Visual column index or another passed \
argument.\n   * @returns {string|number} Column property, physical column \
index or passed argument.\n   */\n  colToProp(column) {\n    if \
(Number.isInteger(column) === false) {\n      return column;\n    }\n    \
const physicalColumn = this.instance.toPhysicalColumn(column);\n    if \
(physicalColumn === null) {\n      return column;\n    }\n    if \
(this.colToPropCache && isDefined(this.colToPropCache[physicalColumn])) {\n   \
   return this.colToPropCache[physicalColumn];\n    }\n    return \
physicalColumn;\n  }\n  /**\n   * Translates property into visual column \
index.\n   *\n   * @param {string|number} prop Column property which may be \
also a physical column index.\n   * @returns {string|number} Visual column \
index or passed argument.\n   */\n  propToCol(prop) {\n    const \
cachedPhysicalIndex = this.propToColCache.get(prop);\n    if \
(isDefined(cachedPhysicalIndex)) {\n      return \
this.instance.toVisualColumn(cachedPhysicalIndex);\n    }\n    const \
visualColumn = this.instance.toVisualColumn(prop);\n    if (visualColumn === \
null) {\n      return prop;\n    }\n    return visualColumn;\n  }\n  /**\n   \
* Returns data's schema.\n   *\n   * @returns {object}\n   */\n  getSchema() \
{\n    const schema = this.tableMeta.dataSchema;\n    if (schema) {\n      if \
(typeof schema === \"function\") {\n        return schema();\n      }\n      \
return schema;\n    }\n    return this.duckSchema;\n  }\n  /**\n   * Creates \
the duck schema based on the current dataset.\n   *\n   * @returns \
{Array|object}\n   */\n  createDuckSchema() {\n    return this.dataSource && \
this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};\n  }\n  /**\n   * \
Refresh the data schema.\n   */\n  refreshDuckSchema() {\n    this.duckSchema \
= this.createDuckSchema();\n  }\n  /**\n   * Creates row at the bottom of the \
data array.\n   *\n   * @param {number} [index] Physical index of the row \
before which the new row will be inserted.\n   * @param {number} [amount=1] \
An amount of rows to add.\n   * @param {object} [options] Additional options \
for created rows.\n   * @param {string} [options.source] Source of method \
call.\n   * @param {'above'|'below'} [options.mode] Sets where the row is \
inserted: above or below the passed index.\n   * @fires \
Hooks#afterCreateRow\n   * @returns {number} Returns number of created \
rows.\n   */\n  createRow(index2) {\n    let amount = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : 1;\n    let {\n      source,\n      \
mode = \"above\"\n    } = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : {};\n    const sourceRowsCount = \
this.instance.countSourceRows();\n    let physicalRowIndex = \
sourceRowsCount;\n    let numberOfCreatedRows = 0;\n    let rowIndex = \
index2;\n    if (typeof rowIndex !== \"number\" || rowIndex >= \
sourceRowsCount) {\n      rowIndex = sourceRowsCount;\n    }\n    if \
(rowIndex < this.instance.countRows()) {\n      physicalRowIndex = \
this.instance.toPhysicalRow(rowIndex);\n    }\n    const continueProcess = \
this.instance.runHooks(\"beforeCreateRow\", rowIndex, amount, source);\n    \
if (continueProcess === false || physicalRowIndex === null) {\n      return \
{\n        delta: 0\n      };\n    }\n    const maxRows = \
this.tableMeta.maxRows;\n    const columnCount = this.getSchema().length;\n   \
 const rowsToAdd = [];\n    while (numberOfCreatedRows < amount && \
sourceRowsCount + numberOfCreatedRows < maxRows) {\n      let row = null;\n   \
   if (this.instance.dataType === \"array\") {\n        if \
(this.tableMeta.dataSchema) {\n          row = deepClone(this.getSchema());\n \
       } else {\n          row = [];\n          rangeEach(columnCount - 1, () \
=> row.push(null));\n        }\n      } else if (this.instance.dataType === \
\"function\") {\n        row = this.tableMeta.dataSchema(rowIndex + \
numberOfCreatedRows);\n      } else {\n        row = {};\n        \
deepExtend(row, this.getSchema());\n      }\n      rowsToAdd.push(row);\n     \
 numberOfCreatedRows += 1;\n    }\n    \
this.instance.rowIndexMapper.insertIndexes(rowIndex, numberOfCreatedRows);\n  \
  if (mode === \"below\") {\n      physicalRowIndex = \
Math.min(physicalRowIndex + 1, sourceRowsCount);\n    }\n    \
this.spliceData(physicalRowIndex, 0, rowsToAdd);\n    const newVisualRowIndex \
= this.instance.toVisualRow(physicalRowIndex);\n    if \
(this.instance.countSourceRows() === rowsToAdd.length) {\n      \
this.instance.columnIndexMapper.initToLength(this.instance.getInitialColumnCo\
unt());\n    }\n    if (numberOfCreatedRows > 0) {\n      if (index2 === void \
0 || index2 === null) {\n        this.metaManager.createRow(null, \
numberOfCreatedRows);\n      } else if (source !== \"auto\") {\n        \
this.metaManager.createRow(physicalRowIndex, amount);\n      }\n    }\n    \
this.instance.runHooks(\"afterCreateRow\", newVisualRowIndex, \
numberOfCreatedRows, source);\n    this.instance.forceFullRender = true;\n    \
return {\n      delta: numberOfCreatedRows,\n      startPhysicalIndex: \
physicalRowIndex\n    };\n  }\n  /**\n   * Creates column at the right of the \
data array.\n   *\n   * @param {number} [index] Visual index of the column \
before which the new column will be inserted.\n   * @param {number} \
[amount=1] An amount of columns to add.\n   * @param {object} [options] \
Additional options for created columns.\n   * @param {string} \
[options.source] Source of method call.\n   * @param {'start'|'end'} \
[options.mode] Sets where the column is inserted: at the start (left in \
[LTR](@/api/options.md#layoutdirection), right in \
[RTL](@/api/options.md#layoutdirection)) or at the end (right in LTR, left in \
LTR)\n   * the passed index.\n   * @fires Hooks#afterCreateCol\n   * @returns \
{number} Returns number of created columns.\n   */\n  createCol(index2) {\n   \
 let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] \
: 1;\n    let {\n      source,\n      mode = \"start\"\n    } = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    if \
(!this.instance.isColumnModificationAllowed()) {\n      throw new \
Error(\"Cannot create new column. When data source in an object, you can only \
have as much columns as defined in first data row, data schema or in the \
'columns' setting.If you want to be able to add new columns, you have to use \
array datasource.\");\n    }\n    const dataSource = this.dataSource;\n    \
const maxCols = this.tableMeta.maxCols;\n    const countSourceCols = \
this.instance.countSourceCols();\n    let columnIndex = index2;\n    if \
(typeof columnIndex !== \"number\" || columnIndex >= countSourceCols) {\n     \
 columnIndex = countSourceCols;\n    }\n    const continueProcess = \
this.instance.runHooks(\"beforeCreateCol\", columnIndex, amount, source);\n   \
 if (continueProcess === false) {\n      return {\n        delta: 0\n      \
};\n    }\n    let physicalColumnIndex = countSourceCols;\n    if \
(columnIndex < this.instance.countCols()) {\n      physicalColumnIndex = \
this.instance.toPhysicalColumn(columnIndex);\n    }\n    const \
numberOfSourceRows = this.instance.countSourceRows();\n    let nrOfColumns = \
this.instance.countCols();\n    let numberOfCreatedCols = 0;\n    let \
currentIndex = physicalColumnIndex;\n    if (mode === \"end\") {\n      \
currentIndex = Math.min(currentIndex + 1, countSourceCols);\n    }\n    const \
startPhysicalIndex = currentIndex;\n    while (numberOfCreatedCols < amount \
&& nrOfColumns < maxCols) {\n      if (typeof columnIndex !== \"number\" || \
columnIndex >= nrOfColumns) {\n        if (numberOfSourceRows > 0) {\n        \
  for (let row = 0; row < numberOfSourceRows; row += 1) {\n            if \
(typeof dataSource[row] === \"undefined\") {\n              dataSource[row] = \
[];\n            }\n            dataSource[row].push(null);\n          }\n    \
    } else {\n          dataSource.push([null]);\n        }\n      } else {\n \
       for (let row = 0; row < numberOfSourceRows; row++) {\n          \
dataSource[row].splice(currentIndex, 0, null);\n        }\n      }\n      \
numberOfCreatedCols += 1;\n      currentIndex += 1;\n      nrOfColumns += \
1;\n    }\n    this.instance.columnIndexMapper.insertIndexes(columnIndex, \
numberOfCreatedCols);\n    if (numberOfCreatedCols > 0) {\n      if (index2 \
=== void 0 || index2 === null) {\n        this.metaManager.createColumn(null, \
numberOfCreatedCols);\n      } else if (source !== \"auto\") {\n        \
this.metaManager.createColumn(startPhysicalIndex, amount);\n      }\n    }\n  \
  const newVisualColumnIndex = \
this.instance.toVisualColumn(startPhysicalIndex);\n    \
this.instance.runHooks(\"afterCreateCol\", newVisualColumnIndex, \
numberOfCreatedCols, source);\n    this.instance.forceFullRender = true;\n    \
this.refreshDuckSchema();\n    return {\n      delta: numberOfCreatedCols,\n  \
    startPhysicalIndex\n    };\n  }\n  /**\n   * Removes row from the data \
array.\n   *\n   * @fires Hooks#beforeRemoveRow\n   * @fires \
Hooks#afterRemoveRow\n   * @param {number} [index] Visual index of the row to \
be removed. If not provided, the last row will be removed.\n   * @param \
{number} [amount=1] Amount of the rows to be removed. If not provided, one \
row will be removed.\n   * @param {string} [source] Source of method call.\n  \
 * @returns {boolean} Returns `false` when action was cancelled, otherwise \
`true`.\n   */\n  removeRow(index2) {\n    let amount = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : 1;\n    let source = \
arguments.length > 2 ? arguments[2] : void 0;\n    let rowIndex = \
Number.isInteger(index2) ? index2 : -amount;\n    const \
removedPhysicalIndexes = this.visualRowsToPhysical(rowIndex, amount);\n    \
const sourceRowsLength = this.instance.countSourceRows();\n    rowIndex = \
(sourceRowsLength + rowIndex) % sourceRowsLength;\n    const \
actionWasNotCancelled = this.instance.runHooks(\"beforeRemoveRow\", rowIndex, \
removedPhysicalIndexes.length, removedPhysicalIndexes, source);\n    if \
(actionWasNotCancelled === false) {\n      return false;\n    }\n    const \
numberOfRemovedIndexes = removedPhysicalIndexes.length;\n    \
this.filterData(rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes);\n  \
  if (rowIndex < this.instance.countRows()) {\n      \
this.instance.rowIndexMapper.removeIndexes(removedPhysicalIndexes);\n      \
const customDefinedColumns = isDefined(this.tableMeta.columns) || \
isDefined(this.tableMeta.dataSchema);\n      if \
(this.instance.rowIndexMapper.getNotTrimmedIndexesLength() === 0 && \
customDefinedColumns === false) {\n        \
this.instance.columnIndexMapper.setIndexesSequence([]);\n      }\n    }\n    \
const descendingPhysicalRows = removedPhysicalIndexes.slice(0).sort((a, b) => \
b - a);\n    descendingPhysicalRows.forEach((rowPhysicalIndex) => {\n      \
this.metaManager.removeRow(rowPhysicalIndex, 1);\n    });\n    \
this.instance.runHooks(\"afterRemoveRow\", rowIndex, numberOfRemovedIndexes, \
removedPhysicalIndexes, source);\n    this.instance.forceFullRender = true;\n \
   return true;\n  }\n  /**\n   * Removes column from the data array.\n   *\n \
  * @fires Hooks#beforeRemoveCol\n   * @fires Hooks#afterRemoveCol\n   * \
@param {number} [index] Visual index of the column to be removed. If not \
provided, the last column will be removed.\n   * @param {number} [amount=1] \
Amount of the columns to be removed. If not provided, one column will be \
removed.\n   * @param {string} [source] Source of method call.\n   * @returns \
{boolean} Returns `false` when action was cancelled, otherwise `true`.\n   \
*/\n  removeCol(index2) {\n    let amount = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : 1;\n    let source = \
arguments.length > 2 ? arguments[2] : void 0;\n    if (this.instance.dataType \
=== \"object\" || this.tableMeta.columns) {\n      throw new Error(\"cannot \
remove column with object data source or columns option specified\");\n    \
}\n    let columnIndex = typeof index2 !== \"number\" ? -amount : index2;\n   \
 columnIndex = (this.instance.countCols() + columnIndex) % \
this.instance.countCols();\n    const removedPhysicalIndexes = \
this.visualColumnsToPhysical(columnIndex, amount);\n    const \
descendingPhysicalColumns = removedPhysicalIndexes.slice(0).sort((a, b) => b \
- a);\n    const actionWasNotCancelled = \
this.instance.runHooks(\"beforeRemoveCol\", columnIndex, amount, \
removedPhysicalIndexes, source);\n    if (actionWasNotCancelled === false) \
{\n      return false;\n    }\n    let isTableUniform = true;\n    const \
removedColumnsCount = descendingPhysicalColumns.length;\n    const data2 = \
this.dataSource;\n    for (let c = 0; c < removedColumnsCount; c++) {\n      \
if (isTableUniform && removedPhysicalIndexes[0] !== removedPhysicalIndexes[c] \
- c) {\n        isTableUniform = false;\n      }\n    }\n    if \
(isTableUniform) {\n      for (let r = 0, rlen = \
this.instance.countSourceRows(); r < rlen; r++) {\n        \
data2[r].splice(removedPhysicalIndexes[0], amount);\n        if (r === 0) {\n \
         this.metaManager.removeColumn(removedPhysicalIndexes[0], amount);\n  \
      }\n      }\n    } else {\n      for (let r = 0, rlen = \
this.instance.countSourceRows(); r < rlen; r++) {\n        for (let c = 0; c \
< removedColumnsCount; c++) {\n          \
data2[r].splice(descendingPhysicalColumns[c], 1);\n          if (r === 0) {\n \
           this.metaManager.removeColumn(descendingPhysicalColumns[c], 1);\n  \
        }\n        }\n      }\n    }\n    if (columnIndex < \
this.instance.countCols()) {\n      \
this.instance.columnIndexMapper.removeIndexes(removedPhysicalIndexes);\n      \
if (this.instance.columnIndexMapper.getNotTrimmedIndexesLength() === 0) {\n   \
     this.instance.rowIndexMapper.setIndexesSequence([]);\n      }\n    }\n   \
 this.instance.runHooks(\"afterRemoveCol\", columnIndex, amount, \
removedPhysicalIndexes, source);\n    this.instance.forceFullRender = true;\n \
   this.refreshDuckSchema();\n    return true;\n  }\n  /**\n   * Add/Removes \
data from the column.\n   *\n   * @param {number} col Physical index of \
column in which do you want to do splice.\n   * @param {number} index Index \
at which to start changing the array. If negative, will begin that many \
elements from the end.\n   * @param {number} amount An integer indicating the \
number of old array elements to remove. If amount is 0, no elements are \
removed.\n   * @param {Array} [elements] The new columns to add.\n   * \
@returns {Array} Returns removed portion of columns.\n   */\n  spliceCol(col, \
index2, amount) {\n    const colData = this.instance.getDataAtCol(col);\n    \
const removed = colData.slice(index2, index2 + amount);\n    const after = \
colData.slice(index2 + amount);\n    for (var _len = arguments.length, \
elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) \
{\n      elements[_key - 3] = arguments[_key];\n    }\n    \
extendArray(elements, after);\n    let i = 0;\n    while (i < amount) {\n     \
 elements.push(null);\n      i += 1;\n    }\n    to2dArray(elements);\n    \
this.instance.populateFromArray(index2, col, elements, null, null, \
\"spliceCol\");\n    return removed;\n  }\n  /**\n   * Add/Removes data from \
the row.\n   *\n   * @param {number} row Physical index of row in which do \
you want to do splice.\n   * @param {number} index Index at which to start \
changing the array. If negative, will begin that many elements from the \
end.\n   * @param {number} amount An integer indicating the number of old \
array elements to remove. If amount is 0, no elements are removed.\n   * \
@param {Array} [elements] The new rows to add.\n   * @returns {Array} Returns \
removed portion of rows.\n   */\n  spliceRow(row, index2, amount) {\n    \
const rowData = this.instance.getSourceDataAtRow(row);\n    const removed = \
rowData.slice(index2, index2 + amount);\n    const after = \
rowData.slice(index2 + amount);\n    for (var _len2 = arguments.length, \
elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; \
_key2++) {\n      elements[_key2 - 3] = arguments[_key2];\n    }\n    \
extendArray(elements, after);\n    let i = 0;\n    while (i < amount) {\n     \
 elements.push(null);\n      i += 1;\n    }\n    \
this.instance.populateFromArray(row, index2, [elements], null, null, \
\"spliceRow\");\n    return removed;\n  }\n  /**\n   * Add/remove row(s) \
to/from the data source.\n   *\n   * @param {number} index Physical index of \
the element to add/remove.\n   * @param {number} deleteCount Number of rows \
to remove.\n   * @param {Array<object>} elements Row elements to be added.\n  \
 */\n  spliceData(index2, deleteCount, elements) {\n    const \
continueSplicing = this.instance.runHooks(\"beforeDataSplice\", index2, \
deleteCount, elements);\n    if (continueSplicing !== false) {\n      const \
newData = [...this.dataSource.slice(0, index2), ...elements, \
...this.dataSource.slice(index2)];\n      this.dataSource.length = 0;\n      \
newData.forEach((row) => this.dataSource.push(row));\n    }\n  }\n  /**\n   * \
Filter unwanted data elements from the data source.\n   *\n   * @param \
{number} index Visual index of the element to remove.\n   * @param {number} \
amount Number of rows to add/remove.\n   * @param {number} physicalRows \
Physical row indexes.\n   */\n  filterData(index2, amount, physicalRows) {\n  \
  let data2 = this.instance.runHooks(\"filterData\", index2, amount, \
physicalRows);\n    if (Array.isArray(data2) === false) {\n      data2 = \
this.dataSource.filter((row, rowIndex) => physicalRows.indexOf(rowIndex) === \
-1);\n    }\n    this.dataSource.length = 0;\n    \
Array.prototype.push.apply(this.dataSource, data2);\n  }\n  /**\n   * Returns \
single value from the data array.\n   *\n   * @param {number} row Visual row \
index.\n   * @param {number} prop The column property.\n   * @returns {*}\n   \
*/\n  get(row, prop) {\n    const physicalRow = \
this.instance.toPhysicalRow(row);\n    let dataRow = \
this.dataSource[physicalRow];\n    const modifiedRowData = \
this.instance.runHooks(\"modifyRowData\", physicalRow);\n    dataRow = \
isNaN(modifiedRowData) ? modifiedRowData : dataRow;\n    let value = null;\n  \
  if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n \
     value = dataRow[prop];\n    } else if (typeof prop === \"string\" && \
prop.indexOf(\".\") > -1) {\n      const sliced = prop.split(\".\");\n      \
let out = dataRow;\n      if (!out) {\n        return null;\n      }\n      \
for (let i = 0, ilen = sliced.length; i < ilen; i++) {\n        out = \
out[sliced[i]];\n        if (typeof out === \"undefined\") {\n          \
return null;\n        }\n      }\n      value = out;\n    } else if (typeof \
prop === \"function\") {\n      value = \
prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);\n    }\n    if \
(this.instance.hasHook(\"modifyData\")) {\n      const valueHolder = \
createObjectPropListener(value);\n      \
this.instance.runHooks(\"modifyData\", physicalRow, this.propToCol(prop), \
valueHolder, \"get\");\n      if (valueHolder.isTouched()) {\n        value = \
valueHolder.value;\n      }\n    }\n    return value;\n  }\n  /**\n   * \
Returns single value from the data array (intended for clipboard copy to an \
external application).\n   *\n   * @param {number} row Physical row index.\n  \
 * @param {number} prop The column property.\n   * @returns {string}\n   */\n \
 getCopyable(row, prop) {\n    if (this.instance.getCellMeta(row, \
this.propToCol(prop)).copyable) {\n      return this.get(row, prop);\n    }\n \
   return \"\";\n  }\n  /**\n   * Saves single value to the data array.\n   \
*\n   * @param {number} row Visual row index.\n   * @param {number} prop The \
column property.\n   * @param {string} value The value to set.\n   */\n  \
set(row, prop, value) {\n    const physicalRow = \
this.instance.toPhysicalRow(row);\n    let newValue = value;\n    let dataRow \
= this.dataSource[physicalRow];\n    const modifiedRowData = \
this.instance.runHooks(\"modifyRowData\", physicalRow);\n    dataRow = \
isNaN(modifiedRowData) ? modifiedRowData : dataRow;\n    if \
(this.instance.hasHook(\"modifyData\")) {\n      const valueHolder = \
createObjectPropListener(newValue);\n      \
this.instance.runHooks(\"modifyData\", physicalRow, this.propToCol(prop), \
valueHolder, \"set\");\n      if (valueHolder.isTouched()) {\n        \
newValue = valueHolder.value;\n      }\n    }\n    if (dataRow && \
dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n      \
dataRow[prop] = newValue;\n    } else if (typeof prop === \"string\" && \
prop.indexOf(\".\") > -1) {\n      const sliced = prop.split(\".\");\n      \
let out = dataRow;\n      let i = 0;\n      let ilen;\n      for (i = 0, ilen \
= sliced.length - 1; i < ilen; i++) {\n        if (typeof out[sliced[i]] === \
\"undefined\") {\n          out[sliced[i]] = {};\n        }\n        out = \
out[sliced[i]];\n      }\n      out[sliced[i]] = newValue;\n    } else if \
(typeof prop === \"function\") {\n      \
prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);\n    \
} else {\n      dataRow[prop] = newValue;\n    }\n  }\n  /**\n   * This \
ridiculous piece of code maps rows Id that are present in table data to those \
displayed for user.\n   * The trick is, the physical row id (stored in \
settings.data) is not necessary the same\n   * as the visual (displayed) row \
id (e.g. When sorting is applied).\n   *\n   * @param {number} index Visual \
row index.\n   * @param {number} amount An amount of rows to translate.\n   * \
@returns {number}\n   */\n  visualRowsToPhysical(index2, amount) {\n    const \
totalRows = this.instance.countSourceRows();\n    const logicRows = [];\n    \
let physicRow = (totalRows + index2) % totalRows;\n    let rowsToRemove = \
amount;\n    let row;\n    while (physicRow < totalRows && rowsToRemove) {\n  \
    row = this.instance.toPhysicalRow(physicRow);\n      \
logicRows.push(row);\n      rowsToRemove -= 1;\n      physicRow += 1;\n    \
}\n    return logicRows;\n  }\n  /**\n   *\n   * @param {number} index Visual \
column index.\n   * @param {number} amount An amount of rows to translate.\n  \
 * @returns {Array}\n   */\n  visualColumnsToPhysical(index2, amount) {\n    \
const totalCols = this.instance.countCols();\n    const visualCols = [];\n    \
let physicalCol = (totalCols + index2) % totalCols;\n    let colsToRemove = \
amount;\n    while (physicalCol < totalCols && colsToRemove) {\n      const \
col = this.instance.toPhysicalColumn(physicalCol);\n      \
visualCols.push(col);\n      colsToRemove -= 1;\n      physicalCol += 1;\n    \
}\n    return visualCols;\n  }\n  /**\n   * Clears the data array.\n   */\n  \
clear() {\n    for (let r = 0; r < this.instance.countSourceRows(); r++) {\n  \
    for (let c = 0; c < this.instance.countCols(); c++) {\n        \
this.set(r, this.colToProp(c), \"\");\n      }\n    }\n  }\n  /**\n   * Get \
data length.\n   *\n   * @returns {number}\n   */\n  getLength() {\n    const \
maxRowsFromSettings = this.tableMeta.maxRows;\n    let maxRows;\n    if \
(maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {\n      maxRows = \
0;\n    } else {\n      maxRows = maxRowsFromSettings || Infinity;\n    }\n   \
 const length = this.instance.rowIndexMapper.getNotTrimmedIndexesLength();\n  \
  return Math.min(length, maxRows);\n  }\n  /**\n   * Returns the data \
array.\n   *\n   * @returns {Array}\n   */\n  getAll() {\n    const start = \
{\n      row: 0,\n      col: 0\n    };\n    const end = {\n      row: \
Math.max(this.instance.countRows() - 1, 0),\n      col: \
Math.max(this.instance.countCols() - 1, 0)\n    };\n    if (start.row - \
end.row === 0 && !this.instance.countSourceRows()) {\n      return [];\n    \
}\n    return this.getRange(start, end, _DataMap.DESTINATION_RENDERER);\n  \
}\n  /**\n   * Count the number of columns cached in the `colToProp` cache.\n \
  *\n   * @returns {number} Amount of cached columns.\n   */\n  \
countCachedColumns() {\n    return this.colToPropCache.length;\n  }\n  /**\n  \
 * Returns data range as array.\n   *\n   * @param {object} [start] Start \
selection position. Visual indexes.\n   * @param {object} [end] End selection \
position. Visual indexes.\n   * @param {number} destination Destination of \
datamap.get.\n   * @returns {Array}\n   */\n  getRange(start, end, \
destination) {\n    const output = [];\n    let r;\n    let c;\n    let \
row;\n    const maxRows = this.tableMeta.maxRows;\n    const maxCols = \
this.tableMeta.maxCols;\n    if (maxRows === 0 || maxCols === 0) {\n      \
return [];\n    }\n    const getFn = destination === \
_DataMap.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;\n    \
const rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, \
end.row));\n    const clen = Math.min(Math.max(maxCols - 1, 0), \
Math.max(start.col, end.col));\n    for (r = Math.min(start.row, end.row); r \
<= rlen; r++) {\n      row = [];\n      const physicalRow = r >= 0 ? \
this.instance.toPhysicalRow(r) : r;\n      for (c = Math.min(start.col, \
end.col); c <= clen; c++) {\n        if (physicalRow === null) {\n          \
break;\n        }\n        row.push(getFn.call(this, r, \
this.colToProp(c)));\n      }\n      if (physicalRow !== null) {\n        \
output.push(row);\n      }\n    }\n    return output;\n  }\n  /**\n   * \
Return data as text (tab separated columns).\n   *\n   * @param {object} \
[start] Start selection position. Visual indexes.\n   * @param {object} [end] \
End selection position. Visual indexes.\n   * @returns {string}\n   */\n  \
getText(start, end) {\n    return stringify2(this.getRange(start, end, \
_DataMap.DESTINATION_RENDERER));\n  }\n  /**\n   * Return data as copyable \
text (tab separated columns intended for clipboard copy to an external \
application).\n   *\n   * @param {object} [start] Start selection position. \
Visual indexes.\n   * @param {object} [end] End selection position. Visual \
indexes.\n   * @returns {string}\n   */\n  getCopyableText(start, end) {\n    \
return stringify2(this.getRange(start, end, \
_DataMap.DESTINATION_CLIPBOARD_GENERATOR));\n  }\n  /**\n   * Destroy \
instance.\n   */\n  destroy() {\n    this.instance = null;\n    \
this.metaManager = null;\n    this.dataSource = null;\n    this.duckSchema = \
null;\n    this.colToPropCache.length = 0;\n    \
this.propToColCache.clear();\n    this.propToColCache = void 0;\n  }\n};\nvar \
dataMap_default = DataMap;\n\n// \
node_modules/handsontable/cellTypes/registry.mjs\nvar {\n  register: \
register6,\n  getItem: getItem5,\n  hasItem: hasItem4,\n  getNames: \
getNames4,\n  getValues: getValues4\n} = \
staticRegister(\"cellTypes\");\nfunction _getItem4(name) {\n  if \
(!hasItem4(name)) {\n    throw Error(`You declared cell type \"${name}\" as a \
string that is not mapped to a known object.\n                 Cell type must \
be an object or a string mapped to an object registered by\n                 \
\"Handsontable.cellTypes.registerCellType\" method`);\n  }\n  return \
getItem5(name);\n}\nfunction _register4(name, type) {\n  if (typeof name !== \
\"string\") {\n    type = name;\n    name = type.CELL_TYPE;\n  }\n  const {\n \
   editor,\n    renderer,\n    validator\n  } = type;\n  if (editor) {\n    \
_register(name, editor);\n  }\n  if (renderer) {\n    _register2(name, \
renderer);\n  }\n  if (validator) {\n    _register3(name, validator);\n  }\n  \
register6(name, type);\n}\n\n// \
node_modules/handsontable/dataMap/metaManager/utils.mjs\nfunction \
canBeOverwritten(propertyName, metaObject) {\n  var _metaObject$_automati;\n  \
if (propertyName === \"CELL_TYPE\") {\n    return false;\n  }\n  return \
((_metaObject$_automati = metaObject._automaticallyAssignedMetaProps) === \
null || _metaObject$_automati === void 0 ? void 0 : \
_metaObject$_automati.has(propertyName)) || !hasOwnProperty(metaObject, \
propertyName);\n}\nfunction extendByMetaType(metaObject, settings) {\n  let \
settingsToCompareWith = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : metaObject;\n  const validType = typeof settings.type === \
\"string\" ? _getItem4(settings.type) : settings.type;\n  if \
(metaObject._automaticallyAssignedMetaProps) {\n    objectEach(settings, \
(value, key) => void \
metaObject._automaticallyAssignedMetaProps.delete(key));\n  }\n  if \
(!isObject(validType)) {\n    return;\n  }\n  if (settingsToCompareWith === \
metaObject && !metaObject._automaticallyAssignedMetaProps) {\n    \
metaObject._automaticallyAssignedMetaProps = /* @__PURE__ */ new Set();\n  \
}\n  const expandedType = {};\n  objectEach(validType, (value, property) => \
{\n    if (canBeOverwritten(property, settingsToCompareWith)) {\n      var \
_metaObject$_automati2;\n      expandedType[property] = value;\n      \
(_metaObject$_automati2 = metaObject._automaticallyAssignedMetaProps) === \
null || _metaObject$_automati2 === void 0 || \
_metaObject$_automati2.add(property);\n    }\n  });\n  extend(metaObject, \
expandedType);\n}\nfunction columnFactory(TableMeta2) {\n  let conflictList = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n  \
function ColumnMeta2() {\n  }\n  inherit(ColumnMeta2, TableMeta2);\n  for \
(let i = 0; i < conflictList.length; i++) {\n    \
ColumnMeta2.prototype[conflictList[i]] = void 0;\n  }\n  return \
ColumnMeta2;\n}\nfunction isUnsignedNumber(value) {\n  return \
Number.isInteger(value) && value >= 0;\n}\nfunction assert(condition22, \
errorMessage) {\n  if (!condition22()) {\n    throw new Error(`Assertion \
failed: ${errorMessage}`);\n  }\n}\nfunction isNullish(variable) {\n  return \
variable === null || variable === void 0;\n}\n\n// \
node_modules/handsontable/dataMap/metaManager/metaSchema.mjs\nvar \
metaSchema_default = () => {\n  return {\n    /* eslint-disable \
jsdoc/require-description-complete-sentence */\n    /**\n     * Information \
on which of the meta properties were added automatically.\n     * For \
example: setting the `renderer` property directly won't extend the \
`_automaticallyAssignedMetaProps`\n     * entry, but setting a `type` will \
modify it to `Set(3) {'renderer', 'editor', 'validator', ...}`.\n     *\n     \
* @private\n     * @type {Set}\n     * @default undefined\n     */\n    \
_automaticallyAssignedMetaProps: void 0,\n    /**\n     * The \
`activeHeaderClassName` option lets you add a CSS class name\n     * to every \
currently-active, currently-selected header (when a whole column or row is \
selected).\n     *\n     * Read more:\n     * - \
[`currentRowClassName`](#currentRowClassName)\n     * - \
[`currentColClassName`](#currentColClassName)\n     * - \
[`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`invalidCellClassName`](#invalidCellClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     * - [`className`](#className)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @since 0.38.2\n   \
  * @default 'ht__active_highlight'\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * // add an `ht__active_highlight` CSS class \
name\n     * // to every currently-active, currently-selected header\n     * \
activeHeaderClassName: 'ht__active_highlight',\n     * ```\n     */\n    \
activeHeaderClassName: \"ht__active_highlight\",\n    /**\n     * The \
`allowEmpty` option determines whether Handsontable accepts the following \
values:\n     * - `null`\n     * - `undefined`\n     * - `''`\n     *\n     * \
You can set the `allowEmpty` option to one of the following:\n     *\n     * \
| Setting          | Description                                              \
                                                                            \
|\n     * | ---------------- | \
-----------------------------------------------------------------------------\
------------------------------------------------------- |\n     * | `true` \
(default) | - Accept `null`, `undefined` and `''` values<br>- Mark cells that \
contain `null`, `undefined` or `''` values as `valid`              |\n     * \
| `false`          | - Don't accept `null`, `undefined` and `''` values<br>- \
Mark cells that contain `null`, `undefined` or `''` values with as `invalid` \
|\n     *\n     * ::: tip\n     * To use the [`allowEmpty`](#allowempty) \
option, you need to set the [`validator`](#validator) option (or the \
[`type`](#type) option).\n     * :::\n     *\n     * @memberof Options#\n     \
* @type {boolean}\n     * @default true\n     * @category Core\n     *\n     \
* @example\n     * ```js\n     * // allow empty values in each cell of the \
entire grid\n     * allowEmpty: true,\n     *\n     * // or\n     * columns: \
[\n     *   {\n     *     type: 'date',\n     *     dateFormat: \
'DD/MM/YYYY',\n     *     // allow empty values in each cell of the 'date' \
column\n     *     allowEmpty: true\n     *   }\n     * ],\n     * ```\n     \
*/\n    allowEmpty: true,\n    /**\n     * The `allowHtml` option configures \
whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)\n     \
* and [`dropdown`](@/guides/cell-types/dropdown-cell-type.md) cells' \
[`source`](#source) data\n     * is treated as HTML.\n     *\n     * You can \
set the `allowHtml` option to one of the following:\n     *\n     * | Setting \
          | Description                                         |\n     * | \
----------------- | --------------------------------------------------- |\n   \
  * | `false` (default) | The [`source`](#source) data is not treated as HTML \
|\n     * | `true`            | The [`source`](#source) data is treated as \
HTML     |\n     *\n     * __Warning:__ Setting the `allowHtml` option to \
`true` can cause serious XSS vulnerabilities.\n     *\n     * Read more:\n    \
 * - [Autocomplete cell \
type](@/guides/cell-types/autocomplete-cell-type.md)\n     * - [Dropdown cell \
type](@/guides/cell-types/dropdown-cell-type.md)\n     * - \
[`source`](#source)\n     *\n     * @memberof Options#\n     * @type \
{boolean}\n     * @default false\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * columns: [\n     *   {\n     *   // set the \
`type` of each cell in this column to `autocomplete`\n     *   type: \
'autocomplete',\n     *   // set options available in every `autocomplete` \
cell of this column\n     *   source: ['<strong>foo</strong>', \
'<strong>bar</strong>']\n     *   // use HTML in the `source` list\n     *   \
allowHtml: true,\n     *   },\n     * ],\n     * ```\n     */\n    allowHtml: \
false,\n    /**\n     * If set to `true`, the `allowInsertColumn` option adds \
the following menu items to the [context \
menu](@/guides/accessories-and-menus/context-menu.md):\n     * - **Insert \
column left**\n     * - **Insert column right**\n     *\n     * @memberof \
Options#\n     * @type {boolean}\n     * @default true\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * // hide the 'Insert \
column left' and 'Insert column right' menu items from the context menu\n     \
* allowInsertColumn: false,\n     * ```\n     */\n    allowInsertColumn: \
true,\n    /**\n     * If set to `true`, the `allowInsertRow` option adds the \
following menu items to the [context \
menu](@/guides/accessories-and-menus/context-menu.md):\n     * - **Insert row \
above**\n     * - **Insert row below**\n     *\n     * @memberof Options#\n   \
  * @type {boolean}\n     * @default true\n     * @category Core\n     *\n    \
 * @example\n     * ```js\n     * // hide the 'Insert row above' and 'Insert \
row below' menu items from the context menu\n     * allowInsertRow: false,\n  \
   * ```\n     */\n    allowInsertRow: true,\n    /**\n     * The \
`allowInvalid` option determines whether Handsontable accepts values\n     * \
that were marked as `invalid` by the [cell \
validator](@/guides/cell-functions/cell-validator.md).\n     *\n     * You \
can set the `allowInvalid` option to one of the following:\n     *\n     * | \
Setting          | Description                                                \
                                                                              \
                                          |\n     * | ---------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
------------------------ |\n     * | `true` (default) | - Accept `invalid` \
values<br>- Allow the user to close the [cell \
editor](@/guides/cell-functions/cell-editor.md) with `invalid` values<br>- \
Save `invalid` values into the data source                   |\n     * | \
`false`          | - Don't accept `invalid` values<br>- Don't allow the user \
to close the [cell editor](@/guides/cell-functions/cell-editor.md) with \
`invalid` values<br>- Don't save `invalid` values into the data source |\n    \
 *\n     * Setting the `allowInvalid` option to `false` can be useful when \
used with the [Autocomplete strict \
mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-strict-mode)\
.\n     *\n     * Read more:\n     * - [Cell \
validator](@/guides/cell-functions/cell-validator.md)\n     * - [Cell \
editor](@/guides/cell-functions/cell-editor.md)\n     * - [Autocomplete \
strict \
mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-strict-mode)\
\n     *\n     * @memberof Options#\n     * @type {boolean}\n     * @default \
true\n     * @category Core\n     *\n     * @example\n     * ```js\n     * // \
don't accept `invalid` values\n     * // don't allow the user to close the \
cell editor\n     * // don't save `invalid` values into the data source\n     \
* allowInvalid: false,\n     * ```\n     */\n    allowInvalid: true,\n    \
/**\n     * If set to `true`, the `allowRemoveColumn` option adds the \
following menu items to the [context \
menu](@/guides/accessories-and-menus/context-menu.md):\n     * - **Remove \
column**\n     *\n     * Read more:\n     * - [Context \
menu](@/guides/accessories-and-menus/context-menu.md)\n     *\n     * \
@memberof Options#\n     * @type {boolean}\n     * @default true\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // hide the \
'Remove column' menu item from the context menu\n     * allowRemoveColumn: \
false,\n     * ```\n     */\n    allowRemoveColumn: true,\n    /**\n     * If \
set to `true`, the `allowRemoveRow` option adds the following menu items to \
the [context menu](@/guides/accessories-and-menus/context-menu.md):\n     * - \
**Remove row**\n     *\n     * Read more:\n     * - [Context \
menu](@/guides/accessories-and-menus/context-menu.md)\n     *\n     * \
@memberof Options#\n     * @type {boolean}\n     * @default true\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // hide the \
'Remove row' menu item from the context menu\n     * allowRemoveRow: false,\n \
    * ```\n     */\n    allowRemoveRow: true,\n    /**\n     * The \
`autoColumnSize` option configures the \
[`AutoColumnSize`](@/api/autoColumnSize.md) plugin.\n     *\n     * You can \
set the `autoColumnSize` option to one of the following:\n     *\n     * | \
Setting   | Description                                                       \
                           |\n     * | --------- | \
-----------------------------------------------------------------------------\
--------------- |\n     * | `false`   | Disable the \
[`AutoColumnSize`](@/api/autoColumnSize.md) plugin                            \
   |\n     * | `true`    | Enable the \
[`AutoColumnSize`](@/api/autoColumnSize.md) plugin with the default \
configuration |\n     * | An object | Enable the \
[`AutoColumnSize`](@/api/autoColumnSize.md) plugin and modify the plugin \
options  |\n     *\n     * If you set the `autoColumnSize` option to an \
object, you can set the following [`AutoColumnSize`](@/api/autoColumnSize.md) \
plugin options:\n     *\n     * | Property                | Possible values   \
              | Description                                                   \
                                                 |\n     * | \
----------------------- | ------------------------------- | \
-----------------------------------------------------------------------------\
--------------------------------- |\n     * | `syncLimit`             | A \
number \\| A percentage string | The number/percentage of columns to keep in \
sync<br>(default: `50`)                                            |\n     * \
| `useHeaders`            | `true` \\| `false`               | When \
calculating column widths:<br>`true`: use column headers<br>`false`: don't \
use column headers          |\n     * | `samplingRatio`         | A number    \
                    | The number of samples of the same length to be used in \
column width calculations                               |\n     * | \
`allowSampleDuplicates` | `true` \\| `false`               | When calculating \
column widths:<br>`true`: Allow duplicate samples<br>`false`: Don't allow \
duplicate samples |\n     *\n     * By default, the `autoColumnSize` option \
is set to `undefined`,\n     * but the \
[`AutoColumnSize`](@/api/autoColumnSize.md) plugin acts as enabled.\n     * \
To disable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin \
completely,\n     * set the `autoColumnSize` option to `false`.\n     *\n     \
* Using the [`colWidths`](#colWidths) option forcibly disables the \
[`AutoColumnSize`](@/api/autoColumnSize.md) plugin.\n     *\n     * Read \
more:\n     * - [Plugins: `AutoColumnSize`](@/api/autoColumnSize.md)\n     \
*\n     * @memberof Options#\n     * @type {object|boolean}\n     * @default \
undefined\n     * @category AutoColumnSize\n     *\n     * @example\n     * \
```js\n     * autoColumnSize: {\n     *   // keep 40% of columns in sync (the \
rest of columns: async)\n     *   syncLimit: '40%',\n     *   // when \
calculating column widths, use column headers\n     *   useHeaders: true,\n   \
  *   // when calculating column widths, use 10 samples of the same length\n  \
   *   samplingRatio: 10,\n     *   // when calculating column widths, allow \
duplicate samples\n     *   allowSampleDuplicates: true\n     * },\n     * \
```\n     */\n    autoColumnSize: void 0,\n    /**\n     * The `autoRowSize` \
option configures the [`AutoRowSize`](@/api/autoRowSize.md) plugin.\n     *\n \
    * You can set the `autoRowSize` option to one of the following:\n     *\n \
    * | Setting   | Description                                               \
                             |\n     * | --------- | \
-----------------------------------------------------------------------------\
--------- |\n     * | `false`   | Disable the \
[`AutoRowSize`](@/api/autoRowSize.md) plugin                               \
|\n     * | `true`    | Enable the [`AutoRowSize`](@/api/autoRowSize.md) \
plugin with the default configuration |\n     * | An object | Enable the \
[`AutoRowSize`](@/api/autoRowSize.md) plugin and modify the plugin options  \
|\n     *\n     * To give Handsontable's \
[scrollbar](https://handsontable.com/docs/8.0.0/demo-scrolling.html)\n     * \
a proper size, set the `autoRowSize` option to `true`.\n     *\n     * If you \
set the `autoRowSize` option to an object, you can set the following \
[`AutoRowSize`](@/api/autoRowSize.md) plugin options:\n     *\n     * | \
Property    | Possible values                 | Description                   \
                                    |\n     * | ----------- | \
------------------------------- | \
----------------------------------------------------------------- |\n     * | \
`syncLimit` | A number \\| A percentage string | The number/percentage of \
rows to keep in sync<br>(default: `500`) |\n     *\n     * Using the \
[`rowHeights`](#rowHeights) option forcibly disables the \
[`AutoRowSize`](@/api/autoRowSize.md) plugin.\n     *\n     * Read more:\n    \
 * - [Plugins: `AutoRowSize`](@/api/autoRowSize.md)\n     *\n     * @memberof \
Options#\n     * @type {object|boolean}\n     * @default undefined\n     * \
@category AutoRowSize\n     *\n     * @example\n     * ```js\n     * \
autoRowSize: {\n     *   // keep 40% of rows in sync (the rest of rows: \
async)\n     *   syncLimit: '40%'\n     * },\n     * ```\n     */\n    \
autoRowSize: void 0,\n    /**\n     * With [`autoWrapCol`](#autowrapcol) \
enabled:\n     * - When you select a bottom-most cell, pressing \
<kbd>**\[AHat]\206\223**</kbd> takes you to the top-most cell of the next \
column.\n     * - When you select a top-most cell, pressing \
<kbd>**\[AHat]\206\221**</kbd> takes you to the bottom-most cell of the \
previous column.\n     *\n     * You can set the \
[`autoWrapCol`](#autowrapcol) option to one of the following:\n     *\n     * \
| Setting           | Description                                             \
                                                                              \
                                                                              \
                         |\n     * | ----------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
----- |\n     * | `true`            | When you select a bottom-most cell, \
pressing <kbd>**\[AHat]\206\223**</kbd> takes you to the top-most cell of the \
next column.<br><br>When you select a top-most cell, pressing \
<kbd>**\[AHat]\206\221**</kbd> takes you to the bottom-most cell of the \
previous column. |\n     * | `false` (default) | When you select a \
bottom-most cell, pressing <kbd>**\[AHat]\206\223**</kbd> doesn't do \
anything.<br><br>When you select a top-most cell, pressing \
<kbd>**\[AHat]\206\221**</kbd> doesn't do anything.                           \
                                         |\n     *\n     * @memberof \
Options#\n     * @type {boolean}\n     * @default false\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * // when you select a \
bottom-most cell, pressing \[AHat]\[Not]\207 doesn't do anything\n     * // \
when you select a top-most cell, pressing \[AHat]\[Not]\206 doesn't do \
anything\n     * autoWrapCol: false, // default setting\n     *\n     * // \
when you select a bottom-most cell, pressing \[AHat]\[Not]\207 takes you to \
the top-most cell of the next column\n     * // when you select a top-most \
cell, pressing \[AHat]\[Not]\206 takes you to the bottom-most cell of the \
previous column\n     * autoWrapCol: true,\n     * ```\n     */\n    \
autoWrapCol: false,\n    /**\n     * With [`autoWrapRow`](#autoWrapRow) \
enabled:\n     * - When you select the first cell of a row, pressing \
<kbd>**\[AHat]\206\220**</kbd>* takes you to the last cell of the row \
above.\n     * - When you select the last cell of a row, pressing \
<kbd>**\[AHat]\206\222**</kbd>* takes you to the first cell of the row \
below.\n     *\n     * You can set the [`autoWrapRow`](#autoWrapRow) option \
to one of the following:\n     *\n     * | Setting           | Description    \
                                                                              \
                                                                              \
                                                              |\n     * | \
----------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
- |\n     * | `true`            | When you select the first cell of a row, \
pressing <kbd>**\[AHat]\206\220**</kbd>* takes you to the last cell of the \
row above.<br><br>When you select the last cell of a row, pressing \
<kbd>**\[AHat]\206\222**</kbd>* takes you to the first cell of the row below. \
|\n     * | `false` (default) | When you select the first cell of a row, \
pressing <kbd>**\[AHat]\206\220**</kbd>* doesn't do anything.<br><br>When you \
select the last cell of a row, pressing <kbd>**\[AHat]\206\222**</kbd>* \
doesn't do anything.                                                  |\n     \
*\n     * \\* The exact key depends on your \
[`layoutDirection`](#layoutdirection) configuration.\n     *\n     * \
@memberof Options#\n     * @type {boolean}\n     * @default false\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // when you \
select the first cell of a row, pressing \[AHat]\[Not]\205 doesn't do \
anything\n     * // when you select the last cell of a row, pressing \
\[AHat]\236\[DownExclamation]\[IDoubleDot]\[Cedilla]\217 doesn't do \
anything\n     * autoWrapRow: false, // default setting\n     *\n     * // \
when you select the first cell of a row, pressing \[AHat]\[Not]\205 takes you \
to the last cell of the row above\n     * // when you select the last cell of \
a row, pressing \[AHat]\236\[DownExclamation]\[IDoubleDot]\[Cedilla]\217 \
takes you to the first cell of the row below\n     * autoWrapRow: true,\n     \
* ```\n     */\n    autoWrapRow: false,\n    /**\n     * @description\n     * \
The `bindRowsWithHeaders` option configures the \
[`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin.\n     *\n     * \
You can set the `bindRowsWithHeaders` option to one of the following:\n     \
*\n     * | Setting | Description                                             \
                     |\n     * | ------- | \
---------------------------------------------------------------------------- \
|\n     * | `false` | Disable the the \
[`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin |\n     * | \
`true`  | Enable the the \
[`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin  |\n     *\n     \
* Read more:\n     * - [Plugins: \
`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md)\n     *\n     * \
@memberof Options#\n     * @type {boolean|string}\n     * @default \
undefined\n     * @category BindRowsWithHeaders\n     *\n     * @example\n    \
 * ```js\n     * // enable the `BindRowsWithHeaders` plugin\n     * \
bindRowsWithHeaders: true\n     * ```\n     */\n    bindRowsWithHeaders: void \
0,\n    /**\n     * The `cell` option lets you apply [configuration \
options](@/guides/getting-started/configuration-options.md) to individual \
cells.\n     *\n     * The `cell` option overwrites the [top-level grid \
options](@/guides/getting-started/configuration-options.md#set-grid-options),\
\n     * and the [`columns`](#columns) options.\n     *\n     * Read more:\n  \
   * - [Configuration options: Setting cell \
options](@/guides/getting-started/configuration-options.md#set-cell-options)\
\n     * - [`columns`](#columns)\n     *\n     * @memberof Options#\n     * \
@type {Array[]}\n     * @default []\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * // set the `cell` option to an array of \
objects\n     * cell: [\n     *   // make the cell with coordinates (0, 0) \
read-only\n     *   {\n     *     row: 0,\n     *     col: 0,\n     *     \
readOnly: true\n     *   }\n     * ],\n     * ```\n     */\n    cell: [],\n   \
 /**\n     * @description\n     * The `cells` option lets you apply any other \
[configuration options](@/guides/getting-started/configuration-options.md) \
to\n     * individual grid elements (columns, rows, cells), based on any \
logic you implement.\n     *\n     * The `cells` option overwrites all other \
options (including options set by [`columns`](#columns) and \
[`cell`](#cell)).\n     * It takes the following parameters:\n     *\n     * \
| Parameter | Required | Type             | Description                       \
                                                                              \
                                                                              \
                                                                              \
                                                            |\n     * | \
--------- | -------- | ---------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
------------------- |\n     * | `row`     | Yes      | Number           | A \
physical row index                                                            \
                                                                              \
                                                                              \
                                                                              \
              |\n     * | `column`  | Yes      | Number           | A \
physical column index                                                         \
                                                                              \
                                                                              \
                                                                              \
              |\n     * | `prop`    | No       | String \\| Number | If \
[`data`](#data) is set to an [array of \
arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), `prop` \
is the same number as `column`.<br><br>If [`data`](#data) is set to an [array \
of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), \
`prop` is a property name for the column's data object. |\n     *\n     * \
Read more:\n     * - [Configuration options: Implementing custom \
logic](@/guides/getting-started/configuration-options.md#implement-custom-log\
ic)\n     * - [Configuration options: Setting row \
options](@/guides/getting-started/configuration-options.md#set-row-options)\n \
    * - [`columns`](#columns)\n     * - [`cell`](#cell)\n     *\n     * \
@memberof Options#\n     * @type {Function}\n     * @default undefined\n     \
* @category Core\n     *\n     * @example\n     * ```js\n     * // set the \
`cells` option to your custom function\n     * cells(row, column, prop) {\n   \
  *   const cellProperties = { readOnly: false };\n     *   const \
visualRowIndex = this.instance.toVisualRow(row);\n     *   const \
visualColIndex = this.instance.toVisualColumn(column);\n     *\n     *   if \
(visualRowIndex === 0 && visualColIndex === 0) {\n     *     \
cellProperties.readOnly = true;\n     *   }\n     *\n     *   return \
cellProperties;\n     * },\n     * ```\n     */\n    cells: void 0,\n    \
/**\n     * The `checkedTemplate` option lets you configure what value\n     \
* a checked [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell \
has.\n     *\n     * You can set the `checkedTemplate` option to one of the \
following:\n     *\n     * | Setting          | Description                   \
                                                                              \
                                                                             \
|\n     * | ---------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
------------------------------ |\n     * | `true` (default) | If a \
[`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is \
checked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for \
this cell returns `true`                  |\n     * | A string         | If a \
[`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is \
checked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for \
this cell returns a string of your choice |\n     *\n     * Read more:\n     \
* - [Checkbox cell type: Checkbox \
template](@/guides/cell-types/checkbox-cell-type.md#checkbox-template)\n     \
* - [`getDataAtCell()`](@/api/core.md#getDataAtCell)\n     * - \
[`uncheckedTemplate`](#uncheckedTemplate)\n     *\n     * @memberof \
Options#\n     * @type {boolean|string|number}\n     * @default true\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * columns: [\n    \
 *   {\n     *     // set the `type` of each cell in this column to \
`checkbox`\n     *     // when checked, the cell's value is `true`\n     *    \
 // when unchecked, the cell's value is `false`\n     *     type: \
'checkbox',\n     *   },\n     *   {\n     *     // set the `type` of each \
cell in this column to `checkbox`\n     *     type: 'checkbox',\n     *     \
// when checked, the cell's value is `'Yes'`\n     *     checkedTemplate: \
'Yes',\n     *     // when unchecked, the cell's value is `'No'`\n     *     \
uncheckedTemplate: 'No'\n     *  }\n     * ],\n     * ```\n     */\n    \
checkedTemplate: void 0,\n    /**\n     * The `className` option lets you add \
CSS class names to every currently-selected element.\n     *\n     * You can \
set the `className` option to one of the following:\n     *\n     * | Setting \
            | Description                                                     \
 |\n     * | ------------------- | \
---------------------------------------------------------------- |\n     * | \
A string            | Add a single CSS class name to every currently-selected \
element  |\n     * | An array of strings | Add multiple CSS class names to \
every currently-selected element |\n     *\n     * ::: tip\n     * Don't \
change the `className` metadata of the [column \
summary](@/guides/columns/column-summary.md) row.\n     * To style the \
summary row, use the class name assigned automatically by the \
[`ColumnSummary`](@/api/columnSummary.md) plugin: `columnSummaryResult`.\n    \
 * :::\n     *\n     * To apply different CSS class names on different \
levels, use Handsontable's [cascading \
configuration](@/guides/getting-started/configuration-options.md#cascading-co\
nfiguration).\n     *\n     * Read more:\n     * - [Configuration options: \
Cascading \
configuration](@/guides/getting-started/configuration-options.md#cascading-co\
nfiguration)\n     * - [`currentRowClassName`](#currentRowClassName)\n     * \
- [`currentColClassName`](#currentColClassName)\n     * - \
[`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`activeHeaderClassName`](#activeHeaderClassName)\n     * - \
[`invalidCellClassName`](#invalidCellClassName)\n     * - \
[`placeholderCellClassName`](#placeholderCellClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     *\n     * @memberof Options#\n     \
* @type {string|string[]}\n     * @default undefined\n     * @category Core\n \
    *\n     * @example\n     * ```js\n     * // add a `your-class-name` CSS \
class name\n     * // to every currently-selected element\n     * className: \
'your-class-name',\n     *\n     * // add `first-class-name` and \
`second-class-name` CSS class names\n     * // to every currently-selected \
element\n     * className: ['first-class-name', 'second-class-name'],\n     * \
```\n     */\n    className: void 0,\n    /**\n     * The `colHeaders` option \
configures your grid's column headers.\n     *\n     * You can set the \
`colHeaders` option to one of the following:\n     *\n     * | Setting  | \
Description                                                          |\n     \
* | -------- | \
-------------------------------------------------------------------- |\n     \
* | `true`   | Enable the default column headers ('A', 'B', 'C', ...)         \
      |\n     * | `false`  | Disable column headers                           \
                    |\n     * | An array | Define your own column headers \
(e.g. `['One', 'Two', 'Three', ...]`) |\n     * | A function | Define your \
own column headers, using a function                     |\n     *\n     * \
Read more:\n     * - [Column header](@/guides/columns/column-header.md)\n     \
*\n     * @memberof Options#\n     * @type {boolean|string[]|Function}\n     \
* @default null\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * // enable the default column headers\n     * colHeaders: \
true,\n     *\n     * // set your own column headers\n     * colHeaders: \
['One', 'Two', 'Three'],\n     *\n     * // set your own column headers, \
using a function\n     * colHeaders: function(visualColumnIndex) {\n     *   \
return `${visualColumnIndex} + : AB`;\n     * },\n     * ```\n     */\n    \
colHeaders: null,\n    /**\n     * @description\n     * The \
`collapsibleColumns` option configures the \
[`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin.\n     *\n     * \
You can set the `collapsibleColumns` option to one of the following:\n     \
*\n     * | Setting              | Description                                \
                                                       |\n     * | \
-------------------- | \
-----------------------------------------------------------------------------\
-------------------- |\n     * | `false`              | Disable the \
[`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin                    \
        |\n     * | `true`               | Enable the \
[`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin                    \
         |\n     * | An array of objects  | Enable the \
[`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin for selected \
column headers |\n     *\n     * Read more:\n     * - [Plugins: \
`CollapsibleColumns`](@/api/collapsibleColumns.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean|object[]}\n     * @default undefined\n     * \
@category CollapsibleColumns\n     *\n     * @example\n     * ```js\n     * \
// enable column collapsing for all headers\n     * collapsibleColumns: \
true,\n     *\n     * // enable column collapsing for selected headers\n     \
* collapsibleColumns: [\n     *   {row: -4, col: 1, collapsible: true},\n     \
*   {row: -3, col: 5, collapsible: true}\n     * ],\n     * ```\n     */\n    \
collapsibleColumns: void 0,\n    /**\n     * @description\n     * The \
`columnHeaderHeight` option configures the height of column headers.\n     \
*\n     * You can set the `columnHeaderHeight` option to one of the \
following:\n     *\n     * | Setting  | Description                           \
              |\n     * | -------- | \
--------------------------------------------------- |\n     * | A number | \
Set the same height for every column header         |\n     * | An array | \
Set different heights for individual column headers |\n     *\n     * \
@memberof Options#\n     * @type {number|number[]}\n     * @default \
undefined\n     * @category Core\n     *\n     * @example\n     * ```js\n     \
* // set the same height for every column header\n     * columnHeaderHeight: \
25,\n     *\n     * // set different heights for individual column headers\n  \
   * columnHeaderHeight: [25, 30, 55],\n     * ```\n     */\n    \
columnHeaderHeight: void 0,\n    /**\n     * @description\n     * The \
`columns` option lets you apply any other [configuration \
options](@/guides/getting-started/configuration-options.md) to individual \
columns (or ranges of columns).\n     *\n     * You can set the `columns` \
option to one of the following:\n     * - An array of objects (each object \
represents one column)\n     * - A function that returns an array of \
objects\n     *\n     * The `columns` option overwrites the [top-level grid \
options](@/guides/getting-started/configuration-options.md#set-grid-options).\
\n     *\n     * When you use `columns`, the [`startCols`](#startCols), \
[`minCols`](#minCols), and [`maxCols`](#maxCols) options are ignored.\n     \
*\n     * Read more:\n     * - [Configuration options: Setting column \
options](@/guides/getting-started/configuration-options.md#set-column-options\
)\n     * - [`startCols`](#startCols)\n     * - [`minCols`](#minCols)\n     * \
- [`maxCols`](#maxCols)\n     * - [`data`](#data)\n     *\n     * @memberof \
Options#\n     * @type {object[]|Function}\n     * @default undefined\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // set the \
`columns` option to an array of objects\n     * // each object represents one \
column\n     * columns: [\n     *   {\n     *     // column options for the \
first (by physical index) column\n     *     type: 'numeric',\n     *     \
numericFormat: {\n     *       pattern: '0,0.00 $'\n     *     }\n     *   \
},\n     *   {\n     *     // column options for the second (by physical \
index) column\n     *     type: 'text',\n     *     readOnly: true\n     *   \
}\n     * ],\n     *\n     * // or set the `columns` option to a function, \
based on physical indexes\n     * columns(index) {\n     *   return {\n     * \
    type: index > 0 ? 'numeric' : 'text',\n     *     readOnly: index < 1\n   \
  *   }\n     * }\n     * ```\n     */\n    columns: void 0,\n    /**\n     * \
@description\n     * The `columnSorting` option configures the \
[`ColumnSorting`](@/api/columnSorting.md) plugin.\n     *\n     * You can set \
the `columnSorting` option to one of the following:\n     *\n     * | Setting \
   | Description                                                              \
                                                              |\n     * | \
---------- | \
-----------------------------------------------------------------------------\
--------------------------------------------------------- |\n     * | `true`  \
   | Enable the [`ColumnSorting`](@/api/columnSorting.md) plugin with the \
default configuration                                             |\n     * | \
`false`    | Disable the [`ColumnSorting`](@/api/columnSorting.md) plugin     \
                                                                      |\n     \
* | An object  | - Enable the [`ColumnSorting`](@/api/columnSorting.md) \
plugin<br>- Modify the [`ColumnSorting`](@/api/columnSorting.md) plugin \
options |\n     *\n     * If you set the `columnSorting` option to an \
object,\n     * you can set the following \
[`ColumnSorting`](@/api/columnSorting.md) plugin options:\n     *\n     * | \
Option                   | Possible settings                                  \
                                                                              \
                |\n     * | ------------------------ | \
-----------------------------------------------------------------------------\
------------------------------------------------------------------- |\n     * \
| `indicator`              | `true`: Display the arrow icon in the column \
header, to indicate a sortable column<br>`false`: Don't display the arrow \
icon in the column header  |\n     * | `headerAction`           | `true`: \
Enable clicking on the column header to sort the column<br>`false`: Disable \
clicking on the column header to sort the column             |\n     * | \
`sortEmptyCells`         | `true`: Sort empty cells as well<br>`false`: Place \
empty cells at the end                                                        \
                |\n     * | `compareFunctionFactory` | A [custom compare \
function](@/guides/rows/rows-sorting.md#add-a-custom-comparator)              \
                                                  |\n     *\n     * If you \
set the `columnSorting` option to an object,\n     * you can also sort \
individual columns at Handsontable's initialization.\n     * In the \
`columnSorting` object, add an object named `initialConfig`,\n     * with the \
following properties:\n     *\n     * | Option      | Possible settings   | \
Description                                                      |\n     * | \
----------- | ------------------- | \
---------------------------------------------------------------- |\n     * | \
`column`    | A number            | The index of the column that you want to \
sort at initialization  |\n     * | `sortOrder` | `'asc'` \\| `'desc'` | The \
sorting order:<br>`'asc'`: ascending<br>`'desc'`: descending |\n     *\n     \
* Read more:\n     * - [Rows sorting](@/guides/rows/rows-sorting.md)\n     * \
- [Rows sorting: Custom compare \
functions](@/guides/rows/rows-sorting.md#add-a-custom-comparator)\n     * - \
[`multiColumnSorting`](#multiColumnSorting)\n     *\n     * @memberof \
Options#\n     * @type {boolean|object}\n     * @default undefined\n     * \
@category ColumnSorting\n     *\n     * @example\n     * ```js\n     * // \
enable the `ColumnSorting` plugin\n     * columnSorting: true\n     *\n     * \
// enable the `ColumnSorting` plugin with custom configuration\n     * \
columnSorting: {\n     *   // sort empty cells as well\n     *   \
sortEmptyCells: true,\n     *   // display the arrow icon in the column \
header\n     *   indicator: true,\n     *   // disable clicking on the column \
header to sort the column\n     *   headerAction: false,\n     *   // add a \
custom compare function\n     *   compareFunctionFactory(sortOrder, \
columnMeta) {\n     *     return function(value, nextValue) {\n     *       \
// some value comparisons which will return -1, 0 or 1...\n     *     }\n     \
*   }\n     * }\n     *\n     * // enable the `ColumnSorting` plugin\n     * \
columnSorting: {\n     *   // at initialization, sort column 1 in ascending \
order\n     *   initialConfig: {\n     *     column: 1,\n     *     \
sortOrder: 'asc'\n     *   },\n     *   // at initialization, sort column 2 \
in descending order\n     *   initialConfig: {\n     *     column: 2,\n     * \
    sortOrder: 'desc'\n     *   }\n     * }\n     * ```\n     */\n    \
columnSorting: void 0,\n    /**\n     * @description\n     * The \
`columnSummary` option configures the \
[`ColumnSummary`](@/api/columnSummary.md) plugin.\n     *\n     * You can set \
the `columnSummary` option to an array of objects.\n     * Each object \
configures a single column summary, using the following properties:\n     *\n \
    * | Property                 | Possible values                            \
                             | Description                                    \
                                                                              \
|\n     * | ------------------------ | \
----------------------------------------------------------------------- | \
-----------------------------------------------------------------------------\
----------------------------------------------- |\n     * | `sourceColumn`    \
       | A number                                                             \
   | [Column to \
summarize](@/guides/columns/column-summary.md#step-2-select-cells-that-you-wa\
nt-to-summarize)                     |\n     * | `ranges`                 | \
An array                                                                | \
[Ranges of rows to \
summarize](@/guides/columns/column-summary.md#step-2-select-cells-that-you-wa\
nt-to-summarize)             |\n     * | `type`                   | `'sum'` \
\\| `'min'` \\| `'max'` \\| `'count'` \\| `'average'` \\| `'custom'` | \
[Summary \
function](@/guides/columns/column-summary.md#step-3-calculate-your-summary)   \
                                      |\n     * | `destinationRow`         | \
A number                                                                | \
[Destination cell's row \
coordinate](@/guides/columns/column-summary.md#step-4-provide-the-destination\
-cell-s-coordinates)    |\n     * | `destinationColumn`      | A number       \
                                                         | [Destination \
cell's column \
coordinate](@/guides/columns/column-summary.md#step-4-provide-the-destination\
-cell-s-coordinates) |\n     * | `forceNumeric`           | `true`  \\| \
`false`                                                      | [Treat \
non-numerics as \
numerics](@/guides/columns/column-summary.md#force-numeric-values)            \
                      |\n     * | `reversedRowCoords`      | `true`  \\| \
`false`                                                      | [Reverse row \
coordinates](@/guides/columns/column-summary.md#step-5-make-room-for-the-dest\
ination-cell)                      |\n     * | `suppressDataTypeErrors` | \
`true`  \\| `false`                                                      | \
[Suppress data type \
errors](@/guides/columns/column-summary.md#throw-data-type-errors)            \
                        |\n     * | `readOnly`               | `true`  \\| \
`false`                                                      | Make summary \
cell read-only                                                                \
                                  |\n     * | `roundFloat`             | \
`true`  \\| `false`                                                      | \
[Round summary \
result](@/guides/columns/column-summary.md#round-a-column-summary-result)     \
                             |\n     * | `customFunction`         | A \
function                                                              | \
[Custom summary \
function](@/guides/columns/column-summary.md#implement-a-custom-summary-funct\
ion)                         |\n     *\n     * Read more:\n     * - [Column \
summary](@/guides/columns/column-summary.md)\n     * - [Plugins: \
`ColumnSummary`](@/api/columnSummary.md)\n     *\n     * @memberof Options#\n \
    * @type {object[]|Function}\n     * @default undefined\n     * @category \
ColumnSummary\n     *\n     * @example\n     * ```js\n     * columnSummary: \
[\n     *   {\n     *     sourceColumn: 0,\n     *     ranges: [\n     *      \
 [0, 2], [4], [6, 8]\n     *     ],\n     *     type: 'custom',\n     *     \
destinationRow: 4,\n     *     destinationColumn: 1,\n     *     \
forceNumeric: true,\n     *     reversedRowCoords: true,\n     *     \
suppressDataTypeErrors: false,\n     *     readOnly: true,\n     *     \
roundFloat: false,\n     *     customFunction(endpoint) {\n     *        \
return 100;\n     *     }\n     *   }\n     * ],\n     * ```\n     */\n    \
columnSummary: void 0,\n    /**\n     * The `colWidths` option sets columns' \
widths, in pixels.\n     *\n     * The default column width is 50px. To \
change it, set the `colWidths` option to one of the following:\n     *\n     \
* | Setting     | Description                                                 \
                                         | Example                            \
                               |\n     * | ----------- | \
-----------------------------------------------------------------------------\
----------------------- | \
----------------------------------------------------------------- |\n     * | \
A number    | Set the same width for every column                             \
                                     | `colWidths: 100`                       \
                           |\n     * | A string    | Set the same width for \
every column                                                                  \
| `colWidths: '100px'`                                              |\n     * \
| An array    | Set widths separately for each column                         \
                                       | `colWidths: [100, 120, undefined]`   \
                             |\n     * | A function  | Set column widths \
dynamically,<br>on each render                                                \
     | `colWidths(visualColumnIndex) { return visualColumnIndex * 10; }` |\n  \
   * | `undefined` | Used by the \
[modifyColWidth](@/api/hooks.md#modifyColWidth) hook,<br>to detect column \
width changes. | `colWidths: undefined`                                       \
     |\n     *\n     * Setting `colWidths` even for a single column disables \
the {@link AutoColumnSize} plugin\n     * for all columns. For this reason, \
if you use `colWidths`, we recommend you set a width for each one\n     * of \
your columns. Otherwise, every column with an undefined width defaults back \
to 50px,\n     * which may cut longer columns names.\n     *\n     * Read \
more:\n     * - [Column width](@/guides/columns/column-width.md)\n     * - \
[Hooks: `modifyColWidth`](@/api/hooks.md#modifyColWidth)\n     * - \
[`autoColumnSize`](#autoColumnSize)\n     *\n     * @memberof Options#\n     \
* @type {number|number[]|string|string[]|Array<undefined>|Function}\n     * \
@default undefined\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * // set every column's width to 100px\n     * colWidths: 100,\n  \
   *\n     * // set every column's width to 100px\n     * colWidths: \
'100px',\n     *\n     * // set the first (by visual index) column's width to \
100\n     * // set the second (by visual index) column's width to 120\n     * \
// set the third (by visual index) column's width to `undefined`, so that it \
defaults to 50px\n     * // set any other column's width to the default 50px \
(note that longer cell values and column names can get cut)\n     * \
colWidths: [100, 120, undefined],\n     *\n     * // set each column's width \
individually, using a function\n     * colWidths(visualColumnIndex) {\n     * \
  return visualColumnIndex * 10;\n     * },\n     * ```\n     */\n    \
colWidths: void 0,\n    /**\n     * The `commentedCellClassName` option lets \
you add a CSS class name to cells\n     * that have comments.\n     *\n     * \
Read more:\n     * - [Comments](@/guides/cell-features/comments.md)\n     * - \
[`comments`](#comments)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`currentRowClassName`](#currentRowClassName)\n     * - \
[`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`activeHeaderClassName`](#activeHeaderClassName)\n     * - \
[`invalidCellClassName`](#invalidCellClassName)\n     * - \
[`placeholderCellClassName`](#placeholderCellClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     * - [`className`](#className)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @default \
'htCommentCell'\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * // add a `has-comment` CSS class name\n     * // to each cell \
that has a comment\n     * commentedCellClassName: 'has-comment',\n     * \
```\n     */\n    commentedCellClassName: \"htCommentCell\",\n    /**\n     * \
@description\n     * The `comments` option configures the \
[`Comments`](@/api/comments.md) plugin.\n     *\n     * You can set the \
`comments` option to one of the following:\n     *\n     * | Setting   | \
Description                                                                   \
                                                                              \
                          |\n     * | --------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
--------------------------- |\n     * | `true`    | - Enable the \
[`Comments`](@/api/comments.md) plugin<br>- Add comment menu items to the \
[context menu](@/guides/accessories-and-menus/context-menu.md)                \
                 |\n     * | `false`   | Disable the \
[`Comments`](@/api/comments.md) plugin                                        \
                                                                              \
              |\n     * | An object | - Enable the \
[`Comments`](@/api/comments.md) plugin<br>- Add comment menu items to the \
[context menu](@/guides/accessories-and-menus/context-menu.md)<br>- Configure \
comment settings |\n     *\n     * If you set the `comments` option to an \
object, you can configure the following comment options:\n     *\n     * | \
Option         | Possible settings           | Description                    \
                     |\n     * | -------------- | --------------------------- \
| --------------------------------------------------- |\n     * | \
`displayDelay` | A number (default: `250`)   | Display comments after a delay \
(in milliseconds)    |\n     * | `readOnly`     | `true` \\| `false` \
(default) | `true`: Make comments read-only                     |\n     * | \
`style`        | An object                   | Set comment boxes' `width` and \
`height` (in pixels) |\n     *\n     * Read more:\n     * - \
[Comments](@/guides/cell-features/comments.md)\n     * - [Context \
menu](@/guides/accessories-and-menus/context-menu.md)\n     * - \
[`width`](#width)\n     * - [`height`](#height)\n     * - \
[`readOnly`](#readOnly)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     *\n     * @memberof \
Options#\n     * @type {boolean|object[]}\n     * @default false\n     * \
@category Comments\n     *\n     * @example\n     * ```js\n     * // enable \
the `Comments` plugin\n     * comments: true,\n     *\n     * // enable the \
`Comments` plugin\n     * // and configure its settings\n     * comments: {\n \
    *   // display all comments with a 1-second delay\n     *   displayDelay: \
1000,\n     *   // make all comments read-only\n     *   readOnly: true,\n    \
 *   // set the default size of all comment boxes\n     *   style: {\n     *  \
   width: 300,\n     *     height: 100\n     *   }\n     * }\n     * ```\n    \
 */\n    comments: false,\n    /**\n     * @description\n     * The \
`contextMenu` option configures the [`ContextMenu`](@/api/contextMenu.md) \
plugin.\n     *\n     * You can set the `contextMenu` option to one of the \
following:\n     *\n     * | Setting   | Description                          \
                                                                              \
                                                                              \
       |\n     * | --------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
--------------------------------------------- |\n     * | `false`   | Disable \
the [`ContextMenu`](@/api/contextMenu.md) plugin                              \
                                                                              \
                                    |\n     * | `true`    | - Enable the \
[`ContextMenu`](@/api/contextMenu.md) plugin<br>- Use the [default context \
menu \
options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-def\
ault-options)                 |\n     * | An array  | - Enable the \
[`ContextMenu`](@/api/contextMenu.md) plugin<br>- Modify [individual context \
menu \
options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-spe\
cific-options)              |\n     * | An object | - Enable the \
[`ContextMenu`](@/api/contextMenu.md) plugin<br>- Apply a [custom context \
menu \
configuration](@/guides/accessories-and-menus/context-menu.md#context-menu-wi\
th-a-fully-custom-configuration) |\n     *\n     * Read more:\n     * - \
[Context menu](@/guides/accessories-and-menus/context-menu.md)\n     * - \
[Context menu: Context menu with default \
options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-def\
ault-options)\n     * - [Context menu: Context menu with specific \
options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-spe\
cific-options)\n     * - [Context menu: Context menu with fully custom \
configuration \
options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-a-f\
ully-custom-configuration)\n     * - [Plugins: \
`ContextMenu`](@/api/contextMenu.md)\n     *\n     * @memberof Options#\n     \
* @type {boolean|string[]|object}\n     * @default undefined\n     * \
@category ContextMenu\n     *\n     * @example\n     * ```js\n     * // \
enable the `ContextMenu` plugin\n     * // use the default context menu \
options\n     * contextMenu: true,\n     *\n     * // enable the \
`ContextMenu` plugin\n     * // and modify individual context menu options\n  \
   * contextMenu: ['row_above', 'row_below', '---------', 'undo', 'redo'],\n  \
   *\n     * // enable the `ContextMenu` plugin\n     * // and apply a custom \
context menu configuration\n     * contextMenu: {\n     *   items: {\n     *  \
   'option1': {\n     *       name: 'Option 1'\n     *     },\n     *     \
'option2': {\n     *       name: 'Option 2',\n     *       submenu: {\n     * \
        items: [\n     *           {\n     *             key: \
'option2:suboption1',\n     *             name: 'Suboption 1',\n     *        \
     callback: function(key, options) {\n     *               ...\n     *     \
        }\n     *           },\n     *           ...\n     *         ]\n     \
*       }\n     *     }\n     *   }\n     * },\n     * ```\n     */\n    \
contextMenu: void 0,\n    /**\n     * @description\n     * The `copyable` \
option determines whether a cell's value can be copied to the clipboard or \
not.\n     *\n     * You can set the `copyable` option to one of the \
following:\n     *\n     * | Setting                                          \
                                                              | Description   \
                                                                              \
                           |\n     * | \
-----------------------------------------------------------------------------\
--------------------------------- | \
-----------------------------------------------------------------------------\
----------------------------------------- |\n     * | `true` (default)        \
                                                                              \
         | - On pressing <kbd>**Ctrl**</kbd>/<kbd>**Cmd**</kbd> + \
<kbd>**C**</kbd>, add the cell's value to the clipboard         |\n     * | \
`false`<br>(default for the \
[`password`](@/guides/cell-types/password-cell-type.md) [cell type](#type))   \
     | - On pressing <kbd>**Ctrl**</kbd>/<kbd>**Cmd**</kbd> + \
<kbd>**C**</kbd>, add an empty string (`\"\"`) to the clipboard   |\n     *\n \
    * Read more:\n     * - [Clipboard](@/guides/cell-features/clipboard.md)\n \
    * - [Configuration options: Cascading \
configuration](@/guides/getting-started/configuration-options.md#cascading-co\
nfiguration)\n     * - [Password cell \
type](@/guides/cell-types/password-cell-type.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean}\n     * @default true\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * // enable copying for \
each cell of the entire grid\n     * copyable: true,\n     *\n     * // \
enable copying for individual columns\n     * columns: [\n     *   {\n     *  \
   // enable copying for each cell of this column\n     *     copyable: \
true\n     *   },\n     *   {\n     *     // disable copying for each cell of \
this column\n     *     copyable: false\n     *   }\n     * ]\n     *\n     * \
// enable copying for specific cells\n     * cells: [\n     *   {\n     *     \
cell: 0,\n     *     row: 0,\n     *     // disable copying for cell (0, 0)\n \
    *     copyable: false,\n     *   }\n     * ],\n     * ```\n     */\n    \
copyable: true,\n    /**\n     * The `copyPaste` option configures the \
[`CopyPaste`](@/api/copyPaste.md) plugin.\n     *\n     * You can set the \
`copyPaste` option to one of the following:\n     *\n     * | Setting         \
  | Description                                                               \
                                             |\n     * | ----------------- | \
-----------------------------------------------------------------------------\
----------------------------------------- |\n     * | `true` (default)  | \
Enable the [`CopyPaste`](@/api/copyPaste.md) plugin with the default \
configuration                                     |\n     * | `false`         \
  | Disable the [`CopyPaste`](@/api/copyPaste.md) plugin                      \
                                             |\n     * | An object         | \
- Enable the [`CopyPaste`](@/api/copyPaste.md) plugin<br>- Modify the \
[`CopyPaste`](@/api/copyPaste.md) plugin options |\n     *\n     * ##### \
copyPaste: Additional options\n     *\n     * If you set the `copyPaste` \
option to an object, you can set the following `CopyPaste` plugin options:\n  \
   *\n     * | Option                   | Possible settings                   \
               | Description                                                  \
                                                                              \
                                                         |\n     * | \
------------------------ | -------------------------------------------------- \
| \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
----------------------------------------- |\n     * | `columnsLimit`          \
 | A number (default: `Infinity`)                     | The maximum number of \
columns that can be copied                                                    \
                                                                              \
                  |\n     * | `rowsLimit`              | A number (default: \
`Infinity`)                     | The maximum number of columns that can be \
copied                                                                        \
                                                                            \
|\n     * | `pasteMode`              | `'overwrite'` \\| `'shift_down'` \\| \
`'shift_right'` | When pasting:<br>`'overwrite'`: overwrite the \
currently-selected cells<br>`'shift_down'`: move the currently-selected cells \
down<br>`'shift_right'`: move the currently-selected cells to the right |\n   \
  * | `copyColumnHeaders`      | Boolean (default: `false`)                   \
      | `true`: add a context menu option for copying cells along with their \
nearest column headers                                                        \
                                                 |\n     * | \
`copyColumnGroupHeaders` | Boolean (default: `false`)                         \
| `true`: add a context menu option for copying cells along with all their \
related columns headers                                                       \
                                             |\n     * | \
`copyColumnHeadersOnly`  | Boolean (default: `false`)                         \
| `true`: add a context menu option for copying column headers nearest to the \
selected cells (without copying cells)                                        \
                            |\n     * | `uiContainer`            | An HTML \
element                                    | The UI container for the \
secondary focusable element                                                   \
                                                                              \
               |\n     *\n     * Read more:\n     * - [Plugins: \
`CopyPaste`](@/api/copyPaste.md)\n     * - [Guides: \
Clipboard](@/guides/cell-features/clipboard.md)\n     *\n     * @memberof \
Options#\n     * @type {object|boolean}\n     * @default true\n     * \
@category CopyPaste\n     *\n     * @example\n     * ```js\n     * // enable \
the plugin with the default configuration\n     * copyPaste: true // set by \
default\n     *\n     * // disable the plugin\n     * copyPaste: false,\n     \
*\n     * // enable the plugin with a custom configuration\n     * copyPaste: \
{\n     *   // set a maximum number of columns that can be copied\n     *   \
columnsLimit: 25,\n     *\n     *   // set a maximum number of rows that can \
be copied\n     *   rowsLimit: 50,\n     *\n     *   // set the paste \
behavior\n     *   pasteMode: 'shift_down',\n     *\n     *   // add the \
option to copy cells along with their nearest column headers\n     *   \
copyColumnHeaders: true,\n     *\n     *   // add the option to copy cells \
along with all their related columns headers\n     *   \
copyColumnGroupHeaders: true,\n     *\n     *   // add the option to copy \
just column headers (without copying cells)\n     *   copyColumnHeadersOnly: \
true,\n     *\n     *   // set a UI container\n     *   uiContainer: \
document.body,\n     * },\n     * ```\n     */\n    copyPaste: true,\n    \
/**\n     * The `correctFormat` option configures whether \
incorrectly-formatted times and dates are amended or not.\n     *\n     * \
When the user enters dates and times, Handsontable can automatically adjust \
their format\n     * to match the [`dateFormat`](#dateFormat) and \
[`timeFormat`](@/guides/cell-types/time-cell-type.md) settings.\n     *\n     \
* You can set the `correctFormat` option to one of the following:\n     *\n   \
  * | Setting           | Description                                         \
                                                                              \
                        |\n     * | ----------------- | \
-----------------------------------------------------------------------------\
---------------------------------------------------------------------------- \
|\n     * | `false` (default) | Don't correct the format of the entered date \
or time (treat the entered date or time as invalid)                           \
                               |\n     * | `true`            | Correct the \
format of the entered date or time to match the [`dateFormat`](#dateFormat) \
or [`timeFormat`](@/guides/cell-types/time-cell-type.md) settings |\n     *\n \
    * Read more:\n     * - [Date cell \
type](@/guides/cell-types/date-cell-type.md)\n     * - [Time cell \
type](@/guides/cell-types/time-cell-type.md)\n     * - \
[`dateFormat`](#dateFormat)\n     *\n     * @memberof Options#\n     * @type \
{boolean}\n     * @default false\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * columns: [\n     *   {\n     *   // set the \
`type` of each cell in this column to `date`\n     *   type: 'date',\n     *  \
 // for every `date` cell of this column, set the date format to \
`YYYY-MM-DD`\n     *   dateFormat: 'YYYY-MM-DD',\n     *   // enforce the \
`YYYY-MM-DD` date format\n     *   correctFormat: true\n     *   },\n     *\n \
    *   {\n     *   // set the `type` of each cell in this column to `time`\n \
    *   type: 'time',\n     *   // for every `time` cell of this column, set \
the time format to `h:mm:ss a`\n     *   timeFormat: 'h:mm:ss a',\n     *   \
// enforce the `h:mm:ss a` time format\n     *   correctFormat: true\n     *  \
 },\n     * ],\n     * ```\n     */\n    correctFormat: false,\n    /**\n     \
* The `currentColClassName` option lets you add a CSS class name\n     * to \
each cell of the currently-visible, currently-selected columns.\n     *\n     \
* Read more:\n     * - [`currentRowClassName`](#currentRowClassName)\n     * \
- [`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`activeHeaderClassName`](#activeHeaderClassName)\n     * - \
[`invalidCellClassName`](#invalidCellClassName)\n     * - \
[`placeholderCellClassName`](#placeholderCellClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     * - [`className`](#className)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @default \
undefined\n     * @category Core\n     *\n     * @example\n     * ```js\n     \
* // add a `your-class-name` CSS class name\n     * // to each cell of the \
currently-visible, currently-selected columns\n     * currentColClassName: \
'your-class-name',\n     * ```\n     */\n    currentColClassName: void 0,\n   \
 /**\n     * The `currentHeaderClassName` option lets you add a CSS class \
name\n     * to every currently-visible, currently-selected header.\n     *\n \
    * Read more:\n     * - [`currentRowClassName`](#currentRowClassName)\n    \
 * - [`currentColClassName`](#currentColClassName)\n     * - \
[`activeHeaderClassName`](#activeHeaderClassName)\n     * - \
[`invalidCellClassName`](#invalidCellClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     * - [`className`](#className)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @default \
'ht__highlight'\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * // add an `ht__highlight` CSS class name\n     * // to every \
currently-visible, currently-selected header\n     * currentHeaderClassName: \
'ht__highlight',\n     * ```\n     */\n    currentHeaderClassName: \
\"ht__highlight\",\n    /**\n     * The `currentRowClassName` option lets you \
add a CSS class name\n     * to each cell of the currently-visible, \
currently-selected rows.\n     *\n     * Read more:\n     * - \
[`currentColClassName`](#currentColClassName)\n     * - \
[`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`activeHeaderClassName`](#activeHeaderClassName)\n     * - \
[`invalidCellClassName`](#invalidCellClassName)\n     * - \
[`placeholderCellClassName`](#placeholderCellClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     * - [`className`](#className)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @default \
undefined\n     * @category Core\n     *\n     * @example\n     * ```js\n     \
* // add a `your-class-name` CSS class name\n     * // to each cell of the \
currently-visible, currently-selected rows\n     * currentRowClassName: \
'your-class-name',\n     * ```\n     */\n    currentRowClassName: void 0,\n   \
 /**\n     * @description\n     * The `customBorders` option configures the \
[`CustomBorders`](@/api/customBorders.md) plugin.\n     *\n     * To enable \
the [`CustomBorders`](@/api/customBorders.md) plugin\n     * (and add its \
menu items to the [context \
menu](@/guides/accessories-and-menus/context-menu.md)),\n     * set the \
`customBorders` option to `true`.\n     *\n     * To enable the \
[`CustomBorders`](@/api/customBorders.md) plugin\n     * and add a predefined \
border around a particular cell,\n     * set the `customBorders` option to an \
array of objects.\n     * Each object represents a border configuration for \
one cell, and has the following properties:\n     *\n     * | Property | \
Sub-properties     | Types                              | Description         \
                                              |\n     * | -------- | \
------------------ | ---------------------------------- | \
----------------------------------------------------------------- |\n     * | \
`row`    | -                  | `row`: Number                      | The \
cell's row coordinate.                                        |\n     * | \
`col`    | -                  | `col`: Number                      | The \
cell's column coordinate.                                     |\n     * | \
`start`  | `width`<br>`color` | `width`: Number<br>`color`: String | If the \
[layout direction](@/guides/internationalization/layout-direction.md) is LTR \
(default): `start` sets the width (`width`) and color (`color`) of the \
left-hand border.<br><br>If the [layout \
direction](@/guides/internationalization/layout-direction.md) is RTL: `start` \
sets the width (`width`) and color (`color`) of the right-hand border. |\n    \
 * | `end`    | `width`<br>`color` | `width`: Number<br>`color`: String | If \
the [layout direction](@/guides/internationalization/layout-direction.md) is \
LTR (default): `end` sets the width (`width`) and color (`color`) of the \
right-hand border.<br><br>If the [layout \
direction](@/guides/internationalization/layout-direction.md) is RTL: `end` \
sets the width (`width`) and color (`color`) of the left-hand border. |\n     \
* | `top`    | `width`<br>`color` | `width`: Number<br>`color`: String | Sets \
the width (`width`) and color (`color`) of the top border. |\n     * | \
`bottom` | `width`<br>`color` | `width`: Number<br>`color`: String | Sets the \
width (`width`) and color (`color`) of the bottom border. |\n     *\n     * \
To enable the [`CustomBorders`](@/api/customBorders.md) plugin\n     * and \
add a predefined border around a range of cells,\n     * set the \
`customBorders` option to an array of objects.\n     * Each object represents \
a border configuration for a single range of cells, and has the following \
properties:\n     *\n     * | Property | Sub-properties                       \
        | Types                                                            | \
Description                                                                   \
               |\n     * | -------- | \
-------------------------------------------- | \
---------------------------------------------------------------- | \
-----------------------------------------------------------------------------\
--------------- |\n     * | `range`  | `from` {`row`, `col`}<br>`to` {`row`, \
`col`} | `from`: Object<br>`to`: Object<br>`row`: Number<br>`col`: Number | \
If the [layout direction](@/guides/internationalization/layout-direction.md) \
is LTR (default):<br>- `from` selects the range's top-left corner.<br>- `to` \
selects the range's bottom-right corner.<br><br>If the [layout \
direction](@/guides/internationalization/layout-direction.md) is RTL: <br>- \
`from` selects the range's top-right corner.<br>- `to` selects the range's \
bottom-left corner. |\n     * | `start`  | `width`<br>`color` | `width`: \
Number<br>`color`: String | If the [layout \
direction](@/guides/internationalization/layout-direction.md) is LTR \
(default): `start` sets the width (`width`) and color (`color`) of the \
left-hand border.<br><br>If the [layout \
direction](@/guides/internationalization/layout-direction.md) is RTL: `start` \
sets the width (`width`) and color (`color`) of the right-hand border. |\n    \
 * | `end`    | `width`<br>`color` | `width`: Number<br>`color`: String | If \
the [layout direction](@/guides/internationalization/layout-direction.md) is \
LTR (default): `end` sets the width (`width`) and color (`color`) of the \
right-hand border.<br><br>If the [layout \
direction](@/guides/internationalization/layout-direction.md) is RTL: `end` \
sets the width (`width`) and color (`color`) of the left-hand border. |\n     \
* | `top`    | `width`<br>`color`                           | `width`: \
Number<br>`color`: String                               | Sets the width \
(`width`) and color (`color`) of the top border. |\n     * | `bottom` | \
`width`<br>`color`                           | `width`: Number<br>`color`: \
String                               | Sets the width (`width`) and color \
(`color`) of the bottom border. |\n     *\n     * Read more:\n     * - \
[Formatting cells: Custom cell \
borders](@/guides/cell-features/formatting-cells.md#custom-cell-borders)\n    \
 * - [Context menu](@/guides/accessories-and-menus/context-menu.md)\n     * - \
[Plugins: `CustomBorders`](@/api/customBorders.md)\n     * - [Layout \
direction](@/guides/internationalization/layout-direction.md)\n     * - \
[`layoutDirection`](#layoutDirection)\n     *\n     * @memberof Options#\n    \
 * @type {boolean|object[]}\n     * @default false\n     * @category \
CustomBorders\n     *\n     * @example\n     * ```js\n     * // enable the \
`CustomBorders` plugin\n     * customBorders: true,\n     *\n     * // enable \
the `CustomBorders` plugin\n     * // and add a predefined border for a \
particular cell\n     * customBorders: [\n     *   // add an object with a \
border configuration for one cell\n     *   {\n     *     // set the cell's \
row coordinate\n     *     row: 2,\n     *     // set the cell's column \
coordinate\n     *     col: 2,\n     *     // set the left/right border's \
width and color\n     *     start: {\n     *       width: 2,\n     *       \
color: 'red'\n     *     },\n     *     // set the right/left border's width \
and color\n     *     end: {\n     *       width: 1,\n     *       color: \
'green'\n     *     },\n     *     // set the top border's width and color\n  \
   *     top: '',\n     *     // set the bottom border's width and color\n    \
 *     bottom: ''\n     *   }\n     * ],\n     *\n     * // enable the \
`CustomBorders` plugin\n     * // and add a predefined border for a range of \
cells\n     * customBorders: [\n     *   // add an object with a border \
configuration for one range of cells\n     *   {\n     *     // select a \
range of cells\n     *     range: {\n     *       // set the range's top-left \
corner\n     *       from: {\n     *         row: 1,\n     *         col: 1\n \
    *       },\n     *       // set the range's bottom-right corner\n     *   \
    to: {\n     *         row: 3,\n     *         col: 4\n     *       }\n    \
 *     },\n     *     // set the left/right border's width and color\n     *  \
   start: {\n     *       width: 2,\n     *       color: 'red'\n     *     \
},\n     *     // set the right/left border's width and color\n     *     \
end: {},\n     *     // set the top border's width and color\n     *     top: \
{},\n     *     // set the bottom border's width and color\n     *     \
bottom: {}\n     *   }\n     * ],\n     * ```\n     */\n    customBorders: \
false,\n    /**\n     * @description\n     * The `data` option sets the \
initial [data](@/guides/getting-started/binding-to-data.md) of your \
Handsontable instance.\n     *\n     * Handsontable's data is bound to your \
source data by reference (i.e. when you edit Handsontable's data, your source \
data alters as well).\n     *\n     * You can set the `data` option:\n     * \
- Either to an [array of \
arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).\n     * \
- Or to an [array of \
objects](@/guides/getting-started/binding-to-data.md#array-of-objects).\n     \
*\n     * If you don't set the `data` option (or set it to `null`), \
Handsontable renders as an empty 5x5 grid by default.\n     *\n     * Read \
more:\n     * - [Binding to \
data](@/guides/getting-started/binding-to-data.md)\n     * - \
[`dataSchema`](#dataSchema)\n     * - [`startRows`](#startRows)\n     * - \
[`startCols`](#startCols)\n     *\n     * @memberof Options#\n     * @type \
{Array[]|object[]}\n     * @default undefined\n     * @category Core\n     \
*\n     * @example\n     * ```js\n     * // as an array of arrays\n     * \
data: [\n     *   ['A', 'B', 'C'],\n     *   ['D', 'E', 'F'],\n     *   ['G', \
'H', 'J']\n     * ]\n     *\n     * // as an array of objects\n     * data: \
[\n     *   {id: 1, name: 'Ted Right'},\n     *   {id: 2, name: 'Frank \
Honest'},\n     *   {id: 3, name: 'Joan Well'},\n     *   {id: 4, name: 'Gail \
Polite'},\n     *   {id: 5, name: 'Michael Fair'},\n     * ]\n     * ```\n    \
 */\n    data: void 0,\n    /**\n     * @description\n     * When the \
[`data`](#data) option is set to an [array of \
objects](@/guides/getting-started/binding-to-data.md#array-of-objects)\n     \
* (or is empty), the `dataSchema` option defines the structure of new rows.\n \
    *\n     * Using the `dataSchema` option, you can start out with an empty \
grid.\n     *\n     * You can set the `dataSchema` option to one of the \
following:\n     * - An object\n     * - A function\n     *\n     * Read \
more:\n     * - [Binding to data: Array of objects with custom data \
schema](@/guides/getting-started/binding-to-data.md#array-of-objects-with-cus\
tom-data-schema)\n     * - [Binding to data: Function data source and \
schema](@/guides/getting-started/binding-to-data.md#function-data-source-and-\
schema)\n     * - [`data`](#data)\n     *\n     * @memberof Options#\n     * \
@type {object|Function}\n     * @default undefined\n     * @category Core\n   \
  *\n     * @example\n     * ```js\n     * // with `dataSchema`, you can \
start with an empty grid\n     * data: null,\n     * dataSchema: {id: null, \
name: {first: null, last: null}, address: null},\n     * colHeaders: ['ID', \
'First Name', 'Last Name', 'Address'],\n     * columns: [\n     *   {data: \
'id'},\n     *   {data: 'name.first'},\n     *   {data: 'name.last'},\n     * \
  {data: 'address'}\n     * ],\n     * startRows: 5,\n     * minSpareRows: \
1\n     * ```\n     */\n    dataSchema: void 0,\n    /**\n     * The \
`dateFormat` option configures the date format accepted by \
[`date`](@/guides/cell-types/date-cell-type.md) cells.\n     *\n     * You \
can set the `dateFormat` option to a string with a proper date format. The \
default value is: `'DD/MM/YYYY'`.\n     *\n     * To automatically correct \
dates whose format doesn't match the `dateFormat` setting, use the \
[`correctFormat`](#correctFormat) option.\n     *\n     * Read more:\n     * \
- [Date cell type](@/guides/cell-types/date-cell-type.md)\n     * - \
[`correctFormat`](#correctFormat)\n     * - [`defaultDate`](#defaultDate)\n   \
  *\n     * @memberof Options#\n     * @type {string}\n     * @default \
'DD/MM/YYYY'\n     * @category Core\n     *\n     * @example\n     * ```js\n  \
   * columns: [\n     *   {\n     *   // set the `type` of each cell in this \
column to `date`\n     *   type: 'date',\n     *   // for every `date` cell \
of this column, set the date format to `YYYY-MM-DD`\n     *   dateFormat: \
'YYYY-MM-DD',\n     *   },\n     * ],\n     * ```\n     */\n    dateFormat: \
\"DD/MM/YYYY\",\n    /**\n     * The `datePickerConfig` option configures the \
`date` [cell editor](@/guides/cell-functions/cell-editor.md)'s date picker, \
which uses an external dependency: \
[Pikaday](https://github.com/Pikaday/Pikaday/tree/1.8.2).\n     *\n     * You \
can set the `datePickerConfig` option to an object with any of the available \
[Pikaday \
options](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration),\n     \
* except for the following, which are always overwritten by the `date` [cell \
editor](@/guides/cell-functions/cell-editor.md):\n     * - `bound`\n     * - \
`container`\n     * - `field`\n     * - `trigger`\n     *\n     * If the \
`datePickerConfig` option is not defined, the `date` [cell \
editor](@/guides/cell-functions/cell-editor.md) overwrites the following \
[Pikaday \
options](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration) as \
well:\n     *\n     * | Pikaday option       | Handsontable's setting |\n     \
* | -------------------- | ---------------------- |\n     * | `format`        \
     | `'DD/MM/YYYY'`         |\n     * | `reposition`         | `false`      \
          |\n     *\n     * Read more:\n     * - [`editor`](#editor)\n     * \
- [`dateFormat`](#dateFormat)\n     * - [Cell \
editor](@/guides/cell-functions/cell-editor.md)\n     * - [All Pikaday \
options \
&#8594;](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration)\n     \
*\n     * @memberof Options#\n     * @type {object}\n     * @default \
undefined\n     * @category Core\n     */\n    datePickerConfig: void 0,\n    \
/**\n     * The `defaultDate` option configures the date displayed\n     * in \
empty [`date`](@/guides/cell-types/date-cell-type.md) cells.\n     *\n     * \
You can set the `defaultDate` option to a string.\n     *\n     * Read \
more:\n     * - [Date cell type](@/guides/cell-types/date-cell-type.md)\n     \
* - [`dateFormat`](#dateFormat)\n     *\n     * @memberof Options#\n     * \
@type {string}\n     * @default undefined\n     * @category Core\n     *\n    \
 * @example\n     * ```js\n     * columns: [\n     *   {\n     *     // set \
the `type` of each cell in this column to `date`\n     *     type: 'date',\n  \
   *     // in every empty `date` cell of this column, display `2015-02-02`\n \
    *     defaultDate: '2015-02-02'\n     *   }\n     * ],\n     * ```\n     \
*/\n    defaultDate: void 0,\n    /**\n     * @description\n     * The \
`disableVisualSelection` option configures how\n     * \
[selection](@/guides/cell-features/selection.md) is shown.\n     *\n     * \
You can set the `disableVisualSelection` option to one of the following:\n    \
 *\n     * | Setting           | Description                                  \
                                                       |\n     * | \
----------------- | \
-----------------------------------------------------------------------------\
---------------------- |\n     * | `false` (default) | - Show single-cell \
selection<br>- Show range selection<br>- Show header selection                \
   |\n     * | `true`            | - Don't show single-cell selection<br>- \
Don't show range selection<br>- Don't show header selection |\n     * | \
`'current'`       | - Don't show single-cell selection<br>- Show range \
selection<br>- Show header selection             |\n     * | `'area'`         \
 | - Show single-cell selection<br>- Don't show range selection<br>- Show \
header selection             |\n     * | `'header'`        | - Show \
single-cell selection<br>- Show range selection<br>- Don't show header \
selection             |\n     * | An array          | A combination of \
`'current'`, `'area'`, and/or `'header'`                                      \
     |\n     *\n     * Read more:\n     * - \
[Selection](@/guides/cell-features/selection.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean|string|string[]}\n     * @default false\n     \
* @category Core\n     *\n     * @example\n     * ```js\n     * // don't show \
single-cell selection\n     * // don't show range selection\n     * // don't \
show header selection\n     * disableVisualSelection: true,\n     *\n     * \
// don't show single-cell selection\n     * // show range selection\n     * \
// show header selection\n     * disableVisualSelection: 'current',\n     *\n \
    * // don't show single-cell selection\n     * // don't show range \
selection\n     * // show header selection\n     * disableVisualSelection: \
['current', 'area'],\n     * ```\n     */\n    disableVisualSelection: \
false,\n    /**\n     * @description\n     * The `dragToScroll` option \
configures the [`DragToScroll`](@/api/dragToScroll.md) plugin.\n     *\n     \
* You can set the `dragToScroll` option to one of the following:\n     *\n    \
 * | Setting          | Description                                           \
                      |\n     * | ---------------- | \
--------------------------------------------------------------------------- \
|\n     * | `true` (default) | When selection reaches the edge of the grid's \
viewport, scroll the viewport |\n     * | `false`          | Don't scroll the \
viewport                                                   |\n     *\n     * \
Read more:\n     * - [Plugins: `DragToScroll`](@/api/dragToScroll.md)\n     \
*\n     * @memberof Options#\n     * @type {boolean}\n     * @default true\n  \
   * @category DragToScroll\n     *\n     * @example\n     * ```js\n     * // \
when selection reaches the edge of the grid's viewport, scroll the viewport\n \
    * dragToScroll: true,\n     * ```\n     */\n    dragToScroll: true,\n    \
/**\n     * The `dropdownMenu` option configures the \
[`DropdownMenu`](@/api/dropdownMenu.md) plugin.\n     *\n     * You can set \
the `dropdownMenu` option to one of the following:\n     *\n     * | Setting  \
 | Description                                                                \
                                                                              \
                                    |\n     * | --------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
---------------------------------- |\n     * | `false`   | Disable the \
[`DropdownMenu`](@/api/dropdownMenu.md) plugin                                \
                                                                              \
                     |\n     * | `true`    | - Enable the \
[`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Use the [default context \
menu \
options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-def\
ault-options)    |\n     * | An array  | - Enable the \
[`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Modify [individual \
context menu \
options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-spe\
cific-options) |\n     * | An object | - Enable the \
[`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Apply a custom dropdown \
menu configuration                                                            \
                      |\n     *\n     * Read more:\n     * - [Context \
menu](@/guides/accessories-and-menus/context-menu.md)\n     * - [Plugins: \
`DropdownMenu`](@/api/dropdownMenu.md)\n     *\n     * @memberof Options#\n   \
  * @type {boolean|object|string[]}\n     * @default undefined\n     * \
@category DropdownMenu\n     *\n     * @example\n     * ```js\n     * // \
enable the `DropdownMenu` plugin\n     * // use the default context menu \
options\n     * dropdownMenu: true,\n     *\n     * // enable the \
`DropdownMenu` plugin\n     * // and modify individual context menu options\n \
    * dropdownMenu: ['row_above', 'row_below', '---------', 'undo', \
'redo'],\n     *\n     * // enable the `DropdownMenu` plugin\n     * // and \
apply a custom dropdown menu configuration\n     * dropdownMenu: {\n     *   \
items: {\n     *     'option1': {\n     *       name: 'Option 1'\n     *     \
},\n     *     'option2': {\n     *       name: 'Option 2',\n     *       \
submenu: {\n     *         items: [\n     *           {\n     *             \
key: 'option2:suboption1',\n     *             name: 'Suboption 1',\n     *   \
          callback(key, options) {\n     *               ...\n     *          \
   }\n     *           },\n     *           ...\n     *         ]\n     *     \
  }\n     *     }\n     *   }\n     * },\n     * ```\n     */\n    \
dropdownMenu: void 0,\n    /**\n     * The `editor` option sets a [cell \
editor](@/guides/cell-functions/cell-editor.md) for a cell.\n     *\n     * \
You can set the `editor` option to one of the following [cell editor \
aliases](@/guides/cell-functions/cell-editor.md):\n     *\n     * | Alias     \
          | Cell editor function                                              \
         |\n     * | ------------------- | \
-------------------------------------------------------------------------- \
|\n     * | A custom alias      | Your [custom cell \
editor](@/guides/cell-functions/cell-editor.md) function |\n     * | \
`'autocomplete'`    | `AutocompleteEditor`                                    \
                   |\n     * | `'base'`            | `BaseEditor`             \
                                                  |\n     * | `'checkbox'`    \
    | `CheckboxEditor`                                                        \
   |\n     * | `'date'`            | `DateEditor`                             \
                                  |\n     * | `'dropdown'`        | \
`DropdownEditor`                                                           \
|\n     * | `'handsontable'`    | `HandsontableEditor`                        \
                               |\n     * | `'numeric'`         | \
`NumericEditor`                                                            \
|\n     * | `'password'`        | `PasswordEditor`                            \
                               |\n     * | `'select'`          | \
`SelectEditor`                                                             \
|\n     * | `'text'`            | `TextEditor`                                \
                               |\n     * | `'time'`            | `TimeEditor` \
                                                              |\n     *\n     \
* To disable editing cells through cell editors,\n     * set the `editor` \
option to `false`.\n     * You'll still be able to change cells' content \
through Handsontable's API\n     * or through plugins (e.g. \
[`CopyPaste`](@/api/copyPaste.md)), though.\n     *\n     * To set the \
[`editor`](#editor), [`renderer`](#renderer), and [`validator`](#validator)\n \
    * options all at once, use the [`type`](#type) option.\n     *\n     * \
Read more:\n     * - [Cell editor](@/guides/cell-functions/cell-editor.md)\n  \
   * - [Cell type](@/guides/cell-types/cell-type.md)\n     * - [Configuration \
options: Cascading \
configuration](@/guides/getting-started/configuration-options.md#cascading-co\
nfiguration)\n     * - [`type`](#type)\n     *\n     * @memberof Options#\n   \
  * @type {string|Function|boolean}\n     * @default undefined\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // use the \
`numeric` editor for each cell of the entire grid\n     * editor: \
'numeric',\n     *\n     * // apply the `editor` option to individual \
columns\n     * columns: [\n     *   {\n     *     // use the `autocomplete` \
editor for each cell of this column\n     *     editor: 'autocomplete'\n     \
*   },\n     *   {\n     *     // disable editing cells through cell editors \
for each cell of this column\n     *     editor: false\n     *   }\n     * \
]\n     * ```\n     */\n    editor: void 0,\n    /**\n     * The \
`enterBeginsEditing` option configures the action of the <kbd>**Enter**</kbd> \
key.\n     *\n     * You can set the `enterBeginsEditing` option to one of \
the following:\n     *\n     * | Setting          | Description               \
                                                                              \
                                                                              \
                    |\n     * | ---------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
----------------------------------------------- |\n     * | `true` (default) \
| - On pressing <kbd>**Enter**</kbd> once, enter the editing mode of the \
active cell<br>- On pressing <kbd>**Enter**</kbd> twice, move to another \
cell,<br>as configured by the [`enterMoves`](#enterMoves) setting |\n     * | \
`false`          | - On pressing <kbd>**Enter**</kbd> once, move to another \
cell,<br>as configured by the [`enterMoves`](#enterMoves) setting             \
                                                                       |\n    \
 *\n     * Read more:\n     * - [`enterMoves`](#enterMoves)\n     *\n     * \
@memberof Options#\n     * @type {boolean}\n     * @default true\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // press Enter \
once to start editing\n     * // press Enter twice to move to another cell\n  \
   * enterBeginsEditing: true,\n     *\n     * // press Enter once to move to \
another cell\n     * enterBeginsEditing: false,\n     * ```\n     */\n    \
enterBeginsEditing: true,\n    /**\n     * The `enterMoves` option configures \
the action of the <kbd>**Enter**</kbd> key.\n     *\n     * If the \
[`enterBeginsEditing`](#enterBeginsEditing) option is set to `true`,\n     * \
the `enterMoves` setting applies to the **second** pressing of the \
<kbd>**Enter**</kbd> key.\n     *\n     * If the \
[`enterBeginsEditing`](#enterBeginsEditing) option is set to `false`,\n     * \
the `enterMoves` setting applies to the **first** pressing of the \
<kbd>**Enter**</kbd> key.\n     *\n     * You can set the `enterMoves` option \
to an object with the following properties\n     * (or to a function that \
returns such an object):\n     *\n     * | Property | Type   | Description    \
                                                                              \
                                                            |\n     * | \
-------- | ------ | \
-----------------------------------------------------------------------------\
--------------------------------------------------------------------------- \
|\n     * | `col`    | Number | - On pressing <kbd>**Enter**</kbd>, move \
selection `col` columns right<br>- On pressing <kbd>**Shift**</kbd> + \
<kbd>**Enter**</kbd>, move selection `col` columns left |\n     * | `row`    \
| Number | - On pressing <kbd>**Enter**</kbd>, move selection `row` rows \
down<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Enter**</kbd>, move \
selection `row` rows up          |\n     *\n     * Read more:\n     * - \
[`enterBeginsEditing`](#enterBeginsEditing)\n     *\n     * @memberof \
Options#\n     * @type {object|Function}\n     * @default {col: 0, row: 1}\n  \
   * @category Core\n     *\n     * @example\n     * ```js\n     * // on \
pressing Enter, move selection 1 column right and 1 row down\n     * // on \
pressing Shift+Enter, move selection 1 column left and 1 row up\n     * \
enterMoves: {col: 1, row: 1},\n     *\n     * // the same setting, as a \
function\n     * // `event` is a DOM Event object received on pressing \
Enter\n     * // you can use it to check whether the user pressed Enter or \
Shift+Enter\n     * enterMoves(event) {\n     *   return {col: 1, row: 1};\n  \
   * },\n     * ```\n     */\n    enterMoves: {\n      col: 0,\n      row: \
1\n    },\n    /**\n     * The `fillHandle` option configures the \
[Autofill](@/api/autofill.md) plugin.\n     *\n     * You can set the \
`fillHandle` option to one the following:\n     *\n     * | Setting        | \
Description                                                                \
|\n     * | -------------- | \
-------------------------------------------------------------------------- \
|\n     * | `true`         | - Enable autofill in all directions<br>- Add the \
fill handle               |\n     * | `false`        | Disable autofill       \
                                                    |\n     * | `'vertical'`  \
 | - Enable vertical autofill<br>- Add the fill handle                        \
|\n     * | `'horizontal'` | - Enable horizontal autofill<br>- Add the fill \
handle                      |\n     * | An object      | - Enable \
autofill<br>- Add the fill handle<br>- Configure autofill options |\n     *\n \
    * If you set the `fillHandle` option to an object, you can configure the \
following autofill options:\n     *\n     * | Option          | Possible \
settings              | Description                                           \
                                                    |\n     * | \
--------------- | ------------------------------ | \
-----------------------------------------------------------------------------\
---------------------------- |\n     * | `autoInsertRow` | `true` (default) \
\\| `false`    | `true`: When you reach the grid's bottom, add new \
rows<br>`false`: When you reach the grid's bottom, stop |\n     * | \
`direction`     | `'vertical'` \\| `'horizontal'` | `'vertical'`: Enable \
vertical autofill<br>`'horizontal'`: Enable horizontal autofill               \
       |\n     *\n     * Read more:\n     * - [AutoFill \
values](@/guides/cell-features/autofill-values.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean|string|object}\n     * @default true\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // enable \
autofill in all directions\n     * // with `autoInsertRow` enabled\n     * \
fillHandle: true,\n     *\n     * // enable vertical autofill\n     * // with \
`autoInsertRow` enabled\n     * fillHandle: 'vertical',\n     *\n     * // \
enable horizontal autofill\n     * // with `autoInsertRow` enabled\n     * \
fillHandle: 'horizontal',\n     *\n     * // enable autofill in all \
directions\n     * // with `autoInsertRow` disabled\n     * fillHandle: {\n   \
  *   autoInsertRow: false,\n     * },\n     *\n     * // enable vertical \
autofill\n     * // with `autoInsertRow` disabled\n     * fillHandle: {\n     \
*   autoInsertRow: false,\n     *   direction: 'vertical'\n     * },\n     * \
```\n     */\n    fillHandle: {\n      autoInsertRow: false\n    },\n    \
/**\n     * The `filter` option configures whether \
[`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells'\n     \
* lists are updated by the end user's input.\n     *\n     * You can set the \
`filter` option to one of the following:\n     *\n     * | Setting          | \
Description                                                                   \
                                        |\n     * | ---------------- | \
-----------------------------------------------------------------------------\
---------------------------------------- |\n     * | `true` (default) | When \
the end user types into the input area, only options matching the input are \
displayed                            |\n     * | `false`          | When the \
end user types into the input area, all options are displayed<br>(options \
matching the input are put in bold |\n     *\n     * Read more:\n     * - \
[Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)\n     \
* - [`source`](#source)\n     * - \
[`filteringCaseSensitive`](#filteringCaseSensitive)\n     *\n     * @memberof \
Options#\n     * @type {boolean}\n     * @default true\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * columns: [{\n     *   // \
set the `type` of each cell in this column to `autocomplete`\n     *   type: \
'autocomplete',\n     *   // set options available in every `autocomplete` \
cell of this column\n     *   source: ['A', 'B', 'C'],\n     *   // when the \
end user types in `A`, display only the A option\n     *   // when the end \
user types in `B`, display only the B option\n     *   // when the end user \
types in `C`, display only the C option\n     *   filter: true\n     * }],\n  \
   * ```\n     */\n    filter: true,\n    /**\n     * The \
`filteringCaseSensitive` option configures whether \
[`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells'\n     \
* input is case-sensitive.\n     *\n     * You can set the \
`filteringCaseSensitive` option to one of the following:\n     *\n     * | \
Setting           | Description                                               \
                                         |\n     * | ----------------- | \
-----------------------------------------------------------------------------\
--------------------- |\n     * | `false` (default) | \
[`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells' input \
is not case-sensitive |\n     * | `true`            | \
[`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells' input \
is case-sensitive     |\n     *\n     * Read more:\n     * - [Autocomplete \
cell type](@/guides/cell-types/autocomplete-cell-type.md)\n     * - \
[`source`](#source)\n     * - [`filter`](#filter)\n     *\n     * @memberof \
Options#\n     * @type {boolean}\n     * @default false\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * columns: [\n     *   {\n  \
   *     type: 'autocomplete',\n     *     source: [ ... ],\n     *     // \
match case while searching autocomplete options\n     *     \
filteringCaseSensitive: true\n     *   }\n     * ],\n     * ```\n     */\n    \
filteringCaseSensitive: false,\n    /**\n     * The `filters` option \
configures the [`Filters`](@/api/filters.md) plugin.\n     *\n     * You can \
set the `filters` option to one of the following:\n     *\n     * | Setting | \
Description                                      |\n     * | ------- | \
------------------------------------------------ |\n     * | `false` | \
Disable the [`Filters`](@/api/filters.md) plugin |\n     * | `true`  | Enable \
the [`Filters`](@/api/filters.md) plugin  |\n     *\n     * Read more:\n     \
* - [Column filter](@/guides/columns/column-filter.md)\n     * - [Plugins: \
`Filters`](@/api/filters.md)\n     * - [`dropdownMenu`](#dropdownMenu)\n     \
*\n     * @memberof Options#\n     * @type {boolean}\n     * @default \
undefined\n     * @category Filters\n     *\n     * @example\n     * ```js\n  \
   * // enable the `Filters` plugin\n     * filters: true,\n     * ```\n     \
*/\n    filters: void 0,\n    /**\n     * `fixedColumnsLeft` is a legacy \
option.\n     *\n     * If your grid's [layout \
direction](@/guides/internationalization/layout-direction.md) is LTR \
(default), `fixedColumnsLeft` acts like the \
[`fixedColumnsStart`](#fixedColumnsStart) option.\n     *\n     * If your \
grid's [layout direction](@/guides/internationalization/layout-direction.md) \
is RTL, using `fixedColumnsLeft` throws an error.\n     *\n     * Use \
[`fixedColumnsStart`](#fixedColumnsStart), which works in any layout \
direction.\n     *\n     * Read more:\n     * - \
[`fixedColumnsStart`](#fixedcolumnsstart)\n     *\n     * @memberof \
Options#\n     * @type {number}\n     * @default 0\n     * @category Core\n   \
  *\n     * @example\n     * ```js\n     * // freeze the first 3 columns from \
the left\n     * fixedColumnsLeft: 3,\n     * ```\n     */\n    \
fixedColumnsLeft: 0,\n    /**\n     * If your grid's [layout \
direction](@/guides/internationalization/layout-direction.md) is LTR \
(default), the `fixedColumnsStart` option sets the number of [frozen \
columns](@/guides/columns/column-freezing.md) at the left-hand edge of the \
grid.\n     *\n     * If your grid's [layout \
direction](@/guides/internationalization/layout-direction.md) is RTL, the \
`fixedColumnsStart` option sets the number of [frozen \
columns](@/guides/columns/column-freezing.md) at the right-hand edge of the \
grid.\n     *\n     * Read more:\n     * - [Column \
freezing](@/guides/columns/column-freezing.md)\n     * - [Layout \
direction](@/guides/internationalization/layout-direction.md)\n     * - \
[`fixedColumnsLeft`](#fixedcolumnsleft)\n     * - \
[`layoutDirection`](#layoutDirection)\n     *\n     * @memberof Options#\n    \
 * @type {number}\n     * @default 0\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * // when `layoutDirection` is set to `inherit` \
(default)\n     * // freeze the first 3 columns from the left or from the \
right\n     * // depending on your HTML document's `dir` attribute\n     * \
layoutDirection: 'inherit',\n     * fixedColumnsStart: 3,\n     *\n     * // \
when `layoutDirection` is set to `rtl`\n     * // freeze the first 3 columns \
from the right\n     * // regardless of your HTML document's `dir` \
attribute\n     * layoutDirection: 'rtl',\n     * fixedColumnsStart: 3,\n     \
*\n     * // when `layoutDirection` is set to `ltr`\n     * // freeze the \
first 3 columns from the left\n     * // regardless of your HTML document's \
`dir` attribute\n     * layoutDirection: 'ltr',\n     * fixedColumnsStart: \
3,\n     * ```\n     */\n    fixedColumnsStart: 0,\n    /**\n     * The \
`fixedRowsBottom` option sets the number of [frozen \
rows](@/guides/rows/row-freezing.md)\n     * at the bottom of the grid.\n     \
*\n     * Read more:\n     * - [Row \
freezing](@/guides/rows/row-freezing.md)\n     *\n     * @memberof Options#\n \
    * @type {number}\n     * @default 0\n     * @category Core\n     *\n     \
* @example\n     * ```js\n     * // freeze the bottom 3 rows\n     * \
fixedRowsBottom: 3,\n     * ```\n     */\n    fixedRowsBottom: 0,\n    /**\n  \
   * The `fixedRowsTop` option sets the number of [frozen \
rows](@/guides/rows/row-freezing.md) at the top of the grid.\n     *\n     * \
Read more:\n     * - [Row freezing](@/guides/rows/row-freezing.md)\n     *\n  \
   * @memberof Options#\n     * @type {number}\n     * @default 0\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // freeze the \
top 3 rows\n     * fixedRowsTop: 3,\n     * ```\n     */\n    fixedRowsTop: \
0,\n    /**\n     * The `formulas` option configures the \
[`Formulas`](@/api/formulas.md) plugin.\n     *\n     * The \
[`Formulas`](@/api/formulas.md) plugin uses the \
[HyperFormula](https://handsontable.github.io/hyperformula/) calculation \
engine.\n     * To install \
[HyperFormula](https://handsontable.github.io/hyperformula/), read the \
following:\n     * - [Formula calculation: Initialization \
methods](@/guides/formulas/formula-calculation.md#initialization-methods)\n   \
  *\n     * You can set the `formulas` option to an object with the following \
properties:\n     *\n     * | Property    | Possible values                   \
                                                                              \
                                                                              \
                         |\n     * | ----------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
------------------------------------------------------------ |\n     * | \
`engine`    | `HyperFormula` \\|<br>A \
[HyperFormula](https://handsontable.github.io/hyperformula/) instance \
\\|<br>A [HyperFormula \
configuration](https://handsontable.github.io/hyperformula/api/interfaces/con\
figparams.html) object |\n     * | `sheetId`   | A number                     \
                                                                              \
                                                                              \
                              |\n     * | `sheetName` | A string              \
                                                                              \
                                                                              \
                                     |\n     *\n     * Read more:\n     * - \
[Plugins: `Formulas`](@/api/formulas.md)\n     * - [Formula \
calculation](@/guides/formulas/formula-calculation.md)\n     * - \
[HyperFormula documentation: Client-side \
installation](https://handsontable.github.io/hyperformula/guide/client-side-i\
nstallation)\n     * - [HyperFormula documentation: Configuration \
options](https://handsontable.github.io/hyperformula/api/interfaces/configpar\
ams.html)\n     *\n     * @memberof Options#\n     * @type {object}\n     * \
@default undefined\n     * @category Formulas\n     *\n     * @example\n     \
* ```js\n     * // either add the `HyperFormula` class\n     * formulas: {\n  \
   *   // set `engine` to `HyperFormula`\n     *   engine: HyperFormula,\n    \
 *   sheetId: 1,\n     *   sheetName: 'Sheet 1'\n     * }\n     *\n     * // \
or, add a HyperFormula instance\n     * // initialized with the \
`'internal-use-in-handsontable'` license key\n     * const \
hyperformulaInstance = HyperFormula.buildEmpty({\n     *   licenseKey: \
'internal-use-in-handsontable',\n     * });\n     *\n     * formulas: {\n     \
*   // set `engine` to a HyperFormula instance\n     *   engine: \
hyperFormulaInstance,\n     *   sheetId: 1,\n     *   sheetName: 'Sheet 1'\n  \
   * }\n     *\n     * // or, add a HyperFormula configuration object\n     * \
formulas: {\n     *   // set `engine` to a HyperFormula configuration \
object\n     *   engine: {\n     *     hyperformula: HyperFormula // or \
`engine: hyperFormulaInstance`\n     *     leapYear1900: false,       // this \
option comes from HyperFormula\n     *     // add more HyperFormula \
configuration options\n     *   },\n     *   sheetId: 1,\n     *   sheetName: \
'Sheet 1'\n     * }\n     *\n     * // use the same HyperFormula instance in \
multiple Handsontable instances\n     *\n     * // a Handsontable instance \
`hot1`\n     * formulas: {\n     *   engine: HyperFormula,\n     *   sheetId: \
1,\n     *   sheetName: 'Sheet 1'\n     * }\n     *\n     * // a Handsontable \
instance `hot2`\n     * formulas: {\n     *   engine: \
hot1.getPlugin('formulas').engine,\n     *   sheetId: 1,\n     *   sheetName: \
'Sheet 1'\n     * }\n     * ```\n     */\n    formulas: void 0,\n    /**\n    \
 * The `fragmentSelection` option configures text selection settings.\n     \
*\n     * You can set the `fragmentSelection` option to one of the \
following:\n     *\n     * | Setting           | Decription                   \
                     |\n     * | ----------------- | \
------------------------------------------------- |\n     * | `false` \
(default) | Disable text selection                            |\n     * | \
`true`            | Enable text selection in multiple cells at a time |\n     \
* | `'cell'`          | Enable text selection in one cell at a time       |\n \
    *\n     * @memberof Options#\n     * @type {boolean|string}\n     * \
@default false\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * // enable text selection in multiple cells at a time\n     * \
fragmentSelection: true,\n     *\n     * // enable text selection in one cell \
a time\n     * fragmentSelection: 'cell',\n     * ```\n     */\n    \
fragmentSelection: false,\n    /**\n     * The `height` option configures the \
height of your grid.\n     *\n     * You can set `height` option to one of \
the following:\n     *\n     * | Setting                                      \
                              | Example                    |\n     * | \
-------------------------------------------------------------------------- | \
-------------------------- |\n     * | A number of pixels                     \
                                    | `height: 500`              |\n     * | \
A string with a [CSS unit](https://www.w3schools.com/cssref/css_units.asp) | \
`height: '75vw'`           |\n     * | A function that returns a valid number \
or string                           | `height() { return 500; }` |\n     *\n  \
   * Read more:\n     * - [Grid \
size](@/guides/getting-started/grid-size.md)\n     *\n     * @memberof \
Options#\n     * @type {number|string|Function}\n     * @default undefined\n  \
   * @category Core\n     *\n     * @example\n     * ```js\n     * // set the \
grid's height to 500px\n     * height: 500,\n     *\n     * // set the grid's \
height to 75vh\n     * height: '75vh',\n     *\n     * // set the grid's \
height to 500px, using a function\n     * height() {\n     *   return 500;\n  \
   * },\n     * ```\n     */\n    height: void 0,\n    /**\n     * The \
`hiddenColumns` option configures the \
[`HiddenColumns`](@/api/hiddenColumns.md) plugin.\n     *\n     * You can set \
the `hiddenColumns` option to one of the following:\n     *\n     * | Setting \
  | Description                                                               \
                   |\n     * | --------- | \
-----------------------------------------------------------------------------\
--------------- |\n     * | `false`   | Disable the \
[`HiddenColumns`](@/api/hiddenColumns.md) plugin                              \
   |\n     * | `true`    | Enable the \
[`HiddenColumns`](@/api/hiddenColumns.md) plugin with the default plugin \
options  |\n     * | An object | - Enable the \
[`HiddenColumns`](@/api/hiddenColumns.md) plugin<br>- Modify the plugin \
options |\n     *\n     * If you set the `hiddenColumns` to an object, you \
can set the following [`HiddenColumns`](@/api/hiddenColumns.md) plugin \
options:\n     *\n     * | Property           | Possible values     | \
Description                                                                   \
                                                                          |\n \
    * | ------------------ | ------------------- | \
-----------------------------------------------------------------------------\
-------------------------------------------------------------------------- \
|\n     * | `columns`          | An array of indexes | An array of indexes of \
columns that are hidden at initialization                                     \
                                                   |\n     * | \
`copyPasteEnabled` | `true` \\| `false`   | `true`: when copying or pasting \
data, take hidden columns into account<br>`false`: when copying or pasting \
data, don't take hidden columns into account |\n     * | `indicators`       | \
`true` \\| `false`   | `true`: display UI markers to indicate the presence of \
hidden columns<br>`false`: display UI markers                                 \
                   |\n     *\n     * Read more:\n     * - [Plugins: \
`HiddenColumns`](@/api/hiddenColumns.md)\n     * - [Column \
hiding](@/guides/columns/column-hiding.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean|object}\n     * @default undefined\n     * \
@category HiddenColumns\n     *\n     * @example\n     * ```js\n     * // \
enable the `HiddenColumns` plugin\n     * hiddenColumns: true,\n     *\n     \
* // enable `HiddenColumns` plugin, and modify the plugin options\n     * \
hiddenColumns: {\n     *   // set columns that are hidden by default\n     *  \
 columns: [5, 10, 15],\n     *   // when copying or pasting data, take hidden \
columns into account\n     *   copyPasteEnabled: true,\n     *   // show \
where hidden columns are\n     *   indicators: true\n     * }\n     * ```\n   \
  */\n    hiddenColumns: void 0,\n    /**\n     * The `hiddenRows` option \
configures the [`HiddenRows`](@/api/hiddenRows.md) plugin.\n     *\n     * \
You can set the `hiddenRows` option to one of the following:\n     *\n     * \
| Setting   | Description                                                     \
                       |\n     * | --------- | \
-----------------------------------------------------------------------------\
--------- |\n     * | `false`   | Disable the \
[`HiddenRows`](@/api/hiddenRows.md) plugin                                 \
|\n     * | `true`    | Enable the [`HiddenRows`](@/api/hiddenRows.md) plugin \
with the default plugin options  |\n     * | An object | - Enable the \
[`HiddenRows`](@/api/hiddenRows.md) plugin<br>- Modify the plugin options |\n \
    *\n     * If you set the `hiddenRows` to an object, you can set the \
following [`HiddenRows`](@/api/hiddenRows.md) plugin options:\n     *\n     * \
| Property           | Possible values     | Description                      \
                                                                              \
                                   |\n     * | ------------------ | \
------------------- | \
-----------------------------------------------------------------------------\
-------------------------------------------------------------------- |\n     \
* | `rows   `          | An array of indexes | An array of indexes of rows \
that are hidden at initialization                                             \
                                        |\n     * | `copyPasteEnabled` | \
`true` \\| `false`   | `true`: when copying or pasting data, take hidden rows \
into account<br>`false`: when copying or pasting data, don't take hidden rows \
into account |\n     * | `indicators`       | `true` \\| `false`   | `true`: \
display UI markers to indicate the presence of hidden rows<br>`false`: \
display UI markers                                                 |\n     \
*\n     * Read more:\n     * - [Plugins: `HiddenRows`](@/api/hiddenRows.md)\n \
    * - [Row hiding](@/guides/rows/row-hiding.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean|object}\n     * @default undefined\n     * \
@category HiddenRows\n     *\n     * @example\n     * ```js\n     * // enable \
the `HiddenRows` plugin\n     * hiddenRows: true,\n     *\n     * // enable \
`HiddenRows` plugin, and modify the plugin options\n     * hiddenRows: {\n    \
 *   // set rows that are hidden by default\n     *   rows: [5, 10, 15],\n    \
 *   // when copying or pasting data, take hidden rows into account\n     *   \
copyPasteEnabled: true,\n     *   // show where hidden rows are\n     *   \
indicators: true\n     * }\n     * ```\n     */\n    hiddenRows: void 0,\n    \
/**\n     * The `invalidCellClassName` option lets you add a CSS class name \
to cells\n     * that were marked as `invalid` by the [cell \
validator](@/guides/cell-functions/cell-validator.md).\n     *\n     * Read \
more:\n     * - [Cell validator](@/guides/cell-functions/cell-validator.md)\n \
    * - [`currentRowClassName`](#currentRowClassName)\n     * - \
[`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`activeHeaderClassName`](#activeHeaderClassName)\n     * - \
[`currentColClassName`](#currentColClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     * - [`className`](#className)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @default \
'htInvalid'\n     * @category Core\n     *\n     * @example\n     * ```js\n   \
  * // add a `highlight-error` CSS class name\n     * // to every `invalid` \
cell`\n     * invalidCellClassName: 'highlight-error',\n     * ```\n     */\n \
   invalidCellClassName: \"htInvalid\",\n    /**\n     * The `isEmptyCol` \
option lets you define your own custom method\n     * for checking if a \
column at a given visual index is empty.\n     *\n     * The `isEmptyCol` \
setting overwrites the built-in [`isEmptyCol`](@/api/core.md#isEmptyCol) \
method.\n     *\n     * @memberof Options#\n     * @type {Function}\n     * \
@param {number} col Visual column index.\n     * @returns {boolean}\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // overwrite \
the built-in `isEmptyCol` method\n     * isEmptyCol(visualColumnIndex) {\n    \
 *    // your custom method\n     *    ...\n     * },\n     * ```\n     */\n  \
  isEmptyCol(col) {\n      let row;\n      let rowLen;\n      let value;\n    \
  for (row = 0, rowLen = this.countRows(); row < rowLen; row++) {\n        \
value = this.getDataAtCell(row, col);\n        if (isEmpty(value) === false) \
{\n          return false;\n        }\n      }\n      return true;\n    },\n  \
  /**\n     * The `isEmptyRow` option lets you define your own custom \
method\n     * for checking if a row at a given visual index is empty.\n     \
*\n     * The `isEmptyRow` setting overwrites the built-in \
[`isEmptyRow`](@/api/core.md#isEmptyRow) method.\n     *\n     * @memberof \
Options#\n     * @type {Function}\n     * @param {number} row Visual row \
index.\n     * @returns {boolean}\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * // overwrite the built-in `isEmptyRow` \
method\n     * isEmptyRow(visualRowIndex) {\n     *    // your custom \
method\n     *    ...\n     * },\n     * ```\n     */\n    isEmptyRow(row) \
{\n      let col;\n      let colLen;\n      let value;\n      let meta;\n     \
 for (col = 0, colLen = this.countCols(); col < colLen; col++) {\n        \
value = this.getDataAtCell(row, col);\n        if (isEmpty(value) === false) \
{\n          if (typeof value === \"object\") {\n            meta = \
this.getCellMeta(row, col);\n            return \
isObjectEqual(this.getSchema()[meta.prop], value);\n          }\n          \
return false;\n        }\n      }\n      return true;\n    },\n    /**\n     \
* @description\n     * The `label` option configures \
[`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cells` labels.\n     \
*\n     * You can set the `label` option to an object with the following \
properties:\n     *\n     * | Property    | Possible values                   \
| Description                                                                 \
                                                                              \
                                                              |\n     * | \
----------- | --------------------------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
------------------------------------------------------------- |\n     * | \
`position`  | `'after'` (default) \\| `'before'` | `'after'`: place the label \
to the right of the checkbox<br>`'before'`: place the label to the left of \
the checkbox                                                                  \
                                    |\n     * | `value`     | A string \\| A \
function            | The label's text                                        \
                                                                              \
                                                                              \
    |\n     * | `separated` | `false` (default) \\| `true`       | `false`: \
don't separate the label from the checkbox<br>`true`: separate the label from \
the checkbox                                                                  \
                                                   |\n     * | `property`  | \
A string                          | - A [`data`](#data) object property name \
that's used as the label's text <br>- Works only when the [`data`](#data) \
option is set to an [array of \
objects](@/guides/getting-started/binding-to-data.md#array-of-objects) |\n    \
 *\n     * Read more:\n     * - [Checkbox cell type: Checkbox \
labels](@/guides/cell-types/checkbox-cell-type.md#checkbox-labels)\n     *\n  \
   * @memberof Options#\n     * @type {object}\n     * @default undefined\n   \
  * @category Core\n     *\n     * @example\n     * ```js\n     * columns: \
[{\n     *   type: 'checkbox',\n     *   // add 'My label:' after the \
checkbox\n     *   label: { position: 'after', value: 'My label: ', \
separated: true }\n     * }],\n     * ```\n     */\n    label: void 0,\n    \
/**\n     * The `language` option configures Handsontable's \
[language](@/guides/internationalization/language.md) settings.\n     *\n     \
* You can set the `language` option to one of the following:\n     *\n     * \
| Setting             | Description                 |\n     * | \
------------------- | --------------------------- |\n     * | `'en-US'` \
(default) | English - United States     |\n     * | `'ar-AR'`           | \
Arabic - Global.<br><br>To properly render this language, set the [layout \
direction](@/guides/internationalization/layout-direction.md) to RTL. |\n     \
* | `'cs-CZ'`           | Czech - Czech Republic      |\n     * | `'de-CH'`   \
        | German - Switzerland        |\n     * | `'de-DE'`           | \
German - Germany            |\n     * | `'es-MX'`           | Spanish - \
Mexico            |\n     * | `'fr-FR'`           | French - France           \
  |\n     * | `'it-IT'`           | Italian - Italy             |\n     * | \
`'ja-JP'`           | Japanese - Japan            |\n     * | `'ko-KR'`       \
    | Korean - Korea              |\n     * | `'lv-LV'`           | Latvian - \
Latvia            |\n     * | `'nb-NO'`           | Norwegian \
(Bokm\[CapitalATilde]\[Yen]l) - Norway |\n     * | `'nl-NL'`           | \
Dutch - Netherlands         |\n     * | `'pl-PL'`           | Polish - Poland \
            |\n     * | `'pt-BR'`           | Portuguese - Brazil         |\n \
    * | `'ru-RU'`           | Russian - Russia            |\n     * | \
`'sr-SP'`           | Serbian (Latin) - Serbia    |\n     * | `'zh-CN'`       \
    | Chinese - China             |\n     * | `'zh-TW'`           | Chinese - \
Taiwan            |\n     *\n     * Read more:\n     * - \
[Language](@/guides/internationalization/language.md)\n     * - \
[`locale`](#locale)\n     * - [`layoutDirection`](#layoutdirection)\n     *\n \
    * @memberof Options#\n     * @type {string}\n     * @default 'en-US'\n    \
 * @category Core\n     *\n     * @example\n     * ```js\n     * // set \
Handsontable's language to Polish\n     * language: 'pl-PL',\n     * ```\n    \
 */\n    language: \"en-US\",\n    /**\n     * The `layoutDirection` option \
configures whether Handsontable renders from the left to the right, or from \
the right to the left.\n     *\n     * You can set the layout direction only \
at Handsontable's \
[initialization](@/guides/getting-started/installation.md#initialize-handsont\
able). Any change of the `layoutDirection` option after the initialization \
(e.g. using the [`updateSettings()`](@/api/core.md#updatesettings) method) is \
ignored.\n     *\n     * You can set the `layoutDirection` option only [for \
the entire \
grid](@/guides/getting-started/configuration-options.md#set-grid-options).\n  \
   * You can't set it for individual columns, rows, or cells.\n     *\n     * \
You can set the `layoutDirection` option to one of the following strings:\n   \
  *\n     * | Setting             | Description                               \
                                                                              \
                                                                     |\n     \
* | ------------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
---------------------------------- |\n     * | `inherit` (default) | Set \
Handsontable's layout direction automatically,<br>based on the value of your \
HTML document's \
[`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/d\
ir) attribute  |\n     * | `rtl`               | Render Handsontable from the \
right to the left,<br>even when your HTML document's \
[`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/d\
ir) attribute is set to `ltr` |\n     * | `ltr`               | Render \
Handsontable from the left to the right,<br>even when your HTML document's \
[`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/d\
ir) attribute is set to `rtl` |\n     *\n     * Read more:\n     * - [Layout \
direction](@/guides/internationalization/layout-direction.md)\n     * - \
[Language](@/guides/internationalization/language.md)\n     * - \
[`language`](#language)\n     * - [`locale`](#locale)\n     * - \
[`fixedColumnsStart`](#fixedcolumnsstart)\n     * - \
[`customBorders`](#customBorders)\n     *\n     * @memberof Options#\n     * \
@type {string}\n     * @default 'inherit'\n     * @category Core\n     *\n    \
 * @example\n     * ```js\n     * // inherit Handsontable's layout \
direction\n     * // from the value of your HTML document's `dir` attribute\n \
    * layoutDirection: 'inherit',\n     *\n     * // render Handsontable from \
the right to the left\n     * // regardless of your HTML document's `dir`\n   \
  * layoutDirection: 'rtl',\n     *\n     * // render Handsontable from the \
left to the right\n     * // regardless of your HTML document's `dir`\n     * \
layoutDirection: 'ltr',\n     * ```\n     */\n    layoutDirection: \
\"inherit\",\n    /**\n     * The `licenseKey` option sets your Handsontable \
license key.\n     *\n     * You can set the `licenseKey` option to one of \
the following:\n     *\n     * | Setting                                      \
                                                           | Description      \
                                                                              \
   |\n     * | \
-----------------------------------------------------------------------------\
-------------------------- | \
-----------------------------------------------------------------------------\
-------------------- |\n     * | A string with your [commercial license \
key](@/guides/getting-started/license-key.md#commercial-license) | For \
[commercial \
use](@/guides/technical-specification/software-license.md#commercial-use)     \
    |\n     * | `'non-commercial-and-evaluation'`                             \
                                          | For [non-commercial \
use](@/guides/technical-specification/software-license.md#non-commercial-use) \
|\n     *\n     * Read more:\n     * - [License \
key](@/guides/getting-started/license-key.md)\n     *\n     * @memberof \
Options#\n     * @type {string}\n     * @default undefined\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * // for commercial use\n   \
  * licenseKey: 'xxxxx-xxxxx-xxxxx-xxxxx-xxxxx', // your commercial license \
key\n     *\n     * // for non-commercial use\n     * licenseKey: \
'non-commercial-and-evaluation',\n     * ```\n     */\n    licenseKey: void \
0,\n    /**\n     * The `locale` option configures Handsontable's \
[locale](@/guides/internationalization/locale.md) settings.\n     *\n     * \
You can set the `locale` option to any valid and canonicalized Unicode BCP 47 \
locale tag,\n     * both for the [entire \
grid](@/guides/internationalization/locale.md#set-the-grid-s-locale),\n     * \
and for [individual \
columns](@/guides/internationalization/locale.md#set-a-column-s-locale).\n    \
 *\n     * Read more:\n     * - \
[Locale](@/guides/internationalization/locale.md)\n     * - \
[`language`](#language)\n     * - [`layoutDirection`](#layoutdirection)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @default \
'en-US'\n     * @category Core\n     *\n     * @example\n     * ```js\n     * \
// set the entire grid's locale to Polish\n     * locale: 'pl-PL',\n     *\n  \
   * // set individual columns' locales\n     * columns: [\n     *   {\n     \
*     // set the first column's locale to Polish\n     *     locale: \
'pl-PL',\n     *   },\n     *   {\n     *     // set the second column's \
locale to German\n     *     locale: 'de-DE',\n     *   },\n     * ],\n     * \
```\n     */\n    locale: \"en-US\",\n    /**\n     * The \
`manualColumnFreeze` option configures the \
[`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin.\n     *\n     * \
You can set the `manualColumnFreeze` option to one of the following:\n     \
*\n     * | Setting  | Description                                            \
                |\n     * | -------- | \
---------------------------------------------------------------------- |\n    \
 * | `true`   | Enable the \
[`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin  |\n     * | \
`false`  | Disable the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) \
plugin |\n     *\n     * Read more:\n     * - [Column \
freezing](@/guides/columns/column-freezing.md#user-triggered-freeze)\n     \
*\n     * @memberof Options#\n     * @type {boolean}\n     * @default \
undefined\n     * @category ManualColumnFreeze\n     *\n     * @example\n     \
* ```js\n     * // enable the `ManualColumnFreeze` plugin\n     * \
manualColumnFreeze: true,\n     * ```\n     */\n    manualColumnFreeze: void \
0,\n    /**\n     * The `manualColumnMove` option configures the \
[`ManualColumnMove`](@/api/manualColumnMove.md) plugin.\n     *\n     * You \
can set the `manualColumnMove` option to one of the following:\n     *\n     \
* | Setting  | Description                                                    \
                                                    |\n     * | -------- | \
-----------------------------------------------------------------------------\
------------------------------------- |\n     * | `true`   | Enable the \
[`ManualColumnMove`](@/api/manualColumnMove.md) plugin                        \
                          |\n     * | `false`  | Disable the \
[`ManualColumnMove`](@/api/manualColumnMove.md) plugin                        \
                         |\n     * | An array | - Enable the \
[`ManualColumnMove`](@/api/manualColumnMove.md) plugin<br>- Move individual \
columns at initialization |\n     *\n     * Read more:\n     * - [Column \
moving](@/guides/columns/column-moving.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean|number[]}\n     * @default undefined\n     * \
@category ManualColumnMove\n     *\n     * @example\n     * ```js\n     * // \
enable the `ManualColumnMove` plugin\n     * manualColumnMove: true,\n     \
*\n     * // enable the `ManualColumnMove` plugin\n     * // at \
initialization, move column 0 to 1\n     * // at initialization, move column \
1 to 4\n     * // at initialization, move column 2 to 6\n     * \
manualColumnMove: [1, 4, 6],\n     * ```\n     */\n    manualColumnMove: void \
0,\n    /**\n     * @description\n     * The `manualColumnResize` option \
configures the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin.\n  \
   *\n     * You can set the `manualColumnResize` option to one of the \
following:\n     *\n     * | Setting  | Description                           \
                                                                              \
  |\n     * | -------- | \
-----------------------------------------------------------------------------\
---------------------------------------- |\n     * | `true`   | Enable the \
[`ManualColumnResize`](@/api/manualColumnResize.md) plugin                    \
                             |\n     * | `false`  | Disable the \
[`ManualColumnResize`](@/api/manualColumnResize.md) plugin                    \
                            |\n     * | An array | - Enable the \
[`ManualColumnResize`](@/api/manualColumnResize.md) plugin<br>- Set initial \
widths of individual columns |\n     *\n     * Read more:\n     * - [Column \
width: Column \
stretching](@/guides/columns/column-width.md#column-stretching)\n     *\n     \
* @memberof Options#\n     * @type {boolean|number[]}\n     * @default \
undefined\n     * @category ManualColumnResize\n     *\n     * @example\n     \
* ```js\n     * // enable the `manualColumnResize` plugin\n     * \
manualColumnResize: true,\n     *\n     * // enable the `manualColumnResize` \
plugin\n     * // set the initial width of column 0 to 40 pixels\n     * // \
set the initial width of column 1 to 50 pixels\n     * // set the initial \
width of column 2 to 60 pixels\n     * manualColumnResize: [40, 50, 60],\n    \
 * ```\n     */\n    manualColumnResize: void 0,\n    /**\n     * \
@description\n     * The `manualRowMove` option configures the \
[`ManualRowMove`](@/api/manualRowMove.md) plugin.\n     *\n     * You can set \
the `manualRowMove` option to one of the following:\n     *\n     * | Setting \
 | Description                                                                \
                               |\n     * | -------- | \
-----------------------------------------------------------------------------\
---------------------------- |\n     * | `true`   | Enable the \
[`ManualRowMove`](@/api/manualRowMove.md) plugin                              \
                 |\n     * | `false`  | Disable the \
[`ManualRowMove`](@/api/manualRowMove.md) plugin                              \
                |\n     * | An array | - Enable the \
[`ManualRowMove`](@/api/manualRowMove.md) plugin<br>- Move individual rows at \
initialization |\n     *\n     * Read more:\n     * - [Row \
moving](@/guides/rows/row-moving.md)\n     *\n     * @memberof Options#\n     \
* @type {boolean|number[]}\n     * @default undefined\n     * @category \
ManualRowMove\n     *\n     * @example\n     * ```js\n     * // enable the \
`ManualRowMove` plugin\n     * manualRowMove: true,\n     *\n     * // enable \
the `ManualRowMove` plugin\n     * // at initialization, move row 0 to 1\n    \
 * // at initialization, move row 1 to 4\n     * // at initialization, move \
row 2 to 6\n     * manualColumnMove: [1, 4, 6],\n     * ```\n     */\n    \
manualRowMove: void 0,\n    /**\n     * @description\n     * The \
`manualRowResize` option configures the \
[`ManualRowResize`](@/api/manualRowResize.md) plugin.\n     *\n     * You can \
set the `manualRowResize` option to one of the following:\n     *\n     * | \
Setting  | Description                                                        \
                                           |\n     * | -------- | \
-----------------------------------------------------------------------------\
-------------------------------- |\n     * | `true`   | Enable the \
[`ManualRowResize`](@/api/manualRowResize.md) plugin                          \
                     |\n     * | `false`  | Disable the \
[`ManualRowResize`](@/api/manualRowResize.md) plugin                          \
                    |\n     * | An array | - Enable the \
[`ManualRowResize`](@/api/manualRowResize.md) plugin<br>- Set initial heights \
of individual rows |\n     *\n     * Read more:\n     * - [Row height: Adjust \
the row height \
manually](@/guides/rows/row-height.md#adjust-the-row-height-manually)\n     \
*\n     * @memberof Options#\n     * @type {boolean|number[]}\n     * \
@default undefined\n     * @category ManualRowResize\n     *\n     * \
@example\n     * ```js\n     * // enable the `ManualRowResize` plugin\n     * \
manualRowResize: true,\n     *\n     * // enable the `ManualRowResize` \
plugin\n     * // set the initial height of row 0 to 40 pixels\n     * // set \
the initial height of row 1 to 50 pixels\n     * // set the initial height of \
row 2 to 60 pixels\n     * manualRowResize: [40, 50, 60],\n     * ```\n     \
*/\n    manualRowResize: void 0,\n    /**\n     * The `maxCols` option sets a \
maximum number of columns.\n     *\n     * The `maxCols` option is used:\n    \
 * - At initialization: if the `maxCols` value is lower than the initial \
number of columns,\n     * Handsontable trims columns from the right.\n     * \
- At runtime: for example, when inserting columns.\n     *\n     * @memberof \
Options#\n     * @type {number}\n     * @default Infinity\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * // set the maximum number \
of columns to 300\n     * maxCols: 300,\n     * ```\n     */\n    maxCols: \
Infinity,\n    /**\n     * The `maxRows` option sets a maximum number of \
rows.\n     *\n     * The `maxRows` option is used:\n     * - At \
initialization: if the `maxRows` value is lower than the initial number of \
rows,\n     * Handsontable trims rows from the bottom.\n     * - At runtime: \
for example, when inserting rows.\n     *\n     * @memberof Options#\n     * \
@type {number}\n     * @default Infinity\n     * @category Core\n     *\n     \
* @example\n     * ```js\n     * // set the maximum number of rows to 300\n   \
  * maxRows: 300,\n     * ```\n     */\n    maxRows: Infinity,\n    /**\n     \
* @description\n     * The `mergeCells` option configures the \
[`MergeCells`](@/api/mergeCells.md) plugin.\n     *\n     * You can set the \
`mergeCells` option to one of the following:\n     *\n     * | Setting        \
     | Description                                                            \
                             |\n     * | ------------------- | \
-----------------------------------------------------------------------------\
---------------------- |\n     * | `true`              | Enable the \
[`MergeCells`](@/api/mergeCells.md) plugin                                    \
           |\n     * | `false`             | Disable the \
[`MergeCells`](@/api/mergeCells.md) plugin                                    \
          |\n     * | An array of objects | - Enable the \
[`MergeCells`](@/api/mergeCells.md) plugin<br>- Merge specific cells at \
initialization |\n     *\n     * To merge specific cells at Handsontable's \
initialization,\n     * set the `mergeCells` option to an array of objects, \
with the following properties:\n     *\n     * | Property  | Description      \
                                          |\n     * | --------- | \
---------------------------------------------------------- |\n     * | `row`  \
   | The row index of the merged section's beginning            |\n     * | \
`col`     | The column index of the merged section's beginning         |\n    \
 * | `rowspan` | The width (as a number of rows) of the merged section      \
|\n     * | `colspan` | The height (as a number of columns ) of the merged \
section |\n     *\n     * Read more:\n     * - [Merge \
cells](@/guides/cell-features/merge-cells.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean|object[]}\n     * @default false\n     * \
@category MergeCells\n     *\n     * @example\n     * ```js\n     * // enable \
the `MergeCells` plugin\n     * mergeCells: true,\n     *\n     * // enable \
the `MergeCells` plugin\n     * // and merge specific cells at \
initialization\n     * mergeCells: [\n     *   // merge cells from cell (1,1) \
to cell (3,3)\n     *   {row: 1, col: 1, rowspan: 3, colspan: 3},\n     *   \
// merge cells from cell (3,4) to cell (2,2)\n     *   {row: 3, col: 4, \
rowspan: 2, colspan: 2},\n     *   // merge cells from cell (5,6) to cell \
(3,3)\n     *   {row: 5, col: 6, rowspan: 3, colspan: 3}\n     * ],\n     * \
```\n     */\n    mergeCells: false,\n    /**\n     * The `minCols` option \
sets a minimum number of columns.\n     *\n     * The `minCols` option is \
used:\n     * - At initialization: if the `minCols` value is higher than the \
initial number of columns,\n     * Handsontable adds empty columns to the \
right.\n     * - At runtime: for example, when removing columns.\n     *\n    \
 * The `minCols` option works only when your [`data`](#data) is an [array of \
arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).\n     * \
When your [`data`](#data) is an [array of \
objects](@/guides/getting-started/binding-to-data.md#array-of-objects),\n     \
* you can only have as many columns as defined in:\n     * - The first data \
row\n     * - The [`dataSchema`](#dataSchema) option\n     * - The \
[`columns`](#columns) option\n     *\n     * @memberof Options#\n     * @type \
{number}\n     * @default 0\n     * @category Core\n     *\n     * @example\n \
    * ```js\n     * // set the minimum number of columns to 10\n     * \
minCols: 10,\n     * ```\n     */\n    minCols: 0,\n    /**\n     * The \
`minRows` option sets a minimum number of rows.\n     *\n     * The `minRows` \
option is used:\n     * - At initialization: if the `minRows` value is higher \
than the initial number of rows,\n     * Handsontable adds empty rows at the \
bottom.\n     * - At runtime: for example, when removing rows.\n     *\n     \
* @memberof Options#\n     * @type {number}\n     * @default 0\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // set the \
minimum number of rows to 10\n     * minRows: 10,\n     * ```\n     */\n    \
minRows: 0,\n    /**\n     * The `minSpareCols` option sets a minimum number \
of empty columns\n     * at the grid's right-hand end.\n     *\n     * If \
there already are other empty columns at the grid's right-hand end,\n     * \
they are counted into the `minSpareCols` value.\n     *\n     * The total \
number of columns can't exceed the [`maxCols`](#maxCols) value.\n     *\n     \
* The `minSpareCols` option works only when your [`data`](#data) is an [array \
of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).\n    \
 * When your [`data`](#data) is an [array of \
objects](@/guides/getting-started/binding-to-data.md#array-of-objects),\n     \
* you can only have as many columns as defined in:\n     * - The first data \
row\n     * - The [`dataSchema`](#dataSchema) option\n     * - The \
[`columns`](#columns) option\n     *\n     * @memberof Options#\n     * @type \
{number}\n     * @default 0\n     * @category Core\n     *\n     * @example\n \
    * ```js\n     * // at Handsontable's initialization, add at least 3 empty \
columns on the right\n     * minSpareCols: 3,\n     * ```\n     */\n    \
minSpareCols: 0,\n    /**\n     * The `minSpareRows` option sets a minimum \
number of empty rows\n     * at the bottom of the grid.\n     *\n     * If \
there already are other empty rows at the bottom,\n     * they are counted \
into the `minSpareRows` value.\n     *\n     * The total number of rows can't \
exceed the [`maxRows`](#maxRows) value.\n     *\n     * @memberof Options#\n  \
   * @type {number}\n     * @default 0\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * // at Handsontable's initialization, add at \
least 3 empty rows at the bottom\n     * minSpareRows: 3,\n     * ```\n     \
*/\n    minSpareRows: 0,\n    /**\n     * @description\n     * The \
`multiColumnSorting` option configures the \
[`MultiColumnSorting`](@/api/columnSorting.md) plugin.\n     *\n     * You \
can set the `multiColumnSorting` option to one of the following:\n     *\n    \
 * | Setting    | Description                                                 \
                                                                              \
                 |\n     * | ---------- | \
-----------------------------------------------------------------------------\
----------------------------------------------------------------------------- \
|\n     * | `true`     | Enable the \
[`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin with the default \
configuration                                                       |\n     * \
| `false`    | Disable the \
[`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin                    \
                                                                 |\n     * | \
An object  | - Enable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) \
plugin<br>- Modify the [`MultiColumnSorting`](@/api/multiColumnSorting.md) \
plugin options |\n     *\n     * If you set the `multiColumnSorting` option \
to an object,\n     * you can set the following \
[`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin options:\n     *\n \
    * | Option                   | Possible settings                          \
                                                                              \
                        |\n     * | ------------------------ | \
-----------------------------------------------------------------------------\
------------------------------------------------------------------- |\n     * \
| `indicator`              | `true`: Display the arrow icon in the column \
header, to indicate a sortable column<br>`false`: Don't display the arrow \
icon in the column header |\n     * | `headerAction`           | `true`: \
Enable clicking on the column header to sort the column<br>`false`: Disable \
clicking on the column header to sort the column             |\n     * | \
`sortEmptyCells`         | `true`: Sort empty cells as well<br>`false`: Place \
empty cells at the end                                                        \
                |\n     * | `compareFunctionFactory` | A [custom compare \
function](@/guides/rows/rows-sorting.md#add-a-custom-comparator)              \
                                                 |\n     *\n     * If you set \
the `multiColumnSorting` option to an object,\n     * you can also sort \
individual columns at Handsontable's initialization.\n     * In the \
`multiColumnSorting` object, add an object named `initialConfig`,\n     * \
with the following properties:\n     *\n     * | Option      | Possible \
settings   | Description                                                      \
|\n     * | ----------- | ------------------- | \
---------------------------------------------------------------- |\n     * | \
`column`    | A number            | The index of the column that you want to \
sort at initialization  |\n     * | `sortOrder` | `'asc'` \\| `'desc'` | The \
sorting order:<br>`'asc'`: ascending<br>`'desc'`: descending |\n     *\n     \
* Read more:\n     * - [Rows sorting](@/guides/rows/rows-sorting.md)\n     * \
- [`columnSorting`](#columnSorting)\n     *\n     * @memberof Options#\n     \
* @type {boolean|object}\n     * @default undefined\n     * @category \
MultiColumnSorting\n     *\n     * @example\n     * ```js\n     * // enable \
the `MultiColumnSorting` plugin\n     * multiColumnSorting: true\n     *\n    \
 * // enable the `MultiColumnSorting` plugin with custom configuration\n     \
* multiColumnSorting: {\n     *   // sort empty cells as well\n     *   \
sortEmptyCells: true,\n     *   // display the arrow icon in the column \
header\n     *   indicator: true,\n     *   // disable clicking on the column \
header to sort the column\n     *   headerAction: false,\n     *   // add a \
custom compare function\n     *   compareFunctionFactory(sortOrder, \
columnMeta) {\n     *     return function(value, nextValue) {\n     *       \
// some value comparisons which will return -1, 0 or 1...\n     *     }\n     \
*   }\n     * }\n     *\n     * // enable the `MultiColumnSorting` plugin\n   \
  * multiColumnSorting: {\n     *   // at initialization, sort column 1 in \
ascending order\n     *   initialConfig: {\n     *     column: 1,\n     *     \
sortOrder: 'asc'\n     *   },\n     *   // at initialization, sort column 2 \
in descending order\n     *   initialConfig: {\n     *     column: 2,\n     * \
    sortOrder: 'desc'\n     *   }\n     * }\n     * ```\n     */\n    \
multiColumnSorting: void 0,\n    /**\n     * @description\n     * The \
`nestedHeaders` option configures the \
[`NestedHeaders`](@/api/nestedHeaders.md) plugin.\n     *\n     * You can set \
the `nestedHeaders` option to one of the following:\n     *\n     * | Setting \
          | Description                                                       \
                                                                    |\n     * \
| ----------------- | \
-----------------------------------------------------------------------------\
-------------------------------------------------------- |\n     * | `false` \
(default) | Disable the [`NestedHeaders`](@/api/nestedHeaders.md) plugin      \
                                                                    |\n     * \
| `true`            | - Enable the [`NestedHeaders`](@/api/nestedHeaders.md) \
plugin<br>- Don't configure any nested headers                                \
 |\n     * | Array of arrays   | - Enable the \
[`NestedHeaders`](@/api/nestedHeaders.md) plugin<br>- Configure headers that \
are nested on Handsontable's initialization |\n     *\n     * If you set the \
`nestedHeaders` option to an array of arrays, each array configures one set \
of nested headers.\n     *\n     * Each array element configures one header, \
and can be one of the following:\n     *\n     * | Array element | \
Description                                                                   \
               |\n     * | ------------- | \
-----------------------------------------------------------------------------\
--------------- |\n     * | A string      | The header's label                \
                                                           |\n     * | An \
object     | Properties:<br>`label` (string): the header's label<br>`colspan` \
(integer): the column width |\n     *\n     * Read more:\n     * - [Plugins: \
`NestedHeaders`](@/api/nestedHeaders.md)\n     * - [Column groups: Nested \
headers](@/guides/columns/column-groups.md#nested-headers)\n     *\n     * \
@memberof Options#\n     * @type {boolean|Array[]}\n     * @default \
undefined\n     * @category NestedHeaders\n     *\n     * @example\n     * \
```js\n     * nestedHeaders: [\n     *   ['A', {label: 'B', colspan: 8}, \
'C'],\n     *   ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, \
'G'],\n     *   ['H', 'I', 'J', 'K', 'L', 'M', 'N', 'R', 'S', 'T']\n     * \
],\n     * ```\n     */\n    nestedHeaders: void 0,\n    /**\n     * \
@description\n     * The `nestedRows` option configures the \
[`NestedRows`](@/api/nestedRows.md) plugin.\n     *\n     * You can set the \
`nestedRows` option to one of the following:\n     *\n     * | Setting        \
   | Description                                            |\n     * | \
----------------- | ------------------------------------------------------ \
|\n     * | `false` (default) | Disable the \
[`NestedRows`](@/api/nestedRows.md) plugin |\n     * | `true`            | \
Enable the [`NestedRows`](@/api/nestedRows.md) plugin  |\n     *\n     * Read \
more:\n     * - [Plugins: `NestedRows`](@/api/nestedRows.md)\n     *\n     * \
@example\n     * ```js\n     * // enable the `NestedRows` plugin\n     * \
nestedRows: true,\n     * ```\n     *\n     * @memberof Options#\n     * \
@type {boolean}\n     * @default false\n     * @category NestedRows\n     \
*/\n    nestedRows: void 0,\n    /**\n     * The `noWordWrapClassName` option \
lets you add a CSS class name\n     * to each cell that has the \
[`wordWrap`](#wordWrap) option set to `false`.\n     *\n     * Read more:\n   \
  * - [`wordWrap`](#wordWrap)\n     * - \
[`currentRowClassName`](#currentRowClassName)\n     * - \
[`currentColClassName`](#currentColClassName)\n     * - \
[`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`invalidCellClassName`](#invalidCellClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     * - [`className`](#className)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @default \
'htNoWrap'\n     * @category Core\n     *\n     * @example\n     * ```js\n    \
 * // add an `is-noWrapCell` CSS class name\n     * // to each cell that \
doesn't wrap content\n     * noWordWrapClassName: 'is-noWrapCell',\n     * \
```\n     */\n    noWordWrapClassName: \"htNoWrap\",\n    /**\n     * The \
`numericFormat` option configures the number format and the currency format\n \
    * of [`numeric`](@/guides/cell-types/numeric-cell-type.md) cells` \
displayed output\n     * in the numeric cell renderer.\n     *\n     * You \
can set the `numericFormat` option to an object with the following \
properties:\n     *\n     * | Property    | Possible values                   \
                                            | Description     |\n     * | \
----------- | \
----------------------------------------------------------------------------- \
| --------------- |\n     * | `pattern`   | All [`numbro.js` number \
formats](https://numbrojs.com/format.html#numbers)    | Number format   |\n   \
  * | `culture`   | All [`numbro.js` currency \
formats](https://numbrojs.com/format.html#currency) | Currency format |\n     \
*\n     * The `numericFormat` option as no effect on the numeric cell \
editor.\n     *\n     * In the source data, numeric data is stored as \
JavaScript numbers.\n     *\n     * Read more:\n     * - [Numeric cell \
type](@/guides/cell-types/numeric-cell-type.md)\n     * - [Third-party \
licenses](@/guides/technical-specification/third-party-licenses.md)\n     *\n \
    * @memberof Options#\n     * @since 0.35.0\n     * @type {object}\n     * \
@default undefined\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * columns: [\n     *   {\n     *     // set the `type` of each \
cell in this column to `numeric`\n     *     type: 'numeric',\n     *     // \
set the `numericFormat` option for every `numeric` cell of this column\n     \
*     numericFormat: {\n     *       // set the number format\n     *       \
pattern: '0,00',\n     *       // set the currency format\n     *       \
culture: 'en-US'\n     *     }\n     *   }\n     * ],\n     * ```\n     */\n  \
  numericFormat: void 0,\n    /**\n     * If the `observeDOMVisibility` \
option is set to `true`,\n     * Handsontable rerenders every time it detects \
that the grid was made visible in the DOM.\n     *\n     * @memberof \
Options#\n     * @type {boolean}\n     * @default true\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * // don't rerender the \
grid on visibility changes\n     * observeDOMVisibility: false,\n     * ```\n \
    */\n    observeDOMVisibility: true,\n    /**\n     * The \
`outsideClickDeselects` option determines what happens to the current \
[selection](@/guides/cell-features/selection.md)\n     * when you click \
outside of the grid.\n     *\n     * You can set the `outsideClickDeselects` \
option to one of the following:\n     *\n     * | Setting          | \
Description                                                                   \
                           |\n     * | ---------------- | \
-----------------------------------------------------------------------------\
--------------------------- |\n     * | `true` (default) | On a mouse click \
outside of the grid, clear the current \
[selection](@/guides/cell-features/selection.md) |\n     * | `false`          \
| On a mouse click outside of the grid, keep the current \
[selection](@/guides/cell-features/selection.md)  |\n     * | A function      \
 | A function that takes the click event target and returns a boolean         \
                              |\n     *\n     * @memberof Options#\n     * \
@type {boolean|Function}\n     * @default true\n     * @category Core\n     \
*\n     * @example\n     * ```js\n     * // on a mouse click outside of the \
grid, clear the current selection\n     * outsideClickDeselects: true,\n     \
*\n     * // on a mouse click outside of the grid, keep the current \
selection\n     * outsideClickDeselects: false,\n     *\n     * // take the \
click event target and return `false`\n     * outsideClickDeselects(event) \
{\n     *   return false;\n     * }\n     *\n     * // take the click event \
target and return `true`\n     * outsideClickDeselects(event) {\n     *   \
return false;\n     * }\n     * ```\n     */\n    outsideClickDeselects: \
true,\n    /**\n     * @description\n     * The `persistentState` option \
configures the [`PersistentState`](@/api/persistentState.md) plugin.\n     \
*\n     * You can set the `persistentState` to one of the following:\n     \
*\n     * | Setting           | Description                                   \
                   |\n     * | ----------------- | \
---------------------------------------------------------------- |\n     * | \
`false` (default) | Disable the [`PersistentState`](@/api/persistentState.md) \
plugin |\n     * | `true`            | Enable the \
[`PersistentState`](@/api/persistentState.md) plugin  |\n     *\n     * Read \
more:\n     * - [Saving data: Saving data \
locally](@/guides/getting-started/saving-data.md#save-data-locally)\n     * - \
[Plugins: `PersistentState`](@/api/persistentState.md)\n     *\n     * \
@memberof Options#\n     * @type {boolean}\n     * @default false\n     * \
@category PersistentState\n     *\n     * @example\n     * ```js\n     * // \
enable the `PersistentState` plugin\n     * persistentState: true,\n     * \
```\n     */\n    persistentState: void 0,\n    /**\n     * The `placeholder` \
option lets you display placeholder text in every empty cell.\n     *\n     * \
You can set the `placeholder` option to one of the following:\n     *\n     * \
| Setting            | Example        | Description                           \
                                |\n     * | ------------------ | \
-------------- | \
--------------------------------------------------------------------- |\n     \
* | A non-empty string | `'Empty cell'` | Display `Empty cell` text in empty \
cells                              |\n     * | A non-string value | `000`     \
     | Display `000` text in empty cells (non-string values get stringified) \
|\n     *\n     * Read more:\n     * - \
[`placeholderCellClassName`](#placeholderCellClassName)\n     *\n     * \
@memberof Options#\n     * @type {string}\n     * @default undefined\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // display \
'Empty cell' text\n     * // in every empty cell of the entire grid\n     * \
placeholder: 'Empty cell',\n     *\n     * // or\n     * columns: [\n     *   \
{\n     *     data: 'date',\n     *     dateFormat: 'DD/MM/YYYY',\n     *     \
// display 'Empty date cell' text\n     *     // in every empty cell of the \
`date` column\n     *     placeholder: 'Empty date cell'\n     *   }\n     * \
],\n     * ```\n     */\n    placeholder: void 0,\n    /**\n     * The \
`placeholderCellClassName` option lets you add a CSS class name to cells\n    \
 * that contain [`placeholder`](#placeholder) text.\n     *\n     * Read \
more:\n     * - [Cell validator](@/guides/cell-functions/cell-validator.md)\n \
    * - [`placeholder`](#placeholder)\n     * - \
[`currentRowClassName`](#currentRowClassName)\n     * - \
[`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`activeHeaderClassName`](#activeHeaderClassName)\n     * - \
[`currentColClassName`](#currentColClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     * - [`className`](#className)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @default \
'htPlaceholder'\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * // add a `has-placeholder` CSS class name\n     * // to each \
cell that contains `placeholder` text\n     * placeholderCellClassName: \
'has-placeholder',\n     * ```\n     */\n    placeholderCellClassName: \
\"htPlaceholder\",\n    /**\n     * The `preventOverflow` option configures \
preventing Handsontable\n     * from overflowing outside of its parent \
element.\n     *\n     * You can set the `preventOverflow` option to one of \
the following:\n     *\n     * | Setting           | Description              \
        |\n     * | ----------------- | -------------------------------- |\n  \
   * | `false` (default) | Don't prevent overflowing        |\n     * | \
`'horizontal'`      | Prevent horizontal overflowing |\n     * | `'vertical'` \
       | Prevent vertical overflowing   |\n     *\n     * @memberof \
Options#\n     * @type {string|boolean}\n     * @default false\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // prevent \
horizontal overflowing\n     * preventOverflow: 'horizontal',\n     * ```\n   \
  */\n    preventOverflow: false,\n    /**\n     * The `preventWheel` option \
configures preventing the `wheel` event's default action\n     * on \
overlays.\n     *\n     * You can set the `preventWheel` option to one of the \
following:\n     *\n     * | Setting           | Description                  \
                    |\n     * | ----------------- | \
------------------------------------------------ |\n     * | `false` \
(default) | Don't prevent the `wheel` event's default action |\n     * | \
`true`            | Prevent the `wheel` event's default action       |\n     \
*\n     * @memberof Options#\n     * @private\n     * @type {boolean}\n     * \
@default false\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * // don't prevent the `wheel` event's default action\n     * \
preventWheel: false,\n     * ```\n     */\n    preventWheel: false,\n    \
/**\n     * @description\n     * The `readOnly` option determines whether a \
cell, column or comment is editable or not.\n     *\n     * You can set the \
`readOnly` option to one of the following:\n     *\n     * | Setting          \
 | Decription                                                                 \
                                               |\n     * | ----------------- \
| \
-----------------------------------------------------------------------------\
-------------------------------------------- |\n     * | `false` (default) | \
Set as editable                                                               \
                                            |\n     * | `true`            | - \
Set as read-only<br>- Add the \
[`readOnlyCellClassName`](#readOnlyCellClassName) CSS class name (by default: \
`htDimmed`) |\n     *\n     * `readOnly` cells can't be changed by the \
[`populateFromArray()`](@/api/core.md#populatefromarray) method.\n     *\n    \
 * Read more:\n     * - [Configuration options: Cascading \
configuration](@/guides/getting-started/configuration-options.md#cascading-co\
nfiguration)\n     *\n     * @memberof Options#\n     * @type {boolean}\n     \
* @default false\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * // set as read-only\n     * readOnly: true,\n     * ```\n     \
*/\n    readOnly: false,\n    /**\n     * The `readOnlyCellClassName` option \
lets you add a CSS class name to [read-only](#readOnly) cells.\n     *\n     \
* Read more:\n     * - [`currentRowClassName`](#currentRowClassName)\n     * \
- [`currentColClassName`](#currentColClassName)\n     * - \
[`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`activeHeaderClassName`](#activeHeaderClassName)\n     * - \
[`invalidCellClassName`](#invalidCellClassName)\n     * - \
[`placeholderCellClassName`](#placeholderCellClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`TableClassName`](#TableClassName)\n     *\n     * @memberof Options#\n     \
* @type {string}\n     * @default 'htDimmed'\n     * @category Core\n     *\n \
    * @example\n     * ```js\n     * // add a `is-readOnly` CSS class name\n  \
   * // to every read-only cell\n     * readOnlyCellClassName: \
'is-readOnly',\n     * ```\n     */\n    readOnlyCellClassName: \
\"htDimmed\",\n    /**\n     * The `renderAllRows` option configures \
Handsontable's [row virtualization](@/guides/rows/row-virtualization.md).\n   \
  *\n     * You can set the `renderAllRows` option to one of the following:\n \
    *\n     * | Setting           | Description                               \
                                                         |\n     * | \
----------------- | \
-----------------------------------------------------------------------------\
--------------------- |\n     * | `false` (default) | Enable [row \
virtualization](@/guides/rows/row-virtualization.md)                          \
         |\n     * | `true`            | Disable [row \
virtualization](@/guides/rows/row-virtualization.md)<br>(render all rows of \
the grid) |\n     *\n     * Read more:\n     * - [Row \
virtualization](@/guides/rows/row-virtualization.md)\n     *\n     * \
@memberof Options#\n     * @type {boolean}\n     * @default undefined\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // disable row \
virtualization\n     * renderAllRows: true,\n     * ```\n     */\n    \
renderAllRows: void 0,\n    /**\n     * @description\n     * The `renderer` \
option sets a [cell renderer](@/guides/cell-functions/cell-renderer.md) for a \
cell.\n     *\n     * You can set the `renderer` option to one of the \
following:\n     * - A custom renderer function\n     * - One of the \
following [cell renderer \
aliases](@/guides/cell-functions/cell-renderer.md):\n     *\n     * | Alias   \
            | Cell renderer function                                          \
               |\n     * | ------------------- | \
-----------------------------------------------------------------------------\
- |\n     * | A custom alias      | Your [custom cell \
renderer](@/guides/cell-functions/cell-renderer.md) function |\n     * | \
`'autocomplete'`    | `AutocompleteRenderer`                                  \
                       |\n     * | `'base'`            | `BaseRenderer`       \
                                                          |\n     * | \
`'checkbox'`        | `CheckboxRenderer`                                      \
                       |\n     * | `'date'`            | `DateRenderer`       \
                                                          |\n     * | \
`'dropdown'`        | `DropdownRenderer`                                      \
                       |\n     * | `'html'`            | `HtmlRenderer`       \
                                                          |\n     * | \
`'numeric'`         | `NumericRenderer`                                       \
                       |\n     * | `'password'`        | `PasswordRenderer`   \
                                                          |\n     * | \
`'text'`            | `TextRenderer`                                          \
                       |\n     * | `'time'`            | `TimeRenderer`       \
                                                          |\n     *\n     * \
To set the [`renderer`](#renderer), [`editor`](#editor), and \
[`validator`](#validator)\n     * options all at once, use the \
[`type`](#type) option.\n     *\n     * Read more:\n     * - [Cell \
renderer](@/guides/cell-functions/cell-renderer.md)\n     * - [Cell \
type](@/guides/cell-types/cell-type.md)\n     * - [Configuration options: \
Cascading \
configuration](@/guides/getting-started/configuration-options.md#cascading-co\
nfiguration)\n     * - [`type`](#type)\n     *\n     * @memberof Options#\n   \
  * @type {string|Function}\n     * @default undefined\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * // use the `numeric` \
renderer for each cell of the entire grid\n     * renderer: `'numeric'`,\n    \
 *\n     * // add a custom renderer function\n     * renderer(hotInstance, \
td, row, column, prop, value, cellProperties) {\n     *   // your custom \
renderer's logic\n     *   ...\n     * }\n     *\n     * // apply the \
`renderer` option to individual columns\n     * columns: [\n     *   {\n     \
*     // use the `autocomplete` renderer for each cell of this column\n     * \
    renderer: 'autocomplete'\n     *   },\n     *   {\n     *     // use the \
`myCustomRenderer` renderer for each cell of this column\n     *     \
renderer: 'myCustomRenderer'\n     *   }\n     * ]\n     * ```\n     */\n    \
renderer: void 0,\n    /**\n     * The `rowHeaders` option configures your \
grid's row headers.\n     *\n     * You can set the `rowHeaders` option to \
one of the following:\n     *\n     * | Setting    | Description              \
                                         |\n     * | ---------- | \
----------------------------------------------------------------- |\n     * | \
`true`     | Enable the default row headers ('1', '2', '3', ...)              \
 |\n     * | `false`    | Disable row headers                                 \
              |\n     * | An array   | Define your own row headers (e.g. \
`['One', 'Two', 'Three', ...]`) |\n     * | A function | Define your own row \
headers, using a function                     |\n     *\n     * Read more:\n  \
   * - [Row header](@/guides/rows/row-header.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean|string[]|Function}\n     * @default \
undefined\n     * @category Core\n     *\n     * @example\n     * ```js\n     \
* // enable the default row headers\n     * rowHeaders: true,\n     *\n     * \
// set your own row headers\n     * rowHeaders: ['One', 'Two', 'Three'],\n    \
 *\n     * // set your own row headers, using a function\n     * rowHeaders: \
function(visualRowIndex) {\n     *   return `${visualRowIndex}: AB`;\n     * \
},\n     * ```\n     */\n    rowHeaders: void 0,\n    /**\n     * \
@description\n     * The `rowHeaderWidth` option configures the width of row \
headers.\n     *\n     * You can set the `rowHeaderWidth` option to one of \
the following:\n     *\n     * | Setting  | Description                       \
              |\n     * | -------- | \
----------------------------------------------- |\n     * | A number | Set \
the same width for every row header         |\n     * | An array | Set \
different widths for individual row headers |\n     *\n     * @memberof \
Options#\n     * @type {number|number[]}\n     * @default undefined\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // set the same \
width for every row header\n     * rowHeaderWidth: 25,\n     *\n     * // set \
different widths for individual row headers\n     * rowHeaderWidth: [25, 30, \
55],\n     * ```\n     */\n    rowHeaderWidth: void 0,\n    /**\n     * The \
`rowHeights` option sets rows' heights, in pixels.\n     *\n     * In the \
rendering process, the default row height is 23 px (22 px + 1 px of the row's \
bottom border).\n     * You can change it to equal or greater than 23px, by \
setting the `rowHeights` option to one of the following:\n     *\n     * | \
Setting     | Description                                                     \
                                    | Example                                 \
                     |\n     * | ----------- | \
-----------------------------------------------------------------------------\
---------------------- | \
------------------------------------------------------------ |\n     * | A \
number    | Set the same height for every row                                 \
                                  | `rowHeights: 100`                         \
                   |\n     * | A string    | Set the same height for every \
row                                                                   | \
`rowHeights: '100px'`                                        |\n     * | An \
array    | Set heights separately for each row                                \
                                 | `rowHeights: [100, 120, undefined]`        \
                  |\n     * | A function  | Set row heights \
dynamically,<br>on each render                                                \
      | `rowHeights(visualRowIndex) { return visualRowIndex * 10; }` |\n     \
* | `undefined` | Used by the \
[modifyRowHeight](@/api/hooks.md#modifyRowHeight) hook,<br>to detect row \
height changes | `rowHeights: undefined`                                      \
|\n     *\n     * The `rowHeights` option also sets the minimum row height \
that can be set\n     * via the {@link ManualRowResize} and {@link \
AutoRowSize} plugins (if they are enabled).\n     *\n     * Read more:\n     \
* - [Row height](@/guides/rows/row-height.md)\n     *\n     * @memberof \
Options#\n     * @type \
{number|number[]|string|string[]|Array<undefined>|Function}\n     * @default \
undefined\n     * @category Core\n     *\n     * @example\n     * ```js\n     \
* // set every row's height to 100px\n     * rowHeights: 100,\n     *\n     * \
// set every row's height to 100px\n     * rowHeights: '100px',\n     *\n     \
* // set the first (by visual index) row's height to 100\n     * // set the \
second (by visual index) row's height to 120\n     * // set the third (by \
visual index) row's height to `undefined`\n     * // set any other row's \
height to the default 23px\n     * rowHeights: [100, 120, undefined],\n     \
*\n     * // set each row's height individually, using a function\n     * \
rowHeights(visualRowIndex) {\n     *   return visualRowIndex * 10;\n     * \
},\n     * ```\n     */\n    rowHeights: void 0,\n    /**\n     * \
@description\n     * The `search` option configures the \
[`Search`](@/api/search.md) plugin.\n     *\n     * You can set the `search` \
option to one of the following:\n     *\n     * | Setting           | \
Description                                                                   \
       |\n     * | ----------------- | \
-----------------------------------------------------------------------------\
------- |\n     * | `false` (default) | Disable the \
[`Search`](@/api/search.md) plugin                                       |\n  \
   * | `true`            | Enable the [`Search`](@/api/search.md) plugin with \
the default configuration         |\n     * | An object         | - Enable \
the [`Search`](@/api/search.md) plugin<br>- Apply your custom configuration \
|\n     *\n     * If you set the `search` option to an object, you can \
configure the following search options:\n     *\n     * | Option              \
| Possible settings | Description                                             \
                                             |\n     * | ------------------- \
| ----------------- | \
-----------------------------------------------------------------------------\
----------------------- |\n     * | `searchResultClass` | A string          | \
Add a custom CSS class name to search results                                 \
                       |\n     * | `queryMethod`       | A function        | \
Add a [custom query \
method](@/guides/accessories-and-menus/searching-values.md#custom-query-metho\
d)  |\n     * | `callback`          | A function        | Add a [custom \
callback \
function](@/guides/accessories-and-menus/searching-values.md#custom-callback) \
|\n     *\n     * Read more:\n     * - [Searching \
values](@/guides/accessories-and-menus/searching-values.md)\n     * - \
[Searching values: Custom query \
method](@/guides/accessories-and-menus/searching-values.md#custom-query-metho\
d)\n     * - [Searching values: Custom \
callback](@/guides/accessories-and-menus/searching-values.md#custom-callback)\
\n     *\n     * @memberof Options#\n     * @type {boolean|object}\n     * \
@default false\n     * @category Search\n     *\n     * @example\n     * \
```js\n     * // enable the `Search` plugin with the default configuration\n  \
   * search: true,\n     *\n     * // enable the `Search` plugin with a \
custom configuration\n     * search: {\n     *   // add a `customClass` CSS \
class name to search results\n     *   searchResultClass: 'customClass',\n    \
 *   // add a custom query method\n     *   queryMethod(queryStr, value) {\n  \
   *     ...\n     *   },\n     *   // add a custom callback function\n     * \
  callback(instance, row, column, value, result) {\n     *     ...\n     *   \
}\n     * }\n     * ```\n     */\n    search: false,\n    /**\n     * \
@description\n     * The `selectionMode` option configures how \
[selection](@/guides/cell-features/selection.md) works.\n     *\n     * You \
can set the `selectionMode` option to one of the following:\n     *\n     * | \
Setting      | Description                                                  \
|\n     * | ------------ | \
------------------------------------------------------------ |\n     * | \
`'single'`   | Allow the user to select only one cell at a time.            \
|\n     * | `'range'`    | Allow the user to select one range of cells at a \
time.       |\n     * | `'multiple'` | Allow the user to select multiple \
ranges of cells at a time. |\n     *\n     * Read more:\n     * - [Selection: \
Selecting ranges](@/guides/cell-features/selection.md#select-ranges)\n     \
*\n     * @memberof Options#\n     * @type {string}\n     * @default \
'multiple'\n     * @category Core\n     *\n     * @example\n     * ```js\n    \
 * // you can only select one cell at at a time\n     * selectionMode: \
'single',\n     *\n     * // you can select one range of cells at a time\n    \
 * selectionMode: 'range',\n     *\n     * // you can select multiple ranges \
of cells at a time\n     * selectionMode: 'multiple',\n     * ```\n     */\n  \
  selectionMode: \"multiple\",\n    /**\n     * The `selectOptions` option \
configures options that the end user can choose from in \
[`select`](@/guides/cell-types/select-cell-type.md) cells.\n     *\n     * \
You can set the `selectOptions` option to one of the following:\n     *\n     \
* | Setting                         | Description                             \
                                      |\n     * | \
------------------------------- | \
----------------------------------------------------------------------------- \
|\n     * | An array of strings             | Each string is one option's \
value and label                                   |\n     * | An object with \
key-string pairs | - Each key is one option's value<br>- The key's string is \
that option's label |\n     * | A function                      | A function \
that returns an object with key-string pairs                       |\n     \
*\n     * Read more:\n     * - [Select cell \
type](@/guides/cell-types/select-cell-type.md)\n     *\n     * @memberof \
Options#\n     * @type {string[]|object|Function}\n     * @default \
undefined\n     * @category Core\n     *\n     * @example\n     * ```js\n     \
* columns: [\n     *   {\n     *     // set the `type` of each cell in this \
column to `select`\n     *     type: 'select',\n     *     // set the first \
option's value and label to `A`\n     *     // set the second option's value \
and label to `B`\n     *     // set the third option's value and label to \
`C`\n     *     selectOptions: ['A', 'B', 'C'],\n     *   },\n     *   {\n    \
 *     // set the `type` of each cell in this column to `select`\n     *     \
type: 'select',\n     *     selectOptions: {\n     *       // set the first \
option's value to `value1` and label to `Label 1`\n     *       value1: \
'Label 1',\n     *       // set the second option's value to `value2` and \
label to `Label 2`\n     *       value2: 'Label 2',\n     *       // set the \
third option's value to `value3` and label to `Label 3`\n     *       value3: \
'Label 3',\n     *     },\n     *   },\n     *   {\n     *     // set the \
`type` of each cell in this column to `select`\n     *     type: 'select',\n  \
   *     // set `selectOption` to a function that returns available options \
as an object\n     *     selectOptions(visualRow, visualColumn, prop) {\n     \
*       return {\n     *         value1: 'Label 1',\n     *         value2: \
'Label 2',\n     *         value3: 'Label 3',\n     *       };\n     *   },\n \
    * ],\n     * ```\n     */\n    selectOptions: void 0,\n    /**\n     * \
@description\n     * The `skipColumnOnPaste` option determines whether you \
can paste data into a given column.\n     *\n     * You can only apply the \
`skipColumnOnPaste` option to an entire column, using the \
[`columns`](#columns) option.\n     *\n     * You can set the \
`skipColumnOnPaste` option to one of the following:\n     *\n     * | Setting \
          | Description                                                       \
                                    |\n     * | ----------------- | \
-----------------------------------------------------------------------------\
------------------------ |\n     * | `false` (default) | Enable pasting data \
into this column                                                              \
    |\n     * | `true`            | - Disable pasting data into this \
column<br>- On pasting, paste data into the next column to the right |\n     \
*\n     * Read more:\n     * - [Configuration options: Setting column \
options](@/guides/getting-started/configuration-options.md#set-column-options\
)\n     *\n     * @memberof Options#\n     * @type {boolean}\n     * @default \
false\n     * @category Core\n     *\n     * @example\n     * ```js\n     * \
columns: [\n     *   {\n     *     // disable pasting data into this column\n \
    *     skipColumnOnPaste: true\n     *   }\n     * ],\n     * ```\n     \
*/\n    skipColumnOnPaste: false,\n    /**\n     * @description\n     *\n     \
* The `skipRowOnPaste` option determines whether you can paste data into a \
given row.\n     *\n     * You can only apply the `skipRowOnPaste` option to \
an entire row, using the [`cells`](#cells) option.\n     *\n     * You can \
set the `skipRowOnPaste` option to one of the following:\n     *\n     * | \
Setting           | Description                                               \
                          |\n     * | ----------------- | \
-----------------------------------------------------------------------------\
------ |\n     * | `false` (default) | Enable pasting data into this row      \
                                             |\n     * | `true`            | \
- Disable pasting data into this row<br>- On pasting, paste data into the row \
below |\n     *\n     * Read more:\n     * - [Configuration options: Setting \
row \
options](@/guides/getting-started/configuration-options.md#set-row-options)\n \
    *\n     * @memberof Options#\n     * @type {boolean}\n     * @default \
false\n     * @category Core\n     *\n     * @example\n     * ```js\n     * \
cells(row, column) {\n     *  const cellProperties = {};\n     *\n     *  // \
disable pasting data into row 1\n     *  if (row === 1) {\n     *    \
cellProperties.skipRowOnPaste = true;\n     *  }\n     *\n     *  return \
cellProperties;\n     * }\n     * ```\n     */\n    skipRowOnPaste: false,\n  \
  /**\n     * The `sortByRelevance` option configures whether \
[`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells'\n     \
* lists are sorted in the same order as provided in the [`source`](#source) \
option.\n     *\n     * You can set the `sortByRelevance` option to one of \
the following:\n     *\n     * | Setting          | Description               \
                                                   |\n     * | \
---------------- | \
---------------------------------------------------------------------------- \
|\n     * | `true` (default) | Sort options in the same order as provided in \
the [`source`](#source) option |\n     * | `false`          | Sort options \
alphabetically                                                  |\n     *\n   \
  * Read more:\n     * - [`source`](#source)\n     * - [Autocomplete cell \
type](@/guides/cell-types/autocomplete-cell-type.md)\n     *\n     * \
@memberof Options#\n     * @type {boolean}\n     * @default true\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * columns: [{\n   \
  *   // set the `type` of each cell in this column to `autocomplete`\n     * \
  type: 'autocomplete',\n     *   // set options available in every \
`autocomplete` cell of this column\n     *   source: ['D', 'C', 'B', 'A'],\n  \
   *   // sort the `autocomplete` option in this order: D, C, B, A\n     *   \
sortByRelevance: true\n     * }],\n     * ```\n     */\n    sortByRelevance: \
true,\n    /**\n     * The `source` option sets options available in \
[`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)\n     * and \
[`dropdown`](@/guides/cell-types/dropdown-cell-type.md) cells.\n     *\n     \
* You can set the `source` option to one of the following:\n     *\n     * - \
An array\n     * - A function\n     *\n     * Read more:\n     * - \
[Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)\n     \
* - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type.md)\n     * - \
[`strict`](#strict)\n     * - [`allowHtml`](#allowHtml)\n     * - \
[`filter`](#filter)\n     * - [`sortByRelevance`](#sortByRelevance)\n     *\n \
    * @memberof Options#\n     * @type {Array|Function}\n     * @default \
undefined\n     * @category Core\n     *\n     * @example\n     * ```js\n     \
* // set `source` to an array\n     * columns: [{\n     *   // set the `type` \
of each cell in this column to `autocomplete`\n     *   type: \
'autocomplete',\n     *   // set options available in every `autocomplete` \
cell of this column\n     *   source: ['A', 'B', 'C', 'D']\n     * }],\n     \
*\n     * // set `source` to a function\n     * columns: [{\n     *   // set \
the `type` of each cell in this column to `autocomplete`\n     *   type: \
'autocomplete',\n     *   // for every `autocomplete` cell in this column, \
fetch data from an external source\n     *   source(query, callback) {\n     \
*     fetch('https://example.com/query?q=' + query, function(response) {\n    \
 *       callback(response.items);\n     *     })\n     *   }\n     * }],\n   \
  * ```\n     */\n    source: void 0,\n    /**\n     * @description\n     * \
If the [`data`](#data) option is not set, the `startCols` option sets the \
initial number of empty columns.\n     *\n     * The `startCols` option works \
only in Handsontable's constructor.\n     *\n     * @memberof Options#\n     \
* @type {number}\n     * @default 5\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * // start with 15 empty columns\n     * \
startCols: 15,\n     * ```\n     */\n    startCols: 5,\n    /**\n     * \
@description\n     * If the [`data`](#data) option is not set, the \
`startRows` option sets the initial number of empty rows.\n     *\n     * The \
`startRows` option works only in Handsontable's constructor.\n     *\n     * \
@memberof Options#\n     * @type {number}\n     * @default 5\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // start with \
15 empty rows\n     * startRows: 15,\n     * ```\n     */\n    startRows: \
5,\n    /**\n     * @description\n     * The `stretchH` option determines \
what happens when the declared grid width\n     * is different from the \
calculated sum of all column widths.\n     *\n     * You can set the \
`stretchH` option to one of the following:\n     *\n     * | Setting          \
  | Description                                                       |\n     \
* | ------------------ | \
----------------------------------------------------------------- |\n     * | \
`'none'` (default) | Don't fit the grid to the container (disable column \
stretching)   |\n     * | `'last'`           | Fit the grid to the container, \
by stretching only the last column |\n     * | `'all'`            | Fit the \
grid to the container, by stretching all columns evenly   |\n     *\n     * \
Read more:\n     * - [Column width: Column \
stretching](@/guides/columns/column-width.md#column-stretching)\n     *\n     \
* @memberof Options#\n     * @type {string}\n     * @default 'none'\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // fit the grid \
to the container\n     * // by stretching all columns evenly\n     * \
stretchH: 'all',\n     * ```\n     */\n    stretchH: \"none\",\n    /**\n     \
* The `strict` option configures the behavior of \
[`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells.\n     \
*\n     * You can set the `strict` option to one of the following:\n     *\n  \
   * | Setting | Mode                                                         \
                                 | Description                                \
                                                |\n     * | ------- | \
-----------------------------------------------------------------------------\
---------------- | \
-----------------------------------------------------------------------------\
------------- |\n     * | `true`  | [Strict \
mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-strict-mode) \
        | The end user:<br>- Can only choose one of suggested values<br>- \
Can't enter a custom value |\n     * | `false` | [Flexible \
mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-flexible-mod\
e)     | The end user:<br>- Can choose one of suggested values<br>- Can enter \
a custom value        |\n     *\n     * Read more:\n     * - [Autocomplete \
cell type](@/guides/cell-types/autocomplete-cell-type.md)\n     * - \
[`source`](#source)\n     *\n     * @memberof Options#\n     * @type \
{boolean}\n     * @default undefined\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * columns: [\n     *   {\n     *   // set the \
`type` of each cell in this column to `autocomplete`\n     *   type: \
'autocomplete',\n     *   // set options available in every `autocomplete` \
cell of this column\n     *   source: ['A', 'B', 'C'],\n     *   // values \
entered must match `A`, `B`, or `C`\n     *   strict: true\n     *   },\n     \
* ],\n     * ```\n     */\n    strict: void 0,\n    /**\n     * The \
`tableClassName` option lets you add CSS class names\n     * to every \
Handsontable instance inside the `container` element.\n     *\n     * You can \
set the `tableClassName` option to one of the following:\n     *\n     * | \
Setting             | Description                                             \
                                   |\n     * | ------------------- | \
-----------------------------------------------------------------------------\
------------- |\n     * | A string            | Add a single CSS class name \
to every Handsontable instance inside the `container` element  |\n     * | An \
array of strings | Add multiple CSS class names to every Handsontable \
instance inside the `container` element |\n     *\n     * Read more:\n     * \
- [`currentRowClassName`](#currentRowClassName)\n     * - \
[`currentColClassName`](#currentColClassName)\n     * - \
[`currentHeaderClassName`](#currentHeaderClassName)\n     * - \
[`activeHeaderClassName`](#activeHeaderClassName)\n     * - \
[`invalidCellClassName`](#invalidCellClassName)\n     * - \
[`placeholderCellClassName`](#placeholderCellClassName)\n     * - \
[`readOnlyCellClassName`](#readOnlyCellClassName)\n     * - \
[`noWordWrapClassName`](#noWordWrapClassName)\n     * - \
[`commentedCellClassName`](#commentedCellClassName)\n     * - \
[`className`](#className)\n     *\n     * @memberof Options#\n     * @type \
{string|string[]}\n     * @default undefined\n     * @category Core\n     *\n \
    * @example\n     * ```js\n     * // add a `your-class-name` CSS class \
name\n     * // to every Handsontable instance inside the `container` \
element\n     * tableClassName: 'your-class-name',\n     *\n     * // add \
`first-class-name` and `second-class-name` CSS class names\n     * // to \
every Handsontable instance inside the `container` element\n     * \
tableClassName: ['first-class-name', 'second-class-name'],\n     * ```\n     \
*/\n    tableClassName: void 0,\n    /**\n     * The `tabMoves` option \
configures the action of the <kbd>**Tab**</kbd> key.\n     *\n     * You can \
set the `tabMoves` option to an object with the following properties\n     * \
(or to a function that returns such an object):\n     *\n     * | Property | \
Type   | Description                                                          \
                                                                              \
      |\n     * | -------- | ------ | \
-----------------------------------------------------------------------------\
--------------------------------------------------------------------------- \
|\n     * | `row`    | Number | - On pressing <kbd>**Tab**</kbd>, move \
selection `row` rows down<br>- On pressing <kbd>**Shift**</kbd> + \
<kbd>**Tab**</kbd>, move selection `row` rows up              |\n     * | \
`col`    | Number | - On pressing <kbd>**Tab**</kbd>, move selection `col` \
columns right<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Tab**</kbd>, \
move selection `col` columns left     |\n     *\n     * @memberof Options#\n  \
   * @type {object|Function}\n     * @default {row: 0, col: 1}\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // on pressing \
Tab, move selection 2 rows down and 2 columns right\n     * // on pressing \
Shift+Tab, move selection 2 rows up and 2 columns left\n     * tabMoves: \
{row: 2, col: 2},\n     *\n     * // the same setting, as a function\n     * \
// `event` is a DOM Event object received on pressing Tab\n     * // you can \
use it to check whether the user pressed Tab or Shift+Tab\n     * \
tabMoves(event) {\n     *   return {row: 2, col: 2};\n     * },\n     * ```\n \
    */\n    tabMoves: {\n      row: 0,\n      col: 1\n    },\n    /**\n     * \
@description\n     * The `title` option configures [column \
header](@/guides/columns/column-header.md) names.\n     *\n     * You can set \
the `title` option to a string.\n     *\n     * Read more:\n     * - [Column \
header](@/guides/columns/column-header.md)\n     * - [`columns`](#columns)\n  \
   *\n     * @memberof Options#\n     * @type {string}\n     * @default \
undefined\n     * @category Core\n     *\n     * @example\n     * ```js\n     \
* columns: [\n     *   {\n     *     // set the first column header name to \
`First name`\n     *     title: 'First name',\n     *     type: 'text',\n     \
*   },\n     *   {\n     *     // set the second column header name to `Last \
name`\n     *     title: 'Last name',\n     *     type: 'text',\n     *   }\n \
    * ],\n     * ```\n     */\n    title: void 0,\n    /**\n     * The \
`trimDropdown` option configures the width of the \
[`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)\n     * and \
[`dropdown`](@/guides/cell-types/dropdown-cell-type.md) lists.\n     *\n     \
* You can set the `trimDropdown` option to one of the following:\n     *\n    \
 * | Setting          | Description                                           \
                          |\n     * | ---------------- | \
-----------------------------------------------------------------------------\
-- |\n     * | `true` (default) | Make the dropdown/autocomplete list's width \
the same as the edited cell's width |\n     * | `false`          | Scale the \
dropdown/autocomplete list's width to the list's content              |\n     \
*\n     * Read more:\n     * - [Autocomplete cell \
type](@/guides/cell-types/autocomplete-cell-type.md)\n     * - [Dropdown cell \
type](@/guides/cell-types/dropdown-cell-type.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean}\n     * @default true\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * columns: [\n     *   {\n  \
   *     type: 'autocomplete',\n     *     // for each cell of this column\n  \
   *     // make the `autocomplete` list's width the same as the edited \
cell's width\n     *     trimDropdown: true,\n     *   },\n     *   {\n     * \
    type: 'dropdown',\n     *     // for each cell of this column\n     *     \
// scale the `dropdown` list's width to the list's content\n     *     \
trimDropdown: false,\n     *   }\n     * ],\n     * ```\n     */\n    \
trimDropdown: true,\n    /**\n     * @description\n     * The `trimRows` \
option configures the [`TrimRows`](@/api/trimRows.md) plugin.\n     *\n     * \
You can set the `trimRows` option to one of the following:\n     *\n     * | \
Setting                          | Description                                \
                                                   |\n     * | \
-------------------------------- | \
-----------------------------------------------------------------------------\
---------------- |\n     * | `false`                          | Disable the \
[`TrimRows`](@/api/trimRows.md) plugin                                        \
    |\n     * | `true`                           | Enable the \
[`TrimRows`](@/api/trimRows.md) plugin                                        \
     |\n     * | An array of physical row indexes | - Enable the \
[`TrimRows`](@/api/trimRows.md) plugin<br>- Trim selected rows at \
initialization |\n     *\n     * Read more:\n     * - [Plugins: \
`TrimRows`](@/api/trimRows.md)\n     * - [Row \
trimming](@/guides/rows/row-trimming.md)\n     *\n     * @memberof Options#\n \
    * @type {boolean|number[]}\n     * @default undefined\n     * @category \
TrimRows\n     *\n     * @example\n     * ```js\n     * // enable the \
`TrimRows` plugin\n     * trimRows: true,\n     *\n     * // enable the \
`TrimRows` plugin\n     * // at Handsontable's initialization, trim rows 5, \
10, and 15\n     * trimRows: [5, 10, 15],\n     * ```\n     */\n    trimRows: \
void 0,\n    /**\n     * The `trimWhitespace` option configures automatic \
whitespace removal. This option\n     * affects the cell renderer and the \
cell editor.\n     *\n     * You can set the `trimWhitespace` option to one \
of the following:\n     *\n     * | Setting          | Description            \
                                         |\n     * | ---------------- | \
--------------------------------------------------------------- |\n     * | \
`true` (default) | Remove whitespace at the beginning and at the end of each \
cell |\n     * | `false`          | Don't remove whitespace                   \
                      |\n     *\n     * @memberof Options#\n     * @type \
{boolean}\n     * @default true\n     * @category Core\n     *\n     * \
@example\n     * ```js\n     * columns: [\n     *   {\n     *     // don't \
remove whitespace\n     *     // from any cell of this column\n     *     \
trimWhitespace: false\n     *   }\n     * ]\n     * ```\n     */\n    \
trimWhitespace: true,\n    /**\n     * @description\n     * The `type` option \
lets you set the [`renderer`](#renderer), [`editor`](#editor), and \
[`validator`](#validator)\n     * options all at once, by selecting a [cell \
type](@/guides/cell-types/cell-type.md).\n     *\n     * You can set the \
`type` option to one of the following:\n     *\n     * | Cell type            \
                                             | Renderer, editor & validator   \
                                                                              \
                                                                              \
                                                        |\n     * | \
----------------------------------------------------------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
----------- |\n     * | A [custom cell \
type](@/guides/cell-types/cell-type.md)            | Renderer: your [custom \
cell renderer](@/guides/cell-functions/cell-renderer.md)<br>Editor: your \
[custom cell editor](@/guides/cell-functions/cell-editor.md)<br>Validator: \
your [custom cell validator](@/guides/cell-functions/cell-validator.md) |\n   \
  * | [`'autocomplete'`](@/guides/cell-types/autocomplete-cell-type.md) | \
Renderer: `AutocompleteRenderer`<br>Editor: \
`AutocompleteEditor`<br>Validator: `AutocompleteValidator`                    \
                                                     |\n     * | \
[`'checkbox'`](@/guides/cell-types/checkbox-cell-type.md)         | Renderer: \
`CheckboxRenderer`<br>Editor: `CheckboxEditor`<br>Validator: -                \
                                                                              \
                                 |\n     * | \
[`'date'`](@/guides/cell-types/date-cell-type.md)                 | Renderer: \
`DateRenderer`<br>Editor: `DateEditor`<br>Validator: `DateValidator`          \
                                                                              \
         |\n     * | \
[`'dropdown'`](@/guides/cell-types/dropdown-cell-type.md)         | Renderer: \
`DropdownRenderer`<br>Editor: `DropdownEditor`<br>Validator: \
`DropdownValidator`                                                           \
                          |\n     * | \
[`'handsontable'`](@/guides/cell-types/handsontable-cell-type.md) | Renderer: \
`AutocompleteRenderer`<br>Editor: `HandsontableEditor`<br>Validator: -        \
                                                                              \
                                 |\n     * | \
[`'numeric'`](@/guides/cell-types/numeric-cell-type.md)           | Renderer: \
`NumericRenderer`<br>Editor: `NumericEditor`<br>Validator: `NumericValidator` \
                                                                              \
         |\n     * | \
[`'password'`](@/guides/cell-types/password-cell-type.md)         | Renderer: \
`PasswordRenderer`<br>Editor: `PasswordEditor`<br>Validator: -                \
                                                                              \
                                 |\n     * | `'text'`                         \
                                 | Renderer: `TextRenderer`<br>Editor: \
`TextEditor`<br>Validator: -                                                  \
                                                                              \
       |\n     * | [`'time`'](@/guides/cell-types/time-cell-type.md)          \
       | Renderer: `TimeRenderer`<br>Editor: `TimeEditor`<br>Validator: \
`TimeValidator`                                                               \
                                  |\n     *\n     * Read more:\n     * - \
[Cell type](@/guides/cell-types/cell-type.md)\n     * - [Cell \
renderer](@/guides/cell-functions/cell-renderer.md)\n     * - [Cell \
editor](@/guides/cell-functions/cell-editor.md)\n     * - [Cell \
validator](@/guides/cell-functions/cell-validator.md)\n     * - \
[Configuration options: Cascading \
configuration](@/guides/getting-started/configuration-options.md#cascading-co\
nfiguration)\n     * - [`renderer`](#renderer)\n     * - \
[`editor`](#editor)\n     * - [`validator`](#validator)\n     *\n     * \
@memberof Options#\n     * @type {string}\n     * @default 'text'\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // set the \
`numeric` cell type for each cell of the entire grid\n     * type: \
`'numeric'`,\n     *\n     * // apply the `type` option to individual \
columns\n     * columns: [\n     *   {\n     *     // set the `autocomplete` \
cell type for each cell of this column\n     *     type: 'autocomplete'\n     \
*   },\n     *   {\n     *     // set the `myCustomCellType` cell type for \
each cell of this column\n     *     type: 'myCustomCellType'\n     *   }\n   \
  * ]\n     * ```\n     */\n    type: \"text\",\n    /**\n     * The \
`uncheckedTemplate` option lets you configure what value\n     * an unchecked \
[`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell has.\n     *\n   \
  * You can set the `uncheckedTemplate` option to one of the following:\n     \
*\n     * | Setting           | Description                                   \
                                                                              \
                                                               |\n     * | \
----------------- | \
-----------------------------------------------------------------------------\
-----------------------------------------------------------------------------\
-------------------------------- |\n     * | `false` (default) | If a \
[`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is \
unchecked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for \
this cell returns `false`                 |\n     * | A string          | If \
a [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is \
unchecked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for \
this cell returns a string of your choice |\n     *\n     * Read more:\n     \
* - [Checkbox cell type: Checkbox \
template](@/guides/cell-types/checkbox-cell-type.md#checkbox-template)\n     \
* - [`getDataAtCell()`](@/api/core.md#getDataAtCell)\n     * - \
[`checkedTemplate`](#checkedTemplate)\n     *\n     * @memberof Options#\n    \
 * @type {boolean|string|number}\n     * @default false\n     * @category \
Core\n     *\n     * @example\n     * ```js\n     * columns: [\n     *   {\n  \
   *     // set the `type` of each cell in this column to `checkbox`\n     *  \
   // when unchecked, the cell's value is `false`\n     *     // when \
checked, the cell's value is `true`\n     *     type: 'checkbox',\n     *   \
},\n     *   {\n     *     // set the `type` of each cell in this column to \
`checkbox`\n     *     // when unchecked, the cell's value is `'No'`\n     *  \
   // when checked, the cell's value is `'Yes'`\n     *     type: \
'checkbox',\n     *     uncheckedTemplate: 'No'\n     *     checkedTemplate: \
'Yes',\n     *  }\n     * ],\n     * ```\n     */\n    uncheckedTemplate: \
void 0,\n    /**\n     * The `undo` option configures the \
[`UndoRedo`](@/api/undoRedo.md) plugin.\n     *\n     * You can set the \
`undo` option to one of the following:\n     *\n     * | Setting | \
Description                                        |\n     * | ------- | \
-------------------------------------------------- |\n     * | `true`  | \
Enable the [`UndoRedo`](@/api/undoRedo.md) plugin  |\n     * | `false` | \
Disable the [`UndoRedo`](@/api/undoRedo.md) plugin |\n     *\n     * By \
default, the `undo` option is set to `undefined`,\n     * but the \
[`UndoRedo`](@/api/undoRedo.md) plugin acts as enabled.\n     * To disable \
the [`UndoRedo`](@/api/undoRedo.md) plugin completely,\n     * set the `undo` \
option to `false`.\n     *\n     * Read more:\n     * - [Undo and \
redo](@/guides/accessories-and-menus/undo-redo.md)\n     *\n     * @memberof \
Options#\n     * @type {boolean}\n     * @default undefined\n     * @category \
UndoRedo\n     *\n     * @example\n     * ```js\n     * // enable the \
`UndoRedo` plugin\n     * undo: true,\n     * ```\n     */\n    undo: void \
0,\n    /**\n     * @description\n     * The `validator` option sets a [cell \
validator](@/guides/cell-functions/cell-validator.md) for a cell.\n     *\n   \
  * You can set the `validator` option to one of the following:\n     *\n     \
* | Setting              | Description                                        \
                              |\n     * | -------------------- | \
-----------------------------------------------------------------------------\
--- |\n     * | A string             | A [cell validator \
alias](@/guides/cell-functions/cell-validator.md)              |\n     * | A \
function           | Your [custom cell validator \
function](@/guides/cell-functions/cell-validator.md) |\n     * | A regular \
expression | A regular expression used for cell validation                    \
                |\n     *\n     * By setting the `validator` option to a \
string,\n     * you can use one of the following [cell validator \
aliases](@/guides/cell-functions/cell-validator.md):\n     *\n     * | Alias  \
             | Cell validator function                                        \
         |\n     * | ------------------- | \
----------------------------------------------------------------------- |\n   \
  * | A custom alias      | Your [custom cell \
validator](@/guides/cell-functions/cell-validator.md) |\n     * | \
`'autocomplete'`    | `AutocompleteValidator`                                 \
                |\n     * | `'date'`            | `DateValidator`             \
                                            |\n     * | `'dropdown'`        | \
`DropdownValidator`                                                     |\n   \
  * | `'numeric'`         | `NumericValidator`                                \
                      |\n     * | `'time'`            | `TimeValidator`       \
                                                  |\n     *\n     * To set \
the [`editor`](#editor), [`renderer`](#renderer), and \
[`validator`](#validator)\n     * options all at once, use the \
[`type`](#type) option.\n     *\n     * Read more:\n     * - [Cell \
validator](@/guides/cell-functions/cell-validator.md)\n     * - [Cell \
type](@/guides/cell-types/cell-type.md)\n     * - [Configuration options: \
Cascading \
configuration](@/guides/getting-started/configuration-options.md#cascading-co\
nfiguration)\n     * - [`type`](#type)\n     *\n     * @memberof Options#\n   \
  * @type {Function|RegExp|string}\n     * @default undefined\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * columns: [\n    \
 *    {\n     *      // use a built-in `numeric` cell validator\n     *      \
validator: 'numeric'\n     *    },\n     *    {\n     *      // validate \
against a regular expression\n     *      validator: /^[0-9]$/\n     *    \
},\n     *    {\n     *      // add a custom cell validator function\n     *  \
    validator(value, callback) {\n     *          ...\n     *      }\n     *  \
  },\n     * ],\n     * ```\n     */\n    validator: void 0,\n    /**\n     * \
@description\n     * The `viewportColumnRenderingOffset` option configures \
the number of columns\n     * to be rendered outside of the grid's \
viewport.\n     *\n     * You can set the `viewportColumnRenderingOffset` \
option to one of the following:\n     *\n     * | Setting            | \
Description                                             |\n     * | \
------------------ | ------------------------------------------------------- \
|\n     * | `auto` (default)   | Use the offset calculated automatically by \
Handsontable |\n     * | A number           | Set the offset manually         \
                        |\n     *\n     * Read more:\n     * - [Performance: \
Define the number of pre-rendered rows and \
columns](@/guides/optimization/performance.md#define-the-number-of-pre-render\
ed-rows-and-columns)\n     *\n     * @memberof Options#\n     * @type \
{number|string}\n     * @default 'auto'\n     * @category Core\n     *\n     \
* @example\n     * ```js\n     * // render 70 columns outside of the grid's \
viewport\n     * viewportColumnRenderingOffset: 70,\n     * ```\n     */\n    \
viewportColumnRenderingOffset: \"auto\",\n    /**\n     * @description\n     \
* The `viewportRowRenderingOffset` option configures the number of rows\n     \
* to be rendered outside of the grid's viewport.\n     *\n     * You can set \
the `viewportRowRenderingOffset` option to one of the following:\n     *\n    \
 * | Setting            | Description                                         \
    |\n     * | ------------------ | \
------------------------------------------------------- |\n     * | `auto` \
(default)   | Use the offset calculated automatically by Handsontable |\n     \
* | A number           | Set the offset manually                              \
   |\n     *\n     * Read more:\n     * - [Performance: Define the number of \
pre-rendered rows and \
columns](@/guides/optimization/performance.md#define-the-number-of-pre-render\
ed-rows-and-columns)\n     * - [Column \
virtualization](@/guides/columns/column-virtualization.md)\n     *\n     * \
@memberof Options#\n     * @type {number|string}\n     * @default 'auto'\n    \
 * @category Core\n     *\n     * @example\n     * ```js\n     * // render 70 \
rows outside of the grid's viewport\n     * viewportRowRenderingOffset: 70,\n \
    * ```\n     */\n    viewportRowRenderingOffset: \"auto\",\n    /**\n     \
* The `visibleRows` option sets the height of the \
[`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)\n     * and \
[`dropdown`](@/guides/cell-types/dropdown-cell-type.md) lists.\n     *\n     \
* When the number of list options exceeds the `visibleRows` number, a \
scrollbar appears.\n     *\n     * Read more:\n     * - [Autocomplete cell \
type](@/guides/cell-types/autocomplete-cell-type.md)\n     * - [Dropdown cell \
type](@/guides/cell-types/dropdown-cell-type.md)\n     *\n     * @memberof \
Options#\n     * @type {number}\n     * @default 10\n     * @category Core\n  \
   *\n     * @example\n     * ```js\n     * columns: [\n     *   {\n     *    \
 type: 'autocomplete',\n     *     // set the `autocomplete` list's height to \
15 options\n     *     // for each cell of this column\n     *     \
visibleRows: 15,\n     *   },\n     *   {\n     *     type: 'dropdown',\n     \
*     // set the `dropdown` list's height to 5 options\n     *     // for \
each cell of this column\n     *     visibleRows: 5,\n     *   }\n     * ],\n \
    * ```\n     */\n    visibleRows: 10,\n    /**\n     * The `width` option \
configures the width of your grid.\n     *\n     * You can set the `width` \
option to one of the following:\n     *\n     * | Setting                     \
                                               | Example                   \
|\n     * | \
-------------------------------------------------------------------------- | \
------------------------- |\n     * | A number of pixels                      \
                                   | `width: 500`              |\n     * | A \
string with a [CSS unit](https://www.w3schools.com/cssref/css_units.asp) | \
`width: '75vw'`           |\n     * | A function that returns a valid number \
or string                           | `width() { return 500; }` |\n     *\n   \
  * Read more:\n     * - [Grid size](@/guides/getting-started/grid-size.md)\n \
    *\n     * @memberof Options#\n     * @type {number|string|Function}\n     \
* @default undefined\n     * @category Core\n     *\n     * @example\n     * \
```js\n     * // set the grid's width to 500px\n     * width: 500,\n     *\n  \
   * // set the grid's width to 75vw\n     * width: '75vw',\n     *\n     * \
// set the grid's width to 500px, using a function\n     * width() {\n     *  \
 return 500;\n     * },\n     * ```\n     */\n    width: void 0,\n    /**\n   \
  * The `wordWrap` option configures whether content that exceeds a column's \
width is wrapped or not.\n     *\n     * You can set the `wordWrap` option to \
one of the following:\n     *\n     * | Setting          | Description        \
                                     |\n     * | ---------------- | \
------------------------------------------------------- |\n     * | `true` \
(default) | If content exceeds the column's width, wrap the content |\n     * \
| `false`          | Don't wrap content                                      \
|\n     *\n     * To style cells that don't wrap content, use the \
[`noWordWrapClassName`](#noWordWrapClassName) option.\n     *\n     * Read \
more:\n     * - [`noWordWrapClassName`](#noWordWrapClassName)\n     *\n     * \
@memberof Options#\n     * @type {boolean}\n     * @default true\n     * \
@category Core\n     *\n     * @example\n     * ```js\n     * // set column \
width for every column of the entire grid\n     * colWidths: 100,\n     *\n   \
  * columns: [\n     *   {\n     *     // don't wrap content in this column\n \
    *     wordWrap: false,\n     *   },\n     *   {\n     *     // if content \
exceeds this column's width, wrap the content\n     *     wordWrap: true,\n   \
  *   }\n     * ],\n     * ```\n     */\n    wordWrap: true\n    /* \
eslint-enable jsdoc/require-description-complete-sentence */\n  };\n};\n\n// \
node_modules/handsontable/dataMap/metaManager/metaLayers/globalMeta.mjs\nfunc\
tion createTableMetaEmptyClass() {\n  return class TableMeta {\n  };\n}\nvar \
GlobalMeta = class {\n  constructor(hot2) {\n    this.metaCtor = \
createTableMetaEmptyClass();\n    this.meta = this.metaCtor.prototype;\n    \
extend(this.meta, metaSchema_default());\n    this.meta.instance = hot2;\n  \
}\n  /**\n   * Gets constructor of the global meta object. Necessary for \
inheritance for creating the next meta layers.\n   *\n   * @returns \
{Function}\n   */\n  getMetaConstructor() {\n    return this.metaCtor;\n  }\n \
 /**\n   * Gets settings object for this layer.\n   *\n   * @returns \
{object}\n   */\n  getMeta() {\n    return this.meta;\n  }\n  /**\n   * \
Updates global settings object by merging settings with the current state.\n  \
 *\n   * @param {object} settings An object to merge with.\n   */\n  \
updateMeta(settings) {\n    var _settings$type;\n    extend(this.meta, \
settings);\n    extendByMetaType(this.meta, {\n      ...settings,\n      \
type: (_settings$type = settings.type) !== null && _settings$type !== void 0 \
? _settings$type : this.meta.type\n    }, settings);\n  }\n};\n\n// \
node_modules/handsontable/dataMap/metaManager/metaLayers/tableMeta.mjs\nvar \
TableMeta = class {\n  constructor(globalMeta) {\n    const MetaCtor = \
globalMeta.getMetaConstructor();\n    this.meta = new MetaCtor();\n  }\n  \
/**\n   * Gets settings object for this layer.\n   *\n   * @returns \
{TableMeta}\n   */\n  getMeta() {\n    return this.meta;\n  }\n  /**\n   * \
Updates table settings object by merging settings with the current state.\n   \
*\n   * @param {object} settings An object to merge with.\n   */\n  \
updateMeta(settings) {\n    extend(this.meta, settings);\n    \
extendByMetaType(this.meta, settings, settings);\n  }\n};\n\n// \
node_modules/handsontable/dataMap/metaManager/lazyFactoryMap.mjs\nvar \
LazyFactoryMap = class {\n  constructor(valueFactory) {\n    \
this.valueFactory = valueFactory;\n    this.data = [];\n    this.index = \
[];\n    this.holes = /* @__PURE__ */ new Set();\n  }\n  /**\n   * Gets or if \
data not exist creates and returns new data.\n   *\n   * @param {number} key \
The item key as zero-based index.\n   * @returns {*}\n   */\n  obtain(key) \
{\n    assert(() => isUnsignedNumber(key), \"Expecting an unsigned \
number.\");\n    const dataIndex = this._getStorageIndexByKey(key);\n    let \
result;\n    if (dataIndex >= 0) {\n      result = this.data[dataIndex];\n    \
  if (result === void 0) {\n        result = this.valueFactory(key);\n        \
this.data[dataIndex] = result;\n      }\n    } else {\n      result = \
this.valueFactory(key);\n      if (this.holes.size > 0) {\n        const \
reuseIndex = this.holes.values().next().value;\n        \
this.holes.delete(reuseIndex);\n        this.data[reuseIndex] = result;\n     \
   this.index[key] = reuseIndex;\n      } else {\n        \
this.data.push(result);\n        this.index[key] = this.data.length - 1;\n    \
  }\n    }\n    return result;\n  }\n  /**\n   * Inserts an empty data to the \
map. This method creates an empty space for obtaining\n   * new data.\n   *\n \
  * @param {number} key The key as volatile zero-based index at which to \
begin inserting space for new data.\n   * @param {number} [amount=1] Ammount \
of data to insert.\n   */\n  insert(key) {\n    let amount = arguments.length \
> 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    assert(() => \
isUnsignedNumber(key) || isNullish(key), \"Expecting an unsigned number or \
null/undefined argument.\");\n    const newIndexes = [];\n    const \
dataLength = this.data.length;\n    for (let i = 0; i < amount; i++) {\n      \
newIndexes.push(dataLength + i);\n      this.data.push(void 0);\n    }\n    \
const insertionIndex = isNullish(key) ? this.index.length : key;\n    \
this.index = [...this.index.slice(0, insertionIndex), ...newIndexes, \
...this.index.slice(insertionIndex)];\n  }\n  /**\n   * Removes (soft remove) \
data from \"index\" and according to the amount of data.\n   *\n   * @param \
{number} key The key as volatile zero-based index at which to begin removing \
the data.\n   * @param {number} [amount=1] Ammount data to remove.\n   */\n  \
remove(key) {\n    let amount = arguments.length > 1 && arguments[1] !== void \
0 ? arguments[1] : 1;\n    assert(() => isUnsignedNumber(key) || \
isNullish(key), \"Expecting an unsigned number or null/undefined \
argument.\");\n    const removed = this.index.splice(isNullish(key) ? \
this.index.length - amount : key, amount);\n    for (let i = 0; i < \
removed.length; i++) {\n      const removedIndex = removed[i];\n      if \
(typeof removedIndex === \"number\") {\n        \
this.holes.add(removedIndex);\n      }\n    }\n  }\n  /**\n   * Returns the \
size of the data which this map holds.\n   *\n   * @returns {number}\n   */\n \
 size() {\n    return this.data.length - this.holes.size;\n  }\n  /**\n   * \
Returns a new Iterator object that contains the values for each item in the \
LazyMap object.\n   *\n   * @returns {Iterator}\n   */\n  values() {\n    \
return arrayFilter(this.data, (_, index2) => \
!this.holes.has(index2))[Symbol.iterator]();\n  }\n  /**\n   * Returns a new \
Iterator object that contains an array of `[index, value]` for each item in \
the LazyMap object.\n   *\n   * @returns {Iterator}\n   */\n  entries() {\n   \
 const validEntries = [];\n    for (let i = 0; i < this.data.length; i++) {\n \
     const keyIndex = this._getKeyByStorageIndex(i);\n      if (keyIndex !== \
-1) {\n        validEntries.push([keyIndex, this.data[i]]);\n      }\n    }\n \
   let dataIndex = 0;\n    return {\n      next: () => {\n        if \
(dataIndex < validEntries.length) {\n          const value = \
validEntries[dataIndex];\n          dataIndex += 1;\n          return {\n     \
       value,\n            done: false\n          };\n        }\n        \
return {\n          done: true\n        };\n      }\n    };\n  }\n  /**\n   * \
Clears the map.\n   */\n  clear() {\n    this.data = [];\n    this.index = \
[];\n    this.holes.clear();\n  }\n  /**\n   * Gets storage index calculated \
from the key associated with the specified value.\n   *\n   * @param {number} \
key Volatile zero-based index.\n   * @returns {number} Returns index 0-N or \
-1 if no storage index found.\n   */\n  _getStorageIndexByKey(key) {\n    \
return this.index.length > key ? this.index[key] : -1;\n  }\n  /**\n   * Gets \
the key associated with the specified value calculated from storage index.\n  \
 *\n   * @param {number} dataIndex Zero-based storage index.\n   * @returns \
{number} Returns index 0-N or -1 if no key found.\n   */\n  \
_getKeyByStorageIndex(dataIndex) {\n    return \
this.index.indexOf(dataIndex);\n  }\n  /**\n   * Makes this object \
iterable.\n   *\n   * @returns {Iterator}\n   */\n  [Symbol.iterator]() {\n   \
 return this.entries();\n  }\n};\n\n// \
node_modules/handsontable/dataMap/metaManager/metaLayers/columnMeta.mjs\nvar \
COLUMNS_PROPS_CONFLICTS = [\"data\", \"width\"];\nvar ColumnMeta = class {\n  \
constructor(globalMeta) {\n    this.globalMeta = globalMeta;\n    this.metas \
= new LazyFactoryMap(() => this._createMeta());\n  }\n  /**\n   * Updates \
column meta object by merging settings with the current state.\n   *\n   * \
@param {number} physicalColumn The physical column index which points what \
column meta object is updated.\n   * @param {object} settings An object to \
merge with.\n   */\n  updateMeta(physicalColumn, settings) {\n    const meta \
= this.getMeta(physicalColumn);\n    extend(meta, settings);\n    \
extendByMetaType(meta, settings);\n  }\n  /**\n   * Creates one or more \
columns at specific position.\n   *\n   * @param {number} physicalColumn The \
physical column index which points from what position the column is added.\n  \
 * @param {number} amount An amount of columns to add.\n   */\n  \
createColumn(physicalColumn, amount) {\n    this.metas.insert(physicalColumn, \
amount);\n  }\n  /**\n   * Removes one or more columns from the collection.\n \
  *\n   * @param {number} physicalColumn The physical column index which \
points from what position the column is removed.\n   * @param {number} amount \
An amount columns to remove.\n   */\n  removeColumn(physicalColumn, amount) \
{\n    this.metas.remove(physicalColumn, amount);\n  }\n  /**\n   * Gets \
settings object for this layer.\n   *\n   * @param {number} physicalColumn \
The physical column index.\n   * @returns {object}\n   */\n  \
getMeta(physicalColumn) {\n    return this.metas.obtain(physicalColumn);\n  \
}\n  /**\n   * Gets constructor of the column meta object. Necessary for \
inheritance - creating the next meta layers.\n   *\n   * @param {number} \
physicalColumn The physical column index.\n   * @returns {Function}\n   */\n  \
getMetaConstructor(physicalColumn) {\n    return \
this.metas.obtain(physicalColumn).constructor;\n  }\n  /**\n   * Clears all \
saved column meta objects.\n   */\n  clearCache() {\n    \
this.metas.clear();\n  }\n  /**\n   * Creates and returns new column meta \
object with properties inherited from the global meta layer.\n   *\n   * \
@private\n   * @returns {object}\n   */\n  _createMeta() {\n    return \
columnFactory(this.globalMeta.getMetaConstructor(), \
COLUMNS_PROPS_CONFLICTS).prototype;\n  }\n};\n\n// \
node_modules/handsontable/dataMap/metaManager/metaLayers/cellMeta.mjs\nvar \
CellMeta = class {\n  constructor(columnMeta) {\n    this.columnMeta = \
columnMeta;\n    this.metas = new LazyFactoryMap(() => this._createRow());\n  \
}\n  /**\n   * Updates cell meta object by merging settings with the current \
state.\n   *\n   * @param {number} physicalRow The physical row index which \
points what cell meta object is updated.\n   * @param {number} physicalColumn \
The physical column index which points what cell meta object is updated.\n   \
* @param {object} settings An object to merge with.\n   */\n  \
updateMeta(physicalRow, physicalColumn, settings) {\n    const meta = \
this.getMeta(physicalRow, physicalColumn);\n    extend(meta, settings);\n    \
extendByMetaType(meta, settings);\n  }\n  /**\n   * Creates one or more rows \
at specific position.\n   *\n   * @param {number} physicalRow The physical \
row index which points from what position the row is added.\n   * @param \
{number} amount An amount of rows to add.\n   */\n  createRow(physicalRow, \
amount) {\n    this.metas.insert(physicalRow, amount);\n  }\n  /**\n   * \
Creates one or more columns at specific position.\n   *\n   * @param {number} \
physicalColumn The physical column index which points from what position the \
column is added.\n   * @param {number} amount An amount of columns to add.\n  \
 */\n  createColumn(physicalColumn, amount) {\n    for (let i = 0; i < \
this.metas.size(); i++) {\n      this.metas.obtain(i).insert(physicalColumn, \
amount);\n    }\n  }\n  /**\n   * Removes one or more rows from the \
collection.\n   *\n   * @param {number} physicalRow The physical row index \
which points from what position the row is removed.\n   * @param {number} \
amount An amount of rows to remove.\n   */\n  removeRow(physicalRow, amount) \
{\n    this.metas.remove(physicalRow, amount);\n  }\n  /**\n   * Removes one \
or more columns from the collection.\n   *\n   * @param {number} \
physicalColumn The physical column index which points from what position the \
column is removed.\n   * @param {number} amount An amount of columns to \
remove.\n   */\n  removeColumn(physicalColumn, amount) {\n    for (let i = 0; \
i < this.metas.size(); i++) {\n      \
this.metas.obtain(i).remove(physicalColumn, amount);\n    }\n  }\n  /**\n   * \
Gets settings object for this layer.\n   *\n   * @param {number} physicalRow \
The physical row index.\n   * @param {number} physicalColumn The physical \
column index.\n   * @param {string} [key] If the key exists its value will be \
returned, otherwise the whole cell meta object.\n   * @returns {object}\n   \
*/\n  getMeta(physicalRow, physicalColumn, key) {\n    const cellMeta = \
this.metas.obtain(physicalRow).obtain(physicalColumn);\n    if (key === void \
0) {\n      return cellMeta;\n    }\n    return cellMeta[key];\n  }\n  /**\n  \
 * Sets settings object for this layer defined by \"key\" property.\n   *\n   \
* @param {number} physicalRow The physical row index.\n   * @param {number} \
physicalColumn The physical column index.\n   * @param {string} key The \
property name to set.\n   * @param {*} value Value to save.\n   */\n  \
setMeta(physicalRow, physicalColumn, key, value) {\n    var \
_cellMeta$_automatica;\n    const cellMeta = \
this.metas.obtain(physicalRow).obtain(physicalColumn);\n    \
(_cellMeta$_automatica = cellMeta._automaticallyAssignedMetaProps) === null \
|| _cellMeta$_automatica === void 0 || _cellMeta$_automatica.delete(key);\n   \
 cellMeta[key] = value;\n  }\n  /**\n   * Removes a property defined by the \
\"key\" argument from the cell meta object.\n   *\n   * @param {number} \
physicalRow The physical row index.\n   * @param {number} physicalColumn The \
physical column index.\n   * @param {string} key The property name to \
remove.\n   */\n  removeMeta(physicalRow, physicalColumn, key) {\n    const \
cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);\n    delete \
cellMeta[key];\n  }\n  /**\n   * Returns all cell meta objects that were \
created during the Handsontable operation. As cell meta\n   * objects are \
created lazy, the length of the returned collection depends on how and when \
the\n   * table has asked for access to that meta objects.\n   *\n   * \
@returns {object[]}\n   */\n  getMetas() {\n    const metas = [];\n    const \
rows = Array.from(this.metas.values());\n    for (let row = 0; row < \
rows.length; row++) {\n      metas.push(...rows[row].values());\n    }\n    \
return metas;\n  }\n  /**\n   * Returns all cell meta objects that were \
created during the Handsontable operation but for\n   * specific row index.\n \
  *\n   * @param {number} physicalRow The physical row index.\n   * @returns \
{object[]}\n   */\n  getMetasAtRow(physicalRow) {\n    assert(() => \
isUnsignedNumber(physicalRow), \"Expecting an unsigned number.\");\n    const \
rowsMeta = new Map(this.metas);\n    return rowsMeta.has(physicalRow) ? \
Array.from(rowsMeta.get(physicalRow).values()) : [];\n  }\n  /**\n   * Clears \
all saved cell meta objects.\n   */\n  clearCache() {\n    \
this.metas.clear();\n  }\n  /**\n   * Creates and returns new structure for \
cell meta objects stored in columnar axis.\n   *\n   * @private\n   * \
@returns {object}\n   */\n  _createRow() {\n    return new \
LazyFactoryMap((physicalColumn) => this._createMeta(physicalColumn));\n  }\n  \
/**\n   * Creates and returns new cell meta object with properties inherited \
from the column meta layer.\n   *\n   * @private\n   * @param {number} \
physicalColumn The physical column index.\n   * @returns {object}\n   */\n  \
_createMeta(physicalColumn) {\n    const ColumnMeta2 = \
this.columnMeta.getMetaConstructor(physicalColumn);\n    return new \
ColumnMeta2();\n  }\n};\n\n// \
node_modules/handsontable/dataMap/metaManager/index.mjs\nvar MetaManager = \
class {\n  constructor(hot2) {\n    let customSettings = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : {};\n    let metaMods = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    \
this.hot = hot2;\n    this.globalMeta = new GlobalMeta(hot2);\n    \
this.tableMeta = new TableMeta(this.globalMeta);\n    this.columnMeta = new \
ColumnMeta(this.globalMeta);\n    this.cellMeta = new \
CellMeta(this.columnMeta);\n    metaMods.forEach((ModifierClass) => new \
ModifierClass(this));\n    this.globalMeta.updateMeta(customSettings);\n  }\n \
 /**\n   * Gets the global meta object that is a root of all default \
settings, which are recognizable by Handsontable.\n   * Other layers \
inherites all properties from this. Adding, removing, or changing property in \
that\n   * object has a direct reflection to all layers.\n   *\n   * @returns \
{object}\n   */\n  getGlobalMeta() {\n    return this.globalMeta.getMeta();\n \
 }\n  /**\n   * Updates global settings object by merging settings with the \
current state.\n   *\n   * @param {object} settings An object to merge \
with.\n   */\n  updateGlobalMeta(settings) {\n    \
this.globalMeta.updateMeta(settings);\n  }\n  /**\n   * Gets settings object \
that was passed in the Handsontable constructor. That layer contains all\n   \
* default settings inherited from the GlobalMeta layer merged with settings \
passed by the developer.\n   * Adding, removing, or changing property in that \
object has no direct reflection on any other layers.\n   *\n   * @returns \
{TableMeta}\n   */\n  getTableMeta() {\n    return \
this.tableMeta.getMeta();\n  }\n  /**\n   * Updates table settings object by \
merging settings with the current state.\n   *\n   * @param {object} settings \
An object to merge with.\n   */\n  updateTableMeta(settings) {\n    \
this.tableMeta.updateMeta(settings);\n  }\n  /**\n   * Gets column meta \
object that is a root of all settings defined in the column property of the \
Handsontable\n   * settings. Each column in the Handsontable is associated \
with a unique meta object which identified by\n   * the physical column \
index. Adding, removing, or changing property in that object has a direct \
reflection\n   * only for the CellMeta layer. The reflection will be visible \
only if the property doesn't exist in the lower\n   * layers (prototype \
lookup).\n   *\n   * @param {number} physicalColumn The physical column \
index.\n   * @returns {object}\n   */\n  getColumnMeta(physicalColumn) {\n    \
return this.columnMeta.getMeta(physicalColumn);\n  }\n  /**\n   * Updates \
column meta object by merging settings with the current state.\n   *\n   * \
@param {number} physicalColumn The physical column index which points what \
column meta object is updated.\n   * @param {object} settings An object to \
merge with.\n   */\n  updateColumnMeta(physicalColumn, settings) {\n    \
this.columnMeta.updateMeta(physicalColumn, settings);\n  }\n  /**\n   * Gets \
the cell meta object that is a root of all settings defined for the specific \
cell rendered by\n   * the Handsontable. Each cell meta inherits settings \
from higher layers. When a property doesn't\n   * exist in that layer, it is \
looked up through a prototype to the highest layer. Starting\n   * from \
CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default \
settings. Adding,\n   * removing, or changing property in that object has no \
direct reflection on any other layers.\n   *\n   * @param {number} \
physicalRow The physical row index.\n   * @param {number} physicalColumn The \
physical column index.\n   * @param {object} options Additional options that \
are used to extend the cell meta object.\n   * @param {number} \
options.visualRow The visual row index of the currently requested cell meta \
object.\n   * @param {number} options.visualColumn The visual column index of \
the currently requested cell meta object.\n   * @returns {object}\n   */\n  \
getCellMeta(physicalRow, physicalColumn, _ref) {\n    let {\n      \
visualRow,\n      visualColumn\n    } = _ref;\n    const cellMeta = \
this.cellMeta.getMeta(physicalRow, physicalColumn);\n    cellMeta.visualRow = \
visualRow;\n    cellMeta.visualCol = visualColumn;\n    cellMeta.row = \
physicalRow;\n    cellMeta.col = physicalColumn;\n    \
this.runLocalHooks(\"afterGetCellMeta\", cellMeta);\n    return cellMeta;\n  \
}\n  /**\n   * Gets a value (defined by the `key` property) from the cell \
meta object.\n   *\n   * @param {number} physicalRow The physical row \
index.\n   * @param {number} physicalColumn The physical column index.\n   * \
@param {string} key Defines the value that will be returned from the cell \
meta object.\n   * @returns {*}\n   */\n  getCellMetaKeyValue(physicalRow, \
physicalColumn, key) {\n    if (typeof key !== \"string\") {\n      throw new \
Error(\"The passed cell meta object key is not a string\");\n    }\n    \
return this.cellMeta.getMeta(physicalRow, physicalColumn, key);\n  }\n  /**\n \
  * Sets settings object for cell meta object defined by \"key\" property.\n  \
 *\n   * @param {number} physicalRow The physical row index.\n   * @param \
{number} physicalColumn The physical column index.\n   * @param {string} key \
The property name to set.\n   * @param {*} value Value to save.\n   */\n  \
setCellMeta(physicalRow, physicalColumn, key, value) {\n    \
this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);\n  }\n  /**\n \
  * Updates cell meta object by merging settings with the current state.\n   \
*\n   * @param {number} physicalRow The physical row index which points what \
cell meta object is updated.\n   * @param {number} physicalColumn The \
physical column index which points what cell meta object is updated.\n   * \
@param {object} settings An object to merge with.\n   */\n  \
updateCellMeta(physicalRow, physicalColumn, settings) {\n    \
this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);\n  }\n  \
/**\n   * Removes a property defined by the \"key\" argument from the cell \
meta object.\n   *\n   * @param {number} physicalRow The physical row \
index.\n   * @param {number} physicalColumn The physical column index.\n   * \
@param {string} key The property name to remove.\n   */\n  \
removeCellMeta(physicalRow, physicalColumn, key) {\n    \
this.cellMeta.removeMeta(physicalRow, physicalColumn, key);\n  }\n  /**\n   * \
Returns all cell meta objects that were created during the Handsontable \
operation. As cell meta\n   * objects are created lazy, the length of the \
returned collection depends on how and when the\n   * table has asked for \
access to that meta objects.\n   *\n   * @returns {object[]}\n   */\n  \
getCellsMeta() {\n    return this.cellMeta.getMetas();\n  }\n  /**\n   * \
Returns all cell meta objects that were created during the Handsontable \
operation but for\n   * specyfic row index.\n   *\n   * @param {number} \
physicalRow The physical row index.\n   * @returns {object[]}\n   */\n  \
getCellsMetaAtRow(physicalRow) {\n    return \
this.cellMeta.getMetasAtRow(physicalRow);\n  }\n  /**\n   * Creates one or \
more rows at specific position.\n   *\n   * @param {number} physicalRow The \
physical row index which points from what position the row is added.\n   * \
@param {number} [amount=1] An amount of rows to add.\n   */\n  \
createRow(physicalRow) {\n    let amount = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : 1;\n    \
this.cellMeta.createRow(physicalRow, amount);\n  }\n  /**\n   * Removes one \
or more rows from the collection.\n   *\n   * @param {number} physicalRow The \
physical row index which points from what position the row is removed.\n   * \
@param {number} [amount=1] An amount rows to remove.\n   */\n  \
removeRow(physicalRow) {\n    let amount = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : 1;\n    \
this.cellMeta.removeRow(physicalRow, amount);\n  }\n  /**\n   * Creates one \
or more columns at specific position.\n   *\n   * @param {number} \
physicalColumn The physical column index which points from what position the \
column is added.\n   * @param {number} [amount=1] An amount of columns to \
add.\n   */\n  createColumn(physicalColumn) {\n    let amount = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    \
this.cellMeta.createColumn(physicalColumn, amount);\n    \
this.columnMeta.createColumn(physicalColumn, amount);\n  }\n  /**\n   * \
Removes one or more columns from the collection.\n   *\n   * @param {number} \
physicalColumn The physical column index which points from what position the \
column is removed.\n   * @param {number} [amount=1] An amount of columns to \
remove.\n   */\n  removeColumn(physicalColumn) {\n    let amount = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    \
this.cellMeta.removeColumn(physicalColumn, amount);\n    \
this.columnMeta.removeColumn(physicalColumn, amount);\n  }\n  /**\n   * \
Clears all saved cell meta objects. It keeps column meta, table meta, and \
global meta intact.\n   */\n  clearCellsCache() {\n    \
this.cellMeta.clearCache();\n  }\n  /**\n   * Clears all saved cell and \
columns meta objects.\n   */\n  clearCache() {\n    \
this.cellMeta.clearCache();\n    this.columnMeta.clearCache();\n  \
}\n};\nmixin(MetaManager, localHooks_default);\n\n// \
node_modules/handsontable/dataMap/replaceData.mjs\nfunction \
replaceData(data2, setDataMapFunction, callbackFunction, config) {\n  const \
{\n    hotInstance,\n    dataMap,\n    dataSource,\n    internalSource,\n    \
source,\n    metaManager,\n    firstRun\n  } = config;\n  const \
capitalizedInternalSource = toUpperCaseFirst(internalSource);\n  const \
tableMeta = hotInstance.getSettings();\n  if \
(Array.isArray(tableMeta.dataSchema)) {\n    hotInstance.dataType = \
\"array\";\n  } else if (isFunction(tableMeta.dataSchema)) {\n    \
hotInstance.dataType = \"function\";\n  } else {\n    hotInstance.dataType = \
\"object\";\n  }\n  if (dataMap) {\n    dataMap.destroy();\n  }\n  data2 = \
hotInstance.runHooks(`before${capitalizedInternalSource}`, data2, firstRun, \
source);\n  const newDataMap = new dataMap_default(hotInstance, data2, \
metaManager);\n  setDataMapFunction(newDataMap);\n  if (typeof data2 === \
\"object\" && data2 !== null) {\n    if (!(data2.push && data2.splice)) {\n   \
   data2 = [data2];\n    }\n  } else if (data2 === null) {\n    const \
dataSchema = newDataMap.getSchema();\n    data2 = [];\n    let row;\n    let \
r = 0;\n    let rlen = 0;\n    for (r = 0, rlen = tableMeta.startRows; r < \
rlen; r++) {\n      if ((hotInstance.dataType === \"object\" || \
hotInstance.dataType === \"function\") && tableMeta.dataSchema) {\n        \
row = deepClone(dataSchema);\n        data2.push(row);\n      } else if \
(hotInstance.dataType === \"array\") {\n        row = \
deepClone(dataSchema[0]);\n        data2.push(row);\n      } else {\n        \
row = [];\n        for (let c = 0, clen = tableMeta.startCols; c < clen; c++) \
{\n          row.push(null);\n        }\n        data2.push(row);\n      }\n  \
  }\n  } else {\n    throw new Error(`${internalSource} only accepts array of \
objects or array of arrays (${typeof data2} given)`);\n  }\n  if \
(Array.isArray(data2[0])) {\n    hotInstance.dataType = \"array\";\n  }\n  \
tableMeta.data = data2;\n  newDataMap.dataSource = data2;\n  dataSource.data \
= data2;\n  dataSource.dataType = hotInstance.dataType;\n  \
dataSource.colToProp = newDataMap.colToProp.bind(newDataMap);\n  \
dataSource.propToCol = newDataMap.propToCol.bind(newDataMap);\n  \
dataSource.countCachedColumns = \
newDataMap.countCachedColumns.bind(newDataMap);\n  \
callbackFunction(newDataMap);\n  \
hotInstance.runHooks(`after${capitalizedInternalSource}`, data2, firstRun, \
source);\n  if (!firstRun) {\n    hotInstance.runHooks(\"afterChange\", null, \
internalSource);\n    hotInstance.render();\n  }\n}\n\n// \
node_modules/handsontable/dataMap/metaManager/mods/dynamicCellMeta.mjs\nvar \
DynamicCellMetaMod = class {\n  constructor(metaManager) {\n    \
this.metaManager = metaManager;\n    this.metaSyncMemo = /* @__PURE__ */ new \
Map();\n    metaManager.addLocalHook(\"afterGetCellMeta\", (cellMeta) => \
this.extendCellMeta(cellMeta));\n    \
pluginHooks_default.getSingleton().add(\"beforeRender\", (forceFullRender) => \
{\n      if (forceFullRender) {\n        this.metaSyncMemo.clear();\n      \
}\n    }, this.metaManager.hot);\n  }\n  /**\n   * Extends the cell meta \
object by user-specific properties.\n   *\n   * The cell meta object can be \
extended dynamically,\n   * either by Handsontable's hooks \
(`beforeGetCellMeta` and`afterGetCellMeta`),\n   * or by Handsontable's \
`cells` option.\n   *\n   * To boost performance, the extending process is \
triggered only once per one slow Handsontable render cycle.\n   *\n   * \
@param {object} cellMeta The cell meta object.\n   */\n  \
extendCellMeta(cellMeta) {\n    var _this$metaSyncMemo$ge;\n    const {\n     \
 row: physicalRow,\n      col: physicalColumn\n    } = cellMeta;\n    if \
((_this$metaSyncMemo$ge = this.metaSyncMemo.get(physicalRow)) !== null && \
_this$metaSyncMemo$ge !== void 0 && \
_this$metaSyncMemo$ge.has(physicalColumn)) {\n      return;\n    }\n    const \
{\n      visualRow,\n      visualCol\n    } = cellMeta;\n    const hot2 = \
this.metaManager.hot;\n    const prop = hot2.colToProp(visualCol);\n    \
cellMeta.prop = prop;\n    hot2.runHooks(\"beforeGetCellMeta\", visualRow, \
visualCol, cellMeta);\n    const cellType = hasOwnProperty(cellMeta, \
\"type\") ? cellMeta.type : null;\n    let cellSettings = \
isFunction(cellMeta.cells) ? cellMeta.cells(physicalRow, physicalColumn, \
prop) : null;\n    if (cellType) {\n      if (cellSettings) {\n        var \
_cellSettings$type;\n        cellSettings.type = (_cellSettings$type = \
cellSettings.type) !== null && _cellSettings$type !== void 0 ? \
_cellSettings$type : cellType;\n      } else {\n        cellSettings = {\n    \
      type: cellType\n        };\n      }\n    }\n    if (cellSettings) {\n   \
   this.metaManager.updateCellMeta(physicalRow, physicalColumn, \
cellSettings);\n    }\n    hot2.runHooks(\"afterGetCellMeta\", visualRow, \
visualCol, cellMeta);\n    if (!this.metaSyncMemo.has(physicalRow)) {\n      \
this.metaSyncMemo.set(physicalRow, /* @__PURE__ */ new Set());\n    }\n    \
this.metaSyncMemo.get(physicalRow).add(physicalColumn);\n  }\n};\n\n// \
node_modules/handsontable/dataMap/metaManager/mods/extendMetaProperties.mjs\n\
var ExtendMetaPropertiesMod = class {\n  constructor(metaManager) {\n    \
this.metaManager = metaManager;\n    this.usageTracker = /* @__PURE__ */ new \
Set();\n    this.propDescriptors = /* @__PURE__ */ new \
Map([[\"fixedColumnsLeft\", {\n      target: \"fixedColumnsStart\",\n      \
onChange(propName) {\n        const isRtl = this.metaManager.hot.isRtl();\n   \
     if (isRtl && propName === \"fixedColumnsLeft\") {\n          throw new \
Error(\"The `fixedColumnsLeft` is not supported for RTL. Please use option \
`fixedColumnsStart`.\");\n        }\n        if \
(this.usageTracker.has(\"fixedColumnsLeft\") && \
this.usageTracker.has(\"fixedColumnsStart\")) {\n          throw new \
Error(\"The `fixedColumnsLeft` and `fixedColumnsStart` should not be used \
together. Please use only the option `fixedColumnsStart`.\");\n        }\n    \
  }\n    }], [\"layoutDirection\", {\n      onChange(propName, value, \
isInitialChange) {\n        if (!isInitialChange) {\n          throw new \
Error(`The \\`${propName}\\` option can not be updated after the Handsontable \
is initialized.`);\n        }\n      }\n    }]]);\n    \
this.extendMetaProps();\n  }\n  /**\n   * Extends the meta options based on \
the object descriptors from the `propDescriptors` list.\n   */\n  \
extendMetaProps() {\n    this.propDescriptors.forEach((descriptor, alias) => \
{\n      const {\n        target,\n        onChange: onChange2 = () => {\n    \
    }\n      } = descriptor;\n      const hasTarget = typeof target === \
\"string\";\n      const targetProp = hasTarget ? target : alias;\n      \
const origProp = `_${targetProp}`;\n      \
this.metaManager.globalMeta.meta[origProp] = \
this.metaManager.globalMeta.meta[targetProp];\n      \
this.installPropWatcher(alias, origProp, onChange2);\n      if (hasTarget) \
{\n        this.installPropWatcher(target, origProp, onChange2);\n      }\n   \
 });\n  }\n  /**\n   * Installs the property watcher to the `propName` option \
and forwards getter and setter to\n   * the new one.\n   *\n   * @param \
{string} propName The property to watch.\n   * @param {string} origProp The \
property from/to the value is forwarded.\n   * @param {Function} onChange The \
callback.\n   */\n  installPropWatcher(propName, origProp, onChange2) {\n    \
const self2 = this;\n    \
Object.defineProperty(this.metaManager.globalMeta.meta, propName, {\n      \
get() {\n        return this[origProp];\n      },\n      set(value) {\n       \
 const isInitialChange = !self2.usageTracker.has(propName);\n        \
self2.usageTracker.add(propName);\n        onChange2.call(self2, propName, \
value, isInitialChange);\n        this[origProp] = value;\n      },\n      \
enumerable: true,\n      configurable: true\n    });\n  }\n};\n\n// \
node_modules/handsontable/shortcuts/utils.mjs\nvar mappings = /* @__PURE__ */ \
new Map([\n  [\" \", \"space\"],\n  // custom mapping\n  [\"spacebar\", \
\"space\"],\n  [\"scroll\", \"scrolllock\"],\n  [\"del\", \"delete\"],\n  \
[\"esc\", \"escape\"],\n  [\"medianexttrack\", \"mediatracknext\"],\n  \
[\"mediaprevioustrack\", \"mediatrackprevious\"],\n  [\"volumeup\", \
\"audiovolumeup\"],\n  [\"volumedown\", \"audiovolumedown\"],\n  \
[\"volumemute\", \"audiovolumemute\"],\n  [\"multiply\", \"*\"],\n  [\"add\", \
\"+\"],\n  [\"divide\", \"/\"],\n  [\"subtract\", \"-\"],\n  [\"left\", \
\"arrowleft\"],\n  [\"right\", \"arrowright\"],\n  [\"up\", \"arrowup\"],\n  \
[\"down\", \"arrowdown\"]\n]);\nvar normalizeKeys = (keys) => {\n  return \
keys.map((key) => {\n    const lowercaseKey = key.toLowerCase();\n    if \
(mappings.has(lowercaseKey)) {\n      return mappings.get(lowercaseKey);\n    \
}\n    return lowercaseKey;\n  }).sort().join(\"+\");\n};\nvar getKeysList = \
(normalizedKeys) => {\n  return normalizedKeys.split(\"+\");\n};\nvar \
normalizeEventKey = (key) => {\n  return key.toLowerCase();\n};\n\n// \
node_modules/handsontable/shortcuts/context.mjs\nvar createContext = (name) \
=> {\n  const SHORTCUTS = createUniqueMap({\n    errorIdExists: (keys) => \
`The \"${keys}\" shortcut is already registered in the \"${name}\" \
context.`\n  });\n  const addShortcut = function() {\n    let {\n      \
keys,\n      callback,\n      group,\n      runOnlyIf = () => true,\n      \
captureCtrl = false,\n      preventDefault = true,\n      stopPropagation = \
false,\n      relativeToGroup,\n      position\n    } = arguments.length > 0 \
&& arguments[0] !== void 0 ? arguments[0] : {};\n    if (isUndefined(group)) \
{\n      throw new Error(\"You need to define the shortcut's group.\");\n    \
}\n    if (isFunction(callback) === false) {\n      throw new Error(\"The \
shortcut's callback needs to be a function.\");\n    }\n    if \
(Array.isArray(keys) === false) {\n      throw new Error(toSingleLine`Pass \
the shortcut\\'s keys as an array of arrays,\\x20\n      using the \
KeyboardEvent.key properties:\\x20\n      \
https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\
.`);\n    }\n    const newShortcut = {\n      callback,\n      group,\n      \
runOnlyIf,\n      captureCtrl,\n      preventDefault,\n      \
stopPropagation\n    };\n    if (isDefined(relativeToGroup)) {\n      \
[newShortcut.relativeToGroup, newShortcut.position] = [relativeToGroup, \
position];\n    }\n    keys.forEach((keyCombination) => {\n      const \
normalizedKeys = normalizeKeys(keyCombination);\n      const \
hasKeyCombination = SHORTCUTS.hasItem(normalizedKeys);\n      if \
(hasKeyCombination) {\n        const shortcuts = \
SHORTCUTS.getItem(normalizedKeys);\n        let insertionIndex = \
shortcuts.findIndex((shortcut) => shortcut.group === relativeToGroup);\n      \
  if (insertionIndex !== -1) {\n          if (position === \"before\") {\n    \
        insertionIndex -= 1;\n          } else {\n            insertionIndex \
+= 1;\n          }\n        } else {\n          insertionIndex = \
shortcuts.length;\n        }\n        shortcuts.splice(insertionIndex, 0, \
newShortcut);\n      } else {\n        SHORTCUTS.addItem(normalizedKeys, \
[newShortcut]);\n      }\n    });\n  };\n  const addShortcuts = \
function(shortcuts) {\n    let options = arguments.length > 1 && arguments[1] \
!== void 0 ? arguments[1] : {};\n    shortcuts.forEach((shortcut) => {\n      \
objectEach(options, (value, key) => {\n        if \
(Object.prototype.hasOwnProperty.call(shortcut, key) === false) {\n          \
shortcut[key] = options[key];\n        }\n      });\n      \
addShortcut(shortcut);\n    });\n  };\n  const removeShortcutsByKeys = (keys) \
=> {\n    const normalizedKeys = normalizeKeys(keys);\n    \
SHORTCUTS.removeItem(normalizedKeys);\n  };\n  const removeShortcutsByGroup = \
(group) => {\n    const shortcuts = SHORTCUTS.getItems();\n    \
shortcuts.forEach((_ref) => {\n      let [normalizedKeys, shortcutOptions] = \
_ref;\n      const leftOptions = shortcutOptions.filter((option) => \
option.group !== group);\n      if (leftOptions.length === 0) {\n        \
removeShortcutsByKeys(getKeysList(normalizedKeys));\n      } else {\n        \
shortcutOptions.length = 0;\n        shortcutOptions.push(...leftOptions);\n  \
    }\n    });\n  };\n  const getShortcuts = (keys) => {\n    const \
normalizedKeys = normalizeKeys(keys);\n    const shortcuts = \
SHORTCUTS.getItem(normalizedKeys);\n    return isDefined(shortcuts) ? \
shortcuts.slice() : [];\n  };\n  const hasShortcut = (keys) => {\n    const \
normalizedKeys = normalizeKeys(keys);\n    return \
SHORTCUTS.hasItem(normalizedKeys);\n  };\n  return {\n    addShortcut,\n    \
addShortcuts,\n    getShortcuts,\n    hasShortcut,\n    \
removeShortcutsByKeys,\n    removeShortcutsByGroup\n  };\n};\n\n// \
node_modules/handsontable/shortcuts/keyObserver.mjs\nfunction \
createKeysObserver() {\n  const PRESSED_KEYS = /* @__PURE__ */ new Set();\n  \
return {\n    /**\n     * Press a key.\n     *\n     * @param {string} key \
Names of the shortcut's keys,\n     * (coming from \
[`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/Keyboa\
rdEvent/key/Key_Values)),\n     * in lowercase or uppercase, unified across \
browsers\n     */\n    press(key) {\n      PRESSED_KEYS.add(key);\n    },\n   \
 /**\n     * Release a pressed key.\n     *\n     * @param {string} key Names \
of the shortcut's keys,\n     * (coming from \
[`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/Keyboa\
rdEvent/key/Key_Values)),\n     * in lowercase or uppercase, unified across \
browsers\n     */\n    release(key) {\n      PRESSED_KEYS.delete(key);\n    \
},\n    /**\n     * Release all pressed keys.\n     */\n    releaseAll() {\n  \
    PRESSED_KEYS.clear();\n    },\n    /**\n     * Check if a key is \
pressed.\n     *\n     * @param {string} key Names of the shortcut's keys,\n  \
   * (coming from \
[`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/Keyboa\
rdEvent/key/Key_Values)),\n     * in lowercase or uppercase, unified across \
browsers\n     * @returns {boolean}\n     */\n    isPressed(key) {\n      \
return PRESSED_KEYS.has(key);\n    }\n  };\n}\n\n// \
node_modules/handsontable/shortcuts/recorder.mjs\nvar MODIFIER_KEYS = \
[\"meta\", \"alt\", \"shift\", \"control\"];\nvar modifierKeysObserver = \
createKeysObserver();\nfunction useRecorder(ownerWindow, handleEvent, \
beforeKeyDown, afterKeyDown, callback) {\n  const isModifierKey = \
(pressedKey) => {\n    return MODIFIER_KEYS.includes(pressedKey);\n  };\n  \
const getPressedModifierKeys = function(event2) {\n    let mergeMetaKeys = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    \
const pressedModifierKeys = [];\n    if (event2.altKey) {\n      \
pressedModifierKeys.push(\"alt\");\n    }\n    if (mergeMetaKeys && \
(event2.ctrlKey || event2.metaKey)) {\n      \
pressedModifierKeys.push(\"control/meta\");\n    } else {\n      if \
(event2.ctrlKey) {\n        pressedModifierKeys.push(\"control\");\n      }\n \
     if (event2.metaKey) {\n        pressedModifierKeys.push(\"meta\");\n     \
 }\n    }\n    if (event2.shiftKey) {\n      \
pressedModifierKeys.push(\"shift\");\n    }\n    return \
pressedModifierKeys;\n  };\n  const onkeydown = (event2) => {\n    if \
(handleEvent(event2) === false) {\n      return;\n    }\n    const result = \
beforeKeyDown(event2);\n    if (event2.keyCode === 229 || result === false || \
isImmediatePropagationStopped(event2)) {\n      return;\n    }\n    const \
pressedKey = normalizeEventKey(event2.key);\n    let extraModifierKeys = \
[];\n    if (isModifierKey(pressedKey)) {\n      \
modifierKeysObserver.press(pressedKey);\n    } else {\n      \
extraModifierKeys = getPressedModifierKeys(event2);\n    }\n    const \
pressedKeys = [pressedKey].concat(extraModifierKeys);\n    const \
isExecutionCancelled = callback(event2, pressedKeys);\n    if \
(!isExecutionCancelled && (isMacOS() && extraModifierKeys.includes(\"meta\") \
|| !isMacOS() && extraModifierKeys.includes(\"control\"))) {\n      \
callback(event2, [pressedKey].concat(getPressedModifierKeys(event2, \
true)));\n    }\n    afterKeyDown(event2);\n  };\n  const onkeyup = (event2) \
=> {\n    if (handleEvent(event2) === false) {\n      return;\n    }\n    \
const pressedKey = normalizeEventKey(event2.key);\n    if \
(isModifierKey(pressedKey) === false) {\n      return;\n    }\n    \
modifierKeysObserver.release(pressedKey);\n  };\n  const onblur = () => {\n   \
 modifierKeysObserver.releaseAll();\n  };\n  const mount = () => {\n    let \
eventTarget = ownerWindow;\n    while (eventTarget) {\n      \
eventTarget.document.documentElement.addEventListener(\"keydown\", \
onkeydown);\n      \
eventTarget.document.documentElement.addEventListener(\"keyup\", onkeyup);\n  \
    eventTarget.document.documentElement.addEventListener(\"blur\", \
onblur);\n      eventTarget = getParentWindow(eventTarget);\n    }\n  };\n  \
const unmount = () => {\n    let eventTarget = ownerWindow;\n    while \
(eventTarget) {\n      \
eventTarget.document.documentElement.removeEventListener(\"keydown\", \
onkeydown);\n      \
eventTarget.document.documentElement.removeEventListener(\"keyup\", \
onkeyup);\n      \
eventTarget.document.documentElement.removeEventListener(\"blur\", onblur);\n \
     eventTarget = getParentWindow(eventTarget);\n    }\n  };\n  return {\n   \
 mount,\n    unmount,\n    isPressed: (key) => \
modifierKeysObserver.isPressed(key),\n    releasePressedKeys: () => \
modifierKeysObserver.releaseAll()\n  };\n}\n\n// \
node_modules/handsontable/shortcuts/manager.mjs\nvar createShortcutManager = \
(_ref) => {\n  let {\n    ownerWindow,\n    handleEvent,\n    \
beforeKeyDown,\n    afterKeyDown\n  } = _ref;\n  const CONTEXTS = \
createUniqueMap({\n    errorIdExists: (keys) => `The \"${keys}\" context name \
is already registered.`\n  });\n  let activeContextName = \"grid\";\n  const \
addContext = (contextName) => {\n    const context = \
createContext(contextName);\n    CONTEXTS.addItem(contextName, context);\n    \
return context;\n  };\n  const getActiveContextName = () => {\n    return \
activeContextName;\n  };\n  const getContext = (contextName) => {\n    return \
CONTEXTS.getItem(contextName);\n  };\n  const setActiveContextName = \
(contextName) => {\n    activeContextName = contextName;\n  };\n  let \
isCtrlKeySilenced = false;\n  const keyRecorder = useRecorder(ownerWindow, \
handleEvent, beforeKeyDown, afterKeyDown, (event2, keys) => {\n    const \
activeContext = getContext(getActiveContextName());\n    let \
isExecutionCancelled = false;\n    if (!activeContext.hasShortcut(keys)) {\n  \
    return isExecutionCancelled;\n    }\n    const shortcuts = \
activeContext.getShortcuts(keys);\n    for (let index2 = 0; index2 < \
shortcuts.length; index2++) {\n      const {\n        callback,\n        \
runOnlyIf,\n        preventDefault,\n        stopPropagation,\n        \
captureCtrl\n      } = shortcuts[index2];\n      if (runOnlyIf(event2) !== \
false) {\n        isCtrlKeySilenced = captureCtrl;\n        \
isExecutionCancelled = callback(event2, keys) === false;\n        \
isCtrlKeySilenced = false;\n        if (preventDefault) {\n          \
event2.preventDefault();\n        }\n        if (stopPropagation) {\n         \
 event2.stopPropagation();\n        }\n        if (isExecutionCancelled) {\n  \
        break;\n        }\n      }\n    }\n    return isExecutionCancelled;\n \
 });\n  keyRecorder.mount();\n  return {\n    addContext,\n    \
getActiveContextName,\n    getContext,\n    setActiveContextName,\n    /**\n  \
   * Returns whether `control` or `meta` keys are pressed.\n     *\n     * \
@memberof ShortcutManager#\n     * @type {Function}\n     * @returns \
{boolean}\n     */\n    isCtrlPressed: () => !isCtrlKeySilenced && \
(keyRecorder.isPressed(\"control\") || keyRecorder.isPressed(\"meta\")),\n    \
/**\n     * Release every previously pressed key.\n     *\n     * @type \
{Function}\n     * @memberof ShortcutManager#\n     */\n    \
releasePressedKeys: () => keyRecorder.releasePressedKeys(),\n    /**\n     * \
Destroy a context manager instance.\n     *\n     * @type {Function}\n     * \
@memberof ShortcutManager#\n     */\n    destroy: () => \
keyRecorder.unmount()\n  };\n};\n\n// node_modules/handsontable/core.mjs\nvar \
SHORTCUTS_GROUP = \"gridDefault\";\nvar activeGuid = null;\nfunction \
Core(rootElement, userSettings) {\n  var _userSettings$layoutD;\n  let \
rootInstanceSymbol2 = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : false;\n  let preventScrollingToCell = false;\n  let instance \
= this;\n  const eventManager = new eventManager_default(instance);\n  let \
datamap;\n  let dataSource;\n  let grid;\n  let editorManager;\n  let \
firstRun = true;\n  if (hasValidParameter(rootInstanceSymbol2)) {\n    \
registerAsRootInstance(this);\n  }\n  this.rootElement = rootElement;\n  \
this.rootDocument = rootElement.ownerDocument;\n  this.rootWindow = \
this.rootDocument.defaultView;\n  this.isDestroyed = false;\n  \
this.renderSuspendedCounter = 0;\n  this.executionSuspendedCounter = 0;\n  \
const layoutDirection = (_userSettings$layoutD = userSettings === null || \
userSettings === void 0 ? void 0 : userSettings.layoutDirection) !== null && \
_userSettings$layoutD !== void 0 ? _userSettings$layoutD : \"inherit\";\n  \
const rootElementDirection = [\"rtl\", \"ltr\"].includes(layoutDirection) ? \
layoutDirection : \
this.rootWindow.getComputedStyle(this.rootElement).direction;\n  \
this.rootElement.setAttribute(\"dir\", rootElementDirection);\n  this.isRtl = \
function() {\n    return rootElementDirection === \"rtl\";\n  };\n  \
this.isLtr = function() {\n    return !instance.isRtl();\n  };\n  \
this.getDirectionFactor = function() {\n    return instance.isLtr() ? 1 : \
-1;\n  };\n  userSettings.language = \
getValidLanguageCode(userSettings.language);\n  const metaManager = new \
MetaManager(instance, userSettings, [DynamicCellMetaMod, \
ExtendMetaPropertiesMod]);\n  const tableMeta = metaManager.getTableMeta();\n \
 const globalMeta = metaManager.getGlobalMeta();\n  const pluginsRegistry = \
createUniqueMap();\n  this.container = \
this.rootDocument.createElement(\"div\");\n  this.renderCall = false;\n  \
rootElement.insertBefore(this.container, rootElement.firstChild);\n  if \
(isRootInstance(this)) {\n    _injectProductInfo(userSettings.licenseKey, \
rootElement);\n  }\n  this.guid = `ht_${randomString()}`;\n  \
this.columnIndexMapper = new IndexMapper();\n  this.rowIndexMapper = new \
IndexMapper();\n  \
this.columnIndexMapper.addLocalHook(\"indexesSequenceChange\", (source) => \
{\n    instance.runHooks(\"afterColumnSequenceChange\", source);\n  });\n  \
this.rowIndexMapper.addLocalHook(\"indexesSequenceChange\", (source) => {\n   \
 instance.runHooks(\"afterRowSequenceChange\", source);\n  });\n  dataSource \
= new dataSource_default(instance);\n  if (!this.rootElement.id || \
this.rootElement.id.substring(0, 3) === \"ht_\") {\n    this.rootElement.id = \
this.guid;\n  }\n  const visualToRenderableCoords = (coords) => {\n    const \
{\n      row: visualRow,\n      col: visualColumn\n    } = coords;\n    \
return instance._createCellCoords(\n      // We just store indexes for rows \
and columns without headers.\n      visualRow >= 0 ? \
instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : \
visualRow,\n      visualColumn >= 0 ? \
instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : \
visualColumn\n    );\n  };\n  const renderableToVisualCoords = (coords) => \
{\n    const {\n      row: renderableRow,\n      col: renderableColumn\n    } \
= coords;\n    return instance._createCellCoords(\n      // We just store \
indexes for rows and columns without headers.\n      renderableRow >= 0 ? \
instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : \
renderableRow,\n      renderableColumn >= 0 ? \
instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : \
renderableColumn\n      // eslint-disable-line max-len\n    );\n  };\n  let \
selection = new selection_default2(tableMeta, {\n    rowIndexMapper: () => \
instance.rowIndexMapper,\n    columnIndexMapper: () => \
instance.columnIndexMapper,\n    countCols: () => instance.countCols(),\n    \
countRows: () => instance.countRows(),\n    propToCol: (prop) => \
datamap.propToCol(prop),\n    isEditorOpened: () => \
instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false,\n \
   countColsTranslated: () => this.view.countRenderableColumns(),\n    \
countRowsTranslated: () => this.view.countRenderableRows(),\n    \
getShortcutManager: () => instance.getShortcutManager(),\n    \
createCellCoords: (row, column) => instance._createCellCoords(row, column),\n \
   createCellRange: (highlight, from, to) => \
instance._createCellRange(highlight, from, to),\n    \
visualToRenderableCoords,\n    renderableToVisualCoords,\n    \
isDisabledCellSelection: (visualRow, visualColumn) => \
instance.getCellMeta(visualRow, visualColumn).disableVisualSelection\n  });\n \
 this.selection = selection;\n  const onIndexMapperCacheUpdate = (_ref) => \
{\n    let {\n      hiddenIndexesChanged\n    } = _ref;\n    if \
(hiddenIndexesChanged) {\n      this.selection.refresh();\n    }\n  };\n  \
this.columnIndexMapper.addLocalHook(\"cacheUpdated\", \
onIndexMapperCacheUpdate);\n  \
this.rowIndexMapper.addLocalHook(\"cacheUpdated\", \
onIndexMapperCacheUpdate);\n  \
this.selection.addLocalHook(\"beforeSetRangeStart\", (cellCoords) => {\n    \
this.runHooks(\"beforeSetRangeStart\", cellCoords);\n  });\n  \
this.selection.addLocalHook(\"beforeSetRangeStartOnly\", (cellCoords) => {\n  \
  this.runHooks(\"beforeSetRangeStartOnly\", cellCoords);\n  });\n  \
this.selection.addLocalHook(\"beforeSetRangeEnd\", (cellCoords) => {\n    \
this.runHooks(\"beforeSetRangeEnd\", cellCoords);\n    if (cellCoords.row < \
0) {\n      cellCoords.row = this.view._wt.wtTable.getFirstVisibleRow();\n    \
}\n    if (cellCoords.col < 0) {\n      cellCoords.col = \
this.view._wt.wtTable.getFirstVisibleColumn();\n    }\n  });\n  \
this.selection.addLocalHook(\"afterSetRangeEnd\", (cellCoords) => {\n    \
const preventScrolling = createObjectPropListener(false);\n    const \
selectionRange = this.selection.getSelectedRange();\n    const {\n      \
from,\n      to\n    } = selectionRange.current();\n    const \
selectionLayerLevel = selectionRange.size() - 1;\n    \
this.runHooks(\"afterSelection\", from.row, from.col, to.row, to.col, \
preventScrolling, selectionLayerLevel);\n    \
this.runHooks(\"afterSelectionByProp\", from.row, \
instance.colToProp(from.col), to.row, instance.colToProp(to.col), \
preventScrolling, selectionLayerLevel);\n    const isSelectedByAnyHeader = \
this.selection.isSelectedByAnyHeader();\n    const currentSelectedRange = \
this.selection.selectedRange.current();\n    let scrollToCell = true;\n    if \
(preventScrollingToCell) {\n      scrollToCell = false;\n    }\n    if \
(preventScrolling.isTouched()) {\n      scrollToCell = \
!preventScrolling.value;\n    }\n    const isSelectedByRowHeader = \
this.selection.isSelectedByRowHeader();\n    const isSelectedByColumnHeader = \
this.selection.isSelectedByColumnHeader();\n    if (scrollToCell !== false) \
{\n      if (!isSelectedByAnyHeader) {\n        if (currentSelectedRange && \
!this.selection.isMultiple()) {\n          \
this.view.scrollViewport(visualToRenderableCoords(currentSelectedRange.from))\
;\n        } else {\n          \
this.view.scrollViewport(visualToRenderableCoords(cellCoords));\n        }\n  \
    } else if (isSelectedByRowHeader) {\n        \
this.view.scrollViewportVertically(instance.rowIndexMapper.getRenderableFromV\
isualIndex(cellCoords.row));\n      } else if (isSelectedByColumnHeader) {\n  \
      \
this.view.scrollViewportHorizontally(instance.columnIndexMapper.getRenderable\
FromVisualIndex(cellCoords.col));\n      }\n    }\n    if \
(isSelectedByRowHeader && isSelectedByColumnHeader) {\n      \
addClass(this.rootElement, [\"ht__selection--rows\", \
\"ht__selection--columns\"]);\n    } else if (isSelectedByRowHeader) {\n      \
removeClass(this.rootElement, \"ht__selection--columns\");\n      \
addClass(this.rootElement, \"ht__selection--rows\");\n    } else if \
(isSelectedByColumnHeader) {\n      removeClass(this.rootElement, \
\"ht__selection--rows\");\n      addClass(this.rootElement, \
\"ht__selection--columns\");\n    } else {\n      \
removeClass(this.rootElement, [\"ht__selection--rows\", \
\"ht__selection--columns\"]);\n    }\n    this._refreshBorders(null);\n  \
});\n  this.selection.addLocalHook(\"afterSelectionFinished\", (cellRanges) \
=> {\n    const selectionLayerLevel = cellRanges.length - 1;\n    const {\n   \
   from,\n      to\n    } = cellRanges[selectionLayerLevel];\n    \
this.runHooks(\"afterSelectionEnd\", from.row, from.col, to.row, to.col, \
selectionLayerLevel);\n    this.runHooks(\"afterSelectionEndByProp\", \
from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), \
selectionLayerLevel);\n  });\n  \
this.selection.addLocalHook(\"afterIsMultipleSelection\", (isMultiple) => {\n \
   const changedIsMultiple = this.runHooks(\"afterIsMultipleSelection\", \
isMultiple.value);\n    if (isMultiple.value) {\n      isMultiple.value = \
changedIsMultiple;\n    }\n  });\n  \
this.selection.addLocalHook(\"beforeModifyTransformStart\", (cellCoordsDelta) \
=> {\n    this.runHooks(\"modifyTransformStart\", cellCoordsDelta);\n  });\n  \
this.selection.addLocalHook(\"afterModifyTransformStart\", (coords, \
rowTransformDir, colTransformDir) => {\n    \
this.runHooks(\"afterModifyTransformStart\", coords, rowTransformDir, \
colTransformDir);\n  });\n  \
this.selection.addLocalHook(\"beforeModifyTransformEnd\", (cellCoordsDelta) \
=> {\n    this.runHooks(\"modifyTransformEnd\", cellCoordsDelta);\n  });\n  \
this.selection.addLocalHook(\"afterModifyTransformEnd\", (coords, \
rowTransformDir, colTransformDir) => {\n    \
this.runHooks(\"afterModifyTransformEnd\", coords, rowTransformDir, \
colTransformDir);\n  });\n  this.selection.addLocalHook(\"afterDeselect\", () \
=> {\n    editorManager.destroyEditor();\n    this._refreshBorders();\n    \
removeClass(this.rootElement, [\"ht__selection--rows\", \
\"ht__selection--columns\"]);\n    this.runHooks(\"afterDeselect\");\n  });\n \
 this.selection.addLocalHook(\"insertRowRequire\", (totalRows) => {\n    \
this.alter(\"insert_row_above\", totalRows, 1, \"auto\");\n  });\n  \
this.selection.addLocalHook(\"insertColRequire\", (totalCols) => {\n    \
this.alter(\"insert_col_start\", totalCols, 1, \"auto\");\n  });\n  grid = \
{\n    /**\n     * Inserts or removes rows and columns.\n     *\n     * \
@private\n     * @param {string} action Possible values: \
\"insert_row_above\", \"insert_row_below\", \"insert_col_start\", \
\"insert_col_end\",\n     *                        \"remove_row\", \
\"remove_col\".\n     * @param {number|Array} index Row or column visual \
index which from the alter action will be triggered.\n     *                  \
           Alter actions such as \"remove_row\" and \"remove_col\" support \
array indexes in the\n     *                             format `[[index, \
amount], [index, amount]...]` this can be used to remove\n     *              \
               non-consecutive columns or rows in one call.\n     * @param \
{number} [amount=1] Amount of rows or columns to remove.\n     * @param \
{string} [source] Optional. Source of hook runner.\n     * @param {boolean} \
[keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     \
*/\n    alter(action, index2) {\n      var _index, _index2;\n      let amount \
= arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n      \
let source = arguments.length > 3 ? arguments[3] : void 0;\n      let \
keepEmptyRows = arguments.length > 4 ? arguments[4] : void 0;\n      const \
normalizeIndexesGroup = (indexes) => {\n        if (indexes.length === 0) {\n \
         return [];\n        }\n        const sortedIndexes = [...indexes];\n \
       sortedIndexes.sort((_ref2, _ref3) => {\n          let [indexA] = \
_ref2;\n          let [indexB] = _ref3;\n          if (indexA === indexB) {\n \
           return 0;\n          }\n          return indexA > indexB ? 1 : \
-1;\n        });\n        const normalizedIndexes = \
arrayReduce(sortedIndexes, (acc, _ref4) => {\n          let [groupIndex, \
groupAmount] = _ref4;\n          const previousItem = acc[acc.length - 1];\n  \
        const [prevIndex, prevAmount] = previousItem;\n          const \
prevLastIndex = prevIndex + prevAmount;\n          if (groupIndex <= \
prevLastIndex) {\n            const amountToAdd = Math.max(groupAmount - \
(prevLastIndex - groupIndex), 0);\n            previousItem[1] += \
amountToAdd;\n          } else {\n            acc.push([groupIndex, \
groupAmount]);\n          }\n          return acc;\n        }, \
[sortedIndexes[0]]);\n        return normalizedIndexes;\n      };\n      \
switch (action) {\n        case \"insert_row_below\":\n        case \
\"insert_row_above\":\n          const numberOfSourceRows = \
instance.countSourceRows();\n          if (tableMeta.maxRows === \
numberOfSourceRows) {\n            return;\n          }\n          const \
insertRowMode = action === \"insert_row_below\" ? \"below\" : \"above\";\n    \
      index2 = (_index = index2) !== null && _index !== void 0 ? _index : \
insertRowMode === \"below\" ? numberOfSourceRows : 0;\n          const {\n    \
        delta: rowDelta,\n            startPhysicalIndex: \
startRowPhysicalIndex\n          } = datamap.createRow(index2, amount, {\n    \
        source,\n            mode: insertRowMode\n          });\n          if \
(rowDelta) {\n            const currentSelectedRange = \
selection.selectedRange.current();\n            const currentFromRange = \
currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : \
currentSelectedRange.from;\n            const currentFromRow = \
currentFromRange === null || currentFromRange === void 0 ? void 0 : \
currentFromRange.row;\n            const startVisualRowIndex = \
instance.toVisualRow(startRowPhysicalIndex);\n            if \
(selection.isSelectedByCorner()) {\n              instance.selectAll();\n     \
       } else if (isDefined(currentFromRow) && currentFromRow >= \
startVisualRowIndex) {\n              const {\n                row: \
currentToRow,\n                col: currentToColumn\n              } = \
currentSelectedRange.to;\n              let currentFromColumn = \
currentFromRange.col;\n              if (selection.isSelectedByRowHeader()) \
{\n                currentFromColumn = -1;\n              }\n              \
selection.getSelectedRange().pop();\n              \
selection.setRangeStartOnly(instance._createCellCoords(currentFromRow + \
rowDelta, currentFromColumn), true);\n              \
selection.setRangeEnd(instance._createCellCoords(currentToRow + rowDelta, \
currentToColumn));\n            } else {\n              \
instance._refreshBorders();\n            }\n          }\n          break;\n   \
     case \"insert_col_start\":\n        case \"insert_col_end\":\n          \
const insertColumnMode = action === \"insert_col_end\" ? \"end\" : \
\"start\";\n          index2 = (_index2 = index2) !== null && _index2 !== \
void 0 ? _index2 : insertColumnMode === \"end\" ? instance.countSourceCols() \
: 0;\n          const {\n            delta: colDelta,\n            \
startPhysicalIndex: startColumnPhysicalIndex\n          } = \
datamap.createCol(index2, amount, {\n            source,\n            mode: \
insertColumnMode\n          });\n          if (colDelta) {\n            if \
(Array.isArray(tableMeta.colHeaders)) {\n              const spliceArray = \
[instance.toVisualColumn(startColumnPhysicalIndex), 0];\n              \
spliceArray.length += colDelta;\n              \
Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray);\n            \
}\n            const currentSelectedRange = \
selection.selectedRange.current();\n            const currentFromRange = \
currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : \
currentSelectedRange.from;\n            const currentFromColumn = \
currentFromRange === null || currentFromRange === void 0 ? void 0 : \
currentFromRange.col;\n            const startVisualColumnIndex = \
instance.toVisualColumn(startColumnPhysicalIndex);\n            if \
(selection.isSelectedByCorner()) {\n              instance.selectAll();\n     \
       } else if (isDefined(currentFromColumn) && currentFromColumn >= \
startVisualColumnIndex) {\n              const {\n                row: \
currentToRow,\n                col: currentToColumn\n              } = \
currentSelectedRange.to;\n              let currentFromRow = \
currentFromRange.row;\n              if \
(selection.isSelectedByColumnHeader()) {\n                currentFromRow = \
-1;\n              }\n              selection.getSelectedRange().pop();\n     \
         \
selection.setRangeStartOnly(instance._createCellCoords(currentFromRow, \
currentFromColumn + colDelta), true);\n              \
selection.setRangeEnd(instance._createCellCoords(currentToRow, \
currentToColumn + colDelta));\n            } else {\n              \
instance._refreshBorders();\n            }\n          }\n          break;\n   \
     case \"remove_row\":\n          const removeRow = (indexes) => {\n       \
     let offset3 = 0;\n            arrayEach(indexes, (_ref5) => {\n          \
    let [groupIndex, groupAmount] = _ref5;\n              const calcIndex = \
isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - \
offset3, 0);\n              if (Number.isInteger(groupIndex)) {\n             \
   groupIndex = Math.max(groupIndex - offset3, 0);\n              }\n         \
     const wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);\n \
             if (!wasRemoved) {\n                return;\n              }\n   \
           const totalRows = instance.countRows();\n              const \
fixedRowsTop = tableMeta.fixedRowsTop;\n              if (fixedRowsTop >= \
calcIndex + 1) {\n                tableMeta.fixedRowsTop -= \
Math.min(groupAmount, fixedRowsTop - calcIndex);\n              }\n           \
   const fixedRowsBottom = tableMeta.fixedRowsBottom;\n              if \
(fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {\n             \
   tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);\n     \
         }\n              offset3 += groupAmount;\n            });\n          \
};\n          if (Array.isArray(index2)) {\n            \
removeRow(normalizeIndexesGroup(index2));\n          } else {\n            \
removeRow([[index2, amount]]);\n          }\n          \
grid.adjustRowsAndCols();\n          instance._refreshBorders();\n          \
break;\n        case \"remove_col\":\n          const removeCol = (indexes) \
=> {\n            let offset3 = 0;\n            arrayEach(indexes, (_ref6) => \
{\n              let [groupIndex, groupAmount] = _ref6;\n              const \
calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : \
Math.max(groupIndex - offset3, 0);\n              let physicalColumnIndex = \
instance.toPhysicalColumn(calcIndex);\n              if \
(Number.isInteger(groupIndex)) {\n                groupIndex = \
Math.max(groupIndex - offset3, 0);\n              }\n              const \
wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);\n            \
  if (!wasRemoved) {\n                return;\n              }\n              \
const fixedColumnsStart = tableMeta.fixedColumnsStart;\n              if \
(fixedColumnsStart >= calcIndex + 1) {\n                \
tableMeta.fixedColumnsStart -= Math.min(groupAmount, fixedColumnsStart - \
calcIndex);\n              }\n              if \
(Array.isArray(tableMeta.colHeaders)) {\n                if (typeof \
physicalColumnIndex === \"undefined\") {\n                  \
physicalColumnIndex = -1;\n                }\n                \
tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);\n              \
}\n              offset3 += groupAmount;\n            });\n          };\n     \
     if (Array.isArray(index2)) {\n            \
removeCol(normalizeIndexesGroup(index2));\n          } else {\n            \
removeCol([[index2, amount]]);\n          }\n          \
grid.adjustRowsAndCols();\n          instance._refreshBorders();\n          \
break;\n        default:\n          throw new Error(`There is no such action \
\"${action}\"`);\n      }\n      if (!keepEmptyRows) {\n        \
grid.adjustRowsAndCols();\n      }\n    },\n    /**\n     * Makes sure there \
are empty rows at the bottom of the table.\n     *\n     * @private\n     \
*/\n    adjustRowsAndCols() {\n      const minRows = tableMeta.minRows;\n     \
 const minSpareRows = tableMeta.minSpareRows;\n      const minCols = \
tableMeta.minCols;\n      const minSpareCols = tableMeta.minSpareCols;\n      \
if (instance.countRows() === 0 && instance.countCols() === 0) {\n        \
selection.deselect();\n      }\n      if (minRows) {\n        const nrOfRows \
= instance.countRows();\n        if (nrOfRows < minRows) {\n          \
datamap.createRow(nrOfRows, minRows - nrOfRows, {\n            source: \
\"auto\"\n          });\n        }\n      }\n      if (minSpareRows) {\n      \
  const emptyRows = instance.countEmptyRows(true);\n        if (emptyRows < \
minSpareRows) {\n          const emptyRowsMissing = minSpareRows - \
emptyRows;\n          const rowsToCreate = Math.min(emptyRowsMissing, \
tableMeta.maxRows - instance.countSourceRows());\n          \
datamap.createRow(instance.countRows(), rowsToCreate, {\n            source: \
\"auto\"\n          });\n        }\n      }\n      {\n        let \
emptyCols;\n        if (minCols || minSpareCols) {\n          emptyCols = \
instance.countEmptyCols(true);\n        }\n        let nrOfColumns = \
instance.countCols();\n        if (minCols && !tableMeta.columns && \
nrOfColumns < minCols) {\n          const colsToCreate = minCols - \
nrOfColumns;\n          emptyCols += colsToCreate;\n          \
datamap.createCol(nrOfColumns, colsToCreate, {\n            source: \
\"auto\"\n          });\n        }\n        if (minSpareCols && \
!tableMeta.columns && instance.dataType === \"array\" && emptyCols < \
minSpareCols) {\n          nrOfColumns = instance.countCols();\n          \
const emptyColsMissing = minSpareCols - emptyCols;\n          const \
colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns);\n \
         datamap.createCol(nrOfColumns, colsToCreate, {\n            source: \
\"auto\"\n          });\n        }\n      }\n      if \
(selection.isSelected()) {\n        const rowCount = instance.countRows();\n  \
      const colCount = instance.countCols();\n        \
arrayEach(selection.selectedRange, (range) => {\n          let \
selectionChanged = false;\n          let fromRow = range.from.row;\n          \
let fromCol = range.from.col;\n          let toRow = range.to.row;\n          \
let toCol = range.to.col;\n          if (fromRow > rowCount - 1) {\n          \
  fromRow = rowCount - 1;\n            selectionChanged = true;\n            \
if (toRow > fromRow) {\n              toRow = fromRow;\n            }\n       \
   } else if (toRow > rowCount - 1) {\n            toRow = rowCount - 1;\n    \
        selectionChanged = true;\n            if (fromRow > toRow) {\n        \
      fromRow = toRow;\n            }\n          }\n          if (fromCol > \
colCount - 1) {\n            fromCol = colCount - 1;\n            \
selectionChanged = true;\n            if (toCol > fromCol) {\n              \
toCol = fromCol;\n            }\n          } else if (toCol > colCount - 1) \
{\n            toCol = colCount - 1;\n            selectionChanged = true;\n  \
          if (fromCol > toCol) {\n              fromCol = toCol;\n            \
}\n          }\n          if (selectionChanged) {\n            \
instance.selectCell(fromRow, fromCol, toRow, toCol);\n          }\n        \
});\n      }\n      if (instance.view) {\n        \
instance.view.adjustElementsSize();\n      }\n    },\n    /**\n     * \
Populate the data from the provided 2d array from the given cell \
coordinates.\n     *\n     * @private\n     * @param {object} start Start \
selection position. Visual indexes.\n     * @param {Array} input 2d data \
array.\n     * @param {object} [end] End selection position (only for \
drag-down mode). Visual indexes.\n     * @param {string} \
[source=\"populateFromArray\"] Source information string.\n     * @param \
{string} [method=\"overwrite\"] Populate method. Possible options: \
`shift_down`, `shift_right`, `overwrite`.\n     * @returns {object|undefined} \
Ending td in pasted area (only if any cell was changed).\n     */\n    \
populateFromArray(start, input, end, source, method) {\n      let r;\n      \
let rlen;\n      let c;\n      let clen;\n      const setData = [];\n      \
const current = {};\n      const newDataByColumns = [];\n      const startRow \
= start.row;\n      const startColumn = start.col;\n      rlen = \
input.length;\n      if (rlen === 0) {\n        return false;\n      }\n      \
let columnsPopulationEnd = 0;\n      let rowsPopulationEnd = 0;\n      if \
(isObject(end)) {\n        columnsPopulationEnd = end.col - startColumn + \
1;\n        rowsPopulationEnd = end.row - startRow + 1;\n      }\n      \
switch (method) {\n        case \"shift_down\":\n          const \
populatedDataByColumns = pivot(input);\n          const numberOfDataColumns = \
populatedDataByColumns.length;\n          const numberOfColumnsToPopulate = \
Math.max(numberOfDataColumns, columnsPopulationEnd);\n          const \
pushedDownDataByRows = instance.getData().slice(startRow);\n          const \
pushedDownDataByColumns = pivot(pushedDownDataByRows).slice(startColumn, \
startColumn + numberOfColumnsToPopulate);\n          for (c = 0; c < \
numberOfColumnsToPopulate; c += 1) {\n            if (c < \
numberOfDataColumns) {\n              for (r = 0, rlen = \
populatedDataByColumns[c].length; r < rowsPopulationEnd - rlen; r += 1) {\n   \
             populatedDataByColumns[c].push(populatedDataByColumns[c][r % \
rlen]);\n              }\n              if (c < \
pushedDownDataByColumns.length) {\n                \
newDataByColumns.push(populatedDataByColumns[c].concat(pushedDownDataByColumn\
s[c]));\n              } else {\n                \
newDataByColumns.push(populatedDataByColumns[c].concat(new \
Array(pushedDownDataByRows.length).fill(null)));\n              }\n           \
 } else {\n              newDataByColumns.push(populatedDataByColumns[c % \
numberOfDataColumns].concat(pushedDownDataByColumns[c]));\n            }\n    \
      }\n          instance.populateFromArray(startRow, startColumn, \
pivot(newDataByColumns));\n          break;\n        case \"shift_right\":\n  \
        const numberOfDataRows = input.length;\n          const \
numberOfRowsToPopulate = Math.max(numberOfDataRows, rowsPopulationEnd);\n     \
     const pushedRightDataByRows = \
instance.getData().slice(startRow).map((rowData) => \
rowData.slice(startColumn));\n          for (r = 0; r < \
numberOfRowsToPopulate; r += 1) {\n            if (r < numberOfDataRows) {\n  \
            for (c = 0, clen = input[r].length; c < columnsPopulationEnd - \
clen; c += 1) {\n                input[r].push(input[r][c % clen]);\n         \
     }\n              if (r < pushedRightDataByRows.length) {\n               \
 for (let i = 0; i < pushedRightDataByRows[r].length; i += 1) {\n             \
     input[r].push(pushedRightDataByRows[r][i]);\n                }\n         \
     } else {\n                input[r].push(...new \
Array(pushedRightDataByRows[0].length).fill(null));\n              }\n        \
    } else {\n              input.push(input[r % rlen].slice(0, \
numberOfRowsToPopulate).concat(pushedRightDataByRows[r]));\n            }\n   \
       }\n          instance.populateFromArray(startRow, startColumn, \
input);\n          break;\n        case \"overwrite\":\n        default:\n    \
      current.row = start.row;\n          current.col = start.col;\n          \
let skippedRow = 0;\n          let skippedColumn = 0;\n          let pushData \
= true;\n          let cellMeta;\n          const getInputValue = function \
getInputValue2(row) {\n            let col = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : null;\n            const rowValue = \
input[row % input.length];\n            if (col !== null) {\n              \
return rowValue[col % rowValue.length];\n            }\n            return \
rowValue;\n          };\n          const rowInputLength = input.length;\n     \
     const rowSelectionLength = end ? end.row - start.row + 1 : 0;\n          \
if (end) {\n            rlen = rowSelectionLength;\n          } else {\n      \
      rlen = Math.max(rowInputLength, rowSelectionLength);\n          }\n     \
     for (r = 0; r < rlen; r++) {\n            if (end && current.row > \
end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow \
&& current.row > instance.countRows() - 1 || current.row >= \
tableMeta.maxRows) {\n              break;\n            }\n            const \
visualRow = r - skippedRow;\n            const colInputLength = \
getInputValue(visualRow).length;\n            const colSelectionLength = end \
? end.col - start.col + 1 : 0;\n            if (end) {\n              clen = \
colSelectionLength;\n            } else {\n              clen = \
Math.max(colInputLength, colSelectionLength);\n            }\n            \
current.col = start.col;\n            cellMeta = \
instance.getCellMeta(current.row, current.col);\n            if ((source === \
\"CopyPaste.paste\" || source === \"Autofill.fill\") && \
cellMeta.skipRowOnPaste) {\n              skippedRow += 1;\n              \
current.row += 1;\n              rlen += 1;\n              continue;\n        \
    }\n            skippedColumn = 0;\n            for (c = 0; c < clen; c++) \
{\n              if (end && current.col > end.col && colSelectionLength > \
colInputLength || !tableMeta.allowInsertColumn && current.col > \
instance.countCols() - 1 || current.col >= tableMeta.maxCols) {\n             \
   break;\n              }\n              cellMeta = \
instance.getCellMeta(current.row, current.col);\n              if ((source \
=== \"CopyPaste.paste\" || source === \"Autofill.fill\") && \
cellMeta.skipColumnOnPaste) {\n                skippedColumn += 1;\n          \
      current.col += 1;\n                clen += 1;\n                \
continue;\n              }\n              if (cellMeta.readOnly && source !== \
\"UndoRedo.undo\") {\n                current.col += 1;\n                \
continue;\n              }\n              const visualColumn = c - \
skippedColumn;\n              let value = getInputValue(visualRow, \
visualColumn);\n              let orgValue = \
instance.getDataAtCell(current.row, current.col);\n              if (value \
!== null && typeof value === \"object\") {\n                if \
(Array.isArray(value) && orgValue === null)\n                  orgValue = \
[];\n                if (orgValue === null || typeof orgValue !== \"object\") \
{\n                  pushData = false;\n                } else {\n            \
      const orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : \
orgValue[0] || orgValue);\n                  const valueSchema = \
duckSchema(Array.isArray(value) ? value : value[0] || value);\n               \
   if (isObjectEqual(orgValueSchema, valueSchema) || \
Array.isArray(orgValueSchema) && Array.isArray(valueSchema)) {\n              \
      value = deepClone(value);\n                  } else {\n                 \
   pushData = false;\n                  }\n                }\n              } \
else if (orgValue !== null && typeof orgValue === \"object\") {\n             \
   pushData = false;\n              }\n              if (pushData) {\n        \
        setData.push([current.row, current.col, value]);\n              }\n   \
           pushData = true;\n              current.col += 1;\n            }\n \
           current.row += 1;\n          }\n          \
instance.setDataAtCell(setData, null, null, source || \
\"populateFromArray\");\n          break;\n      }\n    }\n  };\n  function \
setLanguage(languageCode) {\n    const normalizedLanguageCode = \
normalizeLanguageCode(languageCode);\n    if \
(hasLanguageDictionary(normalizedLanguageCode)) {\n      \
instance.runHooks(\"beforeLanguageChange\", normalizedLanguageCode);\n      \
globalMeta.language = normalizedLanguageCode;\n      \
instance.runHooks(\"afterLanguageChange\", normalizedLanguageCode);\n    } \
else {\n      warnUserAboutLanguageRegistration(languageCode);\n    }\n  }\n  \
function setClassName(className, classSettings) {\n    const element = \
className === \"className\" ? instance.rootElement : instance.table;\n    if \
(firstRun) {\n      addClass(element, classSettings);\n    } else {\n      \
let globalMetaSettingsArray = [];\n      let settingsArray = [];\n      if \
(globalMeta[className]) {\n        globalMetaSettingsArray = \
Array.isArray(globalMeta[className]) ? globalMeta[className] : \
stringToArray(globalMeta[className]);\n      }\n      if (classSettings) {\n  \
      settingsArray = Array.isArray(classSettings) ? classSettings : \
stringToArray(classSettings);\n      }\n      const classNameToRemove = \
getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);\n      const \
classNameToAdd = getDifferenceOfArrays(settingsArray, \
globalMetaSettingsArray);\n      if (classNameToRemove.length) {\n        \
removeClass(element, classNameToRemove);\n      }\n      if \
(classNameToAdd.length) {\n        addClass(element, classNameToAdd);\n      \
}\n    }\n    globalMeta[className] = classSettings;\n  }\n  this.init = \
function() {\n    dataSource.setData(tableMeta.data);\n    \
instance.runHooks(\"beforeInit\");\n    if (isMobileBrowser() || isIpadOS()) \
{\n      addClass(instance.rootElement, \"mobile\");\n    }\n    \
this.updateSettings(tableMeta, true);\n    this.view = new \
tableView_default(this);\n    editorManager = \
editorManager_default.getInstance(instance, tableMeta, selection);\n    \
instance.runHooks(\"init\");\n    this.forceFullRender = true;\n    \
this.view.render();\n    if (!!firstRun && instance.rootElement.offsetParent \
=== null) {\n      observeVisibilityChangeOnce(instance.rootElement, () => \
{\n        instance.view._wt.wtOverlays.updateLastSpreaderSize();\n        \
instance.render();\n        instance.view.adjustElementsSize();\n      });\n  \
  }\n    if (typeof firstRun === \"object\") {\n      \
instance.runHooks(\"afterChange\", firstRun[0], firstRun[1]);\n      firstRun \
= false;\n    }\n    instance.runHooks(\"afterInit\");\n  };\n  function \
ValidatorsQueue() {\n    let resolved = false;\n    return {\n      \
validatorsInQueue: 0,\n      valid: true,\n      addValidatorToQueue() {\n    \
    this.validatorsInQueue += 1;\n        resolved = false;\n      },\n      \
removeValidatorFormQueue() {\n        this.validatorsInQueue = \
this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        \
this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty() {\n      },\n     \
 checkIfQueueIsEmpty() {\n        if (this.validatorsInQueue === 0 && \
resolved === false) {\n          resolved = true;\n          \
this.onQueueEmpty(this.valid);\n        }\n      }\n    };\n  }\n  function \
getParsedNumber(numericData) {\n    const unifiedNumericData = \
numericData.replace(\",\", \".\");\n    if \
(isNaN(parseFloat(unifiedNumericData)) === false) {\n      return \
parseFloat(unifiedNumericData);\n    }\n    return numericData;\n  }\n  \
function validateChanges(changes, source, callback) {\n    if \
(!changes.length) {\n      return;\n    }\n    const activeEditor = \
instance.getActiveEditor();\n    const waitingForValidator = new \
ValidatorsQueue();\n    let shouldBeCanceled = true;\n    \
waitingForValidator.onQueueEmpty = (isValid) => {\n      if (activeEditor && \
shouldBeCanceled) {\n        activeEditor.cancelChanges();\n      }\n      \
callback(isValid);\n    };\n    for (let i = changes.length - 1; i >= 0; i--) \
{\n      const [row, prop, , newValue] = changes[i];\n      const col = \
datamap.propToCol(prop);\n      const cellProperties = \
instance.getCellMeta(row, col);\n      if (cellProperties.type === \
\"numeric\" && typeof newValue === \"string\" && isNumericLike(newValue)) {\n \
       changes[i][3] = getParsedNumber(newValue);\n      }\n      if \
(instance.getCellValidator(cellProperties)) {\n        \
waitingForValidator.addValidatorToQueue();\n        \
instance.validateCell(changes[i][3], cellProperties, function(index2, \
cellPropertiesReference) {\n          return function(result) {\n            \
if (typeof result !== \"boolean\") {\n              throw new \
Error(\"Validation error: result is not boolean\");\n            }\n          \
  if (result === false && cellPropertiesReference.allowInvalid === false) {\n \
             shouldBeCanceled = false;\n              changes.splice(index2, \
1);\n              cellPropertiesReference.valid = true;\n              const \
cell = instance.getCell(cellPropertiesReference.visualRow, \
cellPropertiesReference.visualCol);\n              if (cell !== null) {\n     \
           removeClass(cell, tableMeta.invalidCellClassName);\n              \
}\n            }\n            \
waitingForValidator.removeValidatorFormQueue();\n          };\n        }(i, \
cellProperties), source);\n      }\n    }\n    \
waitingForValidator.checkIfQueueIsEmpty();\n  }\n  function \
applyChanges(changes, source) {\n    let i = changes.length - 1;\n    if (i < \
0) {\n      return;\n    }\n    for (; i >= 0; i--) {\n      let \
skipThisChange = false;\n      if (changes[i] === null) {\n        \
changes.splice(i, 1);\n        continue;\n      }\n      if ((changes[i][2] \
=== null || changes[i][2] === void 0) && (changes[i][3] === null || \
changes[i][3] === void 0)) {\n        continue;\n      }\n      if \
(tableMeta.allowInsertRow) {\n        while (changes[i][0] > \
instance.countRows() - 1) {\n          const {\n            delta: \
numberOfCreatedRows\n          } = datamap.createRow(void 0, void 0, {\n      \
      source\n          });\n          if (numberOfCreatedRows === 0) {\n     \
       skipThisChange = true;\n            break;\n          }\n        }\n   \
   }\n      if (instance.dataType === \"array\" && (!tableMeta.columns || \
tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {\n        \
while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n       \
   const {\n            delta: numberOfCreatedColumns\n          } = \
datamap.createCol(void 0, void 0, {\n            source\n          });\n      \
    if (numberOfCreatedColumns === 0) {\n            skipThisChange = true;\n \
           break;\n          }\n        }\n      }\n      if (skipThisChange) \
{\n        continue;\n      }\n      datamap.set(changes[i][0], \
changes[i][1], changes[i][3]);\n    }\n    instance.forceFullRender = true;\n \
   grid.adjustRowsAndCols();\n    instance.runHooks(\"beforeChangeRender\", \
changes, source);\n    editorManager.lockEditor();\n    \
instance._refreshBorders(null);\n    editorManager.unlockEditor();\n    \
instance.view.adjustElementsSize();\n    instance.runHooks(\"afterChange\", \
changes, source || \"edit\");\n    const activeEditor = \
instance.getActiveEditor();\n    if (activeEditor && \
isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n \
   }\n  }\n  this._createCellCoords = function(row, column) {\n    return \
instance.view._wt.createCellCoords(row, column);\n  };\n  \
this._createCellRange = function(highlight, from, to) {\n    return \
instance.view._wt.createCellRange(highlight, from, to);\n  };\n  \
this.validateCell = function(value, cellProperties, callback, source) {\n    \
let validator = instance.getCellValidator(cellProperties);\n    function \
done(valid) {\n      let canBeValidated = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : true;\n      if (!canBeValidated || \
cellProperties.hidden === true) {\n        callback(valid);\n        \
return;\n      }\n      const col = cellProperties.visualCol;\n      const \
row = cellProperties.visualRow;\n      const td = instance.getCell(row, col, \
true);\n      if (td && td.nodeName !== \"TH\") {\n        const \
renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);\n  \
      const renderableColumn = \
instance.columnIndexMapper.getRenderableFromVisualIndex(col);\n        \
instance.view._wt.getSetting(\"cellRenderer\", renderableRow, \
renderableColumn, td);\n      }\n      callback(valid);\n    }\n    if \
(isRegExp(validator)) {\n      validator = function(expression) {\n        \
return function(cellValue, validatorCallback) {\n          \
validatorCallback(expression.test(cellValue));\n        };\n      \
}(validator);\n    }\n    if (isFunction(validator)) {\n      value = \
instance.runHooks(\"beforeValidate\", value, cellProperties.visualRow, \
cellProperties.prop, source);\n      instance._registerImmediate(() => {\n    \
    validator.call(cellProperties, value, (valid) => {\n          if \
(!instance) {\n            return;\n          }\n          valid = \
instance.runHooks(\"afterValidate\", valid, value, cellProperties.visualRow, \
cellProperties.prop, source);\n          cellProperties.valid = valid;\n      \
    done(valid);\n          instance.runHooks(\"postAfterValidate\", valid, \
value, cellProperties.visualRow, cellProperties.prop, source);\n        });\n \
     });\n    } else {\n      instance._registerImmediate(() => {\n        \
cellProperties.valid = true;\n        done(cellProperties.valid, false);\n    \
  });\n    }\n  };\n  function setDataInputToArray(row, propOrCol, value) {\n \
   if (Array.isArray(row)) {\n      return row;\n    }\n    return [[row, \
propOrCol, value]];\n  }\n  function processChanges(changes, source) {\n    \
const activeEditor = instance.getActiveEditor();\n    const \
beforeChangeResult = instance.runHooks(\"beforeChange\", changes, source || \
\"edit\");\n    const filteredChanges = changes.filter((change) => change !== \
null);\n    if (beforeChangeResult === false || filteredChanges.length === 0) \
{\n      if (activeEditor) {\n        activeEditor.cancelChanges();\n      \
}\n      return [];\n    }\n    return filteredChanges;\n  }\n  \
this.setDataAtCell = function(row, column, value, source) {\n    const input \
= setDataInputToArray(row, column, value);\n    const changes = [];\n    let \
changeSource = source;\n    let i;\n    let ilen;\n    let prop;\n    for (i \
= 0, ilen = input.length; i < ilen; i++) {\n      if (typeof input[i] !== \
\"object\") {\n        throw new Error(\"Method `setDataAtCell` accepts row \
number or changes array of arrays as its first parameter\");\n      }\n      \
if (typeof input[i][1] !== \"number\") {\n        throw new Error(\"Method \
`setDataAtCell` accepts row and column number as its parameters. If you want \
to use object property name, use method `setDataAtRowProp`\");\n      }\n     \
 if (input[i][1] >= this.countCols()) {\n        prop = input[i][1];\n      } \
else {\n        prop = datamap.colToProp(input[i][1]);\n      }\n      \
changes.push([input[i][0], prop, \
dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), \
input[i][2]]);\n    }\n    if (!changeSource && typeof row === \"object\") \
{\n      changeSource = column;\n    }\n    const processedChanges = \
processChanges(changes, source);\n    \
instance.runHooks(\"afterSetDataAtCell\", processedChanges, changeSource);\n  \
  validateChanges(processedChanges, changeSource, () => {\n      \
applyChanges(processedChanges, changeSource);\n    });\n  };\n  \
this.setDataAtRowProp = function(row, prop, value, source) {\n    const input \
= setDataInputToArray(row, prop, value);\n    const changes = [];\n    let \
changeSource = source;\n    let i;\n    let ilen;\n    for (i = 0, ilen = \
input.length; i < ilen; i++) {\n      changes.push([input[i][0], input[i][1], \
dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), \
input[i][2]]);\n    }\n    if (!changeSource && typeof row === \"object\") \
{\n      changeSource = prop;\n    }\n    const processedChanges = \
processChanges(changes, source);\n    \
instance.runHooks(\"afterSetDataAtRowProp\", processedChanges, \
changeSource);\n    validateChanges(processedChanges, changeSource, () => {\n \
     applyChanges(processedChanges, changeSource);\n    });\n  };\n  \
this.listen = function() {\n    if (instance && !instance.isListening()) {\n  \
    activeGuid = instance.guid;\n      instance.runHooks(\"afterListen\");\n  \
  }\n  };\n  this.unlisten = function() {\n    if (this.isListening()) {\n    \
  activeGuid = null;\n      instance.runHooks(\"afterUnlisten\");\n    }\n  \
};\n  this.isListening = function() {\n    return activeGuid === \
instance.guid;\n  };\n  this.destroyEditor = function() {\n    let \
revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : false;\n    let prepareEditorIfNeeded = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : true;\n    \
instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);\n  };\n  \
this.populateFromArray = function(row, column, input, endRow, endCol, source, \
method) {\n    if (!(typeof input === \"object\" && typeof input[0] === \
\"object\")) {\n      throw new Error(\"populateFromArray parameter `input` \
must be an array of arrays\");\n    }\n    const c = typeof endRow === \
\"number\" ? instance._createCellCoords(endRow, endCol) : null;\n    return \
grid.populateFromArray(instance._createCellCoords(row, column), input, c, \
source, method);\n  };\n  this.spliceCol = function(column, index2, amount) \
{\n    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len \
- 3 : 0), _key = 3; _key < _len; _key++) {\n      elements[_key - 3] = \
arguments[_key];\n    }\n    return datamap.spliceCol(column, index2, amount, \
...elements);\n  };\n  this.spliceRow = function(row, index2, amount) {\n    \
for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 \
: 0), _key2 = 3; _key2 < _len2; _key2++) {\n      elements[_key2 - 3] = \
arguments[_key2];\n    }\n    return datamap.spliceRow(row, index2, amount, \
...elements);\n  };\n  this.getSelected = function() {\n    if \
(selection.isSelected()) {\n      return \
arrayMap(selection.getSelectedRange(), (_ref7) => {\n        let {\n          \
from,\n          to\n        } = _ref7;\n        return [from.row, from.col, \
to.row, to.col];\n      });\n    }\n  };\n  this.getSelectedLast = function() \
{\n    const selected = this.getSelected();\n    let result;\n    if \
(selected && selected.length > 0) {\n      result = selected[selected.length \
- 1];\n    }\n    return result;\n  };\n  this.getSelectedRange = function() \
{\n    if (selection.isSelected()) {\n      return \
Array.from(selection.getSelectedRange());\n    }\n  };\n  \
this.getSelectedRangeLast = function() {\n    const selectedRange = \
this.getSelectedRange();\n    let result;\n    if (selectedRange && \
selectedRange.length > 0) {\n      result = \
selectedRange[selectedRange.length - 1];\n    }\n    return result;\n  };\n  \
this.emptySelectedCells = function(source) {\n    if (!selection.isSelected() \
|| this.countRows() === 0 || this.countCols() === 0) {\n      return;\n    \
}\n    const changes = [];\n    arrayEach(selection.getSelectedRange(), \
(cellRange) => {\n      const topStart = cellRange.getTopStartCorner();\n     \
 const bottomEnd = cellRange.getBottomEndCorner();\n      \
rangeEach(topStart.row, bottomEnd.row, (row) => {\n        \
rangeEach(topStart.col, bottomEnd.col, (column) => {\n          if \
(!this.getCellMeta(row, column).readOnly) {\n            changes.push([row, \
column, null]);\n          }\n        });\n      });\n    });\n    if \
(changes.length > 0) {\n      this.setDataAtCell(changes, source);\n    }\n  \
};\n  this.isRenderSuspended = function() {\n    return \
this.renderSuspendedCounter > 0;\n  };\n  this.suspendRender = function() {\n \
   this.renderSuspendedCounter += 1;\n  };\n  this.resumeRender = function() \
{\n    const nextValue = this.renderSuspendedCounter - 1;\n    \
this.renderSuspendedCounter = Math.max(nextValue, 0);\n    if \
(!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {\n  \
    if (this.renderCall) {\n        this.render();\n      } else {\n        \
this._refreshBorders(null);\n      }\n    }\n  };\n  this.render = function() \
{\n    if (this.view) {\n      this.renderCall = true;\n      \
this.forceFullRender = true;\n      if (!this.isRenderSuspended()) {\n        \
editorManager.lockEditor();\n        this._refreshBorders(null);\n        \
editorManager.unlockEditor();\n      }\n    }\n  };\n  this.batchRender = \
function(wrappedOperations) {\n    this.suspendRender();\n    const result = \
wrappedOperations();\n    this.resumeRender();\n    return result;\n  };\n  \
this.isExecutionSuspended = function() {\n    return \
this.executionSuspendedCounter > 0;\n  };\n  this.suspendExecution = \
function() {\n    this.executionSuspendedCounter += 1;\n    \
this.columnIndexMapper.suspendOperations();\n    \
this.rowIndexMapper.suspendOperations();\n  };\n  this.resumeExecution = \
function() {\n    let forceFlushChanges = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : false;\n    const nextValue = \
this.executionSuspendedCounter - 1;\n    this.executionSuspendedCounter = \
Math.max(nextValue, 0);\n    if (!this.isExecutionSuspended() && nextValue \
=== this.executionSuspendedCounter || forceFlushChanges) {\n      \
this.columnIndexMapper.resumeOperations();\n      \
this.rowIndexMapper.resumeOperations();\n    }\n  };\n  this.batchExecution = \
function(wrappedOperations) {\n    let forceFlushChanges = arguments.length > \
1 && arguments[1] !== void 0 ? arguments[1] : false;\n    \
this.suspendExecution();\n    const result = wrappedOperations();\n    \
this.resumeExecution(forceFlushChanges);\n    return result;\n  };\n  \
this.batch = function(wrappedOperations) {\n    this.suspendRender();\n    \
this.suspendExecution();\n    const result = wrappedOperations();\n    \
this.resumeExecution();\n    this.resumeRender();\n    return result;\n  };\n \
 this.refreshDimensions = function() {\n    if (!instance.view) {\n      \
return;\n    }\n    const {\n      width: lastWidth,\n      height: \
lastHeight\n    } = instance.view.getLastSize();\n    const {\n      width,\n \
     height\n    } = instance.rootElement.getBoundingClientRect();\n    const \
isSizeChanged = width !== lastWidth || height !== lastHeight;\n    const \
isResizeBlocked = instance.runHooks(\"beforeRefreshDimensions\", {\n      \
width: lastWidth,\n      height: lastHeight\n    }, {\n      width,\n      \
height\n    }, isSizeChanged) === false;\n    if (isResizeBlocked) {\n      \
return;\n    }\n    if (isSizeChanged || \
instance.view._wt.wtOverlays.scrollableElement === instance.rootWindow) {\n   \
   instance.view.setLastSize(width, height);\n      instance.render();\n    \
}\n    instance.runHooks(\"afterRefreshDimensions\", {\n      width: \
lastWidth,\n      height: lastHeight\n    }, {\n      width,\n      height\n  \
  }, isSizeChanged);\n  };\n  this.updateData = function(data2, source) {\n   \
 replaceData(data2, (newDataMap) => {\n      datamap = newDataMap;\n    }, \
(newDataMap) => {\n      datamap = newDataMap;\n      \
instance.columnIndexMapper.fitToLength(this.getInitialColumnCount());\n      \
instance.rowIndexMapper.fitToLength(this.countSourceRows());\n      \
grid.adjustRowsAndCols();\n    }, {\n      hotInstance: instance,\n      \
dataMap: datamap,\n      dataSource,\n      internalSource: \"updateData\",\n \
     source,\n      metaManager,\n      firstRun\n    });\n  };\n  \
this.loadData = function(data2, source) {\n    replaceData(data2, \
(newDataMap) => {\n      datamap = newDataMap;\n    }, () => {\n      \
metaManager.clearCellsCache();\n      instance.initIndexMappers();\n      \
grid.adjustRowsAndCols();\n      if (firstRun) {\n        firstRun = [null, \
\"loadData\"];\n      }\n    }, {\n      hotInstance: instance,\n      \
dataMap: datamap,\n      dataSource,\n      internalSource: \"loadData\",\n   \
   source,\n      metaManager,\n      firstRun\n    });\n  };\n  \
this.getInitialColumnCount = function() {\n    const columnsSettings = \
tableMeta.columns;\n    let finalNrOfColumns = 0;\n    if \
(Array.isArray(columnsSettings)) {\n      finalNrOfColumns = \
columnsSettings.length;\n    } else if (isFunction(columnsSettings)) {\n      \
if (instance.dataType === \"array\") {\n        const nrOfSourceColumns = \
this.countSourceCols();\n        for (let columnIndex = 0; columnIndex < \
nrOfSourceColumns; columnIndex += 1) {\n          if \
(columnsSettings(columnIndex)) {\n            finalNrOfColumns += 1;\n        \
  }\n        }\n      } else if (instance.dataType === \"object\" || \
instance.dataType === \"function\") {\n        finalNrOfColumns = \
datamap.colToPropCache.length;\n      }\n    } else if \
(isDefined(tableMeta.dataSchema)) {\n      const schema = \
datamap.getSchema();\n      finalNrOfColumns = Array.isArray(schema) ? \
schema.length : deepObjectSize(schema);\n    } else {\n      finalNrOfColumns \
= this.countSourceCols();\n    }\n    return finalNrOfColumns;\n  };\n  \
this.initIndexMappers = function() {\n    \
this.columnIndexMapper.initToLength(this.getInitialColumnCount());\n    \
this.rowIndexMapper.initToLength(this.countSourceRows());\n  };\n  \
this.getData = function(row, column, row2, column2) {\n    if \
(isUndefined(row)) {\n      return datamap.getAll();\n    }\n    return \
datamap.getRange(instance._createCellCoords(row, column), \
instance._createCellCoords(row2, column2), datamap.DESTINATION_RENDERER);\n  \
};\n  this.getCopyableText = function(startRow, startCol, endRow, endCol) {\n \
   return datamap.getCopyableText(instance._createCellCoords(startRow, \
startCol), instance._createCellCoords(endRow, endCol));\n  };\n  \
this.getCopyableData = function(row, column) {\n    return \
datamap.getCopyable(row, datamap.colToProp(column));\n  };\n  this.getSchema \
= function() {\n    return datamap.getSchema();\n  };\n  this.updateSettings \
= function(settings) {\n    let init = arguments.length > 1 && arguments[1] \
!== void 0 ? arguments[1] : false;\n    const dataUpdateFunction = (firstRun \
? instance.loadData : instance.updateData).bind(this);\n    let columnsAsFunc \
= false;\n    let i;\n    let j;\n    if (isDefined(settings.rows)) {\n      \
throw new Error('The \"rows\" setting is no longer supported. Do you mean \
startRows, minRows or maxRows?');\n    }\n    if (isDefined(settings.cols)) \
{\n      throw new Error('The \"cols\" setting is no longer supported. Do you \
mean startCols, minCols or maxCols?');\n    }\n    if \
(isDefined(settings.ganttChart)) {\n      throw new Error('Since 8.0.0 the \
\"ganttChart\" setting is no longer supported.');\n    }\n    for (i in \
settings) {\n      if (i === \"data\") {\n      } else if (i === \
\"language\") {\n        setLanguage(settings.language);\n      } else if (i \
=== \"className\") {\n        setClassName(\"className\", \
settings.className);\n      } else if (i === \"tableClassName\" && \
instance.table) {\n        setClassName(\"tableClassName\", \
settings.tableClassName);\n        \
instance.view._wt.wtOverlays.syncOverlayTableClassNames();\n      } else if \
(pluginHooks_default.getSingleton().isRegistered(i) || \
pluginHooks_default.getSingleton().isDeprecated(i)) {\n        if \
(isFunction(settings[i]) || Array.isArray(settings[i])) {\n          \
settings[i].initialHook = true;\n          instance.addHook(i, \
settings[i]);\n        }\n      } else if (!init && hasOwnProperty(settings, \
i)) {\n        globalMeta[i] = settings[i];\n      }\n    }\n    if \
(settings.data === void 0 && tableMeta.data === void 0) {\n      \
dataUpdateFunction(null, \"updateSettings\");\n    } else if (settings.data \
!== void 0) {\n      dataUpdateFunction(settings.data, \"updateSettings\");\n \
   } else if (settings.columns !== void 0) {\n      datamap.createMap();\n    \
  instance.initIndexMappers();\n    }\n    const clen = \
instance.countCols();\n    const columnSetting = tableMeta.columns;\n    if \
(columnSetting && isFunction(columnSetting)) {\n      columnsAsFunc = true;\n \
   }\n    if (settings.cell !== void 0 || settings.cells !== void 0 || \
settings.columns !== void 0) {\n      metaManager.clearCache();\n    }\n    \
if (clen > 0) {\n      for (i = 0, j = 0; i < clen; i++) {\n        if \
(columnSetting) {\n          const column = columnsAsFunc ? columnSetting(i) \
: columnSetting[j];\n          if (column) {\n            \
metaManager.updateColumnMeta(j, column);\n          }\n        }\n        j \
+= 1;\n      }\n    }\n    if (isDefined(settings.cell)) {\n      \
objectEach(settings.cell, (cell) => {\n        \
instance.setCellMetaObject(cell.row, cell.col, cell);\n      });\n    }\n    \
instance.runHooks(\"afterCellMetaReset\");\n    let currentHeight = \
instance.rootElement.style.height;\n    if (currentHeight !== \"\") {\n      \
currentHeight = parseInt(instance.rootElement.style.height, 10);\n    }\n    \
let height = settings.height;\n    if (isFunction(height)) {\n      height = \
height();\n    }\n    if (init) {\n      const initialStyle = \
instance.rootElement.getAttribute(\"style\");\n      if (initialStyle) {\n    \
    instance.rootElement.setAttribute(\"data-initialstyle\", \
instance.rootElement.getAttribute(\"style\"));\n      }\n    }\n    if \
(height === null) {\n      const initialStyle = \
instance.rootElement.getAttribute(\"data-initialstyle\");\n      if \
(initialStyle && (initialStyle.indexOf(\"height\") > -1 || \
initialStyle.indexOf(\"overflow\") > -1)) {\n        \
instance.rootElement.setAttribute(\"style\", initialStyle);\n      } else {\n \
       instance.rootElement.style.height = \"\";\n        \
instance.rootElement.style.overflow = \"\";\n      }\n    } else if (height \
!== void 0) {\n      instance.rootElement.style.height = isNaN(height) ? \
`${height}` : `${height}px`;\n      instance.rootElement.style.overflow = \
\"hidden\";\n    }\n    if (typeof settings.width !== \"undefined\") {\n      \
let width = settings.width;\n      if (isFunction(width)) {\n        width = \
width();\n      }\n      instance.rootElement.style.width = isNaN(width) ? \
`${width}` : `${width}px`;\n    }\n    if (!init) {\n      if (instance.view) \
{\n        \
instance.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n        \
instance.view._wt.exportSettingsAsClassNames();\n      }\n      \
instance.runHooks(\"afterUpdateSettings\", settings);\n    }\n    \
grid.adjustRowsAndCols();\n    if (instance.view && !firstRun) {\n      \
instance.forceFullRender = true;\n      editorManager.lockEditor();\n      \
instance._refreshBorders(null);\n      \
instance.view._wt.wtOverlays.adjustElementsSize();\n      \
editorManager.unlockEditor();\n    }\n    if (!init && instance.view && \
(currentHeight === \"\" || height === \"\" || height === void 0) && \
currentHeight !== height) {\n      \
instance.view._wt.wtOverlays.updateMainScrollableElements();\n    }\n  };\n  \
this.getValue = function() {\n    const sel = instance.getSelectedLast();\n   \
 if (tableMeta.getValue) {\n      if (isFunction(tableMeta.getValue)) {\n     \
   return tableMeta.getValue.call(instance);\n      } else if (sel) {\n       \
 return instance.getData()[sel[0][0]][tableMeta.getValue];\n      }\n    } \
else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    \
}\n  };\n  this.getSettings = function() {\n    return tableMeta;\n  };\n  \
this.clear = function() {\n    this.selectAll();\n    \
this.emptySelectedCells();\n  };\n  this.alter = function(action, index2, \
amount, source, keepEmptyRows) {\n    grid.alter(action, index2, amount, \
source, keepEmptyRows);\n  };\n  this.getCell = function(row, column) {\n    \
let topmost = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] \
: false;\n    let renderableColumnIndex = column;\n    let renderableRowIndex \
= row;\n    if (column >= 0) {\n      if \
(this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {\n        \
return null;\n      }\n      renderableColumnIndex = \
this.columnIndexMapper.getRenderableFromVisualIndex(column);\n    }\n    if \
(row >= 0) {\n      if \
(this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {\n        return \
null;\n      }\n      renderableRowIndex = \
this.rowIndexMapper.getRenderableFromVisualIndex(row);\n    }\n    if \
(renderableRowIndex === null || renderableColumnIndex === null) {\n      \
return null;\n    }\n    return \
instance.view.getCellAtCoords(instance._createCellCoords(renderableRowIndex, \
renderableColumnIndex), topmost);\n  };\n  this.getCoords = function(element) \
{\n    const renderableCoords = this.view._wt.wtTable.getCoords(element);\n   \
 if (renderableCoords === null) {\n      return null;\n    }\n    const {\n   \
   row: renderableRow,\n      col: renderableColumn\n    } = \
renderableCoords;\n    let visualRow = renderableRow;\n    let visualColumn = \
renderableColumn;\n    if (renderableRow >= 0) {\n      visualRow = \
this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);\n    }\n    \
if (renderableColumn >= 0) {\n      visualColumn = \
this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);\n    \
}\n    return instance._createCellCoords(visualRow, visualColumn);\n  };\n  \
this.colToProp = function(column) {\n    return datamap.colToProp(column);\n  \
};\n  this.propToCol = function(prop) {\n    return \
datamap.propToCol(prop);\n  };\n  this.toVisualRow = (row) => \
this.rowIndexMapper.getVisualFromPhysicalIndex(row);\n  this.toVisualColumn = \
(column) => this.columnIndexMapper.getVisualFromPhysicalIndex(column);\n  \
this.toPhysicalRow = (row) => \
this.rowIndexMapper.getPhysicalFromVisualIndex(row);\n  this.toPhysicalColumn \
= (column) => this.columnIndexMapper.getPhysicalFromVisualIndex(column);\n  \
this.getDataAtCell = function(row, column) {\n    return datamap.get(row, \
datamap.colToProp(column));\n  };\n  this.getDataAtRowProp = function(row, \
prop) {\n    return datamap.get(row, prop);\n  };\n  this.getDataAtCol = \
function(column) {\n    const columnData = [];\n    const dataByRows = \
datamap.getRange(instance._createCellCoords(0, column), \
instance._createCellCoords(tableMeta.data.length - 1, column), \
datamap.DESTINATION_RENDERER);\n    for (let i = 0; i < dataByRows.length; i \
+= 1) {\n      for (let j = 0; j < dataByRows[i].length; j += 1) {\n        \
columnData.push(dataByRows[i][j]);\n      }\n    }\n    return columnData;\n  \
};\n  this.getDataAtProp = function(prop) {\n    const columnData = [];\n    \
const dataByRows = datamap.getRange(instance._createCellCoords(0, \
datamap.propToCol(prop)), instance._createCellCoords(tableMeta.data.length - \
1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);\n    for (let i = \
0; i < dataByRows.length; i += 1) {\n      for (let j = 0; j < \
dataByRows[i].length; j += 1) {\n        columnData.push(dataByRows[i][j]);\n \
     }\n    }\n    return columnData;\n  };\n  this.getSourceData = \
function(row, column, row2, column2) {\n    let data2;\n    if (row === void \
0) {\n      data2 = dataSource.getData();\n    } else {\n      data2 = \
dataSource.getByRange(instance._createCellCoords(row, column), \
instance._createCellCoords(row2, column2));\n    }\n    return data2;\n  };\n \
 this.getSourceDataArray = function(row, column, row2, column2) {\n    let \
data2;\n    if (row === void 0) {\n      data2 = dataSource.getData(true);\n  \
  } else {\n      data2 = \
dataSource.getByRange(instance._createCellCoords(row, column), \
instance._createCellCoords(row2, column2), true);\n    }\n    return data2;\n \
 };\n  this.getSourceDataAtCol = function(column) {\n    return \
dataSource.getAtColumn(column);\n  };\n  this.setSourceDataAtCell = \
function(row, column, value, source) {\n    const input = \
setDataInputToArray(row, column, value);\n    const \
isThereAnySetSourceListener = this.hasHook(\"afterSetSourceDataAtCell\");\n   \
 const changesForHook = [];\n    if (isThereAnySetSourceListener) {\n      \
arrayEach(input, (_ref8) => {\n        let [changeRow, changeProp, \
changeValue] = _ref8;\n        changesForHook.push([\n          changeRow,\n  \
        changeProp,\n          dataSource.getAtCell(changeRow, changeProp),\n \
         // The previous value.\n          changeValue\n        ]);\n      \
});\n    }\n    arrayEach(input, (_ref9) => {\n      let [changeRow, \
changeProp, changeValue] = _ref9;\n      dataSource.setAtCell(changeRow, \
changeProp, changeValue);\n    });\n    if (isThereAnySetSourceListener) {\n  \
    this.runHooks(\"afterSetSourceDataAtCell\", changesForHook, source);\n    \
}\n    this.render();\n    const activeEditor = instance.getActiveEditor();\n \
   if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      \
activeEditor.refreshValue();\n    }\n  };\n  this.getSourceDataAtRow = \
function(row) {\n    return dataSource.getAtRow(row);\n  };\n  \
this.getSourceDataAtCell = function(row, column) {\n    return \
dataSource.getAtCell(row, column);\n  };\n  this.getDataAtRow = function(row) \
{\n    const data2 = datamap.getRange(instance._createCellCoords(row, 0), \
instance._createCellCoords(row, this.countCols() - 1), \
datamap.DESTINATION_RENDERER);\n    return data2[0] || [];\n  };\n  \
this.getDataType = function(rowFrom, columnFrom, rowTo, columnTo) {\n    \
const coords = rowFrom === void 0 ? [0, 0, this.countRows(), \
this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];\n    const \
[rowStart, columnStart] = coords;\n    let [, , rowEnd, columnEnd] = \
coords;\n    let previousType = null;\n    let currentType = null;\n    if \
(rowEnd === void 0) {\n      rowEnd = rowStart;\n    }\n    if (columnEnd === \
void 0) {\n      columnEnd = columnStart;\n    }\n    let type = \"mixed\";\n \
   rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, \
rowEnd), (row) => {\n      let isTypeEqual = true;\n      \
rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), \
Math.max(columnStart, columnEnd), (column) => {\n        const cellType = \
this.getCellMeta(row, column);\n        currentType = cellType.type;\n        \
if (previousType) {\n          isTypeEqual = previousType === currentType;\n  \
      } else {\n          previousType = currentType;\n        }\n        \
return isTypeEqual;\n      });\n      type = isTypeEqual ? currentType : \
\"mixed\";\n      return isTypeEqual;\n    });\n    return type;\n  };\n  \
this.removeCellMeta = function(row, column, key) {\n    const [physicalRow, \
physicalColumn] = [this.toPhysicalRow(row), this.toPhysicalColumn(column)];\n \
   let cachedValue = metaManager.getCellMetaKeyValue(physicalRow, \
physicalColumn, key);\n    const hookResult = \
instance.runHooks(\"beforeRemoveCellMeta\", row, column, key, cachedValue);\n \
   if (hookResult !== false) {\n      metaManager.removeCellMeta(physicalRow, \
physicalColumn, key);\n      instance.runHooks(\"afterRemoveCellMeta\", row, \
column, key, cachedValue);\n    }\n    cachedValue = null;\n  };\n  \
this.spliceCellsMeta = function(visualIndex) {\n    let deleteAmount = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    for \
(var _len3 = arguments.length, cellMetaRows = new Array(_len3 > 2 ? _len3 - 2 \
: 0), _key3 = 2; _key3 < _len3; _key3++) {\n      cellMetaRows[_key3 - 2] = \
arguments[_key3];\n    }\n    if (cellMetaRows.length > 0 && \
!Array.isArray(cellMetaRows[0])) {\n      throw new Error(\"The 3rd argument \
(cellMetaRows) has to be passed as an array of cell meta objects array.\");\n \
   }\n    if (deleteAmount > 0) {\n      \
metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);\n    \
}\n    if (cellMetaRows.length > 0) {\n      \
arrayEach(cellMetaRows.reverse(), (cellMetaRow) => {\n        \
metaManager.createRow(this.toPhysicalRow(visualIndex));\n        \
arrayEach(cellMetaRow, (cellMeta, columnIndex) => \
this.setCellMetaObject(visualIndex, columnIndex, cellMeta));\n      });\n    \
}\n    instance.render();\n  };\n  this.setCellMetaObject = function(row, \
column, prop) {\n    if (typeof prop === \"object\") {\n      \
objectEach(prop, (value, key) => {\n        this.setCellMeta(row, column, \
key, value);\n      });\n    }\n  };\n  this.setCellMeta = function(row, \
column, key, value) {\n    const allowSetCellMeta = \
instance.runHooks(\"beforeSetCellMeta\", row, column, key, value);\n    if \
(allowSetCellMeta === false) {\n      return;\n    }\n    let physicalRow = \
row;\n    let physicalColumn = column;\n    if (row < this.countRows()) {\n   \
   physicalRow = this.toPhysicalRow(row);\n    }\n    if (column < \
this.countCols()) {\n      physicalColumn = this.toPhysicalColumn(column);\n  \
  }\n    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);\n  \
  instance.runHooks(\"afterSetCellMeta\", row, column, key, value);\n  };\n  \
this.getCellsMeta = function() {\n    return metaManager.getCellsMeta();\n  \
};\n  this.getCellMeta = function(row, column) {\n    let physicalRow = \
this.toPhysicalRow(row);\n    let physicalColumn = \
this.toPhysicalColumn(column);\n    if (physicalRow === null) {\n      \
physicalRow = row;\n    }\n    if (physicalColumn === null) {\n      \
physicalColumn = column;\n    }\n    return \
metaManager.getCellMeta(physicalRow, physicalColumn, {\n      visualRow: \
row,\n      visualColumn: column\n    });\n  };\n  this.getCellMetaAtRow = \
function(row) {\n    return metaManager.getCellsMetaAtRow(row);\n  };\n  \
this.isColumnModificationAllowed = function() {\n    return \
!(instance.dataType === \"object\" || tableMeta.columns);\n  };\n  \
this.getCellRenderer = function(rowOrMeta, column) {\n    const cellRenderer \
= typeof rowOrMeta === \"number\" ? instance.getCellMeta(rowOrMeta, \
column).renderer : rowOrMeta.renderer;\n    if (typeof cellRenderer === \
\"string\") {\n      return _getItem2(cellRenderer);\n    }\n    return \
isUndefined(cellRenderer) ? _getItem2(\"text\") : cellRenderer;\n  };\n  \
this.getCellEditor = function(rowOrMeta, column) {\n    const cellEditor = \
typeof rowOrMeta === \"number\" ? instance.getCellMeta(rowOrMeta, \
column).editor : rowOrMeta.editor;\n    if (typeof cellEditor === \"string\") \
{\n      return _getItem(cellEditor);\n    }\n    return \
isUndefined(cellEditor) ? _getItem(\"text\") : cellEditor;\n  };\n  \
this.getCellValidator = function(rowOrMeta, column) {\n    const \
cellValidator = typeof rowOrMeta === \"number\" ? \
instance.getCellMeta(rowOrMeta, column).validator : rowOrMeta.validator;\n    \
if (typeof cellValidator === \"string\") {\n      return \
_getItem3(cellValidator);\n    }\n    return cellValidator;\n  };\n  \
this.validateCells = function(callback) {\n    \
this._validateCells(callback);\n  };\n  this.validateRows = function(rows, \
callback) {\n    if (!Array.isArray(rows)) {\n      throw new \
Error(\"validateRows parameter `rows` must be an array\");\n    }\n    \
this._validateCells(callback, rows);\n  };\n  this.validateColumns = \
function(columns, callback) {\n    if (!Array.isArray(columns)) {\n      \
throw new Error(\"validateColumns parameter `columns` must be an array\");\n  \
  }\n    this._validateCells(callback, void 0, columns);\n  };\n  \
this._validateCells = function(callback, rows, columns) {\n    const \
waitingForValidator = new ValidatorsQueue();\n    if (callback) {\n      \
waitingForValidator.onQueueEmpty = callback;\n    }\n    let i = \
instance.countRows() - 1;\n    while (i >= 0) {\n      if (rows !== void 0 && \
rows.indexOf(i) === -1) {\n        i -= 1;\n        continue;\n      }\n      \
let j = instance.countCols() - 1;\n      while (j >= 0) {\n        if \
(columns !== void 0 && columns.indexOf(j) === -1) {\n          j -= 1;\n      \
    continue;\n        }\n        \
waitingForValidator.addValidatorToQueue();\n        \
instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, \
j), (result) => {\n          if (typeof result !== \"boolean\") {\n           \
 throw new Error(\"Validation error: result is not boolean\");\n          }\n \
         if (result === false) {\n            waitingForValidator.valid = \
false;\n          }\n          \
waitingForValidator.removeValidatorFormQueue();\n        }, \
\"validateCells\");\n        j -= 1;\n      }\n      i -= 1;\n    }\n    \
waitingForValidator.checkIfQueueIsEmpty();\n  };\n  this.getRowHeader = \
function(row) {\n    let rowHeader = tableMeta.rowHeaders;\n    let \
physicalRow = row;\n    if (physicalRow !== void 0) {\n      physicalRow = \
instance.runHooks(\"modifyRowHeader\", physicalRow);\n    }\n    if \
(physicalRow === void 0) {\n      rowHeader = [];\n      \
rangeEach(instance.countRows() - 1, (i) => {\n        \
rowHeader.push(instance.getRowHeader(i));\n      });\n    } else if \
(Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {\n      \
rowHeader = rowHeader[physicalRow];\n    } else if (isFunction(rowHeader)) \
{\n      rowHeader = rowHeader(physicalRow);\n    } else if (rowHeader && \
typeof rowHeader !== \"string\" && typeof rowHeader !== \"number\") {\n      \
rowHeader = physicalRow + 1;\n    }\n    return rowHeader;\n  };\n  \
this.hasRowHeaders = function() {\n    return !!tableMeta.rowHeaders;\n  };\n \
 this.hasColHeaders = function() {\n    if (tableMeta.colHeaders !== void 0 \
&& tableMeta.colHeaders !== null) {\n      return !!tableMeta.colHeaders;\n   \
 }\n    for (let i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      \
if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n    \
return false;\n  };\n  this.getColHeader = function(column) {\n    let \
headerLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] \
: -1;\n    const columnIndex = instance.runHooks(\"modifyColHeader\", \
column);\n    if (columnIndex === void 0) {\n      const out = [];\n      \
const ilen = instance.countCols();\n      for (let i = 0; i < ilen; i++) {\n  \
      out.push(instance.getColHeader(i));\n      }\n      return out;\n    \
}\n    let result = tableMeta.colHeaders;\n    const \
translateVisualIndexToColumns = function(visualColumnIndex) {\n      const \
arr = [];\n      const columnsLen = instance.countCols();\n      let index2 = \
0;\n      for (; index2 < columnsLen; index2++) {\n        if \
(isFunction(tableMeta.columns) && tableMeta.columns(index2)) {\n          \
arr.push(index2);\n        }\n      }\n      return arr[visualColumnIndex];\n \
   };\n    const physicalColumn = instance.toPhysicalColumn(columnIndex);\n   \
 const prop = translateVisualIndexToColumns(physicalColumn);\n    if \
(tableMeta.colHeaders === false) {\n      result = null;\n    } else if \
(tableMeta.columns && isFunction(tableMeta.columns) && \
tableMeta.columns(prop) && tableMeta.columns(prop).title) {\n      result = \
tableMeta.columns(prop).title;\n    } else if (tableMeta.columns && \
tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) \
{\n      result = tableMeta.columns[physicalColumn].title;\n    } else if \
(Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] \
!== void 0) {\n      result = tableMeta.colHeaders[physicalColumn];\n    } \
else if (isFunction(tableMeta.colHeaders)) {\n      result = \
tableMeta.colHeaders(physicalColumn);\n    } else if (tableMeta.colHeaders && \
typeof tableMeta.colHeaders !== \"string\" && typeof tableMeta.colHeaders !== \
\"number\") {\n      result = spreadsheetColumnLabel(columnIndex);\n    }\n   \
 result = instance.runHooks(\"modifyColumnHeaderValue\", result, column, \
headerLevel);\n    return result;\n  };\n  this._getColWidthFromSettings = \
function(col) {\n    let width;\n    if (col >= 0) {\n      const \
cellProperties = instance.getCellMeta(0, col);\n      width = \
cellProperties.width;\n    }\n    if (width === void 0 || width === \
tableMeta.width) {\n      width = tableMeta.colWidths;\n    }\n    if (width \
!== void 0 && width !== null) {\n      switch (typeof width) {\n        case \
\"object\":\n          width = width[col];\n          break;\n        case \
\"function\":\n          width = width(col);\n          break;\n        \
default:\n          break;\n      }\n      if (typeof width === \"string\") \
{\n        width = parseInt(width, 10);\n      }\n    }\n    return width;\n  \
};\n  this.getColWidth = function(column) {\n    let width = \
instance._getColWidthFromSettings(column);\n    width = \
instance.runHooks(\"modifyColWidth\", width, column);\n    if (width === void \
0) {\n      width = viewportColumns_default.DEFAULT_WIDTH;\n    }\n    return \
width;\n  };\n  this._getRowHeightFromSettings = function(row) {\n    let \
height = tableMeta.rowHeights;\n    if (height !== void 0 && height !== null) \
{\n      switch (typeof height) {\n        case \"object\":\n          height \
= height[row];\n          break;\n        case \"function\":\n          \
height = height(row);\n          break;\n        default:\n          break;\n \
     }\n      if (typeof height === \"string\") {\n        height = \
parseInt(height, 10);\n      }\n    }\n    return height;\n  };\n  \
this.getRowHeight = function(row) {\n    let height = \
instance._getRowHeightFromSettings(row);\n    height = \
instance.runHooks(\"modifyRowHeight\", height, row);\n    return height;\n  \
};\n  this.countSourceRows = function() {\n    return \
dataSource.countRows();\n  };\n  this.countSourceCols = function() {\n    \
return dataSource.countFirstRowKeys();\n  };\n  this.countRows = function() \
{\n    return datamap.getLength();\n  };\n  this.countCols = function() {\n   \
 const maxCols = tableMeta.maxCols;\n    const dataLen = \
this.columnIndexMapper.getNotTrimmedIndexesLength();\n    return \
Math.min(maxCols, dataLen);\n  };\n  this.countRenderedRows = function() {\n  \
  return instance.view._wt.drawn ? \
instance.view._wt.wtTable.getRenderedRowsCount() : -1;\n  };\n  \
this.countVisibleRows = function() {\n    return instance.view._wt.drawn ? \
instance.view._wt.wtTable.getVisibleRowsCount() : -1;\n  };\n  \
this.countRenderedCols = function() {\n    return instance.view._wt.drawn ? \
instance.view._wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n  \
this.countVisibleCols = function() {\n    return instance.view._wt.drawn ? \
instance.view._wt.wtTable.getVisibleColumnsCount() : -1;\n  };\n  \
this.countEmptyRows = function() {\n    let ending = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : false;\n    let emptyRows = 0;\n    \
rangeEachReverse(instance.countRows() - 1, (visualIndex) => {\n      if \
(instance.isEmptyRow(visualIndex)) {\n        emptyRows += 1;\n      } else \
if (ending === true) {\n        return false;\n      }\n    });\n    return \
emptyRows;\n  };\n  this.countEmptyCols = function() {\n    let ending = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    \
let emptyColumns = 0;\n    rangeEachReverse(instance.countCols() - 1, \
(visualIndex) => {\n      if (instance.isEmptyCol(visualIndex)) {\n        \
emptyColumns += 1;\n      } else if (ending === true) {\n        return \
false;\n      }\n    });\n    return emptyColumns;\n  };\n  this.isEmptyRow = \
function(row) {\n    return tableMeta.isEmptyRow.call(instance, row);\n  };\n \
 this.isEmptyCol = function(column) {\n    return \
tableMeta.isEmptyCol.call(instance, column);\n  };\n  this.selectCell = \
function(row, column, endRow, endColumn) {\n    let scrollToCell = \
arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    \
let changeListener = arguments.length > 5 && arguments[5] !== void 0 ? \
arguments[5] : true;\n    if (isUndefined(row) || isUndefined(column)) {\n    \
  return false;\n    }\n    return this.selectCells([[row, column, endRow, \
endColumn]], scrollToCell, changeListener);\n  };\n  this.selectCells = \
function() {\n    let coords = arguments.length > 0 && arguments[0] !== void \
0 ? arguments[0] : [[]];\n    let scrollToCell = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : true;\n    let changeListener = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    \
if (scrollToCell === false) {\n      preventScrollingToCell = true;\n    }\n  \
  const wasSelected = selection.selectCells(coords);\n    if (wasSelected && \
changeListener) {\n      instance.listen();\n    }\n    \
preventScrollingToCell = false;\n    return wasSelected;\n  };\n  \
this.selectColumns = function(startColumn) {\n    let endColumn = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
startColumn;\n    return selection.selectColumns(startColumn, endColumn);\n  \
};\n  this.selectRows = function(startRow) {\n    let endRow = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startRow;\n  \
  return selection.selectRows(startRow, endRow);\n  };\n  this.deselectCell = \
function() {\n    selection.deselect();\n  };\n  this.selectAll = function() \
{\n    let includeHeaders = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : true;\n    const includeRowHeaders = includeHeaders && \
this.hasRowHeaders();\n    const includeColumnHeaders = includeHeaders && \
this.hasColHeaders();\n    preventScrollingToCell = true;\n    \
selection.selectAll(includeRowHeaders, includeColumnHeaders);\n    \
preventScrollingToCell = false;\n  };\n  const getIndexToScroll = \
(indexMapper, visualIndex) => {\n    return \
indexMapper.getNearestNotHiddenIndex(visualIndex, 1, true);\n  };\n  \
this.scrollViewportTo = function(row, column) {\n    let snapToBottom = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    \
let snapToRight = arguments.length > 3 && arguments[3] !== void 0 ? \
arguments[3] : false;\n    let considerHiddenIndexes = arguments.length > 4 \
&& arguments[4] !== void 0 ? arguments[4] : true;\n    const snapToTop = \
!snapToBottom;\n    const snapToLeft = !snapToRight;\n    let renderableRow = \
row;\n    let renderableColumn = column;\n    if (considerHiddenIndexes) {\n  \
    const isRowInteger2 = Number.isInteger(row);\n      const \
isColumnInteger2 = Number.isInteger(column);\n      const visualRowToScroll = \
isRowInteger2 ? getIndexToScroll(this.rowIndexMapper, row) : void 0;\n      \
const visualColumnToScroll = isColumnInteger2 ? \
getIndexToScroll(this.columnIndexMapper, column) : void 0;\n      if \
(visualRowToScroll === null || visualColumnToScroll === null) {\n        \
return false;\n      }\n      renderableRow = isRowInteger2 ? \
instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : \
void 0;\n      renderableColumn = isColumnInteger2 ? \
instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) \
: void 0;\n    }\n    const isRowInteger = Number.isInteger(renderableRow);\n \
   const isColumnInteger = Number.isInteger(renderableColumn);\n    if \
(isRowInteger && isColumnInteger) {\n      return \
instance.view.scrollViewport(instance._createCellCoords(renderableRow, \
renderableColumn), snapToTop, snapToRight, snapToBottom, snapToLeft);\n    \
}\n    if (isRowInteger && isColumnInteger === false) {\n      return \
instance.view.scrollViewportVertically(renderableRow, snapToTop, \
snapToBottom);\n    }\n    if (isColumnInteger && isRowInteger === false) {\n \
     return instance.view.scrollViewportHorizontally(renderableColumn, \
snapToRight, snapToLeft);\n    }\n    return false;\n  };\n  this.destroy = \
function() {\n    instance._clearTimeouts();\n    \
instance._clearImmediates();\n    if (instance.view) {\n      \
instance.view.destroy();\n    }\n    if (dataSource) {\n      \
dataSource.destroy();\n    }\n    dataSource = null;\n    \
this.getShortcutManager().destroy();\n    metaManager.clearCache();\n    if \
(isRootInstance(instance)) {\n      const licenseInfo = \
this.rootDocument.querySelector(\".hot-display-license-info\");\n      if \
(licenseInfo) {\n        licenseInfo.parentNode.removeChild(licenseInfo);\n   \
   }\n    }\n    empty(instance.rootElement);\n    eventManager.destroy();\n  \
  if (editorManager) {\n      editorManager.destroy();\n    }\n    \
instance.batchExecution(() => {\n      \
instance.rowIndexMapper.unregisterAll();\n      \
instance.columnIndexMapper.unregisterAll();\n      \
pluginsRegistry.getItems().forEach((_ref10) => {\n        let [, plugin] = \
_ref10;\n        plugin.destroy();\n      });\n      \
pluginsRegistry.clear();\n      instance.runHooks(\"afterDestroy\");\n    }, \
true);\n    pluginHooks_default.getSingleton().destroy(instance);\n    \
objectEach(instance, (property, key, obj) => {\n      if \
(isFunction(property)) {\n        obj[key] = postMortem(key);\n      } else \
if (key !== \"guid\") {\n        obj[key] = null;\n      }\n    });\n    \
instance.isDestroyed = true;\n    if (datamap) {\n      datamap.destroy();\n  \
  }\n    datamap = null;\n    grid = null;\n    selection = null;\n    \
editorManager = null;\n    instance = null;\n  };\n  function \
postMortem(method) {\n    return () => {\n      throw new Error(`The \
\"${method}\" method cannot be called because this Handsontable instance has \
been destroyed`);\n    };\n  }\n  this.getActiveEditor = function() {\n    \
return editorManager.getActiveEditor();\n  };\n  this.getPlugin = \
function(pluginName) {\n    const unifiedPluginName = \
toUpperCaseFirst(pluginName);\n    if (unifiedPluginName === \"UndoRedo\") \
{\n      return this.undoRedo;\n    }\n    return \
pluginsRegistry.getItem(unifiedPluginName);\n  };\n  this.getPluginName = \
function(plugin) {\n    if (plugin === this.undoRedo) {\n      return \
this.undoRedo.constructor.PLUGIN_KEY;\n    }\n    return \
pluginsRegistry.getId(plugin);\n  };\n  this.getInstance = function() {\n    \
return instance;\n  };\n  this.addHook = function(key, callback) {\n    \
pluginHooks_default.getSingleton().add(key, callback, instance);\n  };\n  \
this.hasHook = function(key) {\n    return \
pluginHooks_default.getSingleton().has(key, instance) || \
pluginHooks_default.getSingleton().has(key);\n  };\n  this.addHookOnce = \
function(key, callback) {\n    pluginHooks_default.getSingleton().once(key, \
callback, instance);\n  };\n  this.removeHook = function(key, callback) {\n   \
 pluginHooks_default.getSingleton().remove(key, callback, instance);\n  };\n  \
this.runHooks = function(key, p1, p2, p3, p4, p5, p6) {\n    return \
pluginHooks_default.getSingleton().run(instance, key, p1, p2, p3, p4, p5, \
p6);\n  };\n  this.getTranslatedPhrase = function(dictionaryKey, \
extraArguments) {\n    return getTranslatedPhrase(tableMeta.language, \
dictionaryKey, extraArguments);\n  };\n  this.toHTML = () => \
instanceToHTML(this);\n  this.toTableElement = () => {\n    const tempElement \
= this.rootDocument.createElement(\"div\");\n    \
tempElement.insertAdjacentHTML(\"afterbegin\", instanceToHTML(this));\n    \
return tempElement.firstElementChild;\n  };\n  this.timeouts = [];\n  \
this._registerTimeout = function(handle) {\n    let delay = arguments.length \
> 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    let handleFunc = \
handle;\n    if (typeof handleFunc === \"function\") {\n      handleFunc = \
setTimeout(handleFunc, delay);\n    }\n    this.timeouts.push(handleFunc);\n  \
};\n  this._clearTimeouts = function() {\n    arrayEach(this.timeouts, \
(handler) => {\n      clearTimeout(handler);\n    });\n  };\n  \
this.immediates = [];\n  this._registerImmediate = function(callback) {\n    \
this.immediates.push(setImmediate(callback));\n  };\n  this._clearImmediates \
= function() {\n    arrayEach(this.immediates, (handler) => {\n      \
clearImmediate(handler);\n    });\n  };\n  this._refreshBorders = function() \
{\n    let revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : false;\n    let prepareEditorIfNeeded = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : true;\n    \
editorManager.destroyEditor(revertOriginal);\n    instance.view.render();\n   \
 if (prepareEditorIfNeeded && selection.isSelected()) {\n      \
editorManager.prepareEditor();\n    }\n  };\n  this.isRtl = function() {\n    \
return instance.rootWindow.getComputedStyle(instance.rootElement).direction \
=== \"rtl\";\n  };\n  this.isLtr = function() {\n    return \
!instance.isRtl();\n  };\n  this.getDirectionFactor = function() {\n    \
return instance.isLtr() ? 1 : -1;\n  };\n  const shortcutManager = \
createShortcutManager({\n    handleEvent(event2) {\n      const isListening = \
instance.isListening();\n      const isKeyboardEventWithKey = (event2 === \
null || event2 === void 0 ? void 0 : event2.key) !== void 0;\n      return \
isListening && isKeyboardEventWithKey;\n    },\n    beforeKeyDown: (event2) \
=> {\n      return this.runHooks(\"beforeKeyDown\", event2);\n    },\n    \
afterKeyDown: (event2) => {\n      if (this.isDestroyed) {\n        return;\n \
     }\n      instance.runHooks(\"afterDocumentKeyDown\", event2);\n    },\n  \
  ownerWindow: this.rootWindow\n  });\n  \
this.addHook(\"beforeOnCellMouseDown\", (event2) => {\n    if (event2.ctrlKey \
=== false && event2.metaKey === false) {\n      \
shortcutManager.releasePressedKeys();\n    }\n  });\n  \
this.getShortcutManager = function() {\n    return shortcutManager;\n  };\n  \
const gridContext = shortcutManager.addContext(\"grid\");\n  const gridConfig \
= {\n    runOnlyIf: () => {\n      return isDefined(instance.getSelected()) \
&& instance.countRenderedRows() > 0 && instance.countRenderedCols() > 0;\n    \
},\n    group: SHORTCUTS_GROUP\n  };\n  \
shortcutManager.setActiveContextName(\"grid\");\n  \
gridContext.addShortcuts([{\n    keys: [[\"Control/Meta\", \"A\"]],\n    \
callback: () => {\n      instance.selectAll();\n    }\n  }, {\n    keys: \
[[\"Control/Meta\", \"Enter\"]],\n    callback: () => {\n      const \
selectedRange = instance.getSelectedRange();\n      const {\n        row: \
highlightRow,\n        col: highlightColumn\n      } = \
selectedRange[selectedRange.length - 1].highlight;\n      const \
valueToPopulate = instance.getDataAtCell(highlightRow, highlightColumn);\n    \
  const cellValues = /* @__PURE__ */ new Map();\n      for (let i = 0; i < \
selectedRange.length; i++) {\n        selectedRange[i].forAll((row, column) \
=> {\n          if (row >= 0 && column >= 0 && (row !== highlightRow || \
column !== highlightColumn)) {\n            const {\n              readOnly\n \
           } = instance.getCellMeta(row, column);\n            if (!readOnly) \
{\n              cellValues.set(`${row}x${column}`, [row, column, \
valueToPopulate]);\n            }\n          }\n        });\n      }\n      \
instance.setDataAtCell(Array.from(cellValues.values()));\n    },\n    \
runOnlyIf: () => instance.getSelectedRangeLast().getCellsCount() > 1\n  }, \
{\n    keys: [[\"ArrowUp\"]],\n    callback: () => {\n      \
selection.transformStart(-1, 0);\n    }\n  }, {\n    keys: [[\"ArrowUp\", \
\"Control/Meta\"]],\n    captureCtrl: true,\n    callback: () => {\n      \
selection.setRangeStart(instance._createCellCoords(instance.rowIndexMapper.ge\
tNearestNotHiddenIndex(0, 1), \
instance.getSelectedRangeLast().highlight.col));\n    }\n  }, {\n    keys: \
[[\"ArrowUp\", \"Shift\"]],\n    callback: () => {\n      \
selection.transformEnd(-1, 0);\n    }\n  }, {\n    keys: [[\"ArrowUp\", \
\"Shift\", \"Control/Meta\"]],\n    captureCtrl: true,\n    callback: () => \
{\n      const {\n        from,\n        to\n      } = \
instance.getSelectedRangeLast();\n      const row = \
instance.rowIndexMapper.getNearestNotHiddenIndex(0, 1);\n      \
selection.setRangeStart(from.clone());\n      \
selection.setRangeEnd(instance._createCellCoords(row, to.col));\n    },\n    \
runOnlyIf: () => !(instance.selection.isSelectedByCorner() || \
instance.selection.isSelectedByColumnHeader())\n  }, {\n    keys: \
[[\"ArrowDown\"]],\n    callback: () => {\n      selection.transformStart(1, \
0);\n    }\n  }, {\n    keys: [[\"ArrowDown\", \"Control/Meta\"]],\n    \
captureCtrl: true,\n    callback: () => {\n      \
selection.setRangeStart(instance._createCellCoords(instance.rowIndexMapper.ge\
tNearestNotHiddenIndex(instance.countRows() - 1, -1), \
instance.getSelectedRangeLast().highlight.col));\n    }\n  }, {\n    keys: \
[[\"ArrowDown\", \"Shift\"]],\n    callback: () => {\n      \
selection.transformEnd(1, 0);\n    }\n  }, {\n    keys: [[\"ArrowDown\", \
\"Shift\", \"Control/Meta\"]],\n    captureCtrl: true,\n    callback: () => \
{\n      const {\n        from,\n        to\n      } = \
instance.getSelectedRangeLast();\n      const row = \
instance.rowIndexMapper.getNearestNotHiddenIndex(instance.countRows() - 1, \
-1);\n      selection.setRangeStart(from.clone());\n      \
selection.setRangeEnd(instance._createCellCoords(row, to.col));\n    },\n    \
runOnlyIf: () => !(instance.selection.isSelectedByCorner() || \
instance.selection.isSelectedByColumnHeader())\n  }, {\n    keys: \
[[\"ArrowLeft\"]],\n    callback: () => {\n      selection.transformStart(0, \
-1 * instance.getDirectionFactor());\n    }\n  }, {\n    keys: \
[[\"ArrowLeft\", \"Control/Meta\"]],\n    captureCtrl: true,\n    callback: \
() => {\n      const row = instance.getSelectedRangeLast().highlight.row;\n   \
   const column = \
instance.columnIndexMapper.getNearestNotHiddenIndex(...instance.isRtl() ? \
[instance.countCols() - 1, -1] : [0, 1]);\n      \
selection.setRangeStart(instance._createCellCoords(row, column));\n    }\n  \
}, {\n    keys: [[\"ArrowLeft\", \"Shift\"]],\n    callback: () => {\n      \
selection.transformEnd(0, -1 * instance.getDirectionFactor());\n    }\n  }, \
{\n    keys: [[\"ArrowLeft\", \"Shift\", \"Control/Meta\"]],\n    \
captureCtrl: true,\n    callback: () => {\n      const {\n        from,\n     \
   to\n      } = instance.getSelectedRangeLast();\n      const column = \
instance.columnIndexMapper.getNearestNotHiddenIndex(...instance.isRtl() ? \
[instance.countCols() - 1, -1] : [0, 1]);\n      \
selection.setRangeStart(from.clone());\n      \
selection.setRangeEnd(instance._createCellCoords(to.row, column));\n    },\n  \
  runOnlyIf: () => !(instance.selection.isSelectedByCorner() || \
instance.selection.isSelectedByRowHeader())\n  }, {\n    keys: \
[[\"ArrowRight\"]],\n    callback: () => {\n      selection.transformStart(0, \
instance.getDirectionFactor());\n    }\n  }, {\n    keys: [[\"ArrowRight\", \
\"Control/Meta\"]],\n    captureCtrl: true,\n    callback: () => {\n      \
const row = instance.getSelectedRangeLast().highlight.row;\n      const \
column = \
instance.columnIndexMapper.getNearestNotHiddenIndex(...instance.isRtl() ? [0, \
1] : [instance.countCols() - 1, -1]);\n      \
selection.setRangeStart(instance._createCellCoords(row, column));\n    }\n  \
}, {\n    keys: [[\"ArrowRight\", \"Shift\"]],\n    callback: () => {\n      \
selection.transformEnd(0, instance.getDirectionFactor());\n    }\n  }, {\n    \
keys: [[\"ArrowRight\", \"Shift\", \"Control/Meta\"]],\n    captureCtrl: \
true,\n    callback: () => {\n      const {\n        from,\n        to\n      \
} = instance.getSelectedRangeLast();\n      const column = \
instance.columnIndexMapper.getNearestNotHiddenIndex(...instance.isRtl() ? [0, \
1] : [instance.countCols() - 1, -1]);\n      \
selection.setRangeStart(from.clone());\n      \
selection.setRangeEnd(instance._createCellCoords(to.row, column));\n    },\n  \
  runOnlyIf: () => !(instance.selection.isSelectedByCorner() || \
instance.selection.isSelectedByRowHeader())\n  }, {\n    keys: \
[[\"Home\"]],\n    captureCtrl: true,\n    callback: () => {\n      const \
fixedColumns = parseInt(instance.getSettings().fixedColumnsStart, 10);\n      \
const row = instance.getSelectedRangeLast().highlight.row;\n      const \
column = instance.columnIndexMapper.getNearestNotHiddenIndex(fixedColumns, \
1);\n      selection.setRangeStart(instance._createCellCoords(row, \
column));\n    },\n    runOnlyIf: () => \
instance.view.isMainTableNotFullyCoveredByOverlays()\n  }, {\n    keys: \
[[\"Home\", \"Shift\"]],\n    callback: () => {\n      \
selection.setRangeEnd(instance._createCellCoords(selection.selectedRange.curr\
ent().from.row, instance.columnIndexMapper.getNearestNotHiddenIndex(0, \
1)));\n    }\n  }, {\n    keys: [[\"Home\", \"Control/Meta\"]],\n    \
captureCtrl: true,\n    callback: () => {\n      const fixedRows = \
parseInt(instance.getSettings().fixedRowsTop, 10);\n      const fixedColumns \
= parseInt(instance.getSettings().fixedColumnsStart, 10);\n      const row = \
instance.rowIndexMapper.getNearestNotHiddenIndex(fixedRows, 1);\n      const \
column = instance.columnIndexMapper.getNearestNotHiddenIndex(fixedColumns, \
1);\n      selection.setRangeStart(instance._createCellCoords(row, \
column));\n    },\n    runOnlyIf: () => \
instance.view.isMainTableNotFullyCoveredByOverlays()\n  }, {\n    keys: \
[[\"End\"]],\n    captureCtrl: true,\n    callback: () => {\n      \
selection.setRangeStart(instance._createCellCoords(instance.getSelectedRangeL\
ast().highlight.row, \
instance.columnIndexMapper.getNearestNotHiddenIndex(instance.countCols() - 1, \
-1)));\n    },\n    runOnlyIf: () => \
instance.view.isMainTableNotFullyCoveredByOverlays()\n  }, {\n    keys: \
[[\"End\", \"Shift\"]],\n    callback: () => {\n      \
selection.setRangeEnd(instance._createCellCoords(selection.selectedRange.curr\
ent().from.row, \
instance.columnIndexMapper.getNearestNotHiddenIndex(instance.countCols() - 1, \
-1)));\n    }\n  }, {\n    keys: [[\"End\", \"Control/Meta\"]],\n    \
captureCtrl: true,\n    callback: () => {\n      const fixedRows = \
parseInt(instance.getSettings().fixedRowsBottom, 10);\n      const row = \
instance.rowIndexMapper.getNearestNotHiddenIndex(instance.countRows() - \
fixedRows - 1, -1);\n      const column = \
instance.columnIndexMapper.getNearestNotHiddenIndex(instance.countCols() - 1, \
-1);\n      selection.setRangeStart(instance._createCellCoords(row, \
column));\n    },\n    runOnlyIf: () => \
instance.view.isMainTableNotFullyCoveredByOverlays()\n  }, {\n    keys: \
[[\"PageUp\"]],\n    callback: () => {\n      \
selection.transformStart(-instance.countVisibleRows(), 0);\n    }\n  }, {\n   \
 keys: [[\"PageUp\", \"Shift\"]],\n    callback: () => {\n      const {\n     \
   to\n      } = instance.getSelectedRangeLast();\n      const \
nextRowIndexToSelect = Math.max(to.row - instance.countVisibleRows(), 0);\n   \
   const row = \
instance.rowIndexMapper.getNearestNotHiddenIndex(nextRowIndexToSelect, 1);\n  \
    if (row !== null) {\n        const coords = \
instance._createCellCoords(row, to.col);\n        const scrollPadding = \
to.row - instance.view.getFirstFullyVisibleRow();\n        const \
nextVerticalScroll = Math.max(coords.row - scrollPadding, 0);\n        \
selection.setRangeEnd(coords);\n        \
instance.scrollViewportTo(nextVerticalScroll);\n      }\n    }\n  }, {\n    \
keys: [[\"PageDown\"]],\n    callback: () => {\n      \
selection.transformStart(instance.countVisibleRows(), 0);\n    }\n  }, {\n    \
keys: [[\"PageDown\", \"Shift\"]],\n    callback: () => {\n      const {\n    \
    to\n      } = instance.getSelectedRangeLast();\n      const \
nextRowIndexToSelect = Math.min(to.row + instance.countVisibleRows(), \
instance.countRows() - 1);\n      const row = \
instance.rowIndexMapper.getNearestNotHiddenIndex(nextRowIndexToSelect, -1);\n \
     if (row !== null) {\n        const coords = \
instance._createCellCoords(row, to.col);\n        const scrollPadding = \
to.row - instance.view.getFirstFullyVisibleRow();\n        const \
nextVerticalScroll = Math.min(coords.row - scrollPadding, \
instance.countRows() - 1);\n        selection.setRangeEnd(coords);\n        \
instance.scrollViewportTo(nextVerticalScroll);\n      }\n    }\n  }, {\n    \
keys: [[\"Tab\"]],\n    callback: (event2) => {\n      const tabMoves = \
typeof tableMeta.tabMoves === \"function\" ? tableMeta.tabMoves(event2) : \
tableMeta.tabMoves;\n      selection.transformStart(tabMoves.row, \
tabMoves.col, true);\n    }\n  }, {\n    keys: [[\"Shift\", \"Tab\"]],\n    \
callback: (event2) => {\n      const tabMoves = typeof tableMeta.tabMoves === \
\"function\" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;\n      \
selection.transformStart(-tabMoves.row, -tabMoves.col);\n    }\n  }], \
gridConfig);\n  getPluginsNames().forEach((pluginName) => {\n    const \
PluginClass = getPlugin(pluginName);\n    pluginsRegistry.addItem(pluginName, \
new PluginClass(this));\n  });\n  \
pluginHooks_default.getSingleton().run(instance, \"construct\");\n}\n\n// \
node_modules/handsontable/mixins/hooksRefRegisterer.mjs\nvar MIXIN_NAME7 = \
\"hooksRefRegisterer\";\nvar hooksRefRegisterer = {\n  /**\n   * Internal \
hooks storage.\n   */\n  _hooksStorage: /* @__PURE__ */ \
Object.create(null),\n  /**\n   * Add hook to the collection.\n   *\n   * \
@param {string} key The hook name.\n   * @param {Function} callback The hook \
callback.\n   * @returns {object}\n   */\n  addHook(key, callback) {\n    if \
(!this._hooksStorage[key]) {\n      this._hooksStorage[key] = [];\n    }\n    \
this.hot.addHook(key, callback);\n    \
this._hooksStorage[key].push(callback);\n    return this;\n  },\n  /**\n   * \
Remove all hooks listeners by hook name.\n   *\n   * @param {string} key The \
hook name.\n   */\n  removeHooksByKey(key) {\n    \
arrayEach(this._hooksStorage[key] || [], (callback) => {\n      \
this.hot.removeHook(key, callback);\n    });\n  },\n  /**\n   * Clear all \
added hooks.\n   */\n  clearHooks() {\n    objectEach(this._hooksStorage, \
(callbacks, name) => this.removeHooksByKey(name));\n    this._hooksStorage = \
{};\n  }\n};\ndefineGetter(hooksRefRegisterer, \"MIXIN_NAME\", MIXIN_NAME7, \
{\n  writable: false,\n  enumerable: false\n});\nvar \
hooksRefRegisterer_default = hooksRefRegisterer;\n\n// \
node_modules/handsontable/editors/baseEditor/baseEditor.mjs\nvar EDITOR_TYPE \
= \"base\";\nvar EDITOR_STATE = Object.freeze({\n  VIRGIN: \
\"STATE_VIRGIN\",\n  // before editing\n  EDITING: \"STATE_EDITING\",\n  \
WAITING: \"STATE_WAITING\",\n  // waiting for async validation\n  FINISHED: \
\"STATE_FINISHED\"\n});\nvar SHORTCUTS_GROUP_EDITOR2 = \"baseEditor\";\nvar \
BaseEditor = class {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n \
 }\n  /**\n   * @param {Handsontable} instance A reference to the source \
instance of the Handsontable.\n   */\n  constructor(instance) {\n    this.hot \
= instance;\n    this.instance = instance;\n    this.state = \
EDITOR_STATE.VIRGIN;\n    this._opened = false;\n    this._fullEditMode = \
false;\n    this._closeCallback = null;\n    this.TD = null;\n    this.row = \
null;\n    this.col = null;\n    this.prop = null;\n    this.originalValue = \
null;\n    this.cellProperties = null;\n    this.init();\n  }\n  /**\n   * \
Fires callback after closing editor.\n   *\n   * @private\n   * @param \
{boolean} result The editor value.\n   */\n  _fireCallbacks(result) {\n    if \
(this._closeCallback) {\n      this._closeCallback(result);\n      \
this._closeCallback = null;\n    }\n  }\n  /**\n   * Initializes an editor's \
intance.\n   */\n  init() {\n  }\n  /**\n   * Required method to get current \
value from editable element.\n   */\n  getValue() {\n    throw Error(\"Editor \
getValue() method unimplemented\");\n  }\n  /**\n   * Required method to set \
new value into editable element.\n   */\n  setValue() {\n    throw \
Error(\"Editor setValue() method unimplemented\");\n  }\n  /**\n   * Required \
method to open editor.\n   */\n  open() {\n    throw Error(\"Editor open() \
method unimplemented\");\n  }\n  /**\n   * Required method to close editor.\n \
  */\n  close() {\n    throw Error(\"Editor close() method \
unimplemented\");\n  }\n  /**\n   * Prepares editor's meta data.\n   *\n   * \
@param {number} row The visual row index.\n   * @param {number} col The \
visual column index.\n   * @param {number|string} prop The column property \
(passed when datasource is an array of objects).\n   * @param \
{HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value \
The rendered value.\n   * @param {object} cellProperties The cell meta object \
({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, \
cellProperties) {\n    this.TD = td;\n    this.row = row;\n    this.col = \
col;\n    this.prop = prop;\n    this.originalValue = value;\n    \
this.cellProperties = cellProperties;\n    this.state = \
EDITOR_STATE.VIRGIN;\n  }\n  /**\n   * Fallback method to provide extendable \
editors in ES5.\n   *\n   * @returns {Function}\n   */\n  extend() {\n    \
return class Editor extends this.constructor {\n    };\n  }\n  /**\n   * \
Saves value from editor into data storage.\n   *\n   * @param {*} value The \
editor value.\n   * @param {boolean} ctrlDown If `true`, applies value to \
each cell in the last selected range.\n   */\n  saveValue(value, ctrlDown) \
{\n    let visualRowFrom;\n    let visualColumnFrom;\n    let visualRowTo;\n  \
  let visualColumnTo;\n    if (ctrlDown) {\n      const selectedLast = \
this.hot.getSelectedLast();\n      visualRowFrom = \
Math.max(Math.min(selectedLast[0], selectedLast[2]), 0);\n      \
visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0);\n \
     visualRowTo = Math.max(selectedLast[0], selectedLast[2]);\n      \
visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);\n    } else {\n  \
    [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = \
[this.row, this.col, null, null];\n    }\n    const modifiedCellCoords = \
this.hot.runHooks(\"modifyGetCellCoords\", visualRowFrom, \
visualColumnFrom);\n    if (Array.isArray(modifiedCellCoords)) {\n      \
[visualRowFrom, visualColumnFrom] = modifiedCellCoords;\n    }\n    const \
shortcutManager = this.hot.getShortcutManager();\n    const editorContext = \
shortcutManager.getContext(\"editor\");\n    const contextConfig = {\n      \
runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: \
SHORTCUTS_GROUP_EDITOR2\n    };\n    if (this.isInFullEditMode()) {\n      \
editorContext.addShortcuts([{\n        keys: [[\"ArrowUp\"]],\n        \
callback: () => {\n          this.hot.selection.transformStart(-1, 0);\n      \
  }\n      }, {\n        keys: [[\"ArrowDown\"]],\n        callback: () => \
{\n          this.hot.selection.transformStart(1, 0);\n        }\n      }, \
{\n        keys: [[\"ArrowLeft\"]],\n        callback: () => {\n          \
this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());\n   \
     }\n      }, {\n        keys: [[\"ArrowRight\"]],\n        callback: () \
=> {\n          this.hot.selection.transformStart(0, \
this.hot.getDirectionFactor());\n        }\n      }], contextConfig);\n    \
}\n    this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, \
visualRowTo, visualColumnTo, \"edit\");\n  }\n  /**\n   * Begins editing on a \
highlighted cell and hides fillHandle corner if was present.\n   *\n   * \
@param {*} newInitialValue The initial editor value.\n   * @param {Event} \
event The keyboard event object.\n   */\n  beginEditing(newInitialValue, \
event2) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    \
}\n    const hotInstance = this.hot;\n    const renderableRowIndex = \
hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const \
renderableColumnIndex = \
hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    \
hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIn\
dex, renderableColumnIndex));\n    this.state = EDITOR_STATE.EDITING;\n    if \
(this.isInFullEditMode()) {\n      const stringifiedInitialValue = typeof \
newInitialValue === \"string\" ? newInitialValue : \
stringify(this.originalValue);\n      \
this.setValue(stringifiedInitialValue);\n    }\n    this.open(event2);\n    \
this._opened = true;\n    this.focus();\n    hotInstance.view.render();\n    \
hotInstance.runHooks(\"afterBeginEditing\", this.row, this.col);\n  }\n  \
/**\n   * Finishes editing and start saving or restoring process for editing \
cell or last selected range.\n   *\n   * @param {boolean} \
restoreOriginalValue If true, then closes editor without saving value from \
the editor into a cell.\n   * @param {boolean} ctrlDown If true, then \
saveValue will save editor's value to each cell in the last selected range.\n \
  * @param {Function} callback The callback function, fired after editor \
closing.\n   */\n  finishEditing(restoreOriginalValue, ctrlDown, callback) \
{\n    let val;\n    if (callback) {\n      const previousCloseCallback = \
this._closeCallback;\n      this._closeCallback = (result) => {\n        if \
(previousCloseCallback) {\n          previousCloseCallback(result);\n        \
}\n        callback(result);\n        this.hot.view.render();\n      };\n    \
}\n    if (this.isWaiting()) {\n      return;\n    }\n    const \
shortcutManager = this.hot.getShortcutManager();\n    const editorContext = \
shortcutManager.getContext(\"editor\");\n    \
editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR2);\n    \
editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);\n    if \
(this.state === EDITOR_STATE.VIRGIN) {\n      this.hot._registerTimeout(() => \
{\n        this._fireCallbacks(true);\n      });\n      return;\n    }\n    \
if (this.state === EDITOR_STATE.EDITING) {\n      if (restoreOriginalValue) \
{\n        this.cancelChanges();\n        this.hot.view.render();\n        \
return;\n      }\n      const value = this.getValue();\n      if \
(this.cellProperties.trimWhitespace) {\n        val = [[typeof value === \
\"string\" ? String.prototype.trim.call(value || \"\") : value]];\n      } \
else {\n        val = [[value]];\n      }\n      this.state = \
EDITOR_STATE.WAITING;\n      this.saveValue(val, ctrlDown);\n      if \
(this.hot.getCellValidator(this.cellProperties)) {\n        \
this.hot.addHookOnce(\"postAfterValidate\", (result) => {\n          \
this.state = EDITOR_STATE.FINISHED;\n          this.discardEditor(result);\n  \
      });\n      } else {\n        this.state = EDITOR_STATE.FINISHED;\n      \
  this.discardEditor(true);\n      }\n    }\n  }\n  /**\n   * Finishes \
editing without singout saving value.\n   */\n  cancelChanges() {\n    \
this.state = EDITOR_STATE.FINISHED;\n    this.discardEditor();\n  }\n  /**\n  \
 * Verifies result of validation or closes editor if user's cancelled \
changes.\n   *\n   * @param {boolean|undefined} result If `false` and the \
cell using allowInvalid option,\n   *                                   then \
an editor won't be closed until validation is passed.\n   */\n  \
discardEditor(result) {\n    if (this.state !== EDITOR_STATE.FINISHED) {\n    \
  return;\n    }\n    if (result === false && \
this.cellProperties.allowInvalid !== true) {\n      \
this.hot.selectCell(this.row, this.col);\n      this.focus();\n      \
this.state = EDITOR_STATE.EDITING;\n      this._fireCallbacks(false);\n    } \
else {\n      this.close();\n      this._opened = false;\n      \
this._fullEditMode = false;\n      this.state = EDITOR_STATE.VIRGIN;\n      \
this._fireCallbacks(true);\n      const shortcutManager = \
this.hot.getShortcutManager();\n      \
shortcutManager.setActiveContextName(\"grid\");\n    }\n  }\n  /**\n   * \
Switch editor into full edit mode. In this state navigation keys don't close \
editor. This mode is activated\n   * automatically after hit ENTER or F2 key \
on the cell or while editing cell press F2 key.\n   */\n  \
enableFullEditMode() {\n    this._fullEditMode = true;\n  }\n  /**\n   * \
Checks if editor is in full edit mode.\n   *\n   * @returns {boolean}\n   \
*/\n  isInFullEditMode() {\n    return this._fullEditMode;\n  }\n  /**\n   * \
Returns information whether the editor is open.\n   *\n   * @returns \
{boolean}\n   */\n  isOpened() {\n    return this._opened;\n  }\n  /**\n   * \
Returns information whether the editor is waiting, eg.: for async \
validation.\n   *\n   * @returns {boolean}\n   */\n  isWaiting() {\n    \
return this.state === EDITOR_STATE.WAITING;\n  }\n  /* eslint-disable \
jsdoc/require-description-complete-sentence */\n  /**\n   * Gets the object \
that provides information about the edited cell size and its position\n   * \
relative to the table viewport.\n   *\n   * The rectangle has six integer \
properties:\n   *  - `top` The top position relative to the table viewport\n  \
 *  - `start` The left (or right in RTL) position relative to the table \
viewport\n   *  - `width` The cell's current width;\n   *  - `maxWidth` The \
maximum cell's width after which the editor goes out of the table viewport\n  \
 *  - `height` The cell's current height;\n   *  - `maxHeight` The maximum \
cell's height after which the editor goes out of the table viewport\n   *\n   \
* @returns {{top: number, start: number, width: number, maxWidth: number, \
height: number, maxHeight: number} | undefined}\n   */\n  getEditedCellRect() \
{\n    var _wtOverlays$getParent;\n    const TD = this.getEditedCell();\n    \
if (!TD) {\n      return;\n    }\n    const {\n      wtOverlays,\n      \
wtViewport\n    } = this.hot.view._wt;\n    const rootWindow = \
this.hot.rootWindow;\n    const currentOffset = offset(TD);\n    const \
cellWidth = outerWidth(TD);\n    const containerOffset = \
offset(this.hot.rootElement);\n    const containerWidth = \
outerWidth(this.hot.rootElement);\n    const scrollableContainerTop = \
wtOverlays.topOverlay.holder;\n    const scrollableContainerLeft = \
wtOverlays.inlineStartOverlay.holder;\n    const containerScrollTop = \
scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : \
0;\n    const containerScrollLeft = scrollableContainerLeft !== rootWindow ? \
scrollableContainerLeft.scrollLeft : 0;\n    const gridMostRightPos = \
rootWindow.innerWidth - containerOffset.left - containerWidth;\n    const {\n \
     wtTable: overlayTable\n    } = (_wtOverlays$getParent = \
wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 \
? _wtOverlays$getParent : this.hot.view._wt;\n    const overlayName = \
overlayTable.name;\n    const scrollTop = [\"master\", \
\"inline_start\"].includes(overlayName) ? containerScrollTop : 0;\n    const \
scrollLeft = [\"master\", \"top\", \"bottom\"].includes(overlayName) ? \
containerScrollLeft : 0;\n    const editTopModifier = currentOffset.top === \
containerOffset.top ? 0 : 1;\n    let topPos = currentOffset.top - \
containerOffset.top - editTopModifier - scrollTop;\n    let inlineStartPos = \
0;\n    if (this.hot.isRtl()) {\n      inlineStartPos = rootWindow.innerWidth \
- currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;\n    } \
else {\n      inlineStartPos = currentOffset.left - containerOffset.left - 1 \
- scrollLeft;\n    }\n    if ([\"top\", \
\"top_inline_start_corner\"].includes(overlayName)) {\n      topPos += \
wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if ([\"inline_start\", \
\"top_inline_start_corner\"].includes(overlayName)) {\n      inlineStartPos \
+= Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());\n    }\n    \
const hasColumnHeaders = this.hot.hasColHeaders();\n    const renderableRow = \
this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const \
renderableColumn = \
this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    const \
nrOfRenderableRowIndexes = \
this.hot.rowIndexMapper.getRenderableIndexesLength();\n    const \
firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - \
this.hot.view._wt.getSetting(\"fixedRowsBottom\");\n    if (hasColumnHeaders \
&& renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) \
{\n      topPos += 1;\n    }\n    if (renderableColumn <= 0) {\n      \
inlineStartPos += 1;\n    }\n    const firstRowOffset = \
wtViewport.rowsRenderCalculator.startPosition;\n    const firstColumnOffset = \
wtViewport.columnsRenderCalculator.startPosition;\n    const \
horizontalScrollPosition = \
Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());\n    const \
verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();\n    \
const scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);\n    const \
cellTopOffset = TD.offsetTop + firstRowOffset - verticalScrollPosition;\n    \
let cellStartOffset = 0;\n    if (this.hot.isRtl()) {\n      const cellOffset \
= TD.offsetLeft;\n      if (cellOffset >= 0) {\n        cellStartOffset = \
overlayTable.getWidth() - TD.offsetLeft;\n      } else {\n        \
cellStartOffset = Math.abs(cellOffset);\n      }\n      cellStartOffset += \
firstColumnOffset - horizontalScrollPosition - cellWidth;\n    } else {\n     \
 cellStartOffset = TD.offsetLeft + firstColumnOffset - \
horizontalScrollPosition;\n    }\n    const cellComputedStyle = \
getComputedStyle(this.TD, this.hot.rootWindow);\n    const \
borderPhysicalWidthProp = this.hot.isRtl() ? \"borderRightWidth\" : \
\"borderLeftWidth\";\n    const inlineStartBorderCompensation = \
parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;\n    \
const topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) \
> 0 ? 0 : 1;\n    const width = outerWidth(TD) + \
inlineStartBorderCompensation;\n    const height = outerHeight(TD) + \
topBorderCompensation;\n    const actualVerticalScrollbarWidth = \
hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;\n    const \
actualHorizontalScrollbarWidth = \
hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;\n    \
const maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - \
actualVerticalScrollbarWidth + inlineStartBorderCompensation;\n    const \
maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) \
- actualHorizontalScrollbarWidth + topBorderCompensation, 23);\n    return \
{\n      top: topPos,\n      start: inlineStartPos,\n      height,\n      \
maxHeight,\n      width,\n      maxWidth\n    };\n  }\n  /* eslint-enable \
jsdoc/require-description-complete-sentence */\n  /**\n   * Gets className of \
the edited cell if exist.\n   *\n   * @returns {string}\n   */\n  \
getEditedCellsLayerClass() {\n    const editorSection = \
this.checkEditorSection();\n    switch (editorSection) {\n      case \
\"inline-start\":\n        return \"ht_clone_left ht_clone_inline_start\";\n  \
    case \"bottom\":\n        return \"ht_clone_bottom\";\n      case \
\"bottom-inline-start-corner\":\n        return \"ht_clone_bottom_left_corner \
ht_clone_bottom_inline_start_corner\";\n      case \"top\":\n        return \
\"ht_clone_top\";\n      case \"top-inline-start-corner\":\n        return \
\"ht_clone_top_left_corner ht_clone_top_inline_start_corner\";\n      \
default:\n        return \"ht_clone_master\";\n    }\n  }\n  /**\n   * Gets \
HTMLTableCellElement of the edited cell if exist.\n   *\n   * @returns \
{HTMLTableCellElement|null}\n   */\n  getEditedCell() {\n    return \
this.hot.getCell(this.row, this.col, true);\n  }\n  /**\n   * Returns name of \
the overlay, where editor is placed.\n   *\n   * @private\n   * @returns \
{string}\n   */\n  checkEditorSection() {\n    const totalRows = \
this.hot.countRows();\n    let section = \"\";\n    if (this.row < \
this.hot.getSettings().fixedRowsTop) {\n      if (this.col < \
this.hot.getSettings().fixedColumnsStart) {\n        section = \
\"top-inline-start-corner\";\n      } else {\n        section = \"top\";\n    \
  }\n    } else if (this.hot.getSettings().fixedRowsBottom && this.row >= \
totalRows - this.hot.getSettings().fixedRowsBottom) {\n      if (this.col < \
this.hot.getSettings().fixedColumnsStart) {\n        section = \
\"bottom-inline-start-corner\";\n      } else {\n        section = \
\"bottom\";\n      }\n    } else if (this.col < \
this.hot.getSettings().fixedColumnsStart) {\n      section = \
\"inline-start\";\n    }\n    return section;\n  }\n};\nmixin(BaseEditor, \
hooksRefRegisterer_default);\n\n// \
node_modules/handsontable/3rdparty/autoResize/autoResize.mjs\nfunction \
autoResize() {\n  var defaults = {\n    minHeight: 200,\n    maxHeight: \
300,\n    minWidth: 100,\n    maxWidth: 300\n  }, el, body = document.body, \
text = document.createTextNode(\"\"), span = \
document.createElement(\"SPAN\"), observe = function(element, event2, \
handler) {\n    element.addEventListener(event2, handler, false);\n  }, \
unObserve = function(element, event2, handler) {\n    \
element.removeEventListener(event2, handler, false);\n  }, resize = \
function(newChar) {\n    var width, scrollHeight;\n    if (!newChar) {\n      \
newChar = \"\";\n    } else if (!/^[a-zA-Z \
\\.,\\\\\\/\\|0-9]$/.test(newChar)) {\n      newChar = \".\";\n    }\n    if \
(text.textContent !== void 0) {\n      text.textContent = el.value + \
newChar;\n    } else {\n      text.data = el.value + newChar;\n    }\n    \
span.style.position = \"absolute\";\n    span.style.fontSize = \
getComputedStyle2(el).fontSize;\n    span.style.fontFamily = \
getComputedStyle2(el).fontFamily;\n    span.style.whiteSpace = \"pre\";\n    \
body.appendChild(span);\n    width = span.clientWidth + 2;\n    \
body.removeChild(span);\n    el.style.height = defaults.minHeight + \"px\";\n \
   if (defaults.minWidth > width) {\n      el.style.width = defaults.minWidth \
+ \"px\";\n    } else if (width > defaults.maxWidth) {\n      el.style.width \
= defaults.maxWidth + \"px\";\n    } else {\n      el.style.width = width + \
\"px\";\n    }\n    scrollHeight = el.scrollHeight ? el.scrollHeight - 1 : \
0;\n    if (defaults.minHeight > scrollHeight) {\n      el.style.height = \
defaults.minHeight + \"px\";\n    } else if (defaults.maxHeight < \
scrollHeight) {\n      el.style.height = defaults.maxHeight + \"px\";\n      \
el.style.overflowY = \"visible\";\n    } else {\n      el.style.height = \
scrollHeight + \"px\";\n    }\n  }, delayedResize = function() {\n    \
window.setTimeout(resize, 0);\n  }, extendDefaults = function(config) {\n    \
if (config && config.minHeight) {\n      if (config.minHeight == \"inherit\") \
{\n        defaults.minHeight = el.clientHeight;\n      } else {\n        var \
minHeight = parseInt(config.minHeight);\n        if (!isNaN(minHeight)) {\n   \
       defaults.minHeight = minHeight;\n        }\n      }\n    }\n    if \
(config && config.maxHeight) {\n      if (config.maxHeight == \"inherit\") \
{\n        defaults.maxHeight = el.clientHeight;\n      } else {\n        var \
maxHeight = parseInt(config.maxHeight);\n        if (!isNaN(maxHeight)) {\n   \
       defaults.maxHeight = maxHeight;\n        }\n      }\n    }\n    if \
(config && config.minWidth) {\n      if (config.minWidth == \"inherit\") {\n  \
      defaults.minWidth = el.clientWidth;\n      } else {\n        var \
minWidth = parseInt(config.minWidth);\n        if (!isNaN(minWidth)) {\n      \
    defaults.minWidth = minWidth;\n        }\n      }\n    }\n    if (config \
&& config.maxWidth) {\n      if (config.maxWidth == \"inherit\") {\n        \
defaults.maxWidth = el.clientWidth;\n      } else {\n        var maxWidth = \
parseInt(config.maxWidth);\n        if (!isNaN(maxWidth)) {\n          \
defaults.maxWidth = maxWidth;\n        }\n      }\n    }\n    if \
(!span.firstChild) {\n      span.className = \"autoResize\";\n      \
span.style.display = \"inline-block\";\n      span.appendChild(text);\n    \
}\n  }, init = function(el_, config, doObserve) {\n    el = el_;\n    \
extendDefaults(config);\n    if (el.nodeName == \"TEXTAREA\") {\n      \
el.style.resize = \"none\";\n      el.style.overflowY = \"\";\n      \
el.style.height = defaults.minHeight + \"px\";\n      el.style.minWidth = \
defaults.minWidth + \"px\";\n      el.style.maxWidth = defaults.maxWidth + \
\"px\";\n      el.style.overflowY = \"hidden\";\n    }\n    if (doObserve) \
{\n      observe(el, \"change\", resize);\n      observe(el, \"cut\", \
delayedResize);\n      observe(el, \"paste\", delayedResize);\n      \
observe(el, \"drop\", delayedResize);\n      observe(el, \"keydown\", \
delayedResize);\n      observe(el, \"focus\", resize);\n      observe(el, \
\"compositionstart\", delayedResize);\n      observe(el, \
\"compositionupdate\", delayedResize);\n      observe(el, \"compositionend\", \
delayedResize);\n    }\n    resize();\n  };\n  function \
getComputedStyle2(element) {\n    return element.currentStyle || \
document.defaultView.getComputedStyle(element);\n  }\n  return {\n    init: \
function(el_, config, doObserve) {\n      init(el_, config, doObserve);\n    \
},\n    unObserve: function() {\n      unObserve(el, \"change\", resize);\n   \
   unObserve(el, \"cut\", delayedResize);\n      unObserve(el, \"paste\", \
delayedResize);\n      unObserve(el, \"drop\", delayedResize);\n      \
unObserve(el, \"keydown\", delayedResize);\n      unObserve(el, \"focus\", \
resize);\n      unObserve(el, \"compositionstart\", delayedResize);\n      \
unObserve(el, \"compositionupdate\", delayedResize);\n      unObserve(el, \
\"compositionend\", delayedResize);\n    },\n    resize\n  };\n}\n\n// \
node_modules/handsontable/editors/textEditor/caretPositioner.mjs\nfunction \
updateCaretPosition(actionName, textareaElement) {\n  const caretPosition = \
getCaretPosition(textareaElement);\n  const textLines = \
textareaElement.value.split(\"\\n\");\n  let newCaretPosition = \
caretPosition;\n  let lineStartIndex = 0;\n  for (let i = 0; i < \
textLines.length; i++) {\n    const textLine = textLines[i];\n    if (i !== \
0) {\n      lineStartIndex += textLines[i - 1].length + 1;\n    }\n    const \
lineEndIndex = lineStartIndex + textLine.length;\n    if (actionName === \
\"home\") {\n      newCaretPosition = lineStartIndex;\n    } else if \
(actionName === \"end\") {\n      newCaretPosition = lineEndIndex;\n    }\n   \
 if (caretPosition <= lineEndIndex) {\n      break;\n    }\n  }\n  \
setCaretPosition(textareaElement, newCaretPosition);\n}\n\n// \
node_modules/handsontable/editors/textEditor/textEditor.mjs\nvar \
EDITOR_VISIBLE_CLASS_NAME = \"ht_editor_visible\";\nvar \
EDITOR_HIDDEN_CLASS_NAME = \"ht_editor_hidden\";\nvar SHORTCUTS_GROUP2 = \
\"textEditor\";\nvar EDITOR_TYPE2 = \"text\";\nvar TextEditor = class extends \
BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE2;\n  }\n  \
/**\n   * @param {Core} instance The Handsontable instance.\n   */\n  \
constructor(instance) {\n    super(instance);\n    this.eventManager = new \
eventManager_default(this);\n    this.autoResize = autoResize();\n    \
this.TEXTAREA = void 0;\n    this.textareaStyle = void 0;\n    \
this.TEXTAREA_PARENT = void 0;\n    this.textareaParentStyle = void 0;\n    \
this.layerClass = void 0;\n    this.createElements();\n    \
this.bindEvents();\n    this.hot.addHookOnce(\"afterDestroy\", () => \
this.destroy());\n  }\n  /**\n   * Gets current value from editable \
element.\n   *\n   * @returns {number}\n   */\n  getValue() {\n    return \
this.TEXTAREA.value;\n  }\n  /**\n   * Sets new value into editable \
element.\n   *\n   * @param {*} newValue The editor value.\n   */\n  \
setValue(newValue) {\n    this.TEXTAREA.value = newValue;\n  }\n  /**\n   * \
Opens the editor and adjust its size.\n   */\n  open() {\n    \
this.refreshDimensions();\n    this.showEditableElement();\n    const \
shortcutManager = this.hot.getShortcutManager();\n    \
shortcutManager.setActiveContextName(\"editor\");\n    \
this.addHook(\"afterDocumentKeyDown\", (event2) => \
this.onAfterDocumentKeyDown(event2));\n    this.registerShortcuts();\n  }\n  \
/**\n   * Closes the editor.\n   */\n  close() {\n    \
this.autoResize.unObserve();\n    if (this.hot.rootDocument.activeElement === \
this.TEXTAREA) {\n      this.hot.listen();\n    }\n    \
this.hideEditableElement();\n    this.unregisterShortcuts();\n    \
this.removeHooksByKey(\"afterDocumentKeyDown\");\n  }\n  /**\n   * Prepares \
editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   \
* @param {number} col The visual column index.\n   * @param {number|string} \
prop The column property (passed when datasource is an array of objects).\n   \
* @param {HTMLTableCellElement} td The rendered cell element.\n   * @param \
{*} value The rendered value.\n   * @param {object} cellProperties The cell \
meta object ({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, \
value, cellProperties) {\n    const previousState = this.state;\n    \
super.prepare(row, col, prop, td, value, cellProperties);\n    if \
(!cellProperties.readOnly) {\n      this.refreshDimensions(true);\n      \
const {\n        allowInvalid,\n        fragmentSelection\n      } = \
cellProperties;\n      if (allowInvalid) {\n        this.TEXTAREA.value = \
\"\";\n      }\n      if (previousState !== EDITOR_STATE.FINISHED) {\n        \
this.hideEditableElement();\n      }\n      const restoreFocus = \
!fragmentSelection;\n      if (restoreFocus && !isMobileBrowser()) {\n        \
this.focus();\n      }\n    }\n  }\n  /**\n   * Begins editing on a \
highlighted cell and hides fillHandle corner if was present.\n   *\n   * \
@param {*} newInitialValue The editor initial value.\n   * @param {Event} \
event The keyboard event object.\n   */\n  beginEditing(newInitialValue, \
event2) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    \
}\n    this.TEXTAREA.value = \"\";\n    super.beginEditing(newInitialValue, \
event2);\n  }\n  /**\n   * Sets focus state on the select element.\n   */\n  \
focus() {\n    this.TEXTAREA.select();\n    setCaretPosition(this.TEXTAREA, \
this.TEXTAREA.value.length);\n  }\n  /**\n   * Creates an editor's elements \
and adds necessary CSS classnames.\n   */\n  createElements() {\n    const \
{\n      rootDocument\n    } = this.hot;\n    this.TEXTAREA = \
rootDocument.createElement(\"TEXTAREA\");\n    \
this.TEXTAREA.setAttribute(\"data-hot-input\", \"\");\n    \
this.TEXTAREA.tabIndex = -1;\n    addClass(this.TEXTAREA, \
\"handsontableInput\");\n    this.textareaStyle = this.TEXTAREA.style;\n    \
this.textareaStyle.width = 0;\n    this.textareaStyle.height = 0;\n    \
this.textareaStyle.overflowY = \"visible\";\n    this.TEXTAREA_PARENT = \
rootDocument.createElement(\"DIV\");\n    addClass(this.TEXTAREA_PARENT, \
\"handsontableInputHolder\");\n    if (hasClass(this.TEXTAREA_PARENT, \
this.layerClass)) {\n      removeClass(this.TEXTAREA_PARENT, \
this.layerClass);\n    }\n    addClass(this.TEXTAREA_PARENT, \
EDITOR_HIDDEN_CLASS_NAME);\n    this.textareaParentStyle = \
this.TEXTAREA_PARENT.style;\n    \
this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);\n    \
this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);\n  }\n  /**\n   * \
Moves an editable element out of the viewport, but element must be able to \
hold focus for IME support.\n   *\n   * @private\n   */\n  \
hideEditableElement() {\n    if (isEdge()) {\n      \
this.textareaStyle.textIndent = \"-99999px\";\n    }\n    \
this.textareaStyle.overflowY = \"visible\";\n    \
this.textareaParentStyle.opacity = \"0\";\n    \
this.textareaParentStyle.height = \"1px\";\n    \
removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    \
addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n  }\n  /**\n   * \
Resets an editable element position.\n   *\n   * @private\n   */\n  \
showEditableElement() {\n    this.textareaParentStyle.height = \"\";\n    \
this.textareaParentStyle.overflow = \"\";\n    \
this.textareaParentStyle.position = \"\";\n    \
this.textareaParentStyle[this.hot.isRtl() ? \"left\" : \"right\"] = \
\"auto\";\n    this.textareaParentStyle.opacity = \"1\";\n    \
this.textareaStyle.textIndent = \"\";\n    this.textareaStyle.overflowY = \
\"hidden\";\n    const childNodes = this.TEXTAREA_PARENT.childNodes;\n    let \
hasClassHandsontableEditor = false;\n    rangeEach(childNodes.length - 1, \
(index2) => {\n      const childNode = childNodes[index2];\n      if \
(hasClass(childNode, \"handsontableEditor\")) {\n        \
hasClassHandsontableEditor = true;\n        return false;\n      }\n    });\n \
   if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {\n      \
removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    }\n    if \
(hasClassHandsontableEditor) {\n      this.layerClass = \
EDITOR_VISIBLE_CLASS_NAME;\n      addClass(this.TEXTAREA_PARENT, \
this.layerClass);\n    } else {\n      this.layerClass = \
this.getEditedCellsLayerClass();\n      addClass(this.TEXTAREA_PARENT, \
this.layerClass);\n    }\n  }\n  /**\n   * Refreshes editor's value using \
source data.\n   *\n   * @private\n   */\n  refreshValue() {\n    const \
physicalRow = this.hot.toPhysicalRow(this.row);\n    const sourceData = \
this.hot.getSourceDataAtCell(physicalRow, this.col);\n    this.originalValue \
= sourceData;\n    this.setValue(sourceData);\n    \
this.refreshDimensions();\n  }\n  /**\n   * Refreshes editor's size and \
position.\n   *\n   * @private\n   * @param {boolean} force Indicates if the \
refreshing editor dimensions should be triggered.\n   */\n  \
refreshDimensions() {\n    let force = arguments.length > 0 && arguments[0] \
!== void 0 ? arguments[0] : false;\n    if (this.state !== \
EDITOR_STATE.EDITING && !force) {\n      return;\n    }\n    this.TD = \
this.getEditedCell();\n    if (!this.TD) {\n      if (!force) {\n        \
this.close();\n      }\n      return;\n    }\n    const {\n      top: top2,\n \
     start,\n      width,\n      maxWidth,\n      height,\n      maxHeight\n  \
  } = this.getEditedCellRect();\n    this.textareaParentStyle.top = \
`${top2}px`;\n    this.textareaParentStyle[this.hot.isRtl() ? \"right\" : \
\"left\"] = `${start}px`;\n    this.showEditableElement();\n    const \
cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    \
this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;\n    \
this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;\n    \
this.TEXTAREA.style.backgroundColor = this.TD.style.backgroundColor;\n    \
const textareaComputedStyle = getComputedStyle(this.TEXTAREA);\n    const \
horizontalPadding = parseInt(textareaComputedStyle.paddingLeft, 10) + \
parseInt(textareaComputedStyle.paddingRight, 10);\n    const verticalPadding \
= parseInt(textareaComputedStyle.paddingTop, 10) + \
parseInt(textareaComputedStyle.paddingBottom, 10);\n    const finalWidth = \
width - horizontalPadding;\n    const finalHeight = height - \
verticalPadding;\n    const finalMaxWidth = maxWidth - horizontalPadding;\n   \
 const finalMaxHeight = maxHeight - verticalPadding;\n    \
this.autoResize.init(this.TEXTAREA, {\n      minWidth: Math.min(finalWidth, \
finalMaxWidth),\n      minHeight: Math.min(finalHeight, finalMaxHeight),\n    \
  // TEXTAREA should never be wider than visible part of the viewport (should \
not cover the scrollbar)\n      maxWidth: finalMaxWidth,\n      maxHeight: \
finalMaxHeight\n    }, true);\n  }\n  /**\n   * Binds events and hooks.\n   \
*\n   * @private\n   */\n  bindEvents() {\n    \
this.eventManager.addEventListener(this.TEXTAREA, \"cut\", (event2) => \
event2.stopPropagation());\n    \
this.eventManager.addEventListener(this.TEXTAREA, \"paste\", (event2) => \
event2.stopPropagation());\n    if (isIOS()) {\n      \
this.eventManager.addEventListener(this.TEXTAREA, \"focusout\", () => \
this.finishEditing(false));\n    }\n    \
this.addHook(\"afterScrollHorizontally\", () => this.refreshDimensions());\n  \
  this.addHook(\"afterScrollVertically\", () => this.refreshDimensions());\n  \
  this.addHook(\"afterColumnResize\", () => {\n      \
this.refreshDimensions();\n      this.focus();\n    });\n    \
this.addHook(\"afterRowResize\", () => {\n      this.refreshDimensions();\n   \
   this.focus();\n    });\n  }\n  /**\n   * Ugly hack for \
autocompleteEditor.\n   *\n   * @private\n   */\n  allowKeyEventPropagation() \
{\n  }\n  /**\n   * Destroys the internal event manager and clears attached \
hooks.\n   *\n   * @private\n   */\n  destroy() {\n    \
this.eventManager.destroy();\n    this.clearHooks();\n  }\n  /**\n   * \
Register shortcuts responsible for handling editor.\n   *\n   * @private\n   \
*/\n  registerShortcuts() {\n    const shortcutManager = \
this.hot.getShortcutManager();\n    const editorContext = \
shortcutManager.getContext(\"editor\");\n    const contextConfig = {\n      \
runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: \
SHORTCUTS_GROUP2\n    };\n    const insertNewLine = () => {\n      \
this.hot.rootDocument.execCommand(\"insertText\", false, \"\\n\");\n    };\n  \
  editorContext.addShortcuts([{\n      keys: [[\"Tab\"]],\n      // TODO: \
Duplicated part of code (callback to shortcut).\n      callback: (event2) => \
{\n        const tableMeta = this.hot.getSettings();\n        const tabMoves \
= typeof tableMeta.tabMoves === \"function\" ? tableMeta.tabMoves(event2) : \
tableMeta.tabMoves;\n        this.hot.selection.transformStart(tabMoves.row, \
tabMoves.col, true);\n      }\n    }, {\n      keys: [[\"Shift\", \
\"Tab\"]],\n      // TODO: Duplicated part of code (callback to shortcut).\n  \
    callback: (event2) => {\n        const tableMeta = \
this.hot.getSettings();\n        const tabMoves = typeof tableMeta.tabMoves \
=== \"function\" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;\n        \
this.hot.selection.transformStart(-tabMoves.row, -tabMoves.col);\n      }\n   \
 }, {\n      keys: [[\"Control\", \"Enter\"]],\n      callback: () => {\n     \
   insertNewLine();\n        return false;\n      },\n      runOnlyIf: \
(event2) => !this.hot.selection.isMultiple() && // We trigger a data \
population for multiple selection.\n      // catch CTRL but not right ALT \
(which in some systems triggers ALT+CTRL)\n      !event2.altKey,\n      \
relativeToGroup: SHORTCUTS_GROUP_EDITOR,\n      position: \"before\"\n    }, \
{\n      keys: [[\"Meta\", \"Enter\"]],\n      callback: () => {\n        \
insertNewLine();\n        return false;\n      },\n      runOnlyIf: () => \
!this.hot.selection.isMultiple(),\n      // We trigger a data population for \
multiple selection.\n      relativeToGroup: SHORTCUTS_GROUP_EDITOR,\n      \
position: \"before\"\n    }, {\n      keys: [[\"Alt\", \"Enter\"]],\n      \
callback: () => {\n        insertNewLine();\n        return false;\n      \
},\n      relativeToGroup: SHORTCUTS_GROUP_EDITOR,\n      position: \
\"before\"\n    }, {\n      // TODO: Duplicated part of code (callback to \
shortcut)\n      keys: [[\"PageUp\"]],\n      callback: () => {\n        \
this.hot.selection.transformStart(-this.hot.countVisibleRows(), 0);\n      \
}\n    }, {\n      // TODO: Duplicated part of code (callback to shortcut)\n  \
    keys: [[\"PageDown\"]],\n      callback: () => {\n        \
this.hot.selection.transformStart(this.hot.countVisibleRows(), 0);\n      }\n \
   }, {\n      keys: [[\"Home\"]],\n      callback: (event2, _ref) => {\n     \
   let [keyName] = _ref;\n        updateCaretPosition(keyName, \
this.TEXTAREA);\n      }\n    }, {\n      keys: [[\"End\"]],\n      callback: \
(event2, _ref2) => {\n        let [keyName] = _ref2;\n        \
updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }, {\n      keys: \
[[\"Control/Meta\", \"Z\"]],\n      preventDefault: false,\n      callback: \
() => {\n        this.hot._registerTimeout(() => {\n          \
this.autoResize.resize();\n        }, 10);\n      }\n    }, {\n      keys: \
[[\"Control/Meta\", \"Shift\", \"Z\"]],\n      preventDefault: false,\n      \
callback: () => {\n        this.hot._registerTimeout(() => {\n          \
this.autoResize.resize();\n        }, 10);\n      }\n    }], \
contextConfig);\n  }\n  /**\n   * Unregister shortcuts responsible for \
handling editor.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    \
const shortcutManager = this.hot.getShortcutManager();\n    const \
editorContext = shortcutManager.getContext(\"editor\");\n    \
editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);\n    \
editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP2);\n    \
editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR2);\n  }\n  /**\n  \
 * OnAfterDocumentKeyDown callback.\n   *\n   * @private\n   * @param \
{KeyboardEvent} event The keyboard event object.\n   */\n  \
onAfterDocumentKeyDown(event2) {\n    const arrowKeyCodes = \
[KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN, \
KEY_CODES.ARROW_LEFT];\n    if (arrowKeyCodes.indexOf(event2.keyCode) === -1) \
{\n      this.autoResize.resize(String.fromCharCode(event2.keyCode));\n    \
}\n  }\n};\n\n// \
node_modules/handsontable/renderers/baseRenderer/baseRenderer.mjs\nvar \
RENDERER_TYPE = \"base\";\nfunction baseRenderer(instance, TD, row, col, \
prop, value, cellProperties) {\n  const classesToAdd = [];\n  const \
classesToRemove = [];\n  if (cellProperties.className) {\n    addClass(TD, \
cellProperties.className);\n  }\n  if (cellProperties.readOnly) {\n    \
classesToAdd.push(cellProperties.readOnlyCellClassName);\n  }\n  if \
(cellProperties.valid === false && cellProperties.invalidCellClassName) {\n   \
 classesToAdd.push(cellProperties.invalidCellClassName);\n  } else {\n    \
classesToRemove.push(cellProperties.invalidCellClassName);\n  }\n  if \
(cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {\n \
   classesToAdd.push(cellProperties.noWordWrapClassName);\n  }\n  if (!value \
&& cellProperties.placeholder) {\n    \
classesToAdd.push(cellProperties.placeholderCellClassName);\n  }\n  \
removeClass(TD, classesToRemove);\n  addClass(TD, \
classesToAdd);\n}\nbaseRenderer.RENDERER_TYPE = RENDERER_TYPE;\n\n// \
node_modules/handsontable/renderers/textRenderer/textRenderer.mjs\nvar \
RENDERER_TYPE2 = \"text\";\nfunction textRenderer(instance, TD, row, col, \
prop, value, cellProperties) {\n  baseRenderer.apply(this, [instance, TD, \
row, col, prop, value, cellProperties]);\n  let escaped = value;\n  if \
(!escaped && cellProperties.placeholder) {\n    escaped = \
cellProperties.placeholder;\n  }\n  escaped = stringify(escaped);\n  if \
(cellProperties.trimWhitespace) {\n    escaped = escaped.trim();\n  }\n  if \
(cellProperties.rendererTemplate) {\n    empty(TD);\n    const TEMPLATE = \
instance.rootDocument.createElement(\"TEMPLATE\");\n    \
TEMPLATE.setAttribute(\"bind\", \"{{}}\");\n    TEMPLATE.innerHTML = \
cellProperties.rendererTemplate;\n    \
HTMLTemplateElement.decorate(TEMPLATE);\n    TEMPLATE.model = \
instance.getSourceDataAtRow(row);\n    TD.appendChild(TEMPLATE);\n  } else \
{\n    fastInnerText(TD, escaped);\n  }\n}\ntextRenderer.RENDERER_TYPE = \
RENDERER_TYPE2;\n\n// \
node_modules/handsontable/cellTypes/textType/textType.mjs\nvar CELL_TYPE2 = \
\"text\";\nvar TextCellType = {\n  CELL_TYPE: CELL_TYPE2,\n  editor: \
TextEditor,\n  renderer: textRenderer\n};\n\n// \
node_modules/handsontable/base.mjs\n_register4(TextCellType);\nHandsontable.e\
ditors = {\n  BaseEditor\n};\nfunction Handsontable(rootElement, \
userSettings) {\n  const instance = new Core(rootElement, userSettings || {}, \
rootInstanceSymbol);\n  instance.init();\n  return \
instance;\n}\nHandsontable.Core = function(rootElement) {\n  let userSettings \
= arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  \
return new Core(rootElement, userSettings, \
rootInstanceSymbol);\n};\nHandsontable.DefaultSettings = \
metaSchema_default();\nHandsontable.hooks = \
pluginHooks_default.getSingleton();\nHandsontable.CellCoords = \
coords_default;\nHandsontable.CellRange = \
range_default;\nHandsontable.packageName = \
\"handsontable\";\nHandsontable.buildDate = \"31/08/2023 \
08:23:33\";\nHandsontable.version = \"13.1.0\";\nHandsontable.languages = {\n \
 dictionaryKeys,\n  getLanguageDictionary,\n  getLanguagesDictionaries,\n  \
registerLanguageDictionary,\n  getTranslatedPhrase\n};\nvar base_default = \
Handsontable;\n\n// \
node_modules/handsontable/editors/handsontableEditor/handsontableEditor.mjs\n\
var SHORTCUTS_GROUP3 = \"handsontableEditor\";\nvar EDITOR_TYPE3 = \
\"handsontable\";\nvar HandsontableEditor = class extends TextEditor {\n  \
static get EDITOR_TYPE() {\n    return EDITOR_TYPE3;\n  }\n  /**\n   * Opens \
the editor and adjust its size.\n   */\n  open() {\n    super.open();\n    if \
(this.htEditor) {\n      this.htEditor.destroy();\n    }\n    if \
(this.htContainer.style.display === \"none\") {\n      \
this.htContainer.style.display = \"\";\n    }\n    this.htEditor = new \
this.hot.constructor(this.htContainer, this.htOptions);\n    \
this.htEditor.init();\n    this.htEditor.rootElement.style.display = \"\";\n  \
  if (this.cellProperties.strict) {\n      this.htEditor.selectCell(0, 0);\n  \
  } else {\n      this.htEditor.deselectCell();\n    }\n    \
setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);\n    \
this.refreshDimensions();\n  }\n  /**\n   * Closes the editor.\n   */\n  \
close() {\n    if (this.htEditor) {\n      \
this.htEditor.rootElement.style.display = \"none\";\n    }\n    \
this.removeHooksByKey(\"beforeKeyDown\");\n    super.close();\n  }\n  /**\n   \
* Prepares editor's meta data and configuration of the internal \
Handsontable's instance.\n   *\n   * @param {number} row The visual row \
index.\n   * @param {number} col The visual column index.\n   * @param \
{number|string} prop The column property (passed when datasource is an array \
of objects).\n   * @param {HTMLTableCellElement} td The rendered cell \
element.\n   * @param {*} value The rendered value.\n   * @param {object} \
cellProperties The cell meta object ({@see Core#getCellMeta}).\n   */\n  \
prepare(row, col, prop, td, value, cellProperties) {\n    super.prepare(row, \
col, prop, td, value, cellProperties);\n    const parent2 = this;\n    const \
options = {\n      startRows: 0,\n      startCols: 0,\n      minRows: 0,\n    \
  minCols: 0,\n      className: \"listbox\",\n      copyPaste: false,\n      \
autoColumnSize: false,\n      autoRowSize: false,\n      readOnly: true,\n    \
  fillHandle: false,\n      autoWrapCol: false,\n      autoWrapRow: false,\n  \
    afterOnCellMouseDown(_, coords) {\n        const sourceValue = \
this.getSourceData(coords.row, coords.col);\n        if (sourceValue !== void \
0) {\n          parent2.setValue(sourceValue);\n        }\n        \
parent2.instance.destroyEditor();\n      },\n      preventWheel: true,\n      \
layoutDirection: this.hot.isRtl() ? \"rtl\" : \"ltr\"\n    };\n    if \
(this.cellProperties.handsontable) {\n      extend(options, \
cellProperties.handsontable);\n    }\n    this.htOptions = options;\n  }\n  \
/**\n   * Begins editing on a highlighted cell and hides fillHandle corner if \
was present.\n   *\n   * @param {*} newInitialValue The editor initial \
value.\n   * @param {*} event The keyboard event object.\n   */\n  \
beginEditing(newInitialValue, event2) {\n    const onBeginEditing = \
this.hot.getSettings().onBeginEditing;\n    if (onBeginEditing && \
onBeginEditing() === false) {\n      return;\n    }\n    \
super.beginEditing(newInitialValue, event2);\n  }\n  /**\n   * Creates an \
editor's elements and adds necessary CSS classnames.\n   */\n  \
createElements() {\n    super.createElements();\n    const DIV = \
this.hot.rootDocument.createElement(\"DIV\");\n    DIV.className = \
\"handsontableEditor\";\n    this.TEXTAREA_PARENT.appendChild(DIV);\n    \
this.htContainer = DIV;\n    this.assignHooks();\n  }\n  /**\n   * Finishes \
editing and start saving or restoring process for editing cell or last \
selected range.\n   *\n   * @param {boolean} restoreOriginalValue If true, \
then closes editor without saving value from the editor into a cell.\n   * \
@param {boolean} ctrlDown If true, then saveValue will save editor's value to \
each cell in the last selected range.\n   * @param {Function} callback The \
callback function, fired after editor closing.\n   */\n  \
finishEditing(restoreOriginalValue, ctrlDown, callback) {\n    if \
(this.htEditor && this.htEditor.isListening()) {\n      this.hot.listen();\n  \
  }\n    if (this.htEditor && this.htEditor.getSelectedLast()) {\n      const \
value = this.htEditor.getInstance().getValue();\n      if (value !== void 0) \
{\n        this.setValue(value);\n      }\n    }\n    \
super.finishEditing(restoreOriginalValue, ctrlDown, callback);\n  }\n  /**\n  \
 * Assings afterDestroy callback to prevent memory leaks.\n   *\n   * \
@private\n   */\n  assignHooks() {\n    this.hot.addHook(\"afterDestroy\", () \
=> {\n      if (this.htEditor) {\n        this.htEditor.destroy();\n      }\n \
   });\n  }\n  /**\n   * Register shortcuts responsible for handling \
editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const \
shortcutManager = this.hot.getShortcutManager();\n    const editorContext = \
shortcutManager.getContext(\"editor\");\n    super.registerShortcuts();\n    \
const contextConfig = {\n      group: SHORTCUTS_GROUP3,\n      \
relativeToGroup: SHORTCUTS_GROUP_NAVIGATION,\n      position: \"before\"\n    \
};\n    const action = (rowToSelect, event2) => {\n      const innerHOT = \
this.htEditor.getInstance();\n      if (rowToSelect !== void 0) {\n        if \
(rowToSelect < 0 || innerHOT.flipped && rowToSelect > innerHOT.countRows() - \
1) {\n          innerHOT.deselectCell();\n        } else {\n          \
innerHOT.selectCell(rowToSelect, 0);\n        }\n        if \
(innerHOT.getData().length) {\n          event2.preventDefault();\n          \
stopImmediatePropagation(event2);\n          this.hot.listen();\n          \
this.TEXTAREA.focus();\n          return false;\n        }\n      }\n    };\n \
   editorContext.addShortcuts([{\n      keys: [[\"ArrowUp\"]],\n      \
callback: (event2) => {\n        const innerHOT = \
this.htEditor.getInstance();\n        let rowToSelect;\n        let \
selectedRow;\n        if (!innerHOT.getSelectedLast() && innerHOT.flipped) \
{\n          rowToSelect = innerHOT.countRows() - 1;\n        } else if \
(innerHOT.getSelectedLast()) {\n          if (innerHOT.flipped) {\n           \
 selectedRow = innerHOT.getSelectedLast()[0];\n            rowToSelect = \
Math.max(0, selectedRow - 1);\n          } else {\n            selectedRow = \
innerHOT.getSelectedLast()[0];\n            rowToSelect = selectedRow - 1;\n  \
        }\n        }\n        return action(rowToSelect, event2);\n      },\n \
     preventDefault: false\n      // Doesn't block default behaviour \
(navigation) for a `textArea` HTMLElement.\n    }, {\n      keys: \
[[\"ArrowDown\"]],\n      callback: (event2) => {\n        const innerHOT = \
this.htEditor.getInstance();\n        let rowToSelect;\n        let \
selectedRow;\n        if (!innerHOT.getSelectedLast() && !innerHOT.flipped) \
{\n          rowToSelect = 0;\n        } else if (innerHOT.getSelectedLast()) \
{\n          if (innerHOT.flipped) {\n            rowToSelect = \
innerHOT.getSelectedLast()[0] + 1;\n          } else if (!innerHOT.flipped) \
{\n            const lastRow = innerHOT.countRows() - 1;\n            \
selectedRow = innerHOT.getSelectedLast()[0];\n            rowToSelect = \
Math.min(lastRow, selectedRow + 1);\n          }\n        }\n        return \
action(rowToSelect, event2);\n      },\n      preventDefault: false\n      // \
Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.\n  \
  }], contextConfig);\n  }\n  /**\n   * Unregister shortcuts responsible for \
handling editor.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    \
super.unregisterShortcuts();\n    const shortcutManager = \
this.hot.getShortcutManager();\n    const editorContext = \
shortcutManager.getContext(\"editor\");\n    \
editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP3);\n  }\n};\n\n// \
node_modules/handsontable/editors/autocompleteEditor/autocompleteEditor.mjs\n\
function _defineProperty16(obj, key, value) {\n  key = \
_toPropertyKey16(key);\n  if (key in obj) {\n    Object.defineProperty(obj, \
key, { value, enumerable: true, configurable: true, writable: true });\n  } \
else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction \
_toPropertyKey16(arg) {\n  var key = _toPrimitive16(arg, \"string\");\n  \
return typeof key === \"symbol\" ? key : String(key);\n}\nfunction \
_toPrimitive16(input, hint) {\n  if (typeof input !== \"object\" || input === \
null)\n    return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim \
!== void 0) {\n    var res = prim.call(input, hint || \"default\");\n    if \
(typeof res !== \"object\")\n      return res;\n    throw new \
TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return \
(hint === \"string\" ? String : Number)(input);\n}\nvar privatePool5 = /* \
@__PURE__ */ new WeakMap();\nvar EDITOR_TYPE4 = \"autocomplete\";\nvar \
AutocompleteEditor = class extends HandsontableEditor {\n  static get \
EDITOR_TYPE() {\n    return EDITOR_TYPE4;\n  }\n  constructor(instance) {\n   \
 super(instance);\n    _defineProperty16(this, \"sortByRelevance\", \
function(value, choices, caseSensitive) {\n      const choicesRelevance = \
[];\n      const result = [];\n      const valueLength = value.length;\n      \
let choicesCount = choices.length;\n      let charsLeft;\n      let \
currentItem;\n      let i;\n      let valueIndex;\n      if (valueLength === \
0) {\n        for (i = 0; i < choicesCount; i++) {\n          \
result.push(i);\n        }\n        return result;\n      }\n      for (i = \
0; i < choicesCount; i++) {\n        currentItem = \
stripTags(stringify(choices[i]));\n        if (caseSensitive) {\n          \
valueIndex = currentItem.indexOf(value);\n        } else {\n          const \
locale = this.cellProperties.locale;\n          valueIndex = \
currentItem.toLocaleLowerCase(locale).indexOf(value.toLocaleLowerCase(locale)\
);\n        }\n        if (valueIndex !== -1) {\n          charsLeft = \
currentItem.length - valueIndex - valueLength;\n          \
choicesRelevance.push({\n            baseIndex: i,\n            index: \
valueIndex,\n            charsLeft,\n            value: currentItem\n         \
 });\n        }\n      }\n      choicesRelevance.sort((a, b) => {\n        if \
(b.index === -1) {\n          return -1;\n        }\n        if (a.index === \
-1) {\n          return 1;\n        }\n        if (a.index < b.index) {\n     \
     return -1;\n        } else if (b.index < a.index) {\n          return \
1;\n        } else if (a.index === b.index) {\n          if (a.charsLeft < \
b.charsLeft) {\n            return -1;\n          } else if (a.charsLeft > \
b.charsLeft) {\n            return 1;\n          }\n        }\n        return \
0;\n      });\n      for (i = 0, choicesCount = choicesRelevance.length; i < \
choicesCount; i++) {\n        result.push(choicesRelevance[i].baseIndex);\n   \
   }\n      return result;\n    });\n    this.query = null;\n    \
this.strippedChoices = [];\n    this.rawChoices = [];\n    \
privatePool5.set(this, {\n      skipOne: false,\n      isMacOS: \
this.hot.rootWindow.navigator.platform.indexOf(\"Mac\") > -1\n    });\n  }\n  \
/**\n   * Gets current value from editable element.\n   *\n   * @returns \
{string}\n   */\n  getValue() {\n    const selectedValue = \
this.rawChoices.find((value) => {\n      const strippedValue = \
this.stripValueIfNeeded(value);\n      return strippedValue === \
this.TEXTAREA.value;\n    });\n    if (isDefined(selectedValue)) {\n      \
return selectedValue;\n    }\n    return this.TEXTAREA.value;\n  }\n  /**\n   \
* Creates an editor's elements and adds necessary CSS classnames.\n   */\n  \
createElements() {\n    super.createElements();\n    \
addClass(this.htContainer, \"autocompleteEditor\");\n    \
addClass(this.htContainer, \
this.hot.rootWindow.navigator.platform.indexOf(\"Mac\") === -1 ? \"\" : \
\"htMacScroll\");\n  }\n  /**\n   * Opens the editor and adjust its size and \
internal Handsontable's instance.\n   */\n  open() {\n    const priv = \
privatePool5.get(this);\n    super.open();\n    const choicesListHot = \
this.htEditor.getInstance();\n    const trimDropdown = \
this.cellProperties.trimDropdown === void 0 ? true : \
this.cellProperties.trimDropdown;\n    this.showEditableElement();\n    \
this.focus();\n    let scrollbarWidth = getScrollbarWidth();\n    if \
(scrollbarWidth === 0 && priv.isMacOS) {\n      scrollbarWidth += 15;\n    \
}\n    this.addHook(\"beforeKeyDown\", (event2) => \
this.onBeforeKeyDown(event2));\n    choicesListHot.updateSettings({\n      \
colWidths: trimDropdown ? [outerWidth(this.TEXTAREA) - 2] : void 0,\n      \
width: trimDropdown ? outerWidth(this.TEXTAREA) + scrollbarWidth : void 0,\n  \
    renderer: (instance, TD, row, col, prop, value, cellProperties) => {\n    \
    textRenderer(instance, TD, row, col, prop, value, cellProperties);\n      \
  const {\n          filteringCaseSensitive,\n          allowHtml,\n          \
locale\n        } = this.cellProperties;\n        const query = this.query;\n \
       let cellValue = stringify(value);\n        let indexOfMatch;\n        \
let match;\n        if (cellValue && !allowHtml) {\n          indexOfMatch = \
filteringCaseSensitive === true ? cellValue.indexOf(query) : \
cellValue.toLocaleLowerCase(locale).indexOf(query.toLocaleLowerCase(locale));\
\n          if (indexOfMatch !== -1) {\n            match = \
cellValue.substr(indexOfMatch, query.length);\n            cellValue = \
cellValue.replace(match, `<strong>${match}</strong>`);\n          }\n        \
}\n        TD.innerHTML = cellValue;\n      },\n      autoColumnSize: true\n  \
  });\n    if (priv.skipOne) {\n      priv.skipOne = false;\n    }\n    \
this.hot._registerTimeout(() => {\n      \
this.queryChoices(this.TEXTAREA.value);\n    });\n  }\n  /**\n   * Closes the \
editor.\n   */\n  close() {\n    this.removeHooksByKey(\"beforeKeyDown\");\n  \
  super.close();\n  }\n  /**\n   * Verifies result of validation or closes \
editor if user's cancelled changes.\n   *\n   * @param {boolean|undefined} \
result If `false` and the cell using allowInvalid option,\n   *               \
                    then an editor won't be closed until validation is \
passed.\n   */\n  discardEditor(result) {\n    super.discardEditor(result);\n \
   this.hot.view.render();\n  }\n  /**\n   * Prepares choices list based on \
applied argument.\n   *\n   * @private\n   * @param {string} query The \
query.\n   */\n  queryChoices(query) {\n    const source = \
this.cellProperties.source;\n    this.query = query;\n    if (typeof source \
=== \"function\") {\n      source.call(this.cellProperties, query, (choices) \
=> {\n        this.rawChoices = choices;\n        \
this.updateChoicesList(this.stripValuesIfNeeded(choices));\n      });\n    } \
else if (Array.isArray(source)) {\n      this.rawChoices = source;\n      \
this.updateChoicesList(this.stripValuesIfNeeded(source));\n    } else {\n     \
 this.updateChoicesList([]);\n    }\n  }\n  /**\n   * Updates list of the \
possible completions to choose.\n   *\n   * @private\n   * @param {Array} \
choicesList The choices list to process.\n   */\n  \
updateChoicesList(choicesList) {\n    const pos = \
getCaretPosition(this.TEXTAREA);\n    const endPos = \
getSelectionEndPosition(this.TEXTAREA);\n    const sortByRelevanceSetting = \
this.cellProperties.sortByRelevance;\n    const filterSetting = \
this.cellProperties.filter;\n    let orderByRelevance = null;\n    let \
highlightIndex = null;\n    let choices = choicesList;\n    if \
(sortByRelevanceSetting) {\n      orderByRelevance = \
this.sortByRelevance(this.stripValueIfNeeded(this.getValue()), choices, \
this.cellProperties.filteringCaseSensitive);\n    }\n    const \
orderByRelevanceLength = Array.isArray(orderByRelevance) ? \
orderByRelevance.length : 0;\n    if (filterSetting === false) {\n      if \
(orderByRelevanceLength) {\n        highlightIndex = orderByRelevance[0];\n   \
   }\n    } else {\n      const sorted = [];\n      for (let i = 0, \
choicesCount = choices.length; i < choicesCount; i++) {\n        if \
(sortByRelevanceSetting && orderByRelevanceLength <= i) {\n          break;\n \
       }\n        if (orderByRelevanceLength) {\n          \
sorted.push(choices[orderByRelevance[i]]);\n        } else {\n          \
sorted.push(choices[i]);\n        }\n      }\n      highlightIndex = 0;\n     \
 choices = sorted;\n    }\n    this.strippedChoices = choices;\n    \
this.htEditor.loadData(pivot([choices]));\n    this.updateDropdownHeight();\n \
   this.flipDropdownIfNeeded();\n    if (this.cellProperties.strict === true) \
{\n      this.highlightBestMatchingChoice(highlightIndex);\n    }\n    \
this.hot.listen();\n    setCaretPosition(this.TEXTAREA, pos, pos === endPos ? \
void 0 : endPos);\n  }\n  /**\n   * Checks where is enough place to open \
editor.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  \
flipDropdownIfNeeded() {\n    const trimmingContainer = \
getTrimmingContainer(this.hot.view._wt.wtTable.TABLE);\n    const \
isWindowAsScrollableElement = trimmingContainer === this.hot.rootWindow;\n    \
const preventOverflow = this.cellProperties.preventOverflow;\n    if \
(isWindowAsScrollableElement || !isWindowAsScrollableElement && \
(preventOverflow || preventOverflow === \"horizontal\")) {\n      return \
false;\n    }\n    const textareaOffset = offset(this.TEXTAREA);\n    const \
textareaHeight = outerHeight(this.TEXTAREA);\n    const dropdownHeight = \
this.getDropdownHeight();\n    const trimmingContainerScrollTop = \
trimmingContainer.scrollTop;\n    const headersHeight = \
outerHeight(this.hot.view._wt.wtTable.THEAD);\n    const containerOffset = \
offset(trimmingContainer);\n    const spaceAbove = textareaOffset.top - \
containerOffset.top - headersHeight + trimmingContainerScrollTop;\n    const \
spaceBelow = trimmingContainer.scrollHeight - spaceAbove - headersHeight - \
textareaHeight;\n    const flipNeeded = dropdownHeight > spaceBelow && \
spaceAbove > spaceBelow;\n    if (flipNeeded) {\n      \
this.flipDropdown(dropdownHeight);\n    } else {\n      \
this.unflipDropdown();\n    }\n    this.limitDropdownIfNeeded(flipNeeded ? \
spaceAbove : spaceBelow, dropdownHeight);\n    return flipNeeded;\n  }\n  \
/**\n   * Checks if the internal table should generate scrollbar or could be \
rendered without it.\n   *\n   * @private\n   * @param {number} \
spaceAvailable The free space as height defined in px available for dropdown \
list.\n   * @param {number} dropdownHeight The dropdown height.\n   */\n  \
limitDropdownIfNeeded(spaceAvailable, dropdownHeight) {\n    if \
(dropdownHeight > spaceAvailable) {\n      let tempHeight = 0;\n      let i = \
0;\n      let lastRowHeight = 0;\n      let height = null;\n      do {\n      \
  lastRowHeight = this.htEditor.getRowHeight(i) || \
this.htEditor.view._wt.getSetting(\"defaultRowHeight\");\n        tempHeight \
+= lastRowHeight;\n        i += 1;\n      } while (tempHeight < \
spaceAvailable);\n      height = tempHeight - lastRowHeight;\n      if \
(this.htEditor.flipped) {\n        this.htEditor.rootElement.style.top = \
`${parseInt(this.htEditor.rootElement.style.top, 10) + dropdownHeight - \
height}px`;\n      }\n      this.setDropdownHeight(tempHeight - \
lastRowHeight);\n    }\n  }\n  /**\n   * Configures editor to open it at the \
top.\n   *\n   * @private\n   * @param {number} dropdownHeight The dropdown \
height.\n   */\n  flipDropdown(dropdownHeight) {\n    const dropdownStyle = \
this.htEditor.rootElement.style;\n    dropdownStyle.position = \
\"absolute\";\n    dropdownStyle.top = `${-dropdownHeight}px`;\n    \
this.htEditor.flipped = true;\n  }\n  /**\n   * Configures editor to open it \
at the bottom.\n   *\n   * @private\n   */\n  unflipDropdown() {\n    const \
dropdownStyle = this.htEditor.rootElement.style;\n    dropdownStyle.position \
= \"absolute\";\n    dropdownStyle.top = \"\";\n    this.htEditor.flipped = \
void 0;\n  }\n  /**\n   * Updates width and height of the internal \
Handsontable's instance.\n   *\n   * @private\n   */\n  \
updateDropdownHeight() {\n    const currentDropdownWidth = \
this.htEditor.getColWidth(0) + getScrollbarWidth(this.hot.rootDocument) + \
2;\n    const trimDropdown = this.cellProperties.trimDropdown;\n    \
this.htEditor.updateSettings({\n      height: this.getDropdownHeight(),\n     \
 width: trimDropdown ? void 0 : currentDropdownWidth\n    });\n    \
this.htEditor.view._wt.wtTable.alignOverlaysWithTrimmingContainer();\n  }\n  \
/**\n   * Sets new height of the internal Handsontable's instance.\n   *\n   \
* @private\n   * @param {number} height The new dropdown height.\n   */\n  \
setDropdownHeight(height) {\n    this.htEditor.updateSettings({\n      \
height\n    });\n  }\n  /**\n   * Creates new selection on specified row \
index, or deselects selected cells.\n   *\n   * @private\n   * @param \
{number|undefined} index The visual row index.\n   */\n  \
highlightBestMatchingChoice(index2) {\n    if (typeof index2 === \"number\") \
{\n      this.htEditor.selectCell(index2, 0, void 0, void 0, void 0, \
false);\n    } else {\n      this.htEditor.deselectCell();\n    }\n  }\n  \
/**\n   * Calculates and return the internal Handsontable's height.\n   *\n   \
* @private\n   * @returns {number}\n   */\n  getDropdownHeight() {\n    const \
firstRowHeight = this.htEditor.getInstance().getRowHeight(0) || 23;\n    \
const visibleRows = this.cellProperties.visibleRows;\n    return \
this.strippedChoices.length >= visibleRows ? visibleRows * firstRowHeight : \
this.strippedChoices.length * firstRowHeight + 8;\n  }\n  /**\n   * Sanitizes \
value from potential dangerous tags.\n   *\n   * @private\n   * @param \
{string} value The value to sanitize.\n   * @returns {string}\n   */\n  \
stripValueIfNeeded(value) {\n    return \
this.stripValuesIfNeeded([value])[0];\n  }\n  /**\n   * Sanitizes an array of \
the values from potential dangerous tags.\n   *\n   * @private\n   * @param \
{string[]} values The value to sanitize.\n   * @returns {string[]}\n   */\n  \
stripValuesIfNeeded(values) {\n    const {\n      allowHtml\n    } = \
this.cellProperties;\n    const stringifiedValues = arrayMap(values, (value) \
=> stringify(value));\n    const strippedValues = arrayMap(stringifiedValues, \
(value) => allowHtml ? value : stripTags(value));\n    return \
strippedValues;\n  }\n  /**\n   * Captures use of arrow down and up to \
control their behaviour.\n   *\n   * @private\n   * @param {number} keyCode \
The keyboard keycode.\n   * @returns {boolean}\n   */\n  \
allowKeyEventPropagation(keyCode) {\n    const selectedRange = \
this.htEditor.getSelectedRangeLast();\n    const selected = {\n      row: \
selectedRange ? selectedRange.from.row : -1\n    };\n    let allowed = \
false;\n    if (keyCode === KEY_CODES.ARROW_DOWN && selected.row > 0 && \
selected.row < this.htEditor.countRows() - 1) {\n      allowed = true;\n    \
}\n    if (keyCode === KEY_CODES.ARROW_UP && selected.row > -1) {\n      \
allowed = true;\n    }\n    return allowed;\n  }\n  /**\n   * OnBeforeKeyDown \
callback.\n   *\n   * @private\n   * @param {KeyboardEvent} event The \
keyboard event object.\n   */\n  onBeforeKeyDown(event2) {\n    const priv = \
privatePool5.get(this);\n    priv.skipOne = false;\n    if \
(isPrintableChar(event2.keyCode) || event2.keyCode === KEY_CODES.BACKSPACE || \
event2.keyCode === KEY_CODES.DELETE || event2.keyCode === KEY_CODES.INSERT) \
{\n      let timeOffset = 10;\n      if (event2.keyCode === KEY_CODES.C && \
(event2.ctrlKey || event2.metaKey)) {\n        return;\n      }\n      if \
(!this.isOpened()) {\n        timeOffset += 10;\n      }\n      if \
(this.htEditor) {\n        this.hot._registerTimeout(() => {\n          \
this.queryChoices(this.TEXTAREA.value);\n          priv.skipOne = true;\n     \
   }, timeOffset);\n      }\n    }\n  }\n};\n\n// \
node_modules/handsontable/editors/checkboxEditor/checkboxEditor.mjs\nvar \
EDITOR_TYPE5 = \"checkbox\";\nvar CheckboxEditor = class extends BaseEditor \
{\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE5;\n  }\n  \
beginEditing(initialValue, event2) {\n    if (event2 && event2.type === \
\"mouseup\") {\n      const checkbox = \
this.TD.querySelector('input[type=\"checkbox\"]');\n      if \
(!hasClass(checkbox, \"htBadValue\")) {\n        checkbox.click();\n      }\n \
   }\n  }\n  finishEditing() {\n  }\n  init() {\n  }\n  open() {\n  }\n  \
close() {\n  }\n  getValue() {\n  }\n  setValue() {\n  }\n  focus() {\n  \
}\n};\n\n// node_modules/handsontable/editors/dateEditor/dateEditor.mjs\nvar \
import_moment2 = __toESM(require_moment(), 1);\nvar import_pikaday = \
__toESM(require_pikaday(), 1);\nvar EDITOR_TYPE6 = \"date\";\nvar \
SHORTCUTS_GROUP_EDITOR3 = \"dateEditor\";\nvar DateEditor = class extends \
TextEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE6;\n  }\n  \
/**\n   * @param {Core} hotInstance Handsontable instance.\n   * @private\n   \
*/\n  constructor(hotInstance) {\n    super(hotInstance);\n    \
this.defaultDateFormat = \"DD/MM/YYYY\";\n    this.isCellEdited = false;\n    \
this.parentDestroyed = false;\n    this.$datePicker = null;\n  }\n  init() \
{\n    if (typeof import_moment2.default !== \"function\") {\n      throw new \
Error(\"You need to include moment.js to your project.\");\n    }\n    if \
(typeof import_pikaday.default !== \"function\") {\n      throw new \
Error(\"You need to include Pikaday to your project.\");\n    }\n    \
super.init();\n    this.instance.addHook(\"afterDestroy\", () => {\n      \
this.parentDestroyed = true;\n      this.destroyElements();\n    });\n  }\n  \
/**\n   * Create data picker instance.\n   */\n  createElements() {\n    \
super.createElements();\n    this.datePicker = \
this.hot.rootDocument.createElement(\"DIV\");\n    this.datePickerStyle = \
this.datePicker.style;\n    this.datePickerStyle.position = \"absolute\";\n   \
 this.datePickerStyle.top = 0;\n    this.datePickerStyle.left = 0;\n    \
this.datePickerStyle.zIndex = 9999;\n    \
this.datePicker.setAttribute(\"dir\", this.hot.isRtl() ? \"rtl\" : \
\"ltr\");\n    addClass(this.datePicker, \"htDatepickerHolder\");\n    \
this.hot.rootDocument.body.appendChild(this.datePicker);\n    const \
eventManager = new eventManager_default(this);\n    \
eventManager.addEventListener(this.datePicker, \"mousedown\", (event2) => \
event2.stopPropagation());\n  }\n  /**\n   * Destroy data picker instance.\n  \
 */\n  destroyElements() {\n    const datePickerParentElement = \
this.datePicker.parentNode;\n    if (this.$datePicker) {\n      \
this.$datePicker.destroy();\n    }\n    if (datePickerParentElement) {\n      \
datePickerParentElement.removeChild(this.datePicker);\n    }\n  }\n  /**\n   \
* Prepare editor to appear.\n   *\n   * @param {number} row The visual row \
index.\n   * @param {number} col The visual column index.\n   * @param \
{number|string} prop The column property (passed when datasource is an array \
of objects).\n   * @param {HTMLTableCellElement} td The rendered cell \
element.\n   * @param {*} value The rendered value.\n   * @param {object} \
cellProperties The cell meta object ({@see Core#getCellMeta}).\n   */\n  \
prepare(row, col, prop, td, value, cellProperties) {\n    super.prepare(row, \
col, prop, td, value, cellProperties);\n  }\n  /**\n   * Open editor.\n   *\n \
  * @param {Event} [event=null] The event object.\n   */\n  open() {\n    let \
event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
null;\n    const shortcutManager = this.hot.getShortcutManager();\n    const \
editorContext = shortcutManager.getContext(\"editor\");\n    super.open();\n  \
  this.showDatepicker(event2);\n    editorContext.addShortcut({\n      keys: \
[[\"Enter\"]],\n      callback: (keyboardEvent) => {\n        \
keyboardEvent.stopPropagation();\n      },\n      group: \
SHORTCUTS_GROUP_EDITOR3\n    });\n  }\n  /**\n   * Close editor.\n   */\n  \
close() {\n    var _this$$datePicker;\n    this._opened = false;\n    if \
((_this$$datePicker = this.$datePicker) !== null && _this$$datePicker !== \
void 0 && _this$$datePicker.destroy) {\n      this.$datePicker.destroy();\n   \
 }\n    this.instance._registerTimeout(() => {\n      \
this.instance._refreshBorders();\n    });\n    const shortcutManager = \
this.hot.getShortcutManager();\n    const editorContext = \
shortcutManager.getContext(\"editor\");\n    \
editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR3);\n    \
super.close();\n  }\n  /**\n   * Finishes editing and start saving or \
restoring process for editing cell or last selected range.\n   *\n   * @param \
{boolean} restoreOriginalValue If true, then closes editor without saving \
value from the editor into a cell.\n   * @param {boolean} ctrlDown If true, \
then saveValue will save editor's value to each cell in the last selected \
range.\n   */\n  finishEditing() {\n    let restoreOriginalValue = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    \
let ctrlDown = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] \
: false;\n    if (restoreOriginalValue) {\n      const value = \
this.originalValue;\n      if (value !== void 0) {\n        \
this.setValue(value);\n      }\n    }\n    \
super.finishEditing(restoreOriginalValue, ctrlDown);\n  }\n  /**\n   * Show \
data picker.\n   *\n   * @param {Event} event The event object.\n   */\n  \
showDatepicker(event2) {\n    const offset3 = \
this.TD.getBoundingClientRect();\n    const dateFormat = \
this.cellProperties.dateFormat || this.defaultDateFormat;\n    const \
isMouseDown = this.instance.view.isMouseDown();\n    const isMeta = event2 ? \
isFunctionKey(event2.keyCode) : false;\n    let dateStr;\n    \
this.datePicker.style.display = \"block\";\n    this.$datePicker = new \
import_pikaday.default(this.getDatePickerConfig());\n    \
this.$datePicker._onInputFocus = function() {\n    };\n    \
this.datePickerStyle.top = `${this.hot.rootWindow.pageYOffset + offset3.top + \
outerHeight(this.TD)}px`;\n    let pickerLeftPosition = \
this.hot.rootWindow.pageXOffset;\n    if (this.hot.isRtl()) {\n      \
pickerLeftPosition = offset3.right - outerWidth(this.datePicker);\n    } else \
{\n      pickerLeftPosition = offset3.left;\n    }\n    \
this.datePickerStyle.left = `${pickerLeftPosition}px`;\n    if \
(this.originalValue) {\n      dateStr = this.originalValue;\n      if ((0, \
import_moment2.default)(dateStr, dateFormat, true).isValid()) {\n        \
this.$datePicker.setMoment((0, import_moment2.default)(dateStr, dateFormat), \
true);\n      }\n      if (this.getValue() !== this.originalValue) {\n        \
this.setValue(this.originalValue);\n      }\n      if (!isMeta && \
!isMouseDown) {\n        this.setValue(\"\");\n      }\n    } else if \
(this.cellProperties.defaultDate) {\n      dateStr = \
this.cellProperties.defaultDate;\n      if ((0, \
import_moment2.default)(dateStr, dateFormat, true).isValid()) {\n        \
this.$datePicker.setMoment((0, import_moment2.default)(dateStr, dateFormat), \
true);\n      }\n      if (!isMeta && !isMouseDown) {\n        \
this.setValue(\"\");\n      }\n    } else {\n      \
this.$datePicker.gotoToday();\n    }\n  }\n  /**\n   * Hide data picker.\n   \
*/\n  hideDatepicker() {\n    this.datePickerStyle.display = \"none\";\n    \
this.$datePicker.hide();\n  }\n  /**\n   * Get date picker options.\n   *\n   \
* @returns {object}\n   */\n  getDatePickerConfig() {\n    const htInput = \
this.TEXTAREA;\n    const options = {};\n    if (this.cellProperties && \
this.cellProperties.datePickerConfig) {\n      deepExtend(options, \
this.cellProperties.datePickerConfig);\n    }\n    const origOnSelect = \
options.onSelect;\n    const origOnClose = options.onClose;\n    \
options.field = htInput;\n    options.trigger = htInput;\n    \
options.container = this.datePicker;\n    options.bound = false;\n    \
options.format = options.format || this.defaultDateFormat;\n    \
options.reposition = options.reposition || false;\n    options.isRTL = \
false;\n    options.onSelect = (value) => {\n      let dateStr = value;\n     \
 if (!isNaN(dateStr.getTime())) {\n        dateStr = (0, \
import_moment2.default)(dateStr).format(this.cellProperties.dateFormat || \
this.defaultDateFormat);\n      }\n      this.setValue(dateStr);\n      \
this.hideDatepicker();\n      if (origOnSelect) {\n        origOnSelect();\n  \
    }\n    };\n    options.onClose = () => {\n      if \
(!this.parentDestroyed) {\n        this.finishEditing(false);\n      }\n      \
if (origOnClose) {\n        origOnClose();\n      }\n    };\n    return \
options;\n  }\n};\n\n// \
node_modules/handsontable/editors/dropdownEditor/dropdownEditor.mjs\nvar \
EDITOR_TYPE7 = \"dropdown\";\nvar DropdownEditor = class extends \
AutocompleteEditor {\n  static get EDITOR_TYPE() {\n    return \
EDITOR_TYPE7;\n  }\n  /**\n   * @param {number} row The visual row index.\n   \
* @param {number} col The visual column index.\n   * @param {number|string} \
prop The column property (passed when datasource is an array of objects).\n   \
* @param {HTMLTableCellElement} td The rendered cell element.\n   * @param \
{*} value The rendered value.\n   * @param {object} cellProperties The cell \
meta object ({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, \
value, cellProperties) {\n    super.prepare(row, col, prop, td, value, \
cellProperties);\n    this.cellProperties.filter = false;\n    \
this.cellProperties.strict = true;\n  \
}\n};\npluginHooks_default.getSingleton().add(\"beforeValidate\", \
function(value, row, col) {\n  const cellMeta = this.getCellMeta(row, \
this.propToCol(col));\n  if (cellMeta.editor === DropdownEditor) {\n    if \
(cellMeta.strict === void 0) {\n      cellMeta.filter = false;\n      \
cellMeta.strict = true;\n    }\n  }\n});\n\n// \
node_modules/handsontable/editors/numericEditor/numericEditor.mjs\nvar \
EDITOR_TYPE8 = \"numeric\";\nvar NumericEditor = class extends TextEditor {\n \
 static get EDITOR_TYPE() {\n    return EDITOR_TYPE8;\n  }\n};\n\n// \
node_modules/handsontable/editors/passwordEditor/passwordEditor.mjs\nvar \
EDITOR_TYPE9 = \"password\";\nvar PasswordEditor = class extends TextEditor \
{\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE9;\n  }\n  \
createElements() {\n    super.createElements();\n    this.TEXTAREA = \
this.hot.rootDocument.createElement(\"input\");\n    \
this.TEXTAREA.setAttribute(\"type\", \"password\");\n    \
this.TEXTAREA.setAttribute(\"data-hot-input\", \"\");\n    \
this.TEXTAREA.className = \"handsontableInput\";\n    this.textareaStyle = \
this.TEXTAREA.style;\n    this.textareaStyle.width = 0;\n    \
this.textareaStyle.height = 0;\n    empty(this.TEXTAREA_PARENT);\n    \
this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);\n  }\n};\n\n// \
node_modules/handsontable/editors/selectEditor/selectEditor.mjs\nvar \
EDITOR_VISIBLE_CLASS_NAME2 = \"ht_editor_visible\";\nvar SHORTCUTS_GROUP4 = \
\"selectEditor\";\nvar EDITOR_TYPE10 = \"select\";\nvar SelectEditor = class \
extends BaseEditor {\n  static get EDITOR_TYPE() {\n    return \
EDITOR_TYPE10;\n  }\n  /**\n   * Initializes editor instance, DOM Element and \
mount hooks.\n   */\n  init() {\n    this.select = \
this.hot.rootDocument.createElement(\"SELECT\");\n    addClass(this.select, \
\"htSelectEditor\");\n    this.select.style.display = \"none\";\n    \
this.hot.rootElement.appendChild(this.select);\n    this.registerHooks();\n  \
}\n  /**\n   * Returns select's value.\n   *\n   * @returns {*}\n   */\n  \
getValue() {\n    return this.select.value;\n  }\n  /**\n   * Sets value in \
the select element.\n   *\n   * @param {*} value A new select's value.\n   \
*/\n  setValue(value) {\n    this.select.value = value;\n  }\n  /**\n   * \
Opens the editor and adjust its size.\n   */\n  open() {\n    this._opened = \
true;\n    this.refreshDimensions();\n    this.select.style.display = \"\";\n \
   const shortcutManager = this.hot.getShortcutManager();\n    \
shortcutManager.setActiveContextName(\"editor\");\n    \
this.registerShortcuts();\n  }\n  /**\n   * Closes the editor.\n   */\n  \
close() {\n    this._opened = false;\n    this.select.style.display = \
\"none\";\n    if (hasClass(this.select, EDITOR_VISIBLE_CLASS_NAME2)) {\n     \
 removeClass(this.select, EDITOR_VISIBLE_CLASS_NAME2);\n    }\n    \
this.unregisterShortcuts();\n    this.clearHooks();\n  }\n  /**\n   * Sets \
focus state on the select element.\n   */\n  focus() {\n    \
this.select.focus();\n  }\n  /**\n   * Binds hooks to refresh editor's size \
after scrolling of the viewport or resizing of columns/rows.\n   *\n   * \
@private\n   */\n  registerHooks() {\n    \
this.addHook(\"afterScrollHorizontally\", () => this.refreshDimensions());\n  \
  this.addHook(\"afterScrollVertically\", () => this.refreshDimensions());\n  \
  this.addHook(\"afterColumnResize\", () => this.refreshDimensions());\n    \
this.addHook(\"afterRowResize\", () => this.refreshDimensions());\n  }\n  \
/**\n   * Prepares editor's meta data and a list of available options.\n   \
*\n   * @param {number} row The visual row index.\n   * @param {number} col \
The visual column index.\n   * @param {number|string} prop The column \
property (passed when datasource is an array of objects).\n   * @param \
{HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value \
The rendered value.\n   * @param {object} cellProperties The cell meta object \
({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, \
cellProperties) {\n    super.prepare(row, col, prop, td, value, \
cellProperties);\n    const selectOptions = \
this.cellProperties.selectOptions;\n    let options;\n    if (typeof \
selectOptions === \"function\") {\n      options = \
this.prepareOptions(selectOptions(this.row, this.col, this.prop));\n    } \
else {\n      options = this.prepareOptions(selectOptions);\n    }\n    \
empty(this.select);\n    objectEach(options, (optionValue, key) => {\n      \
const optionElement = this.hot.rootDocument.createElement(\"OPTION\");\n      \
optionElement.value = key;\n      fastInnerHTML(optionElement, \
optionValue);\n      this.select.appendChild(optionElement);\n    });\n  }\n  \
/**\n   * Creates consistent list of available options.\n   *\n   * \
@private\n   * @param {Array|object} optionsToPrepare The list of the values \
to render in the select eleemnt.\n   * @returns {object}\n   */\n  \
prepareOptions(optionsToPrepare) {\n    let preparedOptions = {};\n    if \
(Array.isArray(optionsToPrepare)) {\n      for (let i = 0, len = \
optionsToPrepare.length; i < len; i++) {\n        \
preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];\n      }\n    } \
else if (typeof optionsToPrepare === \"object\") {\n      preparedOptions = \
optionsToPrepare;\n    }\n    return preparedOptions;\n  }\n  /**\n   * \
Refreshes editor's value using source data.\n   *\n   * @private\n   */\n  \
refreshValue() {\n    const sourceData = \
this.hot.getSourceDataAtCell(this.row, this.prop);\n    this.originalValue = \
sourceData;\n    this.setValue(sourceData);\n    this.refreshDimensions();\n  \
}\n  /**\n   * Refreshes editor's size and position.\n   *\n   * @private\n   \
*/\n  refreshDimensions() {\n    if (this.state !== EDITOR_STATE.EDITING) {\n \
     return;\n    }\n    this.TD = this.getEditedCell();\n    if (!this.TD) \
{\n      this.close();\n      return;\n    }\n    const {\n      top: top2,\n \
     start,\n      width,\n      height\n    } = this.getEditedCellRect();\n  \
  const selectStyle = this.select.style;\n    selectStyle.height = \
`${height}px`;\n    selectStyle.width = `${width}px`;\n    selectStyle.top = \
`${top2}px`;\n    selectStyle[this.hot.isRtl() ? \"right\" : \"left\"] = \
`${start}px`;\n    selectStyle.margin = \"0px\";\n    addClass(this.select, \
EDITOR_VISIBLE_CLASS_NAME2);\n  }\n  /**\n   * Register shortcuts responsible \
for handling editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n   \
 const shortcutManager = this.hot.getShortcutManager();\n    const \
editorContext = shortcutManager.getContext(\"editor\");\n    const \
contextConfig = {\n      group: SHORTCUTS_GROUP4\n    };\n    if \
(this.isInFullEditMode() === false) {\n      return;\n    }\n    \
editorContext.addShortcuts([{\n      keys: [[\"ArrowUp\"]],\n      callback: \
() => {\n        const previousOptionIndex = this.select.selectedIndex - 1;\n \
       if (previousOptionIndex >= 0) {\n          \
this.select[previousOptionIndex].selected = true;\n        }\n      }\n    }, \
{\n      keys: [[\"ArrowDown\"]],\n      callback: () => {\n        const \
nextOptionIndex = this.select.selectedIndex + 1;\n        if (nextOptionIndex \
<= this.select.length - 1) {\n          this.select[nextOptionIndex].selected \
= true;\n        }\n      }\n    }], contextConfig);\n  }\n  /**\n   * \
Unregister shortcuts responsible for handling editor.\n   *\n   * @private\n  \
 */\n  unregisterShortcuts() {\n    const shortcutManager = \
this.hot.getShortcutManager();\n    const editorContext = \
shortcutManager.getContext(\"editor\");\n    \
editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP4);\n  }\n};\n\n// \
node_modules/handsontable/editors/timeEditor/timeEditor.mjs\nvar \
EDITOR_TYPE11 = \"time\";\nvar TimeEditor = class extends TextEditor {\n  \
static get EDITOR_TYPE() {\n    return EDITOR_TYPE11;\n  }\n  /**\n   * \
Prepares editor's meta data.\n   *\n   * @param {number} row The visual row \
index.\n   * @param {number} col The visual column index.\n   * @param \
{number|string} prop The column property (passed when datasource is an array \
of objects).\n   * @param {HTMLTableCellElement} td The rendered cell \
element.\n   * @param {*} value The rendered value.\n   * @param {object} \
cellProperties The cell meta object ({@see Core#getCellMeta}).\n   */\n  \
prepare(row, col, prop, td, value, cellProperties) {\n    super.prepare(row, \
col, prop, td, value, cellProperties);\n    this.TEXTAREA.dir = \"ltr\";\n  \
}\n};\n\n// node_modules/handsontable/editors/index.mjs\nfunction \
registerAllEditors() {\n  _register(BaseEditor);\n  \
_register(AutocompleteEditor);\n  _register(CheckboxEditor);\n  \
_register(DateEditor);\n  _register(DropdownEditor);\n  \
_register(HandsontableEditor);\n  _register(NumericEditor);\n  \
_register(PasswordEditor);\n  _register(SelectEditor);\n  \
_register(TextEditor);\n  _register(TimeEditor);\n}\n\n// \
node_modules/handsontable/renderers/htmlRenderer/htmlRenderer.mjs\nvar \
RENDERER_TYPE3 = \"html\";\nfunction htmlRenderer(instance, TD, row, col, \
prop, value, cellProperties) {\n  baseRenderer.apply(this, [instance, TD, \
row, col, prop, value, cellProperties]);\n  fastInnerHTML(TD, value === null \
|| value === void 0 ? \"\" : value, false);\n}\nhtmlRenderer.RENDERER_TYPE = \
RENDERER_TYPE3;\n\n// \
node_modules/handsontable/renderers/autocompleteRenderer/autocompleteRenderer\
.mjs\nvar RENDERER_TYPE4 = \"autocomplete\";\nfunction \
autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {\n \
 const {\n    rootDocument\n  } = instance;\n  const rendererFunc = \
cellProperties.allowHtml ? htmlRenderer : textRenderer;\n  const ARROW = \
rootDocument.createElement(\"DIV\");\n  ARROW.className = \
\"htAutocompleteArrow\";\n  \
ARROW.appendChild(rootDocument.createTextNode(String.fromCharCode(9660)));\n  \
rendererFunc.apply(this, [instance, TD, row, col, prop, value, \
cellProperties]);\n  if (!TD.firstChild) {\n    \
TD.appendChild(rootDocument.createTextNode(String.fromCharCode(160)));\n  }\n \
 TD.insertBefore(ARROW, TD.firstChild);\n  addClass(TD, \
\"htAutocomplete\");\n  if (!instance.acArrowListener) {\n    const \
eventManager = new eventManager_default(instance);\n    \
instance.acArrowListener = function(event2) {\n      if \
(hasClass(event2.target, \"htAutocompleteArrow\")) {\n        \
instance.view._wt.getSetting(\"onCellDblClick\", null, \
instance._createCellCoords(row, col), TD);\n      }\n    };\n    \
eventManager.addEventListener(instance.rootElement, \"mousedown\", \
instance.acArrowListener);\n    instance.addHookOnce(\"afterDestroy\", () => \
{\n      eventManager.destroy();\n    });\n  \
}\n}\nautocompleteRenderer.RENDERER_TYPE = RENDERER_TYPE4;\n\n// \
node_modules/handsontable/renderers/checkboxRenderer/checkboxRenderer.mjs\nva\
r isListeningKeyDownEvent = /* @__PURE__ */ new WeakMap();\nvar \
isCheckboxListenerAdded = /* @__PURE__ */ new WeakMap();\nvar BAD_VALUE_CLASS \
= \"htBadValue\";\nvar ATTR_ROW = \"data-row\";\nvar ATTR_COLUMN = \
\"data-col\";\nvar SHORTCUTS_GROUP5 = \"checkboxRenderer\";\nvar \
RENDERER_TYPE5 = \
\"checkbox\";\npluginHooks_default.getSingleton().add(\"modifyAutoColumnSizeS\
eed\", function(bundleSeed, cellMeta, cellValue) {\n  const {\n    label,\n   \
 type,\n    row,\n    column,\n    prop\n  } = cellMeta;\n  if (type !== \
RENDERER_TYPE5) {\n    return;\n  }\n  if (label) {\n    const {\n      \
value: labelValue,\n      property: labelProperty\n    } = label;\n    let \
labelText = cellValue;\n    if (labelValue) {\n      labelText = typeof \
labelValue === \"function\" ? labelValue(row, column, prop, cellValue) : \
labelValue;\n    } else if (labelProperty) {\n      const labelData = \
this.getDataAtRowProp(row, labelProperty);\n      labelText = labelData !== \
null ? labelData : cellValue;\n    }\n    bundleSeed = labelText;\n  }\n  \
return bundleSeed;\n});\nfunction checkboxRenderer(instance, TD, row, col, \
prop, value, cellProperties) {\n  const {\n    rootDocument\n  } = \
instance;\n  baseRenderer.apply(this, [instance, TD, row, col, prop, value, \
cellProperties]);\n  registerEvents(instance);\n  let input = \
createInput(rootDocument);\n  const labelOptions = cellProperties.label;\n  \
let badValue = false;\n  if (typeof cellProperties.checkedTemplate === \
\"undefined\") {\n    cellProperties.checkedTemplate = true;\n  }\n  if \
(typeof cellProperties.uncheckedTemplate === \"undefined\") {\n    \
cellProperties.uncheckedTemplate = false;\n  }\n  empty(TD);\n  if (value === \
cellProperties.checkedTemplate || \
stringify(value).toLocaleLowerCase(cellProperties.locale) === \
stringify(cellProperties.checkedTemplate).toLocaleLowerCase(cellProperties.lo\
cale)) {\n    input.checked = true;\n  } else if (value === \
cellProperties.uncheckedTemplate || \
stringify(value).toLocaleLowerCase(cellProperties.locale) === \
stringify(cellProperties.uncheckedTemplate).toLocaleLowerCase(cellProperties.\
locale)) {\n    input.checked = false;\n  } else if (isEmpty(value)) {\n    \
addClass(input, \"noValue\");\n  } else {\n    input.style.display = \
\"none\";\n    addClass(input, BAD_VALUE_CLASS);\n    badValue = true;\n  }\n \
 input.setAttribute(ATTR_ROW, row);\n  input.setAttribute(ATTR_COLUMN, \
col);\n  if (!badValue && labelOptions) {\n    let labelText = \"\";\n    if \
(labelOptions.value) {\n      labelText = typeof labelOptions.value === \
\"function\" ? labelOptions.value.call(this, row, col, prop, value) : \
labelOptions.value;\n    } else if (labelOptions.property) {\n      const \
labelValue = instance.getDataAtRowProp(row, labelOptions.property);\n      \
labelText = labelValue !== null ? labelValue : \"\";\n    }\n    const label \
= createLabel(rootDocument, labelText, labelOptions.separated !== true);\n    \
if (labelOptions.position === \"before\") {\n      if \
(labelOptions.separated) {\n        TD.appendChild(label);\n        \
TD.appendChild(input);\n      } else {\n        label.appendChild(input);\n   \
     input = label;\n      }\n    } else if (!labelOptions.position || \
labelOptions.position === \"after\") {\n      if (labelOptions.separated) {\n \
       TD.appendChild(input);\n        TD.appendChild(label);\n      } else \
{\n        label.insertBefore(input, label.firstChild);\n        input = \
label;\n      }\n    }\n  }\n  if (!labelOptions || labelOptions && \
!labelOptions.separated) {\n    TD.appendChild(input);\n  }\n  if (badValue) \
{\n    TD.appendChild(rootDocument.createTextNode(\"#bad-value#\"));\n  }\n  \
if (!isListeningKeyDownEvent.has(instance)) {\n    \
isListeningKeyDownEvent.set(instance, true);\n    registerShortcuts();\n  }\n \
 function registerShortcuts() {\n    const shortcutManager = \
instance.getShortcutManager();\n    const gridContext = \
shortcutManager.getContext(\"grid\");\n    const config = {\n      group: \
SHORTCUTS_GROUP5\n    };\n    gridContext.addShortcuts([{\n      keys: \
[[\"space\"]],\n      callback: () => {\n        \
changeSelectedCheckboxesState();\n        return \
!areSelectedCheckboxCells();\n      }\n    }, {\n      keys: [[\"enter\"]],\n \
     callback: () => {\n        changeSelectedCheckboxesState();\n        \
return !areSelectedCheckboxCells();\n      },\n      runOnlyIf: () => \
instance.getSettings().enterBeginsEditing\n    }, {\n      keys: \
[[\"delete\"], [\"backspace\"]],\n      callback: () => {\n        \
changeSelectedCheckboxesState(true);\n        return \
!areSelectedCheckboxCells();\n      },\n      relativeToGroup: \
SHORTCUTS_GROUP_EDITOR,\n      position: \"before\"\n    }], config);\n  }\n  \
function changeSelectedCheckboxesState() {\n    let uncheckCheckbox = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    \
const selRange = instance.getSelectedRange();\n    if (!selRange) {\n      \
return;\n    }\n    for (let key = 0; key < selRange.length; key++) {\n      \
const {\n        row: startRow,\n        col: startColumn\n      } = \
selRange[key].getTopStartCorner();\n      const {\n        row: endRow,\n     \
   col: endColumn\n      } = selRange[key].getBottomEndCorner();\n      const \
changes = [];\n      for (let visualRow = startRow; visualRow <= endRow; \
visualRow += 1) {\n        for (let visualColumn = startColumn; visualColumn \
<= endColumn; visualColumn += 1) {\n          const cachedCellProperties = \
instance.getCellMeta(visualRow, visualColumn);\n          if \
(cachedCellProperties.type !== \"checkbox\") {\n            return;\n         \
 }\n          if (cachedCellProperties.readOnly === true) {\n            \
continue;\n          }\n          if (typeof \
cachedCellProperties.checkedTemplate === \"undefined\") {\n            \
cachedCellProperties.checkedTemplate = true;\n          }\n          if \
(typeof cachedCellProperties.uncheckedTemplate === \"undefined\") {\n         \
   cachedCellProperties.uncheckedTemplate = false;\n          }\n          \
const dataAtCell = instance.getDataAtCell(visualRow, visualColumn);\n         \
 if (uncheckCheckbox === false) {\n            if \
([cachedCellProperties.checkedTemplate, \
cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {\n    \
          changes.push([visualRow, visualColumn, \
cachedCellProperties.uncheckedTemplate]);\n            } else if \
([cachedCellProperties.uncheckedTemplate, \
cachedCellProperties.uncheckedTemplate.toString(), null, void \
0].includes(dataAtCell)) {\n              changes.push([visualRow, \
visualColumn, cachedCellProperties.checkedTemplate]);\n            }\n        \
  } else {\n            changes.push([visualRow, visualColumn, \
cachedCellProperties.uncheckedTemplate]);\n          }\n        }\n      }\n  \
    if (changes.length > 0) {\n        instance.setDataAtCell(changes);\n     \
 }\n    }\n  }\n  function areSelectedCheckboxCells() {\n    const selRange = \
instance.getSelectedRange();\n    if (!selRange) {\n      return;\n    }\n    \
for (let key = 0; key < selRange.length; key++) {\n      const topLeft = \
selRange[key].getTopStartCorner();\n      const bottomRight = \
selRange[key].getBottomEndCorner();\n      for (let visualRow = topLeft.row; \
visualRow <= bottomRight.row; visualRow++) {\n        for (let visualColumn = \
topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {\n          \
const cachedCellProperties = instance.getCellMeta(visualRow, visualColumn);\n \
         if (cachedCellProperties.type !== \"checkbox\") {\n            \
return false;\n          }\n          const cell = \
instance.getCell(visualRow, visualColumn);\n          if (cell === null || \
cell === void 0) {\n            return true;\n          } else {\n            \
const checkboxes = cell.querySelectorAll(\"input[type=checkbox]\");\n         \
   if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {\n           \
   return true;\n            }\n          }\n        }\n      }\n    }\n    \
return false;\n  }\n}\ncheckboxRenderer.RENDERER_TYPE = \
RENDERER_TYPE5;\nfunction registerEvents(instance) {\n  let eventManager = \
isCheckboxListenerAdded.get(instance);\n  if (!eventManager) {\n    const {\n \
     rootElement\n    } = instance;\n    eventManager = new \
eventManager_default(instance);\n    \
eventManager.addEventListener(rootElement, \"click\", (event2) => \
onClick(event2, instance));\n    eventManager.addEventListener(rootElement, \
\"mouseup\", (event2) => onMouseUp(event2, instance));\n    \
eventManager.addEventListener(rootElement, \"change\", (event2) => \
onChange(event2, instance));\n    isCheckboxListenerAdded.set(instance, \
eventManager);\n  }\n  return eventManager;\n}\nfunction \
createInput(rootDocument) {\n  const input = \
rootDocument.createElement(\"input\");\n  input.className = \
\"htCheckboxRendererInput\";\n  input.type = \"checkbox\";\n  \
input.setAttribute(\"autocomplete\", \"off\");\n  \
input.setAttribute(\"tabindex\", \"-1\");\n  return \
input.cloneNode(false);\n}\nfunction createLabel(rootDocument, text, \
fullWidth) {\n  const label = rootDocument.createElement(\"label\");\n  \
label.className = `htCheckboxRendererLabel ${fullWidth ? \"fullWidth\" : \
\"\"}`;\n  label.appendChild(rootDocument.createTextNode(text));\n  return \
label.cloneNode(true);\n}\nfunction onMouseUp(event2, instance) {\n  const \
{\n    target\n  } = event2;\n  if (!isCheckboxInput(target)) {\n    \
return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || \
!target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  \
setTimeout(instance.listen, 10);\n}\nfunction onClick(event2, instance) {\n  \
const {\n    target\n  } = event2;\n  if (!isCheckboxInput(target)) {\n    \
return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || \
!target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = \
parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = \
parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = \
instance.getCellMeta(row, col);\n  if (cellProperties.readOnly) {\n    \
event2.preventDefault();\n  }\n}\nfunction onChange(event2, instance) {\n  \
const {\n    target\n  } = event2;\n  if (!isCheckboxInput(target)) {\n    \
return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || \
!target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = \
parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = \
parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = \
instance.getCellMeta(row, col);\n  if (!cellProperties.readOnly) {\n    let \
newCheckboxValue = null;\n    if (event2.target.checked) {\n      \
newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? true : \
cellProperties.checkedTemplate;\n    } else {\n      newCheckboxValue = \
cellProperties.uncheckedTemplate === void 0 ? false : \
cellProperties.uncheckedTemplate;\n    }\n    instance.setDataAtCell(row, \
col, newCheckboxValue);\n  }\n}\nfunction isCheckboxInput(element) {\n  \
return element.tagName === \"INPUT\" && element.getAttribute(\"type\") === \
\"checkbox\";\n}\n\n// \
node_modules/handsontable/renderers/numericRenderer/numericRenderer.mjs\nvar \
import_numbro = __toESM(require_numbro_min(), 1);\nvar RENDERER_TYPE6 = \
\"numeric\";\nfunction numericRenderer(instance, TD, row, col, prop, value, \
cellProperties) {\n  let newValue = value;\n  if (isNumeric(newValue)) {\n    \
const numericFormat = cellProperties.numericFormat;\n    const cellCulture = \
numericFormat && numericFormat.culture || \"-\";\n    const cellFormatPattern \
= numericFormat && numericFormat.pattern;\n    const className = \
cellProperties.className || \"\";\n    const classArr = className.length ? \
className.split(\" \") : [];\n    if (typeof cellCulture !== \"undefined\" && \
!import_numbro.default.languages()[cellCulture]) {\n      const shortTag = \
cellCulture.replace(\"-\", \"\");\n      const langData = \
import_numbro.default.allLanguages ? \
import_numbro.default.allLanguages[cellCulture] : \
import_numbro.default[shortTag];\n      if (langData) {\n        \
import_numbro.default.registerLanguage(langData);\n      }\n    }\n    \
import_numbro.default.setLanguage(cellCulture);\n    newValue = (0, \
import_numbro.default)(newValue).format(cellFormatPattern || \"0\");\n    if \
(classArr.indexOf(\"htLeft\") < 0 && classArr.indexOf(\"htCenter\") < 0 && \
classArr.indexOf(\"htRight\") < 0 && classArr.indexOf(\"htJustify\") < 0) {\n \
     classArr.push(\"htRight\");\n    }\n    if \
(classArr.indexOf(\"htNumeric\") < 0) {\n      \
classArr.push(\"htNumeric\");\n    }\n    cellProperties.className = \
classArr.join(\" \");\n    TD.dir = \"ltr\";\n  }\n  textRenderer(instance, \
TD, row, col, prop, newValue, \
cellProperties);\n}\nnumericRenderer.RENDERER_TYPE = RENDERER_TYPE6;\n\n// \
node_modules/handsontable/renderers/passwordRenderer/passwordRenderer.mjs\nva\
r RENDERER_TYPE7 = \"password\";\nfunction passwordRenderer(instance, TD, \
row, col, prop, value, cellProperties) {\n  textRenderer.apply(this, \
[instance, TD, row, col, prop, value, cellProperties]);\n  const hashLength = \
cellProperties.hashLength || TD.innerHTML.length;\n  const hashSymbol = \
cellProperties.hashSymbol || \"*\";\n  let hash = \"\";\n  \
rangeEach(hashLength - 1, () => {\n    hash += hashSymbol;\n  });\n  \
fastInnerHTML(TD, hash);\n}\npasswordRenderer.RENDERER_TYPE = \
RENDERER_TYPE7;\n\n// \
node_modules/handsontable/renderers/timeRenderer/timeRenderer.mjs\nvar \
RENDERER_TYPE8 = \"time\";\nfunction timeRenderer(instance, TD, row, col, \
prop, value, cellProperties) {\n  textRenderer.apply(this, [instance, TD, \
row, col, prop, value, cellProperties]);\n  TD.dir = \
\"ltr\";\n}\ntimeRenderer.RENDERER_TYPE = RENDERER_TYPE8;\n\n// \
node_modules/handsontable/renderers/index.mjs\nfunction \
registerAllRenderers() {\n  _register2(autocompleteRenderer);\n  \
_register2(baseRenderer);\n  _register2(checkboxRenderer);\n  \
_register2(htmlRenderer);\n  _register2(numericRenderer);\n  \
_register2(passwordRenderer);\n  _register2(textRenderer);\n  \
_register2(timeRenderer);\n}\n\n// \
node_modules/handsontable/validators/autocompleteValidator/autocompleteValida\
tor.mjs\nvar VALIDATOR_TYPE = \"autocomplete\";\nfunction \
autocompleteValidator(value, callback) {\n  let valueToValidate = value;\n  \
if (valueToValidate === null || valueToValidate === void 0) {\n    \
valueToValidate = \"\";\n  }\n  if (this.allowEmpty && valueToValidate === \
\"\") {\n    callback(true);\n    return;\n  }\n  if (this.strict && \
this.source) {\n    if (typeof this.source === \"function\") {\n      \
this.source(valueToValidate, process(valueToValidate, callback));\n    } else \
{\n      process(valueToValidate, callback)(this.source);\n    }\n  } else \
{\n    callback(true);\n  }\n}\nautocompleteValidator.VALIDATOR_TYPE = \
VALIDATOR_TYPE;\nfunction process(value, callback) {\n  const originalVal = \
value;\n  return function(source) {\n    let found = false;\n    for (let s = \
0, slen = source.length; s < slen; s++) {\n      if (originalVal === \
source[s]) {\n        found = true;\n        break;\n      }\n    }\n    \
callback(found);\n  };\n}\n\n// \
node_modules/handsontable/validators/dateValidator/dateValidator.mjs\nvar \
import_moment3 = __toESM(require_moment(), 1);\n\n// \
node_modules/handsontable/helpers/date.mjs\nvar date_exports = \
{};\n__export(date_exports, {\n  getNormalizedDate: () => \
getNormalizedDate\n});\nfunction getNormalizedDate(dateString) {\n  const \
nativeDate = new Date(dateString);\n  if (!isNaN((/* @__PURE__ */ new \
Date(`${dateString}T00:00`)).getDate())) {\n    return new \
Date(nativeDate.getTime() + nativeDate.getTimezoneOffset() * 6e4);\n  }\n  \
return nativeDate;\n}\n\n// \
node_modules/handsontable/validators/dateValidator/dateValidator.mjs\nvar \
VALIDATOR_TYPE2 = \"date\";\nfunction dateValidator(value, callback) {\n  \
const dateEditor = _getEditorInstance(EDITOR_TYPE6, this.instance);\n  let \
valueToValidate = value;\n  let valid = true;\n  if (valueToValidate === null \
|| valueToValidate === void 0) {\n    valueToValidate = \"\";\n  }\n  let \
isValidFormat = (0, import_moment3.default)(valueToValidate, this.dateFormat \
|| dateEditor.defaultDateFormat, true).isValid();\n  let isValidDate = (0, \
import_moment3.default)(new Date(valueToValidate)).isValid() || \
isValidFormat;\n  if (this.allowEmpty && valueToValidate === \"\") {\n    \
isValidDate = true;\n    isValidFormat = true;\n  }\n  if (!isValidDate) {\n  \
  valid = false;\n  }\n  if (!isValidDate && isValidFormat) {\n    valid = \
true;\n  }\n  if (isValidDate && !isValidFormat) {\n    if \
(this.correctFormat === true) {\n      const correctedValue = \
correctFormat(valueToValidate, this.dateFormat);\n      const row = \
this.instance.toVisualRow(this.row);\n      const column = \
this.instance.toVisualColumn(this.col);\n      \
this.instance.setDataAtCell(row, column, correctedValue, \
\"dateValidator\");\n      valid = true;\n    } else {\n      valid = \
false;\n    }\n  }\n  callback(valid);\n}\ndateValidator.VALIDATOR_TYPE = \
VALIDATOR_TYPE2;\nfunction correctFormat(value, dateFormat) {\n  const \
dateFromDate = (0, import_moment3.default)(getNormalizedDate(value));\n  \
const dateFromMoment = (0, import_moment3.default)(value, dateFormat);\n  \
const isAlphanumeric = value.search(/[A-z]/g) > -1;\n  let date;\n  if \
(dateFromDate.isValid() && dateFromDate.format(\"x\") === \
dateFromMoment.format(\"x\") || !dateFromMoment.isValid() || isAlphanumeric) \
{\n    date = dateFromDate;\n  } else {\n    date = dateFromMoment;\n  }\n  \
return date.format(dateFormat);\n}\n\n// \
node_modules/handsontable/validators/numericValidator/numericValidator.mjs\nv\
ar VALIDATOR_TYPE3 = \"numeric\";\nfunction numericValidator(value, callback) \
{\n  let valueToValidate = value;\n  if (valueToValidate === null || \
valueToValidate === void 0) {\n    valueToValidate = \"\";\n  }\n  if \
(this.allowEmpty && valueToValidate === \"\") {\n    callback(true);\n  } \
else if (valueToValidate === \"\") {\n    callback(false);\n  } else {\n    \
callback(isNumeric(value));\n  }\n}\nnumericValidator.VALIDATOR_TYPE = \
VALIDATOR_TYPE3;\n\n// \
node_modules/handsontable/validators/timeValidator/timeValidator.mjs\nvar \
import_moment4 = __toESM(require_moment(), 1);\nvar STRICT_FORMATS = [\n  \
\"YYYY-MM-DDTHH:mm:ss.SSSZ\",\n  \"X\",\n  // Unix timestamp\n  \"x\"\n  // \
Unix ms timestamp\n];\nvar VALIDATOR_TYPE4 = \"time\";\nfunction \
timeValidator(value, callback) {\n  const timeFormat = this.timeFormat || \
\"h:mm:ss a\";\n  let valid = true;\n  let valueToValidate = value;\n  if \
(valueToValidate === null) {\n    valueToValidate = \"\";\n  }\n  \
valueToValidate = /^\\d{3,}$/.test(valueToValidate) ? \
parseInt(valueToValidate, 10) : valueToValidate;\n  const twoDigitValue = \
/^\\d{1,2}$/.test(valueToValidate);\n  if (twoDigitValue) {\n    \
valueToValidate += \":00\";\n  }\n  const date = (0, \
import_moment4.default)(valueToValidate, STRICT_FORMATS, true).isValid() ? \
(0, import_moment4.default)(valueToValidate) : (0, \
import_moment4.default)(valueToValidate, timeFormat);\n  let isValidTime = \
date.isValid();\n  let isValidFormat = (0, \
import_moment4.default)(valueToValidate, timeFormat, true).isValid() && \
!twoDigitValue;\n  if (this.allowEmpty && valueToValidate === \"\") {\n    \
isValidTime = true;\n    isValidFormat = true;\n  }\n  if (!isValidTime) {\n  \
  valid = false;\n  }\n  if (!isValidTime && isValidFormat) {\n    valid = \
true;\n  }\n  if (isValidTime && !isValidFormat) {\n    if \
(this.correctFormat === true) {\n      const correctedValue = \
date.format(timeFormat);\n      const row = \
this.instance.toVisualRow(this.row);\n      const column = \
this.instance.toVisualColumn(this.col);\n      \
this.instance.setDataAtCell(row, column, correctedValue, \
\"timeValidator\");\n      valid = true;\n    } else {\n      valid = \
false;\n    }\n  }\n  callback(valid);\n}\ntimeValidator.VALIDATOR_TYPE = \
VALIDATOR_TYPE4;\n\n// \
node_modules/handsontable/validators/index.mjs\nfunction \
registerAllValidators() {\n  _register3(autocompleteValidator);\n  \
_register3(dateValidator);\n  _register3(numericValidator);\n  \
_register3(timeValidator);\n}\n\n// \
node_modules/handsontable/cellTypes/autocompleteType/autocompleteType.mjs\nva\
r CELL_TYPE3 = \"autocomplete\";\nvar AutocompleteCellType = {\n  CELL_TYPE: \
CELL_TYPE3,\n  editor: AutocompleteEditor,\n  renderer: \
autocompleteRenderer,\n  validator: autocompleteValidator\n};\n\n// \
node_modules/handsontable/cellTypes/checkboxType/checkboxType.mjs\nvar \
CELL_TYPE4 = \"checkbox\";\nvar CheckboxCellType = {\n  CELL_TYPE: \
CELL_TYPE4,\n  editor: CheckboxEditor,\n  renderer: \
checkboxRenderer\n};\n\n// \
node_modules/handsontable/cellTypes/dateType/dateType.mjs\nvar CELL_TYPE5 = \
\"date\";\nvar DateCellType = {\n  CELL_TYPE: CELL_TYPE5,\n  editor: \
DateEditor,\n  // displays small gray arrow on right side of the cell\n  \
renderer: autocompleteRenderer,\n  validator: dateValidator\n};\n\n// \
node_modules/handsontable/cellTypes/dropdownType/dropdownType.mjs\nvar \
CELL_TYPE6 = \"dropdown\";\nvar DropdownCellType = {\n  CELL_TYPE: \
CELL_TYPE6,\n  editor: DropdownEditor,\n  // displays small gray arrow on \
right side of the cell\n  renderer: autocompleteRenderer,\n  validator: \
autocompleteValidator\n};\n\n// \
node_modules/handsontable/cellTypes/handsontableType/handsontableType.mjs\nva\
r CELL_TYPE7 = \"handsontable\";\nvar HandsontableCellType = {\n  CELL_TYPE: \
CELL_TYPE7,\n  editor: HandsontableEditor,\n  // displays small gray arrow on \
right side of the cell\n  renderer: autocompleteRenderer\n};\n\n// \
node_modules/handsontable/cellTypes/numericType/numericType.mjs\nvar \
CELL_TYPE8 = \"numeric\";\nvar NumericCellType = {\n  CELL_TYPE: \
CELL_TYPE8,\n  editor: NumericEditor,\n  renderer: numericRenderer,\n  \
validator: numericValidator,\n  dataType: \"number\"\n};\n\n// \
node_modules/handsontable/cellTypes/passwordType/passwordType.mjs\nvar \
CELL_TYPE9 = \"password\";\nvar PasswordCellType = {\n  CELL_TYPE: \
CELL_TYPE9,\n  editor: PasswordEditor,\n  renderer: passwordRenderer,\n  \
copyable: false\n};\n\n// \
node_modules/handsontable/cellTypes/timeType/timeType.mjs\nvar CELL_TYPE10 = \
\"time\";\nvar TimeCellType = {\n  CELL_TYPE: CELL_TYPE10,\n  editor: \
TimeEditor,\n  renderer: timeRenderer,\n  validator: timeValidator\n};\n\n// \
node_modules/handsontable/cellTypes/index.mjs\nfunction \
registerAllCellTypes() {\n  _register4(AutocompleteCellType);\n  \
_register4(CheckboxCellType);\n  _register4(DateCellType);\n  \
_register4(DropdownCellType);\n  _register4(HandsontableCellType);\n  \
_register4(NumericCellType);\n  _register4(PasswordCellType);\n  \
_register4(TextCellType);\n  _register4(TimeCellType);\n}\n\n// \
node_modules/handsontable/plugins/base/base.mjs\nfunction \
_classPrivateMethodInitSpec(obj, privateSet) {\n  \
_checkPrivateRedeclaration6(obj, privateSet);\n  \
privateSet.add(obj);\n}\nfunction _checkPrivateRedeclaration6(obj, \
privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new \
TypeError(\"Cannot initialize the same private elements twice on an \
object\");\n  }\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) \
{\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to \
get private field on non-instance\");\n  }\n  return fn;\n}\nvar \
DEPS_TYPE_CHECKERS = /* @__PURE__ */ new Map([[\"plugin\", hasPlugin], \
[\"cell-type\", hasItem4], [\"editor\", hasItem], [\"renderer\", hasItem2], \
[\"validator\", hasItem3]]);\nvar PLUGIN_KEY = \"base\";\nvar privatePool6 = \
/* @__PURE__ */ new WeakMap();\nvar missingDependeciesMsgs = [];\nvar \
initializedPlugins = null;\nvar _isRelevantToSettings = /* @__PURE__ */ new \
WeakSet();\nvar BasePlugin = class {\n  static get PLUGIN_KEY() {\n    return \
PLUGIN_KEY;\n  }\n  /**\n   * The `SETTING_KEYS` getter defines the keys \
that, when present in the config object, trigger the plugin update\n   * \
after the `updateSettings` calls.\n   * - When it returns `true`, the plugin \
updates after all `updateSettings` calls, regardless of the contents of the\n \
  * config object.\n   * - When it returns `false`, the plugin never updates \
on `updateSettings` calls.\n   *\n   * @returns {string[] | boolean}\n   */\n \
 static get SETTING_KEYS() {\n    return [this.PLUGIN_KEY];\n  }\n  /**\n   * \
@param {object} hotInstance Handsontable instance.\n   */\n  \
constructor(hotInstance) {\n    _classPrivateMethodInitSpec(this, \
_isRelevantToSettings);\n    defineGetter(this, \"hot\", hotInstance, {\n     \
 writable: false\n    });\n    privatePool6.set(this, {\n      hooks: {}\n    \
});\n    initializedPlugins = null;\n    this.pluginName = null;\n    \
this.pluginsInitializedCallbacks = [];\n    this.isPluginsReady = false;\n    \
this.enabled = false;\n    this.initialized = false;\n    \
this.hot.addHook(\"afterPluginsInitialized\", () => \
this.onAfterPluginsInitialized());\n    \
this.hot.addHook(\"afterUpdateSettings\", (newSettings) => \
this.onUpdateSettings(newSettings));\n    this.hot.addHook(\"beforeInit\", () \
=> this.init());\n  }\n  init() {\n    this.pluginName = \
this.hot.getPluginName(this);\n    const pluginDeps = \
this.constructor.PLUGIN_DEPS;\n    const dependecies = \
Array.isArray(pluginDeps) ? pluginDeps : [];\n    if (dependecies.length > 0) \
{\n      const missingDependencies = [];\n      \
dependecies.forEach((dependency) => {\n        const [type, moduleName] = \
dependency.split(\":\");\n        if (!DEPS_TYPE_CHECKERS.has(type)) {\n      \
    throw new Error(`Unknown plugin dependency type \"${type}\" was \
found.`);\n        }\n        if (!DEPS_TYPE_CHECKERS.get(type)(moduleName)) \
{\n          missingDependencies.push(` - ${moduleName} (${type})`);\n        \
}\n      });\n      if (missingDependencies.length > 0) {\n        const \
errorMsg = [`The ${this.pluginName} plugin requires the following \
modules:\n`, `${missingDependencies.join(\"\\n\")}\n`].join(\"\");\n        \
missingDependeciesMsgs.push(errorMsg);\n      }\n    }\n    if \
(!initializedPlugins) {\n      initializedPlugins = getPluginsNames();\n    \
}\n    if (initializedPlugins.indexOf(\"UndoRedo\") >= 0) {\n      \
initializedPlugins.splice(initializedPlugins.indexOf(\"UndoRedo\"), 1);\n    \
}\n    if (initializedPlugins.indexOf(this.pluginName) >= 0) {\n      \
initializedPlugins.splice(initializedPlugins.indexOf(this.pluginName), 1);\n  \
  }\n    this.hot.addHookOnce(\"afterPluginsInitialized\", () => {\n      if \
(this.isEnabled && this.isEnabled()) {\n        this.enablePlugin();\n      \
}\n    });\n    const isAllPluginsAreInitialized = initializedPlugins.length \
=== 0;\n    if (isAllPluginsAreInitialized) {\n      if \
(missingDependeciesMsgs.length > 0) {\n        const errorMsg = \
[`${missingDependeciesMsgs.join(\"\\n\")}\n`, \"You have to import and \
register them manually.\"].join(\"\");\n        throw new Error(errorMsg);\n  \
    }\n      this.hot.runHooks(\"afterPluginsInitialized\");\n    }\n    \
this.initialized = true;\n  }\n  /**\n   * Enable plugin for this \
Handsontable instance.\n   */\n  enablePlugin() {\n    this.enabled = true;\n \
 }\n  /**\n   * Disable plugin for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    if (this.eventManager) {\n      \
this.eventManager.clear();\n    }\n    this.clearHooks();\n    this.enabled = \
false;\n  }\n  /**\n   * Add listener to plugin hooks system.\n   *\n   * \
@param {string} name The hook name.\n   * @param {Function} callback The \
listener function to add.\n   */\n  addHook(name, callback) {\n    \
privatePool6.get(this).hooks[name] = privatePool6.get(this).hooks[name] || \
[];\n    const hooks = privatePool6.get(this).hooks[name];\n    \
this.hot.addHook(name, callback);\n    hooks.push(callback);\n    \
privatePool6.get(this).hooks[name] = hooks;\n  }\n  /**\n   * Remove all \
hooks listeners by hook name.\n   *\n   * @param {string} name The hook \
name.\n   */\n  removeHooks(name) {\n    \
arrayEach(privatePool6.get(this).hooks[name] || [], (callback) => {\n      \
this.hot.removeHook(name, callback);\n    });\n  }\n  /**\n   * Clear all \
hooks.\n   */\n  clearHooks() {\n    const hooks = \
privatePool6.get(this).hooks;\n    objectEach(hooks, (callbacks, name) => \
this.removeHooks(name));\n    hooks.length = 0;\n  }\n  /**\n   * Register \
function which will be immediately called after all plugins initialized.\n   \
*\n   * @param {Function} callback The listener function to call.\n   */\n  \
callOnPluginsReady(callback) {\n    if (this.isPluginsReady) {\n      \
callback();\n    } else {\n      \
this.pluginsInitializedCallbacks.push(callback);\n    }\n  }\n  /**\n   * On \
after plugins initialized listener.\n   *\n   * @private\n   */\n  \
onAfterPluginsInitialized() {\n    \
arrayEach(this.pluginsInitializedCallbacks, (callback) => callback());\n    \
this.pluginsInitializedCallbacks.length = 0;\n    this.isPluginsReady = \
true;\n  }\n  /**\n   * On update settings listener.\n   *\n   * @private\n   \
* @param {object} newSettings New set of settings passed to the \
`updateSettings` method.\n   */\n  onUpdateSettings(newSettings) {\n    const \
relevantToSettings = _classPrivateMethodGet(this, _isRelevantToSettings, \
_isRelevantToSettings2).call(this, newSettings);\n    if (this.isEnabled) {\n \
     if (this.enabled && !this.isEnabled()) {\n        \
this.disablePlugin();\n      }\n      if (!this.enabled && this.isEnabled()) \
{\n        this.enablePlugin();\n      }\n      if (this.enabled && \
this.isEnabled() && relevantToSettings) {\n        \
this.updatePlugin(newSettings);\n      }\n    }\n  }\n  /**\n   * Updates the \
plugin to use the latest options you have specified.\n   *\n   * @private\n   \
*/\n  updatePlugin() {\n  }\n  /**\n   * Destroy plugin.\n   */\n  destroy() \
{\n    if (this.eventManager) {\n      this.eventManager.destroy();\n    }\n  \
  this.clearHooks();\n    objectEach(this, (value, property) => {\n      if \
(property !== \"hot\") {\n        this[property] = null;\n      }\n    });\n  \
  delete this.t;\n    delete this.hot;\n  }\n};\nfunction \
_isRelevantToSettings2(settings) {\n  if (!settings) {\n    return false;\n  \
}\n  const settingKeys = this.constructor.SETTING_KEYS;\n  if (typeof \
settingKeys === \"boolean\") {\n    return settingKeys;\n  }\n  for (let i = \
0; i < settingKeys.length; i++) {\n    if (settings[settingKeys[i]] !== void \
0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// \
node_modules/handsontable/utils/ghostTable.mjs\nvar GhostTable = class {\n  \
constructor(hotInstance) {\n    this.hot = hotInstance;\n    this.container = \
null;\n    this.injected = false;\n    this.rows = [];\n    this.columns = \
[];\n    this.samples = null;\n    this.settings = {\n      useHeaders: \
true\n    };\n  }\n  /**\n   * Add row.\n   *\n   * @param {number} row Row \
index.\n   * @param {Map} samples Samples Map object.\n   */\n  addRow(row, \
samples) {\n    if (this.columns.length) {\n      throw new Error(\"Doesn't \
support multi-dimensional table\");\n    }\n    if (!this.rows.length) {\n    \
  this.container = this.createContainer(this.hot.rootElement.className);\n    \
}\n    const rowObject = {\n      row\n    };\n    \
this.rows.push(rowObject);\n    this.samples = samples;\n    this.table = \
this.createTable(this.hot.table.className);\n    \
this.table.colGroup.appendChild(this.createColGroupsCol());\n    \
this.table.tr.appendChild(this.createRow(row));\n    \
this.container.container.appendChild(this.table.fragment);\n    \
rowObject.table = this.table.table;\n  }\n  /**\n   * Add a row consisting of \
the column headers.\n   *\n   * @param {Map} samples A map with sampled table \
values.\n   */\n  addColumnHeadersRow(samples) {\n    const colHeader = \
this.hot.getColHeader(0);\n    if (colHeader !== null && colHeader !== void \
0) {\n      const rowObject = {\n        row: -1\n      };\n      \
this.rows.push(rowObject);\n      this.container = \
this.createContainer(this.hot.rootElement.className);\n      this.samples = \
samples;\n      this.table = this.createTable(this.hot.table.className);\n    \
  this.table.colGroup.appendChild(this.createColGroupsCol());\n      \
this.appendColumnHeadersRow();\n      \
this.container.container.appendChild(this.table.fragment);\n      \
rowObject.table = this.table.table;\n    }\n  }\n  /**\n   * Add column.\n   \
*\n   * @param {number} column Column index.\n   * @param {Map} samples A map \
with sampled table values.\n   */\n  addColumn(column, samples) {\n    if \
(this.rows.length) {\n      throw new Error(\"Doesn't support \
multi-dimensional table\");\n    }\n    if (!this.columns.length) {\n      \
this.container = this.createContainer(this.hot.rootElement.className);\n    \
}\n    const columnObject = {\n      col: column\n    };\n    \
this.columns.push(columnObject);\n    this.samples = samples;\n    this.table \
= this.createTable(this.hot.table.className);\n    if \
(this.getSetting(\"useHeaders\") && this.hot.getColHeader(column) !== null) \
{\n      this.hot.view.appendColHeader(column, this.table.th);\n    }\n    \
this.table.tBody.appendChild(this.createCol(column));\n    \
this.container.container.appendChild(this.table.fragment);\n    \
columnObject.table = this.table.table;\n  }\n  /**\n   * Get calculated \
heights.\n   *\n   * @param {Function} callback Callback which will be fired \
for each calculated row.\n   */\n  getHeights(callback) {\n    if \
(!this.injected) {\n      this.injectTable();\n    }\n    \
arrayEach(this.rows, (row) => {\n      callback(row.row, \
outerHeight(row.table) - 1);\n    });\n  }\n  /**\n   * Get calculated \
widths.\n   *\n   * @param {Function} callback Callback which will be fired \
for each calculated column.\n   */\n  getWidths(callback) {\n    if \
(!this.injected) {\n      this.injectTable();\n    }\n    \
arrayEach(this.columns, (column) => {\n      const {\n        width\n      } \
= column.table.getBoundingClientRect();\n      callback(column.col, \
Math.ceil(width));\n    });\n  }\n  /**\n   * Set the Ghost Table settings to \
the provided object.\n   *\n   * @param {object} settings New Ghost Table \
Settings.\n   */\n  setSettings(settings) {\n    this.settings = settings;\n  \
}\n  /**\n   * Set a single setting of the Ghost Table.\n   *\n   * @param \
{string} name Setting name.\n   * @param {*} value Setting value.\n   */\n  \
setSetting(name, value) {\n    if (!this.settings) {\n      this.settings = \
{};\n    }\n    this.settings[name] = value;\n  }\n  /**\n   * Get the Ghost \
Table settings.\n   *\n   * @returns {object|null}\n   */\n  getSettings() \
{\n    return this.settings;\n  }\n  /**\n   * Get a single Ghost Table \
setting.\n   *\n   * @param {string} name The setting name to get.\n   * \
@returns {boolean|null}\n   */\n  getSetting(name) {\n    if (this.settings) \
{\n      return this.settings[name];\n    }\n    return null;\n  }\n  /**\n   \
* Create colgroup col elements.\n   *\n   * @returns {DocumentFragment}\n   \
*/\n  createColGroupsCol() {\n    const fragment = \
this.hot.rootDocument.createDocumentFragment();\n    if \
(this.hot.hasRowHeaders()) {\n      \
fragment.appendChild(this.createColElement(-1));\n    }\n    \
this.samples.forEach((sample) => {\n      arrayEach(sample.strings, (string) \
=> {\n        fragment.appendChild(this.createColElement(string.col));\n      \
});\n    });\n    return fragment;\n  }\n  /**\n   * Create table row \
element.\n   *\n   * @param {number} row Row index.\n   * @returns \
{DocumentFragment} Returns created table row elements.\n   */\n  \
createRow(row) {\n    const {\n      rootDocument\n    } = this.hot;\n    \
const fragment = rootDocument.createDocumentFragment();\n    const th = \
rootDocument.createElement(\"th\");\n    if (this.hot.hasRowHeaders()) {\n    \
  this.hot.view.appendRowHeader(row, th);\n      fragment.appendChild(th);\n  \
  }\n    this.samples.forEach((sample) => {\n      arrayEach(sample.strings, \
(string) => {\n        const column = string.col;\n        const \
cellProperties = this.hot.getCellMeta(row, column);\n        \
cellProperties.col = column;\n        cellProperties.row = row;\n        \
const renderer = this.hot.getCellRenderer(cellProperties);\n        const td \
= rootDocument.createElement(\"td\");\n        \
td.setAttribute(\"ghost-table\", 1);\n        renderer(this.hot, td, row, \
column, this.hot.colToProp(column), string.value, cellProperties);\n        \
fragment.appendChild(td);\n      });\n    });\n    return fragment;\n  }\n  \
/**\n   * Creates DOM elements for headers and appends them to the THEAD \
element of the table.\n   */\n  appendColumnHeadersRow() {\n    const {\n     \
 rootDocument\n    } = this.hot;\n    const domFragment = \
rootDocument.createDocumentFragment();\n    const columnHeaders = [];\n    if \
(this.hot.hasRowHeaders()) {\n      const th = \
rootDocument.createElement(\"th\");\n      columnHeaders.push([-1, th]);\n    \
  domFragment.appendChild(th);\n    }\n    this.samples.forEach((sample) => \
{\n      arrayEach(sample.strings, (string) => {\n        const column = \
string.col;\n        const th = rootDocument.createElement(\"th\");\n        \
columnHeaders.push([column, th]);\n        domFragment.appendChild(th);\n     \
 });\n    });\n    this.table.tHead.appendChild(domFragment);\n    \
arrayEach(columnHeaders, (columnHeader) => {\n      const [column, th] = \
columnHeader;\n      this.hot.view.appendColHeader(column, th);\n    });\n  \
}\n  /**\n   * Create table column elements.\n   *\n   * @param {number} \
column Column index.\n   * @returns {DocumentFragment} Returns created column \
table column elements.\n   */\n  createCol(column) {\n    const {\n      \
rootDocument\n    } = this.hot;\n    const fragment = \
rootDocument.createDocumentFragment();\n    this.samples.forEach((sample) => \
{\n      arrayEach(sample.strings, (string) => {\n        const row = \
string.row;\n        const cellProperties = this.hot.getCellMeta(row, \
column);\n        cellProperties.col = column;\n        cellProperties.row = \
row;\n        const renderer = this.hot.getCellRenderer(cellProperties);\n    \
    const td = rootDocument.createElement(\"td\");\n        const tr = \
rootDocument.createElement(\"tr\");\n        td.setAttribute(\"ghost-table\", \
1);\n        renderer(this.hot, td, row, column, this.hot.colToProp(column), \
string.value, cellProperties);\n        tr.appendChild(td);\n        \
fragment.appendChild(tr);\n      });\n    });\n    return fragment;\n  }\n  \
/**\n   * Remove table from document and reset internal state.\n   */\n  \
clean() {\n    this.rows.length = 0;\n    this.rows[-1] = void 0;\n    \
this.columns.length = 0;\n    if (this.samples) {\n      \
this.samples.clear();\n    }\n    this.samples = null;\n    \
this.removeTable();\n  }\n  /**\n   * Inject generated table into document.\n \
  *\n   * @param {HTMLElement} [parent=null] The element to which the ghost \
table is injected.\n   */\n  injectTable() {\n    let parent2 = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    \
if (!this.injected) {\n      (parent2 || \
this.hot.rootElement).appendChild(this.container.fragment);\n      \
this.injected = true;\n    }\n  }\n  /**\n   * Remove table from document.\n  \
 */\n  removeTable() {\n    if (this.injected && \
this.container.container.parentNode) {\n      \
this.container.container.parentNode.removeChild(this.container.container);\n  \
    this.container = null;\n      this.injected = false;\n    }\n  }\n  /**\n \
  * Create col element.\n   *\n   * @param {number} column Column index.\n   \
* @returns {HTMLElement}\n   */\n  createColElement(column) {\n    const col \
= this.hot.rootDocument.createElement(\"col\");\n    col.style.width = \
`${this.hot.view._wt.wtTable.getStretchedColumnWidth(column)}px`;\n    return \
col;\n  }\n  /**\n   * Create table element.\n   *\n   * @param {string} \
className The CSS classes to add.\n   * @returns {object}\n   */\n  \
createTable() {\n    let className = arguments.length > 0 && arguments[0] !== \
void 0 ? arguments[0] : \"\";\n    const {\n      rootDocument\n    } = \
this.hot;\n    const fragment = rootDocument.createDocumentFragment();\n    \
const table = rootDocument.createElement(\"table\");\n    const tHead = \
rootDocument.createElement(\"thead\");\n    const tBody = \
rootDocument.createElement(\"tbody\");\n    const colGroup = \
rootDocument.createElement(\"colgroup\");\n    const tr = \
rootDocument.createElement(\"tr\");\n    const th = \
rootDocument.createElement(\"th\");\n    if (this.isVertical()) {\n      \
table.appendChild(colGroup);\n    }\n    if (this.isHorizontal()) {\n      \
tr.appendChild(th);\n      tHead.appendChild(tr);\n      \
table.style.tableLayout = \"auto\";\n      table.style.width = \"auto\";\n    \
}\n    table.appendChild(tHead);\n    if (this.isVertical()) {\n      \
tBody.appendChild(tr);\n    }\n    table.appendChild(tBody);\n    \
addClass(table, className);\n    fragment.appendChild(table);\n    return {\n \
     fragment,\n      table,\n      tHead,\n      tBody,\n      colGroup,\n   \
   tr,\n      th\n    };\n  }\n  /**\n   * Create container for tables.\n   \
*\n   * @param {string} className The CSS classes to add.\n   * @returns \
{object}\n   */\n  createContainer() {\n    let className = arguments.length \
> 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    const {\n      \
rootDocument\n    } = this.hot;\n    const fragment = \
rootDocument.createDocumentFragment();\n    const container = \
rootDocument.createElement(\"div\");\n    const containerClassName = \
`htGhostTable htAutoSize ${className.trim()}`;\n    addClass(container, \
containerClassName);\n    fragment.appendChild(container);\n    return {\n    \
  fragment,\n      container\n    };\n  }\n  /**\n   * Checks if table is \
raised vertically (checking rows).\n   *\n   * @returns {boolean}\n   */\n  \
isVertical() {\n    return !!(this.rows.length && !this.columns.length);\n  \
}\n  /**\n   * Checks if table is raised horizontally (checking columns).\n   \
*\n   * @returns {boolean}\n   */\n  isHorizontal() {\n    return \
!!(this.columns.length && !this.rows.length);\n  }\n};\nvar \
ghostTable_default = GhostTable;\n\n// \
node_modules/handsontable/utils/samplesGenerator.mjs\nvar SamplesGenerator = \
class _SamplesGenerator {\n  /**\n   * Number of samples to take of each \
value length.\n   *\n   * @type {number}\n   */\n  static get SAMPLE_COUNT() \
{\n    return 3;\n  }\n  constructor(dataFactory) {\n    this.samples = \
null;\n    this.dataFactory = dataFactory;\n    this.customSampleCount = \
null;\n    this.allowDuplicates = false;\n  }\n  /**\n   * Get the sample \
count for this instance.\n   *\n   * @returns {number}\n   */\n  \
getSampleCount() {\n    if (this.customSampleCount) {\n      return \
this.customSampleCount;\n    }\n    return _SamplesGenerator.SAMPLE_COUNT;\n  \
}\n  /**\n   * Set the sample count.\n   *\n   * @param {number} sampleCount \
Number of samples to be collected.\n   */\n  setSampleCount(sampleCount) {\n  \
  this.customSampleCount = sampleCount;\n  }\n  /**\n   * Set if the \
generator should accept duplicate values.\n   *\n   * @param {boolean} \
allowDuplicates `true` to allow duplicate values.\n   */\n  \
setAllowDuplicates(allowDuplicates) {\n    this.allowDuplicates = \
allowDuplicates;\n  }\n  /**\n   * Generate samples for row. You can control \
which area should be sampled by passing `rowRange` object and `colRange` \
object.\n   *\n   * @param {object|number} rowRange The rows range to \
generate the samples.\n   * @param {object} colRange The column range to \
generate the samples.\n   * @returns {object}\n   */\n  \
generateRowSamples(rowRange, colRange) {\n    return \
this.generateSamples(\"row\", colRange, rowRange);\n  }\n  /**\n   * Generate \
samples for column. You can control which area should be sampled by passing \
`colRange` object and `rowRange` object.\n   *\n   * @param {object} colRange \
Column index.\n   * @param {object} rowRange Column index.\n   * @returns \
{object}\n   */\n  generateColumnSamples(colRange, rowRange) {\n    return \
this.generateSamples(\"col\", rowRange, colRange);\n  }\n  /**\n   * Generate \
collection of samples.\n   *\n   * @param {string} type Type to generate. Can \
be `col` or `row`.\n   * @param {object} range The range to generate the \
samples.\n   * @param {object|number} specifierRange The range to generate \
the samples.\n   * @returns {Map}\n   */\n  generateSamples(type, range, \
specifierRange) {\n    const samples = /* @__PURE__ */ new Map();\n    const \
{\n      from,\n      to\n    } = typeof specifierRange === \"number\" ? {\n  \
    from: specifierRange,\n      to: specifierRange\n    } : \
specifierRange;\n    rangeEach(from, to, (index2) => {\n      const sample = \
this.generateSample(type, range, index2);\n      samples.set(index2, \
sample);\n    });\n    return samples;\n  }\n  /**\n   * Generate sample for \
specified type (`row` or `col`).\n   *\n   * @param {string} type Samples \
type `row` or `col`.\n   * @param {object} range The range to generate the \
samples.\n   * @param {number} specifierValue The range to generate the \
samples.\n   * @returns {Map}\n   */\n  generateSample(type, range, \
specifierValue) {\n    if (type !== \"row\" && type !== \"col\") {\n      \
throw new Error(\"Unsupported sample type\");\n    }\n    const samples = /* \
@__PURE__ */ new Map();\n    const computedKey = type === \"row\" ? \"col\" : \
\"row\";\n    const sampledValues = [];\n    rangeEach(range.from, range.to, \
(index2) => {\n      const {\n        value,\n        bundleSeed\n      } = \
type === \"row\" ? this.dataFactory(specifierValue, index2) : \
this.dataFactory(index2, specifierValue);\n      const hasCustomBundleSeed = \
typeof bundleSeed === \"string\" && bundleSeed.length > 0;\n      let seed;\n \
     if (hasCustomBundleSeed) {\n        seed = bundleSeed;\n      } else if \
(isObject(value)) {\n        seed = `${Object.keys(value).length}`;\n      } \
else if (Array.isArray(value)) {\n        seed = `${value.length}`;\n      } \
else {\n        seed = `${stringify(value).length}`;\n      }\n      if \
(!samples.has(seed)) {\n        samples.set(seed, {\n          needed: \
this.getSampleCount(),\n          strings: []\n        });\n      }\n      \
const sample = samples.get(seed);\n      if (sample.needed) {\n        const \
duplicate = sampledValues.indexOf(value) > -1;\n        if (!duplicate || \
this.allowDuplicates || hasCustomBundleSeed) {\n          \
sample.strings.push({\n            value,\n            [computedKey]: \
index2\n          });\n          sampledValues.push(value);\n          \
sample.needed -= 1;\n        }\n      }\n    });\n    return samples;\n  \
}\n};\nvar samplesGenerator_default = SamplesGenerator;\n\n// \
node_modules/handsontable/plugins/autoColumnSize/autoColumnSize.mjs\npluginHo\
oks_default.getSingleton().register(\"modifyAutoColumnSizeSeed\");\nvar \
PLUGIN_KEY2 = \"autoColumnSize\";\nvar PLUGIN_PRIORITY = 10;\nvar \
privatePool7 = /* @__PURE__ */ new WeakMap();\nvar COLUMN_SIZE_MAP_NAME = \
\"autoColumnSize\";\nvar AutoColumnSize = class _AutoColumnSize extends \
BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY2;\n  }\n  \
static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static \
get SETTING_KEYS() {\n    return true;\n  }\n  static get CALCULATION_STEP() \
{\n    return 50;\n  }\n  static get SYNC_CALCULATION_LIMIT() {\n    return \
50;\n  }\n  constructor(hotInstance) {\n    super(hotInstance);\n    \
privatePool7.set(this, {\n      /**\n       * Cached column header names. It \
is used to diff current column headers with previous state and detect which\n \
      * columns width should be updated.\n       *\n       * @private\n       \
* @type {Array}\n       */\n      cachedColumnHeaders: []\n    });\n    \
this.ghostTable = new ghostTable_default(this.hot);\n    \
this.samplesGenerator = new samplesGenerator_default((row, column) => {\n     \
 const cellMeta = this.hot.getCellMeta(row, column);\n      let cellValue = \
\"\";\n      if (!cellMeta.spanned) {\n        cellValue = \
this.hot.getDataAtCell(row, column);\n      }\n      let bundleSeed = \"\";\n \
     if (this.hot.hasHook(\"modifyAutoColumnSizeSeed\")) {\n        \
bundleSeed = this.hot.runHooks(\"modifyAutoColumnSizeSeed\", bundleSeed, \
cellMeta, cellValue);\n      }\n      return {\n        value: cellValue,\n   \
     bundleSeed\n      };\n    });\n    this.firstCalculation = true;\n    \
this.inProgress = false;\n    this.measuredColumns = 0;\n    \
this.columnWidthsMap = new PhysicalIndexToValueMap();\n    \
this.hot.columnIndexMapper.registerMap(COLUMN_SIZE_MAP_NAME, \
this.columnWidthsMap);\n    this.addHook(\"beforeColumnResize\", (size, \
column, isDblClick) => this.onBeforeColumnResize(size, column, \
isDblClick));\n  }\n  /**\n   * Checks if the plugin is enabled in the \
handsontable settings. This method is executed in {@link Hooks#beforeInit}\n  \
 * hook and if it returns `true` then the {@link #enablePlugin} method is \
called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return \
this.hot.getSettings()[PLUGIN_KEY2] !== false && \
!this.hot.getSettings().colWidths;\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const \
setting = this.hot.getSettings()[PLUGIN_KEY2];\n    if (setting && \
setting.useHeaders !== null && setting.useHeaders !== void 0) {\n      \
this.ghostTable.setSetting(\"useHeaders\", setting.useHeaders);\n    }\n    \
this.setSamplingOptions();\n    this.addHook(\"afterLoadData\", function() \
{\n      return _this.onAfterLoadData(...arguments);\n    });\n    \
this.addHook(\"beforeChangeRender\", (changes) => \
this.onBeforeChange(changes));\n    \
this.addHook(\"afterFormulasValuesUpdate\", (changes) => \
this.onAfterFormulasValuesUpdate(changes));\n    \
this.addHook(\"beforeViewRender\", (force) => \
this.onBeforeViewRender(force));\n    this.addHook(\"modifyColWidth\", \
(width, col) => this.getColumnWidth(col, width));\n    \
this.addHook(\"afterInit\", () => this.onAfterInit());\n    \
super.enablePlugin();\n  }\n  /**\n   * Updates the plugin's state. This \
method is executed when {@link Core#updateSettings} is invoked.\n   */\n  \
updatePlugin() {\n    const changedColumns = \
this.findColumnsWhereHeaderWasChanged();\n    if (changedColumns.length) {\n  \
    this.clearCache(changedColumns);\n      \
this.calculateVisibleColumnsWidth();\n    }\n    super.updatePlugin();\n  }\n \
 /**\n   * Disables the plugin functionality for this Handsontable \
instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n    \
this.addHook(\"beforeColumnResize\", (size, column, isDblClick) => \
this.onBeforeColumnResize(size, column, isDblClick));\n  }\n  /**\n   * \
Calculates visible columns width.\n   */\n  calculateVisibleColumnsWidth() \
{\n    const rowsCount = this.hot.countRows();\n    if (!rowsCount) {\n      \
return;\n    }\n    const force = this.hot.renderCall;\n    const \
firstVisibleColumn = this.getFirstVisibleColumn();\n    const \
lastVisibleColumn = this.getLastVisibleColumn();\n    if (firstVisibleColumn \
=== -1 || lastVisibleColumn === -1) {\n      return;\n    }\n    \
this.calculateColumnsWidth({\n      from: firstVisibleColumn,\n      to: \
lastVisibleColumn\n    }, void 0, force);\n  }\n  /**\n   * Calculates a \
columns width.\n   *\n   * @param {number|object} colRange Visual column \
index or an object with `from` and `to` visual indexes as a range.\n   * \
@param {number|object} rowRange Visual row index or an object with `from` and \
`to` visual indexes as a range.\n   * @param {boolean} [force=false] If \
`true` the calculation will be processed regardless of whether the width \
exists in the cache.\n   */\n  calculateColumnsWidth() {\n    let colRange = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n      \
from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let rowRange = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n      \
from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let force = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    \
const columnsRange = typeof colRange === \"number\" ? {\n      from: \
colRange,\n      to: colRange\n    } : colRange;\n    const rowsRange = \
typeof rowRange === \"number\" ? {\n      from: rowRange,\n      to: \
rowRange\n    } : rowRange;\n    rangeEach(columnsRange.from, \
columnsRange.to, (visualColumn) => {\n      let physicalColumn = \
this.hot.toPhysicalColumn(visualColumn);\n      if (physicalColumn === null) \
{\n        physicalColumn = visualColumn;\n      }\n      if (force || \
this.columnWidthsMap.getValueAtIndex(physicalColumn) === null && \
!this.hot._getColWidthFromSettings(physicalColumn)) {\n        const samples \
= this.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);\n     \
   arrayEach(samples, (_ref) => {\n          let [column, sample] = _ref;\n   \
       return this.ghostTable.addColumn(column, sample);\n        });\n      \
}\n    });\n    if (this.ghostTable.columns.length) {\n      \
this.hot.batchExecution(() => {\n        \
this.ghostTable.getWidths((visualColumn, width) => {\n          const \
physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n          \
this.columnWidthsMap.setValueAtIndex(physicalColumn, width);\n        });\n   \
   }, true);\n      this.measuredColumns = columnsRange.to + 1;\n      \
this.ghostTable.clean();\n    }\n  }\n  /**\n   * Calculates all columns \
width. The calculated column will be cached in the {@link \
AutoColumnSize#widths} property.\n   * To retrieve width for specified column \
use {@link AutoColumnSize#getColumnWidth} method.\n   *\n   * @param \
{object|number} rowRange Row index or an object with `from` and `to` \
properties which define row range.\n   */\n  calculateAllColumnsWidth() {\n   \
 let rowRange = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    \
};\n    let current = 0;\n    const length = this.hot.countCols() - 1;\n    \
let timer = null;\n    this.inProgress = true;\n    const loop = () => {\n    \
  if (!this.hot) {\n        cancelAnimationFrame(timer);\n        \
this.inProgress = false;\n        return;\n      }\n      \
this.calculateColumnsWidth({\n        from: current,\n        to: \
Math.min(current + _AutoColumnSize.CALCULATION_STEP, length)\n      }, \
rowRange);\n      current = current + _AutoColumnSize.CALCULATION_STEP + 1;\n \
     if (current < length) {\n        timer = requestAnimationFrame(loop);\n  \
    } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = \
false;\n        this.hot.view.adjustElementsSize();\n      }\n    };\n    \
const syncLimit = this.getSyncCalculationLimit();\n    if \
(this.firstCalculation && syncLimit >= 0) {\n      \
this.calculateColumnsWidth({\n        from: 0,\n        to: syncLimit\n      \
}, rowRange);\n      this.firstCalculation = false;\n      current = \
syncLimit + 1;\n    }\n    if (current < length) {\n      loop();\n    } else \
{\n      this.inProgress = false;\n    }\n  }\n  /**\n   * Sets the sampling \
options.\n   *\n   * @private\n   */\n  setSamplingOptions() {\n    const \
setting = this.hot.getSettings()[PLUGIN_KEY2];\n    const samplingRatio = \
setting && hasOwnProperty(setting, \"samplingRatio\") ? setting.samplingRatio \
: void 0;\n    const allowSampleDuplicates = setting && \
hasOwnProperty(setting, \"allowSampleDuplicates\") ? \
setting.allowSampleDuplicates : void 0;\n    if (samplingRatio && \
!isNaN(samplingRatio)) {\n      \
this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n   \
 if (allowSampleDuplicates) {\n      \
this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  \
}\n  /**\n   * Recalculates all columns width (overwrite cache values).\n   \
*/\n  recalculateAllColumnsWidth() {\n    if (this.hot.view && \
this.hot.view._wt.wtTable.isVisible()) {\n      this.clearCache();\n      \
this.calculateAllColumnsWidth();\n    }\n  }\n  /**\n   * Gets value which \
tells how many columns should be calculated synchronously (rest of the \
columns will be calculated\n   * asynchronously). The limit is calculated \
based on `syncLimit` set to `autoColumnSize` option (see {@link \
Options#autoColumnSize}).\n   *\n   * @returns {number}\n   */\n  \
getSyncCalculationLimit() {\n    const settings = \
this.hot.getSettings()[PLUGIN_KEY2];\n    let limit = \
_AutoColumnSize.SYNC_CALCULATION_LIMIT;\n    const colsLimit = \
this.hot.countCols() - 1;\n    if (isObject(settings)) {\n      limit = \
settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = \
valueAccordingPercent(colsLimit, limit);\n      } else {\n        limit >>= \
0;\n      }\n    }\n    return Math.min(limit, colsLimit);\n  }\n  /**\n   * \
Gets the calculated column width.\n   *\n   * @param {number} column Visual \
column index.\n   * @param {number} [defaultWidth] Default column width. It \
will be picked up if no calculated width found.\n   * @param {boolean} \
[keepMinimum=true] If `true` then returned value won't be smaller then 50 \
(default column width).\n   * @returns {number}\n   */\n  \
getColumnWidth(column) {\n    let defaultWidth = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : void 0;\n    let keepMinimum = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    \
let width = defaultWidth;\n    if (width === void 0) {\n      width = \
this.columnWidthsMap.getValueAtIndex(this.hot.toPhysicalColumn(column));\n    \
  if (keepMinimum && typeof width === \"number\") {\n        width = \
Math.max(width, viewportColumns_default.DEFAULT_WIDTH);\n      }\n    }\n    \
return width;\n  }\n  /**\n   * Gets the first visible column.\n   *\n   * \
@returns {number} Returns visual column index, -1 if table is not rendered or \
if there are no columns to base the the calculations on.\n   */\n  \
getFirstVisibleColumn() {\n    const wot = this.hot.view._wt;\n    if \
(wot.wtViewport.columnsVisibleCalculator) {\n      const \
firstFullyVisibleColumn = wot.wtTable.getFirstVisibleColumn();\n      if \
(firstFullyVisibleColumn !== -1) {\n        return \
this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstFullyVisibleColu\
mn);\n      }\n    }\n    if (wot.wtViewport.columnsRenderCalculator) {\n     \
 const firstRenderedColumn = wot.wtTable.getFirstRenderedColumn();\n      if \
(firstRenderedColumn !== -1) {\n        return \
this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstRenderedColumn);\
\n      }\n    }\n    return -1;\n  }\n  /**\n   * Gets the last visible \
column.\n   *\n   * @returns {number} Returns visual column index or -1 if \
table is not rendered.\n   */\n  getLastVisibleColumn() {\n    const wot = \
this.hot.view._wt;\n    if (wot.wtViewport.columnsVisibleCalculator) {\n      \
const lastFullyVisibleColumn = wot.wtTable.getLastVisibleColumn();\n      if \
(lastFullyVisibleColumn !== -1) {\n        return \
this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastFullyVisibleColum\
n);\n      }\n    }\n    if (wot.wtViewport.columnsRenderCalculator) {\n      \
const lastRenderedColumn = wot.wtTable.getLastRenderedColumn();\n      if \
(lastRenderedColumn !== -1) {\n        return \
this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastRenderedColumn);\
\n      }\n    }\n    return -1;\n  }\n  /**\n   * Collects all columns which \
titles has been changed in comparison to the previous state.\n   *\n   * \
@private\n   * @returns {Array} It returns an array of physical column \
indexes.\n   */\n  findColumnsWhereHeaderWasChanged() {\n    const \
columnHeaders = this.hot.getColHeader();\n    const {\n      \
cachedColumnHeaders\n    } = privatePool7.get(this);\n    const \
changedColumns = arrayReduce(columnHeaders, (acc, columnTitle, \
physicalColumn) => {\n      const cachedColumnsLength = \
cachedColumnHeaders.length;\n      if (cachedColumnsLength - 1 < \
physicalColumn || cachedColumnHeaders[physicalColumn] !== columnTitle) {\n    \
    acc.push(physicalColumn);\n      }\n      if (cachedColumnsLength - 1 < \
physicalColumn) {\n        cachedColumnHeaders.push(columnTitle);\n      } \
else {\n        cachedColumnHeaders[physicalColumn] = columnTitle;\n      }\n \
     return acc;\n    }, []);\n    return changedColumns;\n  }\n  /**\n   * \
Clears cache of calculated column widths. If you want to clear only selected \
columns pass an array with their indexes.\n   * Otherwise whole cache will be \
cleared.\n   *\n   * @param {number[]} [columns] List of physical column \
indexes to clear.\n   */\n  clearCache() {\n    let columns = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    if \
(columns.length) {\n      this.hot.batchExecution(() => {\n        \
arrayEach(columns, (physicalIndex) => {\n          \
this.columnWidthsMap.setValueAtIndex(physicalIndex, null);\n        });\n     \
 }, true);\n    } else {\n      this.columnWidthsMap.clear();\n    }\n  }\n  \
/**\n   * Checks if all widths were calculated. If not then return `true` \
(need recalculate).\n   *\n   * @returns {boolean}\n   */\n  \
isNeedRecalculate() {\n    return \
!!arrayFilter(this.columnWidthsMap.getValues().slice(0, \
this.measuredColumns), (item) => item === null).length;\n  }\n  /**\n   * On \
before view render listener.\n   *\n   * @private\n   */\n  \
onBeforeViewRender() {\n    this.calculateVisibleColumnsWidth();\n    if \
(this.isNeedRecalculate() && !this.inProgress) {\n      \
this.calculateAllColumnsWidth();\n    }\n  }\n  /**\n   * On after load data \
listener.\n   *\n   * @private\n   */\n  onAfterLoadData() {\n    if \
(this.hot.view) {\n      this.recalculateAllColumnsWidth();\n    } else {\n   \
   setTimeout(() => {\n        if (this.hot) {\n          \
this.recalculateAllColumnsWidth();\n        }\n      }, 0);\n    }\n  }\n  \
/**\n   * On before change listener.\n   *\n   * @private\n   * @param \
{Array} changes An array of modified data.\n   */\n  onBeforeChange(changes) \
{\n    const changedColumns = arrayMap(changes, (_ref2) => {\n      let [, \
columnProperty] = _ref2;\n      return \
this.hot.toPhysicalColumn(this.hot.propToCol(columnProperty));\n    });\n    \
this.clearCache(Array.from(new Set(changedColumns)));\n  }\n  /**\n   * On \
before column resize listener.\n   *\n   * @private\n   * @param {number} \
size Calculated new column width.\n   * @param {number} column Visual index \
of the resized column.\n   * @param {boolean} isDblClick  Flag that \
determines whether there was a double-click.\n   * @returns {number}\n   */\n \
 onBeforeColumnResize(size, column, isDblClick) {\n    let newSize = size;\n  \
  if (isDblClick) {\n      this.calculateColumnsWidth(column, void 0, \
true);\n      newSize = this.getColumnWidth(column, void 0, false);\n    }\n  \
  return newSize;\n  }\n  /**\n   * On after Handsontable init fill plugin \
with all necessary values.\n   *\n   * @private\n   */\n  onAfterInit() {\n   \
 privatePool7.get(this).cachedColumnHeaders = this.hot.getColHeader();\n  }\n \
 /**\n   * After formulas values updated listener.\n   *\n   * @private\n   * \
@param {Array} changes An array of modified data.\n   */\n  \
onAfterFormulasValuesUpdate(changes) {\n    const filteredChanges = \
arrayFilter(changes, (change) => {\n      var _change$address;\n      return \
isDefined((_change$address = change.address) === null || _change$address === \
void 0 ? void 0 : _change$address.col);\n    });\n    const changedColumns = \
arrayMap(filteredChanges, (change) => change.address.col);\n    \
this.clearCache(Array.from(new Set(changedColumns)));\n  }\n  /**\n   * \
Destroys the plugin instance.\n   */\n  destroy() {\n    \
this.ghostTable.clean();\n    super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/autofill/utils.mjs\nvar DIRECTIONS = {\n  \
horizontal: \"horizontal\",\n  vertical: \"vertical\"\n};\nfunction \
getDragDirectionAndRange(startSelection, endSelection, cellCoordsFactory) {\n \
 let startOfDragCoords;\n  let endOfDragCoords;\n  let directionOfDrag;\n  if \
(endSelection[0] === startSelection[0] && endSelection[1] < \
startSelection[1]) {\n    directionOfDrag = \"left\";\n    startOfDragCoords \
= cellCoordsFactory(endSelection[0], endSelection[1]);\n    endOfDragCoords = \
cellCoordsFactory(endSelection[2], startSelection[1] - 1);\n  } else if \
(endSelection[2] === startSelection[2] && endSelection[0] === \
startSelection[0] && endSelection[3] > startSelection[3]) {\n    \
directionOfDrag = \"right\";\n    startOfDragCoords = \
cellCoordsFactory(endSelection[0], startSelection[3] + 1);\n    \
endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);\n  } \
else if (endSelection[0] < startSelection[0] && endSelection[1] === \
startSelection[1]) {\n    directionOfDrag = \"up\";\n    startOfDragCoords = \
cellCoordsFactory(endSelection[0], endSelection[1]);\n    endOfDragCoords = \
cellCoordsFactory(startSelection[0] - 1, endSelection[3]);\n  } else if \
(endSelection[2] > startSelection[2] && endSelection[1] === \
startSelection[1]) {\n    directionOfDrag = \"down\";\n    startOfDragCoords \
= cellCoordsFactory(startSelection[2] + 1, endSelection[1]);\n    \
endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);\n  }\n \
 if (startOfDragCoords) {\n    startOfDragCoords.normalize();\n  }\n  if \
(endOfDragCoords) {\n    endOfDragCoords.normalize();\n  }\n  return {\n    \
directionOfDrag,\n    startOfDragCoords,\n    endOfDragCoords\n  \
};\n}\nfunction getMappedFillHandleSetting(fillHandle) {\n  const \
mappedSettings = {};\n  if (fillHandle === true) {\n    \
mappedSettings.directions = Object.keys(DIRECTIONS);\n    \
mappedSettings.autoInsertRow = true;\n  } else if (isObject(fillHandle)) {\n  \
  if (isDefined(fillHandle.autoInsertRow)) {\n      if (fillHandle.direction \
=== DIRECTIONS.horizontal) {\n        mappedSettings.autoInsertRow = false;\n \
     } else {\n        mappedSettings.autoInsertRow = \
fillHandle.autoInsertRow;\n      }\n    } else {\n      \
mappedSettings.autoInsertRow = false;\n    }\n    if \
(isDefined(fillHandle.direction)) {\n      mappedSettings.directions = \
[fillHandle.direction];\n    } else {\n      mappedSettings.directions = \
Object.keys(DIRECTIONS);\n    }\n  } else if (typeof fillHandle === \
\"string\") {\n    mappedSettings.directions = [fillHandle];\n    \
mappedSettings.autoInsertRow = true;\n  } else {\n    \
mappedSettings.directions = [];\n    mappedSettings.autoInsertRow = false;\n  \
}\n  return mappedSettings;\n}\n\n// \
node_modules/handsontable/plugins/autofill/autofill.mjs\npluginHooks_default.\
getSingleton().register(\"modifyAutofillRange\");\npluginHooks_default.getSin\
gleton().register(\"beforeAutofill\");\npluginHooks_default.getSingleton().re\
gister(\"afterAutofill\");\nvar PLUGIN_KEY3 = \"autofill\";\nvar \
PLUGIN_PRIORITY2 = 20;\nvar SETTING_KEYS = [\"fillHandle\"];\nvar \
INSERT_ROW_ALTER_ACTION_NAME = \"insert_row_below\";\nvar \
INTERVAL_FOR_ADDING_ROW = 200;\nvar Autofill = class extends BasePlugin {\n  \
static get PLUGIN_KEY() {\n    return PLUGIN_KEY3;\n  }\n  static get \
PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY2;\n  }\n  static get \
SETTING_KEYS() {\n    return [PLUGIN_KEY3, ...SETTING_KEYS];\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.eventManager = \
new eventManager_default(this);\n    this.addingStarted = false;\n    \
this.mouseDownOnCellCorner = false;\n    this.mouseDragOutside = false;\n    \
this.handleDraggedCells = 0;\n    this.directions = [];\n    \
this.autoInsertRow = false;\n  }\n  /**\n   * Checks if the plugin is enabled \
in the Handsontable settings.\n   *\n   * @returns {boolean}\n   */\n  \
isEnabled() {\n    return this.hot.getSettings().fillHandle;\n  }\n  /**\n   \
* Enables the plugin functionality for this Handsontable instance.\n   */\n  \
enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    \
this.mapSettings();\n    this.registerEvents();\n    \
this.addHook(\"afterOnCellCornerMouseDown\", (event2) => \
this.onAfterCellCornerMouseDown(event2));\n    \
this.addHook(\"afterOnCellCornerDblClick\", (event2) => \
this.onCellCornerDblClick(event2));\n    \
this.addHook(\"beforeOnCellMouseOver\", (_, coords) => \
this.onBeforeCellMouseOver(coords));\n    super.enablePlugin();\n  }\n  /**\n \
  * Updates the plugin's state.\n   *\n   * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - `autofill`\n   *  - \
[`fillHandle`](@/api/options.md#fillhandle)\n   */\n  updatePlugin() {\n    \
this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  \
}\n  /**\n   * Disables the plugin functionality for this Handsontable \
instance.\n   */\n  disablePlugin() {\n    this.clearMappedSettings();\n    \
super.disablePlugin();\n  }\n  /**\n   * Gets selection data.\n   *\n   * \
@private\n   * @returns {object[]} Ranges Array of objects with properties \
`startRow`, `startCol`, `endRow` and `endCol`.\n   */\n  getSelectionData() \
{\n    const selection = this.hot.getSelectedRangeLast();\n    const {\n      \
row: startRow,\n      col: startCol\n    } = selection.getTopStartCorner();\n \
   const {\n      row: endRow,\n      col: endCol\n    } = \
selection.getBottomEndCorner();\n    const copyableRanges = \
this.hot.runHooks(\"modifyCopyableRange\", [{\n      startRow,\n      \
startCol,\n      endRow,\n      endCol\n    }]);\n    const copyableRows = \
[];\n    const copyableColumns = [];\n    const data2 = [];\n    \
arrayEach(copyableRanges, (range) => {\n      for (let visualRow = \
range.startRow; visualRow <= range.endRow; visualRow += 1) {\n        if \
(copyableRows.indexOf(visualRow) === -1) {\n          \
copyableRows.push(visualRow);\n        }\n      }\n      for (let \
visualColumn = range.startCol; visualColumn <= range.endCol; visualColumn += \
1) {\n        if (copyableColumns.indexOf(visualColumn) === -1) {\n          \
copyableColumns.push(visualColumn);\n        }\n      }\n    });\n    \
arrayEach(copyableRows, (row) => {\n      const rowSet = [];\n      \
arrayEach(copyableColumns, (column) => {\n        \
rowSet.push(this.hot.getCopyableData(row, column));\n      });\n      \
data2.push(rowSet);\n    });\n    return data2;\n  }\n  /**\n   * Try to \
apply fill values to the area in fill border, omitting the selection \
border.\n   *\n   * @private\n   * @returns {boolean} Reports if fill was \
applied.\n   *\n   * @fires Hooks#modifyAutofillRange\n   * @fires \
Hooks#beforeAutofill\n   * @fires Hooks#afterAutofill\n   */\n  fillIn() {\n  \
  if (this.hot.selection.highlight.getFill().isEmpty()) {\n      return \
false;\n    }\n    const [fillStartRow, fillStartColumn, fillEndRow, \
fillEndColumn] = this.hot.selection.highlight.getFill().getVisualCorners();\n \
   const selectionRangeLast = this.hot.getSelectedRangeLast();\n    const \
topStartCorner = selectionRangeLast.getTopStartCorner();\n    const \
bottomEndCorner = selectionRangeLast.getBottomEndCorner();\n    \
this.resetSelectionOfDraggedArea();\n    const cornersOfSelectedCells = \
[topStartCorner.row, topStartCorner.col, bottomEndCorner.row, \
bottomEndCorner.col];\n    const cornersOfSelectionAndDragAreas = \
this.hot.runHooks(\"modifyAutofillRange\", [Math.min(topStartCorner.row, \
fillStartRow), Math.min(topStartCorner.col, fillStartColumn), \
Math.max(bottomEndCorner.row, fillEndRow), Math.max(bottomEndCorner.col, \
fillEndColumn)], cornersOfSelectedCells);\n    const {\n      \
directionOfDrag,\n      startOfDragCoords,\n      endOfDragCoords\n    } = \
getDragDirectionAndRange(cornersOfSelectedCells, \
cornersOfSelectionAndDragAreas, (row, column) => \
this.hot._createCellCoords(row, column));\n    if (startOfDragCoords && \
startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {\n      const \
selectionData = this.getSelectionData();\n      const sourceRange = \
selectionRangeLast.clone();\n      const targetRange = \
this.hot._createCellRange(startOfDragCoords, startOfDragCoords, \
endOfDragCoords);\n      const beforeAutofillHookResult = \
this.hot.runHooks(\"beforeAutofill\", selectionData, sourceRange, \
targetRange, directionOfDrag);\n      if (beforeAutofillHookResult === false) \
{\n        this.hot.selection.highlight.getFill().clear();\n        \
this.hot.render();\n        return false;\n      }\n      let fillData = \
beforeAutofillHookResult;\n      const res = beforeAutofillHookResult;\n      \
if ([\"up\", \"left\"].indexOf(directionOfDrag) > -1 && !(res.length === 1 && \
res[0].length === 0)) {\n        fillData = [];\n        if (directionOfDrag \
=== \"up\") {\n          const dragLength = endOfDragCoords.row - \
startOfDragCoords.row + 1;\n          const fillOffset = dragLength % \
res.length;\n          for (let i = 0; i < dragLength; i++) {\n            \
fillData.push(res[(i + (res.length - fillOffset)) % res.length]);\n          \
}\n        } else {\n          const dragLength = endOfDragCoords.col - \
startOfDragCoords.col + 1;\n          const fillOffset = dragLength % \
res[0].length;\n          for (let i = 0; i < res.length; i++) {\n            \
fillData.push([]);\n            for (let j = 0; j < dragLength; j++) {\n      \
        fillData[i].push(res[i][(j + (res[i].length - fillOffset)) % \
res[i].length]);\n            }\n          }\n        }\n      }\n      \
this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, \
fillData, endOfDragCoords.row, endOfDragCoords.col, \
`${this.pluginName}.fill`, null);\n      \
this.setSelection(cornersOfSelectionAndDragAreas);\n      \
this.hot.runHooks(\"afterAutofill\", fillData, sourceRange, targetRange, \
directionOfDrag);\n      this.hot.render();\n    } else {\n      \
this.hot._refreshBorders();\n    }\n    return true;\n  }\n  /**\n   * \
Reduces the selection area if the handle was dragged outside of the table or \
on headers.\n   *\n   * @private\n   * @param {CellCoords} coords Indexes of \
selection corners.\n   * @returns {CellCoords}\n   */\n  \
reduceSelectionAreaIfNeeded(coords) {\n    if (coords.row < 0) {\n      \
coords.row = 0;\n    }\n    if (coords.col < 0) {\n      coords.col = 0;\n    \
}\n    return coords;\n  }\n  /**\n   * Gets the coordinates of the drag & \
drop borders.\n   *\n   * @private\n   * @param {CellCoords} \
coordsOfSelection `CellCoords` coord object.\n   * @returns {CellCoords}\n   \
*/\n  getCoordsOfDragAndDropBorders(coordsOfSelection) {\n    const \
currentSelection = this.hot.getSelectedRangeLast();\n    const \
bottomRightCorner = currentSelection.getBottomEndCorner();\n    let coords = \
coordsOfSelection;\n    if (this.directions.includes(DIRECTIONS.vertical) && \
this.directions.includes(DIRECTIONS.horizontal)) {\n      const \
topStartCorner = currentSelection.getTopStartCorner();\n      if \
(bottomRightCorner.col <= coordsOfSelection.col || topStartCorner.col >= \
coordsOfSelection.col) {\n        coords = \
this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n   \
   }\n      if (bottomRightCorner.row < coordsOfSelection.row || \
topStartCorner.row > coordsOfSelection.row) {\n        coords = \
this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);\n   \
   }\n    } else if (this.directions.includes(DIRECTIONS.vertical)) {\n      \
coords = this.hot._createCellCoords(coordsOfSelection.row, \
bottomRightCorner.col);\n    } else if \
(this.directions.includes(DIRECTIONS.horizontal)) {\n      coords = \
this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n   \
 } else {\n      return;\n    }\n    return \
this.reduceSelectionAreaIfNeeded(coords);\n  }\n  /**\n   * Show the fill \
border.\n   *\n   * @private\n   * @param {CellCoords} coordsOfSelection \
`CellCoords` coord object.\n   */\n  showBorder(coordsOfSelection) {\n    \
const coordsOfDragAndDropBorders = \
this.getCoordsOfDragAndDropBorders(coordsOfSelection);\n    if \
(coordsOfDragAndDropBorders) {\n      \
this.redrawBorders(coordsOfDragAndDropBorders);\n    }\n  }\n  /**\n   * Add \
new row.\n   *\n   * @private\n   */\n  addRow() {\n    \
this.hot._registerTimeout(() => {\n      \
this.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, void 0, 1, \
`${this.pluginName}.fill`);\n      this.addingStarted = false;\n    }, \
INTERVAL_FOR_ADDING_ROW);\n  }\n  /**\n   * Add new rows if they are needed \
to continue auto-filling values.\n   *\n   * @private\n   */\n  \
addNewRowIfNeeded() {\n    if \
(!this.hot.selection.highlight.getFill().isEmpty() && this.addingStarted === \
false && this.autoInsertRow) {\n      const cornersOfSelectedCells = \
this.hot.getSelectedLast();\n      const cornersOfSelectedDragArea = \
this.hot.selection.highlight.getFill().getVisualCorners();\n      const \
nrOfTableRows = this.hot.countRows();\n      if (cornersOfSelectedCells[2] < \
nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {\n  \
      this.addingStarted = true;\n        this.addRow();\n      }\n    }\n  \
}\n  /**\n   * Get index of last adjacent filled in row.\n   *\n   * \
@private\n   * @param {Array} cornersOfSelectedCells Indexes of selection \
corners.\n   * @returns {number} Gives number greater than or equal to zero \
when selection adjacent can be applied.\n   *                   Or -1 when \
selection adjacent can't be applied.\n   */\n  \
getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {\n    const data2 \
= this.hot.getData();\n    const nrOfTableRows = this.hot.countRows();\n    \
let lastFilledInRowIndex;\n    for (let rowIndex = cornersOfSelectedCells[2] \
+ 1; rowIndex < nrOfTableRows; rowIndex++) {\n      for (let columnIndex = \
cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; \
columnIndex++) {\n        const dataInCell = data2[rowIndex][columnIndex];\n  \
      if (dataInCell) {\n          return -1;\n        }\n      }\n      \
const dataInNextLeftCell = data2[rowIndex][cornersOfSelectedCells[1] - 1];\n  \
    const dataInNextRightCell = data2[rowIndex][cornersOfSelectedCells[3] + \
1];\n      if (!!dataInNextLeftCell || !!dataInNextRightCell) {\n        \
lastFilledInRowIndex = rowIndex;\n      }\n    }\n    return \
lastFilledInRowIndex;\n  }\n  /**\n   * Adds a selection from the start area \
to the specific row index.\n   *\n   * @private\n   * @param {Array} \
selectStartArea Selection area from which we start to create more \
comprehensive selection.\n   * @param {number} rowIndex The row index into \
the selection will be added.\n   */\n  \
addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {\n    \
this.hot.selection.highlight.getFill().clear().add(this.hot._createCellCoords\
(selectStartArea[0], \
selectStartArea[1])).add(this.hot._createCellCoords(rowIndex, \
selectStartArea[3])).commit();\n  }\n  /**\n   * Sets selection based on \
passed corners.\n   *\n   * @private\n   * @param {Array} cornersOfArea An \
array witch defines selection.\n   */\n  setSelection(cornersOfArea) {\n    \
this.hot.selectCell(...arrayMap(cornersOfArea, (index2) => Math.max(index2, \
0)), false, false);\n  }\n  /**\n   * Try to select cells down to the last \
row in the left column and then returns if selection was applied.\n   *\n   * \
@private\n   * @returns {boolean}\n   */\n  selectAdjacent() {\n    const \
cornersOfSelectedCells = this.hot.getSelectedLast();\n    const \
lastFilledInRowIndex = \
this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);\n    if \
(lastFilledInRowIndex === -1 || lastFilledInRowIndex === void 0) {\n      \
return false;\n    }\n    \
this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, \
lastFilledInRowIndex);\n    return true;\n  }\n  /**\n   * Resets selection \
of dragged area.\n   *\n   * @private\n   */\n  resetSelectionOfDraggedArea() \
{\n    this.handleDraggedCells = 0;\n    \
this.hot.selection.highlight.getFill().clear();\n  }\n  /**\n   * Redraws \
borders.\n   *\n   * @private\n   * @param {CellCoords} coords `CellCoords` \
coord object.\n   */\n  redrawBorders(coords) {\n    \
this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeL\
ast().from).add(this.hot.getSelectedRangeLast().to).add(coords).commit();\n   \
 this.hot.view.render();\n  }\n  /**\n   * Get if mouse was dragged \
outside.\n   *\n   * @private\n   * @param {MouseEvent} event `mousemove` \
event properties.\n   * @returns {boolean}\n   */\n  \
getIfMouseWasDraggedOutside(event2) {\n    const {\n      documentElement\n   \
 } = this.hot.rootDocument;\n    const tableBottom = \
offset(this.hot.table).top - (this.hot.rootWindow.pageYOffset || \
documentElement.scrollTop) + outerHeight(this.hot.table);\n    const \
tableRight = offset(this.hot.table).left - (this.hot.rootWindow.pageXOffset \
|| documentElement.scrollLeft) + outerWidth(this.hot.table);\n    return \
event2.clientY > tableBottom && event2.clientX <= tableRight;\n  }\n  /**\n   \
* Bind the events used by the plugin.\n   *\n   * @private\n   */\n  \
registerEvents() {\n    const {\n      documentElement\n    } = \
this.hot.rootDocument;\n    \
this.eventManager.addEventListener(documentElement, \"mouseup\", () => \
this.onMouseUp());\n    this.eventManager.addEventListener(documentElement, \
\"mousemove\", (event2) => this.onMouseMove(event2));\n  }\n  /**\n   * On \
cell corner double click callback.\n   *\n   * @private\n   */\n  \
onCellCornerDblClick() {\n    const selectionApplied = \
this.selectAdjacent();\n    if (selectionApplied) {\n      this.fillIn();\n   \
 }\n  }\n  /**\n   * On after cell corner mouse down listener.\n   *\n   * \
@private\n   */\n  onAfterCellCornerMouseDown() {\n    \
this.handleDraggedCells = 1;\n    this.mouseDownOnCellCorner = true;\n  }\n  \
/**\n   * On before cell mouse over listener.\n   *\n   * @private\n   * \
@param {CellCoords} coords `CellCoords` coord object.\n   */\n  \
onBeforeCellMouseOver(coords) {\n    if (this.mouseDownOnCellCorner && \
!this.hot.view.isMouseDown() && this.handleDraggedCells) {\n      \
this.handleDraggedCells += 1;\n      this.showBorder(coords);\n      \
this.addNewRowIfNeeded();\n    }\n  }\n  /**\n   * On mouse up listener.\n   \
*\n   * @private\n   */\n  onMouseUp() {\n    if (this.handleDraggedCells) \
{\n      if (this.handleDraggedCells > 1) {\n        this.fillIn();\n      \
}\n      this.handleDraggedCells = 0;\n      this.mouseDownOnCellCorner = \
false;\n    }\n  }\n  /**\n   * On mouse move listener.\n   *\n   * \
@private\n   * @param {MouseEvent} event `mousemove` event properties.\n   \
*/\n  onMouseMove(event2) {\n    const mouseWasDraggedOutside = \
this.getIfMouseWasDraggedOutside(event2);\n    if (this.addingStarted === \
false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {\n      \
this.mouseDragOutside = true;\n      this.addingStarted = true;\n    } else \
{\n      this.mouseDragOutside = false;\n    }\n    if (this.mouseDragOutside \
&& this.autoInsertRow) {\n      this.addRow();\n    }\n  }\n  /**\n   * \
Clears mapped settings.\n   *\n   * @private\n   */\n  clearMappedSettings() \
{\n    this.directions.length = 0;\n    this.autoInsertRow = false;\n  }\n  \
/**\n   * Map settings.\n   *\n   * @private\n   */\n  mapSettings() {\n    \
const mappedSettings = \
getMappedFillHandleSetting(this.hot.getSettings().fillHandle);\n    \
this.directions = mappedSettings.directions;\n    this.autoInsertRow = \
mappedSettings.autoInsertRow;\n  }\n  /**\n   * Destroys the plugin \
instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/autoRowSize/autoRowSize.mjs\nvar \
PLUGIN_KEY4 = \"autoRowSize\";\nvar PLUGIN_PRIORITY3 = 40;\nvar \
ROW_WIDTHS_MAP_NAME = \"autoRowSize\";\nvar AutoRowSize = class _AutoRowSize \
extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY4;\n  \
}\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY3;\n  }\n  \
static get SETTING_KEYS() {\n    return true;\n  }\n  static get \
CALCULATION_STEP() {\n    return 50;\n  }\n  static get \
SYNC_CALCULATION_LIMIT() {\n    return 500;\n  }\n  constructor(hotInstance) \
{\n    super(hotInstance);\n    this.rowHeightsMap = void 0;\n    \
this.headerHeight = null;\n    this.ghostTable = new \
ghostTable_default(this.hot);\n    this.samplesGenerator = new \
samplesGenerator_default((row, col) => {\n      let cellValue;\n      if (row \
>= 0) {\n        cellValue = this.hot.getDataAtCell(row, col);\n      } else \
if (row === -1) {\n        cellValue = this.hot.getColHeader(col);\n      }\n \
     return {\n        value: cellValue\n      };\n    });\n    \
this.firstCalculation = true;\n    this.inProgress = false;\n    \
this.measuredRows = 0;\n    this.rowHeightsMap = new \
PhysicalIndexToValueMap();\n    \
this.hot.rowIndexMapper.registerMap(ROW_WIDTHS_MAP_NAME, \
this.rowHeightsMap);\n    this.addHook(\"beforeRowResize\", (size, row, \
isDblClick) => this.onBeforeRowResize(size, row, isDblClick));\n  }\n  /**\n  \
 * Checks if the plugin is enabled in the handsontable settings. This method \
is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` \
then the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * \
@returns {boolean}\n   */\n  isEnabled() {\n    const settings = \
this.hot.getSettings()[PLUGIN_KEY4];\n    return settings === true || \
isObject(settings);\n  }\n  /**\n   * Enables the plugin functionality for \
this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = \
this;\n    if (this.enabled) {\n      return;\n    }\n    \
this.setSamplingOptions();\n    this.addHook(\"afterLoadData\", function() \
{\n      return _this.onAfterLoadData(...arguments);\n    });\n    \
this.addHook(\"beforeChangeRender\", (changes) => \
this.onBeforeChange(changes));\n    this.addHook(\"beforeColumnResize\", () \
=> this.recalculateAllRowsHeight());\n    this.addHook(\"beforeViewRender\", \
(force) => this.onBeforeViewRender(force));\n    \
this.addHook(\"modifyRowHeight\", (height, row) => this.getRowHeight(row, \
height));\n    this.addHook(\"modifyColumnHeaderHeight\", () => \
this.getColumnHeaderHeight());\n    super.enablePlugin();\n  }\n  /**\n   * \
Disables the plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    this.headerHeight = null;\n    \
super.disablePlugin();\n    this.addHook(\"beforeRowResize\", (size, row, \
isDblClick) => this.onBeforeRowResize(size, row, isDblClick));\n  }\n  /**\n  \
 * Calculate a given rows height.\n   *\n   * @param {number|object} rowRange \
Row index or an object with `from` and `to` indexes as a range.\n   * @param \
{number|object} colRange Column index or an object with `from` and `to` \
indexes as a range.\n   * @param {boolean} [force=false] If `true` the \
calculation will be processed regardless of whether the width exists in the \
cache.\n   */\n  calculateRowsHeight() {\n    let rowRange = arguments.length \
> 0 && arguments[0] !== void 0 ? arguments[0] : {\n      from: 0,\n      to: \
this.hot.countRows() - 1\n    };\n    let colRange = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : {\n      from: 0,\n      to: \
this.hot.countCols() - 1\n    };\n    let force = arguments.length > 2 && \
arguments[2] !== void 0 ? arguments[2] : false;\n    const rowsRange = typeof \
rowRange === \"number\" ? {\n      from: rowRange,\n      to: rowRange\n    } \
: rowRange;\n    const columnsRange = typeof colRange === \"number\" ? {\n    \
  from: colRange,\n      to: colRange\n    } : colRange;\n    if \
(this.hot.getColHeader(0) !== null) {\n      const samples = \
this.samplesGenerator.generateRowSamples(-1, columnsRange);\n      \
this.ghostTable.addColumnHeadersRow(samples.get(-1));\n    }\n    \
rangeEach(rowsRange.from, rowsRange.to, (row) => {\n      if (force || \
this.rowHeightsMap.getValueAtIndex(row) === null) {\n        const samples = \
this.samplesGenerator.generateRowSamples(row, columnsRange);\n        \
arrayEach(samples, (_ref) => {\n          let [rowIndex, sample] = _ref;\n    \
      return this.ghostTable.addRow(rowIndex, sample);\n        });\n      \
}\n    });\n    if (this.ghostTable.rows.length) {\n      \
this.hot.batchExecution(() => {\n        this.ghostTable.getHeights((row, \
height) => {\n          if (row < 0) {\n            this.headerHeight = \
height;\n          } else {\n            \
this.rowHeightsMap.setValueAtIndex(this.hot.toPhysicalRow(row), height);\n    \
      }\n        });\n      }, true);\n      this.measuredRows = rowsRange.to \
+ 1;\n      this.ghostTable.clean();\n    }\n  }\n  /**\n   * Calculate all \
rows heights. The calculated row will be cached in the {@link \
AutoRowSize#heights} property.\n   * To retrieve height for specified row use \
{@link AutoRowSize#getRowHeight} method.\n   *\n   * @param {object|number} \
colRange Row index or an object with `from` and `to` properties which define \
row range.\n   */\n  calculateAllRowsHeight() {\n    let colRange = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n      \
from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let current = 0;\n  \
  const length = this.hot.countRows() - 1;\n    let timer = null;\n    \
this.inProgress = true;\n    const loop = () => {\n      if (!this.hot) {\n   \
     cancelAnimationFrame(timer);\n        this.inProgress = false;\n        \
return;\n      }\n      this.calculateRowsHeight({\n        from: current,\n  \
      to: Math.min(current + _AutoRowSize.CALCULATION_STEP, length)\n      }, \
colRange);\n      current = current + _AutoRowSize.CALCULATION_STEP + 1;\n    \
  if (current < length) {\n        timer = requestAnimationFrame(loop);\n     \
 } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = \
false;\n        this.hot.view.adjustElementsSize(true);\n        if \
(this.hot.view._wt.wtOverlays.inlineStartOverlay.needFullRender) {\n          \
this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.draw();\n        }\n    \
  }\n    };\n    const syncLimit = this.getSyncCalculationLimit();\n    if \
(this.firstCalculation && syncLimit >= 0) {\n      \
this.calculateRowsHeight({\n        from: 0,\n        to: syncLimit\n      }, \
colRange);\n      this.firstCalculation = false;\n      current = syncLimit + \
1;\n    }\n    if (current < length) {\n      loop();\n    } else {\n      \
this.inProgress = false;\n      this.hot.view.adjustElementsSize(false);\n    \
}\n  }\n  /**\n   * Sets the sampling options.\n   *\n   * @private\n   */\n  \
setSamplingOptions() {\n    const setting = \
this.hot.getSettings()[PLUGIN_KEY4];\n    const samplingRatio = setting && \
hasOwnProperty(setting, \"samplingRatio\") ? setting.samplingRatio : void \
0;\n    const allowSampleDuplicates = setting && hasOwnProperty(setting, \
\"allowSampleDuplicates\") ? setting.allowSampleDuplicates : void 0;\n    if \
(samplingRatio && !isNaN(samplingRatio)) {\n      \
this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n   \
 if (allowSampleDuplicates) {\n      \
this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  \
}\n  /**\n   * Recalculates all rows height (overwrite cache values).\n   \
*/\n  recalculateAllRowsHeight() {\n    if \
(isVisible(this.hot.view._wt.wtTable.TABLE)) {\n      this.clearCache();\n    \
  this.calculateAllRowsHeight();\n    }\n  }\n  /**\n   * Gets value which \
tells how many rows should be calculated synchronously (rest of the rows will \
be calculated\n   * asynchronously). The limit is calculated based on \
`syncLimit` set to autoRowSize option (see {@link Options#autoRowSize}).\n   \
*\n   * @returns {number}\n   */\n  getSyncCalculationLimit() {\n    const \
settings = this.hot.getSettings()[PLUGIN_KEY4];\n    let limit = \
_AutoRowSize.SYNC_CALCULATION_LIMIT;\n    const rowsLimit = \
this.hot.countRows() - 1;\n    if (isObject(settings)) {\n      limit = \
settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = \
valueAccordingPercent(rowsLimit, limit);\n      } else {\n        limit >>= \
0;\n      }\n    }\n    return Math.min(limit, rowsLimit);\n  }\n  /**\n   * \
Get a row's height, as measured in the DOM.\n   *\n   * The height returned \
includes 1 px of the row's bottom border.\n   *\n   * Mind that this method \
is different from the\n   * [`getRowHeight()`](@/api/core.md#getrowheight) \
method\n   * of Handsontable's [Core](@/api/core.md).\n   *\n   * @param \
{number} row A visual row index.\n   * @param {number} [defaultHeight] If no \
height is found, `defaultHeight` is returned instead.\n   * @returns {number} \
The height of the specified row, in pixels.\n   */\n  getRowHeight(row) {\n   \
 let defaultHeight = arguments.length > 1 && arguments[1] !== void 0 ? \
arguments[1] : void 0;\n    const cachedHeight = row < 0 ? this.headerHeight \
: this.rowHeightsMap.getValueAtIndex(this.hot.toPhysicalRow(row));\n    let \
height = defaultHeight;\n    if (cachedHeight !== null && cachedHeight > \
(defaultHeight || 0)) {\n      height = cachedHeight;\n    }\n    return \
height;\n  }\n  /**\n   * Get the calculated column header height.\n   *\n   \
* @returns {number|undefined}\n   */\n  getColumnHeaderHeight() {\n    return \
this.headerHeight;\n  }\n  /**\n   * Get the first visible row.\n   *\n   * \
@returns {number} Returns row index, -1 if table is not rendered or if there \
are no rows to base the the calculations on.\n   */\n  getFirstVisibleRow() \
{\n    const wot = this.hot.view._wt;\n    if \
(wot.wtViewport.rowsVisibleCalculator) {\n      return \
wot.wtTable.getFirstVisibleRow();\n    }\n    if \
(wot.wtViewport.rowsRenderCalculator) {\n      return \
wot.wtTable.getFirstRenderedRow();\n    }\n    return -1;\n  }\n  /**\n   * \
Gets the last visible row.\n   *\n   * @returns {number} Returns row index or \
-1 if table is not rendered.\n   */\n  getLastVisibleRow() {\n    const wot = \
this.hot.view._wt;\n    if (wot.wtViewport.rowsVisibleCalculator) {\n      \
return wot.wtTable.getLastVisibleRow();\n    }\n    if \
(wot.wtViewport.rowsRenderCalculator) {\n      return \
wot.wtTable.getLastRenderedRow();\n    }\n    return -1;\n  }\n  /**\n   * \
Clears cached heights.\n   */\n  clearCache() {\n    this.headerHeight = \
null;\n    this.rowHeightsMap.init();\n  }\n  /**\n   * Clears cache by \
range.\n   *\n   * @param {object|number} range Row index or an object with \
`from` and `to` properties which define row range.\n   */\n  \
clearCacheByRange(range) {\n    const {\n      from,\n      to\n    } = \
typeof range === \"number\" ? {\n      from: range,\n      to: range\n    } : \
range;\n    this.hot.batchExecution(() => {\n      rangeEach(Math.min(from, \
to), Math.max(from, to), (row) => {\n        \
this.rowHeightsMap.setValueAtIndex(row, null);\n      });\n    }, true);\n  \
}\n  /**\n   * Checks if all heights were calculated. If not then return \
`true` (need recalculate).\n   *\n   * @returns {boolean}\n   */\n  \
isNeedRecalculate() {\n    return \
!!arrayFilter(this.rowHeightsMap.getValues().slice(0, this.measuredRows), \
(item) => item === null).length;\n  }\n  /**\n   * On before view render \
listener.\n   *\n   * @private\n   */\n  onBeforeViewRender() {\n    const \
force = this.hot.renderCall;\n    const fixedRowsBottom = \
this.hot.getSettings().fixedRowsBottom;\n    const firstVisibleRow = \
this.getFirstVisibleRow();\n    const lastVisibleRow = \
this.getLastVisibleRow();\n    if (firstVisibleRow === -1 || lastVisibleRow \
=== -1) {\n      return;\n    }\n    this.calculateRowsHeight({\n      from: \
firstVisibleRow,\n      to: lastVisibleRow\n    }, void 0, force);\n    if \
(fixedRowsBottom) {\n      const totalRows = this.hot.countRows() - 1;\n      \
this.calculateRowsHeight({\n        from: totalRows - fixedRowsBottom,\n      \
  to: totalRows\n      });\n    }\n    if (this.isNeedRecalculate() && \
!this.inProgress) {\n      this.calculateAllRowsHeight();\n    }\n  }\n  \
/**\n   * On before row move listener.\n   *\n   * @private\n   * @param \
{number} from Row index where was grabbed.\n   * @param {number} to \
Destination row index.\n   */\n  onBeforeRowMove(from, to) {\n    \
this.clearCacheByRange({\n      from,\n      to\n    });\n    \
this.calculateAllRowsHeight();\n  }\n  /**\n   * On before row resize \
listener.\n   *\n   * @private\n   * @param {number} size The size of the \
current row index.\n   * @param {number} row Current row index.\n   * @param \
{boolean} isDblClick Indicates if the resize was triggered by doubleclick.\n  \
 * @returns {number}\n   */\n  onBeforeRowResize(size, row, isDblClick) {\n   \
 let newSize = size;\n    if (isDblClick) {\n      \
this.calculateRowsHeight(row, void 0, true);\n      newSize = \
this.getRowHeight(row);\n    }\n    return newSize;\n  }\n  /**\n   * On \
after load data listener.\n   *\n   * @private\n   */\n  onAfterLoadData() \
{\n    if (this.hot.view) {\n      this.recalculateAllRowsHeight();\n    } \
else {\n      setTimeout(() => {\n        if (this.hot) {\n          \
this.recalculateAllRowsHeight();\n        }\n      }, 0);\n    }\n  }\n  \
/**\n   * On before change listener.\n   *\n   * @private\n   * @param \
{Array} changes 2D array containing information about each of the edited \
cells.\n   */\n  onBeforeChange(changes) {\n    let range = null;\n    if \
(changes.length === 1) {\n      range = changes[0][0];\n    } else if \
(changes.length > 1) {\n      range = {\n        from: changes[0][0],\n       \
 to: changes[changes.length - 1][0]\n      };\n    }\n    if (range !== null) \
{\n      this.clearCacheByRange(range);\n    }\n  }\n  /**\n   * Destroys the \
plugin instance.\n   */\n  destroy() {\n    this.ghostTable.clean();\n    \
super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/bindRowsWithHeaders/maps/looseBindsMap.mjs\
\nvar {\n  getListWithInsertedItems: getListWithInsertedItems3,\n  \
getListWithRemovedItems: getListWithRemovedItems3\n} = \
alterUtilsFactory(\"physicallyIndexed\");\nvar LooseBindsMap = class extends \
IndexMap {\n  constructor() {\n    super((index2) => index2);\n  }\n  /**\n   \
* Add values to list and reorganize.\n   *\n   * @private\n   * @param \
{number} insertionIndex Position inside the list.\n   * @param {Array} \
insertedIndexes List of inserted indexes.\n   */\n  insert(insertionIndex, \
insertedIndexes) {\n    const listAfterUpdate = \
getIncreasedIndexes(this.indexedValues, insertedIndexes);\n    \
this.indexedValues = getListWithInsertedItems3(listAfterUpdate, \
insertionIndex, insertedIndexes, this.initValueOrFn);\n    \
super.insert(insertionIndex, insertedIndexes);\n  }\n  /**\n   * Remove \
values from the list and reorganize.\n   *\n   * @private\n   * @param \
{Array} removedIndexes List of removed indexes.\n   */\n  \
remove(removedIndexes) {\n    const listAfterUpdate = \
getListWithRemovedItems3(this.indexedValues, removedIndexes);\n    \
this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);\n  \
  super.remove(removedIndexes);\n  }\n};\nvar looseBindsMap_default = \
LooseBindsMap;\n\n// \
node_modules/handsontable/plugins/bindRowsWithHeaders/maps/strictBindsMap.mjs\
\nvar {\n  getListWithInsertedItems: getListWithInsertedItems4,\n  \
getListWithRemovedItems: getListWithRemovedItems4\n} = \
alterUtilsFactory(\"physicallyIndexed\");\nvar StrictBindsMap = class extends \
IndexMap {\n  constructor() {\n    super((index2) => index2);\n  }\n  /**\n   \
* Add values to list and reorganize.\n   *\n   * @private\n   * @param \
{number} insertionIndex Position inside the list.\n   * @param {Array} \
insertedIndexes List of inserted indexes.\n   */\n  insert(insertionIndex, \
insertedIndexes) {\n    this.indexedValues = \
getListWithInsertedItems4(this.indexedValues, insertionIndex, \
insertedIndexes, (_, ordinalNumber) => this.getNextValue(ordinalNumber));\n   \
 super.insert(insertionIndex, insertedIndexes);\n  }\n  /**\n   * Remove \
values from the list and reorganize.\n   *\n   * @private\n   * @param \
{Array} removedIndexes List of removed indexes.\n   */\n  \
remove(removedIndexes) {\n    this.indexedValues = \
getListWithRemovedItems4(this.indexedValues, removedIndexes);\n    \
super.remove(removedIndexes);\n  }\n  /**\n   * Get next values, which should \
be greater than actual maximum value in the list.\n   *\n   * @param {number} \
ordinalNumber Position in the list.\n   * @returns {number}\n   */\n  \
getNextValue(ordinalNumber) {\n    return Math.max(...this.getValues()) + 1 + \
ordinalNumber;\n  }\n};\nvar strictBindsMap_default = StrictBindsMap;\n\n// \
node_modules/handsontable/plugins/bindRowsWithHeaders/bindRowsWithHeaders.mjs\
\nvar PLUGIN_KEY5 = \"bindRowsWithHeaders\";\nvar PLUGIN_PRIORITY4 = \
210;\nvar DEFAULT_BIND = \"loose\";\nvar bindTypeToMapStrategy = /* @__PURE__ \
*/ new Map([[\"loose\", looseBindsMap_default], [\"strict\", \
strictBindsMap_default]]);\nvar BindRowsWithHeaders = class extends \
BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY5;\n  }\n  \
static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY4;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.headerIndexes = \
null;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable \
settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and \
if it returns `true` then the {@link BindRowsWithHeaders#enablePlugin} method \
is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY5];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
if (this.enabled) {\n      return;\n    }\n    let bindType = \
this.hot.getSettings()[PLUGIN_KEY5];\n    if (typeof bindType !== \"string\") \
{\n      bindType = DEFAULT_BIND;\n    }\n    const MapStrategy = \
bindTypeToMapStrategy.get(bindType);\n    this.headerIndexes = \
this.hot.rowIndexMapper.registerMap(\"bindRowsWithHeaders\", new \
MapStrategy());\n    this.addHook(\"modifyRowHeader\", (row) => \
this.onModifyRowHeader(row));\n    super.enablePlugin();\n  }\n  /**\n   * \
Disables the plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    \
this.hot.rowIndexMapper.unregisterMap(\"bindRowsWithHeaders\");\n    \
super.disablePlugin();\n  }\n  /**\n   * On modify row header listener.\n   \
*\n   * @private\n   * @param {number} row Row index.\n   * @returns \
{number}\n   */\n  onModifyRowHeader(row) {\n    return \
this.headerIndexes.getValueAtIndex(this.hot.toPhysicalRow(row));\n  }\n  \
/**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    \
super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/collapsibleColumns/collapsibleColumns.mjs\n\
function _classPrivateFieldInitSpec6(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration7(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration7(obj, privateCollection) {\n  \
if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_defineProperty17(obj, key, value) {\n  key = _toPropertyKey17(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey17(arg) {\n  var key = \
_toPrimitive17(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive17(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nfunction _classPrivateFieldGet6(receiver, privateMap) {\n \
 var descriptor = _classExtractFieldDescriptor6(receiver, privateMap, \
\"get\");\n  return _classApplyDescriptorGet6(receiver, \
descriptor);\n}\nfunction _classApplyDescriptorGet6(receiver, descriptor) {\n \
 if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  \
return descriptor.value;\n}\nfunction _classPrivateFieldSet6(receiver, \
privateMap, value) {\n  var descriptor = \
_classExtractFieldDescriptor6(receiver, privateMap, \"set\");\n  \
_classApplyDescriptorSet6(receiver, descriptor, value);\n  return \
value;\n}\nfunction _classExtractFieldDescriptor6(receiver, privateMap, \
action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorSet6(receiver, descriptor, value) {\n  if \
(descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n   \
 if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set \
read only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\nvar PLUGIN_KEY6 = \"collapsibleColumns\";\nvar PLUGIN_PRIORITY5 = \
290;\nvar SETTING_KEYS2 = [\"nestedHeaders\"];\nvar COLLAPSIBLE_ELEMENT_CLASS \
= \"collapsibleIndicator\";\nvar actionDictionary = /* @__PURE__ */ new \
Map([[\"collapse\", {\n  hideColumn: true,\n  beforeHook: \
\"beforeColumnCollapse\",\n  afterHook: \"afterColumnCollapse\"\n}], \
[\"expand\", {\n  hideColumn: false,\n  beforeHook: \"beforeColumnExpand\",\n \
 afterHook: \"afterColumnExpand\"\n}]]);\nvar _collapsedColumnsMap = /* \
@__PURE__ */ new WeakMap();\nvar CollapsibleColumns = class extends \
BasePlugin {\n  constructor() {\n    super(...arguments);\n    \
_defineProperty17(this, \"nestedHeadersPlugin\", null);\n    \
_defineProperty17(this, \"eventManager\", new eventManager_default(this));\n  \
  _defineProperty17(this, \"headerStateManager\", null);\n    \
_classPrivateFieldInitSpec6(this, _collapsedColumnsMap, {\n      writable: \
true,\n      value: null\n    });\n  }\n  static get PLUGIN_KEY() {\n    \
return PLUGIN_KEY6;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY5;\n  }\n  static get PLUGIN_DEPS() {\n    return \
[\"plugin:NestedHeaders\"];\n  }\n  static get SETTING_KEYS() {\n    return \
[PLUGIN_KEY6, ...SETTING_KEYS2];\n  }\n  /**\n   * Checks if the plugin is \
enabled in the handsontable settings. This method is executed in {@link \
Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link \
CollapsibleColumns#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY6];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const \
{\n      nestedHeaders\n    } = this.hot.getSettings();\n    if \
(!nestedHeaders) {\n      warn(\"You need to configure the Nested Headers \
plugin in order to use collapsible headers.\");\n    }\n    \
_classPrivateFieldSet6(this, _collapsedColumnsMap, \
this.hot.columnIndexMapper.createAndRegisterIndexMap(this.pluginName, \
\"hiding\"));\n    this.nestedHeadersPlugin = \
this.hot.getPlugin(\"nestedHeaders\");\n    this.headerStateManager = \
this.nestedHeadersPlugin.getStateManager();\n    this.addHook(\"init\", () => \
this.onInit());\n    this.addHook(\"afterLoadData\", function() {\n      \
return _this.onAfterLoadData(...arguments);\n    });\n    \
this.addHook(\"afterGetColHeader\", function() {\n      return \
_this.onAfterGetColHeader(...arguments);\n    });\n    \
this.addHook(\"beforeOnCellMouseDown\", (event2, coords, TD) => \
this.onBeforeOnCellMouseDown(event2, coords, TD));\n    \
super.enablePlugin();\n    this.updatePlugin();\n  }\n  /**\n   * Updates the \
plugin's state.\n   *\n   * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *   - \
[`collapsibleColumns`](@/api/options.md#collapsiblecolumns)\n   *   - \
[`nestedHeaders`](@/api/options.md#nestedheaders)\n   */\n  updatePlugin() \
{\n    if (!this.hot.view) {\n      return;\n    }\n    if \
(!this.nestedHeadersPlugin.detectedOverlappedHeaders) {\n      const {\n      \
  collapsibleColumns\n      } = this.hot.getSettings();\n      if (typeof \
collapsibleColumns === \"boolean\") {\n        \
this.headerStateManager.mapState((headerSettings) => {\n          return {\n  \
          collapsible: headerSettings.origColspan > 1\n          };\n        \
});\n      } else if (Array.isArray(collapsibleColumns)) {\n        \
this.headerStateManager.mapState(() => {\n          return {\n            \
collapsible: false\n          };\n        });\n        \
this.headerStateManager.mergeStateWith(collapsibleColumns);\n      }\n    }\n \
   super.updatePlugin();\n  }\n  /**\n   * Disables the plugin functionality \
for this Handsontable instance.\n   */\n  disablePlugin() {\n    \
this.hot.columnIndexMapper.unregisterMap(this.pluginName);\n    \
_classPrivateFieldSet6(this, _collapsedColumnsMap, null);\n    \
this.nestedHeadersPlugin = null;\n    this.clearButtons();\n    \
super.disablePlugin();\n  }\n  /**\n   * Clears the expand/collapse \
buttons.\n   *\n   * @private\n   */\n  clearButtons() {\n    if \
(!this.hot.view) {\n      return;\n    }\n    const headerLevels = \
this.hot.view._wt.getSetting(\"columnHeaders\").length;\n    const \
mainHeaders = this.hot.view._wt.wtTable.THEAD;\n    const topHeaders = \
this.hot.view._wt.wtOverlays.topOverlay.clone.wtTable.THEAD;\n    const \
topLeftCornerHeaders = \
this.hot.view._wt.wtOverlays.topInlineStartCornerOverlay ? \
this.hot.view._wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD \
: null;\n    const removeButton = function(button) {\n      if (button) {\n   \
     button.parentNode.removeChild(button);\n      }\n    };\n    \
rangeEach(0, headerLevels - 1, (i) => {\n      const masterLevel = \
mainHeaders.childNodes[i];\n      const topLevel = \
topHeaders.childNodes[i];\n      const topLeftCornerLevel = \
topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;\n      \
rangeEach(0, masterLevel.childNodes.length - 1, (j) => {\n        let button \
= masterLevel.childNodes[j].querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);\n \
       removeButton(button);\n        if (topLevel && topLevel.childNodes[j]) \
{\n          button = \
topLevel.childNodes[j].querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);\n      \
    removeButton(button);\n        }\n        if (topLeftCornerHeaders && \
topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {\n          button = \
topLeftCornerLevel.childNodes[j].querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}\
`);\n          removeButton(button);\n        }\n      });\n    }, true);\n  \
}\n  /**\n   * Expands section at the provided coords.\n   *\n   * @param \
{object} coords Contains coordinates information. (`coords.row`, \
`coords.col`).\n   */\n  expandSection(coords) {\n    \
this.toggleCollapsibleSection([coords], \"expand\");\n  }\n  /**\n   * \
Collapses section at the provided coords.\n   *\n   * @param {object} coords \
Contains coordinates information. (`coords.row`, `coords.col`).\n   */\n  \
collapseSection(coords) {\n    this.toggleCollapsibleSection([coords], \
\"collapse\");\n  }\n  /**\n   * Collapses or expand all collapsible \
sections, depending on the action parameter.\n   *\n   * @param {string} \
action 'collapse' or 'expand'.\n   */\n  toggleAllCollapsibleSections(action) \
{\n    const coords = this.headerStateManager.mapNodes((headerSettings) => \
{\n      const {\n        collapsible,\n        origColspan,\n        \
headerLevel,\n        columnIndex,\n        isCollapsed\n      } = \
headerSettings;\n      if (collapsible === true && origColspan > 1 && \
(isCollapsed && action === \"expand\" || !isCollapsed && action === \
\"collapse\")) {\n        return {\n          row: \
this.headerStateManager.levelToRowCoords(headerLevel),\n          col: \
columnIndex\n        };\n      }\n    });\n    \
this.toggleCollapsibleSection(coords, action);\n  }\n  /**\n   * Collapses \
all collapsible sections.\n   */\n  collapseAll() {\n    \
this.toggleAllCollapsibleSections(\"collapse\");\n  }\n  /**\n   * Expands \
all collapsible sections.\n   */\n  expandAll() {\n    \
this.toggleAllCollapsibleSections(\"expand\");\n  }\n  /**\n   * \
Collapses/Expands a section.\n   *\n   * @param {Array} coords Array of \
coords - section coordinates.\n   * @param {string} [action] Action \
definition ('collapse' or 'expand').\n   * @fires \
Hooks#beforeColumnCollapse\n   * @fires Hooks#beforeColumnExpand\n   * @fires \
Hooks#afterColumnCollapse\n   * @fires Hooks#afterColumnExpand\n   */\n  \
toggleCollapsibleSection(coords, action) {\n    if \
(!actionDictionary.has(action)) {\n      throw new Error(`Unsupported action \
is passed (${action}).`);\n    }\n    if (!Array.isArray(coords)) {\n      \
return;\n    }\n    const filteredCoords = arrayFilter(coords, (_ref) => {\n  \
    let {\n        row\n      } = _ref;\n      return row < 0;\n    });\n    \
let isActionPossible = filteredCoords.length > 0;\n    \
arrayEach(filteredCoords, (_ref2) => {\n      var _this$headerStateMana;\n    \
  let {\n        row,\n        col: column\n      } = _ref2;\n      const {\n \
       collapsible,\n        isCollapsed\n      } = (_this$headerStateMana = \
this.headerStateManager.getHeaderSettings(row, column)) !== null && \
_this$headerStateMana !== void 0 ? _this$headerStateMana : {};\n      if \
(!collapsible || isCollapsed && action === \"collapse\" || !isCollapsed && \
action === \"expand\") {\n        isActionPossible = false;\n        return \
false;\n      }\n    });\n    const nodeModRollbacks = [];\n    const \
affectedColumnsIndexes = [];\n    if (isActionPossible) {\n      \
arrayEach(filteredCoords, (_ref3) => {\n        let {\n          row,\n       \
   col: column\n        } = _ref3;\n        const {\n          \
colspanCompensation,\n          affectedColumns,\n          \
rollbackModification\n        } = \
this.headerStateManager.triggerNodeModification(action, row, column);\n       \
 if (colspanCompensation > 0) {\n          \
affectedColumnsIndexes.push(...affectedColumns);\n          \
nodeModRollbacks.push(rollbackModification);\n        }\n      });\n    }\n   \
 const currentCollapsedColumns = this.getCollapsedColumns();\n    let \
destinationCollapsedColumns = [];\n    if (action === \"collapse\") {\n      \
destinationCollapsedColumns = arrayUnique([...currentCollapsedColumns, \
...affectedColumnsIndexes]);\n    } else if (action === \"expand\") {\n      \
destinationCollapsedColumns = arrayFilter(currentCollapsedColumns, (index2) \
=> !affectedColumnsIndexes.includes(index2));\n    }\n    const \
actionTranslator = actionDictionary.get(action);\n    const isActionAllowed = \
this.hot.runHooks(actionTranslator.beforeHook, currentCollapsedColumns, \
destinationCollapsedColumns, isActionPossible);\n    if (isActionAllowed === \
false) {\n      arrayEach(nodeModRollbacks, (nodeModRollback) => {\n        \
nodeModRollback();\n      });\n      return;\n    }\n    \
this.hot.batchExecution(() => {\n      arrayEach(affectedColumnsIndexes, \
(visualColumn) => {\n        _classPrivateFieldGet6(this, \
_collapsedColumnsMap).setValueAtIndex(this.hot.toPhysicalColumn(visualColumn)\
, actionTranslator.hideColumn);\n      });\n    }, true);\n    const \
isActionPerformed = this.getCollapsedColumns().length !== \
currentCollapsedColumns.length;\n    \
this.hot.runHooks(actionTranslator.afterHook, currentCollapsedColumns, \
destinationCollapsedColumns, isActionPossible, isActionPerformed);\n    \
this.hot.render();\n    this.hot.view.adjustElementsSize(true);\n  }\n  /**\n \
  * Gets an array of physical indexes of collapsed columns.\n   *\n   * \
@private\n   * @returns {number[]}\n   */\n  getCollapsedColumns() {\n    \
return _classPrivateFieldGet6(this, \
_collapsedColumnsMap).getHiddenIndexes();\n  }\n  /**\n   * Adds the \
indicator to the headers.\n   *\n   * @private\n   * @param {number} column \
Column index.\n   * @param {HTMLElement} TH TH element.\n   * @param {number} \
headerLevel The index of header level counting from the top (positive\n   *   \
                          values counting from 0 to N).\n   */\n  \
onAfterGetColHeader(column, TH, headerLevel) {\n    var \
_this$headerStateMana2;\n    const {\n      collapsible,\n      \
origColspan,\n      isCollapsed\n    } = (_this$headerStateMana2 = \
this.headerStateManager.getHeaderSettings(headerLevel, column)) !== null && \
_this$headerStateMana2 !== void 0 ? _this$headerStateMana2 : {};\n    const \
isNodeCollapsible = collapsible && origColspan > 1 && column >= \
this.hot.getSettings().fixedColumnsStart;\n    let collapsibleElement = \
TH.querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);\n    if \
(isNodeCollapsible) {\n      if (!collapsibleElement) {\n        \
collapsibleElement = this.hot.rootDocument.createElement(\"div\");\n        \
addClass(collapsibleElement, COLLAPSIBLE_ELEMENT_CLASS);\n        \
TH.querySelector(\"div:first-child\").appendChild(collapsibleElement);\n      \
}\n      removeClass(collapsibleElement, [\"collapsed\", \"expanded\"]);\n    \
  if (isCollapsed) {\n        addClass(collapsibleElement, \"collapsed\");\n  \
      fastInnerText(collapsibleElement, \"+\");\n      } else {\n        \
addClass(collapsibleElement, \"expanded\");\n        \
fastInnerText(collapsibleElement, \"-\");\n      }\n    } else {\n      var \
_collapsibleElement;\n      (_collapsibleElement = collapsibleElement) === \
null || _collapsibleElement === void 0 || _collapsibleElement.remove();\n    \
}\n  }\n  /**\n   * Indicator mouse event callback.\n   *\n   * @private\n   \
* @param {object} event Mouse event.\n   * @param {object} coords Event \
coordinates.\n   */\n  onBeforeOnCellMouseDown(event2, coords) {\n    if \
(hasClass(event2.target, COLLAPSIBLE_ELEMENT_CLASS)) {\n      if \
(hasClass(event2.target, \"expanded\")) {\n        \
this.eventManager.fireEvent(event2.target, \"mouseup\");\n        \
this.toggleCollapsibleSection([coords], \"collapse\");\n      } else if \
(hasClass(event2.target, \"collapsed\")) {\n        \
this.eventManager.fireEvent(event2.target, \"mouseup\");\n        \
this.toggleCollapsibleSection([coords], \"expand\");\n      }\n      \
stopImmediatePropagation(event2);\n    }\n  }\n  /**\n   * Updates the plugin \
state after HoT initialization.\n   *\n   * @private\n   */\n  onInit() {\n   \
 this.updatePlugin();\n  }\n  /**\n   * Updates the plugin state after new \
dataset load.\n   *\n   * @private\n   * @param {Array[]} sourceData Array of \
arrays or array of objects containing data.\n   * @param {boolean} \
initialLoad Flag that determines whether the data has been loaded\n   *       \
                       during the initialization.\n   */\n  \
onAfterLoadData(sourceData, initialLoad) {\n    if (!initialLoad) {\n      \
this.updatePlugin();\n    }\n  }\n  /**\n   * Destroys the plugin instance.\n \
  */\n  destroy() {\n    _classPrivateFieldSet6(this, _collapsedColumnsMap, \
null);\n    super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/columnSorting/columnStatesManager.mjs\nvar \
inheritedColumnProperties = [\"sortEmptyCells\", \"indicator\", \
\"headerAction\", \"compareFunctionFactory\"];\nvar SORT_EMPTY_CELLS_DEFAULT \
= false;\nvar SHOW_SORT_INDICATOR_DEFAULT = true;\nvar HEADER_ACTION_DEFAULT \
= true;\nvar ColumnStatesManager = class {\n  constructor(hot2, mapName) {\n  \
  this.hot = hot2;\n    this.sortingStates = new \
LinkedPhysicalIndexToValueMap();\n    this.sortEmptyCells = \
SORT_EMPTY_CELLS_DEFAULT;\n    this.indicator = \
SHOW_SORT_INDICATOR_DEFAULT;\n    this.headerAction = \
HEADER_ACTION_DEFAULT;\n    this.compareFunctionFactory = void 0;\n    \
this.mapName = mapName;\n    this.hot.columnIndexMapper.registerMap(mapName, \
this.sortingStates);\n  }\n  /**\n   * Update column properties which affect \
the sorting result.\n   *\n   * **Note**: All column properties can be \
overwritten by {@link Options#columns} option.\n   *\n   * @param {object} \
allSortSettings Column sorting plugin's configuration object.\n   */\n  \
updateAllColumnsProperties(allSortSettings) {\n    if \
(!isObject(allSortSettings)) {\n      return;\n    }\n    \
objectEach(allSortSettings, (newValue, propertyName) => {\n      if \
(inheritedColumnProperties.includes(propertyName)) {\n        \
this[propertyName] = newValue;\n      }\n    });\n  }\n  /**\n   * Get all \
column properties which affect the sorting result.\n   *\n   * @returns \
{object}\n   */\n  getAllColumnsProperties() {\n    const columnProperties = \
{\n      sortEmptyCells: this.sortEmptyCells,\n      indicator: \
this.indicator,\n      headerAction: this.headerAction\n    };\n    if \
(typeof this.compareFunctionFactory === \"function\") {\n      \
columnProperties.compareFunctionFactory = this.compareFunctionFactory;\n    \
}\n    return columnProperties;\n  }\n  /**\n   * Get sort order of column.\n \
  *\n   * @param {number} searchedColumn Visual column index.\n   * @returns \
{string|undefined} Sort order (`asc` for ascending, `desc` for descending and \
undefined for not sorted).\n   */\n  getSortOrderOfColumn(searchedColumn) {\n \
   var _this$sortingStates$g;\n    return (_this$sortingStates$g = \
this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(searchedColumn))\
) === null || _this$sortingStates$g === void 0 ? void 0 : \
_this$sortingStates$g.sortOrder;\n  }\n  /**\n   * Get order of particular \
column in the states queue.\n   *\n   * @param {number} column Visual column \
index.\n   * @returns {number}\n   */\n  getIndexOfColumnInSortQueue(column) \
{\n    column = this.hot.toPhysicalColumn(column);\n    return \
this.sortingStates.getEntries().findIndex((_ref) => {\n      let \
[physicalColumn] = _ref;\n      return physicalColumn === column;\n    });\n  \
}\n  /**\n   * Get number of sorted columns.\n   *\n   * @returns {number}\n  \
 */\n  getNumberOfSortedColumns() {\n    return \
this.sortingStates.getLength();\n  }\n  /**\n   * Get if list of sorted \
columns is empty.\n   *\n   * @returns {boolean}\n   */\n  \
isListOfSortedColumnsEmpty() {\n    return this.getNumberOfSortedColumns() \
=== 0;\n  }\n  /**\n   * Get if particular column is sorted.\n   *\n   * \
@param {number} column Visual column index.\n   * @returns {boolean}\n   */\n \
 isColumnSorted(column) {\n    return \
isObject(this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(column)\
));\n  }\n  /**\n   * Queue of sort states containing sorted columns and \
their orders (Array of objects containing `column` and `sortOrder` \
properties).\n   *\n   * **Note**: Please keep in mind that returned objects \
expose **visual** column index under the `column` key.\n   *\n   * @returns \
{Array<object>}\n   */\n  getSortStates() {\n    if (this.sortingStates === \
null) {\n      return [];\n    }\n    const sortingStatesQueue = \
this.sortingStates.getEntries();\n    return sortingStatesQueue.map((_ref2) \
=> {\n      let [physicalColumn, value] = _ref2;\n      return {\n        \
column: this.hot.toVisualColumn(physicalColumn),\n        ...value\n      \
};\n    });\n  }\n  /**\n   * Get sort state for particular column. Object \
contains `column` and `sortOrder` properties.\n   *\n   * **Note**: Please \
keep in mind that returned objects expose **visual** column index under the \
`column` key.\n   *\n   * @param {number} column Visual column index.\n   * \
@returns {object|undefined}\n   */\n  getColumnSortState(column) {\n    const \
sortOrder = this.getSortOrderOfColumn(column);\n    if (isDefined(sortOrder)) \
{\n      return {\n        column,\n        sortOrder\n      };\n    }\n  }\n \
 /**\n   * Set all column states.\n   *\n   * @param {Array} sortStates Sort \
states.\n   */\n  setSortStates(sortStates) {\n    \
this.sortingStates.clear();\n    for (let i = 0; i < sortStates.length; i += \
1) {\n      \
this.sortingStates.setValueAtIndex(this.hot.toPhysicalColumn(sortStates[i].co\
lumn), {\n        sortOrder: sortStates[i].sortOrder\n      });\n    }\n  }\n \
 /**\n   * Destroy the state manager.\n   */\n  destroy() {\n    \
this.hot.columnIndexMapper.unregisterMap(this.mapName);\n    \
this.sortingStates = null;\n  }\n};\n\n// \
node_modules/handsontable/plugins/columnSorting/utils.mjs\nvar ASC_SORT_STATE \
= \"asc\";\nvar DESC_SORT_STATE = \"desc\";\nvar HEADER_SPAN_CLASS = \
\"colHeader\";\nfunction isValidColumnState(columnState) {\n  if \
(isObject(columnState) === false) {\n    return false;\n  }\n  const {\n    \
column,\n    sortOrder\n  } = columnState;\n  return Number.isInteger(column) \
&& [ASC_SORT_STATE, DESC_SORT_STATE].includes(sortOrder);\n}\nfunction \
areValidSortStates(sortStates) {\n  if (sortStates.some((columnState) => \
isValidColumnState(columnState) === false)) {\n    return false;\n  }\n  \
const sortedColumns = sortStates.map((_ref) => {\n    let {\n      column\n   \
 } = _ref;\n    return column;\n  });\n  return new Set(sortedColumns).size \
=== sortedColumns.length;\n}\nfunction getNextSortOrder(sortOrder) {\n  if \
(sortOrder === DESC_SORT_STATE) {\n    return;\n  } else if (sortOrder === \
ASC_SORT_STATE) {\n    return DESC_SORT_STATE;\n  }\n  return \
ASC_SORT_STATE;\n}\nfunction getHeaderSpanElement(TH) {\n  const \
headerSpanElement = TH.querySelector(`.${HEADER_SPAN_CLASS}`);\n  return \
headerSpanElement;\n}\nfunction isFirstLevelColumnHeader(column, TH) {\n  if \
(column < 0 || !TH.parentNode) {\n    return false;\n  }\n  const TRs = \
TH.parentNode.parentNode.childNodes;\n  const headerLevel = \
Array.from(TRs).indexOf(TH.parentNode) - TRs.length;\n  if (headerLevel !== \
-1) {\n    return false;\n  }\n  return true;\n}\nfunction \
wasHeaderClickedProperly(row, column, clickEvent) {\n  return row === -1 && \
column >= 0 && isRightClick(clickEvent) === false;\n}\n\n// \
node_modules/handsontable/plugins/columnSorting/domHelpers.mjs\nvar \
HEADER_CLASS_ASC_SORT = \"ascending\";\nvar HEADER_CLASS_DESC_SORT = \
\"descending\";\nvar HEADER_CLASS_INDICATOR_DISABLED = \
\"indicatorDisabled\";\nvar HEADER_SORT_CLASS = \"columnSorting\";\nvar \
HEADER_ACTION_CLASS = \"sortAction\";\nvar orderToCssClass = /* @__PURE__ */ \
new Map([[ASC_SORT_STATE, HEADER_CLASS_ASC_SORT], [DESC_SORT_STATE, \
HEADER_CLASS_DESC_SORT]]);\nfunction getClassesToAdd(columnStatesManager, \
column, showSortIndicator, headerAction) {\n  const cssClasses = \
[HEADER_SORT_CLASS];\n  if (headerAction) {\n    \
cssClasses.push(HEADER_ACTION_CLASS);\n  }\n  if (showSortIndicator === \
false) {\n    cssClasses.push(HEADER_CLASS_INDICATOR_DISABLED);\n    return \
cssClasses;\n  }\n  const columnOrder = \
columnStatesManager.getSortOrderOfColumn(column);\n  if \
(isDefined(columnOrder)) {\n    \
cssClasses.push(orderToCssClass.get(columnOrder));\n  }\n  return \
cssClasses;\n}\nfunction getClassesToRemove() {\n  return \
Array.from(orderToCssClass.values()).concat(HEADER_ACTION_CLASS, \
HEADER_CLASS_INDICATOR_DISABLED, HEADER_SORT_CLASS);\n}\n\n// \
node_modules/handsontable/plugins/columnSorting/sortFunction/default.mjs\nfun\
ction compareFunctionFactory(sortOrder, columnMeta, columnPluginSettings) {\n \
 const locale = columnMeta.locale;\n  return function(value, nextValue) {\n   \
 const {\n      sortEmptyCells\n    } = columnPluginSettings;\n    if (typeof \
value === \"string\") {\n      value = value.toLocaleLowerCase(locale);\n    \
}\n    if (typeof nextValue === \"string\") {\n      nextValue = \
nextValue.toLocaleLowerCase(locale);\n    }\n    if (value === nextValue) {\n \
     return DO_NOT_SWAP;\n    }\n    if (isEmpty(value)) {\n      if \
(isEmpty(nextValue)) {\n        return DO_NOT_SWAP;\n      }\n      if \
(sortEmptyCells) {\n        return sortOrder === \"asc\" ? \
FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n      }\n      return \
FIRST_AFTER_SECOND;\n    }\n    if (isEmpty(nextValue)) {\n      if \
(sortEmptyCells) {\n        return sortOrder === \"asc\" ? FIRST_AFTER_SECOND \
: FIRST_BEFORE_SECOND;\n      }\n      return FIRST_BEFORE_SECOND;\n    }\n   \
 if (isNaN(value) && !isNaN(nextValue)) {\n      return sortOrder === \"asc\" \
? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n    } else if (!isNaN(value) && \
isNaN(nextValue)) {\n      return sortOrder === \"asc\" ? FIRST_BEFORE_SECOND \
: FIRST_AFTER_SECOND;\n    } else if (!(isNaN(value) || isNaN(nextValue))) \
{\n      value = parseFloat(value);\n      nextValue = \
parseFloat(nextValue);\n    }\n    if (value < nextValue) {\n      return \
sortOrder === \"asc\" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n    }\n    \
if (value > nextValue) {\n      return sortOrder === \"asc\" ? \
FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n    }\n    return DO_NOT_SWAP;\n  \
};\n}\nvar COLUMN_DATA_TYPE = \"default\";\n\n// \
node_modules/handsontable/plugins/columnSorting/sortFunction/numeric.mjs\nfun\
ction compareFunctionFactory2(sortOrder, columnMeta, columnPluginSettings) \
{\n  return function(value, nextValue) {\n    const parsedFirstValue = \
parseFloat(value);\n    const parsedSecondValue = parseFloat(nextValue);\n    \
const {\n      sortEmptyCells\n    } = columnPluginSettings;\n    if \
(parsedFirstValue === parsedSecondValue || isNaN(parsedFirstValue) && \
isNaN(parsedSecondValue)) {\n      return DO_NOT_SWAP;\n    }\n    if \
(sortEmptyCells) {\n      if (isEmpty(value)) {\n        return sortOrder === \
\"asc\" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n      }\n      if \
(isEmpty(nextValue)) {\n        return sortOrder === \"asc\" ? \
FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n      }\n    }\n    if \
(isNaN(parsedFirstValue)) {\n      return FIRST_AFTER_SECOND;\n    }\n    if \
(isNaN(parsedSecondValue)) {\n      return FIRST_BEFORE_SECOND;\n    }\n    \
if (parsedFirstValue < parsedSecondValue) {\n      return sortOrder === \
\"asc\" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n    } else if \
(parsedFirstValue > parsedSecondValue) {\n      return sortOrder === \"asc\" \
? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n    }\n    return DO_NOT_SWAP;\n \
 };\n}\nvar COLUMN_DATA_TYPE2 = \"numeric\";\n\n// \
node_modules/handsontable/plugins/columnSorting/sortFunction/checkbox.mjs\nfu\
nction compareFunctionFactory3(sortOrder, columnMeta, columnPluginSettings) \
{\n  const checkedTemplate = columnMeta.checkedTemplate;\n  const \
uncheckedTemplate = columnMeta.uncheckedTemplate;\n  const {\n    \
sortEmptyCells\n  } = columnPluginSettings;\n  return function(value, \
nextValue) {\n    const isEmptyValue = isEmpty(value);\n    const \
isEmptyNextValue = isEmpty(nextValue);\n    const unifiedValue = isEmptyValue \
? uncheckedTemplate : value;\n    const unifiedNextValue = isEmptyNextValue ? \
uncheckedTemplate : nextValue;\n    const isValueFromTemplate = unifiedValue \
=== uncheckedTemplate || unifiedValue === checkedTemplate;\n    const \
isNextValueFromTemplate = unifiedNextValue === uncheckedTemplate || \
unifiedNextValue === checkedTemplate;\n    if (sortEmptyCells === false) {\n  \
    if (isEmptyValue && isEmptyNextValue === false) {\n        return \
FIRST_AFTER_SECOND;\n      }\n      if (isEmptyValue === false && \
isEmptyNextValue) {\n        return FIRST_BEFORE_SECOND;\n      }\n    }\n    \
if (isValueFromTemplate === false && isNextValueFromTemplate) {\n      return \
sortOrder === \"asc\" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n    }\n    \
if (isValueFromTemplate && isNextValueFromTemplate === false) {\n      return \
sortOrder === \"asc\" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n    }\n    \
if (isValueFromTemplate === false && isNextValueFromTemplate === false) {\n   \
   return compareFunctionFactory(sortOrder, columnMeta, \
columnPluginSettings)(value, nextValue);\n    }\n    if (unifiedValue === \
uncheckedTemplate && unifiedNextValue === checkedTemplate) {\n      return \
sortOrder === \"asc\" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n    }\n    \
if (unifiedValue === checkedTemplate && unifiedNextValue === \
uncheckedTemplate) {\n      return sortOrder === \"asc\" ? FIRST_AFTER_SECOND \
: FIRST_BEFORE_SECOND;\n    }\n    return DO_NOT_SWAP;\n  };\n}\nvar \
COLUMN_DATA_TYPE3 = \"checkbox\";\n\n// \
node_modules/handsontable/plugins/columnSorting/sortFunction/date.mjs\nvar \
import_moment5 = __toESM(require_moment(), 1);\nfunction \
compareFunctionFactory4(sortOrder, columnMeta, columnPluginSettings) {\n  \
return function(value, nextValue) {\n    const {\n      sortEmptyCells\n    } \
= columnPluginSettings;\n    if (value === nextValue) {\n      return \
DO_NOT_SWAP;\n    }\n    if (isEmpty(value)) {\n      if (isEmpty(nextValue)) \
{\n        return DO_NOT_SWAP;\n      }\n      if (sortEmptyCells) {\n        \
return sortOrder === \"asc\" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n    \
  }\n      return FIRST_AFTER_SECOND;\n    }\n    if (isEmpty(nextValue)) {\n \
     if (sortEmptyCells) {\n        return sortOrder === \"asc\" ? \
FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n      }\n      return \
FIRST_BEFORE_SECOND;\n    }\n    const dateFormat = columnMeta.dateFormat;\n  \
  const firstDate = (0, import_moment5.default)(value, dateFormat);\n    \
const nextDate = (0, import_moment5.default)(nextValue, dateFormat);\n    if \
(!firstDate.isValid()) {\n      return FIRST_AFTER_SECOND;\n    }\n    if \
(!nextDate.isValid()) {\n      return FIRST_BEFORE_SECOND;\n    }\n    if \
(nextDate.isAfter(firstDate)) {\n      return sortOrder === \"asc\" ? \
FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;\n    }\n    if \
(nextDate.isBefore(firstDate)) {\n      return sortOrder === \"asc\" ? \
FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;\n    }\n    return DO_NOT_SWAP;\n  \
};\n}\nvar COLUMN_DATA_TYPE4 = \"date\";\n\n// \
node_modules/handsontable/plugins/columnSorting/sortService/registry.mjs\nvar \
{\n  register: registerCompareFunctionFactory,\n  getItem: \
getGloballyCompareFunctionFactory,\n  hasItem: \
hasGloballyCompareFunctionFactory\n} = \
staticRegister(\"sorting.compareFunctionFactory\");\nvar {\n  register: \
registerRootComparator,\n  getItem: getRootComparator\n} = \
staticRegister(\"sorting.mainSortComparator\");\nfunction \
getCompareFunctionFactory(type) {\n  if \
(hasGloballyCompareFunctionFactory(type)) {\n    return \
getGloballyCompareFunctionFactory(type);\n  }\n  return \
getGloballyCompareFunctionFactory(COLUMN_DATA_TYPE);\n}\nregisterCompareFunct\
ionFactory(COLUMN_DATA_TYPE2, \
compareFunctionFactory2);\nregisterCompareFunctionFactory(COLUMN_DATA_TYPE3, \
compareFunctionFactory3);\nregisterCompareFunctionFactory(COLUMN_DATA_TYPE4, \
compareFunctionFactory4);\nregisterCompareFunctionFactory(COLUMN_DATA_TYPE, \
compareFunctionFactory);\n\n// \
node_modules/handsontable/plugins/columnSorting/sortService/engine.mjs\nvar \
DO_NOT_SWAP = 0;\nvar FIRST_BEFORE_SECOND = -1;\nvar FIRST_AFTER_SECOND = \
1;\nfunction sort(indexesWithData, rootComparatorId) {\n  const \
rootComparator3 = getRootComparator(rootComparatorId);\n  for (var _len = \
arguments.length, argsForRootComparator = new Array(_len > 2 ? _len - 2 : 0), \
_key = 2; _key < _len; _key++) {\n    argsForRootComparator[_key - 2] = \
arguments[_key];\n  }\n  \
indexesWithData.sort(rootComparator3(...argsForRootComparator));\n}\n\n// \
node_modules/handsontable/plugins/columnSorting/rootComparator.mjs\nfunction \
rootComparator(sortingOrders, columnMetas) {\n  return \
function(rowIndexWithValues, nextRowIndexWithValues) {\n    const [, \
...values] = rowIndexWithValues;\n    const [, ...nextValues] = \
nextRowIndexWithValues;\n    return function getCompareResult(column) {\n     \
 const sortingOrder = sortingOrders[column];\n      const columnMeta = \
columnMetas[column];\n      const value = values[column];\n      const \
nextValue = nextValues[column];\n      const pluginSettings = \
columnMeta.columnSorting;\n      const compareFunctionFactory5 = \
pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory \
: getCompareFunctionFactory(columnMeta.type);\n      const compareResult = \
compareFunctionFactory5(sortingOrder, columnMeta, pluginSettings)(value, \
nextValue);\n      return compareResult;\n    }(0);\n  };\n}\n\n// \
node_modules/handsontable/plugins/columnSorting/columnSorting.mjs\nvar \
PLUGIN_KEY7 = \"columnSorting\";\nvar PLUGIN_PRIORITY6 = 50;\nvar \
APPEND_COLUMN_CONFIG_STRATEGY = \"append\";\nvar \
REPLACE_COLUMN_CONFIG_STRATEGY = \
\"replace\";\nregisterRootComparator(PLUGIN_KEY7, \
rootComparator);\npluginHooks_default.getSingleton().register(\"beforeColumnS\
ort\");\npluginHooks_default.getSingleton().register(\"afterColumnSort\");\nv\
ar ColumnSorting = class extends BasePlugin {\n  static get PLUGIN_KEY() {\n  \
  return PLUGIN_KEY7;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY6;\n  }\n  constructor(hotInstance) {\n    \
super(hotInstance);\n    this.columnStatesManager = null;\n    \
this.columnMetaCache = null;\n    this.pluginKey = PLUGIN_KEY7;\n    \
this.indexesSequenceCache = null;\n  }\n  /**\n   * Checks if the plugin is \
enabled in the Handsontable settings. This method is executed in {@link \
Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link \
ColumnSorting#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[this.pluginKey];\n  }\n  /**\n   * Enables the \
plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() \
{\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    \
this.columnStatesManager = new ColumnStatesManager(this.hot, \
`${this.pluginKey}.sortingStates`);\n    this.columnMetaCache = new \
PhysicalIndexToValueMap((physicalIndex) => {\n      let visualIndex = \
this.hot.toVisualColumn(physicalIndex);\n      if (visualIndex === null) {\n  \
      visualIndex = physicalIndex;\n      }\n      return \
this.getMergedPluginSettings(visualIndex);\n    });\n    \
this.hot.columnIndexMapper.registerMap(`${this.pluginKey}.columnMeta`, \
this.columnMetaCache);\n    this.addHook(\"afterGetColHeader\", (column, TH) \
=> this.onAfterGetColHeader(column, TH));\n    \
this.addHook(\"beforeOnCellMouseDown\", function() {\n      return \
_this.onBeforeOnCellMouseDown(...arguments);\n    });\n    \
this.addHook(\"afterOnCellMouseDown\", (event2, target) => \
this.onAfterOnCellMouseDown(event2, target));\n    \
this.addHook(\"afterInit\", () => this.loadOrSortBySettings());\n    \
this.addHook(\"afterLoadData\", function() {\n      return \
_this.onAfterLoadData(...arguments);\n    });\n    if (this.hot.view) {\n     \
 this.loadOrSortBySettings();\n    }\n    super.enablePlugin();\n  }\n  /**\n \
  * Disables the plugin functionality for this Handsontable instance.\n   \
*/\n  disablePlugin() {\n    const clearColHeader = (column, TH) => {\n      \
const headerSpanElement = getHeaderSpanElement(TH);\n      if \
(isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === \
null) {\n        return;\n      }\n      \
this.updateHeaderClasses(headerSpanElement);\n    };\n    \
this.hot.addHook(\"afterGetColHeader\", clearColHeader);\n    \
this.hot.addHookOnce(\"afterViewRender\", () => {\n      \
this.hot.removeHook(\"afterGetColHeader\", clearColHeader);\n    });\n    \
this.hot.batchExecution(() => {\n      if (this.indexesSequenceCache !== \
null) {\n        \
this.hot.rowIndexMapper.setIndexesSequence(this.indexesSequenceCache.getValue\
s());\n        this.hot.rowIndexMapper.unregisterMap(this.pluginKey);\n      \
}\n    }, true);\n    \
this.hot.columnIndexMapper.unregisterMap(`${this.pluginKey}.columnMeta`);\n   \
 this.columnStatesManager.destroy();\n    this.columnMetaCache = null;\n    \
this.columnStatesManager = null;\n    super.disablePlugin();\n  }\n  // DIFF \
- MultiColumnSorting & ColumnSorting: changed function documentation.\n  \
/**\n   * Sorts the table by chosen columns and orders.\n   *\n   * @param \
{undefined|object} sortConfig Single column sort configuration. The \
configuration object contains `column` and `sortOrder` properties.\n   * \
First of them contains visual column index, the second one contains sort \
order (`asc` for ascending, `desc` for descending).\n   *\n   * **Note**: \
Please keep in mind that every call of `sort` function set an entirely new \
sort order. Previous sort configs aren't preserved.\n   *\n   * @example\n   \
* ```js\n   * // sort ascending first visual column\n   * \
hot.getPlugin('columnSorting').sort({ column: 0, sortOrder: 'asc' });\n   * \
```\n   *\n   * @fires Hooks#beforeColumnSort\n   * @fires \
Hooks#afterColumnSort\n   */\n  sort(sortConfig) {\n    const \
currentSortConfig = this.getSortConfig();\n    const destinationSortConfigs = \
this.getNormalizedSortConfigs(sortConfig);\n    const sortPossible = \
this.areValidSortConfigs(destinationSortConfigs);\n    const allowSort = \
this.hot.runHooks(\"beforeColumnSort\", currentSortConfig, \
destinationSortConfigs, sortPossible);\n    if (allowSort === false) {\n      \
return;\n    }\n    if (currentSortConfig.length === 0 && \
this.indexesSequenceCache === null) {\n      this.indexesSequenceCache = \
this.hot.rowIndexMapper.registerMap(this.pluginKey, new IndexesSequence());\n \
     \
this.indexesSequenceCache.setValues(this.hot.rowIndexMapper.getIndexesSequenc\
e());\n    }\n    if (sortPossible) {\n      \
this.columnStatesManager.setSortStates(destinationSortConfigs);\n      \
this.sortByPresetSortStates(destinationSortConfigs);\n      \
this.saveAllSortSettings(destinationSortConfigs);\n    }\n    \
this.hot.runHooks(\"afterColumnSort\", currentSortConfig, sortPossible ? \
destinationSortConfigs : currentSortConfig, sortPossible);\n    if \
(sortPossible) {\n      this.hot.render();\n      this.hot.forceFullRender = \
false;\n      this.hot.view.render();\n    }\n  }\n  /**\n   * Clear the sort \
performed on the table.\n   */\n  clearSort() {\n    this.sort([]);\n  }\n  \
/**\n   * Checks if the table is sorted (any column have to be sorted).\n   \
*\n   * @returns {boolean}\n   */\n  isSorted() {\n    return this.enabled && \
!this.columnStatesManager.isListOfSortedColumnsEmpty();\n  }\n  /**\n   * Get \
sort configuration for particular column or for all sorted columns. Objects \
contain `column` and `sortOrder` properties.\n   *\n   * **Note**: Please \
keep in mind that returned objects expose **visual** column index under the \
`column` key. They are handled by the `sort` function.\n   *\n   * @param \
{number} [column] Visual column index.\n   * @returns \
{undefined|object|Array}\n   */\n  getSortConfig(column) {\n    if \
(isDefined(column)) {\n      return \
this.columnStatesManager.getColumnSortState(column);\n    }\n    return \
this.columnStatesManager.getSortStates();\n  }\n  /**\n   * @description\n   \
* Warn: Useful mainly for providing server side sort implementation (see in \
the example below). It doesn't sort the data set. It just sets sort \
configuration for all sorted columns.\n   * Note: Please keep in mind that \
this method doesn't re-render the table.\n   *\n   * @example\n   * ```js\n   \
* beforeColumnSort: function(currentSortConfig, destinationSortConfigs) {\n   \
*   const columnSortPlugin = this.getPlugin('columnSorting');\n   *\n   *   \
columnSortPlugin.setSortConfig(destinationSortConfigs);\n   *\n   *   // \
const newData = ... // Calculated data set, ie. from an AJAX call.\n   *\n   \
*   this.loadData(newData); // Load new data set and re-render the table.\n   \
*\n   *   return false; // The blockade for the default sort action.\n   * \
}\n   * ```\n   *\n   * @param {undefined|object|Array} sortConfig Single \
column sort configuration or full sort configuration (for all sorted \
columns).\n   * The configuration object contains `column` and `sortOrder` \
properties. First of them contains visual column index, the second one \
contains\n   * sort order (`asc` for ascending, `desc` for descending).\n   \
*/\n  setSortConfig(sortConfig) {\n    const destinationSortConfigs = \
this.getNormalizedSortConfigs(sortConfig);\n    if \
(this.areValidSortConfigs(destinationSortConfigs)) {\n      \
this.columnStatesManager.setSortStates(destinationSortConfigs);\n    }\n  }\n \
 /**\n   * Get normalized sort configs.\n   *\n   * @private\n   * @param \
{object|Array} [sortConfig=[]] Single column sort configuration or full sort \
configuration (for all sorted columns).\n   * The configuration object \
contains `column` and `sortOrder` properties. First of them contains visual \
column index, the second one contains\n   * sort order (`asc` for ascending, \
`desc` for descending).\n   * @returns {Array}\n   */\n  \
getNormalizedSortConfigs() {\n    let sortConfig = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : [];\n    if \
(Array.isArray(sortConfig)) {\n      return sortConfig.slice(0, 1);\n    }\n  \
  return [sortConfig];\n  }\n  /**\n   * Get if sort configs are valid.\n   \
*\n   * @private\n   * @param {Array} sortConfigs Sort configuration for all \
sorted columns. Objects contain `column` and `sortOrder` properties.\n   * \
@returns {boolean}\n   */\n  areValidSortConfigs(sortConfigs) {\n    const \
numberOfColumns = this.hot.countCols();\n    return \
areValidSortStates(sortConfigs) && sortConfigs.every((_ref) => {\n      let \
{\n        column\n      } = _ref;\n      return column <= numberOfColumns && \
column >= 0;\n    });\n  }\n  /**\n   * Saves all sorting settings. Saving \
works only when {@link Options#persistentState} option is enabled.\n   *\n   \
* @param {Array} sortConfigs Sort configuration for all sorted columns. \
Objects contain `column` and `sortOrder` properties.\n   *\n   * @private\n   \
* @fires Hooks#persistentStateSave\n   */\n  saveAllSortSettings(sortConfigs) \
{\n    const allSortSettings = \
this.columnStatesManager.getAllColumnsProperties();\n    const \
translateColumnToPhysical = (_ref2) => {\n      let {\n        column: \
visualColumn,\n        ...restOfProperties\n      } = _ref2;\n      return \
{\n        column: this.hot.toPhysicalColumn(visualColumn),\n        \
...restOfProperties\n      };\n    };\n    allSortSettings.initialConfig = \
arrayMap(sortConfigs, translateColumnToPhysical);\n    \
this.hot.runHooks(\"persistentStateSave\", \"columnSorting\", \
allSortSettings);\n  }\n  /**\n   * Get all saved sorting settings. Loading \
works only when {@link Options#persistentState} option is enabled.\n   *\n   \
* @private\n   * @returns {object} Previously saved sort settings.\n   *\n   \
* @fires Hooks#persistentStateLoad\n   */\n  getAllSavedSortSettings() {\n    \
const storedAllSortSettings = {};\n    \
this.hot.runHooks(\"persistentStateLoad\", \"columnSorting\", \
storedAllSortSettings);\n    const allSortSettings = \
storedAllSortSettings.value;\n    const translateColumnToVisual = (_ref3) => \
{\n      let {\n        column: physicalColumn,\n        \
...restOfProperties\n      } = _ref3;\n      return {\n        column: \
this.hot.toVisualColumn(physicalColumn),\n        ...restOfProperties\n      \
};\n    };\n    if (isDefined(allSortSettings) && \
Array.isArray(allSortSettings.initialConfig)) {\n      \
allSortSettings.initialConfig = arrayMap(allSortSettings.initialConfig, \
translateColumnToVisual);\n    }\n    return allSortSettings;\n  }\n  /**\n   \
* Get next sort configuration for particular column. Object contain `column` \
and `sortOrder` properties.\n   *\n   * **Note**: Please keep in mind that \
returned object expose **visual** column index under the `column` key.\n   \
*\n   * @private\n   * @param {number} column Visual column index.\n   * \
@returns {undefined|object}\n   */\n  getColumnNextConfig(column) {\n    \
const sortOrder = this.columnStatesManager.getSortOrderOfColumn(column);\n    \
if (isDefined(sortOrder)) {\n      const nextSortOrder = \
getNextSortOrder(sortOrder);\n      if (isDefined(nextSortOrder)) {\n        \
return {\n          column,\n          sortOrder: nextSortOrder\n        };\n \
     }\n      return;\n    }\n    const nrOfColumns = this.hot.countCols();\n \
   if (Number.isInteger(column) && column >= 0 && column < nrOfColumns) {\n   \
   return {\n        column,\n        sortOrder: getNextSortOrder()\n      \
};\n    }\n  }\n  /**\n   * Get sort configuration with \"next order\" for \
particular column.\n   *\n   * @private\n   * @param {number} columnToChange \
Visual column index of column which order will be changed.\n   * @param \
{string} strategyId ID of strategy. Possible values: 'append' and 'replace'. \
The first one\n   * change order of particular column and change it's \
position in the sort queue to the last one. The second one\n   * just change \
order of particular column.\n   *\n   * **Note**: Please keep in mind that \
returned objects expose **visual** column index under the `column` key.\n   \
*\n   * @returns {Array}\n   */\n  getNextSortConfig(columnToChange) {\n    \
let strategyId = arguments.length > 1 && arguments[1] !== void 0 ? \
arguments[1] : APPEND_COLUMN_CONFIG_STRATEGY;\n    const \
indexOfColumnToChange = \
this.columnStatesManager.getIndexOfColumnInSortQueue(columnToChange);\n    \
const isColumnSorted = indexOfColumnToChange !== -1;\n    const \
currentSortConfig = this.getSortConfig();\n    const nextColumnConfig = \
this.getColumnNextConfig(columnToChange);\n    if (isColumnSorted) {\n      \
if (isUndefined(nextColumnConfig)) {\n        return \
[...currentSortConfig.slice(0, indexOfColumnToChange), \
...currentSortConfig.slice(indexOfColumnToChange + 1)];\n      }\n      if \
(strategyId === APPEND_COLUMN_CONFIG_STRATEGY) {\n        return \
[...currentSortConfig.slice(0, indexOfColumnToChange), \
...currentSortConfig.slice(indexOfColumnToChange + 1), nextColumnConfig];\n   \
   } else if (strategyId === REPLACE_COLUMN_CONFIG_STRATEGY) {\n        \
return [...currentSortConfig.slice(0, indexOfColumnToChange), \
nextColumnConfig, ...currentSortConfig.slice(indexOfColumnToChange + 1)];\n   \
   }\n    }\n    if (isDefined(nextColumnConfig)) {\n      return \
currentSortConfig.concat(nextColumnConfig);\n    }\n    return \
currentSortConfig;\n  }\n  /**\n   * Get plugin's column config for the \
specified column index.\n   *\n   * @private\n   * @param {object} \
columnConfig Configuration inside `columns` property for the specified column \
index.\n   * @returns {object}\n   */\n  getPluginColumnConfig(columnConfig) \
{\n    if (isObject(columnConfig)) {\n      const pluginColumnConfig = \
columnConfig[this.pluginKey];\n      if (isObject(pluginColumnConfig)) {\n    \
    return pluginColumnConfig;\n      }\n    }\n    return {};\n  }\n  /**\n  \
 * Get plugin settings related properties, properly merged from cascade \
settings.\n   *\n   * @private\n   * @param {number} column Visual column \
index.\n   * @returns {object}\n   */\n  getMergedPluginSettings(column) {\n  \
  const pluginMainSettings = this.hot.getSettings()[this.pluginKey];\n    \
const storedColumnProperties = \
this.columnStatesManager.getAllColumnsProperties();\n    const cellMeta = \
this.hot.getCellMeta(0, column);\n    const columnMeta = \
Object.getPrototypeOf(cellMeta);\n    if (Array.isArray(columnMeta.columns)) \
{\n      return Object.assign(storedColumnProperties, pluginMainSettings, \
this.getPluginColumnConfig(columnMeta.columns[column]));\n    } else if \
(isFunction(columnMeta.columns)) {\n      return \
Object.assign(storedColumnProperties, pluginMainSettings, \
this.getPluginColumnConfig(columnMeta.columns(column)));\n    }\n    return \
Object.assign(storedColumnProperties, pluginMainSettings);\n  }\n  /**\n   * \
Get copy of settings for first cell in the column.\n   *\n   * @private\n   * \
@param {number} column Visual column index.\n   * @returns {object}\n   */\n  \
// TODO: Workaround. Inheriting of non-primitive cell meta values doesn't \
work. Instead of getting properties from column meta we call this function.\n \
 // TODO: Remove test named: \"should not break the dataset when inserted new \
row\" (#5431).\n  getFirstCellSettings(column) {\n    const cellMeta = \
this.hot.getCellMeta(0, column);\n    const cellMetaCopy = \
Object.create(cellMeta);\n    cellMetaCopy[this.pluginKey] = \
this.columnMetaCache.getValueAtIndex(this.hot.toPhysicalColumn(column));\n    \
return cellMetaCopy;\n  }\n  /**\n   * Get number of rows which should be \
sorted.\n   *\n   * @private\n   * @param {number} numberOfRows Total number \
of displayed rows.\n   * @returns {number}\n   */\n  \
getNumberOfRowsToSort(numberOfRows) {\n    const settings = \
this.hot.getSettings();\n    if (settings.maxRows <= numberOfRows) {\n      \
return settings.maxRows;\n    }\n    return numberOfRows - \
settings.minSpareRows;\n  }\n  /**\n   * Performs the sorting using a stable \
sort function basing on internal state of sorting.\n   *\n   * @param {Array} \
sortConfigs Sort configuration for all sorted columns. Objects contain \
`column` and `sortOrder` properties.\n   * @private\n   */\n  \
sortByPresetSortStates(sortConfigs) {\n    if (sortConfigs.length === 0) {\n  \
    \
this.hot.rowIndexMapper.setIndexesSequence(this.indexesSequenceCache.getValue\
s());\n      return;\n    }\n    const indexesWithData = [];\n    const \
numberOfRows = this.hot.countRows();\n    const getDataForSortedColumns = \
(visualRowIndex) => arrayMap(sortConfigs, (sortConfig) => \
this.hot.getDataAtCell(visualRowIndex, sortConfig.column));\n    for (let \
visualRowIndex = 0; visualRowIndex < \
this.getNumberOfRowsToSort(numberOfRows); visualRowIndex += 1) {\n      \
indexesWithData.push([this.hot.toPhysicalRow(visualRowIndex)].concat(getDataF\
orSortedColumns(visualRowIndex)));\n    }\n    const indexesBefore = \
arrayMap(indexesWithData, (indexWithData) => indexWithData[0]);\n    \
sort(indexesWithData, this.pluginKey, arrayMap(sortConfigs, (sortConfig) => \
sortConfig.sortOrder), arrayMap(sortConfigs, (sortConfig) => \
this.getFirstCellSettings(sortConfig.column)));\n    for (let visualRowIndex \
= indexesWithData.length; visualRowIndex < numberOfRows; visualRowIndex += 1) \
{\n      \
indexesWithData.push([visualRowIndex].concat(getDataForSortedColumns(visualRo\
wIndex)));\n    }\n    const indexesAfter = arrayMap(indexesWithData, \
(indexWithData) => indexWithData[0]);\n    const indexMapping = new \
Map(arrayMap(indexesBefore, (indexBefore, indexInsideArray) => [indexBefore, \
indexesAfter[indexInsideArray]]));\n    const newIndexesSequence = \
arrayMap(this.hot.rowIndexMapper.getIndexesSequence(), (physicalIndex) => {\n \
     if (indexMapping.has(physicalIndex)) {\n        return \
indexMapping.get(physicalIndex);\n      }\n      return physicalIndex;\n    \
});\n    this.hot.rowIndexMapper.setIndexesSequence(newIndexesSequence);\n  \
}\n  /**\n   * Load saved settings or sort by predefined plugin \
configuration.\n   *\n   * @private\n   */\n  loadOrSortBySettings() {\n    \
const storedAllSortSettings = this.getAllSavedSortSettings();\n    if \
(isObject(storedAllSortSettings)) {\n      \
this.sortBySettings(storedAllSortSettings);\n    } else {\n      const \
allSortSettings = this.hot.getSettings()[this.pluginKey];\n      \
this.sortBySettings(allSortSettings);\n    }\n  }\n  /**\n   * Sort the table \
by provided configuration.\n   *\n   * @private\n   * @param {object} \
allSortSettings All sort config settings. Object may contain `initialConfig`, \
`indicator`,\n   * `sortEmptyCells`, `headerAction` and \
`compareFunctionFactory` properties.\n   */\n  \
sortBySettings(allSortSettings) {\n    if (isObject(allSortSettings)) {\n     \
 this.columnStatesManager.updateAllColumnsProperties(allSortSettings);\n      \
const initialConfig = allSortSettings.initialConfig;\n      if \
(Array.isArray(initialConfig) || isObject(initialConfig)) {\n        \
this.sort(initialConfig);\n      }\n    } else {\n      this.hot.render();\n  \
  }\n  }\n  /**\n   * Callback for the `onAfterGetColHeader` hook. Adds \
column sorting CSS classes.\n   *\n   * @private\n   * @param {number} column \
Visual column index.\n   * @param {Element} TH TH HTML element.\n   */\n  \
onAfterGetColHeader(column, TH) {\n    const headerSpanElement = \
getHeaderSpanElement(TH);\n    if (isFirstLevelColumnHeader(column, TH) === \
false || headerSpanElement === null) {\n      return;\n    }\n    const \
pluginSettingsForColumn = \
this.getFirstCellSettings(column)[this.pluginKey];\n    const \
showSortIndicator = pluginSettingsForColumn.indicator;\n    const \
headerActionEnabled = pluginSettingsForColumn.headerAction;\n    \
this.updateHeaderClasses(headerSpanElement, this.columnStatesManager, column, \
showSortIndicator, headerActionEnabled);\n  }\n  /**\n   * Update header \
classes.\n   *\n   * @private\n   * @param {HTMLElement} headerSpanElement \
Header span element.\n   * @param {...*} args Extra arguments for helpers.\n  \
 */\n  updateHeaderClasses(headerSpanElement) {\n    \
removeClass(headerSpanElement, getClassesToRemove(headerSpanElement));\n    \
if (this.enabled !== false) {\n      for (var _len = arguments.length, args = \
new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        \
args[_key - 1] = arguments[_key];\n      }\n      addClass(headerSpanElement, \
getClassesToAdd(...args));\n    }\n  }\n  /**\n   * Overwriting base plugin's \
`onUpdateSettings` method. Please keep in mind that `onAfterUpdateSettings` \
isn't called\n   * for `updateSettings` in specific situations.\n   *\n   * \
@private\n   * @param {object} newSettings New settings object.\n   */\n  \
onUpdateSettings(newSettings) {\n    super.onUpdateSettings();\n    if \
(this.columnMetaCache !== null) {\n      \
this.columnMetaCache.init(this.hot.columnIndexMapper.getNumberOfIndexes());\n \
   }\n    if (isDefined(newSettings[this.pluginKey])) {\n      \
this.sortBySettings(newSettings[this.pluginKey]);\n    }\n  }\n  /**\n   * \
Callback for the `afterLoadData` hook.\n   *\n   * @private\n   * @param \
{boolean} initialLoad Flag that determines whether the data has been loaded \
during the initialization.\n   */\n  onAfterLoadData(initialLoad) {\n    if \
(initialLoad === true) {\n      if (this.hot.view) {\n        \
this.loadOrSortBySettings();\n      }\n    }\n  }\n  /**\n   * Indicates if \
clickable header was clicked.\n   *\n   * @private\n   * @param {MouseEvent} \
event The `mousedown` event.\n   * @param {number} column Visual column \
index.\n   * @returns {boolean}\n   */\n  wasClickableHeaderClicked(event2, \
column) {\n    const pluginSettingsForColumn = \
this.getFirstCellSettings(column)[this.pluginKey];\n    const \
headerActionEnabled = pluginSettingsForColumn.headerAction;\n    return \
headerActionEnabled && event2.target.nodeName === \"SPAN\";\n  }\n  /**\n   * \
Changes the behavior of selection / dragging.\n   *\n   * @private\n   * \
@param {MouseEvent} event The `mousedown` event.\n   * @param {CellCoords} \
coords Visual coordinates.\n   * @param {HTMLElement} TD The cell element.\n  \
 * @param {object} controller An object with properties `row`, `column` and \
`cell`. Each property contains\n   *                            a boolean \
value that allows or disallows changing the selection for that particular \
area.\n   */\n  onBeforeOnCellMouseDown(event2, coords, TD, controller) {\n   \
 if (wasHeaderClickedProperly(coords.row, coords.col, event2) === false) {\n  \
    return;\n    }\n    if (this.wasClickableHeaderClicked(event2, \
coords.col) && this.hot.getShortcutManager().isCtrlPressed()) {\n      \
controller.column = true;\n    }\n  }\n  /**\n   * Callback for the \
`onAfterOnCellMouseDown` hook.\n   *\n   * @private\n   * @param {Event} \
event Event which are provided by hook.\n   * @param {CellCoords} coords \
Visual coords of the selected cell.\n   */\n  onAfterOnCellMouseDown(event2, \
coords) {\n    if (wasHeaderClickedProperly(coords.row, coords.col, event2) \
=== false) {\n      return;\n    }\n    if \
(this.wasClickableHeaderClicked(event2, coords.col)) {\n      if \
(this.hot.getShortcutManager().isCtrlPressed()) {\n        \
this.hot.deselectCell();\n        this.hot.selectColumns(coords.col);\n      \
}\n      this.sort(this.getColumnNextConfig(coords.col));\n    }\n  }\n  \
/**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    var \
_this$columnStatesMan;\n    (_this$columnStatesMan = \
this.columnStatesManager) === null || _this$columnStatesMan === void 0 || \
_this$columnStatesMan.destroy();\n    super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/columnSummary/endpoints.mjs\nvar Endpoints \
= class {\n  constructor(plugin, settings) {\n    this.plugin = plugin;\n    \
this.hot = this.plugin.hot;\n    this.endpoints = [];\n    this.settings = \
settings;\n    this.settingsType = \"array\";\n    this.currentEndpoint = \
null;\n    this.cellsToSetCache = [];\n  }\n  /**\n   * Get a single endpoint \
object.\n   *\n   * @param {number} index Index of the endpoint.\n   * \
@returns {object}\n   */\n  getEndpoint(index2) {\n    if (this.settingsType \
=== \"function\") {\n      return \
this.fillMissingEndpointData(this.settings)[index2];\n    }\n    return \
this.endpoints[index2];\n  }\n  /**\n   * Get an array with all the \
endpoints.\n   *\n   * @returns {Array}\n   */\n  getAllEndpoints() {\n    if \
(this.settingsType === \"function\") {\n      return \
this.fillMissingEndpointData(this.settings);\n    }\n    return \
this.endpoints;\n  }\n  /**\n   * Used to fill the blanks in the endpoint \
data provided by a settings function.\n   *\n   * @private\n   * @param \
{Function} func Function provided in the HOT settings.\n   * @returns {Array} \
An array of endpoints.\n   */\n  fillMissingEndpointData(func) {\n    return \
this.parseSettings(func.call(this));\n  }\n  /**\n   * Parse plugin's \
settings.\n   *\n   * @param {Array} settings The settings array.\n   * \
@returns {object[]}\n   */\n  parseSettings(settings) {\n    const \
endpointsArray = [];\n    let settingsArray = settings;\n    if \
(!settingsArray && typeof this.settings === \"function\") {\n      \
this.settingsType = \"function\";\n      return;\n    }\n    if \
(!settingsArray) {\n      settingsArray = this.settings;\n    }\n    \
arrayEach(settingsArray, (val) => {\n      const newEndpoint = {};\n      \
this.assignSetting(val, newEndpoint, \"ranges\", [[0, this.hot.countRows() - \
1]]);\n      this.assignSetting(val, newEndpoint, \"reversedRowCoords\", \
false);\n      this.assignSetting(val, newEndpoint, \"destinationRow\", new \
Error(`\n        You must provide a destination row for the Column Summary \
plugin in order to work properly!\n      `));\n      this.assignSetting(val, \
newEndpoint, \"destinationColumn\", new Error(`\n        You must provide a \
destination column for the Column Summary plugin in order to work properly!\n \
     `));\n      this.assignSetting(val, newEndpoint, \"sourceColumn\", \
val.destinationColumn);\n      this.assignSetting(val, newEndpoint, \"type\", \
\"sum\");\n      this.assignSetting(val, newEndpoint, \"forceNumeric\", \
false);\n      this.assignSetting(val, newEndpoint, \
\"suppressDataTypeErrors\", true);\n      this.assignSetting(val, \
newEndpoint, \"suppressDataTypeErrors\", true);\n      \
this.assignSetting(val, newEndpoint, \"customFunction\", null);\n      \
this.assignSetting(val, newEndpoint, \"readOnly\", true);\n      \
this.assignSetting(val, newEndpoint, \"roundFloat\", false);\n      \
endpointsArray.push(newEndpoint);\n    });\n    return endpointsArray;\n  }\n \
 /**\n   * Setter for the internal setting objects.\n   *\n   * @param \
{object} settings Object with the settings.\n   * @param {object} endpoint \
Contains information about the endpoint for the the calculation.\n   * @param \
{string} name Settings name.\n   * @param {object} defaultValue Default value \
for the settings.\n   */\n  assignSetting(settings, endpoint, name, \
defaultValue) {\n    if (name === \"ranges\" && settings[name] === void 0) \
{\n      endpoint[name] = defaultValue;\n      return;\n    } else if (name \
=== \"ranges\" && settings[name].length === 0) {\n      return;\n    }\n    \
if (settings[name] === void 0) {\n      if (defaultValue instanceof Error) \
{\n        throw defaultValue;\n      }\n      endpoint[name] = \
defaultValue;\n    } else {\n      if (name === \"destinationRow\" && \
endpoint.reversedRowCoords) {\n        endpoint[name] = this.hot.countRows() \
- settings[name] - 1;\n      } else {\n        endpoint[name] = \
settings[name];\n      }\n    }\n  }\n  /**\n   * Resets the endpoint setup \
before the structure alteration (like inserting or removing rows/columns). \
Used for settings provided as a function.\n   *\n   * @private\n   * @param \
{string} action Type of the action performed.\n   * @param {number} index \
Row/column index.\n   * @param {number} number Number of rows/columns \
added/removed.\n   */\n  resetSetupBeforeStructureAlteration(action, index2, \
number) {\n    if (this.settingsType !== \"function\") {\n      return;\n    \
}\n    const type = action.indexOf(\"row\") > -1 ? \"row\" : \"col\";\n    \
const endpoints = this.getAllEndpoints();\n    arrayEach(endpoints, (val) => \
{\n      if (type === \"row\" && val.destinationRow >= index2) {\n        if \
(action === \"insert_row\") {\n          val.alterRowOffset = number;\n       \
 } else if (action === \"remove_row\") {\n          val.alterRowOffset = -1 * \
number;\n        }\n      }\n      if (type === \"col\" && \
val.destinationColumn >= index2) {\n        if (action === \"insert_col\") \
{\n          val.alterColumnOffset = number;\n        } else if (action === \
\"remove_col\") {\n          val.alterColumnOffset = -1 * number;\n        \
}\n      }\n    });\n    this.resetAllEndpoints(endpoints, false);\n  }\n  \
/**\n   * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook \
callback. Reset and reenables the summary functionality\n   * after changing \
the table structure.\n   *\n   * @private\n   * @param {string} action Type \
of the action performed.\n   * @param {number} index Row/column index.\n   * \
@param {number} number Number of rows/columns added/removed.\n   * @param \
{Array} [logicRows] Array of the logical indexes.\n   * @param {string} \
[source] Source of change.\n   * @param {boolean} [forceRefresh] `true` of \
the endpoints should refresh after completing the function.\n   */\n  \
resetSetupAfterStructureAlteration(action, index2, number, logicRows, source) \
{\n    let forceRefresh = arguments.length > 5 && arguments[5] !== void 0 ? \
arguments[5] : true;\n    if (this.settingsType === \"function\") {\n      \
const beforeViewRenderCallback = () => {\n        \
this.hot.removeHook(\"beforeViewRender\", beforeViewRenderCallback);\n        \
return this.refreshAllEndpoints();\n      };\n      \
this.hot.addHookOnce(\"beforeViewRender\", beforeViewRenderCallback);\n      \
return;\n    }\n    const type = action.indexOf(\"row\") > -1 ? \"row\" : \
\"col\";\n    const multiplier = action.indexOf(\"remove\") > -1 ? -1 : 1;\n  \
  const endpoints = this.getAllEndpoints();\n    const rowMoving = \
action.indexOf(\"move_row\") === 0;\n    const placeOfAlteration = index2;\n  \
  arrayEach(endpoints, (val) => {\n      if (type === \"row\" && \
val.destinationRow >= placeOfAlteration) {\n        val.alterRowOffset = \
multiplier * number;\n      }\n      if (type === \"col\" && \
val.destinationColumn >= placeOfAlteration) {\n        val.alterColumnOffset \
= multiplier * number;\n      }\n    });\n    \
this.resetAllEndpoints(endpoints, !rowMoving);\n    if (rowMoving) {\n      \
arrayEach(endpoints, (endpoint) => {\n        \
this.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], \
logicRows.length);\n        this.recreatePhysicalRanges(endpoint);\n        \
this.clearOffsetInformation(endpoint);\n      });\n    } else {\n      \
arrayEach(endpoints, (endpoint) => {\n        \
this.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n      });\n    \
}\n    if (forceRefresh) {\n      this.refreshAllEndpoints();\n    }\n  }\n  \
/**\n   * Clear the offset information from the endpoint object.\n   *\n   * \
@private\n   * @param {object} endpoint And endpoint object.\n   */\n  \
clearOffsetInformation(endpoint) {\n    endpoint.alterRowOffset = void 0;\n   \
 endpoint.alterColumnOffset = void 0;\n  }\n  /**\n   * Extend the row ranges \
for the provided endpoint.\n   *\n   * @private\n   * @param {object} \
endpoint The endpoint object.\n   * @param {number} placeOfAlteration Index \
of the row where the alteration takes place.\n   * @param {number} \
previousPosition Previous endpoint result position.\n   * @param {number} \
offset Offset generated by the alteration.\n   */\n  \
extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset3) \
{\n    arrayEach(endpoint.ranges, (range) => {\n      if (range[1]) {\n       \
 if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n      \
    if (previousPosition > range[1]) {\n            range[1] += offset3;\n    \
      } else if (previousPosition < range[0]) {\n            range[0] -= \
offset3;\n          }\n        } else if (previousPosition >= range[0] && \
previousPosition <= range[1]) {\n          range[1] -= offset3;\n          if \
(placeOfAlteration <= range[0]) {\n            range[0] += 1;\n            \
range[1] += 1;\n          }\n        }\n      }\n    });\n  }\n  /**\n   * \
Recreate the physical ranges for the provided endpoint. Used (for example) \
when a row gets moved and extends an existing range.\n   *\n   * @private\n   \
* @param {object} endpoint An endpoint object.\n   */\n  \
recreatePhysicalRanges(endpoint) {\n    const ranges = endpoint.ranges;\n    \
const newRanges = [];\n    const allIndexes = [];\n    arrayEach(ranges, \
(range) => {\n      const newRange = [];\n      if (range[1]) {\n        for \
(let i = range[0]; i <= range[1]; i++) {\n          \
newRange.push(this.hot.toPhysicalRow(i));\n        }\n      } else {\n        \
newRange.push(this.hot.toPhysicalRow(range[0]));\n      }\n      \
allIndexes.push(newRange);\n    });\n    arrayEach(allIndexes, (range) => {\n \
     let newRange = [];\n      arrayEach(range, (coord, index2) => {\n        \
if (index2 === 0) {\n          newRange.push(coord);\n        } else if \
(range[index2] !== range[index2 - 1] + 1) {\n          \
newRange.push(range[index2 - 1]);\n          newRanges.push(newRange);\n      \
    newRange = [];\n          newRange.push(coord);\n        }\n        if \
(index2 === range.length - 1) {\n          newRange.push(coord);\n          \
newRanges.push(newRange);\n        }\n      });\n    });\n    endpoint.ranges \
= newRanges;\n  }\n  /**\n   * Shifts the endpoint coordinates by the defined \
offset.\n   *\n   * @private\n   * @param {object} endpoint Endpoint \
object.\n   * @param {number} offsetStartIndex Index of the performed change \
(if the change is located after the endpoint, nothing about the endpoint has \
to be changed.\n   */\n  shiftEndpointCoordinates(endpoint, offsetStartIndex) \
{\n    if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n      \
endpoint.destinationRow += endpoint.alterRowOffset || 0;\n      \
arrayEach(endpoint.ranges, (element) => {\n        arrayEach(element, \
(subElement, j) => {\n          if (subElement >= offsetStartIndex) {\n       \
     element[j] += endpoint.alterRowOffset || 0;\n          }\n        });\n  \
    });\n    } else if (endpoint.alterColumnOffset && \
endpoint.alterColumnOffset !== 0) {\n      endpoint.destinationColumn += \
endpoint.alterColumnOffset || 0;\n      endpoint.sourceColumn += \
endpoint.alterColumnOffset || 0;\n    }\n  }\n  /**\n   * Resets (removes) \
the endpoints from the table.\n   *\n   * @param {Array} [endpoints] Array \
containing the endpoints.\n   * @param {boolean} [useOffset=true] Use the \
cell offset value.\n   */\n  resetAllEndpoints() {\n    let endpoints = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
this.getAllEndpoints();\n    let useOffset = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : true;\n    const \
anyEndpointOutOfRange = endpoints.some((endpoint) => {\n      const \
alterRowOffset = endpoint.alterRowOffset || 0;\n      const alterColOffset = \
endpoint.alterColumnOffset || 0;\n      if (endpoint.destinationRow + \
alterRowOffset >= this.hot.countRows() || endpoint.destinationColumn + \
alterColOffset >= this.hot.countCols()) {\n        return true;\n      }\n    \
  return false;\n    });\n    if (anyEndpointOutOfRange) {\n      return;\n   \
 }\n    this.cellsToSetCache = [];\n    arrayEach(endpoints, (endpoint) => \
{\n      this.resetEndpointValue(endpoint, useOffset);\n    });\n    \
this.hot.setDataAtCell(this.cellsToSetCache, \"ColumnSummary.reset\");\n    \
this.cellsToSetCache = [];\n  }\n  /**\n   * Calculate and refresh all \
defined endpoints.\n   */\n  refreshAllEndpoints() {\n    \
this.cellsToSetCache = [];\n    arrayEach(this.getAllEndpoints(), (value) => \
{\n      this.currentEndpoint = value;\n      this.plugin.calculate(value);\n \
     this.setEndpointValue(value, \"init\");\n    });\n    \
this.currentEndpoint = null;\n    \
this.hot.setDataAtCell(this.cellsToSetCache, \"ColumnSummary.reset\");\n    \
this.cellsToSetCache = [];\n  }\n  /**\n   * Calculate and refresh endpoints \
only in the changed columns.\n   *\n   * @param {Array} changes Array of \
changes from the `afterChange` hook.\n   */\n  \
refreshChangedEndpoints(changes) {\n    const needToRefresh = [];\n    \
this.cellsToSetCache = [];\n    arrayEach(changes, (value, key, changesObj) \
=> {\n      if (`${value[2] || \"\"}` === `${value[3]}`) {\n        return;\n \
     }\n      arrayEach(this.getAllEndpoints(), (endpoint, j) => {\n        \
if (this.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && \
needToRefresh.indexOf(j) === -1) {\n          needToRefresh.push(j);\n        \
}\n      });\n    });\n    arrayEach(needToRefresh, (value) => {\n      \
this.refreshEndpoint(this.getEndpoint(value));\n    });\n    \
this.hot.setDataAtCell(this.cellsToSetCache, \"ColumnSummary.reset\");\n    \
this.cellsToSetCache = [];\n  }\n  /**\n   * Calculate and refresh a single \
endpoint.\n   *\n   * @param {object} endpoint Contains the endpoint \
information.\n   */\n  refreshEndpoint(endpoint) {\n    this.currentEndpoint \
= endpoint;\n    this.plugin.calculate(endpoint);\n    \
this.setEndpointValue(endpoint);\n    this.currentEndpoint = null;\n  }\n  \
/**\n   * Reset the endpoint value.\n   *\n   * @param {object} endpoint \
Contains the endpoint information.\n   * @param {boolean} [useOffset=true] \
Use the cell offset value.\n   */\n  resetEndpointValue(endpoint) {\n    let \
useOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
true;\n    const alterRowOffset = endpoint.alterRowOffset || 0;\n    const \
alterColOffset = endpoint.alterColumnOffset || 0;\n    \
this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + \
(useOffset ? alterRowOffset : 0)), \
this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? \
alterColOffset : 0)), \"\"]);\n  }\n  /**\n   * Set the endpoint value.\n   \
*\n   * @param {object} endpoint Contains the endpoint information.\n   * \
@param {string} [source] Source of the call information.\n   * @param \
{boolean} [render=false] `true` if it needs to render the table afterwards.\n \
  */\n  setEndpointValue(endpoint, source) {\n    let render = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    \
const visualEndpointRowIndex = \
this.hot.toVisualRow(endpoint.destinationRow);\n    if \
(endpoint.destinationRow >= this.hot.countRows() || \
endpoint.destinationColumn >= this.hot.countCols()) {\n      \
this.throwOutOfBoundsWarning();\n      return;\n    }\n    const \
destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow);\n    if \
(destinationVisualRow !== null) {\n      const cellMeta = \
this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn);\n     \
 if (source === \"init\" || cellMeta.readOnly !== endpoint.readOnly) {\n      \
  cellMeta.readOnly = endpoint.readOnly;\n        cellMeta.className = \
\"columnSummaryResult\";\n      }\n    }\n    if (endpoint.roundFloat && \
!isNaN(endpoint.result)) {\n      endpoint.result = \
endpoint.result.toFixed(endpoint.roundFloat);\n    }\n    if (render) {\n     \
 this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, \
endpoint.result, \"ColumnSummary.set\");\n    } else {\n      \
this.cellsToSetCache.push([visualEndpointRowIndex, \
endpoint.destinationColumn, endpoint.result]);\n    }\n    \
endpoint.alterRowOffset = void 0;\n    endpoint.alterColumnOffset = void 0;\n \
 }\n  /**\n   * Throw an error for the calculation range being out of \
boundaries.\n   *\n   * @private\n   */\n  throwOutOfBoundsWarning() {\n    \
warn(\"One of the Column Summary plugins' destination points you provided is \
beyond the table boundaries!\");\n  }\n};\nvar endpoints_default = \
Endpoints;\n\n// \
node_modules/handsontable/plugins/columnSummary/utils.mjs\nfunction \
isNullishOrNaN(value) {\n  return value === null || value === void 0 || \
isNaN(value);\n}\n\n// \
node_modules/handsontable/plugins/columnSummary/columnSummary.mjs\nvar \
PLUGIN_KEY8 = \"columnSummary\";\nvar PLUGIN_PRIORITY7 = 220;\nvar \
ColumnSummary = class extends BasePlugin {\n  static get PLUGIN_KEY() {\n    \
return PLUGIN_KEY8;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY7;\n  }\n  constructor(hotInstance) {\n    \
super(hotInstance);\n    this.endpoints = null;\n  }\n  /**\n   * Checks if \
the plugin is enabled in the handsontable settings. This method is executed \
in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the \
{@link ColumnSummary#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY8];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    \
this.settings = this.hot.getSettings()[PLUGIN_KEY8];\n    this.endpoints = \
new endpoints_default(this, this.settings);\n    this.addHook(\"afterInit\", \
function() {\n      return _this.onAfterInit(...arguments);\n    });\n    \
this.addHook(\"afterChange\", function() {\n      return \
_this.onAfterChange(...arguments);\n    });\n    \
this.addHook(\"beforeCreateRow\", (index2, amount, source) => \
this.endpoints.resetSetupBeforeStructureAlteration(\"insert_row\", index2, \
amount, null, source));\n    this.addHook(\"beforeCreateCol\", (index2, \
amount, source) => \
this.endpoints.resetSetupBeforeStructureAlteration(\"insert_col\", index2, \
amount, null, source));\n    this.addHook(\"beforeRemoveRow\", function() {\n \
     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key \
< _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      \
return _this.endpoints.resetSetupBeforeStructureAlteration(\"remove_row\", \
...args);\n    });\n    this.addHook(\"beforeRemoveCol\", function() {\n      \
for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 \
< _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      \
return _this.endpoints.resetSetupBeforeStructureAlteration(\"remove_col\", \
...args);\n    });\n    this.addHook(\"afterCreateRow\", (index2, amount, \
source) => this.endpoints.resetSetupAfterStructureAlteration(\"insert_row\", \
index2, amount, null, source));\n    this.addHook(\"afterCreateCol\", \
(index2, amount, source) => \
this.endpoints.resetSetupAfterStructureAlteration(\"insert_col\", index2, \
amount, null, source));\n    this.addHook(\"afterRemoveRow\", function() {\n  \
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; \
_key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n \
     return \
_this.endpoints.resetSetupAfterStructureAlteration(\"remove_row\", \
...args);\n    });\n    this.addHook(\"afterRemoveCol\", function() {\n      \
for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 \
< _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      \
return _this.endpoints.resetSetupAfterStructureAlteration(\"remove_col\", \
...args);\n    });\n    this.addHook(\"afterRowMove\", function() {\n      \
return _this.onAfterRowMove(...arguments);\n    });\n    \
super.enablePlugin();\n  }\n  /**\n   * Disables the plugin functionality for \
this Handsontable instance.\n   */\n  disablePlugin() {\n    this.endpoints = \
null;\n    this.settings = null;\n    this.currentEndpoint = null;\n  }\n  \
/**\n   * Calculates math for a single endpoint.\n   *\n   * @private\n   * \
@param {object} endpoint Contains information about the endpoint.\n   */\n  \
calculate(endpoint) {\n    switch (endpoint.type.toLowerCase()) {\n      case \
\"sum\":\n        endpoint.result = this.calculateSum(endpoint);\n        \
break;\n      case \"min\":\n        endpoint.result = \
this.calculateMinMax(endpoint, endpoint.type);\n        break;\n      case \
\"max\":\n        endpoint.result = this.calculateMinMax(endpoint, \
endpoint.type);\n        break;\n      case \"count\":\n        \
endpoint.result = this.countEntries(endpoint);\n        break;\n      case \
\"average\":\n        endpoint.result = this.calculateAverage(endpoint);\n    \
    break;\n      case \"custom\":\n        endpoint.result = \
endpoint.customFunction.call(this, endpoint);\n        break;\n      \
default:\n        break;\n    }\n  }\n  /**\n   * Calculates sum of the \
values contained in ranges provided in the plugin config.\n   *\n   * \
@private\n   * @param {object} endpoint Contains the endpoint information.\n  \
 * @returns {number} Sum for the selected range.\n   */\n  \
calculateSum(endpoint) {\n    let sum = 0;\n    objectEach(endpoint.ranges, \
(range) => {\n      sum += this.getPartialSum(range, \
endpoint.sourceColumn);\n    });\n    return sum;\n  }\n  /**\n   * Returns \
partial sum of values from a single row range.\n   *\n   * @private\n   * \
@param {Array} rowRange Range for the sum.\n   * @param {number} col Column \
index.\n   * @returns {number} The partial sum.\n   */\n  \
getPartialSum(rowRange, col) {\n    let sum = 0;\n    let i = rowRange[1] || \
rowRange[0];\n    let cellValue = null;\n    let biggestDecimalPlacesCount = \
0;\n    do {\n      cellValue = this.getCellValue(i, col);\n      cellValue = \
isNullishOrNaN(cellValue) ? null : cellValue;\n      if (cellValue !== null) \
{\n        const decimalPlaces = (`${cellValue}`.split(\".\")[1] || \
[]).length || 1;\n        if (decimalPlaces > biggestDecimalPlacesCount) {\n  \
        biggestDecimalPlacesCount = decimalPlaces;\n        }\n      }\n      \
sum += cellValue || 0;\n      i -= 1;\n    } while (i >= rowRange[0]);\n    \
return Math.round(sum * 10 ** biggestDecimalPlacesCount) / 10 ** \
biggestDecimalPlacesCount;\n  }\n  /**\n   * Calculates the minimal value for \
the selected ranges.\n   *\n   * @private\n   * @param {object} endpoint \
Contains the endpoint information.\n   * @param {string} type `'min'` or \
`'max'`.\n   * @returns {number} Min or Max value.\n   */\n  \
calculateMinMax(endpoint, type) {\n    let result = null;\n    \
objectEach(endpoint.ranges, (range) => {\n      const partialResult = \
this.getPartialMinMax(range, endpoint.sourceColumn, type);\n      if (result \
=== null && partialResult !== null) {\n        result = partialResult;\n      \
}\n      if (partialResult !== null) {\n        switch (type) {\n          \
case \"min\":\n            result = Math.min(result, partialResult);\n        \
    break;\n          case \"max\":\n            result = Math.max(result, \
partialResult);\n            break;\n          default:\n            break;\n \
       }\n      }\n    });\n    return result === null ? \"Not enough data\" \
: result;\n  }\n  /**\n   * Returns a local minimum of the provided \
sub-range.\n   *\n   * @private\n   * @param {Array} rowRange Range for the \
calculation.\n   * @param {number} col Column index.\n   * @param {string} \
type `'min'` or `'max'`.\n   * @returns {number|null} Min or max value.\n   \
*/\n  getPartialMinMax(rowRange, col, type) {\n    let result = null;\n    \
let i = rowRange[1] || rowRange[0];\n    let cellValue;\n    do {\n      \
cellValue = this.getCellValue(i, col);\n      cellValue = \
isNullishOrNaN(cellValue) ? null : cellValue;\n      if (result === null) {\n \
       result = cellValue;\n      } else if (cellValue !== null) {\n        \
switch (type) {\n          case \"min\":\n            result = \
Math.min(result, cellValue);\n            break;\n          case \"max\":\n   \
         result = Math.max(result, cellValue);\n            break;\n          \
default:\n            break;\n        }\n      }\n      i -= 1;\n    } while \
(i >= rowRange[0]);\n    return result;\n  }\n  /**\n   * Counts empty cells \
in the provided row range.\n   *\n   * @private\n   * @param {Array} rowRange \
Row range for the calculation.\n   * @param {number} col Column index.\n   * \
@returns {number} Empty cells count.\n   */\n  countEmpty(rowRange, col) {\n  \
  let cellValue;\n    let counter = 0;\n    let i = rowRange[1] || \
rowRange[0];\n    do {\n      cellValue = this.getCellValue(i, col);\n      \
cellValue = isNullishOrNaN(cellValue) ? null : cellValue;\n      if \
(cellValue === null) {\n        counter += 1;\n      }\n      i -= 1;\n    } \
while (i >= rowRange[0]);\n    return counter;\n  }\n  /**\n   * Counts \
non-empty cells in the provided row range.\n   *\n   * @private\n   * @param \
{object} endpoint Contains the endpoint information.\n   * @returns {number} \
Entry count.\n   */\n  countEntries(endpoint) {\n    let result = 0;\n    \
const ranges = endpoint.ranges;\n    objectEach(ranges, (range) => {\n      \
const partial2 = range[1] === void 0 ? 1 : range[1] - range[0] + 1;\n      \
const emptyCount = this.countEmpty(range, endpoint.sourceColumn);\n      \
result += partial2;\n      result -= emptyCount;\n    });\n    return \
result;\n  }\n  /**\n   * Calculates the average value from the cells in the \
range.\n   *\n   * @private\n   * @param {object} endpoint Contains the \
endpoint information.\n   * @returns {number} Avarage value.\n   */\n  \
calculateAverage(endpoint) {\n    const sum = this.calculateSum(endpoint);\n  \
  const entriesCount = this.countEntries(endpoint);\n    return sum / \
entriesCount;\n  }\n  /**\n   * Returns a cell value, taking into \
consideration a basic validation.\n   *\n   * @private\n   * @param {number} \
row Row index.\n   * @param {number} col Column index.\n   * @returns \
{string} The cell value.\n   */\n  getCellValue(row, col) {\n    const \
visualRowIndex = this.hot.toVisualRow(row);\n    const visualColumnIndex = \
this.hot.toVisualColumn(col);\n    let cellValue = \
this.hot.getSourceDataAtCell(row, col);\n    let cellClassName = \"\";\n    \
if (visualRowIndex !== null && visualColumnIndex !== null) {\n      \
cellClassName = this.hot.getCellMeta(visualRowIndex, \
visualColumnIndex).className || \"\";\n    }\n    if \
(cellClassName.indexOf(\"columnSummaryResult\") > -1) {\n      return null;\n \
   }\n    if (this.endpoints.currentEndpoint.forceNumeric) {\n      if \
(typeof cellValue === \"string\") {\n        cellValue = \
cellValue.replace(/,/, \".\");\n      }\n      cellValue = \
parseFloat(cellValue);\n    }\n    if (isNaN(cellValue)) {\n      if \
(!this.endpoints.currentEndpoint.suppressDataTypeErrors) {\n        throw new \
Error(toSingleLine`ColumnSummary plugin: cell at (${row}, ${col}) is not in \
a\\x20\n          numeric format. Cannot do the calculation.`);\n      }\n    \
}\n    return cellValue;\n  }\n  /**\n   * `afterInit` hook callback.\n   *\n \
  * @private\n   */\n  onAfterInit() {\n    this.endpoints.endpoints = \
this.endpoints.parseSettings();\n    \
this.endpoints.refreshAllEndpoints(true);\n  }\n  /**\n   * `afterChange` \
hook callback.\n   *\n   * @private\n   * @param {Array} changes 2D array \
containing information about each of the edited cells.\n   * @param {string} \
source The string that identifies source of changes.\n   */\n  \
onAfterChange(changes, source) {\n    if (changes && source !== \
\"ColumnSummary.reset\" && source !== \"ColumnSummary.set\" && source !== \
\"loadData\") {\n      this.endpoints.refreshChangedEndpoints(changes);\n    \
}\n  }\n  /**\n   * `beforeRowMove` hook callback.\n   *\n   * @private\n   * \
@param {Array} rows Array of visual row indexes to be moved.\n   * @param \
{number} finalIndex Visual row index, being a start index for the moved rows. \
Points to where the elements will be placed after the moving action.\n   * To \
check the visualization of the final index, please take a look at \
[documentation](@/guides/rows/row-moving.md).\n   */\n  onAfterRowMove(rows, \
finalIndex) {\n    \
this.endpoints.resetSetupBeforeStructureAlteration(\"move_row\", rows[0], \
rows.length, rows, this.pluginName);\n    \
this.endpoints.resetSetupAfterStructureAlteration(\"move_row\", finalIndex, \
rows.length, rows, this.pluginName);\n  }\n};\n\n// \
node_modules/handsontable/plugins/comments/commentEditor.mjs\nvar \
CommentEditor = class _CommentEditor {\n  static get CLASS_EDITOR_CONTAINER() \
{\n    return \"htCommentsContainer\";\n  }\n  static get CLASS_EDITOR() {\n  \
  return \"htComments\";\n  }\n  static get CLASS_INPUT() {\n    return \
\"htCommentTextArea\";\n  }\n  static get CLASS_CELL() {\n    return \
\"htCommentCell\";\n  }\n  constructor(rootDocument, isRtl) {\n    \
this.rootDocument = rootDocument;\n    this.isRtl = isRtl;\n    \
this.container = null;\n    this.editor = this.createEditor();\n    \
this.editorStyle = this.editor.style;\n    this.hidden = true;\n    \
this.hide();\n  }\n  /**\n   * Set position of the comments editor according \
to the  provided x and y coordinates.\n   *\n   * @param {number} x X \
position (in pixels).\n   * @param {number} y Y position (in pixels).\n   \
*/\n  setPosition(x, y) {\n    this.editorStyle.left = `${x}px`;\n    \
this.editorStyle.top = `${y}px`;\n  }\n  /**\n   * Set the editor size \
according to the provided arguments.\n   *\n   * @param {number} width Width \
in pixels.\n   * @param {number} height Height in pixels.\n   */\n  \
setSize(width, height) {\n    if (width && height) {\n      const input = \
this.getInputElement();\n      input.style.width = `${width}px`;\n      \
input.style.height = `${height}px`;\n    }\n  }\n  /**\n   * Returns the size \
of the comments editor.\n   *\n   * @returns {{ width: number, height: number \
}}\n   */\n  getSize() {\n    return {\n      width: \
outerWidth(this.getInputElement()),\n      height: \
outerHeight(this.getInputElement())\n    };\n  }\n  /**\n   * Reset the \
editor size to its initial state.\n   */\n  resetSize() {\n    const input = \
this.getInputElement();\n    input.style.width = \"\";\n    \
input.style.height = \"\";\n  }\n  /**\n   * Set the read-only state for the \
comments editor.\n   *\n   * @param {boolean} state The new read only \
state.\n   */\n  setReadOnlyState(state) {\n    const input = \
this.getInputElement();\n    input.readOnly = state;\n  }\n  /**\n   * Show \
the comments editor.\n   */\n  show() {\n    this.editorStyle.display = \
\"block\";\n    this.hidden = false;\n  }\n  /**\n   * Hide the comments \
editor.\n   */\n  hide() {\n    if (!this.hidden) {\n      \
this.editorStyle.display = \"none\";\n    }\n    this.hidden = true;\n  }\n  \
/**\n   * Checks if the editor is visible.\n   *\n   * @returns {boolean}\n   \
*/\n  isVisible() {\n    return this.editorStyle.display === \"block\";\n  \
}\n  /**\n   * Set the comment value.\n   *\n   * @param {string} [value] The \
value to use.\n   */\n  setValue() {\n    let value = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : \"\";\n    const comment = value || \
\"\";\n    this.getInputElement().value = comment;\n  }\n  /**\n   * Get the \
comment value.\n   *\n   * @returns {string}\n   */\n  getValue() {\n    \
return this.getInputElement().value;\n  }\n  /**\n   * Checks if the comment \
input element is focused.\n   *\n   * @returns {boolean}\n   */\n  \
isFocused() {\n    return this.rootDocument.activeElement === \
this.getInputElement();\n  }\n  /**\n   * Focus the comments input element.\n \
  */\n  focus() {\n    this.getInputElement().focus();\n  }\n  /**\n   * \
Create the `textarea` to be used as a comments editor.\n   *\n   * @returns \
{HTMLElement}\n   */\n  createEditor() {\n    const editor = \
this.rootDocument.createElement(\"div\");\n    const textArea = \
this.rootDocument.createElement(\"textarea\");\n    editor.style.display = \
\"none\";\n    this.container = this.rootDocument.createElement(\"div\");\n   \
 this.container.setAttribute(\"dir\", this.isRtl ? \"rtl\" : \"ltr\");\n    \
addClass(this.container, _CommentEditor.CLASS_EDITOR_CONTAINER);\n    \
this.rootDocument.body.appendChild(this.container);\n    addClass(editor, \
_CommentEditor.CLASS_EDITOR);\n    addClass(textArea, \
_CommentEditor.CLASS_INPUT);\n    editor.appendChild(textArea);\n    \
this.container.appendChild(editor);\n    return editor;\n  }\n  /**\n   * Get \
the input element.\n   *\n   * @returns {HTMLElement}\n   */\n  \
getInputElement() {\n    return \
this.editor.querySelector(`.${_CommentEditor.CLASS_INPUT}`);\n  }\n  /**\n   \
* Destroy the comments editor.\n   */\n  destroy() {\n    const \
containerParentElement = this.container ? this.container.parentNode : null;\n \
   this.editor.parentNode.removeChild(this.editor);\n    this.editor = \
null;\n    this.editorStyle = null;\n    if (containerParentElement) {\n      \
containerParentElement.removeChild(this.container);\n    }\n  }\n};\nvar \
commentEditor_default = CommentEditor;\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/separator.mjs\n\
var KEY = \"---------\";\nfunction separatorItem() {\n  return {\n    name: \
KEY\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/utils.mjs\nfunction \
normalizeSelection(selRanges) {\n  return arrayMap(selRanges, (range) => ({\n \
   start: range.getTopStartCorner(),\n    end: range.getBottomEndCorner()\n  \
}));\n}\nfunction isSeparator(cell) {\n  return hasClass(cell, \
\"htSeparator\");\n}\nfunction hasSubMenu(cell) {\n  return hasClass(cell, \
\"htSubmenu\");\n}\nfunction isDisabled(cell) {\n  return hasClass(cell, \
\"htDisabled\");\n}\nfunction isSelectionDisabled(cell) {\n  return \
hasClass(cell, \"htSelectionDisabled\");\n}\nfunction getValidSelection(hot2) \
{\n  const selected = hot2.getSelected();\n  if (!selected) {\n    return \
null;\n  }\n  if (selected[0] < 0) {\n    return null;\n  }\n  return \
selected;\n}\nfunction prepareVerticalAlignClass(className, alignment) {\n  \
if (className.indexOf(alignment) !== -1) {\n    return className;\n  }\n  \
const replacedClassName = className.replace(\"htTop\", \
\"\").replace(\"htMiddle\", \"\").replace(\"htBottom\", \"\").replace(\"  \", \
\"\");\n  return `${replacedClassName} ${alignment}`;\n}\nfunction \
prepareHorizontalAlignClass(className, alignment) {\n  if \
(className.indexOf(alignment) !== -1) {\n    return className;\n  }\n  const \
replacedClassName = className.replace(\"htLeft\", \"\").replace(\"htCenter\", \
\"\").replace(\"htRight\", \"\").replace(\"htJustify\", \"\").replace(\"  \", \
\"\");\n  return `${replacedClassName} ${alignment}`;\n}\nfunction \
getAlignmentClasses(ranges, callback) {\n  const classes = {};\n  \
arrayEach(ranges, (range) => {\n    range.forAll((row, col) => {\n      if \
(row >= 0 && col >= 0) {\n        if (!classes[row]) {\n          \
classes[row] = [];\n        }\n        classes[row][col] = callback(row, \
col);\n      }\n    });\n  });\n  return classes;\n}\nfunction align(ranges, \
type, alignment, cellDescriptor, propertySetter) {\n  arrayEach(ranges, \
(range) => {\n    range.forAll((row, col) => {\n      if (row >= 0 && col >= \
0) {\n        applyAlignClassName(row, col, type, alignment, cellDescriptor, \
propertySetter);\n      }\n    });\n  });\n}\nfunction \
applyAlignClassName(row, col, type, alignment, cellDescriptor, \
propertySetter) {\n  const cellMeta = cellDescriptor(row, col);\n  let \
className = alignment;\n  if (cellMeta.className) {\n    if (type === \
\"vertical\") {\n      className = \
prepareVerticalAlignClass(cellMeta.className, alignment);\n    } else {\n     \
 className = prepareHorizontalAlignClass(cellMeta.className, alignment);\n    \
}\n  }\n  propertySetter(row, col, \"className\", className);\n}\nfunction \
checkSelectionConsistency(ranges, comparator) {\n  let result = false;\n  if \
(Array.isArray(ranges)) {\n    arrayEach(ranges, (range) => {\n      \
range.forAll((row, col) => {\n        if (row >= 0 && col >= 0 && \
comparator(row, col)) {\n          result = true;\n          return false;\n  \
      }\n      });\n      return result;\n    });\n  }\n  return \
result;\n}\nfunction markLabelAsSelected(label) {\n  return `<span \
class=\"selected\">${String.fromCharCode(10003)}</span>${label}`;\n}\nfunctio\
n isItemHidden(item, instance) {\n  return !item.hidden || !(typeof \
item.hidden === \"function\" && item.hidden.call(instance));\n}\nfunction \
shiftSeparators(items, separator) {\n  const result = items.slice(0);\n  for \
(let i = 0; i < result.length; ) {\n    if (result[i].name === separator) {\n \
     result.shift();\n    } else {\n      break;\n    }\n  }\n  return \
result;\n}\nfunction popSeparators(items, separator) {\n  let result = \
items.slice(0);\n  result.reverse();\n  result = shiftSeparators(result, \
separator);\n  result.reverse();\n  return result;\n}\nfunction \
removeDuplicatedSeparators(items) {\n  const result = [];\n  arrayEach(items, \
(value, index2) => {\n    if (index2 > 0) {\n      if (result[result.length - \
1].name !== value.name) {\n        result.push(value);\n      }\n    } else \
{\n      result.push(value);\n    }\n  });\n  return result;\n}\nfunction \
filterSeparators(items) {\n  let separator = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : KEY;\n  let result = \
items.slice(0);\n  result = shiftSeparators(result, separator);\n  result = \
popSeparators(result, separator);\n  result = \
removeDuplicatedSeparators(result);\n  return result;\n}\n\n// \
node_modules/handsontable/plugins/comments/displaySwitch.mjs\nvar \
DEFAULT_DISPLAY_DELAY = 250;\nvar DEFAULT_HIDE_DELAY = 250;\nvar \
DisplaySwitch = class {\n  constructor(displayDelay) {\n    \
this.wasLastActionShow = true;\n    this.showDebounced = null;\n    \
this.hidingTimer = null;\n    this.updateDelay(displayDelay);\n  }\n  /**\n   \
* Responsible for hiding comment after proper delay.\n   */\n  hide() {\n    \
this.wasLastActionShow = false;\n    this.hidingTimer = setTimeout(() => {\n  \
    if (this.wasLastActionShow === false) {\n        \
this.runLocalHooks(\"hide\");\n      }\n    }, DEFAULT_HIDE_DELAY);\n  }\n  \
/**\n   * Responsible for showing comment after proper delay.\n   *\n   * \
@param {object} range Coordinates of selected cell.\n   */\n  show(range) {\n \
   this.wasLastActionShow = true;\n    this.showDebounced(range);\n  }\n  \
/**\n   * Cancel hiding comment.\n   */\n  cancelHiding() {\n    \
this.wasLastActionShow = true;\n    clearTimeout(this.hidingTimer);\n    \
this.hidingTimer = null;\n  }\n  /**\n   * Update the switch settings.\n   \
*\n   * @param {number} displayDelay Delay of showing the comments (in \
milliseconds).\n   */\n  updateDelay() {\n    let displayDelay = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
DEFAULT_DISPLAY_DELAY;\n    this.showDebounced = debounce((range) => {\n      \
if (this.wasLastActionShow) {\n        this.runLocalHooks(\"show\", \
range.from.row, range.from.col);\n      }\n    }, displayDelay);\n  }\n  \
/**\n   * Destroy the switcher.\n   */\n  destroy() {\n    \
this.clearLocalHooks();\n  }\n};\nmixin(DisplaySwitch, \
localHooks_default);\nvar displaySwitch_default = DisplaySwitch;\n\n// \
node_modules/handsontable/plugins/comments/comments.mjs\nvar PLUGIN_KEY9 = \
\"comments\";\nvar PLUGIN_PRIORITY8 = 60;\nvar privatePool8 = /* @__PURE__ */ \
new WeakMap();\nvar META_COMMENT = \"comment\";\nvar META_COMMENT_VALUE = \
\"value\";\nvar META_STYLE = \"style\";\nvar META_READONLY = \
\"readOnly\";\nvar Comments = class extends BasePlugin {\n  static get \
PLUGIN_KEY() {\n    return PLUGIN_KEY9;\n  }\n  static get PLUGIN_PRIORITY() \
{\n    return PLUGIN_PRIORITY8;\n  }\n  constructor(hotInstance) {\n    \
super(hotInstance);\n    this.editor = null;\n    this.displaySwitch = \
null;\n    this.eventManager = null;\n    this.range = {};\n    \
this.preventEditorAutoSwitch = false;\n    privatePool8.set(this, {\n      \
tempEditorDimensions: {},\n      cellBelowCursor: null\n    });\n  }\n  /**\n \
  * Checks if the plugin is enabled in the handsontable settings. This method \
is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` \
then the {@link Comments#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY9];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
if (this.enabled) {\n      return;\n    }\n    if (!this.editor) {\n      \
this.editor = new commentEditor_default(this.hot.rootDocument, \
this.hot.isRtl());\n    }\n    if (!this.eventManager) {\n      \
this.eventManager = new eventManager_default(this);\n    }\n    if \
(!this.displaySwitch) {\n      this.displaySwitch = new \
displaySwitch_default(this.getDisplayDelaySetting());\n    }\n    \
this.addHook(\"afterContextMenuDefaultOptions\", (options) => \
this.addToContextMenu(options));\n    this.addHook(\"afterRenderer\", (TD, \
row, col, prop, value, cellProperties) => this.onAfterRenderer(TD, \
cellProperties));\n    this.addHook(\"afterScrollHorizontally\", () => \
this.hide());\n    this.addHook(\"afterScrollVertically\", () => \
this.hide());\n    this.addHook(\"afterBeginEditing\", () => this.hide());\n  \
  this.displaySwitch.addLocalHook(\"hide\", () => this.hide());\n    \
this.displaySwitch.addLocalHook(\"show\", (row, col) => this.showAtCell(row, \
col));\n    this.registerListeners();\n    super.enablePlugin();\n  }\n  \
/**\n   * Updates the plugin's state.\n   *\n   * This method is executed \
when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any \
of the following configuration options:\n   *   - \
[`comments`](@/api/options.md#comments)\n   */\n  updatePlugin() {\n    \
this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  \
  this.displaySwitch.updateDelay(this.getDisplayDelaySetting());\n  }\n  \
/**\n   * Disables the plugin functionality for this Handsontable instance.\n \
  */\n  disablePlugin() {\n    super.disablePlugin();\n  }\n  /**\n   * \
Registers all necessary DOM listeners.\n   *\n   * @private\n   */\n  \
registerListeners() {\n    const {\n      rootDocument\n    } = this.hot;\n   \
 this.eventManager.addEventListener(rootDocument, \"mouseover\", (event2) => \
this.onMouseOver(event2));\n    \
this.eventManager.addEventListener(rootDocument, \"mousedown\", (event2) => \
this.onMouseDown(event2));\n    \
this.eventManager.addEventListener(rootDocument, \"mouseup\", () => \
this.onMouseUp());\n    \
this.eventManager.addEventListener(this.editor.getInputElement(), \"blur\", \
() => this.onEditorBlur());\n    \
this.eventManager.addEventListener(this.editor.getInputElement(), \
\"mousedown\", (event2) => this.onEditorMouseDown(event2));\n    \
this.eventManager.addEventListener(this.editor.getInputElement(), \
\"mouseup\", (event2) => this.onEditorMouseUp(event2));\n  }\n  /**\n   * \
Sets the current cell range to be able to use general methods like {@link \
Comments#setComment}, {@link Comments#removeComment}, {@link \
Comments#show}.\n   *\n   * @param {object} range Object with `from` \
property, each with `row` and `col` properties.\n   */\n  setRange(range) {\n \
   this.range = range;\n  }\n  /**\n   * Clears the currently selected \
cell.\n   */\n  clearRange() {\n    this.range = {};\n  }\n  /**\n   * Checks \
if the event target is a cell containing a comment.\n   *\n   * @private\n   \
* @param {Event} event DOM event.\n   * @returns {boolean}\n   */\n  \
targetIsCellWithComment(event2) {\n    const closestCell = \
closest(event2.target, \"TD\", \"TBODY\");\n    return !!(closestCell && \
hasClass(closestCell, \"htCommentCell\") && closest(closestCell, \
[this.hot.rootElement]));\n  }\n  /**\n   * Checks if the event target is a \
comment textarea.\n   *\n   * @private\n   * @param {Event} event DOM \
event.\n   * @returns {boolean}\n   */\n  targetIsCommentTextArea(event2) {\n \
   return this.editor.getInputElement() === event2.target;\n  }\n  /**\n   * \
Sets a comment for a cell according to the previously set range (see {@link \
Comments#setRange}).\n   *\n   * @param {string} value Comment contents.\n   \
*/\n  setComment(value) {\n    if (!this.range.from) {\n      throw new \
Error('Before using this method, first set cell range \
(hot.getPlugin(\"comment\").setRange())');\n    }\n    const editorValue = \
this.editor.getValue();\n    let comment = \"\";\n    if (value !== null && \
value !== void 0) {\n      comment = value;\n    } else if (editorValue !== \
null && editorValue !== void 0) {\n      comment = editorValue;\n    }\n    \
const row = this.range.from.row;\n    const col = this.range.from.col;\n    \
this.updateCommentMeta(row, col, {\n      [META_COMMENT_VALUE]: comment\n    \
});\n    this.hot.render();\n  }\n  /**\n   * Sets a comment for a specified \
cell.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} \
column Visual column index.\n   * @param {string} value Comment contents.\n   \
*/\n  setCommentAtCell(row, column, value) {\n    this.setRange({\n      \
from: this.hot._createCellCoords(row, column)\n    });\n    \
this.setComment(value);\n  }\n  /**\n   * Removes a comment from a cell \
according to previously set range (see {@link Comments#setRange}).\n   *\n   \
* @param {boolean} [forceRender=true] If set to `true`, the table will be \
re-rendered at the end of the operation.\n   */\n  removeComment() {\n    let \
forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] \
: true;\n    if (!this.range.from) {\n      throw new Error('Before using \
this method, first set cell range \
(hot.getPlugin(\"comment\").setRange())');\n    }\n    \
this.hot.setCellMeta(this.range.from.row, this.range.from.col, \
META_COMMENT);\n    if (forceRender) {\n      this.hot.render();\n    }\n    \
this.hide();\n  }\n  /**\n   * Removes a comment from a specified cell.\n   \
*\n   * @param {number} row Visual row index.\n   * @param {number} column \
Visual column index.\n   * @param {boolean} [forceRender=true] If `true`, the \
table will be re-rendered at the end of the operation.\n   */\n  \
removeCommentAtCell(row, column) {\n    let forceRender = arguments.length > \
2 && arguments[2] !== void 0 ? arguments[2] : true;\n    this.setRange({\n    \
  from: this.hot._createCellCoords(row, column)\n    });\n    \
this.removeComment(forceRender);\n  }\n  /**\n   * Gets comment from a cell \
according to previously set range (see {@link Comments#setRange}).\n   *\n   \
* @returns {string|undefined} Returns a content of the comment.\n   */\n  \
getComment() {\n    const row = this.range.from.row;\n    const column = \
this.range.from.col;\n    return this.getCommentMeta(row, column, \
META_COMMENT_VALUE);\n  }\n  /**\n   * Gets comment from a cell at the \
provided coordinates.\n   *\n   * @param {number} row Visual row index.\n   * \
@param {number} column Visual column index.\n   * @returns {string|undefined} \
Returns a content of the comment.\n   */\n  getCommentAtCell(row, column) {\n \
   return this.getCommentMeta(row, column, META_COMMENT_VALUE);\n  }\n  /**\n \
  * Shows the comment editor accordingly to the previously set range (see \
{@link Comments#setRange}).\n   *\n   * @returns {boolean} Returns `true` if \
comment editor was shown.\n   */\n  show() {\n    if (!this.range.from) {\n   \
   throw new Error('Before using this method, first set cell range \
(hot.getPlugin(\"comment\").setRange())');\n    }\n    const {\n      from: \
{\n        row,\n        col\n      }\n    } = this.range;\n    if (row < 0 \
|| row > this.hot.countSourceRows() - 1 || col < 0 || col > \
this.hot.countSourceCols() - 1) {\n      return false;\n    }\n    const meta \
= this.hot.getCellMeta(this.range.from.row, this.range.from.col);\n    \
this.editor.setValue(meta[META_COMMENT] ? \
meta[META_COMMENT][META_COMMENT_VALUE] : \"\");\n    this.editor.show();\n    \
this.refreshEditor(true);\n    return true;\n  }\n  /**\n   * Shows comment \
editor according to cell coordinates.\n   *\n   * @param {number} row Visual \
row index.\n   * @param {number} column Visual column index.\n   * @returns \
{boolean} Returns `true` if comment editor was shown.\n   */\n  \
showAtCell(row, column) {\n    this.setRange({\n      from: \
this.hot._createCellCoords(row, column)\n    });\n    return this.show();\n  \
}\n  /**\n   * Hides the comment editor.\n   */\n  hide() {\n    \
this.editor.hide();\n  }\n  /**\n   * Refreshes comment editor position and \
styling.\n   *\n   * @param {boolean} [force=false] If `true` then \
recalculation will be forced.\n   */\n  refreshEditor() {\n    var \
_renderableRow, _renderableColumn;\n    let force = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : false;\n    if (!force && \
(!this.range.from || !this.editor.isVisible())) {\n      return;\n    }\n    \
const {\n      rowIndexMapper,\n      columnIndexMapper\n    } = this.hot;\n  \
  const {\n      row: visualRow,\n      col: visualColumn\n    } = \
this.range.from;\n    let renderableRow = \
rowIndexMapper.getRenderableFromVisualIndex(visualRow);\n    let \
renderableColumn = \
columnIndexMapper.getRenderableFromVisualIndex(visualColumn);\n    const \
targetingPreviousRow = renderableRow === null;\n    \
this.editor.setPosition(0, 0);\n    if (renderableRow === null) {\n      \
renderableRow = \
rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHidde\
nIndex(visualRow, -1));\n    }\n    if (renderableColumn === null) {\n      \
renderableColumn = \
columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNo\
tHiddenIndex(visualColumn, -1));\n    }\n    const isBeforeRenderedRows = \
renderableRow === null;\n    const isBeforeRenderedColumns = renderableColumn \
=== null;\n    renderableRow = (_renderableRow = renderableRow) !== null && \
_renderableRow !== void 0 ? _renderableRow : 0;\n    renderableColumn = \
(_renderableColumn = renderableColumn) !== null && _renderableColumn !== void \
0 ? _renderableColumn : 0;\n    const {\n      rootWindow,\n      view: {\n   \
     _wt: wt\n      }\n    } = this.hot;\n    const {\n      wtTable\n    } = \
wt;\n    const TD = wt.getCell({\n      row: renderableRow,\n      col: \
renderableColumn\n    }, true);\n    const commentStyle = \
this.getCommentMeta(visualRow, visualColumn, META_STYLE);\n    if \
(commentStyle) {\n      this.editor.setSize(commentStyle.width, \
commentStyle.height);\n    } else {\n      this.editor.resetSize();\n    }\n  \
  const lastColWidth = isBeforeRenderedColumns ? 0 : \
wtTable.getStretchedColumnWidth(renderableColumn);\n    const lastRowHeight = \
targetingPreviousRow && !isBeforeRenderedRows ? outerHeight(TD) : 0;\n    \
const {\n      left: left2,\n      top: top2,\n      width: cellWidth,\n      \
height: cellHeight\n    } = TD.getBoundingClientRect();\n    const {\n      \
width: editorWidth,\n      height: editorHeight\n    } = \
this.editor.getSize();\n    const {\n      innerWidth: innerWidth2,\n      \
innerHeight: innerHeight2\n    } = this.hot.rootWindow;\n    const \
documentElement = this.hot.rootDocument.documentElement;\n    let x = left2 + \
rootWindow.scrollX + lastColWidth;\n    let y = top2 + rootWindow.scrollY + \
lastRowHeight;\n    if (this.hot.isRtl()) {\n      x -= editorWidth + \
lastColWidth;\n    }\n    if (this.hot.isLtr() && left2 + cellWidth + \
editorWidth > innerWidth2) {\n      x = left2 + rootWindow.scrollX - \
editorWidth - 1;\n    } else if (this.hot.isRtl() && x < \
-(documentElement.scrollWidth - documentElement.clientWidth)) {\n      x = \
left2 + rootWindow.scrollX + lastColWidth + 1;\n    }\n    if (top2 + \
editorHeight > innerHeight2) {\n      y -= editorHeight - cellHeight + 1;\n   \
 }\n    this.editor.setPosition(x, y);\n    \
this.editor.setReadOnlyState(this.getCommentMeta(visualRow, visualColumn, \
META_READONLY));\n  }\n  /**\n   * Checks if there is a comment for selected \
range.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  \
checkSelectionCommentsConsistency() {\n    const selected = \
this.hot.getSelectedRangeLast();\n    if (!selected) {\n      return false;\n \
   }\n    let hasComment = false;\n    const cell = \
selected.getTopStartCorner();\n    if (this.getCommentMeta(cell.row, \
cell.col, META_COMMENT_VALUE)) {\n      hasComment = true;\n    }\n    return \
hasComment;\n  }\n  /**\n   * Sets or update the comment-related cell meta.\n \
  *\n   * @param {number} row Visual row index.\n   * @param {number} column \
Visual column index.\n   * @param {object} metaObject Object defining all the \
comment-related meta information.\n   */\n  updateCommentMeta(row, column, \
metaObject) {\n    const oldComment = this.hot.getCellMeta(row, \
column)[META_COMMENT];\n    let newComment;\n    if (oldComment) {\n      \
newComment = deepClone(oldComment);\n      deepExtend(newComment, \
metaObject);\n    } else {\n      newComment = metaObject;\n    }\n    \
this.hot.setCellMeta(row, column, META_COMMENT, newComment);\n  }\n  /**\n   \
* Gets the comment related meta information.\n   *\n   * @param {number} row \
Visual row index.\n   * @param {number} column Visual column index.\n   * \
@param {string} property Cell meta property.\n   * @returns {Mixed}\n   */\n  \
getCommentMeta(row, column, property) {\n    const cellMeta = \
this.hot.getCellMeta(row, column);\n    if (!cellMeta[META_COMMENT]) {\n      \
return void 0;\n    }\n    return cellMeta[META_COMMENT][property];\n  }\n  \
/**\n   * `mousedown` event callback.\n   *\n   * @private\n   * @param \
{MouseEvent} event The `mousedown` event.\n   */\n  onMouseDown(event2) {\n   \
 if (!this.hot.view || !this.hot.view._wt) {\n      return;\n    }\n    if \
(!this.preventEditorAutoSwitch && !this.targetIsCommentTextArea(event2)) {\n  \
    const eventCell = closest(event2.target, \"TD\", \"TBODY\");\n      let \
coordinates = null;\n      if (eventCell) {\n        coordinates = \
this.hot.getCoords(eventCell);\n      }\n      if (!eventCell || \
this.range.from && coordinates && (this.range.from.row !== coordinates.row || \
this.range.from.col !== coordinates.col)) {\n        this.hide();\n      }\n  \
  }\n  }\n  /**\n   * `mouseover` event callback.\n   *\n   * @private\n   * \
@param {MouseEvent} event The `mouseover` event.\n   */\n  \
onMouseOver(event2) {\n    const priv = privatePool8.get(this);\n    const \
{\n      rootDocument\n    } = this.hot;\n    if \
(this.preventEditorAutoSwitch || this.editor.isFocused() || \
hasClass(event2.target, \"wtBorder\") || priv.cellBelowCursor === \
event2.target || !this.editor) {\n      return;\n    }\n    \
priv.cellBelowCursor = rootDocument.elementFromPoint(event2.clientX, \
event2.clientY);\n    if (this.targetIsCellWithComment(event2)) {\n      \
const range = this.hot._createCellRange(this.hot.getCoords(event2.target));\n \
     this.displaySwitch.show(range);\n    } else if (isChildOf(event2.target, \
rootDocument) && !this.targetIsCommentTextArea(event2)) {\n      \
this.displaySwitch.hide();\n    }\n  }\n  /**\n   * `mouseup` event \
callback.\n   *\n   * @private\n   */\n  onMouseUp() {\n    \
this.preventEditorAutoSwitch = false;\n  }\n  /**\n   * The `afterRenderer` \
hook callback.\n   *\n   * @private\n   * @param {HTMLTableCellElement} TD \
The rendered `TD` element.\n   * @param {object} cellProperties The rendered \
cell's property object.\n   */\n  onAfterRenderer(TD, cellProperties) {\n    \
if (cellProperties[META_COMMENT] && \
cellProperties[META_COMMENT][META_COMMENT_VALUE]) {\n      addClass(TD, \
cellProperties.commentedCellClassName);\n    }\n  }\n  /**\n   * `blur` event \
callback for the comment editor.\n   *\n   * @private\n   */\n  \
onEditorBlur() {\n    this.setComment();\n  }\n  /**\n   * `mousedown` hook. \
Along with `onEditorMouseUp` used to simulate the textarea resizing event.\n  \
 *\n   * @private\n   * @param {MouseEvent} event The `mousedown` event.\n   \
*/\n  onEditorMouseDown(event2) {\n    const priv = privatePool8.get(this);\n \
   priv.tempEditorDimensions = {\n      width: outerWidth(event2.target),\n   \
   height: outerHeight(event2.target)\n    };\n  }\n  /**\n   * `mouseup` \
hook. Along with `onEditorMouseDown` used to simulate the textarea resizing \
event.\n   *\n   * @private\n   * @param {MouseEvent} event The `mouseup` \
event.\n   */\n  onEditorMouseUp(event2) {\n    const priv = \
privatePool8.get(this);\n    const currentWidth = \
outerWidth(event2.target);\n    const currentHeight = \
outerHeight(event2.target);\n    if (currentWidth !== \
priv.tempEditorDimensions.width + 1 || currentHeight !== \
priv.tempEditorDimensions.height + 2) {\n      \
this.updateCommentMeta(this.range.from.row, this.range.from.col, {\n        \
[META_STYLE]: {\n          width: currentWidth,\n          height: \
currentHeight\n        }\n      });\n    }\n  }\n  /**\n   * Context Menu's \
\"Add comment\" callback. Results in showing the comment editor.\n   *\n   * \
@private\n   */\n  onContextMenuAddComment() {\n    const coords = \
this.hot.getSelectedRangeLast();\n    this.preventEditorAutoSwitch = true;\n  \
  this.displaySwitch.cancelHiding();\n    this.setRange({\n      from: \
coords.highlight\n    });\n    this.show();\n    this.hot.deselectCell();\n   \
 this.editor.focus();\n  }\n  /**\n   * Context Menu's \"remove comment\" \
callback.\n   *\n   * @private\n   */\n  onContextMenuRemoveComment() {\n    \
const coords = this.hot.getSelectedRangeLast();\n    \
this.preventEditorAutoSwitch = true;\n    coords.forAll((row, column) => {\n  \
    if (row >= 0 && column >= 0) {\n        this.removeCommentAtCell(row, \
column, false);\n      }\n    });\n    this.hot.render();\n  }\n  /**\n   * \
Context Menu's \"make comment read-only\" callback.\n   *\n   * @private\n   \
*/\n  onContextMenuMakeReadOnly() {\n    const coords = \
this.hot.getSelectedRangeLast();\n    this.preventEditorAutoSwitch = true;\n  \
  coords.forAll((row, column) => {\n      if (row >= 0 && column >= 0) {\n    \
    const currentState = !!this.getCommentMeta(row, column, META_READONLY);\n \
       this.updateCommentMeta(row, column, {\n          [META_READONLY]: \
!currentState\n        });\n      }\n    });\n  }\n  /**\n   * Add Comments \
plugin options to the Context Menu.\n   *\n   * @private\n   * @param \
{object} defaultOptions The menu options.\n   */\n  \
addToContextMenu(defaultOptions) {\n    const isThereAnyCellRendered = () => \
{\n      return this.hot.rowIndexMapper.getRenderableIndexesLength() > 0 && \
this.hot.columnIndexMapper.getRenderableIndexesLength() > 0;\n    };\n    \
defaultOptions.items.push({\n      name: \"---------\"\n    }, {\n      key: \
\"commentsAddEdit\",\n      name: () => {\n        if \
(this.checkSelectionCommentsConsistency()) {\n          return \
this.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_EDIT_COMMENT);\n        }\n    \
    return this.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_ADD_COMMENT);\n     \
 },\n      callback: () => this.onContextMenuAddComment(),\n      disabled: \
() => {\n        if (!isThereAnyCellRendered()) {\n          return true;\n   \
     }\n        return !(this.hot.getSelectedLast() && \
!this.hot.selection.isSelectedByCorner());\n      }\n    }, {\n      key: \
\"commentsRemove\",\n      name() {\n        return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COMMENT);\n      },\n      \
callback: () => this.onContextMenuRemoveComment(),\n      disabled: () => {\n \
       if (!isThereAnyCellRendered()) {\n          return true;\n        }\n  \
      return !(this.hot.getSelectedLast() && \
!this.hot.selection.isSelectedByCorner());\n      }\n    }, {\n      key: \
\"commentsReadOnly\",\n      name() {\n        let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY_COMMENT);\n        const \
hasProperty = checkSelectionConsistency(this.getSelectedRangeLast(), (row, \
col) => {\n          let readOnlyProperty = this.getCellMeta(row, \
col)[META_COMMENT];\n          if (readOnlyProperty) {\n            \
readOnlyProperty = readOnlyProperty[META_READONLY];\n          }\n          \
if (readOnlyProperty) {\n            return true;\n          }\n        });\n \
       if (hasProperty) {\n          label = markLabelAsSelected(label);\n    \
    }\n        return label;\n      },\n      callback: () => \
this.onContextMenuMakeReadOnly(),\n      disabled: () => {\n        if \
(!isThereAnyCellRendered()) {\n          return true;\n        }\n        \
return !(this.hot.getSelectedLast() && \
!this.hot.selection.isSelectedByCorner()) || \
!this.checkSelectionCommentsConsistency();\n      }\n    });\n  }\n  /**\n   \
* Get `displayDelay` setting of comment plugin.\n   *\n   * @private\n   * \
@returns {number|undefined}\n   */\n  getDisplayDelaySetting() {\n    const \
commentSetting = this.hot.getSettings()[PLUGIN_KEY9];\n    if \
(isObject(commentSetting)) {\n      return commentSetting.displayDelay;\n    \
}\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    \
if (this.editor) {\n      this.editor.destroy();\n    }\n    if \
(this.displaySwitch) {\n      this.displaySwitch.destroy();\n    }\n    \
super.destroy();\n  }\n};\n\n// \
node_modules/core-js/modules/es.array.unshift.js\nvar $5 = \
require_export();\nvar toObject3 = require_to_object();\nvar \
lengthOfArrayLike3 = require_length_of_array_like();\nvar setArrayLength2 = \
require_array_set_length();\nvar deletePropertyOrThrow = \
require_delete_property_or_throw();\nvar doesNotExceedSafeInteger2 = \
require_does_not_exceed_safe_integer();\nvar INCORRECT_RESULT = [].unshift(0) \
!== 1;\nvar properErrorOnNonWritableLength2 = function() {\n  try {\n    \
Object.defineProperty([], \"length\", { writable: false }).unshift();\n  } \
catch (error2) {\n    return error2 instanceof TypeError;\n  }\n};\nvar \
FORCED3 = INCORRECT_RESULT || !properErrorOnNonWritableLength2();\n$5({ \
target: \"Array\", proto: true, arity: 1, forced: FORCED3 }, {\n  // \
eslint-disable-next-line no-unused-vars -- required for `.length`\n  unshift: \
function unshift(item) {\n    var O = toObject3(this);\n    var len = \
lengthOfArrayLike3(O);\n    var argCount = arguments.length;\n    if \
(argCount) {\n      doesNotExceedSafeInteger2(len + argCount);\n      var k = \
len;\n      while (k--) {\n        var to = k + argCount;\n        if (k in \
O)\n          O[to] = O[k];\n        else\n          deletePropertyOrThrow(O, \
to);\n      }\n      for (var j = 0; j < argCount; j++) {\n        O[j] = \
arguments[j];\n      }\n    }\n    return setArrayLength2(O, len + \
argCount);\n  }\n});\n\n// \
node_modules/handsontable/plugins/contextMenu/commandExecutor.mjs\nvar \
CommandExecutor = class {\n  constructor(hotInstance) {\n    this.hot = \
hotInstance;\n    this.commands = {};\n    this.commonCallback = null;\n  }\n \
 /**\n   * Register command.\n   *\n   * @param {string} name Command name.\n \
  * @param {object} commandDescriptor Command descriptor object with \
properties like `key` (command id),\n   *                                   \
`callback` (task to execute), `name` (command name), `disabled` (command \
availability).\n   */\n  registerCommand(name, commandDescriptor) {\n    \
this.commands[name] = commandDescriptor;\n  }\n  /**\n   * Set common \
callback which will be trigger on every executed command.\n   *\n   * @param \
{Function} callback Function which will be fired on every command execute.\n  \
 */\n  setCommonCallback(callback) {\n    this.commonCallback = callback;\n  \
}\n  /**\n   * Execute command by its name.\n   *\n   * @param {string} \
commandName Command id.\n   * @param {*} params Arguments passed to command \
task.\n   */\n  execute(commandName) {\n    for (var _len = arguments.length, \
params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) \
{\n      params[_key - 1] = arguments[_key];\n    }\n    const commandSplit = \
commandName.split(\":\");\n    const commandNamePrimary = commandSplit[0];\n  \
  const subCommandName = commandSplit.length === 2 ? commandSplit[1] : \
null;\n    let command = this.commands[commandNamePrimary];\n    if \
(!command) {\n      throw new Error(`Menu command '${commandNamePrimary}' not \
exists.`);\n    }\n    if (subCommandName && command.submenu) {\n      \
command = findSubCommand(subCommandName, command.submenu.items);\n    }\n    \
if (command.disabled === true) {\n      return;\n    }\n    if (typeof \
command.disabled === \"function\" && command.disabled.call(this.hot) === \
true) {\n      return;\n    }\n    if (hasOwnProperty(command, \"submenu\")) \
{\n      return;\n    }\n    const callbacks = [];\n    if (typeof \
command.callback === \"function\") {\n      \
callbacks.push(command.callback);\n    }\n    if (typeof this.commonCallback \
=== \"function\") {\n      callbacks.push(this.commonCallback);\n    }\n    \
params.unshift(commandSplit.join(\":\"));\n    arrayEach(callbacks, \
(callback) => callback.apply(this.hot, params));\n  }\n};\nfunction \
findSubCommand(subCommandName, subCommands) {\n  let command;\n  \
arrayEach(subCommands, (cmd) => {\n    const cmds = cmd.key ? \
cmd.key.split(\":\") : null;\n    if (Array.isArray(cmds) && cmds[1] === \
subCommandName) {\n      command = cmd;\n      return false;\n    }\n  });\n  \
return command;\n}\nvar commandExecutor_default = CommandExecutor;\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/alignment.mjs\n\
var KEY2 = \"alignment\";\nfunction alignmentItem() {\n  return {\n    key: \
KEY2,\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT);\n    },\n    \
disabled() {\n      if (this.countRows() === 0 || this.countCols() === 0) {\n \
       return true;\n      }\n      return !(this.getSelectedRange() && \
!this.selection.isSelectedByCorner());\n    },\n    submenu: {\n      items: \
[{\n        key: `${KEY2}:left`,\n        name() {\n          let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);\n          const \
hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => \
{\n            const className = this.getCellMeta(row, col).className;\n      \
      if (className && className.indexOf(\"htLeft\") !== -1) {\n              \
return true;\n            }\n          });\n          if (hasClass2) {\n      \
      label = markLabelAsSelected(label);\n          }\n          return \
label;\n        },\n        callback() {\n          const selectedRange = \
this.getSelectedRange();\n          const stateBefore = \
getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, \
col).className);\n          const type = \"horizontal\";\n          const \
alignment = \"htLeft\";\n          this.runHooks(\"beforeCellAlignment\", \
stateBefore, selectedRange, type, alignment);\n          align(selectedRange, \
type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, \
value) => this.setCellMeta(row, col, key, value));\n          \
this.render();\n        },\n        disabled: false\n      }, {\n        key: \
`${KEY2}:center`,\n        name() {\n          let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);\n          \
const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, \
col) => {\n            const className = this.getCellMeta(row, \
col).className;\n            if (className && className.indexOf(\"htCenter\") \
!== -1) {\n              return true;\n            }\n          });\n         \
 if (hasClass2) {\n            label = markLabelAsSelected(label);\n          \
}\n          return label;\n        },\n        callback() {\n          const \
selectedRange = this.getSelectedRange();\n          const stateBefore = \
getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, \
col).className);\n          const type = \"horizontal\";\n          const \
alignment = \"htCenter\";\n          this.runHooks(\"beforeCellAlignment\", \
stateBefore, selectedRange, type, alignment);\n          align(selectedRange, \
type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, \
value) => this.setCellMeta(row, col, key, value));\n          \
this.render();\n        },\n        disabled: false\n      }, {\n        key: \
`${KEY2}:right`,\n        name() {\n          let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);\n          const \
hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => \
{\n            const className = this.getCellMeta(row, col).className;\n      \
      if (className && className.indexOf(\"htRight\") !== -1) {\n             \
 return true;\n            }\n          });\n          if (hasClass2) {\n     \
       label = markLabelAsSelected(label);\n          }\n          return \
label;\n        },\n        callback() {\n          const selectedRange = \
this.getSelectedRange();\n          const stateBefore = \
getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, \
col).className);\n          const type = \"horizontal\";\n          const \
alignment = \"htRight\";\n          this.runHooks(\"beforeCellAlignment\", \
stateBefore, selectedRange, type, alignment);\n          align(selectedRange, \
type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, \
value) => this.setCellMeta(row, col, key, value));\n          \
this.render();\n        },\n        disabled: false\n      }, {\n        key: \
`${KEY2}:justify`,\n        name() {\n          let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);\n          \
const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, \
col) => {\n            const className = this.getCellMeta(row, \
col).className;\n            if (className && \
className.indexOf(\"htJustify\") !== -1) {\n              return true;\n      \
      }\n          });\n          if (hasClass2) {\n            label = \
markLabelAsSelected(label);\n          }\n          return label;\n        \
},\n        callback() {\n          const selectedRange = \
this.getSelectedRange();\n          const stateBefore = \
getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, \
col).className);\n          const type = \"horizontal\";\n          const \
alignment = \"htJustify\";\n          this.runHooks(\"beforeCellAlignment\", \
stateBefore, selectedRange, type, alignment);\n          align(selectedRange, \
type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, \
value) => this.setCellMeta(row, col, key, value));\n          \
this.render();\n        },\n        disabled: false\n      }, {\n        \
name: KEY\n      }, {\n        key: `${KEY2}:top`,\n        name() {\n        \
  let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_TOP);\n    \
      const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), \
(row, col) => {\n            const className = this.getCellMeta(row, \
col).className;\n            if (className && className.indexOf(\"htTop\") \
!== -1) {\n              return true;\n            }\n          });\n         \
 if (hasClass2) {\n            label = markLabelAsSelected(label);\n          \
}\n          return label;\n        },\n        callback() {\n          const \
selectedRange = this.getSelectedRange();\n          const stateBefore = \
getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, \
col).className);\n          const type = \"vertical\";\n          const \
alignment = \"htTop\";\n          this.runHooks(\"beforeCellAlignment\", \
stateBefore, selectedRange, type, alignment);\n          align(selectedRange, \
type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, \
value) => this.setCellMeta(row, col, key, value));\n          \
this.render();\n        },\n        disabled: false\n      }, {\n        key: \
`${KEY2}:middle`,\n        name() {\n          let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);\n          \
const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, \
col) => {\n            const className = this.getCellMeta(row, \
col).className;\n            if (className && className.indexOf(\"htMiddle\") \
!== -1) {\n              return true;\n            }\n          });\n         \
 if (hasClass2) {\n            label = markLabelAsSelected(label);\n          \
}\n          return label;\n        },\n        callback() {\n          const \
selectedRange = this.getSelectedRange();\n          const stateBefore = \
getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, \
col).className);\n          const type = \"vertical\";\n          const \
alignment = \"htMiddle\";\n          this.runHooks(\"beforeCellAlignment\", \
stateBefore, selectedRange, type, alignment);\n          align(selectedRange, \
type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, \
value) => this.setCellMeta(row, col, key, value));\n          \
this.render();\n        },\n        disabled: false\n      }, {\n        key: \
`${KEY2}:bottom`,\n        name() {\n          let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);\n          \
const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, \
col) => {\n            const className = this.getCellMeta(row, \
col).className;\n            if (className && className.indexOf(\"htBottom\") \
!== -1) {\n              return true;\n            }\n          });\n         \
 if (hasClass2) {\n            label = markLabelAsSelected(label);\n          \
}\n          return label;\n        },\n        callback() {\n          const \
selectedRange = this.getSelectedRange();\n          const stateBefore = \
getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, \
col).className);\n          const type = \"vertical\";\n          const \
alignment = \"htBottom\";\n          this.runHooks(\"beforeCellAlignment\", \
stateBefore, selectedRange, type, alignment);\n          align(selectedRange, \
type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, \
value) => this.setCellMeta(row, col, key, value));\n          \
this.render();\n        },\n        disabled: false\n      }]\n    }\n  \
};\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/clearColumn.mjs\
\nvar KEY3 = \"clear_column\";\nfunction clearColumnItem() {\n  return {\n    \
key: KEY3,\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CLEAR_COLUMN);\n    },\n    \
callback(key, selection) {\n      const startColumn = \
selection[0].start.col;\n      const endColumn = selection[0].end.col;\n      \
if (this.countRows()) {\n        this.populateFromArray(0, startColumn, \
[[null]], Math.max(selection[0].start.row, selection[0].end.row), endColumn, \
\"ContextMenu.clearColumn\");\n      }\n    },\n    disabled() {\n      const \
selected = getValidSelection(this);\n      if (!selected) {\n        return \
true;\n      }\n      return !this.selection.isSelectedByColumnHeader();\n    \
}\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/columnLeft.mjs\
\nvar KEY4 = \"col_left\";\nfunction columnLeftItem() {\n  return {\n    key: \
KEY4,\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_LEFT);\n    },\n    \
callback() {\n      const latestSelection = \
this.getSelectedRangeLast().getTopLeftCorner();\n      const alterAction = \
this.isRtl() ? \"insert_col_end\" : \"insert_col_start\";\n      \
this.alter(alterAction, latestSelection.col, 1, \
\"ContextMenu.columnLeft\");\n    },\n    disabled() {\n      if \
(!this.isColumnModificationAllowed()) {\n        return true;\n      }\n      \
const selected = getValidSelection(this);\n      if (!selected) {\n        \
return true;\n      }\n      if (this.selection.isSelectedByCorner()) {\n     \
   const totalColumns = this.countCols();\n        return totalColumns === \
0;\n      }\n      return this.selection.isSelectedByRowHeader() || \
this.countCols() >= this.getSettings().maxCols;\n    },\n    hidden() {\n     \
 return !this.getSettings().allowInsertColumn;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/columnRight.mjs\
\nvar KEY5 = \"col_right\";\nfunction columnRightItem() {\n  return {\n    \
key: KEY5,\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_RIGHT);\n    },\n    \
callback() {\n      const latestSelection = \
this.getSelectedRangeLast().getTopRightCorner();\n      const alterAction = \
this.isRtl() ? \"insert_col_start\" : \"insert_col_end\";\n      \
this.alter(alterAction, latestSelection.col, 1, \
\"ContextMenu.columnRight\");\n    },\n    disabled() {\n      if \
(!this.isColumnModificationAllowed()) {\n        return true;\n      }\n      \
const selected = getValidSelection(this);\n      if (!selected) {\n        \
return true;\n      }\n      if (this.selection.isSelectedByCorner()) {\n     \
   return false;\n      }\n      return \
this.selection.isSelectedByRowHeader() || this.countCols() >= \
this.getSettings().maxCols;\n    },\n    hidden() {\n      return \
!this.getSettings().allowInsertColumn;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/readOnly.mjs\nv\
ar KEY6 = \"make_read_only\";\nfunction readOnlyItem() {\n  return {\n    \
key: KEY6,\n    name() {\n      let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY);\n      const \
atLeastOneReadOnly = checkSelectionConsistency(this.getSelectedRange(), (row, \
col) => this.getCellMeta(row, col).readOnly);\n      if (atLeastOneReadOnly) \
{\n        label = markLabelAsSelected(label);\n      }\n      return \
label;\n    },\n    callback() {\n      const ranges = \
this.getSelectedRange();\n      const atLeastOneReadOnly = \
checkSelectionConsistency(ranges, (row, col) => this.getCellMeta(row, \
col).readOnly);\n      arrayEach(ranges, (range) => {\n        \
range.forAll((row, col) => {\n          if (row >= 0 && col >= 0) {\n         \
   this.setCellMeta(row, col, \"readOnly\", !atLeastOneReadOnly);\n          \
}\n        });\n      });\n      this.render();\n    },\n    disabled() {\n   \
   if (this.selection.isSelectedByCorner()) {\n        return true;\n      \
}\n      if (this.countRows() === 0 || this.countCols() === 0) {\n        \
return true;\n      }\n      if (!this.getSelectedRange() || \
this.getSelectedRange().length === 0) {\n        return true;\n      }\n      \
return false;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/redo.mjs\nvar \
KEY7 = \"redo\";\nfunction redoItem() {\n  return {\n    key: KEY7,\n    \
name() {\n      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REDO);\n    \
},\n    callback() {\n      this.redo();\n    },\n    hidden() {\n      const \
undoRedo = this.getPlugin(\"undoRedo\");\n      return !undoRedo || \
!undoRedo.isEnabled();\n    },\n    disabled() {\n      return \
!this.getPlugin(\"undoRedo\").isRedoAvailable();\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/removeColumn.mj\
s\nvar KEY8 = \"remove_col\";\nfunction removeColumnItem() {\n  return {\n    \
key: KEY8,\n    name() {\n      const selection = this.getSelected();\n      \
let pluralForm = 0;\n      if (selection) {\n        if (selection.length > \
1) {\n          pluralForm = 1;\n        } else {\n          const [, \
fromColumn, , toColumn] = selection[0];\n          if (fromColumn - toColumn \
!== 0) {\n            pluralForm = 1;\n          }\n        }\n      }\n      \
return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COLUMN, \
pluralForm);\n    },\n    callback() {\n      this.alter(\"remove_col\", \
transformSelectionToColumnDistance(this.getSelected()), null, \
\"ContextMenu.removeColumn\");\n    },\n    disabled() {\n      if \
(!this.isColumnModificationAllowed()) {\n        return true;\n      }\n      \
const selected = getValidSelection(this);\n      if (!selected) {\n        \
return true;\n      }\n      const totalColumns = this.countCols();\n      if \
(this.selection.isSelectedByCorner()) {\n        return totalColumns === 0;\n \
     }\n      return this.selection.isSelectedByRowHeader() || totalColumns \
=== 0;\n    },\n    hidden() {\n      return \
!this.getSettings().allowRemoveColumn;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/removeRow.mjs\n\
var KEY9 = \"remove_row\";\nfunction removeRowItem() {\n  return {\n    key: \
KEY9,\n    name() {\n      const selection = this.getSelected();\n      let \
pluralForm = 0;\n      if (selection) {\n        if (selection.length > 1) \
{\n          pluralForm = 1;\n        } else {\n          const [fromRow, , \
toRow] = selection[0];\n          if (fromRow - toRow !== 0) {\n            \
pluralForm = 1;\n          }\n        }\n      }\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_ROW, pluralForm);\n    },\n \
   callback() {\n      this.alter(\"remove_row\", \
transformSelectionToRowDistance(this.getSelected()), 1, \
\"ContextMenu.removeRow\");\n    },\n    disabled() {\n      const selected = \
getValidSelection(this);\n      if (!selected) {\n        return true;\n      \
}\n      const totalRows = this.countRows();\n      if \
(this.selection.isSelectedByCorner()) {\n        return totalRows === 0;\n    \
  }\n      return this.selection.isSelectedByColumnHeader() || totalRows === \
0;\n    },\n    hidden() {\n      return \
!this.getSettings().allowRemoveRow;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/rowAbove.mjs\nv\
ar KEY10 = \"row_above\";\nfunction rowAboveItem() {\n  return {\n    key: \
KEY10,\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_ABOVE);\n    },\n    \
callback() {\n      const latestSelection = \
this.getSelectedRangeLast().getTopLeftCorner();\n      \
this.alter(\"insert_row_above\", latestSelection.row, 1, \
\"ContextMenu.rowAbove\");\n    },\n    disabled() {\n      const selected = \
getValidSelection(this);\n      if (!selected) {\n        return true;\n      \
}\n      if (this.selection.isSelectedByCorner()) {\n        const totalRows \
= this.countRows();\n        return totalRows === 0;\n      }\n      return \
this.selection.isSelectedByColumnHeader() || this.countRows() >= \
this.getSettings().maxRows;\n    },\n    hidden() {\n      return \
!this.getSettings().allowInsertRow;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/rowBelow.mjs\nv\
ar KEY11 = \"row_below\";\nfunction rowBelowItem() {\n  return {\n    key: \
KEY11,\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_BELOW);\n    },\n    \
callback() {\n      const latestSelection = \
this.getSelectedRangeLast().getBottomRightCorner();\n      \
this.alter(\"insert_row_below\", latestSelection.row, 1, \
\"ContextMenu.rowBelow\");\n    },\n    disabled() {\n      const selected = \
getValidSelection(this);\n      if (!selected) {\n        return true;\n      \
}\n      if (this.selection.isSelectedByCorner()) {\n        return false;\n  \
    }\n      return this.selection.isSelectedByColumnHeader() || \
this.countRows() >= this.getSettings().maxRows;\n    },\n    hidden() {\n     \
 return !this.getSettings().allowInsertRow;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/noItems.mjs\nva\
r KEY12 = \"no_items\";\nfunction noItemsItem() {\n  return {\n    key: \
KEY12,\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NO_ITEMS);\n    },\n    disabled: \
true,\n    isCommand: false\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems/undo.mjs\nvar \
KEY13 = \"undo\";\nfunction undoItem() {\n  return {\n    key: KEY13,\n    \
name() {\n      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNDO);\n    \
},\n    callback() {\n      this.undo();\n    },\n    hidden() {\n      const \
undoRedo = this.getPlugin(\"undoRedo\");\n      return !undoRedo || \
!undoRedo.isEnabled();\n    },\n    disabled() {\n      return \
!this.getPlugin(\"undoRedo\").isUndoAvailable();\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/predefinedItems.mjs\nvar ITEMS \
= [KEY10, KEY11, KEY4, KEY5, KEY3, KEY9, KEY8, KEY13, KEY7, KEY6, KEY2, KEY, \
KEY12];\nvar _predefinedItems = {\n  [KEY]: separatorItem,\n  [KEY12]: \
noItemsItem,\n  [KEY10]: rowAboveItem,\n  [KEY11]: rowBelowItem,\n  [KEY4]: \
columnLeftItem,\n  [KEY5]: columnRightItem,\n  [KEY3]: clearColumnItem,\n  \
[KEY9]: removeRowItem,\n  [KEY8]: removeColumnItem,\n  [KEY13]: undoItem,\n  \
[KEY7]: redoItem,\n  [KEY6]: readOnlyItem,\n  [KEY2]: \
alignmentItem\n};\nfunction predefinedItems() {\n  const items = {};\n  \
objectEach(_predefinedItems, (itemFactory, key) => {\n    items[key] = \
itemFactory();\n  });\n  return items;\n}\n\n// \
node_modules/handsontable/plugins/contextMenu/itemsFactory.mjs\nvar \
ItemsFactory = class {\n  constructor(hotInstance) {\n    let orderPattern = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    \
this.hot = hotInstance;\n    this.predefinedItems = predefinedItems();\n    \
this.defaultOrderPattern = orderPattern;\n  }\n  /**\n   * Set predefined \
items.\n   *\n   * @param {Array} predefinedItemsCollection Array of \
predefined items.\n   */\n  setPredefinedItems(predefinedItemsCollection) {\n \
   const items = {};\n    this.defaultOrderPattern.length = 0;\n    \
objectEach(predefinedItemsCollection, (value, key) => {\n      let \
menuItemKey = \"\";\n      if (value.name === KEY) {\n        items[KEY] = \
value;\n        menuItemKey = KEY;\n      } else if (isNaN(parseInt(key, \
10))) {\n        value.key = value.key === void 0 ? key : value.key;\n        \
items[key] = value;\n        menuItemKey = value.key;\n      } else {\n       \
 items[value.key] = value;\n        menuItemKey = value.key;\n      }\n      \
this.defaultOrderPattern.push(menuItemKey);\n    });\n    \
this.predefinedItems = items;\n  }\n  /**\n   * Get all menu items based on \
pattern.\n   *\n   * @param {Array|object|boolean} pattern Pattern which you \
can define by displaying menu items order. If `true` default\n   *            \
                           pattern will be used.\n   * @returns {Array}\n   \
*/\n  getItems() {\n    let pattern = arguments.length > 0 && arguments[0] \
!== void 0 ? arguments[0] : null;\n    return getItems(pattern, \
this.defaultOrderPattern, this.predefinedItems);\n  }\n};\nfunction \
getItems() {\n  let itemsPattern = arguments.length > 0 && arguments[0] !== \
void 0 ? arguments[0] : null;\n  let defaultPattern = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : [];\n  let items = arguments.length \
> 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  const result = [];\n  \
let pattern = itemsPattern;\n  if (pattern && pattern.items) {\n    pattern = \
pattern.items;\n  } else if (!Array.isArray(pattern)) {\n    pattern = \
defaultPattern;\n  }\n  if (isObject(pattern)) {\n    objectEach(pattern, \
(value, key) => {\n      let item = items[typeof value === \"string\" ? value \
: key];\n      if (!item) {\n        item = value;\n      }\n      if \
(isObject(value)) {\n        extend(item, value);\n      } else if (typeof \
item === \"string\") {\n        item = {\n          name: item\n        };\n  \
    }\n      if (item.key === void 0) {\n        item.key = key;\n      }\n   \
   result.push(item);\n    });\n  } else {\n    arrayEach(pattern, (name, \
key) => {\n      let item = items[name];\n      if (!item && \
ITEMS.indexOf(name) >= 0) {\n        return;\n      }\n      if (!item) {\n   \
     item = {\n          name,\n          key: `${key}`\n        };\n      \
}\n      if (isObject(name)) {\n        extend(item, name);\n      }\n      \
if (item.key === void 0) {\n        item.key = key;\n      }\n      \
result.push(item);\n    });\n  }\n  return result;\n}\nvar \
itemsFactory_default = ItemsFactory;\n\n// \
node_modules/handsontable/plugins/contextMenu/cursor.mjs\nvar Cursor = class \
{\n  constructor(object, rootWindow) {\n    const windowScrollTop = \
getWindowScrollTop(rootWindow);\n    const windowScrollLeft = \
getWindowScrollLeft(rootWindow);\n    let top2;\n    let topRelative;\n    \
let left2;\n    let leftRelative;\n    let cellHeight;\n    let cellWidth;\n  \
  this.rootWindow = rootWindow;\n    this.type = \
this.getSourceType(object);\n    if (this.type === \"literal\") {\n      top2 \
= parseInt(object.top, 10);\n      left2 = parseInt(object.left, 10);\n      \
cellHeight = object.height || 0;\n      cellWidth = object.width || 0;\n      \
topRelative = top2;\n      leftRelative = left2;\n      top2 += \
windowScrollTop;\n      left2 += windowScrollLeft;\n    } else if (this.type \
=== \"event\") {\n      top2 = parseInt(object.pageY, 10);\n      left2 = \
parseInt(object.pageX, 10);\n      cellHeight = object.target.clientHeight;\n \
     cellWidth = object.target.clientWidth;\n      topRelative = top2 - \
windowScrollTop;\n      leftRelative = left2 - windowScrollLeft;\n    }\n    \
this.top = top2;\n    this.topRelative = topRelative;\n    this.left = \
left2;\n    this.leftRelative = leftRelative;\n    this.scrollTop = \
windowScrollTop;\n    this.scrollLeft = windowScrollLeft;\n    \
this.cellHeight = cellHeight;\n    this.cellWidth = cellWidth;\n  }\n  /**\n  \
 * Get source type name.\n   *\n   * @param {*} object Event or Object with \
coordinates.\n   * @returns {string} Returns one of this values: `'literal'`, \
`'event'`.\n   */\n  getSourceType(object) {\n    let type = \"literal\";\n   \
 if (object instanceof Event) {\n      type = \"event\";\n    }\n    return \
type;\n  }\n  /**\n   * Checks if element can be placed above the cursor.\n   \
*\n   * @param {HTMLElement} element Element to check if it's size will fit \
above the cursor.\n   * @returns {boolean}\n   */\n  fitsAbove(element) {\n   \
 return this.topRelative >= element.offsetHeight;\n  }\n  /**\n   * Checks if \
element can be placed below the cursor.\n   *\n   * @param {HTMLElement} \
element Element to check if it's size will fit below the cursor.\n   * @param \
{number} [viewportHeight] The viewport height.\n   * @returns {boolean}\n   \
*/\n  fitsBelow(element) {\n    let viewportHeight = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerHeight;\n    \
return this.topRelative + element.offsetHeight <= viewportHeight;\n  }\n  \
/**\n   * Checks if element can be placed on the right of the cursor.\n   *\n \
  * @param {HTMLElement} element Element to check if it's size will fit on \
the right of the cursor.\n   * @param {number} [viewportWidth] The viewport \
width.\n   * @returns {boolean}\n   */\n  fitsOnRight(element) {\n    let \
viewportWidth = arguments.length > 1 && arguments[1] !== void 0 ? \
arguments[1] : this.rootWindow.innerWidth;\n    return this.leftRelative + \
this.cellWidth + element.offsetWidth <= viewportWidth;\n  }\n  /**\n   * \
Checks if element can be placed on the left on the cursor.\n   *\n   * @param \
{HTMLElement} element Element to check if it's size will fit on the left of \
the cursor.\n   * @returns {boolean}\n   */\n  fitsOnLeft(element) {\n    \
return this.leftRelative >= element.offsetWidth;\n  }\n};\nvar cursor_default \
= Cursor;\n\n// node_modules/handsontable/plugins/contextMenu/menu.mjs\nvar \
MIN_WIDTH = 215;\nvar SHORTCUTS_CONTEXT = \"menu\";\nvar SHORTCUTS_GROUP6 = \
SHORTCUTS_CONTEXT;\nvar Menu = class _Menu {\n  /**\n   * @param {Core} \
hotInstance Handsontable instance.\n   * @param {MenuOptions} [options] Menu \
options.\n   */\n  constructor(hotInstance, options) {\n    this.hot = \
hotInstance;\n    this.options = options || {\n      parent: null,\n      \
name: null,\n      className: \"\",\n      keepInViewport: true,\n      \
standalone: false,\n      minWidth: MIN_WIDTH,\n      container: \
this.hot.rootDocument.documentElement\n    };\n    this.eventManager = new \
eventManager_default(this);\n    this.container = \
this.createContainer(this.options.name);\n    this.hotMenu = null;\n    \
this.hotSubMenus = {};\n    this.parentMenu = this.options.parent || null;\n  \
  this.menuItems = null;\n    this.origOutsideClickDeselects = null;\n    \
this.keyEvent = false;\n    this.offset = {\n      above: 0,\n      below: \
0,\n      left: 0,\n      right: 0\n    };\n    this._afterScrollCallback = \
null;\n    this.registerEvents();\n  }\n  /**\n   * Register event \
listeners.\n   *\n   * @private\n   */\n  registerEvents() {\n    let frame = \
this.hot.rootWindow;\n    while (frame) {\n      \
this.eventManager.addEventListener(frame.document, \"mousedown\", (event2) => \
this.onDocumentMouseDown(event2));\n      \
this.eventManager.addEventListener(frame.document, \"contextmenu\", (event2) \
=> this.onDocumentContextMenu(event2));\n      frame = \
getParentWindow(frame);\n    }\n  }\n  /**\n   * Set array of objects which \
defines menu items.\n   *\n   * @param {Array} menuItems Menu items to \
display.\n   */\n  setMenuItems(menuItems) {\n    this.menuItems = \
menuItems;\n  }\n  /**\n   * Returns currently selected menu item. Returns \
`null` if no item was selected.\n   *\n   * @returns {object|null}\n   */\n  \
getSelectedItem() {\n    return this.hasSelectedItem() ? \
this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelectedLast()[0]) : null;\n  \
}\n  /**\n   * Checks if the menu has selected (highlighted) any item from \
the menu list.\n   *\n   * @returns {boolean}\n   */\n  hasSelectedItem() {\n \
   return Array.isArray(this.hotMenu.getSelectedLast());\n  }\n  /**\n   * \
Set offset menu position for specified area (`above`, `below`, `left` or \
`right`).\n   *\n   * @param {string} area Specified area name (`above`, \
`below`, `left` or `right`).\n   * @param {number} offset Offset value.\n   \
*/\n  setOffset(area) {\n    let offset3 = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : 0;\n    this.offset[area] = \
offset3;\n  }\n  /**\n   * Check if menu is using as sub-menu.\n   *\n   * \
@returns {boolean}\n   */\n  isSubMenu() {\n    return this.parentMenu !== \
null;\n  }\n  /**\n   * Open menu.\n   *\n   * @fires \
Hooks#beforeContextMenuShow\n   * @fires Hooks#afterContextMenuShow\n   */\n  \
open() {\n    var _this = this;\n    this.runLocalHooks(\"beforeOpen\");\n    \
this.container.removeAttribute(\"style\");\n    this.container.style.display \
= \"block\";\n    const delayedOpenSubMenu = debounce((row) => \
this.openSubMenu(row), 300);\n    const minWidthOfMenu = \
this.options.minWidth || MIN_WIDTH;\n    let noItemsDefined = false;\n    let \
filteredItems = arrayFilter(this.menuItems, (item) => {\n      if (item.key \
=== KEY12) {\n        noItemsDefined = true;\n      }\n      return \
isItemHidden(item, this.hot);\n    });\n    if (filteredItems.length < 1 && \
!noItemsDefined) {\n      filteredItems.push(predefinedItems()[KEY12]);\n    \
} else if (filteredItems.length === 0) {\n      return;\n    }\n    \
filteredItems = filterSeparators(filteredItems, KEY);\n    let \
shouldAutoCloseMenu = false;\n    const settings = {\n      data: \
filteredItems,\n      colHeaders: false,\n      autoColumnSize: true,\n      \
autoWrapRow: false,\n      modifyColWidth(width) {\n        if \
(isDefined(width) && width < minWidthOfMenu) {\n          return \
minWidthOfMenu;\n        }\n        return width;\n      },\n      \
autoRowSize: false,\n      readOnly: true,\n      editor: false,\n      \
copyPaste: false,\n      maxCols: 1,\n      columns: [{\n        data: \
\"name\",\n        renderer: (hot2, TD, row, col, prop, value) => \
this.menuItemRenderer(hot2, TD, row, col, prop, value)\n      }],\n      \
renderAllRows: true,\n      fragmentSelection: false,\n      \
outsideClickDeselects: false,\n      disableVisualSelection: \"area\",\n      \
layoutDirection: this.hot.isRtl() ? \"rtl\" : \"ltr\",\n      \
afterOnCellMouseOver: (event2, coords) => {\n        if \
(this.isAllSubMenusClosed()) {\n          delayedOpenSubMenu(coords.row);\n   \
     } else {\n          this.openSubMenu(coords.row);\n        }\n      },\n \
     rowHeights: (row) => filteredItems[row].name === KEY ? 1 : 23,\n      \
afterOnCellContextMenu: (event2) => {\n        event2.preventDefault();\n     \
   if (isWindowsOS() && shouldAutoCloseMenu && this.hasSelectedItem()) {\n    \
      this.close(true);\n        }\n      },\n      beforeOnCellMouseUp: \
(event2) => {\n        if (this.hasSelectedItem()) {\n          \
shouldAutoCloseMenu = !this.isCommandPassive(this.getSelectedItem());\n       \
   this.executeCommand(event2);\n        }\n      },\n      \
afterOnCellMouseUp: (event2) => {\n        if ((!isWindowsOS() || \
!isRightClick(event2)) && shouldAutoCloseMenu && this.hasSelectedItem()) {\n  \
        if (isMobileBrowser() || isIpadOS()) {\n            setTimeout(() => \
this.close(true), 325);\n          } else {\n            this.close(true);\n  \
        }\n        }\n      },\n      afterUnlisten: () => {\n        if \
(!this.hasSelectedItem() && this.isOpened()) {\n          \
this.hotMenu.listen();\n        }\n      }\n    };\n    \
this.origOutsideClickDeselects = \
this.hot.getSettings().outsideClickDeselects;\n    \
this.hot.getSettings().outsideClickDeselects = false;\n    this.hotMenu = new \
Core(this.container, settings);\n    this.hotMenu.addHook(\"afterInit\", () \
=> this.onAfterInit());\n    this.hotMenu.addHook(\"afterSelection\", \
function() {\n      return _this.onAfterSelection(...arguments);\n    });\n   \
 this.hotMenu.init();\n    this.hotMenu.listen();\n    const shortcutManager \
= this.hotMenu.getShortcutManager();\n    const menuContext = \
shortcutManager.addContext(SHORTCUTS_GROUP6);\n    const config = {\n      \
group: SHORTCUTS_CONTEXT\n    };\n    const menuContextConfig = {\n      \
...config,\n      runOnlyIf: (event2) => isInput(event2.target) === false || \
this.container.contains(event2.target) === false\n    };\n    \
shortcutManager.setActiveContextName(\"menu\");\n    \
menuContext.addShortcuts([{\n      keys: [[\"Escape\"]],\n      callback: () \
=> {\n        this.keyEvent = true;\n        this.close();\n        \
this.keyEvent = false;\n      }\n    }, {\n      keys: [[\"ArrowDown\"]],\n   \
   callback: () => {\n        const selection = \
this.hotMenu.getSelectedLast();\n        this.keyEvent = true;\n        if \
(selection) {\n          this.selectNextCell(selection[0], selection[1]);\n   \
     } else {\n          this.selectFirstCell();\n        }\n        \
this.keyEvent = false;\n      }\n    }, {\n      keys: [[\"ArrowUp\"]],\n     \
 callback: () => {\n        const selection = \
this.hotMenu.getSelectedLast();\n        this.keyEvent = true;\n        if \
(selection) {\n          this.selectPrevCell(selection[0], selection[1]);\n   \
     } else {\n          this.selectLastCell();\n        }\n        \
this.keyEvent = false;\n      }\n    }, {\n      keys: [[\"ArrowRight\"]],\n  \
    callback: () => {\n        const selection = \
this.hotMenu.getSelectedLast();\n        this.keyEvent = true;\n        if \
(selection) {\n          const menu = this.openSubMenu(selection[0]);\n       \
   if (menu) {\n            menu.selectFirstCell();\n          }\n        }\n \
       this.keyEvent = false;\n      }\n    }, {\n      keys: \
[[\"ArrowLeft\"]],\n      callback: () => {\n        const selection = \
this.hotMenu.getSelectedLast();\n        this.keyEvent = true;\n        if \
(selection && this.isSubMenu()) {\n          this.close();\n          if \
(this.parentMenu) {\n            this.parentMenu.hotMenu.listen();\n          \
}\n        }\n        this.keyEvent = false;\n      }\n    }, {\n      keys: \
[[\"Enter\"]],\n      callback: (event2) => {\n        const selection = \
this.hotMenu.getSelectedLast();\n        this.keyEvent = true;\n        if \
(!this.hotMenu.getSourceDataAtRow(selection[0]).submenu) {\n          \
this.executeCommand(event2);\n          this.close(true);\n        }\n        \
this.keyEvent = false;\n      }\n    }, {\n      keys: [[\"PageUp\"]],\n      \
callback: () => {\n        const selection = \
this.hotMenu.getSelectedLast();\n        this.keyEvent = true;\n        if \
(selection) {\n          \
this.hotMenu.selection.transformStart(-this.hotMenu.countVisibleRows(), 0);\n \
       } else {\n          this.selectFirstCell();\n        }\n        \
this.keyEvent = false;\n      }\n    }, {\n      keys: [[\"PageDown\"]],\n    \
  callback: () => {\n        const selection = \
this.hotMenu.getSelectedLast();\n        this.keyEvent = true;\n        if \
(selection) {\n          \
this.hotMenu.selection.transformStart(this.hotMenu.countVisibleRows(), 0);\n  \
      } else {\n          this.selectLastCell();\n        }\n        \
this.keyEvent = false;\n      }\n    }], menuContextConfig);\n    \
this.blockMainTableCallbacks();\n    this.runLocalHooks(\"afterOpen\");\n  \
}\n  /**\n   * Close menu.\n   *\n   * @param {boolean} [closeParent=false] \
If `true` try to close parent menu if exists.\n   */\n  close() {\n    let \
closeParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] \
: false;\n    if (!this.isOpened()) {\n      return;\n    }\n    if \
(closeParent && this.parentMenu) {\n      this.parentMenu.close();\n    } \
else {\n      this.closeAllSubMenus();\n      this.container.style.display = \
\"none\";\n      this.releaseMainTableCallbacks();\n      \
this.hotMenu.destroy();\n      this.hotMenu = null;\n      \
this.hot.getSettings().outsideClickDeselects = \
this.origOutsideClickDeselects;\n      this.runLocalHooks(\"afterClose\");\n  \
    if (this.parentMenu) {\n        this.parentMenu.hotMenu.listen();\n      \
}\n    }\n  }\n  /**\n   * Open sub menu at the provided row index.\n   *\n   \
* @param {number} row Row index.\n   * @returns {Menu|boolean} Returns \
created menu or `false` if no one menu was created.\n   */\n  \
openSubMenu(row) {\n    if (!this.hotMenu) {\n      return false;\n    }\n    \
const cell = this.hotMenu.getCell(row, 0);\n    this.closeAllSubMenus();\n    \
if (!cell || !hasSubMenu(cell)) {\n      return false;\n    }\n    const \
dataItem = this.hotMenu.getSourceDataAtRow(row);\n    const subMenu = new \
_Menu(this.hot, {\n      parent: this,\n      name: dataItem.name,\n      \
className: this.options.className,\n      keepInViewport: true,\n      \
container: this.options.container\n    });\n    \
subMenu.setMenuItems(dataItem.submenu.items);\n    subMenu.open();\n    \
subMenu.setPosition(cell.getBoundingClientRect());\n    \
this.hotSubMenus[dataItem.key] = subMenu;\n    return subMenu;\n  }\n  /**\n  \
 * Close sub menu at row index.\n   *\n   * @param {number} row Row index.\n  \
 */\n  closeSubMenu(row) {\n    const dataItem = \
this.hotMenu.getSourceDataAtRow(row);\n    const menus = \
this.hotSubMenus[dataItem.key];\n    if (menus) {\n      menus.destroy();\n   \
   delete this.hotSubMenus[dataItem.key];\n    }\n  }\n  /**\n   * Close all \
opened sub menus.\n   */\n  closeAllSubMenus() {\n    \
arrayEach(this.hotMenu.getData(), (value, row) => this.closeSubMenu(row));\n  \
}\n  /**\n   * Checks if all created and opened sub menus are closed.\n   *\n \
  * @returns {boolean}\n   */\n  isAllSubMenusClosed() {\n    return \
Object.keys(this.hotSubMenus).length === 0;\n  }\n  /**\n   * Destroy \
instance.\n   */\n  destroy() {\n    const menuContainerParentElement = \
this.container.parentNode;\n    this.clearLocalHooks();\n    this.close();\n  \
  this.parentMenu = null;\n    this.eventManager.destroy();\n    if \
(menuContainerParentElement) {\n      \
menuContainerParentElement.removeChild(this.container);\n    }\n  }\n  /**\n  \
 * Checks if menu was opened.\n   *\n   * @returns {boolean} Returns `true` \
if menu was opened.\n   */\n  isOpened() {\n    return this.hotMenu !== \
null;\n  }\n  /**\n   * Execute menu command.\n   *\n   * The \
`executeCommand()` method works only for selected cells.\n   *\n   * When no \
cells are selected, `executeCommand()` doesn't do anything.\n   *\n   * \
@param {Event} [event] The mouse event object.\n   */\n  \
executeCommand(event2) {\n    if (!this.isOpened() || \
!this.hasSelectedItem()) {\n      return;\n    }\n    const selectedItem = \
this.getSelectedItem();\n    this.runLocalHooks(\"select\", selectedItem, \
event2);\n    if (this.isCommandPassive(selectedItem)) {\n      return;\n    \
}\n    const selRanges = this.hot.getSelectedRange();\n    const \
normalizedSelection = selRanges ? normalizeSelection(selRanges) : [];\n    \
this.runLocalHooks(\"executeCommand\", selectedItem.key, normalizedSelection, \
event2);\n    if (this.isSubMenu()) {\n      \
this.parentMenu.runLocalHooks(\"executeCommand\", selectedItem.key, \
normalizedSelection, event2);\n    }\n  }\n  /**\n   * Checks if the passed \
command is passive or not. The command is passive when it's marked as\n   * \
disabled, the descriptor object contains `isCommand` property set to `false`, \
command\n   * is a separator, or the item is recognized as submenu. For \
passive items the menu is not\n   * closed automatically after the user \
trigger the command through the UI.\n   *\n   * @param {object} \
commandDescriptor Selected menu item from the menu data source.\n   * \
@returns {boolean}\n   */\n  isCommandPassive(commandDescriptor) {\n    const \
{\n      isCommand,\n      name: commandName,\n      disabled,\n      \
submenu\n    } = commandDescriptor;\n    const isItemDisabled = disabled === \
true || typeof disabled === \"function\" && disabled.call(this.hot) === \
true;\n    return isCommand === false || commandName === KEY || \
isItemDisabled === true || submenu;\n  }\n  /**\n   * Set menu position based \
on dom event or based on literal object.\n   *\n   * @param {Event|object} \
coords Event or literal Object with coordinates.\n   */\n  \
setPosition(coords) {\n    const cursor = new cursor_default(coords, \
this.container.ownerDocument.defaultView);\n    if \
(this.options.keepInViewport) {\n      if (cursor.fitsBelow(this.container)) \
{\n        this.setPositionBelowCursor(cursor);\n      } else if \
(cursor.fitsAbove(this.container)) {\n        \
this.setPositionAboveCursor(cursor);\n      } else {\n        \
this.setPositionBelowCursor(cursor);\n      }\n      if (this.hot.isLtr()) \
{\n        this.setHorizontalPositionForLtr(cursor);\n      } else {\n        \
this.setHorizontalPositionForRtl(cursor);\n      }\n    } else {\n      \
this.setPositionBelowCursor(cursor);\n      \
this.setPositionOnRightOfCursor(cursor);\n    }\n  }\n  /**\n   * Set menu \
horizontal position for RTL mode.\n   *\n   * @param {Cursor} cursor `Cursor` \
object.\n   */\n  setHorizontalPositionForRtl(cursor) {\n    if \
(cursor.fitsOnLeft(this.container)) {\n      \
this.setPositionOnLeftOfCursor(cursor);\n    } else {\n      \
this.setPositionOnRightOfCursor(cursor);\n    }\n  }\n  /**\n   * Set menu \
horizontal position for LTR mode.\n   *\n   * @param {Cursor} cursor `Cursor` \
object.\n   */\n  setHorizontalPositionForLtr(cursor) {\n    if \
(cursor.fitsOnRight(this.container)) {\n      \
this.setPositionOnRightOfCursor(cursor);\n    } else {\n      \
this.setPositionOnLeftOfCursor(cursor);\n    }\n  }\n  /**\n   * Set menu \
position above cursor object.\n   *\n   * @param {Cursor} cursor `Cursor` \
object.\n   */\n  setPositionAboveCursor(cursor) {\n    let top2 = \
this.offset.above + cursor.top - this.container.offsetHeight;\n    if \
(this.isSubMenu()) {\n      top2 = cursor.top + cursor.cellHeight - \
this.container.offsetHeight + 3;\n    }\n    this.container.style.top = \
`${top2}px`;\n  }\n  /**\n   * Set menu position below cursor object.\n   *\n \
  * @param {Cursor} cursor `Cursor` object.\n   */\n  \
setPositionBelowCursor(cursor) {\n    let top2 = this.offset.below + \
cursor.top + 1;\n    if (this.isSubMenu()) {\n      top2 = cursor.top - 1;\n  \
  }\n    this.container.style.top = `${top2}px`;\n  }\n  /**\n   * Set menu \
position on the right of cursor object.\n   *\n   * @param {Cursor} cursor \
`Cursor` object.\n   */\n  setPositionOnRightOfCursor(cursor) {\n    let \
left2 = cursor.left;\n    if (this.isSubMenu()) {\n      const {\n        \
right: parentMenuRight\n      } = \
this.parentMenu.container.getBoundingClientRect();\n      left2 += \
cursor.cellWidth + parentMenuRight - (cursor.left + cursor.cellWidth);\n    } \
else {\n      left2 += this.offset.right;\n    }\n    \
this.container.style.left = `${left2}px`;\n  }\n  /**\n   * Set menu position \
on the left of cursor object.\n   *\n   * @param {Cursor} cursor `Cursor` \
object.\n   */\n  setPositionOnLeftOfCursor(cursor) {\n    let left2 = \
this.offset.left + cursor.left - this.container.offsetWidth;\n    if \
(this.isSubMenu()) {\n      const {\n        left: parentMenuLeft\n      } = \
this.parentMenu.container.getBoundingClientRect();\n      left2 -= \
cursor.left - parentMenuLeft;\n    }\n    this.container.style.left = \
`${left2}px`;\n  }\n  /**\n   * Select first cell in opened menu.\n   */\n  \
selectFirstCell() {\n    const cell = this.hotMenu.getCell(0, 0);\n    if \
(isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {\n      \
this.selectNextCell(0, 0);\n    } else {\n      this.hotMenu.selectCell(0, \
0);\n    }\n  }\n  /**\n   * Select last cell in opened menu.\n   */\n  \
selectLastCell() {\n    const lastRow = this.hotMenu.countRows() - 1;\n    \
const cell = this.hotMenu.getCell(lastRow, 0);\n    if (isSeparator(cell) || \
isDisabled(cell) || isSelectionDisabled(cell)) {\n      \
this.selectPrevCell(lastRow, 0);\n    } else {\n      \
this.hotMenu.selectCell(lastRow, 0, void 0, void 0, false);\n      \
this.hotMenu.scrollViewportTo(lastRow, 0, true, false);\n    }\n  }\n  /**\n  \
 * Select next cell in opened menu.\n   *\n   * @param {number} row Row \
index.\n   * @param {number} col Column index.\n   */\n  selectNextCell(row, \
col) {\n    const nextRow = row + 1;\n    const cell = nextRow < \
this.hotMenu.countRows() ? this.hotMenu.getCell(nextRow, col) : null;\n    if \
(!cell) {\n      return;\n    }\n    if (isSeparator(cell) || \
isDisabled(cell) || isSelectionDisabled(cell)) {\n      \
this.selectNextCell(nextRow, col);\n    } else {\n      \
this.hotMenu.selectCell(nextRow, col);\n    }\n  }\n  /**\n   * Select \
previous cell in opened menu.\n   *\n   * @param {number} row Row index.\n   \
* @param {number} col Column index.\n   */\n  selectPrevCell(row, col) {\n    \
const prevRow = row - 1;\n    const cell = prevRow >= 0 ? \
this.hotMenu.getCell(prevRow, col) : null;\n    if (!cell) {\n      return;\n \
   }\n    if (isSeparator(cell) || isDisabled(cell) || \
isSelectionDisabled(cell)) {\n      this.selectPrevCell(prevRow, col);\n    } \
else {\n      this.hotMenu.selectCell(prevRow, col);\n    }\n  }\n  /**\n   * \
Menu item renderer.\n   *\n   * @private\n   * @param {Core} hot The \
Handsontable instance.\n   * @param {HTMLCellElement} TD The rendered cell \
element.\n   * @param {number} row The visual index.\n   * @param {number} \
col The visual index.\n   * @param {string} prop The column property if \
used.\n   * @param {string} value The cell value.\n   */\n  \
menuItemRenderer(hot2, TD, row, col, prop, value) {\n    const item = \
hot2.getSourceDataAtRow(row);\n    const wrapper = \
this.hot.rootDocument.createElement(\"div\");\n    const isSubMenu = \
(itemToTest) => hasOwnProperty(itemToTest, \"submenu\");\n    const \
itemIsSeparator = (itemToTest) => new RegExp(KEY, \
\"i\").test(itemToTest.name);\n    const itemIsDisabled = (itemToTest) => \
itemToTest.disabled === true || typeof itemToTest.disabled === \"function\" \
&& itemToTest.disabled.call(this.hot) === true;\n    const \
itemIsSelectionDisabled = (itemToTest) => itemToTest.disableSelection;\n    \
let itemValue = value;\n    if (typeof itemValue === \"function\") {\n      \
itemValue = itemValue.call(this.hot);\n    }\n    empty(TD);\n    \
addClass(wrapper, \"htItemWrapper\");\n    TD.appendChild(wrapper);\n    if \
(itemIsSeparator(item)) {\n      addClass(TD, \"htSeparator\");\n    } else \
if (typeof item.renderer === \"function\") {\n      addClass(TD, \
\"htCustomMenuRenderer\");\n      TD.appendChild(item.renderer(hot2, wrapper, \
row, col, prop, itemValue));\n    } else {\n      fastInnerHTML(wrapper, \
itemValue);\n    }\n    if (itemIsDisabled(item)) {\n      addClass(TD, \
\"htDisabled\");\n      this.eventManager.addEventListener(TD, \
\"mouseenter\", () => hot2.deselectCell());\n    } else if \
(itemIsSelectionDisabled(item)) {\n      addClass(TD, \
\"htSelectionDisabled\");\n      this.eventManager.addEventListener(TD, \
\"mouseenter\", () => hot2.deselectCell());\n    } else if (isSubMenu(item)) \
{\n      addClass(TD, \"htSubmenu\");\n      if \
(itemIsSelectionDisabled(item)) {\n        \
this.eventManager.addEventListener(TD, \"mouseenter\", () => \
hot2.deselectCell());\n      } else {\n        \
this.eventManager.addEventListener(TD, \"mouseenter\", () => \
hot2.selectCell(row, col, void 0, void 0, false, false));\n      }\n    } \
else {\n      removeClass(TD, [\"htSubmenu\", \"htDisabled\"]);\n      if \
(itemIsSelectionDisabled(item)) {\n        \
this.eventManager.addEventListener(TD, \"mouseenter\", () => \
hot2.deselectCell());\n      } else {\n        \
this.eventManager.addEventListener(TD, \"mouseenter\", () => \
hot2.selectCell(row, col, void 0, void 0, false, false));\n      }\n    }\n  \
}\n  /**\n   * Create container/wrapper for handsontable.\n   *\n   * \
@private\n   * @param {string} [name] Class name.\n   * @returns \
{HTMLElement}\n   */\n  createContainer() {\n    let name = arguments.length \
> 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    const doc = \
this.options.container.ownerDocument;\n    let className = name;\n    let \
container;\n    if (className) {\n      if (isFunction(className)) {\n        \
className = className.call(this.hot);\n        if (className === null || \
isUndefined(className)) {\n          className = \"\";\n        } else {\n    \
      className = className.toString();\n        }\n      }\n      className \
= className.replace(/[^A-z0-9]/g, \"_\");\n      className = \
`${this.options.className}Sub_${className}`;\n      container = \
doc.querySelector(`.${this.options.className}.${className}`);\n    }\n    if \
(!container) {\n      container = doc.createElement(\"div\");\n      \
addClass(container, `htMenu ${this.options.className}`);\n      if \
(className) {\n        addClass(container, className);\n      }\n      \
this.options.container.appendChild(container);\n    }\n    return \
container;\n  }\n  /**\n   * @private\n   */\n  blockMainTableCallbacks() {\n \
   this._afterScrollCallback = function() {\n    };\n    \
this.hot.addHook(\"afterScrollVertically\", this._afterScrollCallback);\n    \
this.hot.addHook(\"afterScrollHorizontally\", this._afterScrollCallback);\n  \
}\n  /**\n   * @private\n   */\n  releaseMainTableCallbacks() {\n    if \
(this._afterScrollCallback) {\n      \
this.hot.removeHook(\"afterScrollVertically\", this._afterScrollCallback);\n  \
    this.hot.removeHook(\"afterScrollHorizontally\", \
this._afterScrollCallback);\n      this._afterScrollCallback = null;\n    }\n \
 }\n  /**\n   * On after init listener.\n   *\n   * @private\n   */\n  \
onAfterInit() {\n    const {\n      wtTable\n    } = this.hotMenu.view._wt;\n \
   const data2 = this.hotMenu.getSettings().data;\n    const hiderStyle = \
wtTable.hider.style;\n    const holderStyle = wtTable.holder.style;\n    \
const currentHiderWidth = parseInt(hiderStyle.width, 10);\n    const \
realHeight = arrayReduce(data2, (accumulator, value) => accumulator + \
(value.name === KEY ? 1 : 26), 0);\n    holderStyle.width = \
`${currentHiderWidth + 3}px`;\n    holderStyle.height = `${realHeight + \
3}px`;\n    hiderStyle.height = holderStyle.height;\n  }\n  /**\n   * On \
after selection listener.\n   *\n   * @param {number} r Selection start row \
index.\n   * @param {number} c Selection start column index.\n   * @param \
{number} r2 Selection end row index.\n   * @param {number} c2 Selection end \
column index.\n   * @param {object} preventScrolling Object with `value` \
property where its value change will be observed.\n   */\n  \
onAfterSelection(r, c, r2, c2, preventScrolling) {\n    if (this.keyEvent === \
false) {\n      preventScrolling.value = true;\n    }\n  }\n  /**\n   * \
Document mouse down listener.\n   *\n   * @private\n   * @param {Event} event \
The mouse event object.\n   */\n  onDocumentMouseDown(event2) {\n    if \
(!this.isOpened()) {\n      return;\n    }\n    if (this.options.standalone \
&& this.hotMenu && !isChildOf(event2.target, this.hotMenu.rootElement)) {\n   \
   this.close(true);\n    } else if ((this.isAllSubMenusClosed() || \
this.isSubMenu()) && !isChildOf(event2.target, \".htMenu\")) {\n      \
this.close(true);\n    }\n  }\n  /**\n   * Document's contextmenu listener.\n \
  *\n   * @private\n   * @param {MouseEvent} event The mouse event object.\n  \
 */\n  onDocumentContextMenu(event2) {\n    if (!this.isOpened()) {\n      \
return;\n    }\n    if (hasClass(event2.target, \"htCore\") && \
isChildOf(event2.target, this.hotMenu.rootElement)) {\n      \
event2.preventDefault();\n    }\n  }\n};\nmixin(Menu, \
localHooks_default);\nvar menu_default = Menu;\n\n// \
node_modules/handsontable/plugins/contextMenu/contextMenu.mjs\nvar \
PLUGIN_KEY10 = \"contextMenu\";\nvar PLUGIN_PRIORITY9 = \
70;\npluginHooks_default.getSingleton().register(\"afterContextMenuDefaultOpt\
ions\");\npluginHooks_default.getSingleton().register(\"beforeContextMenuShow\
\");\npluginHooks_default.getSingleton().register(\"afterContextMenuShow\");\
\npluginHooks_default.getSingleton().register(\"afterContextMenuHide\");\nplu\
ginHooks_default.getSingleton().register(\"afterContextMenuExecute\");\nvar \
ContextMenu = class _ContextMenu extends BasePlugin {\n  static get \
PLUGIN_KEY() {\n    return PLUGIN_KEY10;\n  }\n  static get PLUGIN_PRIORITY() \
{\n    return PLUGIN_PRIORITY9;\n  }\n  static get PLUGIN_DEPS() {\n    \
return [\"plugin:AutoColumnSize\"];\n  }\n  /**\n   * Context menu default \
items order when `contextMenu` options is set as `true`.\n   *\n   * @returns \
{string[]}\n   */\n  static get DEFAULT_ITEMS() {\n    return [KEY10, KEY11, \
KEY, KEY4, KEY5, KEY, KEY9, KEY8, KEY, KEY13, KEY7, KEY, KEY6, KEY, KEY2];\n  \
}\n  /**\n   * @param {Core} hotInstance Handsontable instance.\n   */\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.eventManager = \
new eventManager_default(this);\n    this.commandExecutor = new \
commandExecutor_default(this.hot);\n    this.itemsFactory = null;\n    \
this.menu = null;\n  }\n  /**\n   * Checks if the plugin is enabled in the \
handsontable settings. This method is executed in {@link Hooks#beforeInit}\n  \
 * hook and if it returns `true` then the {@link ContextMenu#enablePlugin} \
method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    \
return !!this.hot.getSettings()[PLUGIN_KEY10];\n  }\n  /**\n   * Enables the \
plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() \
{\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    \
const settings = this.hot.getSettings()[PLUGIN_KEY10];\n    if (typeof \
settings.callback === \"function\") {\n      \
this.commandExecutor.setCommonCallback(settings.callback);\n    }\n    \
this.menu = new menu_default(this.hot, {\n      className: \
\"htContextMenu\",\n      keepInViewport: true,\n      container: \
settings.uiContainer || this.hot.rootDocument.body\n    });\n    \
this.menu.addLocalHook(\"beforeOpen\", () => this.onMenuBeforeOpen());\n    \
this.menu.addLocalHook(\"afterOpen\", () => this.onMenuAfterOpen());\n    \
this.menu.addLocalHook(\"afterClose\", () => this.onMenuAfterClose());\n    \
this.menu.addLocalHook(\"executeCommand\", function() {\n      for (var _len \
= arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) \
{\n        params[_key] = arguments[_key];\n      }\n      return \
_this.executeCommand.call(_this, ...params);\n    });\n    \
this.addHook(\"afterOnCellContextMenu\", (event2) => \
this.onAfterOnCellContextMenu(event2));\n    super.enablePlugin();\n  }\n  \
/**\n   * Updates the plugin's state.\n   *\n   * This method is executed \
when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any \
of the following configuration options:\n   *  - \
[`contextMenu`](@/api/options.md#contextmenu)\n   */\n  updatePlugin() {\n    \
this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  \
}\n  /**\n   * Disables the plugin functionality for this Handsontable \
instance.\n   */\n  disablePlugin() {\n    this.close();\n    if (this.menu) \
{\n      this.menu.destroy();\n      this.menu = null;\n    }\n    \
super.disablePlugin();\n  }\n  /**\n   * Opens menu and re-position it based \
on the passed coordinates.\n   *\n   * @param {Event} event The mouse event \
object.\n   */\n  open(event2) {\n    if (!this.menu) {\n      return;\n    \
}\n    this.prepareMenuItems();\n    this.menu.open();\n    if \
(!this.menu.isOpened()) {\n      return;\n    }\n    let offsetTop = 0;\n    \
let offsetLeft = 0;\n    if (this.hot.rootDocument !== \
this.menu.container.ownerDocument) {\n      const {\n        frameElement\n   \
   } = this.hot.rootWindow;\n      const {\n        top: top2,\n        left: \
left2\n      } = frameElement.getBoundingClientRect();\n      offsetTop = \
top2 - getWindowScrollTop(event2.view);\n      offsetLeft = left2 - \
getWindowScrollLeft(event2.view);\n    } else {\n      offsetTop = -1 * \
getWindowScrollTop(this.menu.hotMenu.rootWindow);\n      offsetLeft = -1 * \
getWindowScrollLeft(this.menu.hotMenu.rootWindow);\n    }\n    \
this.menu.setPosition({\n      top: parseInt(event2.pageY, 10) + offsetTop,\n \
     left: parseInt(event2.pageX, 10) + offsetLeft\n    });\n  }\n  /**\n   * \
Closes the menu.\n   */\n  close() {\n    if (!this.menu) {\n      return;\n  \
  }\n    this.menu.close();\n    this.itemsFactory = null;\n  }\n  /**\n   * \
Execute context menu command.\n   *\n   * The `executeCommand()` method works \
only for selected cells.\n   *\n   * When no cells are selected, \
`executeCommand()` doesn't do anything.\n   *\n   * You can execute all \
predefined commands:\n   *  * `'row_above'` - Insert row above\n   *  * \
`'row_below'` - Insert row below\n   *  * `'col_left'` - Insert column left\n \
  *  * `'col_right'` - Insert column right\n   *  * `'clear_column'` - Clear \
selected column\n   *  * `'remove_row'` - Remove row\n   *  * `'remove_col'` \
- Remove column\n   *  * `'undo'` - Undo last action\n   *  * `'redo'` - Redo \
last action\n   *  * `'make_read_only'` - Make cell read only\n   *  * \
`'alignment:left'` - Alignment to the left\n   *  * `'alignment:top'` - \
Alignment to the top\n   *  * `'alignment:right'` - Alignment to the right\n  \
 *  * `'alignment:bottom'` - Alignment to the bottom\n   *  * \
`'alignment:middle'` - Alignment to the middle\n   *  * `'alignment:center'` \
- Alignment to the center (justify).\n   *\n   * Or you can execute command \
registered in settings where `key` is your command name.\n   *\n   * @param \
{string} commandName The command name to be executed.\n   * @param {*} params \
Additional parameters passed to command executor module.\n   */\n  \
executeCommand(commandName) {\n    if (this.itemsFactory === null) {\n      \
this.prepareMenuItems();\n    }\n    for (var _len2 = arguments.length, \
params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; \
_key2++) {\n      params[_key2 - 1] = arguments[_key2];\n    }\n    \
this.commandExecutor.execute(commandName, ...params);\n  }\n  /**\n   * \
Prepares available contextMenu's items list and registers them in \
commandExecutor.\n   *\n   * @private\n   * @fires \
Hooks#afterContextMenuDefaultOptions\n   * @fires \
Hooks#beforeContextMenuSetItems\n   */\n  prepareMenuItems() {\n    \
this.itemsFactory = new itemsFactory_default(this.hot, \
_ContextMenu.DEFAULT_ITEMS);\n    const settings = \
this.hot.getSettings()[PLUGIN_KEY10];\n    const predefinedItems2 = {\n      \
items: this.itemsFactory.getItems(settings)\n    };\n    \
this.hot.runHooks(\"afterContextMenuDefaultOptions\", predefinedItems2);\n    \
this.itemsFactory.setPredefinedItems(predefinedItems2.items);\n    const \
menuItems = this.itemsFactory.getItems(settings);\n    \
this.hot.runHooks(\"beforeContextMenuSetItems\", menuItems);\n    \
this.menu.setMenuItems(menuItems);\n    arrayEach(menuItems, (command) => \
this.commandExecutor.registerCommand(command.key, command));\n  }\n  /**\n   \
* On contextmenu listener.\n   *\n   * @private\n   * @param {Event} event \
The mouse event object.\n   */\n  onAfterOnCellContextMenu(event2) {\n    \
const settings = this.hot.getSettings();\n    const showRowHeaders = \
settings.rowHeaders;\n    const showColHeaders = settings.colHeaders;\n    \
function isValidElement(element2) {\n      return element2.nodeName === \
\"TD\" || element2.parentNode.nodeName === \"TD\";\n    }\n    const element \
= event2.target;\n    this.close();\n    if (hasClass(element, \
\"handsontableInput\")) {\n      return;\n    }\n    \
event2.preventDefault();\n    event2.stopPropagation();\n    if \
(!(showRowHeaders || showColHeaders)) {\n      if (!isValidElement(element) \
&& !(hasClass(element, \"current\") && hasClass(element, \"wtBorder\"))) {\n  \
      return;\n      }\n    }\n    this.open(event2);\n  }\n  /**\n   * On \
menu before open listener.\n   *\n   * @private\n   */\n  onMenuBeforeOpen() \
{\n    this.hot.runHooks(\"beforeContextMenuShow\", this);\n  }\n  /**\n   * \
On menu after open listener.\n   *\n   * @private\n   */\n  onMenuAfterOpen() \
{\n    this.hot.runHooks(\"afterContextMenuShow\", this);\n  }\n  /**\n   * \
On menu after close listener.\n   *\n   * @private\n   */\n  \
onMenuAfterClose() {\n    this.hot.listen();\n    \
this.hot.runHooks(\"afterContextMenuHide\", this);\n  }\n  /**\n   * Destroys \
the plugin instance.\n   */\n  destroy() {\n    this.close();\n    if \
(this.menu) {\n      this.menu.destroy();\n    }\n    super.destroy();\n  \
}\n};\nContextMenu.SEPARATOR = {\n  name: KEY\n};\n\n// \
node_modules/handsontable/plugins/copyPaste/contextMenuItem/copy.mjs\nfunctio\
n copyItem(copyPastePlugin) {\n  return {\n    key: \"copy\",\n    name() {\n \
     return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY);\n    },\n    \
callback() {\n      copyPastePlugin.copyCellsOnly();\n    },\n    disabled() \
{\n      if (this.countRows() === 0 || this.countCols() === 0) {\n        \
return true;\n      }\n      const selected = this.getSelected();\n      if \
(!selected || selected.length > 1) {\n        return true;\n      }\n      \
return false;\n    },\n    hidden: false\n  };\n}\n\n// \
node_modules/handsontable/plugins/copyPaste/contextMenuItem/copyColumnHeaders\
Only.mjs\nfunction copyColumnHeadersOnlyItem(copyPastePlugin) {\n  return {\n \
   key: \"copy_column_headers_only\",\n    name() {\n      const \
selectedRange = this.getSelectedRangeLast();\n      const nounForm = \
selectedRange ? Math.min(selectedRange.getWidth() - 1, 1) : 0;\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY, \
nounForm);\n    },\n    callback() {\n      \
copyPastePlugin.copyColumnHeadersOnly();\n    },\n    disabled() {\n      if \
(!this.hasColHeaders()) {\n        return true;\n      }\n      const \
selected = this.getSelected();\n      if (!selected || selected.length > 1) \
{\n        return true;\n      }\n      return false;\n    },\n    hidden: \
false\n  };\n}\n\n// \
node_modules/handsontable/plugins/copyPaste/contextMenuItem/copyWithColumnGro\
upHeaders.mjs\nfunction copyWithColumnGroupHeadersItem(copyPastePlugin) {\n  \
return {\n    key: \"copy_with_column_group_headers\",\n    name() {\n      \
const selectedRange = this.getSelectedRangeLast();\n      const nounForm = \
selectedRange ? Math.min(selectedRange.getWidth() - 1, 1) : 0;\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS, \
nounForm);\n    },\n    callback() {\n      \
copyPastePlugin.copyWithAllColumnHeaders();\n    },\n    disabled() {\n      \
if (!this.hasColHeaders() || !this.getSettings().nestedHeaders) {\n        \
return true;\n      }\n      const selected = this.getSelected();\n      if \
(!selected || selected.length > 1) {\n        return true;\n      }\n      \
return false;\n    },\n    hidden: false\n  };\n}\n\n// \
node_modules/handsontable/plugins/copyPaste/contextMenuItem/copyWithColumnHea\
ders.mjs\nfunction copyWithColumnHeadersItem(copyPastePlugin) {\n  return {\n \
   key: \"copy_with_column_headers\",\n    name() {\n      const \
selectedRange = this.getSelectedRangeLast();\n      const nounForm = \
selectedRange ? Math.min(selectedRange.getWidth() - 1, 1) : 0;\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS, \
nounForm);\n    },\n    callback() {\n      \
copyPastePlugin.copyWithColumnHeaders();\n    },\n    disabled() {\n      if \
(!this.hasColHeaders()) {\n        return true;\n      }\n      const \
selected = this.getSelected();\n      if (!selected || selected.length > 1) \
{\n        return true;\n      }\n      return false;\n    },\n    hidden: \
false\n  };\n}\n\n// \
node_modules/handsontable/plugins/copyPaste/contextMenuItem/cut.mjs\nfunction \
cutItem(copyPastePlugin) {\n  return {\n    key: \"cut\",\n    name() {\n     \
 return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CUT);\n    },\n    \
callback() {\n      copyPastePlugin.cut();\n    },\n    disabled() {\n      \
if (this.countRows() === 0 || this.countCols() === 0) {\n        return \
true;\n      }\n      const selected = this.getSelected();\n      if \
(!selected || selected.length > 1) {\n        return true;\n      }\n      \
return false;\n    },\n    hidden: false\n  };\n}\n\n// \
node_modules/handsontable/plugins/copyPaste/clipboardData.mjs\nvar \
ClipboardData = class {\n  constructor() {\n    this.data = {};\n  }\n  \
setData(type, value) {\n    this.data[type] = value;\n  }\n  getData(type) \
{\n    return this.data[type] || void 0;\n  }\n};\n\n// \
node_modules/handsontable/plugins/copyPaste/pasteEvent.mjs\nvar PasteEvent = \
class {\n  constructor() {\n    this.clipboardData = new ClipboardData();\n  \
}\n};\n\n// \
node_modules/handsontable/plugins/copyPaste/focusableElement.mjs\nvar \
FocusableWrapper = class {\n  constructor(container) {\n    this.rootDocument \
= container.defaultView ? container : container.ownerDocument;\n    \
this.mainElement = null;\n    this.eventManager = new \
eventManager_default(this);\n    this.listenersCount = /* @__PURE__ */ new \
WeakSet();\n    this.container = container;\n  }\n  /**\n   * Switch to the \
secondary focusable element. Used when no any main focusable element is \
provided.\n   */\n  useSecondaryElement() {\n    const el = \
createOrGetSecondaryElement(this.container);\n    if \
(!this.listenersCount.has(el)) {\n      this.listenersCount.add(el);\n      \
forwardEventsToLocalHooks(this.eventManager, el, this);\n    }\n    \
this.mainElement = el;\n  }\n  /**\n   * Switch to the main focusable \
element.\n   *\n   * @param {HTMLElement} element The DOM element.\n   */\n  \
setFocusableElement(element) {\n    if (!this.listenersCount.has(element)) \
{\n      this.listenersCount.add(element);\n      \
forwardEventsToLocalHooks(this.eventManager, element, this);\n    }\n    \
this.mainElement = element;\n  }\n  /**\n   * Get currently set focusable \
element.\n   *\n   * @returns {HTMLElement}\n   */\n  getFocusableElement() \
{\n    return this.mainElement;\n  }\n  /**\n   * Set focus to the focusable \
element.\n   */\n  focus() {\n    this.mainElement.value = \" \";\n    if \
(!isMobileBrowser()) {\n      selectElementIfAllowed(this.mainElement);\n    \
}\n  }\n};\nmixin(FocusableWrapper, localHooks_default);\nvar refCounter = /* \
@__PURE__ */ new WeakMap();\nfunction createElement(container) {\n  const \
focusableWrapper = new FocusableWrapper(container);\n  let counter = \
refCounter.get(container);\n  counter = isNaN(counter) ? 0 : counter;\n  \
refCounter.set(container, counter + 1);\n  return \
focusableWrapper;\n}\nfunction deactivateElement(wrapper) {\n  \
wrapper.eventManager.clear();\n}\nvar runLocalHooks = (eventName, subject) => \
(event2) => subject.runLocalHooks(eventName, event2);\nfunction \
forwardEventsToLocalHooks(eventManager, element, subject) {\n  \
eventManager.addEventListener(element, \"copy\", runLocalHooks(\"copy\", \
subject));\n  eventManager.addEventListener(element, \"cut\", \
runLocalHooks(\"cut\", subject));\n  eventManager.addEventListener(element, \
\"paste\", runLocalHooks(\"paste\", subject));\n}\nvar secondaryElements = /* \
@__PURE__ */ new WeakMap();\nfunction createOrGetSecondaryElement(container) \
{\n  const secondaryElement = secondaryElements.get(container);\n  if \
(secondaryElement) {\n    if (!secondaryElement.parentElement) {\n      \
container.appendChild(secondaryElement);\n    }\n    return \
secondaryElement;\n  }\n  const doc = container.defaultView ? container : \
container.ownerDocument;\n  const element = \
doc.createElement(\"textarea\");\n  secondaryElements.set(container, \
element);\n  element.setAttribute(\"data-hot-input\", \"\");\n  \
element.className = \"HandsontableCopyPaste\";\n  element.tabIndex = -1;\n  \
element.autocomplete = \"off\";\n  element.wrap = \"hard\";\n  element.value \
= \" \";\n  container.appendChild(element);\n  return element;\n}\nfunction \
destroyElement(wrapper) {\n  if (!(wrapper instanceof FocusableWrapper)) {\n  \
  return;\n  }\n  let counter = refCounter.get(wrapper.container);\n  counter \
= isNaN(counter) ? 0 : counter;\n  if (counter > 0) {\n    counter -= 1;\n  \
}\n  deactivateElement(wrapper);\n  if (counter <= 0) {\n    counter = 0;\n   \
 const secondaryElement = secondaryElements.get(wrapper.container);\n    if \
(secondaryElement && secondaryElement.parentNode) {\n      \
secondaryElement.parentNode.removeChild(secondaryElement);\n      \
secondaryElements.delete(wrapper.container);\n    }\n    wrapper.mainElement \
= null;\n  }\n  refCounter.set(wrapper.container, counter);\n}\n\n// \
node_modules/handsontable/plugins/copyPaste/copyableRanges.mjs\nfunction \
_classPrivateMethodInitSpec2(obj, privateSet) {\n  \
_checkPrivateRedeclaration8(obj, privateSet);\n  \
privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec7(obj, \
privateMap, value) {\n  _checkPrivateRedeclaration8(obj, privateMap);\n  \
privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration8(obj, \
privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new \
TypeError(\"Cannot initialize the same private elements twice on an \
object\");\n  }\n}\nfunction _classPrivateMethodGet2(receiver, privateSet, \
fn) {\n  if (!privateSet.has(receiver)) {\n    throw new \
TypeError(\"attempted to get private field on non-instance\");\n  }\n  return \
fn;\n}\nfunction _classPrivateFieldGet7(receiver, privateMap) {\n  var \
descriptor = _classExtractFieldDescriptor7(receiver, privateMap, \"get\");\n  \
return _classApplyDescriptorGet7(receiver, descriptor);\n}\nfunction \
_classApplyDescriptorGet7(receiver, descriptor) {\n  if (descriptor.get) {\n  \
  return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nfunction _classPrivateFieldSet7(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor7(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet7(receiver, descriptor, \
value);\n  return value;\n}\nfunction _classExtractFieldDescriptor7(receiver, \
privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorSet7(receiver, descriptor, value) {\n  if \
(descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n   \
 if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set \
read only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\nvar _selectedRange = /* @__PURE__ */ new WeakMap();\nvar _countRows = \
/* @__PURE__ */ new WeakMap();\nvar _countColumns = /* @__PURE__ */ new \
WeakMap();\nvar _rowsLimit = /* @__PURE__ */ new WeakMap();\nvar \
_columnsLimit = /* @__PURE__ */ new WeakMap();\nvar _countColumnHeaders = /* \
@__PURE__ */ new WeakMap();\nvar _trimColumnsRange = /* @__PURE__ */ new \
WeakSet();\nvar _trimRowsRange = /* @__PURE__ */ new WeakSet();\nvar \
CopyableRangesFactory = class {\n  /* eslint-disable \
jsdoc/require-description-complete-sentence */\n  /**\n   * @param {{\n   *   \
countRows: function(): number,\n   *   countColumns: function(): number,\n   \
*   rowsLimit: function(): number,\n   *   columnsLimit: function(): \
number,\n   *   countColumnHeaders: function(): number\n   * }} dependencies \
The utils class dependencies.\n   */\n  constructor(_ref) {\n    let {\n      \
countRows,\n      countColumns,\n      rowsLimit,\n      columnsLimit,\n      \
countColumnHeaders\n    } = _ref;\n    _classPrivateMethodInitSpec2(this, \
_trimRowsRange);\n    _classPrivateMethodInitSpec2(this, \
_trimColumnsRange);\n    _classPrivateFieldInitSpec7(this, _selectedRange, \
{\n      writable: true,\n      value: void 0\n    });\n    \
_classPrivateFieldInitSpec7(this, _countRows, {\n      writable: true,\n      \
value: void 0\n    });\n    _classPrivateFieldInitSpec7(this, _countColumns, \
{\n      writable: true,\n      value: void 0\n    });\n    \
_classPrivateFieldInitSpec7(this, _rowsLimit, {\n      writable: true,\n      \
value: void 0\n    });\n    _classPrivateFieldInitSpec7(this, _columnsLimit, \
{\n      writable: true,\n      value: void 0\n    });\n    \
_classPrivateFieldInitSpec7(this, _countColumnHeaders, {\n      writable: \
true,\n      value: void 0\n    });\n    _classPrivateFieldSet7(this, \
_countRows, countRows);\n    _classPrivateFieldSet7(this, _countColumns, \
countColumns);\n    _classPrivateFieldSet7(this, _rowsLimit, rowsLimit);\n    \
_classPrivateFieldSet7(this, _columnsLimit, columnsLimit);\n    \
_classPrivateFieldSet7(this, _countColumnHeaders, countColumnHeaders);\n  }\n \
 /* eslint-enable jsdoc/require-description-complete-sentence */\n  /**\n   * \
Sets the selection range to be processed.\n   *\n   * @param {CellRange} \
selectedRange The selection range represented by the CellRange class.\n   \
*/\n  setSelectedRange(selectedRange) {\n    _classPrivateFieldSet7(this, \
_selectedRange, selectedRange);\n  }\n  /**\n   * Returns a new coords object \
within the dataset range (cells) with `startRow`, `startCol`, `endRow`\n   * \
and `endCol` keys.\n   *\n   * @returns {{startRow: number, startCol: number, \
endRow: number, endCol: number} | null}\n   */\n  getCellsRange() {\n    if \
(_classPrivateFieldGet7(this, _countRows).call(this) === 0 || \
_classPrivateFieldGet7(this, _countColumns).call(this) === 0) {\n      return \
null;\n    }\n    const {\n      row: startRow,\n      col: startCol\n    } = \
_classPrivateFieldGet7(this, _selectedRange).getTopStartCorner();\n    const \
{\n      row: endRow,\n      col: endCol\n    } = \
_classPrivateFieldGet7(this, _selectedRange).getBottomEndCorner();\n    const \
finalEndRow = _classPrivateMethodGet2(this, _trimRowsRange, \
_trimRowsRange2).call(this, startRow, endRow);\n    const finalEndCol = \
_classPrivateMethodGet2(this, _trimColumnsRange, \
_trimColumnsRange2).call(this, startCol, endCol);\n    const isRangeTrimmed = \
endRow !== finalEndRow || endCol !== finalEndCol;\n    return {\n      \
isRangeTrimmed,\n      startRow,\n      startCol,\n      endRow: \
finalEndRow,\n      endCol: finalEndCol\n    };\n  }\n  /**\n   * Returns a \
new coords object within the most-bottom column headers range with \
`startRow`,\n   * `startCol`, `endRow` and `endCol` keys.\n   *\n   * \
@returns {{startRow: number, startCol: number, endRow: number, endCol: \
number} | null}\n   */\n  getMostBottomColumnHeadersRange() {\n    if \
(_classPrivateFieldGet7(this, _countColumns).call(this) === 0 || \
_classPrivateFieldGet7(this, _countColumnHeaders).call(this) === 0) {\n      \
return null;\n    }\n    const {\n      col: startCol\n    } = \
_classPrivateFieldGet7(this, _selectedRange).getTopStartCorner();\n    const \
{\n      col: endCol\n    } = _classPrivateFieldGet7(this, \
_selectedRange).getBottomEndCorner();\n    const finalEndCol = \
_classPrivateMethodGet2(this, _trimColumnsRange, \
_trimColumnsRange2).call(this, startCol, endCol);\n    const isRangeTrimmed = \
endCol !== finalEndCol;\n    return {\n      isRangeTrimmed,\n      startRow: \
-1,\n      startCol,\n      endRow: -1,\n      endCol: finalEndCol\n    };\n  \
}\n  /**\n   * Returns a new coords object within all column headers layers \
(including nested headers) range with\n   * `startRow`, `startCol`, `endRow` \
and `endCol` keys.\n   *\n   * @returns {{startRow: number, startCol: number, \
endRow: number, endCol: number} | null}\n   */\n  getAllColumnHeadersRange() \
{\n    if (_classPrivateFieldGet7(this, _countColumns).call(this) === 0 || \
_classPrivateFieldGet7(this, _countColumnHeaders).call(this) === 0) {\n      \
return null;\n    }\n    const {\n      col: startCol\n    } = \
_classPrivateFieldGet7(this, _selectedRange).getTopStartCorner();\n    const \
{\n      col: endCol\n    } = _classPrivateFieldGet7(this, \
_selectedRange).getBottomEndCorner();\n    const finalEndCol = \
_classPrivateMethodGet2(this, _trimColumnsRange, \
_trimColumnsRange2).call(this, startCol, endCol);\n    const isRangeTrimmed = \
endCol !== finalEndCol;\n    return {\n      isRangeTrimmed,\n      startRow: \
-_classPrivateFieldGet7(this, _countColumnHeaders).call(this),\n      \
startCol,\n      endRow: -1,\n      endCol: finalEndCol\n    };\n  \
}\n};\nfunction _trimColumnsRange2(startColumn, endColumn) {\n  return \
Math.min(endColumn, Math.max(startColumn + _classPrivateFieldGet7(this, \
_columnsLimit).call(this) - 1, startColumn));\n}\nfunction \
_trimRowsRange2(startRow, endRow) {\n  return Math.min(endRow, \
Math.max(startRow + _classPrivateFieldGet7(this, _rowsLimit).call(this) - 1, \
startRow));\n}\nfunction normalizeRanges(ranges) {\n  const rows = [];\n  \
const columns = [];\n  arrayEach(ranges, (range) => {\n    const minRow = \
Math.min(range.startRow, range.endRow);\n    const maxRow = \
Math.max(range.startRow, range.endRow);\n    rangeEach(minRow, maxRow, (row) \
=> {\n      if (rows.indexOf(row) === -1) {\n        rows.push(row);\n      \
}\n    });\n    const minColumn = Math.min(range.startCol, range.endCol);\n   \
 const maxColumn = Math.max(range.startCol, range.endCol);\n    \
rangeEach(minColumn, maxColumn, (column) => {\n      if \
(columns.indexOf(column) === -1) {\n        columns.push(column);\n      }\n  \
  });\n  });\n  return {\n    rows,\n    columns\n  };\n}\n\n// \
node_modules/handsontable/plugins/copyPaste/copyPaste.mjs\nfunction \
_classPrivateMethodInitSpec3(obj, privateSet) {\n  \
_checkPrivateRedeclaration9(obj, privateSet);\n  \
privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec8(obj, \
privateMap, value) {\n  _checkPrivateRedeclaration9(obj, privateMap);\n  \
privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration9(obj, \
privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new \
TypeError(\"Cannot initialize the same private elements twice on an \
object\");\n  }\n}\nfunction _defineProperty18(obj, key, value) {\n  key = \
_toPropertyKey18(key);\n  if (key in obj) {\n    Object.defineProperty(obj, \
key, { value, enumerable: true, configurable: true, writable: true });\n  } \
else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction \
_toPropertyKey18(arg) {\n  var key = _toPrimitive18(arg, \"string\");\n  \
return typeof key === \"symbol\" ? key : String(key);\n}\nfunction \
_toPrimitive18(input, hint) {\n  if (typeof input !== \"object\" || input === \
null)\n    return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim \
!== void 0) {\n    var res = prim.call(input, hint || \"default\");\n    if \
(typeof res !== \"object\")\n      return res;\n    throw new \
TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return \
(hint === \"string\" ? String : Number)(input);\n}\nfunction \
_classPrivateMethodGet3(receiver, privateSet, fn) {\n  if \
(!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get \
private field on non-instance\");\n  }\n  return fn;\n}\nfunction \
_classPrivateFieldGet8(receiver, privateMap) {\n  var descriptor = \
_classExtractFieldDescriptor8(receiver, privateMap, \"get\");\n  return \
_classApplyDescriptorGet8(receiver, descriptor);\n}\nfunction \
_classApplyDescriptorGet8(receiver, descriptor) {\n  if (descriptor.get) {\n  \
  return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nfunction _classPrivateFieldSet8(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor8(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet8(receiver, descriptor, \
value);\n  return value;\n}\nfunction _classExtractFieldDescriptor8(receiver, \
privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorSet8(receiver, descriptor, value) {\n  if \
(descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n   \
 if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set \
read only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\npluginHooks_default.getSingleton().register(\"afterCopyLimit\");\nplugi\
nHooks_default.getSingleton().register(\"modifyCopyableRange\");\npluginHooks\
_default.getSingleton().register(\"beforeCut\");\npluginHooks_default.getSing\
leton().register(\"afterCut\");\npluginHooks_default.getSingleton().register(\
\"beforePaste\");\npluginHooks_default.getSingleton().register(\"afterPaste\"\
);\npluginHooks_default.getSingleton().register(\"beforeCopy\");\npluginHooks\
_default.getSingleton().register(\"afterCopy\");\nvar PLUGIN_KEY11 = \
\"copyPaste\";\nvar PLUGIN_PRIORITY10 = 80;\nvar SETTING_KEYS3 = \
[\"fragmentSelection\"];\nvar META_HEAD = ['<meta name=\"generator\" \
content=\"Handsontable\"/>', '<style \
type=\"text/css\">td{white-space:normal}br{mso-data-placement:same-cell}</sty\
le>'].join(\"\");\nvar _enableCopyColumnHeaders = /* @__PURE__ */ new \
WeakMap();\nvar _enableCopyColumnGroupHeaders = /* @__PURE__ */ new \
WeakMap();\nvar _enableCopyColumnHeadersOnly = /* @__PURE__ */ new \
WeakMap();\nvar _copyMode = /* @__PURE__ */ new WeakMap();\nvar \
_isTriggeredByCopy = /* @__PURE__ */ new WeakMap();\nvar _isTriggeredByCut = \
/* @__PURE__ */ new WeakMap();\nvar _copyableRangesFactory = /* @__PURE__ */ \
new WeakMap();\nvar _countCopiedHeaders = /* @__PURE__ */ new WeakSet();\nvar \
CopyPaste = class extends BasePlugin {\n  constructor() {\n    \
super(...arguments);\n    _classPrivateMethodInitSpec3(this, \
_countCopiedHeaders);\n    _defineProperty18(this, \"columnsLimit\", \
Infinity);\n    _defineProperty18(this, \"rowsLimit\", Infinity);\n    \
_defineProperty18(this, \"pasteMode\", \"overwrite\");\n    \
_defineProperty18(this, \"uiContainer\", this.hot.rootDocument.body);\n    \
_classPrivateFieldInitSpec8(this, _enableCopyColumnHeaders, {\n      \
writable: true,\n      value: false\n    });\n    \
_classPrivateFieldInitSpec8(this, _enableCopyColumnGroupHeaders, {\n      \
writable: true,\n      value: false\n    });\n    \
_classPrivateFieldInitSpec8(this, _enableCopyColumnHeadersOnly, {\n      \
writable: true,\n      value: false\n    });\n    \
_classPrivateFieldInitSpec8(this, _copyMode, {\n      writable: true,\n      \
value: \"cells-only\"\n    });\n    _classPrivateFieldInitSpec8(this, \
_isTriggeredByCopy, {\n      writable: true,\n      value: false\n    });\n   \
 _classPrivateFieldInitSpec8(this, _isTriggeredByCut, {\n      writable: \
true,\n      value: false\n    });\n    _classPrivateFieldInitSpec8(this, \
_copyableRangesFactory, {\n      writable: true,\n      value: new \
CopyableRangesFactory({\n        countRows: () => this.hot.countRows(),\n     \
   countColumns: () => this.hot.countCols(),\n        rowsLimit: () => \
this.rowsLimit,\n        columnsLimit: () => this.columnsLimit,\n        \
countColumnHeaders: () => this.hot.view.getColumnHeadersCount()\n      })\n   \
 });\n    _defineProperty18(this, \"copyableRanges\", []);\n    \
_defineProperty18(this, \"focusableElement\", void 0);\n  }\n  static get \
PLUGIN_KEY() {\n    return PLUGIN_KEY11;\n  }\n  static get SETTING_KEYS() \
{\n    return [PLUGIN_KEY11, ...SETTING_KEYS3];\n  }\n  static get \
PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY10;\n  }\n  /**\n   * Checks \
if the [`CopyPaste`](#copypaste) plugin is enabled.\n   *\n   * This method \
gets called by Handsontable's [`beforeInit`](@/api/hooks.md#beforeinit) \
hook.\n   * If it returns `true`, the [`enablePlugin()`](#enableplugin) \
method gets called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n  \
  return !!this.hot.getSettings()[PLUGIN_KEY11];\n  }\n  /**\n   * Enables \
the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.\n   */\n \
 enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    const \
{\n      [PLUGIN_KEY11]: settings\n    } = this.hot.getSettings();\n    if \
(typeof settings === \"object\") {\n      var _settings$pasteMode, \
_settings$uiContainer;\n      this.pasteMode = (_settings$pasteMode = \
settings.pasteMode) !== null && _settings$pasteMode !== void 0 ? \
_settings$pasteMode : this.pasteMode;\n      this.rowsLimit = \
isNaN(settings.rowsLimit) ? this.rowsLimit : settings.rowsLimit;\n      \
this.columnsLimit = isNaN(settings.columnsLimit) ? this.columnsLimit : \
settings.columnsLimit;\n      _classPrivateFieldSet8(this, \
_enableCopyColumnHeaders, !!settings.copyColumnHeaders);\n      \
_classPrivateFieldSet8(this, _enableCopyColumnGroupHeaders, \
!!settings.copyColumnGroupHeaders);\n      _classPrivateFieldSet8(this, \
_enableCopyColumnHeadersOnly, !!settings.copyColumnHeadersOnly);\n      \
this.uiContainer = (_settings$uiContainer = settings.uiContainer) !== null && \
_settings$uiContainer !== void 0 ? _settings$uiContainer : \
this.uiContainer;\n    }\n    \
this.addHook(\"afterContextMenuDefaultOptions\", (options) => \
this.onAfterContextMenuDefaultOptions(options));\n    \
this.addHook(\"afterOnCellMouseUp\", () => this.onAfterOnCellMouseUp());\n    \
this.addHook(\"afterSelectionEnd\", () => this.onAfterSelectionEnd());\n    \
this.addHook(\"beforeKeyDown\", () => this.onBeforeKeyDown());\n    \
this.focusableElement = createElement(this.uiContainer);\n    \
this.focusableElement.addLocalHook(\"copy\", (event2) => \
this.onCopy(event2)).addLocalHook(\"cut\", (event2) => \
this.onCut(event2)).addLocalHook(\"paste\", (event2) => \
this.onPaste(event2));\n    super.enablePlugin();\n  }\n  /**\n   * Updates \
the state of the [`CopyPaste`](#copypaste) plugin.\n   *\n   * Gets called \
when [`updateSettings()`](@/api/core.md#updatesettings)\n   * is invoked with \
any of the following configuration options:\n   *  - \
[`copyPaste`](@/api/options.md#copypaste)\n   *  - \
[`fragmentSelection`](@/api/options.md#fragmentselection)\n   */\n  \
updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    \
this.getOrCreateFocusableElement();\n    super.updatePlugin();\n  }\n  /**\n  \
 * Disables the [`CopyPaste`](#copypaste) plugin for your Handsontable \
instance.\n   */\n  disablePlugin() {\n    if (this.focusableElement) {\n     \
 destroyElement(this.focusableElement);\n    }\n    super.disablePlugin();\n  \
}\n  /**\n   * Copies the contents of the selected cells (and/or their \
related column headers) to the system clipboard.\n   *\n   * Takes an \
optional parameter (`copyMode`) that defines the scope of copying:\n   *\n   \
* | `copyMode` value              | Description                               \
                      |\n   * | ----------------------------- | \
--------------------------------------------------------------- |\n   * | \
`'cells-only'` (default)      | Copy the selected cells                       \
                  |\n   * | `'with-column-headers'`       | - Copy the \
selected cells<br>- Copy the nearest column headers  |\n   * | \
`'with-column-group-headers'` | - Copy the selected cells<br>- Copy all \
related columns headers |\n   * | `'column-headers-only'`       | Copy the \
nearest column headers (without copying cells)         |\n   *\n   * @param \
{string} [copyMode='cells-only'] Copy mode.\n   */\n  copy() {\n    let \
copyMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \
\"cells-only\";\n    _classPrivateFieldSet8(this, _copyMode, copyMode);\n    \
_classPrivateFieldSet8(this, _isTriggeredByCopy, true);\n    \
this.getOrCreateFocusableElement();\n    this.focusableElement.focus();\n    \
this.hot.rootDocument.execCommand(\"copy\");\n  }\n  /**\n   * Copies the \
contents of the selected cells.\n   */\n  copyCellsOnly() {\n    \
this.copy(\"cells-only\");\n  }\n  /**\n   * Copies the contents of column \
headers that are nearest to the selected cells.\n   */\n  \
copyColumnHeadersOnly() {\n    this.copy(\"column-headers-only\");\n  }\n  \
/**\n   * Copies the contents of the selected cells and all their related \
column headers.\n   */\n  copyWithAllColumnHeaders() {\n    \
this.copy(\"with-column-group-headers\");\n  }\n  /**\n   * Copies the \
contents of the selected cells and their nearest column headers.\n   */\n  \
copyWithColumnHeaders() {\n    this.copy(\"with-column-headers\");\n  }\n  \
/**\n   * Cuts the contents of the selected cells to the system clipboard.\n  \
 */\n  cut() {\n    _classPrivateFieldSet8(this, _isTriggeredByCut, true);\n  \
  this.getOrCreateFocusableElement();\n    this.focusableElement.focus();\n   \
 this.hot.rootDocument.execCommand(\"cut\");\n  }\n  /**\n   * Converts the \
contents of multiple ranges (`ranges`) into a single string.\n   *\n   * \
@param {Array<{startRow: number, startCol: number, endRow: number, endCol: \
number}>} ranges Array of objects with properties `startRow`, `endRow`, \
`startCol` and `endCol`.\n   * @returns {string} A string that will be copied \
to the clipboard.\n   */\n  getRangedCopyableData(ranges) {\n    return \
stringify2(this.getRangedData(ranges));\n  }\n  /**\n   * Converts the \
contents of multiple ranges (`ranges`) into an array of arrays.\n   *\n   * \
@param {Array<{startRow: number, startCol: number, endRow: number, endCol: \
number}>} ranges Array of objects with properties `startRow`, `startCol`, \
`endRow` and `endCol`.\n   * @returns {Array[]} An array of arrays that will \
be copied to the clipboard.\n   */\n  getRangedData(ranges) {\n    const \
data2 = [];\n    const {\n      rows,\n      columns\n    } = \
normalizeRanges(ranges);\n    arrayEach(rows, (row) => {\n      const rowSet \
= [];\n      arrayEach(columns, (column) => {\n        if (row < 0) {\n       \
   rowSet.push(this.hot.getColHeader(column, row));\n        } else {\n       \
   rowSet.push(this.hot.getCopyableData(row, column));\n        }\n      \
});\n      data2.push(rowSet);\n    });\n    return data2;\n  }\n  /**\n   * \
Simulates the paste action.\n   *\n   * For security reasons, modern browsers \
don't allow reading from the system clipboard.\n   *\n   * @param {string} \
pastableText The value to paste, as a raw string.\n   * @param {string} \
[pastableHtml=''] The value to paste, as HTML.\n   */\n  paste() {\n    let \
pastableText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] \
: \"\";\n    let pastableHtml = arguments.length > 1 && arguments[1] !== void \
0 ? arguments[1] : pastableText;\n    if (!pastableText && !pastableHtml) {\n \
     return;\n    }\n    const pasteData = new PasteEvent();\n    if \
(pastableText) {\n      pasteData.clipboardData.setData(\"text/plain\", \
pastableText);\n    }\n    if (pastableHtml) {\n      \
pasteData.clipboardData.setData(\"text/html\", pastableHtml);\n    }\n    \
this.getOrCreateFocusableElement();\n    this.onPaste(pasteData);\n  }\n  \
/**\n   * Prepares copyable text from the cells selection in the invisible \
textarea.\n   */\n  setCopyableText() {\n    const selectionRange = \
this.hot.getSelectedRangeLast();\n    if (!selectionRange) {\n      return;\n \
   }\n    _classPrivateFieldGet8(this, \
_copyableRangesFactory).setSelectedRange(selectionRange);\n    const \
groupedRanges = /* @__PURE__ */ new Map([[\"headers\", null], [\"cells\", \
null]]);\n    if (_classPrivateFieldGet8(this, _copyMode) === \
\"column-headers-only\") {\n      groupedRanges.set(\"headers\", \
_classPrivateFieldGet8(this, \
_copyableRangesFactory).getMostBottomColumnHeadersRange());\n    } else {\n   \
   if (_classPrivateFieldGet8(this, _copyMode) === \"with-column-headers\") \
{\n        groupedRanges.set(\"headers\", _classPrivateFieldGet8(this, \
_copyableRangesFactory).getMostBottomColumnHeadersRange());\n      } else if \
(_classPrivateFieldGet8(this, _copyMode) === \"with-column-group-headers\") \
{\n        groupedRanges.set(\"headers\", _classPrivateFieldGet8(this, \
_copyableRangesFactory).getAllColumnHeadersRange());\n      }\n      \
groupedRanges.set(\"cells\", _classPrivateFieldGet8(this, \
_copyableRangesFactory).getCellsRange());\n    }\n    this.copyableRanges = \
Array.from(groupedRanges.values()).filter((range) => range !== \
null).map((_ref) => {\n      let {\n        startRow,\n        startCol,\n    \
    endRow,\n        endCol\n      } = _ref;\n      return {\n        \
startRow,\n        startCol,\n        endRow,\n        endCol\n      };\n    \
});\n    this.copyableRanges = this.hot.runHooks(\"modifyCopyableRange\", \
this.copyableRanges);\n    const cellsRange = groupedRanges.get(\"cells\");\n \
   if (cellsRange !== null && cellsRange.isRangeTrimmed) {\n      const {\n   \
     startRow,\n        startCol,\n        endRow,\n        endCol\n      } = \
cellsRange;\n      this.hot.runHooks(\"afterCopyLimit\", endRow - startRow + \
1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);\n    }\n  }\n  \
/**\n   * Force focus on editable element.\n   *\n   * @private\n   */\n  \
getOrCreateFocusableElement() {\n    var _this$hot$getActiveEd;\n    const \
editableElement = (_this$hot$getActiveEd = this.hot.getActiveEditor()) === \
null || _this$hot$getActiveEd === void 0 ? void 0 : \
_this$hot$getActiveEd.TEXTAREA;\n    if (editableElement) {\n      \
this.focusableElement.setFocusableElement(editableElement);\n    } else {\n   \
   this.focusableElement.useSecondaryElement();\n    }\n  }\n  /**\n   * \
Verifies if editor exists and is open.\n   *\n   * @private\n   * @returns \
{boolean}\n   */\n  isEditorOpened() {\n    var _this$hot$getActiveEd2;\n    \
return (_this$hot$getActiveEd2 = this.hot.getActiveEditor()) === null || \
_this$hot$getActiveEd2 === void 0 ? void 0 : \
_this$hot$getActiveEd2.isOpened();\n  }\n  /**\n   * Prepares new values to \
populate them into datasource.\n   *\n   * @private\n   * @param {Array} \
inputArray An array of the data to populate.\n   * @param {Array} [selection] \
The selection which indicates from what position the data will be \
populated.\n   * @returns {Array} Range coordinates after populate data.\n   \
*/\n  populateValues(inputArray) {\n    let selection = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : \
this.hot.getSelectedRangeLast();\n    if (!inputArray.length) {\n      \
return;\n    }\n    const populatedRowsLength = inputArray.length;\n    const \
populatedColumnsLength = inputArray[0].length;\n    const newRows = [];\n    \
const {\n      row: startRow,\n      col: startColumn\n    } = \
selection.getTopStartCorner();\n    const {\n      row: \
endRowFromSelection,\n      col: endColumnFromSelection\n    } = \
selection.getBottomEndCorner();\n    let visualRowForPopulatedData = \
startRow;\n    let visualColumnForPopulatedData = startColumn;\n    let \
lastVisualRow = startRow;\n    let lastVisualColumn = startColumn;\n    while \
(newRows.length < populatedRowsLength || visualRowForPopulatedData <= \
endRowFromSelection) {\n      const {\n        skipRowOnPaste,\n        \
visualRow\n      } = this.hot.getCellMeta(visualRowForPopulatedData, \
startColumn);\n      visualRowForPopulatedData = visualRow + 1;\n      if \
(skipRowOnPaste === true) {\n        continue;\n      }\n      lastVisualRow \
= visualRow;\n      visualColumnForPopulatedData = startColumn;\n      const \
newRow = [];\n      const insertedRow = newRows.length % \
populatedRowsLength;\n      while (newRow.length < populatedColumnsLength || \
visualColumnForPopulatedData <= endColumnFromSelection) {\n        const {\n  \
        skipColumnOnPaste,\n          visualCol\n        } = \
this.hot.getCellMeta(startRow, visualColumnForPopulatedData);\n        \
visualColumnForPopulatedData = visualCol + 1;\n        if (skipColumnOnPaste \
=== true) {\n          continue;\n        }\n        lastVisualColumn = \
visualCol;\n        const insertedColumn = newRow.length % \
populatedColumnsLength;\n        \
newRow.push(inputArray[insertedRow][insertedColumn]);\n      }\n      \
newRows.push(newRow);\n    }\n    this.hot.populateFromArray(startRow, \
startColumn, newRows, void 0, void 0, \"CopyPaste.paste\", this.pasteMode);\n \
   return [startRow, startColumn, lastVisualRow, lastVisualColumn];\n  }\n  \
/**\n   * `copy` event callback on textarea element.\n   *\n   * @param \
{Event} event ClipboardEvent.\n   * @private\n   */\n  onCopy(event2) {\n    \
if (!this.hot.isListening() && !_classPrivateFieldGet8(this, \
_isTriggeredByCopy) || this.isEditorOpened()) {\n      return;\n    }\n    \
this.setCopyableText();\n    _classPrivateFieldSet8(this, _isTriggeredByCopy, \
false);\n    const data2 = this.getRangedData(this.copyableRanges);\n    \
const copiedHeadersCount = _classPrivateMethodGet3(this, _countCopiedHeaders, \
_countCopiedHeaders2).call(this, this.copyableRanges);\n    const \
allowCopying = !!this.hot.runHooks(\"beforeCopy\", data2, \
this.copyableRanges, copiedHeadersCount);\n    if (allowCopying) {\n      \
const textPlain = stringify2(data2);\n      if (event2 && \
event2.clipboardData) {\n        const textHTML = _dataToHTML(data2, \
this.hot.rootDocument);\n        event2.clipboardData.setData(\"text/plain\", \
textPlain);\n        event2.clipboardData.setData(\"text/html\", [META_HEAD, \
textHTML].join(\"\"));\n      } else if (typeof ClipboardEvent === \
\"undefined\") {\n        this.hot.rootWindow.clipboardData.setData(\"Text\", \
textPlain);\n      }\n      this.hot.runHooks(\"afterCopy\", data2, \
this.copyableRanges, copiedHeadersCount);\n    }\n    \
_classPrivateFieldSet8(this, _copyMode, \"cells-only\");\n    \
event2.preventDefault();\n  }\n  /**\n   * `cut` event callback on textarea \
element.\n   *\n   * @param {Event} event ClipboardEvent.\n   * @private\n   \
*/\n  onCut(event2) {\n    if (!this.hot.isListening() && \
!_classPrivateFieldGet8(this, _isTriggeredByCut) || this.isEditorOpened()) \
{\n      return;\n    }\n    this.setCopyableText();\n    \
_classPrivateFieldSet8(this, _isTriggeredByCut, false);\n    const rangedData \
= this.getRangedData(this.copyableRanges);\n    const allowCuttingOut = \
!!this.hot.runHooks(\"beforeCut\", rangedData, this.copyableRanges);\n    if \
(allowCuttingOut) {\n      const textPlain = stringify2(rangedData);\n      \
if (event2 && event2.clipboardData) {\n        const textHTML = \
_dataToHTML(rangedData, this.hot.rootDocument);\n        \
event2.clipboardData.setData(\"text/plain\", textPlain);\n        \
event2.clipboardData.setData(\"text/html\", [META_HEAD, \
textHTML].join(\"\"));\n      } else if (typeof ClipboardEvent === \
\"undefined\") {\n        this.hot.rootWindow.clipboardData.setData(\"Text\", \
textPlain);\n      }\n      this.hot.emptySelectedCells(\"CopyPaste.cut\");\n \
     this.hot.runHooks(\"afterCut\", rangedData, this.copyableRanges);\n    \
}\n    event2.preventDefault();\n  }\n  /**\n   * `paste` event callback on \
textarea element.\n   *\n   * @param {Event} event ClipboardEvent or pseudo \
ClipboardEvent, if paste was called manually.\n   * @private\n   */\n  \
onPaste(event2) {\n    if (!this.hot.isListening() || this.isEditorOpened()) \
{\n      return;\n    }\n    if (event2 && event2.preventDefault) {\n      \
event2.preventDefault();\n    }\n    let pastedData;\n    if (event2 && \
typeof event2.clipboardData !== \"undefined\") {\n      const textHTML = \
sanitize(event2.clipboardData.getData(\"text/html\"), {\n        ADD_TAGS: \
[\"meta\"],\n        ADD_ATTR: [\"content\"],\n        FORCE_BODY: true\n     \
 });\n      if (textHTML && /(<table)|(<TABLE)/g.test(textHTML)) {\n        \
const parsedConfig = htmlToGridSettings(textHTML, this.hot.rootDocument);\n   \
     pastedData = parsedConfig.data;\n      } else {\n        pastedData = \
event2.clipboardData.getData(\"text/plain\");\n      }\n    } else if (typeof \
ClipboardEvent === \"undefined\" && typeof this.hot.rootWindow.clipboardData \
!== \"undefined\") {\n      pastedData = \
this.hot.rootWindow.clipboardData.getData(\"Text\");\n    }\n    if (typeof \
pastedData === \"string\") {\n      pastedData = parse(pastedData);\n    }\n  \
  if (pastedData && pastedData.length === 0) {\n      return;\n    }\n    if \
(this.hot.runHooks(\"beforePaste\", pastedData, this.copyableRanges) === \
false) {\n      return;\n    }\n    const [startRow, startColumn, endRow, \
endColumn] = this.populateValues(pastedData);\n    \
this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, \
endRow), Math.min(this.hot.countCols() - 1, endColumn));\n    \
this.hot.runHooks(\"afterPaste\", pastedData, this.copyableRanges);\n  }\n  \
/**\n   * Add copy and cut options to the Context Menu.\n   *\n   * \
@private\n   * @param {object} options Contains default added options of the \
Context Menu.\n   */\n  onAfterContextMenuDefaultOptions(options) {\n    \
options.items.push({\n      name: \"---------\"\n    }, copyItem(this));\n    \
if (_classPrivateFieldGet8(this, _enableCopyColumnHeaders)) {\n      \
options.items.push(copyWithColumnHeadersItem(this));\n    }\n    if \
(_classPrivateFieldGet8(this, _enableCopyColumnGroupHeaders)) {\n      \
options.items.push(copyWithColumnGroupHeadersItem(this));\n    }\n    if \
(_classPrivateFieldGet8(this, _enableCopyColumnHeadersOnly)) {\n      \
options.items.push(copyColumnHeadersOnlyItem(this));\n    }\n    \
options.items.push(cutItem(this));\n  }\n  /**\n   * Force focus on \
focusableElement.\n   *\n   * @private\n   */\n  onAfterOnCellMouseUp() {\n   \
 if (!this.hot.isListening() || this.isEditorOpened() || \
this.hot.getSettings().fragmentSelection) {\n      return;\n    }\n    \
this.getOrCreateFocusableElement();\n    this.focusableElement.focus();\n  \
}\n  /**\n   * Force focus on focusableElement after end of the selection.\n  \
 *\n   * @private\n   */\n  onAfterSelectionEnd() {\n    if \
(this.isEditorOpened()) {\n      return;\n    }\n    \
this.getOrCreateFocusableElement();\n    if \
(this.hot.getSettings().fragmentSelection && \
this.focusableElement.getFocusableElement() !== \
this.hot.rootDocument.activeElement && getSelectionText()) {\n      return;\n \
   }\n    this.setCopyableText();\n    this.focusableElement.focus();\n  }\n  \
/**\n   * `beforeKeyDown` listener to force focus of focusableElement.\n   \
*\n   * @private\n   */\n  onBeforeKeyDown() {\n    if \
(!this.hot.isListening() || this.isEditorOpened()) {\n      return;\n    }\n  \
  const activeElement = this.hot.rootDocument.activeElement;\n    const \
activeEditor = this.hot.getActiveEditor();\n    if (!activeEditor || \
activeElement !== this.focusableElement.getFocusableElement() && \
activeElement !== activeEditor.select) {\n      return;\n    }\n    \
this.getOrCreateFocusableElement();\n    this.focusableElement.focus();\n  \
}\n  /**\n   * Destroys the `CopyPaste` plugin instance.\n   */\n  destroy() \
{\n    if (this.focusableElement) {\n      \
destroyElement(this.focusableElement);\n      this.focusableElement = null;\n \
   }\n    super.destroy();\n  }\n};\nfunction _countCopiedHeaders2(ranges) \
{\n  const {\n    rows\n  } = normalizeRanges(ranges);\n  let \
columnHeadersCount = 0;\n  for (let row = 0; row < rows.length; row++) {\n    \
if (rows[row] >= 0) {\n      break;\n    }\n    columnHeadersCount += 1;\n  \
}\n  return {\n    columnHeadersCount\n  };\n}\n\n// \
node_modules/handsontable/plugins/customBorders/utils.mjs\nfunction \
createId(row, col) {\n  return `border_row${row}col${col}`;\n}\nfunction \
createDefaultCustomBorder() {\n  return {\n    width: 1,\n    color: \
\"#000\"\n  };\n}\nfunction createSingleEmptyBorder() {\n  return {\n    \
hide: true\n  };\n}\nfunction createDefaultHtBorder() {\n  return {\n    \
width: 1,\n    color: \"#000\",\n    cornerVisible: false\n  };\n}\nfunction \
normalizeBorder(border) {\n  if (isDefined(border.start) || \
isDefined(border.left)) {\n    var _border$start;\n    border.start = \
(_border$start = border.start) !== null && _border$start !== void 0 ? \
_border$start : border.left;\n  }\n  if (isDefined(border.end) || \
isDefined(border.right)) {\n    var _border$end;\n    border.end = \
(_border$end = border.end) !== null && _border$end !== void 0 ? _border$end : \
border.right;\n  }\n  delete border.left;\n  delete border.right;\n  return \
border;\n}\nfunction denormalizeBorder(border) {\n  if \
(isDefined(border.start)) {\n    border.left = border.start;\n  }\n  if \
(isDefined(border.end)) {\n    border.right = border.end;\n  }\n  return \
border;\n}\nfunction createEmptyBorders(row, col) {\n  return {\n    id: \
createId(row, col),\n    border: createDefaultHtBorder(),\n    row,\n    \
col,\n    top: createSingleEmptyBorder(),\n    bottom: \
createSingleEmptyBorder(),\n    start: createSingleEmptyBorder(),\n    end: \
createSingleEmptyBorder()\n  };\n}\nfunction \
extendDefaultBorder(defaultBorder, customBorder) {\n  if \
(hasOwnProperty(customBorder, \"border\") && customBorder.border) {\n    \
defaultBorder.border = customBorder.border;\n  }\n  if \
(hasOwnProperty(customBorder, \"top\") && isDefined(customBorder.top)) {\n    \
if (customBorder.top) {\n      if (!isObject(customBorder.top)) {\n        \
customBorder.top = createDefaultCustomBorder();\n      }\n      \
defaultBorder.top = customBorder.top;\n    } else {\n      customBorder.top = \
createSingleEmptyBorder();\n      defaultBorder.top = customBorder.top;\n    \
}\n  }\n  if (hasOwnProperty(customBorder, \"bottom\") && \
isDefined(customBorder.bottom)) {\n    if (customBorder.bottom) {\n      if \
(!isObject(customBorder.bottom)) {\n        customBorder.bottom = \
createDefaultCustomBorder();\n      }\n      defaultBorder.bottom = \
customBorder.bottom;\n    } else {\n      customBorder.bottom = \
createSingleEmptyBorder();\n      defaultBorder.bottom = \
customBorder.bottom;\n    }\n  }\n  if (hasOwnProperty(customBorder, \
\"start\") && isDefined(customBorder.start)) {\n    if (customBorder.start) \
{\n      if (!isObject(customBorder.start)) {\n        customBorder.start = \
createDefaultCustomBorder();\n      }\n      defaultBorder.start = \
customBorder.start;\n    } else {\n      customBorder.start = \
createSingleEmptyBorder();\n      defaultBorder.start = customBorder.start;\n \
   }\n  }\n  if (hasOwnProperty(customBorder, \"end\") && \
isDefined(customBorder.end)) {\n    if (customBorder.end) {\n      if \
(!isObject(customBorder.end)) {\n        customBorder.end = \
createDefaultCustomBorder();\n      }\n      defaultBorder.end = \
customBorder.end;\n    } else {\n      customBorder.end = \
createSingleEmptyBorder();\n      defaultBorder.end = customBorder.end;\n    \
}\n  }\n  return defaultBorder;\n}\nfunction checkSelectionBorders(hot2, \
direction) {\n  let atLeastOneHasBorder = false;\n  \
arrayEach(hot2.getSelectedRange(), (range) => {\n    range.forAll((r, c) => \
{\n      if (r < 0 || c < 0) {\n        return;\n      }\n      const \
metaBorders = hot2.getCellMeta(r, c).borders;\n      if (metaBorders) {\n     \
   if (direction) {\n          if (!hasOwnProperty(metaBorders[direction], \
\"hide\") || metaBorders[direction].hide === false) {\n            \
atLeastOneHasBorder = true;\n            return false;\n          }\n        \
} else {\n          atLeastOneHasBorder = true;\n          return false;\n    \
    }\n      }\n    });\n  });\n  return atLeastOneHasBorder;\n}\nfunction \
markSelected(label) {\n  return `<span \
class=\"selected\">${String.fromCharCode(10003)}</span>${label}`;\n}\nfunctio\
n hasLeftRightTypeOptions(borders) {\n  return borders.some((border) => \
isDefined(border.left) || isDefined(border.right));\n}\nfunction \
hasStartEndTypeOptions(borders) {\n  return borders.some((border) => \
isDefined(border.start) || isDefined(border.end));\n}\nvar \
physicalToInlinePropNames = /* @__PURE__ */ new Map([[\"left\", \"start\"], \
[\"right\", \"end\"]]);\nfunction toInlinePropName(propName) {\n  var \
_physicalToInlineProp;\n  return (_physicalToInlineProp = \
physicalToInlinePropNames.get(propName)) !== null && _physicalToInlineProp \
!== void 0 ? _physicalToInlineProp : propName;\n}\n\n// \
node_modules/handsontable/plugins/customBorders/contextMenuItem/bottom.mjs\nf\
unction bottom(customBordersPlugin) {\n  return {\n    key: \
\"borders:bottom\",\n    name() {\n      let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_BOTTOM);\n      const \
hasBorder = checkSelectionBorders(this, \"bottom\");\n      if (hasBorder) \
{\n        label = markSelected(label);\n      }\n      return label;\n    \
},\n    callback(key, selected) {\n      const hasBorder = \
checkSelectionBorders(this, \"bottom\");\n      \
customBordersPlugin.prepareBorder(selected, \"bottom\", hasBorder);\n    }\n  \
};\n}\n\n// \
node_modules/handsontable/plugins/customBorders/contextMenuItem/left.mjs\nfun\
ction left(customBordersPlugin) {\n  const borderDirection = \
customBordersPlugin.hot.isRtl() ? \"end\" : \"start\";\n  return {\n    key: \
\"borders:left\",\n    name() {\n      let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_LEFT);\n      const \
hasBorder = checkSelectionBorders(this, borderDirection);\n      if \
(hasBorder) {\n        label = markSelected(label);\n      }\n      return \
label;\n    },\n    callback(key, selected) {\n      const hasBorder = \
checkSelectionBorders(this, borderDirection);\n      \
customBordersPlugin.prepareBorder(selected, borderDirection, hasBorder);\n    \
}\n  };\n}\n\n// \
node_modules/handsontable/plugins/customBorders/contextMenuItem/noBorders.mjs\
\nfunction noBorders(customBordersPlugin) {\n  return {\n    key: \
\"borders:no_borders\",\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_BORDERS);\n    },\n    \
callback(key, selected) {\n      customBordersPlugin.prepareBorder(selected, \
\"noBorders\");\n    },\n    disabled() {\n      return \
!checkSelectionBorders(this);\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/customBorders/contextMenuItem/right.mjs\nfu\
nction right(customBordersPlugin) {\n  const borderDirection = \
customBordersPlugin.hot.isRtl() ? \"start\" : \"end\";\n  return {\n    key: \
\"borders:right\",\n    name() {\n      let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_RIGHT);\n      const \
hasBorder = checkSelectionBorders(this, borderDirection);\n      if \
(hasBorder) {\n        label = markSelected(label);\n      }\n      return \
label;\n    },\n    callback(key, selected) {\n      const hasBorder = \
checkSelectionBorders(this, borderDirection);\n      \
customBordersPlugin.prepareBorder(selected, borderDirection, hasBorder);\n    \
}\n  };\n}\n\n// \
node_modules/handsontable/plugins/customBorders/contextMenuItem/top.mjs\nfunc\
tion top(customBordersPlugin) {\n  return {\n    key: \"borders:top\",\n    \
name() {\n      let label = \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_TOP);\n      const \
hasBorder = checkSelectionBorders(this, \"top\");\n      if (hasBorder) {\n   \
     label = markSelected(label);\n      }\n      return label;\n    },\n    \
callback(key, selected) {\n      const hasBorder = \
checkSelectionBorders(this, \"top\");\n      \
customBordersPlugin.prepareBorder(selected, \"top\", hasBorder);\n    }\n  \
};\n}\n\n// \
node_modules/handsontable/plugins/customBorders/customBorders.mjs\nfunction \
_defineProperty19(obj, key, value) {\n  key = _toPropertyKey19(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey19(arg) {\n  var key = \
_toPrimitive19(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive19(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar PLUGIN_KEY12 = \"customBorders\";\nvar \
PLUGIN_PRIORITY11 = 90;\nvar CustomBorders = class extends BasePlugin {\n  \
constructor() {\n    super(...arguments);\n    _defineProperty19(this, \
\"savedBorders\", []);\n  }\n  static get PLUGIN_KEY() {\n    return \
PLUGIN_KEY12;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY11;\n  }\n  /**\n   * Checks if the plugin is enabled in the \
handsontable settings. This method is executed in {@link Hooks#beforeInit}\n  \
 * hook and if it returns `true` then the {@link CustomBorders#enablePlugin} \
method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    \
return !!this.hot.getSettings()[PLUGIN_KEY12];\n  }\n  /**\n   * Enables the \
plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() \
{\n    if (this.enabled) {\n      return;\n    }\n    \
this.addHook(\"afterContextMenuDefaultOptions\", (options) => \
this.onAfterContextMenuDefaultOptions(options));\n    this.addHook(\"init\", \
() => this.onAfterInit());\n    super.enablePlugin();\n  }\n  /**\n   * \
Disables the plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    this.hideBorders();\n    super.disablePlugin();\n  }\n \
 /**\n   * Updates the plugin's state.\n   *\n   * This method is executed \
when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any \
of the following configuration options:\n   *  - \
[`customBorders`](@/api/options.md#customborders)\n   */\n  updatePlugin() \
{\n    this.disablePlugin();\n    this.enablePlugin();\n    \
this.changeBorderSettings();\n    super.updatePlugin();\n  }\n  /**\n   * Set \
custom borders.\n   *\n   * @example\n   * ```js\n   * const \
customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an \
array of arrays (produced by `.getSelected()` method).\n   * \
customBordersPlugin.setBorders([[1, 1, 2, 2], [6, 2, 0, 2]], {start: {width: \
2, color: 'blue'}});\n   *\n   * // Using an array of CellRange objects \
(produced by `.getSelectedRange()` method).\n   * //  Selecting a cell \
range.\n   * hot.selectCell(0, 0, 2, 2);\n   * // Returning selected cells' \
range with the getSelectedRange method.\n   * \
customBordersPlugin.setBorders(hot.getSelectedRange(), {start: {hide: false, \
width: 2, color: 'blue'}});\n   * ```\n   *\n   * @param \
{Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * @param \
{object} borderObject Object with `top`, `right`, `bottom` and `start` \
properties.\n   */\n  setBorders(selectionRanges, borderObject) {\n    let \
borderKeys = [\"top\", \"bottom\", \"start\", \"end\"];\n    let normBorder = \
null;\n    if (borderObject) {\n      \
this.checkSettingsCohesion([borderObject]);\n      borderKeys = \
Object.keys(borderObject);\n      normBorder = \
normalizeBorder(borderObject);\n    }\n    const selectionType = \
detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = \
normalizeSelectionFactory(selectionType);\n    arrayEach(selectionRanges, \
(selection) => {\n      const [rowStart, columnStart, rowEnd, columnEnd] = \
selectionSchemaNormalizer(selection);\n      for (let row = rowStart; row <= \
rowEnd; row += 1) {\n        for (let col = columnStart; col <= columnEnd; \
col += 1) {\n          arrayEach(borderKeys, (borderKey) => {\n            \
this.prepareBorderFromCustomAdded(row, col, normBorder, \
toInlinePropName(borderKey));\n          });\n        }\n      }\n    });\n   \
 this.hot.view.render();\n  }\n  /**\n   * Get custom borders.\n   *\n   * \
@example\n   * ```js\n   * const customBordersPlugin = \
hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays \
(produced by `.getSelected()` method).\n   * \
customBordersPlugin.getBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // Using \
an array of CellRange objects (produced by `.getSelectedRange()` method).\n   \
* customBordersPlugin.getBorders(hot.getSelectedRange());\n   * // Using \
without param - return all customBorders.\n   * \
customBordersPlugin.getBorders();\n   * ```\n   *\n   * @param \
{Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * \
@returns {object[]} Returns array of border objects.\n   */\n  \
getBorders(selectionRanges) {\n    if (!Array.isArray(selectionRanges)) {\n   \
   return this.savedBorders;\n    }\n    const selectionType = \
detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = \
normalizeSelectionFactory(selectionType);\n    const selectedBorders = [];\n  \
  arrayEach(selectionRanges, (selection) => {\n      const [rowStart, \
columnStart, rowEnd, columnEnd] = selectionSchemaNormalizer(selection);\n     \
 for (let row = rowStart; row <= rowEnd; row += 1) {\n        for (let col = \
columnStart; col <= columnEnd; col += 1) {\n          \
arrayEach(this.savedBorders, (border) => {\n            if (border.row === \
row && border.col === col) {\n              \
selectedBorders.push(denormalizeBorder(border));\n            }\n          \
});\n        }\n      }\n    });\n    return selectedBorders;\n  }\n  /**\n   \
* Clear custom borders.\n   *\n   * @example\n   * ```js\n   * const \
customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an \
array of arrays (produced by `.getSelected()` method).\n   * \
customBordersPlugin.clearBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // \
Using an array of CellRange objects (produced by `.getSelectedRange()` \
method).\n   * customBordersPlugin.clearBorders(hot.getSelectedRange());\n   \
* // Using without param - clear all customBorders.\n   * \
customBordersPlugin.clearBorders();\n   * ```\n   *\n   * @param \
{Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   */\n  \
clearBorders(selectionRanges) {\n    if (selectionRanges) {\n      \
this.setBorders(selectionRanges);\n    } else {\n      \
arrayEach(this.savedBorders, (border) => {\n        \
this.clearBordersFromSelectionSettings(border.id);\n        \
this.clearNullCellRange();\n        this.hot.removeCellMeta(border.row, \
border.col, \"borders\");\n      });\n      this.savedBorders.length = 0;\n   \
 }\n  }\n  /**\n   * Insert WalkontableSelection instance into Walkontable \
settings.\n   *\n   * @private\n   * @param {object} border Object with `row` \
and `col`, `start`, `end`, `top` and `bottom`, `id` and `border` ({Object} \
with `color`, `width` and `cornerVisible` property) properties.\n   * @param \
{string} [place] Coordinate where add/remove border - `top`, `bottom`, \
`start`, `end`.\n   */\n  insertBorderIntoSettings(border, place) {\n    \
const hasSavedBorders = this.checkSavedBorders(border);\n    if \
(!hasSavedBorders) {\n      this.savedBorders.push(border);\n    }\n    const \
visualCellRange = \
this.hot._createCellRange(this.hot._createCellCoords(border.row, \
border.col));\n    const hasCustomSelections = \
this.checkCustomSelections(border, visualCellRange, place);\n    if \
(!hasCustomSelections) {\n      \
this.hot.selection.highlight.addCustomSelection({\n        border,\n        \
visualCellRange\n      });\n    }\n  }\n  /**\n   * Prepare borders from \
setting (single cell).\n   *\n   * @private\n   * @param {number} row Visual \
row index.\n   * @param {number} column Visual column index.\n   * @param \
{object} borderDescriptor Object with `row` and `col`, `start`, `end`, `top` \
and `bottom` properties.\n   * @param {string} [place] Coordinate where \
add/remove border - `top`, `bottom`, `start`, `end`.\n   */\n  \
prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {\n    \
const nrOfRows = this.hot.countRows();\n    const nrOfColumns = \
this.hot.countCols();\n    if (row >= nrOfRows || column >= nrOfColumns) {\n  \
    return;\n    }\n    let border = createEmptyBorders(row, column);\n    if \
(borderDescriptor) {\n      border = extendDefaultBorder(border, \
borderDescriptor);\n      \
arrayEach(this.hot.selection.highlight.customSelections, (customSelection) => \
{\n        if (border.id === customSelection.settings.id) {\n          \
Object.assign(customSelection.settings, borderDescriptor);\n          \
border.id = customSelection.settings.id;\n          border.top = \
customSelection.settings.top;\n          border.bottom = \
customSelection.settings.bottom;\n          border.start = \
customSelection.settings.start;\n          border.end = \
customSelection.settings.end;\n          return false;\n        }\n      \
});\n    }\n    this.hot.setCellMeta(row, column, \"borders\", \
denormalizeBorder(border));\n    this.insertBorderIntoSettings(border, \
place);\n  }\n  /**\n   * Prepare borders from setting (object).\n   *\n   * \
@private\n   * @param {object} range {CellRange} The CellRange object.\n   * \
@param {object} customBorder Object with `start`, `end`, `top` and `bottom` \
properties.\n   */\n  prepareBorderFromCustomAddedRange(range, customBorder) \
{\n    const lastRowIndex = Math.min(range.to.row, this.hot.countRows() - \
1);\n    const lastColumnIndex = Math.min(range.to.col, this.hot.countCols() \
- 1);\n    rangeEach(range.from.row, lastRowIndex, (rowIndex) => {\n      \
rangeEach(range.from.col, lastColumnIndex, (colIndex) => {\n        const \
border = createEmptyBorders(rowIndex, colIndex);\n        let add = 0;\n      \
  if (rowIndex === range.from.row) {\n          if \
(hasOwnProperty(customBorder, \"top\")) {\n            add += 1;\n            \
border.top = customBorder.top;\n          }\n        }\n        if (rowIndex \
=== range.to.row) {\n          if (hasOwnProperty(customBorder, \"bottom\")) \
{\n            add += 1;\n            border.bottom = customBorder.bottom;\n  \
        }\n        }\n        if (colIndex === range.from.col) {\n          \
if (hasOwnProperty(customBorder, \"start\")) {\n            add += 1;\n       \
     border.start = customBorder.start;\n          }\n        }\n        if \
(colIndex === range.to.col) {\n          if (hasOwnProperty(customBorder, \
\"end\")) {\n            add += 1;\n            border.end = \
customBorder.end;\n          }\n        }\n        if (add > 0) {\n          \
this.hot.setCellMeta(rowIndex, colIndex, \"borders\", \
denormalizeBorder(border));\n          \
this.insertBorderIntoSettings(border);\n        } else {\n        }\n      \
});\n    });\n  }\n  /**\n   * Remove border (triggered from context menu).\n \
  *\n   * @private\n   * @param {number} row Visual row index.\n   * @param \
{number} column Visual column index.\n   */\n  removeAllBorders(row, column) \
{\n    const borderId = createId(row, column);\n    \
this.spliceBorder(borderId);\n    \
this.clearBordersFromSelectionSettings(borderId);\n    \
this.clearNullCellRange();\n    this.hot.removeCellMeta(row, column, \
\"borders\");\n  }\n  /**\n   * Set borders for each cell re. To border \
position.\n   *\n   * @private\n   * @param {number} row Visual row index.\n  \
 * @param {number} column Visual column index.\n   * @param {string} place \
Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and \
`noBorders`.\n   * @param {boolean} remove True when remove borders, and \
false when add borders.\n   */\n  setBorder(row, column, place, remove) {\n   \
 let bordersMeta = this.hot.getCellMeta(row, column).borders;\n    if \
(!bordersMeta || bordersMeta.border === void 0) {\n      bordersMeta = \
createEmptyBorders(row, column);\n    } else {\n      bordersMeta = \
normalizeBorder(bordersMeta);\n    }\n    if (remove) {\n      \
bordersMeta[place] = createSingleEmptyBorder();\n      const hideCount = \
this.countHide(bordersMeta);\n      if (hideCount === 4) {\n        \
this.removeAllBorders(row, column);\n      } else {\n        const \
customSelectionsChecker = \
this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n      \
  if (!customSelectionsChecker) {\n          \
this.insertBorderIntoSettings(bordersMeta);\n        }\n        \
this.hot.setCellMeta(row, column, \"borders\", \
denormalizeBorder(bordersMeta));\n      }\n    } else {\n      \
bordersMeta[place] = createDefaultCustomBorder();\n      const \
customSelectionsChecker = \
this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n      \
if (!customSelectionsChecker) {\n        \
this.insertBorderIntoSettings(bordersMeta);\n      }\n      \
this.hot.setCellMeta(row, column, \"borders\", \
denormalizeBorder(bordersMeta));\n    }\n  }\n  /**\n   * Prepare borders \
based on cell and border position.\n   *\n   * @private\n   * @param \
{CellRange[]} selected An array of CellRange objects.\n   * @param {string} \
place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` \
and `noBorders`.\n   * @param {boolean} remove True when remove borders, and \
false when add borders.\n   */\n  prepareBorder(selected, place, remove) {\n  \
  arrayEach(selected, (_ref) => {\n      let {\n        start,\n        end\n \
     } = _ref;\n      if (start.row === end.row && start.col === end.col) {\n \
       if (place === \"noBorders\") {\n          \
this.removeAllBorders(start.row, start.col);\n        } else {\n          \
this.setBorder(start.row, start.col, place, remove);\n        }\n      } else \
{\n        switch (place) {\n          case \"noBorders\":\n            \
rangeEach(start.col, end.col, (colIndex) => {\n              \
rangeEach(start.row, end.row, (rowIndex) => {\n                \
this.removeAllBorders(rowIndex, colIndex);\n              });\n            \
});\n            break;\n          case \"top\":\n            \
rangeEach(start.col, end.col, (topCol) => {\n              \
this.setBorder(start.row, topCol, place, remove);\n            });\n          \
  break;\n          case \"bottom\":\n            rangeEach(start.col, \
end.col, (bottomCol) => {\n              this.setBorder(end.row, bottomCol, \
place, remove);\n            });\n            break;\n          case \
\"start\":\n            rangeEach(start.row, end.row, (rowStart) => {\n       \
       this.setBorder(rowStart, start.col, place, remove);\n            });\n \
           break;\n          case \"end\":\n            rangeEach(start.row, \
end.row, (rowEnd) => {\n              this.setBorder(rowEnd, end.col, place, \
remove);\n            });\n            break;\n          default:\n           \
 break;\n        }\n      }\n    });\n  }\n  /**\n   * Create borders from \
settings.\n   *\n   * @private\n   * @param {Array} customBorders Object with \
`row` and `col`, `start`, `end`, `top` and `bottom` properties.\n   */\n  \
createCustomBorders(customBorders) {\n    arrayEach(customBorders, \
(customBorder) => {\n      const normCustomBorder = \
normalizeBorder(customBorder);\n      if (customBorder.range) {\n        \
this.prepareBorderFromCustomAddedRange(customBorder.range, \
normCustomBorder);\n      } else {\n        \
this.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, \
normCustomBorder);\n      }\n    });\n  }\n  /**\n   * Count hide property in \
border object.\n   *\n   * @private\n   * @param {object} border Object with \
`row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *           \
             `border` ({Object} with `color`, `width` and `cornerVisible` \
property) properties.\n   * @returns {number}\n   */\n  countHide(border) {\n \
   const {\n      top: top2,\n      bottom: bottom2,\n      start,\n      \
end\n    } = border;\n    const values = [top2, bottom2, start, end];\n    \
return arrayReduce(values, (accumulator, value) => {\n      let result = \
accumulator;\n      if (value && value.hide) {\n        result += 1;\n      \
}\n      return result;\n    }, 0);\n  }\n  /**\n   * Clear borders settings \
from custom selections.\n   *\n   * @private\n   * @param {string} borderId \
Border id name as string.\n   */\n  \
clearBordersFromSelectionSettings(borderId) {\n    const index2 = \
arrayMap(this.hot.selection.highlight.customSelections, (customSelection) => \
customSelection.settings.id).indexOf(borderId);\n    if (index2 > -1) {\n     \
 this.hot.selection.highlight.customSelections[index2].clear();\n    }\n  }\n \
 /**\n   * Clear cellRange with null value.\n   *\n   * @private\n   */\n  \
clearNullCellRange() {\n    \
arrayEach(this.hot.selection.highlight.customSelections, (customSelection, \
index2) => {\n      if (customSelection.cellRange === null) {\n        \
this.hot.selection.highlight.customSelections[index2].destroy();\n        \
this.hot.selection.highlight.customSelections.splice(index2, 1);\n        \
return false;\n      }\n    });\n  }\n  /**\n   * Hide custom borders.\n   \
*\n   * @private\n   */\n  hideBorders() {\n    arrayEach(this.savedBorders, \
(border) => {\n      this.clearBordersFromSelectionSettings(border.id);\n     \
 this.clearNullCellRange();\n    });\n  }\n  /**\n   * Splice border from \
savedBorders.\n   *\n   * @private\n   * @param {string} borderId Border id \
name as string.\n   */\n  spliceBorder(borderId) {\n    const index2 = \
arrayMap(this.savedBorders, (border) => border.id).indexOf(borderId);\n    if \
(index2 > -1) {\n      this.savedBorders.splice(index2, 1);\n    }\n  }\n  \
/**\n   * Check if an border already exists in the savedBorders array, and if \
true update border in savedBorders.\n   *\n   * @private\n   * @param \
{object} border Object with `row` and `col`, `start`, `end`, `top` and \
`bottom`, `id` and\n   *                        `border` ({Object} with \
`color`, `width` and `cornerVisible` property) properties.\n   *\n   * \
@returns {boolean}\n   */\n  checkSavedBorders(border) {\n    let check = \
false;\n    const hideCount = this.countHide(border);\n    if (hideCount === \
4) {\n      this.spliceBorder(border.id);\n      check = true;\n    } else \
{\n      arrayEach(this.savedBorders, (savedBorder, index2) => {\n        if \
(border.id === savedBorder.id) {\n          this.savedBorders[index2] = \
border;\n          check = true;\n          return false;\n        }\n      \
});\n    }\n    return check;\n  }\n  /**\n   * Check if an border already \
exists in the customSelections, and if true call toggleHiddenClass method.\n  \
 *\n   * @private\n   * @param {object} border Object with `row` and `col`, \
`start`, `end`, `top` and `bottom`, `id` and\n   *                        \
`border` ({Object} with `color`, `width` and `cornerVisible` property) \
properties.\n   * @param {string} place Coordinate where add/remove border - \
`top`, `bottom`, `start`, `end` and `noBorders`.\n   * @param {boolean} \
remove True when remove borders, and false when add borders.\n   *\n   * \
@returns {boolean}\n   */\n  checkCustomSelectionsFromContextMenu(border, \
place, remove) {\n    let check = false;\n    \
arrayEach(this.hot.selection.highlight.customSelections, (customSelection) => \
{\n      if (border.id === customSelection.settings.id) {\n        \
objectEach(customSelection.instanceBorders, (borderObject) => {\n          \
borderObject.toggleHiddenClass(place, remove);\n        });\n        check = \
true;\n        return false;\n      }\n    });\n    return check;\n  }\n  \
/**\n   * Check if an border already exists in the customSelections, and if \
true reset cellRange.\n   *\n   * @private\n   * @param {object} border \
Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   \
*                        `border` ({Object} with `color`, `width` and \
`cornerVisible` property) properties.\n   * @param {CellRange} cellRange The \
selection range to check.\n   * @param {string} [place] Coordinate where \
add/remove border - `top`, `bottom`, `start`, `end`.\n   * @returns \
{boolean}\n   */\n  checkCustomSelections(border, cellRange, place) {\n    \
const hideCount = this.countHide(border);\n    let check = false;\n    if \
(hideCount === 4) {\n      this.removeAllBorders(border.row, border.col);\n   \
   check = true;\n    } else {\n      \
arrayEach(this.hot.selection.highlight.customSelections, (customSelection) => \
{\n        if (border.id === customSelection.settings.id) {\n          \
customSelection.visualCellRange = cellRange;\n          \
customSelection.commit();\n          if (place) {\n            \
objectEach(customSelection.instanceBorders, (borderObject) => {\n             \
 borderObject.changeBorderStyle(place, border);\n            });\n          \
}\n          check = true;\n          return false;\n        }\n      });\n   \
 }\n    return check;\n  }\n  /**\n   * Change borders from settings.\n   *\n \
  * @private\n   */\n  changeBorderSettings() {\n    const customBorders = \
this.hot.getSettings()[PLUGIN_KEY12];\n    if (Array.isArray(customBorders)) \
{\n      const bordersClone = deepClone(customBorders);\n      \
this.checkSettingsCohesion(bordersClone);\n      if (!bordersClone.length) \
{\n        this.savedBorders = bordersClone;\n      }\n      \
this.createCustomBorders(bordersClone);\n    } else if (customBorders !== \
void 0) {\n      this.createCustomBorders(this.savedBorders);\n    }\n  }\n  \
/**\n   * Checks the settings cohesion. The properties such like \
\"left\"/\"right\" are supported only\n   * in the LTR mode and the \
\"left\"/\"right\" options can not be used together with \"start\"/\"end\" \
properties.\n   *\n   * @private\n   * @param {object[]} customBorders The \
user defined custom border objects array.\n   */\n  \
checkSettingsCohesion(customBorders) {\n    const hasLeftOrRight = \
hasLeftRightTypeOptions(customBorders);\n    const hasStartOrEnd = \
hasStartEndTypeOptions(customBorders);\n    if (hasLeftOrRight && \
hasStartOrEnd) {\n      throw new Error('The \"left\"/\"right\" and \
\"start\"/\"end\" options should not be used together. Please use only the \
option \"start\"/\"end\".');\n    }\n    if (this.hot.isRtl() && \
hasLeftOrRight) {\n      throw new Error('The \"left\"/\"right\" properties \
are not supported for RTL. Please use option \"start\"/\"end\".');\n    }\n  \
}\n  /**\n   * Add border options to context menu.\n   *\n   * @private\n   * \
@param {object} defaultOptions Context menu items.\n   */\n  \
onAfterContextMenuDefaultOptions(defaultOptions) {\n    if \
(!this.hot.getSettings()[PLUGIN_KEY12]) {\n      return;\n    }\n    \
defaultOptions.items.push({\n      name: \"---------\"\n    }, {\n      key: \
\"borders\",\n      name() {\n        return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS);\n      },\n      \
disabled() {\n        return this.selection.isSelectedByCorner();\n      },\n \
     submenu: {\n        items: [top(this), right(this), bottom(this), \
left(this), noBorders(this)]\n      }\n    });\n  }\n  /**\n   * `afterInit` \
hook callback.\n   *\n   * @private\n   */\n  onAfterInit() {\n    \
this.changeBorderSettings();\n  }\n  /**\n   * Destroys the plugin \
instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/dragToScroll/dragToScroll.mjs\nvar \
PLUGIN_KEY13 = \"dragToScroll\";\nvar PLUGIN_PRIORITY12 = 100;\nvar \
DragToScroll = class extends BasePlugin {\n  static get PLUGIN_KEY() {\n    \
return PLUGIN_KEY13;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY12;\n  }\n  constructor(hotInstance) {\n    \
super(hotInstance);\n    this.eventManager = new \
eventManager_default(this);\n    this.boundaries = null;\n    this.callback = \
null;\n    this.listening = false;\n  }\n  /**\n   * Checks if the plugin is \
enabled in the handsontable settings. This method is executed in {@link \
Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link \
DragToScroll#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n \
  */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY13];\n  \
}\n  /**\n   * Enables the plugin functionality for this Handsontable \
instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      \
return;\n    }\n    this.addHook(\"afterOnCellMouseDown\", (event2) => \
this.setupListening(event2));\n    \
this.addHook(\"afterOnCellCornerMouseDown\", (event2) => \
this.setupListening(event2));\n    this.registerEvents();\n    \
super.enablePlugin();\n  }\n  /**\n   * Updates the plugin's state.\n   *\n   \
* This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`dragToScroll`](@/api/options.md#dragtoscroll)\n   */\n  updatePlugin() {\n  \
  this.disablePlugin();\n    this.enablePlugin();\n    \
super.updatePlugin();\n  }\n  /**\n   * Disables the plugin functionality for \
this Handsontable instance.\n   */\n  disablePlugin() {\n    \
this.unregisterEvents();\n    super.disablePlugin();\n  }\n  /**\n   * Sets \
the value of the visible element.\n   *\n   * @param {DOMRect} boundaries An \
object with coordinates compatible with DOMRect.\n   */\n  \
setBoundaries(boundaries) {\n    this.boundaries = boundaries;\n  }\n  /**\n  \
 * Changes callback function.\n   *\n   * @param {Function} callback The \
callback function.\n   */\n  setCallback(callback) {\n    this.callback = \
callback;\n  }\n  /**\n   * Checks if the mouse position (X, Y) is outside of \
the viewport and fires a callback with calculated X an Y diffs\n   * between \
passed boundaries.\n   *\n   * @param {number} x Mouse X coordinate to \
check.\n   * @param {number} y Mouse Y coordinate to check.\n   */\n  \
check(x, y) {\n    let diffX = 0;\n    let diffY = 0;\n    if (y < \
this.boundaries.top) {\n      diffY = y - this.boundaries.top;\n    } else if \
(y > this.boundaries.bottom) {\n      diffY = y - this.boundaries.bottom;\n   \
 }\n    if (x < this.boundaries.left) {\n      diffX = x - \
this.boundaries.left;\n    } else if (x > this.boundaries.right) {\n      \
diffX = x - this.boundaries.right;\n    }\n    this.callback(diffX, diffY);\n \
 }\n  /**\n   * Enables listening on `mousemove` event.\n   *\n   * \
@private\n   */\n  listen() {\n    this.listening = true;\n  }\n  /**\n   * \
Disables listening on `mousemove` event.\n   *\n   * @private\n   */\n  \
unlisten() {\n    this.listening = false;\n  }\n  /**\n   * Returns current \
state of listening.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  \
isListening() {\n    return this.listening;\n  }\n  /**\n   * Registers dom \
listeners.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n   \
   rootWindow\n    } = this.hot;\n    let frame = rootWindow;\n    while \
(frame) {\n      this.eventManager.addEventListener(frame.document, \
\"contextmenu\", () => this.unlisten());\n      \
this.eventManager.addEventListener(frame.document, \"mouseup\", () => \
this.unlisten());\n      this.eventManager.addEventListener(frame.document, \
\"mousemove\", (event2) => this.onMouseMove(event2));\n      frame = \
getParentWindow(frame);\n    }\n  }\n  /**\n   * Unbinds the events used by \
the plugin.\n   *\n   * @private\n   */\n  unregisterEvents() {\n    \
this.eventManager.clear();\n  }\n  /**\n   * On after on cell/cellCorner \
mouse down listener.\n   *\n   * @private\n   * @param {MouseEvent} event The \
mouse event object.\n   */\n  setupListening(event2) {\n    if \
(isRightClick(event2)) {\n      return;\n    }\n    const scrollHandler = \
this.hot.view._wt.wtTable.holder;\n    if (scrollHandler === \
this.hot.rootWindow) {\n      return;\n    }\n    \
this.setBoundaries(scrollHandler.getBoundingClientRect());\n    \
this.setCallback((scrollX, scrollY) => {\n      if (scrollX < 0) {\n        \
scrollHandler.scrollLeft -= 50;\n      } else if (scrollX > 0) {\n        \
scrollHandler.scrollLeft += 50;\n      }\n      if (scrollY < 0) {\n        \
scrollHandler.scrollTop -= 20;\n      } else if (scrollY > 0) {\n        \
scrollHandler.scrollTop += 20;\n      }\n    });\n    this.listen();\n  }\n  \
/**\n   * 'mouseMove' event callback.\n   *\n   * @private\n   * @param \
{MouseEvent} event `mousemove` event properties.\n   */\n  \
onMouseMove(event2) {\n    if (!this.isListening()) {\n      return;\n    }\n \
   this.check(event2.clientX, event2.clientY);\n  }\n  /**\n   * Destroys the \
plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/dropdownMenu/dropdownMenu.mjs\npluginHooks_\
default.getSingleton().register(\"afterDropdownMenuDefaultOptions\");\nplugin\
Hooks_default.getSingleton().register(\"beforeDropdownMenuShow\");\npluginHoo\
ks_default.getSingleton().register(\"afterDropdownMenuShow\");\npluginHooks_d\
efault.getSingleton().register(\"afterDropdownMenuHide\");\npluginHooks_defau\
lt.getSingleton().register(\"afterDropdownMenuExecute\");\nvar PLUGIN_KEY14 = \
\"dropdownMenu\";\nvar PLUGIN_PRIORITY13 = 230;\nvar BUTTON_CLASS_NAME = \
\"changeType\";\nvar DropdownMenu = class _DropdownMenu extends BasePlugin \
{\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY14;\n  }\n  static get \
PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY13;\n  }\n  static get \
PLUGIN_DEPS() {\n    return [\"plugin:AutoColumnSize\"];\n  }\n  /**\n   * \
Default menu items order when `dropdownMenu` is enabled by setting the config \
item to `true`.\n   *\n   * @returns {Array}\n   */\n  static get \
DEFAULT_ITEMS() {\n    return [KEY4, KEY5, KEY, KEY8, KEY, KEY3, KEY, KEY6, \
KEY, KEY2];\n  }\n  constructor(hotInstance) {\n    super(hotInstance);\n    \
this.eventManager = new eventManager_default(this);\n    this.commandExecutor \
= new commandExecutor_default(this.hot);\n    this.itemsFactory = null;\n    \
this.menu = null;\n    this.hot.addHook(\"afterGetColHeader\", (col, TH) => \
this.onAfterGetColHeader(col, TH));\n  }\n  /**\n   * Checks if the plugin is \
enabled in the handsontable settings. This method is executed in {@link \
Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link \
DropdownMenu#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n \
  */\n  isEnabled() {\n    return this.hot.getSettings()[PLUGIN_KEY14];\n  \
}\n  /**\n   * Enables the plugin functionality for this Handsontable \
instance.\n   *\n   * @fires Hooks#afterDropdownMenuDefaultOptions\n   * \
@fires Hooks#beforeDropdownMenuSetItems\n   */\n  enablePlugin() {\n    var \
_this = this;\n    if (this.enabled) {\n      return;\n    }\n    \
this.itemsFactory = new itemsFactory_default(this.hot, \
_DropdownMenu.DEFAULT_ITEMS);\n    const settings = \
this.hot.getSettings()[PLUGIN_KEY14];\n    const predefinedItems2 = {\n      \
items: this.itemsFactory.getItems(settings)\n    };\n    \
this.registerEvents();\n    if (typeof settings.callback === \"function\") \
{\n      this.commandExecutor.setCommonCallback(settings.callback);\n    }\n  \
  super.enablePlugin();\n    this.callOnPluginsReady(() => {\n      \
this.hot.runHooks(\"afterDropdownMenuDefaultOptions\", predefinedItems2);\n   \
   this.itemsFactory.setPredefinedItems(predefinedItems2.items);\n      const \
menuItems = this.itemsFactory.getItems(settings);\n      if (this.menu) {\n   \
     this.menu.destroy();\n      }\n      this.menu = new \
menu_default(this.hot, {\n        className: \"htDropdownMenu\",\n        \
keepInViewport: true,\n        container: settings.uiContainer || \
this.hot.rootDocument.body\n      });\n      \
this.hot.runHooks(\"beforeDropdownMenuSetItems\", menuItems);\n      \
this.menu.setMenuItems(menuItems);\n      \
this.menu.addLocalHook(\"beforeOpen\", () => this.onMenuBeforeOpen());\n      \
this.menu.addLocalHook(\"afterOpen\", () => this.onMenuAfterOpen());\n      \
this.menu.addLocalHook(\"afterClose\", () => this.onMenuAfterClose());\n      \
this.menu.addLocalHook(\"executeCommand\", function() {\n        for (var \
_len = arguments.length, params = new Array(_len), _key = 0; _key < _len; \
_key++) {\n          params[_key] = arguments[_key];\n        }\n        \
return _this.executeCommand.call(_this, ...params);\n      });\n      \
arrayEach(menuItems, (command) => \
this.commandExecutor.registerCommand(command.key, command));\n    });\n  }\n  \
/**\n   * Updates the plugin's state.\n   *\n   * This method is executed \
when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any \
of the following configuration options:\n   *  - \
[`dropdownMenu`](@/api/options.md#dropdownmenu)\n   */\n  updatePlugin() {\n  \
  this.disablePlugin();\n    this.enablePlugin();\n    \
super.updatePlugin();\n  }\n  /**\n   * Disables the plugin functionality for \
this Handsontable instance.\n   */\n  disablePlugin() {\n    this.close();\n  \
  if (this.menu) {\n      this.menu.destroy();\n    }\n    \
super.disablePlugin();\n  }\n  /**\n   * Registers the DOM listeners.\n   *\n \
  * @private\n   */\n  registerEvents() {\n    \
this.eventManager.addEventListener(this.hot.rootElement, \"click\", (event2) \
=> this.onTableClick(event2));\n  }\n  /**\n   * Opens menu and re-position \
it based on the passed coordinates.\n   *\n   * @param {object|Event} \
position An object with `pageX` and `pageY` properties which contains values \
relative to\n   *                                the top left of the fully \
rendered content area in the browser or with `clientX`\n   *                  \
              and `clientY`  properties which contains values relative to the \
upper left edge\n   *                                of the content area (the \
viewport) of the browser window. This object is structurally\n   *            \
                    compatible with native mouse event so it can be used \
either.\n   * @fires Hooks#beforeDropdownMenuShow\n   * @fires \
Hooks#afterDropdownMenuShow\n   */\n  open(position) {\n    if (!this.menu) \
{\n      return;\n    }\n    this.menu.open();\n    if (position.width) {\n   \
   this.menu.setOffset(\"left\", position.width);\n    }\n    \
this.menu.setPosition(position);\n  }\n  /**\n   * Closes dropdown menu.\n   \
*/\n  close() {\n    if (!this.menu) {\n      return;\n    }\n    \
this.menu.close();\n  }\n  /**\n   * Executes context menu command.\n   *\n   \
* The `executeCommand()` method works only for selected cells.\n   *\n   * \
When no cells are selected, `executeCommand()` doesn't do anything.\n   *\n   \
* You can execute all predefined commands:\n   *  * `'row_above'` - Insert \
row above\n   *  * `'row_below'` - Insert row below\n   *  * `'col_left'` - \
Insert column left\n   *  * `'col_right'` - Insert column right\n   *  * \
`'clear_column'` - Clear selected column\n   *  * `'remove_row'` - Remove \
row\n   *  * `'remove_col'` - Remove column\n   *  * `'undo'` - Undo last \
action\n   *  * `'redo'` - Redo last action\n   *  * `'make_read_only'` - \
Make cell read only\n   *  * `'alignment:left'` - Alignment to the left\n   * \
 * `'alignment:top'` - Alignment to the top\n   *  * `'alignment:right'` - \
Alignment to the right\n   *  * `'alignment:bottom'` - Alignment to the \
bottom\n   *  * `'alignment:middle'` - Alignment to the middle\n   *  * \
`'alignment:center'` - Alignment to the center (justify).\n   *\n   * Or you \
can execute command registered in settings where `key` is your command \
name.\n   *\n   * @param {string} commandName Command name to execute.\n   * \
@param {*} params Additional parameters passed to the command executor.\n   \
*/\n  executeCommand(commandName) {\n    for (var _len2 = arguments.length, \
params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; \
_key2++) {\n      params[_key2 - 1] = arguments[_key2];\n    }\n    \
this.commandExecutor.execute(commandName, ...params);\n  }\n  /**\n   * Turns \
on / off listening on dropdown menu.\n   *\n   * @private\n   * @param \
{boolean} listen Turn on listening when value is set to true, otherwise turn \
it off.\n   */\n  setListening() {\n    let listen = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : true;\n    if (this.menu.isOpened()) \
{\n      if (listen) {\n        this.menu.hotMenu.listen();\n      } else {\n \
       this.menu.hotMenu.unlisten();\n      }\n    }\n  }\n  /**\n   * Table \
click listener.\n   *\n   * @private\n   * @param {Event} event The mouse \
event object.\n   */\n  onTableClick(event2) {\n    \
event2.stopPropagation();\n    if (hasClass(event2.target, BUTTON_CLASS_NAME) \
&& !this.menu.isOpened()) {\n      let offsetTop = 0;\n      let offsetLeft = \
0;\n      if (this.hot.rootDocument !== this.menu.container.ownerDocument) \
{\n        const {\n          frameElement\n        } = \
this.hot.rootWindow;\n        const {\n          top: top2,\n          left: \
left2\n        } = frameElement.getBoundingClientRect();\n        offsetTop = \
top2;\n        offsetLeft = left2;\n      }\n      const rect = \
event2.target.getBoundingClientRect();\n      this.open({\n        left: \
rect.left + offsetLeft,\n        top: rect.top + event2.target.offsetHeight + \
3 + offsetTop,\n        width: rect.width,\n        height: rect.height\n     \
 });\n    }\n  }\n  /**\n   * On after get column header listener.\n   *\n   \
* @private\n   * @param {number} col Visual column index.\n   * @param \
{HTMLTableCellElement} TH Header's TH element.\n   */\n  \
onAfterGetColHeader(col, TH) {\n    const headerRow = TH.parentNode;\n    if \
(!headerRow) {\n      return;\n    }\n    const headerRowList = \
headerRow.parentNode.childNodes;\n    const level = \
Array.prototype.indexOf.call(headerRowList, headerRow);\n    if (col < 0 || \
level !== headerRowList.length - 1) {\n      return;\n    }\n    const \
existingButton = TH.querySelector(`.${BUTTON_CLASS_NAME}`);\n    if \
(this.enabled && existingButton) {\n      return;\n    }\n    if \
(!this.enabled) {\n      if (existingButton) {\n        \
existingButton.parentNode.removeChild(existingButton);\n      }\n      \
return;\n    }\n    const button = \
this.hot.rootDocument.createElement(\"button\");\n    button.className = \
BUTTON_CLASS_NAME;\n    button.type = \"button\";\n    button.onclick = \
function() {\n      return false;\n    };\n    \
TH.firstChild.insertBefore(button, TH.firstChild.firstChild);\n  }\n  /**\n   \
* On menu before open listener.\n   *\n   * @private\n   * @fires \
Hooks#beforeDropdownMenuShow\n   */\n  onMenuBeforeOpen() {\n    \
this.hot.runHooks(\"beforeDropdownMenuShow\", this);\n  }\n  /**\n   * On \
menu after open listener.\n   *\n   * @private\n   * @fires \
Hooks#afterDropdownMenuShow\n   */\n  onMenuAfterOpen() {\n    \
this.hot.runHooks(\"afterDropdownMenuShow\", this);\n  }\n  /**\n   * On menu \
after close listener.\n   *\n   * @private\n   * @fires \
Hooks#afterDropdownMenuHide\n   */\n  onMenuAfterClose() {\n    \
this.hot.listen();\n    this.hot.runHooks(\"afterDropdownMenuHide\", this);\n \
 }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    \
this.close();\n    if (this.menu) {\n      this.menu.destroy();\n    }\n    \
super.destroy();\n  }\n};\nDropdownMenu.SEPARATOR = {\n  name: KEY\n};\n\n// \
node_modules/handsontable/plugins/exportFile/dataProvider.mjs\nvar \
DataProvider = class {\n  constructor(hotInstance) {\n    this.hot = \
hotInstance;\n    this.options = {};\n  }\n  /**\n   * Set options for data \
provider.\n   *\n   * @param {object} options Object with specified \
options.\n   */\n  setOptions(options) {\n    this.options = options;\n  }\n  \
/**\n   * Get table data based on provided settings to the class \
constructor.\n   *\n   * @returns {Array}\n   */\n  getData() {\n    const \
{\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    } = \
this._getDataRange();\n    const options = this.options;\n    const data2 = \
[];\n    rangeEach(startRow, endRow, (rowIndex) => {\n      const row = [];\n \
     if (!options.exportHiddenRows && this._isHiddenRow(rowIndex)) {\n        \
return;\n      }\n      rangeEach(startCol, endCol, (colIndex) => {\n        \
if (!options.exportHiddenColumns && this._isHiddenColumn(colIndex)) {\n       \
   return;\n        }\n        row.push(this.hot.getDataAtCell(rowIndex, \
colIndex));\n      });\n      data2.push(row);\n    });\n    return data2;\n  \
}\n  /**\n   * Gets list of row headers.\n   *\n   * @returns {Array}\n   \
*/\n  getRowHeaders() {\n    const headers = [];\n    if \
(this.options.rowHeaders) {\n      const {\n        startRow,\n        \
endRow\n      } = this._getDataRange();\n      const rowHeaders = \
this.hot.getRowHeader();\n      rangeEach(startRow, endRow, (row) => {\n      \
  if (!this.options.exportHiddenRows && this._isHiddenRow(row)) {\n          \
return;\n        }\n        headers.push(rowHeaders[row]);\n      });\n    \
}\n    return headers;\n  }\n  /**\n   * Gets list of columns headers.\n   \
*\n   * @returns {Array}\n   */\n  getColumnHeaders() {\n    const headers = \
[];\n    if (this.options.columnHeaders) {\n      const {\n        \
startCol,\n        endCol\n      } = this._getDataRange();\n      const \
colHeaders = this.hot.getColHeader();\n      rangeEach(startCol, endCol, \
(column) => {\n        if (!this.options.exportHiddenColumns && \
this._isHiddenColumn(column)) {\n          return;\n        }\n        \
headers.push(colHeaders[column]);\n      });\n    }\n    return headers;\n  \
}\n  /**\n   * Get data range object based on settings provided in the class \
constructor.\n   *\n   * @private\n   * @returns {object} Returns object with \
keys `startRow`, `startCol`, `endRow` and `endCol`.\n   */\n  _getDataRange() \
{\n    const cols = this.hot.countCols() - 1;\n    const rows = \
this.hot.countRows() - 1;\n    let [startRow = 0, startCol = 0, endRow = \
rows, endCol = cols] = this.options.range;\n    startRow = Math.max(startRow, \
0);\n    startCol = Math.max(startCol, 0);\n    endRow = Math.min(endRow, \
rows);\n    endCol = Math.min(endCol, cols);\n    return {\n      startRow,\n \
     startCol,\n      endRow,\n      endCol\n    };\n  }\n  /**\n   * Check \
if row at specified row index is hidden.\n   *\n   * @private\n   * @param \
{number} row Row index.\n   * @returns {boolean}\n   */\n  _isHiddenRow(row) \
{\n    return \
this.hot.rowIndexMapper.isHidden(this.hot.toPhysicalRow(row));\n  }\n  /**\n  \
 * Check if column at specified column index is hidden.\n   *\n   * \
@private\n   * @param {number} column Visual column index.\n   * @returns \
{boolean}\n   */\n  _isHiddenColumn(column) {\n    return \
this.hot.columnIndexMapper.isHidden(this.hot.toPhysicalColumn(column));\n  \
}\n};\nvar dataProvider_default = DataProvider;\n\n// \
node_modules/handsontable/plugins/exportFile/types/_base.mjs\nvar BaseType = \
class _BaseType {\n  /**\n   * Default options.\n   *\n   * @returns \
{object}\n   */\n  static get DEFAULT_OPTIONS() {\n    return {\n      \
mimeType: \"text/plain\",\n      fileExtension: \"txt\",\n      filename: \
\"Handsontable [YYYY]-[MM]-[DD]\",\n      encoding: \"utf-8\",\n      bom: \
false,\n      columnHeaders: false,\n      rowHeaders: false,\n      \
exportHiddenColumns: false,\n      exportHiddenRows: false,\n      range: \
[]\n    };\n  }\n  constructor(dataProvider, options) {\n    \
this.dataProvider = dataProvider;\n    this.options = \
this._mergeOptions(options);\n    \
this.dataProvider.setOptions(this.options);\n  }\n  /**\n   * Merge options \
provided by users with defaults.\n   *\n   * @param {object} options An \
object with options to merge with.\n   * @returns {object} Returns new \
options object.\n   */\n  _mergeOptions(options) {\n    let _options = \
clone(this.constructor.DEFAULT_OPTIONS);\n    const date = /* @__PURE__ */ \
new Date();\n    _options = extend(clone(_BaseType.DEFAULT_OPTIONS), \
_options);\n    _options = extend(_options, options);\n    _options.filename \
= substitute(_options.filename, {\n      YYYY: date.getFullYear(),\n      MM: \
`${date.getMonth() + 1}`.padStart(2, \"0\"),\n      DD: \
`${date.getDate()}`.padStart(2, \"0\")\n    });\n    return _options;\n  \
}\n};\nvar base_default2 = BaseType;\n\n// \
node_modules/handsontable/plugins/exportFile/types/csv.mjs\nvar \
CHAR_CARRIAGE_RETURN = String.fromCharCode(13);\nvar CHAR_DOUBLE_QUOTES = \
String.fromCharCode(34);\nvar CHAR_LINE_FEED = String.fromCharCode(10);\nvar \
Csv = class extends base_default2 {\n  /**\n   * Default options for \
exporting CSV format.\n   *\n   * @returns {object}\n   */\n  static get \
DEFAULT_OPTIONS() {\n    return {\n      mimeType: \"text/csv\",\n      \
fileExtension: \"csv\",\n      bom: true,\n      columnDelimiter: \",\",\n    \
  rowDelimiter: \"\\r\\n\"\n    };\n  }\n  /**\n   * Create string body in \
desired format.\n   *\n   * @returns {string}\n   */\n  export() {\n    const \
options = this.options;\n    const data2 = this.dataProvider.getData();\n    \
let columnHeaders = this.dataProvider.getColumnHeaders();\n    const \
hasColumnHeaders = columnHeaders.length > 0;\n    const rowHeaders = \
this.dataProvider.getRowHeaders();\n    const hasRowHeaders = \
rowHeaders.length > 0;\n    let result = options.bom ? \
String.fromCharCode(65279) : \"\";\n    if (hasColumnHeaders) {\n      \
columnHeaders = arrayMap(columnHeaders, (value) => this._escapeCell(value, \
true));\n      if (hasRowHeaders) {\n        result += \
options.columnDelimiter;\n      }\n      result += \
columnHeaders.join(options.columnDelimiter);\n      result += \
options.rowDelimiter;\n    }\n    arrayEach(data2, (value, index2) => {\n     \
 if (index2 > 0) {\n        result += options.rowDelimiter;\n      }\n      \
if (hasRowHeaders) {\n        result += this._escapeCell(rowHeaders[index2]) \
+ options.columnDelimiter;\n      }\n      result += value.map((cellValue) => \
this._escapeCell(cellValue)).join(options.columnDelimiter);\n    });\n    \
return result;\n  }\n  /**\n   * Escape cell value.\n   *\n   * @param {*} \
value Cell value.\n   * @param {boolean} [force=false] Indicates if cell \
value will be escaped forcefully.\n   * @returns {string}\n   */\n  \
_escapeCell(value) {\n    let force = arguments.length > 1 && arguments[1] \
!== void 0 ? arguments[1] : false;\n    let escapedValue = \
stringify(value);\n    if (escapedValue !== \"\" && (force || \
escapedValue.indexOf(CHAR_CARRIAGE_RETURN) >= 0 || \
escapedValue.indexOf(CHAR_DOUBLE_QUOTES) >= 0 || \
escapedValue.indexOf(CHAR_LINE_FEED) >= 0 || \
escapedValue.indexOf(this.options.columnDelimiter) >= 0)) {\n      \
escapedValue = escapedValue.replace(new RegExp('\"', \"g\"), '\"\"');\n      \
escapedValue = `\"${escapedValue}\"`;\n    }\n    return escapedValue;\n  \
}\n};\nvar csv_default = Csv;\n\n// \
node_modules/handsontable/plugins/exportFile/typeFactory.mjs\nvar TYPE_CSV = \
\"csv\";\nvar EXPORT_TYPES = {\n  [TYPE_CSV]: csv_default\n};\nfunction \
typeFactory(type, dataProvider, options) {\n  if (typeof EXPORT_TYPES[type] \
=== \"function\") {\n    return new EXPORT_TYPES[type](dataProvider, \
options);\n  }\n  return null;\n}\n\n// \
node_modules/handsontable/plugins/exportFile/exportFile.mjs\nvar PLUGIN_KEY15 \
= \"exportFile\";\nvar PLUGIN_PRIORITY14 = 240;\nvar ExportFile = class \
extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY15;\n \
 }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY14;\n  }\n  \
/**\n   * Checks if the plugin is enabled in the handsontable settings. This \
method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns \
`true` then the {@link ExportFile#enablePlugin} method is called.\n   *\n   * \
@returns {boolean}\n   */\n  isEnabled() {\n    return true;\n  }\n  /**\n   \
* @typedef ExportOptions\n   * @memberof ExportFile\n   * @type {object}\n   \
* @property {boolean} [exportHiddenRows=false] Include hidden rows in the \
exported file.\n   * @property {boolean} [exportHiddenColumns=false] Include \
hidden columns in the exported file.\n   * @property {boolean} \
[columnHeaders=false] Include column headers in the exported file.\n   * \
@property {boolean} [rowHeaders=false] Include row headers in the exported \
file.\n   * @property {string} [columnDelimiter=','] Column delimiter.\n   * \
@property {string} [range=[]] Cell range that will be exported to file.\n   \
*/\n  /**\n   * Exports table data as a string.\n   *\n   * @param {string} \
format Export format type eq. `'csv'`.\n   * @param {ExportOptions} options \
Export options.\n   * @returns {string}\n   */\n  exportAsString(format) {\n  \
  let options = arguments.length > 1 && arguments[1] !== void 0 ? \
arguments[1] : {};\n    return this._createTypeFormatter(format, \
options).export();\n  }\n  /**\n   * Exports table data as a blob object.\n   \
*\n   * @param {string} format Export format type eq. `'csv'`.\n   * @param \
{ExportOptions} options Export options.\n   * @returns {Blob}\n   */\n  \
exportAsBlob(format) {\n    let options = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : {};\n    return \
this._createBlob(this._createTypeFormatter(format, options));\n  }\n  /**\n   \
* Exports table data as a downloadable file.\n   *\n   * @param {string} \
format Export format type eq. `'csv'`.\n   * @param {ExportOptions} options \
Export options.\n   */\n  downloadFile(format) {\n    let options = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    \
const {\n      rootDocument,\n      rootWindow\n    } = this.hot;\n    const \
formatter = this._createTypeFormatter(format, options);\n    const blob = \
this._createBlob(formatter);\n    const URL = rootWindow.URL || \
rootWindow.webkitURL;\n    const a = rootDocument.createElement(\"a\");\n    \
const name = \
`${formatter.options.filename}.${formatter.options.fileExtension}`;\n    if \
(a.download !== void 0) {\n      const url = URL.createObjectURL(blob);\n     \
 a.style.display = \"none\";\n      a.setAttribute(\"href\", url);\n      \
a.setAttribute(\"download\", name);\n      \
rootDocument.body.appendChild(a);\n      a.dispatchEvent(new \
MouseEvent(\"click\"));\n      rootDocument.body.removeChild(a);\n      \
setTimeout(() => {\n        URL.revokeObjectURL(url);\n      }, 100);\n    } \
else if (navigator.msSaveOrOpenBlob) {\n      \
navigator.msSaveOrOpenBlob(blob, name);\n    }\n  }\n  /**\n   * Creates and \
returns class formatter for specified export type.\n   *\n   * @private\n   * \
@param {string} format Export format type eq. `'csv'`.\n   * @param \
{ExportOptions} options Export options.\n   * @returns {BaseType}\n   */\n  \
_createTypeFormatter(format) {\n    let options = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : {};\n    if (!EXPORT_TYPES[format]) \
{\n      throw new Error(`Export format type \"${format}\" is not \
supported.`);\n    }\n    return typeFactory(format, new \
dataProvider_default(this.hot), options);\n  }\n  /**\n   * Creates blob \
object based on provided type formatter class.\n   *\n   * @private\n   * \
@param {BaseType} typeFormatter The instance of the specyfic \
formatter/exporter.\n   * @returns {Blob}\n   */\n  \
_createBlob(typeFormatter) {\n    let formatter = null;\n    if (typeof Blob \
!== \"undefined\") {\n      formatter = new Blob([typeFormatter.export()], \
{\n        type: \
`${typeFormatter.options.mimeType};charset=${typeFormatter.options.encoding}`\
\n      });\n    }\n    return formatter;\n  }\n};\n\n// \
node_modules/handsontable/plugins/filters/component/_base.mjs\nvar \
BaseComponent = class {\n  constructor(hotInstance, _ref) {\n    let {\n      \
id,\n      stateless = true\n    } = _ref;\n    this.hot = hotInstance;\n    \
this.id = id;\n    this.elements = [];\n    this.hidden = false;\n    \
this.stateId = `Filters.component.${this.id}`;\n    this.state = stateless ? \
null : this.hot.columnIndexMapper.registerMap(this.stateId, new \
LinkedPhysicalIndexToValueMap());\n  }\n  /**\n   * Reset elements to its \
initial state.\n   */\n  reset() {\n    arrayEach(this.elements, (ui) => \
ui.reset());\n  }\n  /**\n   * Hide component.\n   */\n  hide() {\n    \
this.hidden = true;\n  }\n  /**\n   * Show component.\n   */\n  show() {\n    \
this.hidden = false;\n  }\n  /**\n   * Check if component is hidden.\n   *\n  \
 * @returns {boolean}\n   */\n  isHidden() {\n    return this.hot === null || \
this.hidden;\n  }\n  /**\n   * Restores the component state from the given \
physical column index. The method\n   * internally calls the `setState` \
method. The state then is individually processed\n   * by each component.\n   \
*\n   * @param {number} physicalColumn The physical column index.\n   */\n  \
restoreState(physicalColumn) {\n    if (this.state) {\n      \
this.setState(this.state.getValueAtIndex(physicalColumn));\n    }\n  }\n  \
/**\n   * The custom logic for component state restoring.\n   */\n  \
setState() {\n    throw new Error(\"The state setting logic is not \
implemented\");\n  }\n  /**\n   * Saves the component state to the given \
physical column index. The method\n   * internally calls the `getState` \
method, which returns the current state of\n   * the component.\n   *\n   * \
@param {number} physicalColumn The physical column index.\n   */\n  \
saveState(physicalColumn) {\n    if (this.state) {\n      \
this.state.setValueAtIndex(physicalColumn, this.getState());\n    }\n  }\n  \
/**\n   * The custom logic for component state gathering (for stateful \
components).\n   */\n  getState() {\n    throw new Error(\"The state \
gathering logic is not implemented\");\n  }\n  /**\n   * Destroy element.\n   \
*/\n  destroy() {\n    \
this.hot.columnIndexMapper.unregisterMap(this.stateId);\n    \
this.clearLocalHooks();\n    arrayEach(this.elements, (ui) => \
ui.destroy());\n    this.state = null;\n    this.elements = null;\n    \
this.hot = null;\n  }\n};\nmixin(BaseComponent, localHooks_default);\nvar \
base_default3 = BaseComponent;\n\n// \
node_modules/handsontable/plugins/filters/conditionRegisterer.mjs\nvar \
conditions = {};\nfunction getCondition(name, args) {\n  if \
(!conditions[name]) {\n    throw Error(`Filter condition \"${name}\" does not \
exist.`);\n  }\n  const {\n    condition: condition22,\n    descriptor\n  } = \
conditions[name];\n  let conditionArguments = args;\n  if \
(descriptor.inputValuesDecorator) {\n    conditionArguments = \
descriptor.inputValuesDecorator(conditionArguments);\n  }\n  return \
function(dataRow) {\n    return condition22.apply(dataRow.meta.instance, \
[].concat([dataRow], [conditionArguments]));\n  };\n}\nfunction \
getConditionDescriptor(name) {\n  if (!conditions[name]) {\n    throw \
Error(`Filter condition \"${name}\" does not exist.`);\n  }\n  return \
conditions[name].descriptor;\n}\nfunction registerCondition(name, \
condition22, descriptor) {\n  descriptor.key = name;\n  conditions[name] = \
{\n    condition: condition22,\n    descriptor\n  };\n}\n\n// \
node_modules/handsontable/plugins/filters/condition/none.mjs\nvar \
CONDITION_NAME = \"none\";\nfunction condition() {\n  return \
true;\n}\nregisterCondition(CONDITION_NAME, condition, {\n  name: \
FILTERS_CONDITIONS_NONE,\n  inputsCount: 0,\n  showOperators: \
false\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/empty.mjs\nvar \
CONDITION_NAME2 = \"empty\";\nfunction condition2(dataRow) {\n  return \
isEmpty(dataRow.value);\n}\nregisterCondition(CONDITION_NAME2, condition2, \
{\n  name: FILTERS_CONDITIONS_EMPTY,\n  inputsCount: 0,\n  showOperators: \
true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/notEmpty.mjs\nvar \
CONDITION_NAME3 = \"not_empty\";\nfunction condition3(dataRow, inputValues) \
{\n  return !getCondition(CONDITION_NAME2, \
inputValues)(dataRow);\n}\nregisterCondition(CONDITION_NAME3, condition3, {\n \
 name: FILTERS_CONDITIONS_NOT_EMPTY,\n  inputsCount: 0,\n  showOperators: \
true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/equal.mjs\nvar \
CONDITION_NAME4 = \"eq\";\nfunction condition4(dataRow, _ref) {\n  let \
[value] = _ref;\n  return \
stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale) === \
stringify(value);\n}\nregisterCondition(CONDITION_NAME4, condition4, {\n  \
name: FILTERS_CONDITIONS_EQUAL,\n  inputsCount: 1,\n  showOperators: \
true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/notEqual.mjs\nvar \
CONDITION_NAME5 = \"neq\";\nfunction condition5(dataRow, inputValues) {\n  \
return !getCondition(CONDITION_NAME4, \
inputValues)(dataRow);\n}\nregisterCondition(CONDITION_NAME5, condition5, {\n \
 name: FILTERS_CONDITIONS_NOT_EQUAL,\n  inputsCount: 1,\n  showOperators: \
true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/greaterThan.mjs\nvar \
CONDITION_NAME6 = \"gt\";\nfunction condition6(dataRow, _ref) {\n  let \
[value] = _ref;\n  let conditionValue = value;\n  if (dataRow.meta.type === \
\"numeric\") {\n    conditionValue = parseFloat(conditionValue, 10);\n  }\n  \
return dataRow.value > conditionValue;\n}\nregisterCondition(CONDITION_NAME6, \
condition6, {\n  name: FILTERS_CONDITIONS_GREATER_THAN,\n  inputsCount: 1,\n  \
showOperators: true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/greaterThanOrEqual.mjs\nv\
ar CONDITION_NAME7 = \"gte\";\nfunction condition7(dataRow, _ref) {\n  let \
[value] = _ref;\n  let conditionValue = value;\n  if (dataRow.meta.type === \
\"numeric\") {\n    conditionValue = parseFloat(conditionValue, 10);\n  }\n  \
return dataRow.value >= \
conditionValue;\n}\nregisterCondition(CONDITION_NAME7, condition7, {\n  name: \
FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,\n  inputsCount: 1,\n  \
showOperators: true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/lessThan.mjs\nvar \
CONDITION_NAME8 = \"lt\";\nfunction condition8(dataRow, _ref) {\n  let \
[value] = _ref;\n  let conditionValue = value;\n  if (dataRow.meta.type === \
\"numeric\") {\n    conditionValue = parseFloat(conditionValue, 10);\n  }\n  \
return dataRow.value < conditionValue;\n}\nregisterCondition(CONDITION_NAME8, \
condition8, {\n  name: FILTERS_CONDITIONS_LESS_THAN,\n  inputsCount: 1,\n  \
showOperators: true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/lessThanOrEqual.mjs\nvar \
CONDITION_NAME9 = \"lte\";\nfunction condition9(dataRow, _ref) {\n  let \
[value] = _ref;\n  let conditionValue = value;\n  if (dataRow.meta.type === \
\"numeric\") {\n    conditionValue = parseFloat(conditionValue, 10);\n  }\n  \
return dataRow.value <= \
conditionValue;\n}\nregisterCondition(CONDITION_NAME9, condition9, {\n  name: \
FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,\n  inputsCount: 1,\n  showOperators: \
true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/date/after.mjs\nvar \
import_moment6 = __toESM(require_moment(), 1);\nvar CONDITION_NAME10 = \
\"date_after\";\nfunction condition10(dataRow, _ref) {\n  let [value] = \
_ref;\n  const date = (0, import_moment6.default)(dataRow.value, \
dataRow.meta.dateFormat);\n  const inputDate = (0, \
import_moment6.default)(value, dataRow.meta.dateFormat);\n  if \
(!date.isValid() || !inputDate.isValid()) {\n    return false;\n  }\n  return \
date.diff(inputDate) >= 0;\n}\nregisterCondition(CONDITION_NAME10, \
condition10, {\n  name: FILTERS_CONDITIONS_AFTER,\n  inputsCount: 1,\n  \
showOperators: true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/date/before.mjs\nvar \
import_moment7 = __toESM(require_moment(), 1);\nvar CONDITION_NAME11 = \
\"date_before\";\nfunction condition11(dataRow, _ref) {\n  let [value] = \
_ref;\n  const date = (0, import_moment7.default)(dataRow.value, \
dataRow.meta.dateFormat);\n  const inputDate = (0, \
import_moment7.default)(value, dataRow.meta.dateFormat);\n  if \
(!date.isValid() || !inputDate.isValid()) {\n    return false;\n  }\n  return \
date.diff(inputDate) <= 0;\n}\nregisterCondition(CONDITION_NAME11, \
condition11, {\n  name: FILTERS_CONDITIONS_BEFORE,\n  inputsCount: 1,\n  \
showOperators: true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/between.mjs\nvar \
CONDITION_NAME12 = \"between\";\nfunction condition12(dataRow, _ref) {\n  let \
[from, to] = _ref;\n  let fromValue = from;\n  let toValue = to;\n  if \
(dataRow.meta.type === \"numeric\") {\n    const _from = \
parseFloat(fromValue, 10);\n    const _to = parseFloat(toValue, 10);\n    \
fromValue = Math.min(_from, _to);\n    toValue = Math.max(_from, _to);\n  } \
else if (dataRow.meta.type === \"date\") {\n    const dateBefore = \
getCondition(CONDITION_NAME11, [toValue]);\n    const dateAfter = \
getCondition(CONDITION_NAME10, [fromValue]);\n    return dateBefore(dataRow) \
&& dateAfter(dataRow);\n  }\n  return dataRow.value >= fromValue && \
dataRow.value <= toValue;\n}\nregisterCondition(CONDITION_NAME12, \
condition12, {\n  name: FILTERS_CONDITIONS_BETWEEN,\n  inputsCount: 2,\n  \
showOperators: true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/notBetween.mjs\nvar \
CONDITION_NAME13 = \"not_between\";\nfunction condition13(dataRow, \
inputValues) {\n  return !getCondition(CONDITION_NAME12, \
inputValues)(dataRow);\n}\nregisterCondition(CONDITION_NAME13, condition13, \
{\n  name: FILTERS_CONDITIONS_NOT_BETWEEN,\n  inputsCount: 2,\n  \
showOperators: true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/beginsWith.mjs\nvar \
CONDITION_NAME14 = \"begins_with\";\nfunction condition14(dataRow, _ref) {\n  \
let [value] = _ref;\n  return \
stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).startsWith(st\
ringify(value));\n}\nregisterCondition(CONDITION_NAME14, condition14, {\n  \
name: FILTERS_CONDITIONS_BEGINS_WITH,\n  inputsCount: 1,\n  showOperators: \
true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/endsWith.mjs\nvar \
CONDITION_NAME15 = \"ends_with\";\nfunction condition15(dataRow, _ref) {\n  \
let [value] = _ref;\n  return \
stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).endsWith(stri\
ngify(value));\n}\nregisterCondition(CONDITION_NAME15, condition15, {\n  \
name: FILTERS_CONDITIONS_ENDS_WITH,\n  inputsCount: 1,\n  showOperators: \
true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/contains.mjs\nvar \
CONDITION_NAME16 = \"contains\";\nfunction condition16(dataRow, _ref) {\n  \
let [value] = _ref;\n  return \
stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).indexOf(strin\
gify(value)) >= 0;\n}\nregisterCondition(CONDITION_NAME16, condition16, {\n  \
name: FILTERS_CONDITIONS_CONTAINS,\n  inputsCount: 1,\n  showOperators: \
true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/notContains.mjs\nvar \
CONDITION_NAME17 = \"not_contains\";\nfunction condition17(dataRow, \
inputValues) {\n  return !getCondition(CONDITION_NAME16, \
inputValues)(dataRow);\n}\nregisterCondition(CONDITION_NAME17, condition17, \
{\n  name: FILTERS_CONDITIONS_NOT_CONTAIN,\n  inputsCount: 1,\n  \
showOperators: true\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/date/tomorrow.mjs\nvar \
import_moment8 = __toESM(require_moment(), 1);\nvar CONDITION_NAME18 = \
\"date_tomorrow\";\nfunction condition18(dataRow) {\n  const date = (0, \
import_moment8.default)(dataRow.value, dataRow.meta.dateFormat);\n  if \
(!date.isValid()) {\n    return false;\n  }\n  return date.isSame((0, \
import_moment8.default)().subtract(-1, \"days\").startOf(\"day\"), \
\"d\");\n}\nregisterCondition(CONDITION_NAME18, condition18, {\n  name: \
FILTERS_CONDITIONS_TOMORROW,\n  inputsCount: 0\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/date/today.mjs\nvar \
import_moment9 = __toESM(require_moment(), 1);\nvar CONDITION_NAME19 = \
\"date_today\";\nfunction condition19(dataRow) {\n  const date = (0, \
import_moment9.default)(dataRow.value, dataRow.meta.dateFormat);\n  if \
(!date.isValid()) {\n    return false;\n  }\n  return date.isSame((0, \
import_moment9.default)().startOf(\"day\"), \
\"d\");\n}\nregisterCondition(CONDITION_NAME19, condition19, {\n  name: \
FILTERS_CONDITIONS_TODAY,\n  inputsCount: 0\n});\n\n// \
node_modules/handsontable/plugins/filters/condition/date/yesterday.mjs\nvar \
import_moment10 = __toESM(require_moment(), 1);\nvar CONDITION_NAME20 = \
\"date_yesterday\";\nfunction condition20(dataRow) {\n  const date = (0, \
import_moment10.default)(dataRow.value, dataRow.meta.dateFormat);\n  if \
(!date.isValid()) {\n    return false;\n  }\n  return date.isSame((0, \
import_moment10.default)().subtract(1, \"days\").startOf(\"day\"), \
\"d\");\n}\nregisterCondition(CONDITION_NAME20, condition20, {\n  name: \
FILTERS_CONDITIONS_YESTERDAY,\n  inputsCount: 0\n});\n\n// \
node_modules/handsontable/plugins/filters/utils.mjs\nvar sortCompare = \
getComparisonFunction();\nfunction toVisualValue(value, defaultEmptyValue) \
{\n  let visualValue = value;\n  if (visualValue === \"\") {\n    visualValue \
= `(${defaultEmptyValue})`;\n  }\n  return visualValue;\n}\nvar \
SUPPORT_SET_CONSTRUCTOR = (/* @__PURE__ */ new Set([1])).has(1);\nvar \
SUPPORT_FAST_DEDUPE = SUPPORT_SET_CONSTRUCTOR && typeof Array.from === \
\"function\";\nfunction createArrayAssertion(initialData) {\n  let dataset = \
initialData;\n  if (SUPPORT_SET_CONSTRUCTOR) {\n    dataset = new \
Set(dataset);\n  }\n  return function(value) {\n    let result;\n    if \
(SUPPORT_SET_CONSTRUCTOR) {\n      result = dataset.has(value);\n    } else \
{\n      result = !!~dataset.indexOf(value);\n    }\n    return result;\n  \
};\n}\nfunction toEmptyString(value) {\n  return value === null || value === \
void 0 ? \"\" : value;\n}\nfunction unifyColumnValues(values) {\n  let \
unifiedValues = values;\n  if (SUPPORT_FAST_DEDUPE) {\n    unifiedValues = \
Array.from(new Set(unifiedValues));\n  } else {\n    unifiedValues = \
arrayUnique(unifiedValues);\n  }\n  unifiedValues = unifiedValues.sort((a, b) \
=> {\n    if (typeof a === \"number\" && typeof b === \"number\") {\n      \
return a - b;\n    }\n    if (a === b) {\n      return 0;\n    }\n    return \
a > b ? 1 : -1;\n  });\n  return unifiedValues;\n}\nfunction \
intersectValues(base, selected, defaultEmptyValue, callback) {\n  const \
result = [];\n  const same = base === selected;\n  let \
selectedItemsAssertion;\n  if (!same) {\n    selectedItemsAssertion = \
createArrayAssertion(selected);\n  }\n  arrayEach(base, (value) => {\n    let \
checked = false;\n    if (same || selectedItemsAssertion(value)) {\n      \
checked = true;\n    }\n    const item = {\n      checked,\n      value,\n    \
  visualValue: toVisualValue(value, defaultEmptyValue)\n    };\n    if \
(callback) {\n      callback(item);\n    }\n    result.push(item);\n  });\n  \
return result;\n}\n\n// \
node_modules/handsontable/plugins/filters/condition/byValue.mjs\nvar \
CONDITION_NAME21 = \"by_value\";\nfunction condition21(dataRow, _ref) {\n  \
let [value] = _ref;\n  return \
value(dataRow.value);\n}\nregisterCondition(CONDITION_NAME21, condition21, \
{\n  name: \"By value\",\n  inputsCount: 0,\n  inputValuesDecorator(_ref2) \
{\n    let [data2] = _ref2;\n    return [createArrayAssertion(data2)];\n  \
},\n  showOperators: false\n});\n\n// \
node_modules/handsontable/plugins/filters/logicalOperationRegisterer.mjs\nvar \
operations = {};\nfunction getOperationFunc(id) {\n  if (!operations[id]) {\n \
   throw Error(`Operation with id \"${id}\" does not exist.`);\n  }\n  const \
func = operations[id].func;\n  return function(conditions2, value) {\n    \
return func(conditions2, value);\n  };\n}\nfunction getOperationName(id) {\n  \
return operations[id].name;\n}\nfunction registerOperation(id, name, func) \
{\n  operations[id] = {\n    name,\n    func\n  };\n}\n\n// \
node_modules/handsontable/plugins/filters/logicalOperations/conjunction.mjs\n\
var OPERATION_ID = \"conjunction\";\nvar SHORT_NAME_FOR_COMPONENT = \
FILTERS_LABELS_CONJUNCTION;\nfunction operationResult(conditions2, value) {\n \
 return conditions2.every((condition22) => \
condition22.func(value));\n}\nregisterOperation(OPERATION_ID, \
SHORT_NAME_FOR_COMPONENT, operationResult);\n\n// \
node_modules/handsontable/plugins/filters/logicalOperations/disjunction.mjs\n\
var OPERATION_ID2 = \"disjunction\";\nvar SHORT_NAME_FOR_COMPONENT2 = \
FILTERS_LABELS_DISJUNCTION;\nfunction operationResult2(conditions2, value) \
{\n  return conditions2.some((condition22) => \
condition22.func(value));\n}\nregisterOperation(OPERATION_ID2, \
SHORT_NAME_FOR_COMPONENT2, operationResult2);\n\n// \
node_modules/handsontable/plugins/filters/logicalOperations/disjunctionWithEx\
traCondition.mjs\nvar OPERATION_ID3 = \"disjunctionWithExtraCondition\";\nvar \
SHORT_NAME_FOR_COMPONENT3 = FILTERS_LABELS_DISJUNCTION;\nfunction \
operationResult3(conditions2, value) {\n  if (conditions2.length < 3) {\n    \
throw Error(\"Operation doesn't work on less then three conditions.\");\n  \
}\n  return conditions2.slice(0, conditions2.length - 1).some((condition22) \
=> condition22.func(value)) && conditions2[conditions2.length - \
1].func(value);\n}\nregisterOperation(OPERATION_ID3, \
SHORT_NAME_FOR_COMPONENT3, operationResult3);\n\n// \
node_modules/handsontable/plugins/filters/constants.mjs\nvar TYPE_NUMERIC = \
\"numeric\";\nvar TYPE_TEXT = \"text\";\nvar TYPE_DATE = \"date\";\nvar TYPES \
= {\n  [TYPE_NUMERIC]: [CONDITION_NAME, KEY, CONDITION_NAME2, \
CONDITION_NAME3, KEY, CONDITION_NAME4, CONDITION_NAME5, KEY, CONDITION_NAME6, \
CONDITION_NAME7, CONDITION_NAME8, CONDITION_NAME9, CONDITION_NAME12, \
CONDITION_NAME13],\n  [TYPE_TEXT]: [CONDITION_NAME, KEY, CONDITION_NAME2, \
CONDITION_NAME3, KEY, CONDITION_NAME4, CONDITION_NAME5, KEY, \
CONDITION_NAME14, CONDITION_NAME15, KEY, CONDITION_NAME16, \
CONDITION_NAME17],\n  [TYPE_DATE]: [CONDITION_NAME, KEY, CONDITION_NAME2, \
CONDITION_NAME3, KEY, CONDITION_NAME4, CONDITION_NAME5, KEY, \
CONDITION_NAME11, CONDITION_NAME10, CONDITION_NAME12, KEY, CONDITION_NAME18, \
CONDITION_NAME19, CONDITION_NAME20]\n};\nfunction getOptionsList(type) {\n  \
const items = [];\n  let typeName = type;\n  if (!TYPES[typeName]) {\n    \
typeName = TYPE_TEXT;\n  }\n  arrayEach(TYPES[typeName], (typeValue) => {\n   \
 let option;\n    if (typeValue === KEY) {\n      option = {\n        name: \
KEY\n      };\n    } else {\n      option = \
clone(getConditionDescriptor(typeValue));\n    }\n    items.push(option);\n  \
});\n  return items;\n}\n\n// \
node_modules/handsontable/plugins/filters/ui/_base.mjs\nvar STATE_BUILT = \
\"built\";\nvar STATE_BUILDING = \"building\";\nvar EVENTS_TO_REGISTER = \
[\"click\", \"input\", \"keydown\", \"keypress\", \"keyup\", \"focus\", \
\"blur\", \"change\"];\nvar BaseUI = class _BaseUI {\n  static get DEFAULTS() \
{\n    return clone({\n      className: \"\",\n      value: \"\",\n      \
tagName: \"div\",\n      children: [],\n      wrapIt: true\n    });\n  }\n  \
constructor(hotInstance, options) {\n    this.hot = hotInstance;\n    \
this.eventManager = new eventManager_default(this);\n    this.options = \
extend(_BaseUI.DEFAULTS, options);\n    this._element = \
this.hot.rootDocument.createElement(this.options.wrapIt ? \"div\" : \
this.options.tagName);\n    this.buildState = null;\n  }\n  /**\n   * Set the \
element value.\n   *\n   * @param {*} value Set the component value.\n   */\n \
 setValue(value) {\n    this.options.value = value;\n    this.update();\n  \
}\n  /**\n   * Get the element value.\n   *\n   * @returns {*}\n   */\n  \
getValue() {\n    return this.options.value;\n  }\n  /**\n   * Get element as \
a DOM object.\n   *\n   * @returns {Element}\n   */\n  get element() {\n    \
if (this.buildState === STATE_BUILDING) {\n      return this._element;\n    \
}\n    if (this.buildState === STATE_BUILT) {\n      this.update();\n      \
return this._element;\n    }\n    this.buildState = STATE_BUILDING;\n    \
this.build();\n    this.buildState = STATE_BUILT;\n    return \
this._element;\n  }\n  /**\n   * Check if element was built (built whole DOM \
structure).\n   *\n   * @returns {boolean}\n   */\n  isBuilt() {\n    return \
this.buildState === STATE_BUILT;\n  }\n  /**\n   * Translate value if it is \
possible. It's checked if value belongs to namespace of translated phrases.\n \
  *\n   * @param {*} value Value which will may be translated.\n   * @returns \
{*} Translated value if translation was possible, original value otherwise.\n \
  */\n  translateIfPossible(value) {\n    if (typeof value === \"string\" && \
value.startsWith(FILTERS_NAMESPACE)) {\n      return \
this.hot.getTranslatedPhrase(value);\n    }\n    return value;\n  }\n  /**\n  \
 * Build DOM structure.\n   */\n  build() {\n    const registerEvent = \
(element, eventName) => {\n      this.eventManager.addEventListener(element, \
eventName, (event2) => this.runLocalHooks(eventName, event2, this));\n    \
};\n    if (!this.buildState) {\n      this.buildState = STATE_BUILDING;\n    \
}\n    if (this.options.className) {\n      addClass(this._element, \
this.options.className);\n    }\n    if (this.options.children.length) {\n    \
  arrayEach(this.options.children, (element) => \
this._element.appendChild(element.element));\n    } else if \
(this.options.wrapIt) {\n      const element = \
this.hot.rootDocument.createElement(this.options.tagName);\n      \
objectEach(this.options, (value, key) => {\n        if (element[key] !== void \
0 && key !== \"className\" && key !== \"tagName\" && key !== \"children\") \
{\n          element[key] = this.translateIfPossible(value);\n        }\n     \
 });\n      this._element.appendChild(element);\n      \
arrayEach(EVENTS_TO_REGISTER, (eventName) => registerEvent(element, \
eventName));\n    } else {\n      arrayEach(EVENTS_TO_REGISTER, (eventName) \
=> registerEvent(this._element, eventName));\n    }\n  }\n  /**\n   * Update \
DOM structure.\n   */\n  update() {\n  }\n  /**\n   * Reset to initial \
state.\n   */\n  reset() {\n    this.options.value = \"\";\n    \
this.update();\n  }\n  /**\n   * Show element.\n   */\n  show() {\n    \
this.element.style.display = \"\";\n  }\n  /**\n   * Hide element.\n   */\n  \
hide() {\n    this.element.style.display = \"none\";\n  }\n  /**\n   * Focus \
element.\n   */\n  focus() {\n  }\n  destroy() {\n    \
this.eventManager.destroy();\n    this.eventManager = null;\n    this.hot = \
null;\n    if (this._element.parentNode) {\n      \
this._element.parentNode.removeChild(this._element);\n    }\n    \
this._element = null;\n  }\n};\nmixin(BaseUI, localHooks_default);\nvar \
base_default4 = BaseUI;\n\n// \
node_modules/handsontable/plugins/filters/ui/input.mjs\nvar privatePool9 = /* \
@__PURE__ */ new WeakMap();\nvar InputUI = class _InputUI extends \
base_default4 {\n  static get DEFAULTS() {\n    return clone({\n      \
placeholder: \"\",\n      type: \"text\",\n      tagName: \"input\"\n    \
});\n  }\n  constructor(hotInstance, options) {\n    super(hotInstance, \
extend(_InputUI.DEFAULTS, options));\n    privatePool9.set(this, {});\n    \
this.registerHooks();\n  }\n  /**\n   * Register all necessary hooks.\n   \
*/\n  registerHooks() {\n    this.addLocalHook(\"click\", () => \
this.onClick());\n    this.addLocalHook(\"keyup\", (event2) => \
this.onKeyup(event2));\n  }\n  /**\n   * Build DOM structure.\n   */\n  \
build() {\n    super.build();\n    const priv = privatePool9.get(this);\n    \
const icon = this.hot.rootDocument.createElement(\"div\");\n    priv.input = \
this._element.firstChild;\n    addClass(this._element, \"htUIInput\");\n    \
addClass(icon, \"htUIInputIcon\");\n    this._element.appendChild(icon);\n    \
this.update();\n  }\n  /**\n   * Update element.\n   */\n  update() {\n    if \
(!this.isBuilt()) {\n      return;\n    }\n    const input = \
privatePool9.get(this).input;\n    input.type = this.options.type;\n    \
input.placeholder = this.translateIfPossible(this.options.placeholder);\n    \
input.value = this.translateIfPossible(this.options.value);\n  }\n  /**\n   * \
Focus element.\n   */\n  focus() {\n    if (this.isBuilt()) {\n      \
privatePool9.get(this).input.focus();\n    }\n  }\n  /**\n   * OnClick \
listener.\n   */\n  onClick() {\n  }\n  /**\n   * OnKeyup listener.\n   *\n   \
* @param {Event} event The mouse event object.\n   */\n  onKeyup(event2) {\n  \
  this.options.value = event2.target.value;\n  }\n};\nvar input_default = \
InputUI;\n\n// node_modules/handsontable/plugins/filters/ui/select.mjs\nvar \
privatePool10 = /* @__PURE__ */ new WeakMap();\nvar SelectUI = class \
_SelectUI extends base_default4 {\n  static get DEFAULTS() {\n    return \
clone({\n      className: \"htUISelect\",\n      wrapIt: false\n    });\n  \
}\n  constructor(hotInstance, options) {\n    super(hotInstance, \
extend(_SelectUI.DEFAULTS, options));\n    privatePool10.set(this, {});\n    \
this.menu = null;\n    this.items = [];\n    this.registerHooks();\n  }\n  \
/**\n   * Register all necessary hooks.\n   */\n  registerHooks() {\n    \
this.addLocalHook(\"click\", () => this.onClick());\n  }\n  /**\n   * Set \
options which can be selected in the list.\n   *\n   * @param {Array} items \
Array of objects with required keys `key` and `name`.\n   */\n  \
setItems(items) {\n    this.items = this.translateNames(items);\n    if \
(this.menu) {\n      this.menu.setMenuItems(this.items);\n    }\n  }\n  /**\n \
  * Translate names of menu items.\n   *\n   * @param {Array} items Array of \
objects with required keys `key` and `name`.\n   * @returns {Array} Items \
with translated `name` keys.\n   */\n  translateNames(items) {\n    \
arrayEach(items, (item) => {\n      item.name = \
this.translateIfPossible(item.name);\n    });\n    return items;\n  }\n  \
/**\n   * Build DOM structure.\n   */\n  build() {\n    super.build();\n    \
this.menu = new menu_default(this.hot, {\n      className: \"htSelectUI \
htFiltersConditionsMenu\",\n      keepInViewport: false,\n      standalone: \
true,\n      container: this.options.menuContainer\n    });\n    \
this.menu.setMenuItems(this.items);\n    const caption = new \
base_default4(this.hot, {\n      className: \"htUISelectCaption\"\n    });\n  \
  const dropdown = new base_default4(this.hot, {\n      className: \
\"htUISelectDropdown\"\n    });\n    const priv = privatePool10.get(this);\n  \
  priv.caption = caption;\n    priv.captionElement = caption.element;\n    \
priv.dropdown = dropdown;\n    arrayEach([caption, dropdown], (element) => \
this._element.appendChild(element.element));\n    \
this.menu.addLocalHook(\"select\", (command) => \
this.onMenuSelect(command));\n    this.menu.addLocalHook(\"afterClose\", () \
=> this.onMenuClosed());\n    this.update();\n  }\n  /**\n   * Update DOM \
structure.\n   */\n  update() {\n    if (!this.isBuilt()) {\n      return;\n  \
  }\n    let conditionName;\n    if (this.options.value) {\n      \
conditionName = this.options.value.name;\n    } else {\n      conditionName = \
this.menu.hot.getTranslatedPhrase(FILTERS_CONDITIONS_NONE);\n    }\n    \
privatePool10.get(this).captionElement.textContent = conditionName;\n    \
super.update();\n  }\n  /**\n   * Open select dropdown menu with available \
options.\n   */\n  openOptions() {\n    const rect = \
this.element.getBoundingClientRect();\n    if (this.menu) {\n      \
this.menu.open();\n      this.menu.setPosition({\n        left: \
this.hot.isLtr() ? rect.left - 5 : rect.left - 31,\n        top: rect.top - \
1,\n        width: rect.width,\n        height: rect.height\n      });\n    \
}\n  }\n  /**\n   * Close select dropdown menu.\n   */\n  closeOptions() {\n  \
  if (this.menu) {\n      this.menu.close();\n    }\n  }\n  /**\n   * On menu \
selected listener.\n   *\n   * @private\n   * @param {object} command \
Selected item.\n   */\n  onMenuSelect(command) {\n    if (command.name !== \
KEY) {\n      this.options.value = command;\n      this.update();\n      \
this.runLocalHooks(\"select\", this.options.value);\n    }\n  }\n  /**\n   * \
On menu closed listener.\n   *\n   * @private\n   */\n  onMenuClosed() {\n    \
this.runLocalHooks(\"afterClose\");\n  }\n  /**\n   * On element click \
listener.\n   *\n   * @private\n   */\n  onClick() {\n    \
this.openOptions();\n  }\n  /**\n   * Destroy instance.\n   */\n  destroy() \
{\n    if (this.menu) {\n      this.menu.destroy();\n      this.menu = \
null;\n    }\n    const {\n      caption,\n      dropdown\n    } = \
privatePool10.get(this);\n    if (caption) {\n      caption.destroy();\n    \
}\n    if (dropdown) {\n      dropdown.destroy();\n    }\n    \
super.destroy();\n  }\n};\nvar select_default = SelectUI;\n\n// \
node_modules/handsontable/plugins/filters/component/condition.mjs\nvar \
ConditionComponent = class extends base_default3 {\n  \
constructor(hotInstance, options) {\n    super(hotInstance, {\n      id: \
options.id,\n      stateless: false\n    });\n    this.name = options.name;\n \
   this.addSeparator = options.addSeparator;\n    this.elements.push(new \
select_default(this.hot, {\n      menuContainer: options.menuContainer\n    \
}));\n    this.elements.push(new input_default(this.hot, {\n      \
placeholder: FILTERS_BUTTONS_PLACEHOLDER_VALUE\n    }));\n    \
this.elements.push(new input_default(this.hot, {\n      placeholder: \
FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE\n    }));\n    \
this.registerHooks();\n  }\n  /**\n   * Register all necessary hooks.\n   *\n \
  * @private\n   */\n  registerHooks() {\n    \
this.getSelectElement().addLocalHook(\"select\", (command) => \
this.onConditionSelect(command));\n    \
this.getSelectElement().addLocalHook(\"afterClose\", () => \
this.onSelectUIClosed());\n    arrayEach(this.getInputElements(), (input) => \
{\n      input.addLocalHook(\"keydown\", (event2) => \
this.onInputKeyDown(event2));\n    });\n  }\n  /**\n   * Set state of the \
component.\n   *\n   * @param {object} value State to restore.\n   */\n  \
setState(value) {\n    this.reset();\n    if (!value) {\n      return;\n    \
}\n    const copyOfCommand = clone(value.command);\n    if \
(copyOfCommand.name.startsWith(FILTERS_CONDITIONS_NAMESPACE)) {\n      \
copyOfCommand.name = this.hot.getTranslatedPhrase(copyOfCommand.name);\n    \
}\n    this.getSelectElement().setValue(copyOfCommand);\n    \
arrayEach(value.args, (arg, index2) => {\n      if (index2 > \
copyOfCommand.inputsCount - 1) {\n        return false;\n      }\n      const \
element = this.getInputElement(index2);\n      element.setValue(arg);\n      \
element[copyOfCommand.inputsCount > index2 ? \"show\" : \"hide\"]();\n      \
if (!index2) {\n        setTimeout(() => element.focus(), 10);\n      }\n    \
});\n  }\n  /**\n   * Export state of the component (get selected filter and \
filter arguments).\n   *\n   * @returns {object} Returns object where \
`command` key keeps used condition filter and `args` key its arguments.\n   \
*/\n  getState() {\n    const command = this.getSelectElement().getValue() || \
getConditionDescriptor(CONDITION_NAME);\n    const args = [];\n    \
arrayEach(this.getInputElements(), (element, index2) => {\n      if \
(command.inputsCount > index2) {\n        args.push(element.getValue());\n    \
  }\n    });\n    return {\n      command,\n      args\n    };\n  }\n  /**\n  \
 * Update state of component.\n   *\n   * @param {object} condition The \
condition object.\n   * @param {object} condition.command The command object \
with condition name as `key` property.\n   * @param {Array} condition.args An \
array of values to compare.\n   * @param {number} column Physical column \
index.\n   */\n  updateState(condition22, column) {\n    const command = \
condition22 ? getConditionDescriptor(condition22.name) : \
getConditionDescriptor(CONDITION_NAME);\n    \
this.state.setValueAtIndex(column, {\n      command,\n      args: condition22 \
? condition22.args : []\n    });\n    if (!condition22) {\n      \
arrayEach(this.getInputElements(), (element) => element.setValue(null));\n    \
}\n  }\n  /**\n   * Get select element.\n   *\n   * @returns {SelectUI}\n   \
*/\n  getSelectElement() {\n    return this.elements.filter((element) => \
element instanceof select_default)[0];\n  }\n  /**\n   * Get input element.\n \
  *\n   * @param {number} index Index an array of elements.\n   * @returns \
{InputUI}\n   */\n  getInputElement() {\n    let index2 = arguments.length > \
0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    return \
this.getInputElements()[index2];\n  }\n  /**\n   * Get input elements.\n   \
*\n   * @returns {Array}\n   */\n  getInputElements() {\n    return \
this.elements.filter((element) => element instanceof input_default);\n  }\n  \
/**\n   * Get menu object descriptor.\n   *\n   * @returns {object}\n   */\n  \
getMenuItemDescriptor() {\n    return {\n      key: this.id,\n      name: \
this.name,\n      isCommand: false,\n      disableSelection: true,\n      \
hidden: () => this.isHidden(),\n      renderer: (hot2, wrapper, row, col, \
prop, value) => {\n        addClass(wrapper.parentNode, \
\"htFiltersMenuCondition\");\n        if (this.addSeparator) {\n          \
addClass(wrapper.parentNode, \"border\");\n        }\n        const label = \
this.hot.rootDocument.createElement(\"div\");\n        addClass(label, \
\"htFiltersMenuLabel\");\n        label.textContent = value;\n        \
wrapper.appendChild(label);\n        if \
(!wrapper.parentNode.hasAttribute(\"ghost-table\")) {\n          \
arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));\n        \
}\n        return wrapper;\n      }\n    };\n  }\n  /**\n   * Reset elements \
to their initial state.\n   */\n  reset() {\n    const selectedColumn = \
this.hot.getPlugin(\"filters\").getSelectedColumn();\n    let items = \
[getConditionDescriptor(CONDITION_NAME)];\n    if (selectedColumn !== null) \
{\n      const {\n        visualIndex\n      } = selectedColumn;\n      items \
= getOptionsList(this.hot.getDataType(0, visualIndex, this.hot.countRows(), \
visualIndex));\n    }\n    arrayEach(this.getInputElements(), (element) => \
element.hide());\n    this.getSelectElement().setItems(items);\n    \
super.reset();\n    this.getSelectElement().setValue(items[0]);\n  }\n  /**\n \
  * On condition select listener.\n   *\n   * @private\n   * @param {object} \
command Menu item object (command).\n   */\n  onConditionSelect(command) {\n  \
  arrayEach(this.getInputElements(), (element, index2) => {\n      \
element[command.inputsCount > index2 ? \"show\" : \"hide\"]();\n      if \
(index2 === 0) {\n        setTimeout(() => element.focus(), 10);\n      }\n   \
 });\n    this.runLocalHooks(\"change\", command);\n  }\n  /**\n   * On \
component SelectUI closed listener.\n   *\n   * @private\n   */\n  \
onSelectUIClosed() {\n    this.runLocalHooks(\"afterClose\");\n  }\n  /**\n   \
* Key down listener.\n   *\n   * @private\n   * @param {Event} event The DOM \
event object.\n   */\n  onInputKeyDown(event2) {\n    if \
(isKey(event2.keyCode, \"ENTER\")) {\n      this.runLocalHooks(\"accept\");\n \
     stopImmediatePropagation(event2);\n    } else if (isKey(event2.keyCode, \
\"ESCAPE\")) {\n      this.runLocalHooks(\"cancel\");\n      \
stopImmediatePropagation(event2);\n    }\n  }\n};\nvar condition_default = \
ConditionComponent;\n\n// \
node_modules/handsontable/plugins/filters/ui/radioInput.mjs\nvar \
privatePool11 = /* @__PURE__ */ new WeakMap();\nvar RadioInputUI = class \
_RadioInputUI extends base_default4 {\n  static get DEFAULTS() {\n    return \
clone({\n      type: \"radio\",\n      tagName: \"input\",\n      className: \
\"htUIRadio\",\n      label: {}\n    });\n  }\n  constructor(hotInstance, \
options) {\n    super(hotInstance, extend(_RadioInputUI.DEFAULTS, \
options));\n    privatePool11.set(this, {});\n  }\n  /**\n   * Build DOM \
structure.\n   */\n  build() {\n    super.build();\n    const priv = \
privatePool11.get(this);\n    priv.input = this._element.firstChild;\n    \
const label = this.hot.rootDocument.createElement(\"label\");\n    \
label.textContent = \
this.translateIfPossible(this.options.label.textContent);\n    label.htmlFor \
= this.translateIfPossible(this.options.label.htmlFor);\n    priv.label = \
label;\n    this._element.appendChild(label);\n    this.update();\n  }\n  \
/**\n   * Update element.\n   */\n  update() {\n    if (!this.isBuilt()) {\n  \
    return;\n    }\n    const priv = privatePool11.get(this);\n    \
priv.input.checked = this.options.checked;\n    priv.label.textContent = \
this.translateIfPossible(this.options.label.textContent);\n  }\n  /**\n   * \
Check if radio button is checked.\n   *\n   * @returns {boolean}\n   */\n  \
isChecked() {\n    return this.options.checked;\n  }\n  /**\n   * Set input \
checked attribute.\n   *\n   * @param {boolean} value Set the component \
state.\n   */\n  setChecked() {\n    let value = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : true;\n    this.options.checked = \
value;\n    this.update();\n  }\n  /**\n   * Focus element.\n   */\n  focus() \
{\n    if (this.isBuilt()) {\n      privatePool11.get(this).input.focus();\n  \
  }\n  }\n};\nvar radioInput_default = RadioInputUI;\n\n// \
node_modules/handsontable/plugins/filters/component/operators.mjs\nvar \
SELECTED_AT_START_ELEMENT_INDEX = 0;\nvar OperatorsComponent = class extends \
base_default3 {\n  constructor(hotInstance, options) {\n    \
super(hotInstance, {\n      id: options.id,\n      stateless: false\n    \
});\n    this.name = options.name;\n    this.buildOperatorsElement();\n  }\n  \
/**\n   * Get menu object descriptor.\n   *\n   * @returns {object}\n   */\n  \
getMenuItemDescriptor() {\n    return {\n      key: this.id,\n      name: \
this.name,\n      isCommand: false,\n      disableSelection: true,\n      \
hidden: () => this.isHidden(),\n      renderer: (hot2, wrapper) => {\n        \
addClass(wrapper.parentNode, \"htFiltersMenuOperators\");\n        if \
(!wrapper.parentNode.hasAttribute(\"ghost-table\")) {\n          \
arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));\n        \
}\n        return wrapper;\n      }\n    };\n  }\n  /**\n   * Add \
RadioInputUI elements to component.\n   *\n   * @private\n   */\n  \
buildOperatorsElement() {\n    const operationKeys = [OPERATION_ID, \
OPERATION_ID2];\n    arrayEach(operationKeys, (operation) => {\n      const \
radioInput = new radioInput_default(this.hot, {\n        name: \
\"operator\",\n        label: {\n          htmlFor: operation,\n          \
textContent: getOperationName(operation)\n        },\n        value: \
operation,\n        checked: operation === \
operationKeys[SELECTED_AT_START_ELEMENT_INDEX],\n        id: operation\n      \
});\n      radioInput.addLocalHook(\"change\", (event2) => \
this.onRadioInputChange(event2));\n      this.elements.push(radioInput);\n    \
});\n  }\n  /**\n   * Set state of operators component to check radio input \
at specific `index`.\n   *\n   * @param {number} searchedIndex Index of radio \
input to check.\n   */\n  setChecked(searchedIndex) {\n    if \
(this.elements.length < searchedIndex) {\n      throw \
Error(toSingleLine`Radio button with index ${searchedIndex} doesn't \
exist.`);\n    }\n    arrayEach(this.elements, (element, index2) => {\n      \
element.setChecked(index2 === searchedIndex);\n    });\n  }\n  /**\n   * Get \
`id` of active operator.\n   *\n   * @returns {string}\n   */\n  \
getActiveOperationId() {\n    const operationElement = \
this.elements.find((element) => element instanceof radioInput_default && \
element.isChecked());\n    if (operationElement) {\n      return \
operationElement.getValue();\n    }\n    return OPERATION_ID;\n  }\n  /**\n   \
* Export state of the component (get selected operator).\n   *\n   * @returns \
{string} Returns `id` of selected operator.\n   */\n  getState() {\n    \
return this.getActiveOperationId();\n  }\n  /**\n   * Set state of the \
component.\n   *\n   * @param {object} value State to restore.\n   */\n  \
setState(value) {\n    this.reset();\n    if (value && \
this.getActiveOperationId() !== value) {\n      arrayEach(this.elements, \
(element) => {\n        element.setChecked(element.getValue() === value);\n   \
   });\n    }\n  }\n  /**\n   * Update state of component.\n   *\n   * @param \
{string} [operationId='conjunction'] Id of selected operation.\n   * @param \
{number} column Physical column index.\n   */\n  updateState() {\n    let \
operationId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] \
: OPERATION_ID;\n    let column = arguments.length > 1 ? arguments[1] : void \
0;\n    let selectedOperationId = operationId;\n    if (selectedOperationId \
=== OPERATION_ID3) {\n      selectedOperationId = OPERATION_ID2;\n    }\n    \
this.state.setValueAtIndex(column, selectedOperationId);\n  }\n  /**\n   * \
Reset elements to their initial state.\n   */\n  reset() {\n    \
this.setChecked(SELECTED_AT_START_ELEMENT_INDEX);\n  }\n  /**\n   * OnChange \
listener.\n   *\n   * @private\n   * @param {Event} event The DOM event \
object.\n   */\n  onRadioInputChange(event2) {\n    \
this.setState(event2.target.value);\n  }\n};\nvar operators_default = \
OperatorsComponent;\n\n// \
node_modules/handsontable/plugins/filters/ui/link.mjs\nvar privatePool12 = /* \
@__PURE__ */ new WeakMap();\nvar LinkUI = class _LinkUI extends base_default4 \
{\n  static get DEFAULTS() {\n    return clone({\n      href: \"#\",\n      \
tagName: \"a\"\n    });\n  }\n  constructor(hotInstance, options) {\n    \
super(hotInstance, extend(_LinkUI.DEFAULTS, options));\n    \
privatePool12.set(this, {});\n  }\n  /**\n   * Build DOM structure.\n   */\n  \
build() {\n    super.build();\n    const priv = privatePool12.get(this);\n    \
priv.link = this._element.firstChild;\n  }\n  /**\n   * Update element.\n   \
*/\n  update() {\n    if (!this.isBuilt()) {\n      return;\n    }\n    \
privatePool12.get(this).link.textContent = \
this.translateIfPossible(this.options.textContent);\n  }\n};\nvar \
link_default = LinkUI;\n\n// \
node_modules/handsontable/plugins/filters/ui/multipleSelect.mjs\nvar \
privatePool13 = /* @__PURE__ */ new WeakMap();\nvar SHORTCUTS_GROUP7 = \
\"multipleSelect.itemBox\";\nvar MultipleSelectUI = class _MultipleSelectUI \
extends base_default4 {\n  static get DEFAULTS() {\n    return clone({\n      \
className: \"htUIMultipleSelect\",\n      value: []\n    });\n  }\n  \
constructor(hotInstance, options) {\n    super(hotInstance, \
extend(_MultipleSelectUI.DEFAULTS, options));\n    privatePool13.set(this, \
{});\n    this.searchInput = new input_default(this.hot, {\n      \
placeholder: FILTERS_BUTTONS_PLACEHOLDER_SEARCH,\n      className: \
\"htUIMultipleSelectSearch\"\n    });\n    this.selectAllUI = new \
link_default(this.hot, {\n      textContent: FILTERS_BUTTONS_SELECT_ALL,\n    \
  className: \"htUISelectAll\"\n    });\n    this.clearAllUI = new \
link_default(this.hot, {\n      textContent: FILTERS_BUTTONS_CLEAR,\n      \
className: \"htUIClearAll\"\n    });\n    this.items = [];\n    this.itemsBox \
= null;\n    this.registerHooks();\n  }\n  /**\n   * Register all necessary \
hooks.\n   */\n  registerHooks() {\n    \
this.searchInput.addLocalHook(\"keydown\", (event2) => \
this.onInputKeyDown(event2));\n    this.searchInput.addLocalHook(\"input\", \
(event2) => this.onInput(event2));\n    \
this.selectAllUI.addLocalHook(\"click\", (event2) => \
this.onSelectAllClick(event2));\n    this.clearAllUI.addLocalHook(\"click\", \
(event2) => this.onClearAllClick(event2));\n  }\n  /**\n   * Set available \
options.\n   *\n   * @param {Array} items Array of objects with `checked` and \
`label` property.\n   */\n  setItems(items) {\n    this.items = items;\n    \
if (this.itemsBox) {\n      this.itemsBox.loadData(this.items);\n    }\n  }\n \
 /**\n   * Set a locale for the component.\n   *\n   * @param {string} locale \
Locale used for filter actions performed on data, ie. `en-US`.\n   */\n  \
setLocale(locale) {\n    this.locale = locale;\n  }\n  /**\n   * Get a locale \
for the component.\n   *\n   * @returns {string}\n   */\n  getLocale() {\n    \
return this.locale;\n  }\n  /**\n   * Get all available options.\n   *\n   * \
@returns {Array}\n   */\n  getItems() {\n    return [...this.items];\n  }\n  \
/**\n   * Get element value.\n   *\n   * @returns {Array} Array of selected \
values.\n   */\n  getValue() {\n    return itemsToValue(this.items);\n  }\n  \
/**\n   * Check if all values listed in element are selected.\n   *\n   * \
@returns {boolean}\n   */\n  isSelectedAllValues() {\n    return \
this.items.length === this.getValue().length;\n  }\n  /**\n   * Build DOM \
structure.\n   */\n  build() {\n    super.build();\n    const {\n      \
rootDocument\n    } = this.hot;\n    const itemsBoxWrapper = \
rootDocument.createElement(\"div\");\n    const selectionControl = new \
base_default4(this.hot, {\n      className: \"htUISelectionControls\",\n      \
children: [this.selectAllUI, this.clearAllUI]\n    });\n    \
this._element.appendChild(this.searchInput.element);\n    \
this._element.appendChild(selectionControl.element);\n    \
this._element.appendChild(itemsBoxWrapper);\n    const hotInitializer = \
(wrapper) => {\n      if (!this._element) {\n        return;\n      }\n      \
if (this.itemsBox) {\n        this.itemsBox.destroy();\n      }\n      \
addClass(wrapper, \"htUIMultipleSelectHot\");\n      this.itemsBox = new \
this.hot.constructor(wrapper, {\n        data: this.items,\n        columns: \
[{\n          data: \"checked\",\n          type: \"checkbox\",\n          \
label: {\n            property: \"visualValue\",\n            position: \
\"after\"\n          }\n        }],\n        beforeRenderer: (TD, row, col, \
prop, value, cellProperties) => {\n          TD.title = \
cellProperties.instance.getDataAtRowProp(row, \
cellProperties.label.property);\n        },\n        maxCols: 1,\n        \
autoWrapCol: true,\n        height: 110,\n        // Workaround for #151.\n   \
     colWidths: () => this.itemsBox.container.scrollWidth - \
getScrollbarWidth(rootDocument),\n        copyPaste: false,\n        \
disableVisualSelection: \"area\",\n        fillHandle: false,\n        \
fragmentSelection: \"cell\",\n        tabMoves: {\n          row: 1,\n        \
  col: 0\n        },\n        layoutDirection: this.hot.isRtl() ? \"rtl\" : \
\"ltr\"\n      });\n      this.itemsBox.init();\n      const shortcutManager \
= this.itemsBox.getShortcutManager();\n      const gridContext = \
shortcutManager.getContext(\"grid\");\n      gridContext.addShortcut({\n      \
  // TODO: Is this shortcut really needed? We have one test for that case, \
but focus is performed programmatically.\n        keys: [[\"Escape\"]],\n     \
   callback: (event2) => {\n          this.runLocalHooks(\"keydown\", event2, \
this);\n        },\n        group: SHORTCUTS_GROUP7\n      });\n    };\n    \
hotInitializer(itemsBoxWrapper);\n    setTimeout(() => \
hotInitializer(itemsBoxWrapper), 100);\n  }\n  /**\n   * Reset DOM \
structure.\n   */\n  reset() {\n    this.searchInput.reset();\n    \
this.selectAllUI.reset();\n    this.clearAllUI.reset();\n  }\n  /**\n   * \
Update DOM structure.\n   */\n  update() {\n    if (!this.isBuilt()) {\n      \
return;\n    }\n    this.itemsBox.loadData(valueToItems(this.items, \
this.options.value));\n    super.update();\n  }\n  /**\n   * Destroy \
instance.\n   */\n  destroy() {\n    if (this.itemsBox) {\n      \
this.itemsBox.destroy();\n    }\n    this.searchInput.destroy();\n    \
this.clearAllUI.destroy();\n    this.selectAllUI.destroy();\n    \
this.searchInput = null;\n    this.clearAllUI = null;\n    this.selectAllUI = \
null;\n    this.itemsBox = null;\n    this.items = null;\n    \
super.destroy();\n  }\n  /**\n   * 'input' event listener for input \
element.\n   *\n   * @private\n   * @param {Event} event DOM event.\n   */\n  \
onInput(event2) {\n    const value = \
event2.target.value.toLocaleLowerCase(this.getLocale());\n    let \
filteredItems;\n    if (value === \"\") {\n      filteredItems = \
[...this.items];\n    } else {\n      filteredItems = arrayFilter(this.items, \
(item) => `${item.value}`.toLocaleLowerCase(this.getLocale()).indexOf(value) \
>= 0);\n    }\n    this.itemsBox.loadData(filteredItems);\n  }\n  /**\n   * \
'keydown' event listener for input element.\n   *\n   * @private\n   * @param \
{Event} event DOM event.\n   */\n  onInputKeyDown(event2) {\n    \
this.runLocalHooks(\"keydown\", event2, this);\n    const isKeyCode = \
partial(isKey, event2.keyCode);\n    if (isKeyCode(\"ARROW_DOWN|TAB\") && \
!this.itemsBox.isListening()) {\n      stopImmediatePropagation(event2);\n    \
  this.itemsBox.listen();\n      this.itemsBox.selectCell(0, 0);\n    }\n  \
}\n  /**\n   * On click listener for \"Select all\" link.\n   *\n   * \
@private\n   * @param {DOMEvent} event The mouse event object.\n   */\n  \
onSelectAllClick(event2) {\n    const changes = [];\n    \
event2.preventDefault();\n    arrayEach(this.itemsBox.getSourceData(), (row, \
rowIndex) => {\n      row.checked = true;\n      \
changes.push(dataRowToChangesArray(row, rowIndex)[0]);\n    });\n    \
this.itemsBox.setSourceDataAtCell(changes);\n  }\n  /**\n   * On click \
listener for \"Clear\" link.\n   *\n   * @private\n   * @param {DOMEvent} \
event The mouse event object.\n   */\n  onClearAllClick(event2) {\n    const \
changes = [];\n    event2.preventDefault();\n    \
arrayEach(this.itemsBox.getSourceData(), (row, rowIndex) => {\n      \
row.checked = false;\n      changes.push(dataRowToChangesArray(row, \
rowIndex)[0]);\n    });\n    this.itemsBox.setSourceDataAtCell(changes);\n  \
}\n};\nvar multipleSelect_default = MultipleSelectUI;\nfunction \
valueToItems(availableItems, selectedValue) {\n  const arrayAssertion = \
createArrayAssertion(selectedValue);\n  return arrayMap(availableItems, \
(item) => {\n    item.checked = arrayAssertion(item.value);\n    return \
item;\n  });\n}\nfunction itemsToValue(availableItems) {\n  const items = \
[];\n  arrayEach(availableItems, (item) => {\n    if (item.checked) {\n      \
items.push(item.value);\n    }\n  });\n  return items;\n}\n\n// \
node_modules/handsontable/plugins/filters/component/value.mjs\nvar \
ValueComponent = class extends base_default3 {\n  constructor(hotInstance, \
options) {\n    super(hotInstance, {\n      id: options.id,\n      stateless: \
false\n    });\n    this.name = options.name;\n    this.elements.push(new \
multipleSelect_default(this.hot));\n    this.registerHooks();\n  }\n  /**\n   \
* Register all necessary hooks.\n   *\n   * @private\n   */\n  \
registerHooks() {\n    \
this.getMultipleSelectElement().addLocalHook(\"keydown\", (event2) => \
this.onInputKeyDown(event2));\n  }\n  /**\n   * Set state of the component.\n \
  *\n   * @param {object} value The component value.\n   */\n  \
setState(value) {\n    this.reset();\n    if (value && value.command.key === \
CONDITION_NAME21) {\n      const select = this.getMultipleSelectElement();\n  \
    select.setItems(value.itemsSnapshot);\n      \
select.setValue(value.args[0]);\n      select.setLocale(value.locale);\n    \
}\n  }\n  /**\n   * Export state of the component (get selected filter and \
filter arguments).\n   *\n   * @returns {object} Returns object where \
`command` key keeps used condition filter and `args` key its arguments.\n   \
*/\n  getState() {\n    const select = this.getMultipleSelectElement();\n    \
const availableItems = select.getItems();\n    return {\n      command: {\n   \
     key: select.isSelectedAllValues() || !availableItems.length ? \
CONDITION_NAME : CONDITION_NAME21\n      },\n      args: \
[select.getValue()],\n      itemsSnapshot: availableItems\n    };\n  }\n  \
/**\n   * Update state of component.\n   *\n   * @param {object} stateInfo \
Information about state containing stack of edited column,\n   * stack of \
dependent conditions, data factory and optional condition arguments change. \
It's described by object containing keys:\n   * `editedConditionStack`, \
`dependentConditionStacks`, `visibleDataFactory` and `conditionArgsChange`.\n \
  */\n  updateState(stateInfo) {\n    const updateColumnState = \
(physicalColumn, conditions2, conditionArgsChange, filteredRowsFactory, \
conditionsStack) => {\n      const [firstByValueCondition] = \
arrayFilter(conditions2, (condition22) => condition22.name === \
CONDITION_NAME21);\n      const state = {};\n      const \
defaultBlankCellValue = \
this.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);\n      if \
(firstByValueCondition) {\n        const rowValues = \
unifyColumnValues(arrayMap(filteredRowsFactory(physicalColumn, \
conditionsStack), (row) => row.value));\n        if (conditionArgsChange) {\n \
         firstByValueCondition.args[0] = conditionArgsChange;\n        }\n    \
    const selectedValues = [];\n        const itemsSnapshot = \
intersectValues(rowValues, firstByValueCondition.args[0], \
defaultBlankCellValue, (item) => {\n          if (item.checked) {\n           \
 selectedValues.push(item.value);\n          }\n        });\n        const \
column = stateInfo.editedConditionStack.column;\n        state.locale = \
this.hot.getCellMeta(0, column).locale;\n        state.args = \
[selectedValues];\n        state.command = \
getConditionDescriptor(CONDITION_NAME21);\n        state.itemsSnapshot = \
itemsSnapshot;\n      } else {\n        state.args = [];\n        \
state.command = getConditionDescriptor(CONDITION_NAME);\n      }\n      \
this.state.setValueAtIndex(physicalColumn, state);\n    };\n    \
updateColumnState(stateInfo.editedConditionStack.column, \
stateInfo.editedConditionStack.conditions, stateInfo.conditionArgsChange, \
stateInfo.filteredRowsFactory);\n    if \
(stateInfo.dependentConditionStacks.length) {\n      \
updateColumnState(stateInfo.dependentConditionStacks[0].column, \
stateInfo.dependentConditionStacks[0].conditions, \
stateInfo.conditionArgsChange, stateInfo.filteredRowsFactory, \
stateInfo.editedConditionStack);\n    }\n  }\n  /**\n   * Get multiple select \
element.\n   *\n   * @returns {MultipleSelectUI}\n   */\n  \
getMultipleSelectElement() {\n    return this.elements.filter((element) => \
element instanceof multipleSelect_default)[0];\n  }\n  /**\n   * Get object \
descriptor for menu item entry.\n   *\n   * @returns {object}\n   */\n  \
getMenuItemDescriptor() {\n    return {\n      key: this.id,\n      name: \
this.name,\n      isCommand: false,\n      disableSelection: true,\n      \
hidden: () => this.isHidden(),\n      renderer: (hot2, wrapper, row, col, \
prop, value) => {\n        addClass(wrapper.parentNode, \
\"htFiltersMenuValue\");\n        const label = \
this.hot.rootDocument.createElement(\"div\");\n        addClass(label, \
\"htFiltersMenuLabel\");\n        label.textContent = value;\n        \
wrapper.appendChild(label);\n        if \
(!wrapper.parentNode.hasAttribute(\"ghost-table\")) {\n          \
arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));\n        \
}\n        return wrapper;\n      }\n    };\n  }\n  /**\n   * Reset elements \
to their initial state.\n   */\n  reset() {\n    const defaultBlankCellValue \
= this.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);\n    const values \
= unifyColumnValues(this._getColumnVisibleValues());\n    const items = \
intersectValues(values, values, defaultBlankCellValue);\n    \
this.getMultipleSelectElement().setItems(items);\n    super.reset();\n    \
this.getMultipleSelectElement().setValue(values);\n    const selectedColumn = \
this.hot.getPlugin(\"filters\").getSelectedColumn();\n    if (selectedColumn \
!== null) {\n      \
this.getMultipleSelectElement().setLocale(this.hot.getCellMeta(0, \
selectedColumn.visualIndex).locale);\n    }\n  }\n  /**\n   * Key down \
listener.\n   *\n   * @private\n   * @param {Event} event The DOM event \
object.\n   */\n  onInputKeyDown(event2) {\n    if (isKey(event2.keyCode, \
\"ESCAPE\")) {\n      this.runLocalHooks(\"cancel\");\n      \
stopImmediatePropagation(event2);\n    }\n  }\n  /**\n   * Get data for \
currently selected column.\n   *\n   * @returns {Array}\n   * @private\n   \
*/\n  _getColumnVisibleValues() {\n    const selectedColumn = \
this.hot.getPlugin(\"filters\").getSelectedColumn();\n    if (selectedColumn \
=== null) {\n      return [];\n    }\n    return \
arrayMap(this.hot.getDataAtCol(selectedColumn.visualIndex), (v) => \
toEmptyString(v));\n  }\n};\nvar value_default = ValueComponent;\n\n// \
node_modules/handsontable/plugins/filters/component/actionBar.mjs\nvar \
ActionBarComponent = class _ActionBarComponent extends base_default3 {\n  \
static get BUTTON_OK() {\n    return \"ok\";\n  }\n  static get \
BUTTON_CANCEL() {\n    return \"cancel\";\n  }\n  constructor(hotInstance, \
options) {\n    super(hotInstance, {\n      id: options.id,\n      stateless: \
true\n    });\n    this.name = options.name;\n    this.elements.push(new \
input_default(this.hot, {\n      type: \"button\",\n      value: \
FILTERS_BUTTONS_OK,\n      className: \"htUIButton htUIButtonOK\",\n      \
identifier: _ActionBarComponent.BUTTON_OK\n    }));\n    \
this.elements.push(new input_default(this.hot, {\n      type: \"button\",\n   \
   value: FILTERS_BUTTONS_CANCEL,\n      className: \"htUIButton \
htUIButtonCancel\",\n      identifier: _ActionBarComponent.BUTTON_CANCEL\n    \
}));\n    this.registerHooks();\n  }\n  /**\n   * Register all necessary \
hooks.\n   *\n   * @private\n   */\n  registerHooks() {\n    \
arrayEach(this.elements, (element) => {\n      \
element.addLocalHook(\"click\", (event2, button) => \
this.onButtonClick(event2, button));\n    });\n  }\n  /**\n   * Get menu \
object descriptor.\n   *\n   * @returns {object}\n   */\n  \
getMenuItemDescriptor() {\n    return {\n      key: this.id,\n      name: \
this.name,\n      isCommand: false,\n      disableSelection: true,\n      \
hidden: () => this.isHidden(),\n      renderer: (hot2, wrapper) => {\n        \
addClass(wrapper.parentNode, \"htFiltersMenuActionBar\");\n        if \
(!wrapper.parentNode.hasAttribute(\"ghost-table\")) {\n          \
arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));\n        \
}\n        return wrapper;\n      }\n    };\n  }\n  /**\n   * Fire accept \
event.\n   */\n  accept() {\n    this.runLocalHooks(\"accept\");\n  }\n  \
/**\n   * Fire cancel event.\n   */\n  cancel() {\n    \
this.runLocalHooks(\"cancel\");\n  }\n  /**\n   * On button click listener.\n \
  *\n   * @private\n   * @param {Event} event DOM event.\n   * @param \
{InputUI} button InputUI object.\n   */\n  onButtonClick(event2, button) {\n  \
  if (button.options.identifier === _ActionBarComponent.BUTTON_OK) {\n      \
this.accept();\n    } else {\n      this.cancel();\n    }\n  }\n};\nvar \
actionBar_default = ActionBarComponent;\n\n// \
node_modules/handsontable/plugins/filters/conditionCollection.mjs\nvar \
MAP_NAME = \"ConditionCollection.filteringStates\";\nvar ConditionCollection \
= class {\n  constructor(hot2) {\n    let isMapRegistrable = arguments.length \
> 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    this.hot = hot2;\n \
   this.isMapRegistrable = isMapRegistrable;\n    this.filteringStates = new \
LinkedPhysicalIndexToValueMap();\n    if (this.isMapRegistrable === true) {\n \
     this.hot.columnIndexMapper.registerMap(MAP_NAME, \
this.filteringStates);\n    } else {\n      \
this.filteringStates.init(this.hot.columnIndexMapper.getNumberOfIndexes());\n \
   }\n  }\n  /**\n   * Check if condition collection is empty (so no needed \
to filter data).\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    \
return this.getFilteredColumns().length === 0;\n  }\n  /**\n   * Check if \
value is matched to the criteria of conditions chain.\n   *\n   * @param \
{object} value Object with `value` and `meta` keys.\n   * @param {number} \
column The physical column index.\n   * @returns {boolean}\n   */\n  \
isMatch(value, column) {\n    var _stateForColumn$condi;\n    const \
stateForColumn = this.filteringStates.getValueAtIndex(column);\n    const \
conditions2 = (_stateForColumn$condi = stateForColumn === null || \
stateForColumn === void 0 ? void 0 : stateForColumn.conditions) !== null && \
_stateForColumn$condi !== void 0 ? _stateForColumn$condi : [];\n    const \
operation = stateForColumn === null || stateForColumn === void 0 ? void 0 : \
stateForColumn.operation;\n    return this.isMatchInConditions(conditions2, \
value, operation);\n  }\n  /**\n   * Check if the value is matches the \
conditions.\n   *\n   * @param {Array} conditions List of conditions.\n   * \
@param {object} value Object with `value` and `meta` keys.\n   * @param \
{string} [operationType='conjunction'] Type of conditions operation.\n   * \
@returns {boolean}\n   */\n  isMatchInConditions(conditions2, value) {\n    \
let operationType = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : OPERATION_ID;\n    if (conditions2.length) {\n      return \
getOperationFunc(operationType)(conditions2, value);\n    }\n    return \
true;\n  }\n  /**\n   * Add condition to the collection.\n   *\n   * @param \
{number} column The physical column index.\n   * @param {object} \
conditionDefinition Object with keys:\n   *  * `command` Object, Command \
object with condition name as `key` property.\n   *  * `args` Array, \
Condition arguments.\n   * @param {string} [operation='conjunction'] Type of \
conditions operation.\n   * @param {number} [position] Position to which \
condition will be added. When argument is undefined\n   * the condition will \
be processed as the last condition.\n   * @fires \
ConditionCollection#beforeAdd\n   * @fires ConditionCollection#afterAdd\n   \
*/\n  addCondition(column, conditionDefinition) {\n    let operation = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \
OPERATION_ID;\n    let position = arguments.length > 3 ? arguments[3] : void \
0;\n    const localeForColumn = this.hot.getCellMeta(0, column).locale;\n    \
const args = arrayMap(conditionDefinition.args, (v) => typeof v === \
\"string\" ? v.toLocaleLowerCase(localeForColumn) : v);\n    const name = \
conditionDefinition.name || conditionDefinition.command.key;\n    \
this.runLocalHooks(\"beforeAdd\", column);\n    const columnType = \
this.getOperation(column);\n    if (columnType) {\n      if (columnType !== \
operation) {\n        throw Error(toSingleLine`The column of index ${column} \
has been already applied with a \\`${columnType}\\`\\x20\n        filter \
operation. Use \\`removeConditions\\` to clear the current conditions and \
then add new ones.\\x20\n        Mind that you cannot mix different types of \
operations (for instance, if you use \\`conjunction\\`,\\x20\n        use it \
consequently for a particular column).`);\n      }\n    } else if \
(isUndefined(operations[operation])) {\n      throw new \
Error(toSingleLine`Unexpected operation named \\`${operation}\\`. Possible \
ones are\\x20\n        \\`disjunction\\` and \\`conjunction\\`.`);\n    }\n   \
 const conditionsForColumn = this.getConditions(column);\n    if \
(conditionsForColumn.length === 0) {\n      \
this.filteringStates.setValueAtIndex(column, {\n        operation,\n        \
conditions: [{\n          name,\n          args,\n          func: \
getCondition(name, args)\n        }]\n      }, position);\n    } else {\n     \
 conditionsForColumn.push({\n        name,\n        args,\n        func: \
getCondition(name, args)\n      });\n    }\n    \
this.runLocalHooks(\"afterAdd\", column);\n  }\n  /**\n   * Get all added \
conditions from the collection at specified column index.\n   *\n   * @param \
{number} column The physical column index.\n   * @returns {Array} Returns \
conditions collection as an array.\n   */\n  getConditions(column) {\n    var \
_this$filteringStates, _this$filteringStates2;\n    return \
(_this$filteringStates = (_this$filteringStates2 = \
this.filteringStates.getValueAtIndex(column)) === null || \
_this$filteringStates2 === void 0 ? void 0 : \
_this$filteringStates2.conditions) !== null && _this$filteringStates !== void \
0 ? _this$filteringStates : [];\n  }\n  /**\n   * Get operation for \
particular column.\n   *\n   * @param {number} column The physical column \
index.\n   * @returns {string|undefined}\n   */\n  getOperation(column) {\n   \
 var _this$filteringStates3;\n    return (_this$filteringStates3 = \
this.filteringStates.getValueAtIndex(column)) === null || \
_this$filteringStates3 === void 0 ? void 0 : \
_this$filteringStates3.operation;\n  }\n  /**\n   * Get all filtered physical \
columns in the order in which actions are performed.\n   *\n   * @returns \
{Array}\n   */\n  getFilteredColumns() {\n    return \
this.filteringStates.getEntries().map((_ref) => {\n      let [physicalColumn] \
= _ref;\n      return physicalColumn;\n    });\n  }\n  /**\n   * Gets \
position in the filtering states stack for the specific column.\n   *\n   * \
@param {number} column The physical column index.\n   * @returns {number} \
Returns -1 when the column doesn't exist in the stack.\n   */\n  \
getColumnStackPosition(column) {\n    return \
this.getFilteredColumns().indexOf(column);\n  }\n  /**\n   * Export all \
previously added conditions.\n   *\n   * @returns {Array}\n   */\n  \
exportAllConditions() {\n    return \
arrayReduce(this.filteringStates.getEntries(), (allConditions, _ref2) => {\n  \
    let [column, {\n        operation,\n        conditions: conditions2\n     \
 }] = _ref2;\n      allConditions.push({\n        column,\n        \
operation,\n        conditions: arrayMap(conditions2, (_ref3) => {\n          \
let {\n            name,\n            args\n          } = _ref3;\n          \
return {\n            name,\n            args\n          };\n        })\n     \
 });\n      return allConditions;\n    }, []);\n  }\n  /**\n   * Import \
conditions to the collection.\n   *\n   * @param {Array} conditions The \
collection of the conditions.\n   */\n  importAllConditions(conditions2) {\n  \
  this.clean();\n    arrayEach(conditions2, (stack) => {\n      \
arrayEach(stack.conditions, (condition22) => this.addCondition(stack.column, \
condition22));\n    });\n  }\n  /**\n   * Remove conditions at given column \
index.\n   *\n   * @param {number} column The physical column index.\n   * \
@fires ConditionCollection#beforeRemove\n   * @fires \
ConditionCollection#afterRemove\n   */\n  removeConditions(column) {\n    \
this.runLocalHooks(\"beforeRemove\", column);\n    \
this.filteringStates.clearValue(column);\n    \
this.runLocalHooks(\"afterRemove\", column);\n  }\n  /**\n   * Clean all \
conditions collection and reset order stack.\n   *\n   * @fires \
ConditionCollection#beforeClean\n   * @fires ConditionCollection#afterClean\n \
  */\n  clean() {\n    this.runLocalHooks(\"beforeClean\");\n    \
this.filteringStates.clear();\n    this.runLocalHooks(\"afterClean\");\n  }\n \
 /**\n   * Check if at least one condition was added at specified column \
index. And if second parameter is passed then additionally\n   * check if \
condition exists under its name.\n   *\n   * @param {number} column The \
physical column index.\n   * @param {string} [name] Condition name.\n   * \
@returns {boolean}\n   */\n  hasConditions(column, name) {\n    const \
conditions2 = this.getConditions(column);\n    if (name) {\n      return \
conditions2.some((condition22) => condition22.name === name);\n    }\n    \
return conditions2.length > 0;\n  }\n  /**\n   * Destroy object.\n   */\n  \
destroy() {\n    if (this.isMapRegistrable) {\n      \
this.hot.columnIndexMapper.unregisterMap(MAP_NAME);\n    }\n    \
this.filteringStates = null;\n    this.clearLocalHooks();\n  \
}\n};\nmixin(ConditionCollection, localHooks_default);\nvar \
conditionCollection_default = ConditionCollection;\n\n// \
node_modules/handsontable/plugins/filters/dataFilter.mjs\nvar DataFilter = \
class {\n  constructor(conditionCollection) {\n    let columnDataFactory = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => [];\n  \
  this.conditionCollection = conditionCollection;\n    this.columnDataFactory \
= columnDataFactory;\n  }\n  /**\n   * Filter data based on the conditions \
collection.\n   *\n   * @returns {Array}\n   */\n  filter() {\n    let \
filteredData = [];\n    \
arrayEach(this.conditionCollection.getFilteredColumns(), (physicalColumn, \
index2) => {\n      let columnData = \
this.columnDataFactory(physicalColumn);\n      if (index2) {\n        \
columnData = this._getIntersectData(columnData, filteredData);\n      }\n     \
 filteredData = this.filterByColumn(physicalColumn, columnData);\n    });\n   \
 return filteredData;\n  }\n  /**\n   * Filter data based on specified \
physical column index.\n   *\n   * @param {number} column The physical column \
index.\n   * @param {Array} [dataSource] Data source as array of objects with \
`value` and `meta` keys (e.g. `{value: 'foo', meta: {}}`).\n   * @returns \
{Array} Returns filtered data.\n   */\n  filterByColumn(column) {\n    let \
dataSource = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
[];\n    const filteredData = [];\n    arrayEach(dataSource, (dataRow) => {\n \
     if (dataRow !== void 0 && this.conditionCollection.isMatch(dataRow, \
column)) {\n        filteredData.push(dataRow);\n      }\n    });\n    return \
filteredData;\n  }\n  /**\n   * Intersect data.\n   *\n   * @private\n   * \
@param {Array} data The data to intersect.\n   * @param {Array} needles The \
collection intersected rows with the data.\n   * @returns {Array}\n   */\n  \
_getIntersectData(data2, needles) {\n    const result = [];\n    \
arrayEach(needles, (needleRow) => {\n      const row = \
needleRow.meta.visualRow;\n      if (data2[row] !== void 0) {\n        \
result[row] = data2[row];\n      }\n    });\n    return result;\n  }\n};\nvar \
dataFilter_default = DataFilter;\n\n// \
node_modules/handsontable/plugins/filters/conditionUpdateObserver.mjs\nvar \
ConditionUpdateObserver = class {\n  constructor(hot2, conditionCollection) \
{\n    let columnDataFactory = arguments.length > 2 && arguments[2] !== void \
0 ? arguments[2] : () => [];\n    this.hot = hot2;\n    \
this.conditionCollection = conditionCollection;\n    this.columnDataFactory = \
columnDataFactory;\n    this.changes = [];\n    this.grouping = false;\n    \
this.latestEditedColumnPosition = -1;\n    this.latestOrderStack = [];\n    \
this.conditionCollection.addLocalHook(\"beforeRemove\", (column) => \
this._onConditionBeforeModify(column));\n    \
this.conditionCollection.addLocalHook(\"afterRemove\", (column) => \
this.updateStatesAtColumn(column));\n    \
this.conditionCollection.addLocalHook(\"afterAdd\", (column) => \
this.updateStatesAtColumn(column));\n    \
this.conditionCollection.addLocalHook(\"beforeClean\", () => \
this._onConditionBeforeClean());\n    \
this.conditionCollection.addLocalHook(\"afterClean\", () => \
this._onConditionAfterClean());\n  }\n  /**\n   * Enable grouping changes. \
Grouping is helpful in situations when a lot of conditions is added in one \
moment. Instead of\n   * trigger `update` hook for every condition by \
adding/removing you can group this changes and call `flush` method to \
trigger\n   * it once.\n   */\n  groupChanges() {\n    this.grouping = \
true;\n  }\n  /**\n   * Flush all collected changes. This trigger `update` \
hook for every previously collected change from condition collection.\n   \
*/\n  flush() {\n    this.grouping = false;\n    arrayEach(this.changes, \
(column) => {\n      this.updateStatesAtColumn(column);\n    });\n    \
this.changes.length = 0;\n  }\n  /**\n   * On before modify condition (add or \
remove from collection),.\n   *\n   * @param {number} column Column index.\n  \
 * @private\n   */\n  _onConditionBeforeModify(column) {\n    \
this.latestEditedColumnPosition = \
this.conditionCollection.getColumnStackPosition(column);\n  }\n  /**\n   * \
Update all related states which should be changed after invoking changes \
applied to current column.\n   *\n   * @param {number} column The column \
index.\n   * @param {object} conditionArgsChange Object describing condition \
changes which can be handled by filters on `update` hook.\n   * It contains \
keys `conditionKey` and `conditionValue` which refers to change specified key \
of condition to specified value\n   * based on referred keys.\n   */\n  \
updateStatesAtColumn(column, conditionArgsChange) {\n    var _this = this;\n  \
  if (this.grouping) {\n      if (this.changes.indexOf(column) === -1) {\n    \
    this.changes.push(column);\n      }\n      return;\n    }\n    const \
allConditions = this.conditionCollection.exportAllConditions();\n    let \
editedColumnPosition = \
this.conditionCollection.getColumnStackPosition(column);\n    if \
(editedColumnPosition === -1) {\n      editedColumnPosition = \
this.latestEditedColumnPosition;\n    }\n    const conditionsBefore = \
allConditions.slice(0, editedColumnPosition);\n    const conditionsAfter = \
allConditions.slice(editedColumnPosition);\n    if (conditionsAfter.length && \
conditionsAfter[0].column === column) {\n      conditionsAfter.shift();\n    \
}\n    const visibleDataFactory = curry(function(curriedConditionsBefore, \
curriedColumn) {\n      let conditionsStack = arguments.length > 2 && \
arguments[2] !== void 0 ? arguments[2] : [];\n      const \
splitConditionCollection = new conditionCollection_default(_this.hot, \
false);\n      const curriedConditionsBeforeArray = \
[].concat(curriedConditionsBefore, conditionsStack);\n      \
splitConditionCollection.importAllConditions(curriedConditionsBeforeArray);\n \
     const allRows = _this.columnDataFactory(curriedColumn);\n      let \
visibleRows;\n      if (splitConditionCollection.isEmpty()) {\n        \
visibleRows = allRows;\n      } else {\n        visibleRows = new \
dataFilter_default(splitConditionCollection, (columnData) => \
_this.columnDataFactory(columnData)).filter();\n      }\n      visibleRows = \
arrayMap(visibleRows, (rowData) => rowData.meta.visualRow);\n      const \
visibleRowsAssertion = createArrayAssertion(visibleRows);\n      \
splitConditionCollection.destroy();\n      return arrayFilter(allRows, \
(rowData) => visibleRowsAssertion(rowData.meta.visualRow));\n    \
})(conditionsBefore);\n    const editedConditions = \
[].concat(this.conditionCollection.getConditions(column));\n    \
this.runLocalHooks(\"update\", {\n      editedConditionStack: {\n        \
column,\n        conditions: editedConditions\n      },\n      \
dependentConditionStacks: conditionsAfter,\n      filteredRowsFactory: \
visibleDataFactory,\n      conditionArgsChange\n    });\n  }\n  /**\n   * On \
before conditions clean listener.\n   *\n   * @private\n   */\n  \
_onConditionBeforeClean() {\n    this.latestOrderStack = \
this.conditionCollection.getFilteredColumns();\n  }\n  /**\n   * On after \
conditions clean listener.\n   *\n   * @private\n   */\n  \
_onConditionAfterClean() {\n    arrayEach(this.latestOrderStack, (column) => \
{\n      this.updateStatesAtColumn(column);\n    });\n  }\n  /**\n   * \
Destroy instance.\n   */\n  destroy() {\n    this.clearLocalHooks();\n    \
objectEach(this, (value, property) => {\n      this[property] = null;\n    \
});\n  }\n};\nmixin(ConditionUpdateObserver, localHooks_default);\nvar \
conditionUpdateObserver_default = ConditionUpdateObserver;\n\n// \
node_modules/handsontable/plugins/filters/filters.mjs\nvar PLUGIN_KEY16 = \
\"filters\";\nvar PLUGIN_PRIORITY15 = 250;\nvar Filters = class extends \
BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY16;\n  }\n  \
static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY15;\n  }\n  static \
get PLUGIN_DEPS() {\n    return [\"plugin:DropdownMenu\", \
\"plugin:HiddenRows\", \"cell-type:checkbox\"];\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.eventManager = \
new eventManager_default(this);\n    this.dropdownMenuPlugin = null;\n    \
this.conditionCollection = null;\n    this.conditionUpdateObserver = null;\n  \
  this.components = /* @__PURE__ */ new Map([[\"filter_by_condition\", null], \
[\"filter_operators\", null], [\"filter_by_condition2\", null], \
[\"filter_by_value\", null], [\"filter_action_bar\", null]]);\n    \
this.filtersRowsMap = null;\n    this.hot.addHook(\"afterGetColHeader\", \
(col, TH) => this.onAfterGetColHeader(col, TH));\n  }\n  /**\n   * Checks if \
the plugin is enabled in the handsontable settings. This method is executed \
in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the \
{@link Filters#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
this.hot.getSettings()[PLUGIN_KEY16] ? true : false;\n  }\n  /**\n   * \
Enables the plugin functionality for this Handsontable instance.\n   */\n  \
enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    \
this.filtersRowsMap = this.hot.rowIndexMapper.registerMap(this.pluginName, \
new TrimmingMap());\n    this.dropdownMenuPlugin = \
this.hot.getPlugin(\"dropdownMenu\");\n    const dropdownSettings = \
this.hot.getSettings().dropdownMenu;\n    const menuContainer = \
dropdownSettings && dropdownSettings.uiContainer || \
this.hot.rootDocument.body;\n    const addConfirmationHooks = (component) => \
{\n      component.addLocalHook(\"accept\", () => \
this.onActionBarSubmit(\"accept\"));\n      \
component.addLocalHook(\"cancel\", () => \
this.onActionBarSubmit(\"cancel\"));\n      \
component.addLocalHook(\"change\", (command) => \
this.onComponentChange(component, command));\n      return component;\n    \
};\n    const filterByConditionLabel = () => \
`${this.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_CONDITION)}:`;\n    \
const filterValueLabel = () => \
`${this.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_VALUE)}:`;\n    if \
(!this.components.get(\"filter_by_condition\")) {\n      const \
conditionComponent = new condition_default(this.hot, {\n        id: \
\"filter_by_condition\",\n        name: filterByConditionLabel,\n        \
addSeparator: false,\n        menuContainer\n      });\n      \
conditionComponent.addLocalHook(\"afterClose\", () => \
this.onSelectUIClosed());\n      this.components.set(\"filter_by_condition\", \
addConfirmationHooks(conditionComponent));\n    }\n    if \
(!this.components.get(\"filter_operators\")) {\n      \
this.components.set(\"filter_operators\", new operators_default(this.hot, {\n \
       id: \"filter_operators\",\n        name: \"Operators\"\n      }));\n   \
 }\n    if (!this.components.get(\"filter_by_condition2\")) {\n      const \
conditionComponent = new condition_default(this.hot, {\n        id: \
\"filter_by_condition2\",\n        name: \"\",\n        addSeparator: true,\n \
       menuContainer\n      });\n      \
conditionComponent.addLocalHook(\"afterClose\", () => \
this.onSelectUIClosed());\n      \
this.components.set(\"filter_by_condition2\", \
addConfirmationHooks(conditionComponent));\n    }\n    if \
(!this.components.get(\"filter_by_value\")) {\n      \
this.components.set(\"filter_by_value\", addConfirmationHooks(new \
value_default(this.hot, {\n        id: \"filter_by_value\",\n        name: \
filterValueLabel\n      })));\n    }\n    if \
(!this.components.get(\"filter_action_bar\")) {\n      \
this.components.set(\"filter_action_bar\", addConfirmationHooks(new \
actionBar_default(this.hot, {\n        id: \"filter_action_bar\",\n        \
name: \"Action bar\"\n      })));\n    }\n    if (!this.conditionCollection) \
{\n      this.conditionCollection = new \
conditionCollection_default(this.hot);\n    }\n    if \
(!this.conditionUpdateObserver) {\n      this.conditionUpdateObserver = new \
conditionUpdateObserver_default(this.hot, this.conditionCollection, \
(physicalColumn) => this.getDataMapAtColumn(physicalColumn));\n      \
this.conditionUpdateObserver.addLocalHook(\"update\", (conditionState) => \
this.updateComponents(conditionState));\n    }\n    \
this.components.forEach((component) => component.show());\n    \
this.addHook(\"beforeDropdownMenuSetItems\", (items) => \
this.onBeforeDropdownMenuSetItems(items));\n    \
this.addHook(\"afterDropdownMenuDefaultOptions\", (defaultOptions) => \
this.onAfterDropdownMenuDefaultOptions(defaultOptions));\n    \
this.addHook(\"afterDropdownMenuShow\", () => \
this.onAfterDropdownMenuShow());\n    this.addHook(\"afterDropdownMenuHide\", \
() => this.onAfterDropdownMenuHide());\n    this.addHook(\"afterChange\", \
(changes) => this.onAfterChange(changes));\n    if \
(this.hot.getSettings().dropdownMenu && this.dropdownMenuPlugin) {\n      \
this.dropdownMenuPlugin.disablePlugin();\n      \
this.dropdownMenuPlugin.enablePlugin();\n    }\n    super.enablePlugin();\n  \
}\n  /**\n   * Disables the plugin functionality for this Handsontable \
instance.\n   */\n  disablePlugin() {\n    if (this.enabled) {\n      var \
_this$dropdownMenuPlu;\n      if ((_this$dropdownMenuPlu = \
this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu !== void 0 && \
_this$dropdownMenuPlu.enabled) {\n        \
this.dropdownMenuPlugin.menu.clearLocalHooks();\n      }\n      \
this.components.forEach((component, key) => {\n        component.destroy();\n \
       this.components.set(key, null);\n      });\n      \
this.conditionCollection.destroy();\n      this.conditionCollection = null;\n \
     this.hot.rowIndexMapper.unregisterMap(this.pluginName);\n    }\n    \
super.disablePlugin();\n  }\n  /* eslint-disable \
jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof \
Filters#\n   * @function addCondition\n   * @description\n   * Adds condition \
to the conditions collection at specified column index.\n   *\n   * Possible \
predefined conditions:\n   *  * `begins_with` - Begins with\n   *  * \
`between` - Between\n   *  * `by_value` - By value\n   *  * `contains` - \
Contains\n   *  * `date_after` - After a date\n   *  * `date_before` - Before \
a date\n   *  * `date_today` - Today\n   *  * `date_tomorrow` - Tomorrow\n   \
*  * `date_yesterday` - Yesterday\n   *  * `empty` - Empty\n   *  * \
`ends_with` - Ends with\n   *  * `eq` - Equal\n   *  * `gt` - Greater than\n  \
 *  * `gte` - Greater than or equal\n   *  * `lt` - Less than\n   *  * `lte` \
- Less than or equal\n   *  * `none` - None (no filter)\n   *  * \
`not_between` - Not between\n   *  * `not_contains` - Not contains\n   *  * \
`not_empty` - Not empty\n   *  * `neq` - Not equal.\n   *\n   * Possible \
operations on collection of conditions:\n   *  * `conjunction` - \
[**Conjunction**](https://en.wikipedia.org/wiki/Logical_conjunction) on \
conditions collection (by default), i.e. for such operation: <br/> c1 AND c2 \
AND c3 AND c4 ... AND cn === TRUE, where c1 ... cn are conditions.\n   *  * \
`disjunction` - \
[**Disjunction**](https://en.wikipedia.org/wiki/Logical_disjunction) on \
conditions collection, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 \
... OR cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.\n   *  * \
`disjunctionWithExtraCondition` - **Disjunction** on first `n - 1`\\* \
conditions from collection with an extra requirement computed from the last \
condition, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 ... OR cn-1 \
AND cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.\n   *\n   * \\* \
when `n` is collection size; it's used i.e. for one operation introduced from \
UI (when choosing from filter's drop-down menu two conditions with OR \
operator between them, mixed with choosing values from the multiple choice \
select)\n   *\n   * **Note**: Mind that you cannot mix different types of \
operations (for instance, if you use `conjunction`, use it consequently for a \
particular column).\n   *\n   * @example\n   * ::: only-for javascript\n   * \
```js\n   * const container = document.getElementById('example');\n   * const \
hot = new Handsontable(container, {\n   *   data: getData(),\n   *   filters: \
true\n   * });\n   *\n   * // access to filters plugin instance\n   * const \
filtersPlugin = hot.getPlugin('filters');\n   *\n   * // add filter \"Greater \
than\" 95 to column at index 1\n   * filtersPlugin.addCondition(1, 'gt', \
[95]);\n   * filtersPlugin.filter();\n   *\n   * // add filter \"By value\" \
to column at index 1\n   * // in this case all value's that don't match will \
be filtered.\n   * filtersPlugin.addCondition(1, 'by_value', [['ing', 'ed', \
'as', 'on']]);\n   * filtersPlugin.filter();\n   *\n   * // add filter \
\"Begins with\" with value \"de\" AND \"Not contains\" with value \"ing\"\n   \
* filtersPlugin.addCondition(1, 'begins_with', ['de'], 'conjunction');\n   * \
filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'conjunction');\n   * \
filtersPlugin.filter();\n   *\n   * // add filter \"Begins with\" with value \
\"de\" OR \"Not contains\" with value \"ing\"\n   * \
filtersPlugin.addCondition(1, 'begins_with', ['de'], 'disjunction');\n   * \
filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'disjunction');\n   * \
filtersPlugin.filter();\n   * ```\n   * :::\n   *\n   * ::: only-for react\n  \
 * ```jsx\n   * const hotRef = useRef(null);\n   *\n   * ...\n   *\n   * \
<HotTable\n   *   ref={hotRef}\n   *   data={getData()}\n   *   \
filters={true}\n   * />\n   *\n   * // access to filters plugin instance\n   \
* const hot = hotRef.current.hotInstance;\n   * const filtersPlugin = \
hot.getPlugin('filters');\n   *\n   * // add filter \"Greater than\" 95 to \
column at index 1\n   * filtersPlugin.addCondition(1, 'gt', [95]);\n   * \
filtersPlugin.filter();\n   *\n   * // add filter \"By value\" to column at \
index 1\n   * // in this case all value's that don't match will be \
filtered.\n   * filtersPlugin.addCondition(1, 'by_value', [['ing', 'ed', \
'as', 'on']]);\n   * filtersPlugin.filter();\n   *\n   * // add filter \
\"Begins with\" with value \"de\" AND \"Not contains\" with value \"ing\"\n   \
* filtersPlugin.addCondition(1, 'begins_with', ['de'], 'conjunction');\n   * \
filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'conjunction');\n   * \
filtersPlugin.filter();\n   *\n   * // add filter \"Begins with\" with value \
\"de\" OR \"Not contains\" with value \"ing\"\n   * \
filtersPlugin.addCondition(1, 'begins_with', ['de'], 'disjunction');\n   * \
filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'disjunction');\n   * \
filtersPlugin.filter();\n   * ```\n   * :::\n   *\n   * @param {number} \
column Visual column index.\n   * @param {string} name Condition short \
name.\n   * @param {Array} args Condition arguments.\n   * @param {string} \
[operationId=conjunction] `id` of operation which is performed on the \
column.\n   */\n  /* eslint-enable \
jsdoc/require-description-complete-sentence */\n  addCondition(column, name, \
args) {\n    let operationId = arguments.length > 3 && arguments[3] !== void \
0 ? arguments[3] : OPERATION_ID;\n    const physicalColumn = \
this.hot.toPhysicalColumn(column);\n    \
this.conditionCollection.addCondition(physicalColumn, {\n      command: {\n   \
     key: name\n      },\n      args\n    }, operationId);\n  }\n  /**\n   * \
Removes conditions at specified column index.\n   *\n   * @param {number} \
column Visual column index.\n   */\n  removeConditions(column) {\n    const \
physicalColumn = this.hot.toPhysicalColumn(column);\n    \
this.conditionCollection.removeConditions(physicalColumn);\n  }\n  /**\n   * \
Clears all conditions previously added to the collection for the specified \
column index or, if the column index\n   * was not passed, clear the \
conditions for all columns.\n   *\n   * @param {number} [column] Visual \
column index.\n   */\n  clearConditions(column) {\n    if (column === void 0) \
{\n      this.conditionCollection.clean();\n    } else {\n      const \
physicalColumn = this.hot.toPhysicalColumn(column);\n      \
this.conditionCollection.removeConditions(physicalColumn);\n    }\n  }\n  \
/**\n   * Filters data based on added filter conditions.\n   *\n   * @fires \
Hooks#beforeFilter\n   * @fires Hooks#afterFilter\n   */\n  filter() {\n    \
const dataFilter = this._createDataFilter();\n    const needToFilter = \
!this.conditionCollection.isEmpty();\n    let visibleVisualRows = [];\n    \
const conditions2 = this.conditionCollection.exportAllConditions();\n    \
const allowFiltering = this.hot.runHooks(\"beforeFilter\", conditions2);\n    \
if (allowFiltering !== false) {\n      if (needToFilter) {\n        const \
trimmedRows = [];\n        this.hot.batchExecution(() => {\n          \
this.filtersRowsMap.clear();\n          visibleVisualRows = \
arrayMap(dataFilter.filter(), (rowData) => rowData.meta.visualRow);\n         \
 const visibleVisualRowsAssertion = \
createArrayAssertion(visibleVisualRows);\n          \
rangeEach(this.hot.countSourceRows() - 1, (row) => {\n            if \
(!visibleVisualRowsAssertion(row)) {\n              trimmedRows.push(row);\n  \
          }\n          });\n          arrayEach(trimmedRows, (physicalRow) => \
{\n            this.filtersRowsMap.setValueAtIndex(physicalRow, true);\n      \
    });\n        }, true);\n        if (!visibleVisualRows.length) {\n        \
  this.hot.deselectCell();\n        }\n      } else {\n        \
this.filtersRowsMap.clear();\n      }\n    }\n    \
this.hot.runHooks(\"afterFilter\", conditions2);\n    \
this.hot.view.adjustElementsSize(true);\n    this.hot.render();\n    \
this.clearColumnSelection();\n  }\n  /**\n   * Gets last selected column \
index.\n   *\n   * @returns {{visualIndex: number, physicalIndex: number} | \
null} Returns `null` when a column is\n   * not selected. Otherwise, returns \
an object with `visualIndex` and `physicalIndex` properties containing\n   * \
the index of the column.\n   */\n  getSelectedColumn() {\n    var \
_this$hot$getSelected;\n    const highlight = (_this$hot$getSelected = \
this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 \
? void 0 : _this$hot$getSelected.highlight;\n    if (!highlight) {\n      \
return null;\n    }\n    return {\n      visualIndex: highlight.col,\n      \
physicalIndex: this.hot.toPhysicalColumn(highlight.col)\n    };\n  }\n  /**\n \
  * Clears column selection.\n   *\n   * @private\n   */\n  \
clearColumnSelection() {\n    const selectedColumn = \
this.getSelectedColumn();\n    if (selectedColumn !== null) {\n      \
this.hot.selectCell(0, selectedColumn.visualIndex);\n    }\n  }\n  /**\n   * \
Returns handsontable source data with cell meta based on current selection.\n \
  *\n   * @param {number} [column] The physical column index. By default \
column index accept the value of the selected column.\n   * @returns {Array} \
Returns array of objects where keys as row index.\n   */\n  \
getDataMapAtColumn(column) {\n    const visualColumn = \
this.hot.toVisualColumn(column);\n    const data2 = [];\n    \
arrayEach(this.hot.getSourceDataAtCol(visualColumn), (value, rowIndex) => {\n \
     var _this$hot$getDataAtCe;\n      const {\n        row,\n        col,\n  \
      visualCol,\n        visualRow,\n        type,\n        instance,\n      \
  dateFormat,\n        locale\n      } = this.hot.getCellMeta(rowIndex, \
visualColumn);\n      const dataValue = (_this$hot$getDataAtCe = \
this.hot.getDataAtCell(this.hot.toVisualRow(rowIndex), visualColumn)) !== \
null && _this$hot$getDataAtCe !== void 0 ? _this$hot$getDataAtCe : value;\n   \
   data2.push({\n        meta: {\n          row,\n          col,\n          \
visualCol,\n          visualRow,\n          type,\n          instance,\n      \
    dateFormat,\n          locale\n        },\n        value: \
toEmptyString(dataValue)\n      });\n    });\n    return data2;\n  }\n  /**\n \
  * `afterChange` listener.\n   *\n   * @private\n   * @param {Array} changes \
Array of changes.\n   */\n  onAfterChange(changes) {\n    if (changes) {\n    \
  arrayEach(changes, (change) => {\n        const [, prop] = change;\n        \
const columnIndex = this.hot.propToCol(prop);\n        if \
(this.conditionCollection.hasConditions(columnIndex)) {\n          \
this.updateValueComponentCondition(columnIndex);\n        }\n      });\n    \
}\n  }\n  /**\n   * Update the condition of ValueComponent, based on the \
handled changes.\n   *\n   * @private\n   * @param {number} columnIndex \
Column index of handled ValueComponent condition.\n   */\n  \
updateValueComponentCondition(columnIndex) {\n    const dataAtCol = \
this.hot.getDataAtCol(columnIndex);\n    const selectedValues = \
unifyColumnValues(dataAtCol);\n    \
this.conditionUpdateObserver.updateStatesAtColumn(columnIndex, \
selectedValues);\n  }\n  /**\n   * Restores components to its saved state.\n  \
 *\n   * @private\n   * @param {Array} components List of components.\n   \
*/\n  restoreComponents(components) {\n    var _this$getSelectedColu;\n    \
const physicalIndex = (_this$getSelectedColu = this.getSelectedColumn()) === \
null || _this$getSelectedColu === void 0 ? void 0 : \
_this$getSelectedColu.physicalIndex;\n    components.forEach((component) => \
{\n      if (component.isHidden()) {\n        return;\n      }\n      \
component.restoreState(physicalIndex);\n    });\n    \
this.updateDependentComponentsVisibility();\n  }\n  /**\n   * After dropdown \
menu show listener.\n   *\n   * @private\n   */\n  onAfterDropdownMenuShow() \
{\n    this.restoreComponents(Array.from(this.components.values()));\n  }\n  \
/**\n   * After dropdown menu hide listener.\n   *\n   * @private\n   */\n  \
onAfterDropdownMenuHide() {\n    \
this.components.get(\"filter_by_condition\").getSelectElement().closeOptions(\
);\n    \
this.components.get(\"filter_by_condition2\").getSelectElement().closeOptions\
();\n  }\n  /**\n   * Before dropdown menu set menu items listener.\n   *\n   \
* @private\n   */\n  onBeforeDropdownMenuSetItems() {\n    if \
(this.dropdownMenuPlugin) {\n      \
this.dropdownMenuPlugin.menu.addLocalHook(\"afterOpen\", () => {\n        \
this.dropdownMenuPlugin.menu.hotMenu.updateSettings({\n          hiddenRows: \
true\n        });\n      });\n    }\n  }\n  /**\n   * After dropdown menu \
default options listener.\n   *\n   * @private\n   * @param {object} \
defaultOptions ContextMenu default item options.\n   */\n  \
onAfterDropdownMenuDefaultOptions(defaultOptions) {\n    \
defaultOptions.items.push({\n      name: KEY\n    });\n    \
this.components.forEach((component) => {\n      \
defaultOptions.items.push(component.getMenuItemDescriptor());\n    });\n  }\n \
 /**\n   * Get an operation, based on the number and types of arguments \
(where arguments are states of components).\n   *\n   * @param {string} \
suggestedOperation Operation which was chosen by user from UI.\n   * @param \
{object} byConditionState1 State of first condition component.\n   * @param \
{object} byConditionState2 State of second condition component.\n   * @param \
{object} byValueState State of value component.\n   * @private\n   * @returns \
{string}\n   */\n  getOperationBasedOnArguments(suggestedOperation, \
byConditionState1, byConditionState2, byValueState) {\n    let operation = \
suggestedOperation;\n    if (operation === OPERATION_ID2 && \
byConditionState1.command.key !== CONDITION_NAME && \
byConditionState2.command.key !== CONDITION_NAME && byValueState.command.key \
!== CONDITION_NAME) {\n      operation = OPERATION_ID3;\n    } else if \
(byValueState.command.key !== CONDITION_NAME) {\n      if \
(byConditionState1.command.key === CONDITION_NAME || \
byConditionState2.command.key === CONDITION_NAME) {\n        operation = \
OPERATION_ID;\n      }\n    }\n    return operation;\n  }\n  /**\n   * On \
action bar submit listener.\n   *\n   * @private\n   * @param {string} \
submitType The submit type.\n   */\n  onActionBarSubmit(submitType) {\n    \
var _this$dropdownMenuPlu3;\n    if (submitType === \"accept\") {\n      \
const selectedColumn = this.getSelectedColumn();\n      if (selectedColumn \
=== null) {\n        var _this$dropdownMenuPlu2;\n        \
(_this$dropdownMenuPlu2 = this.dropdownMenuPlugin) === null || \
_this$dropdownMenuPlu2 === void 0 || _this$dropdownMenuPlu2.close();\n        \
return;\n      }\n      const {\n        physicalIndex\n      } = \
selectedColumn;\n      const byConditionState1 = \
this.components.get(\"filter_by_condition\").getState();\n      const \
byConditionState2 = \
this.components.get(\"filter_by_condition2\").getState();\n      const \
byValueState = this.components.get(\"filter_by_value\").getState();\n      \
const operation = \
this.getOperationBasedOnArguments(this.components.get(\"filter_operators\").g\
etActiveOperationId(), byConditionState1, byConditionState2, byValueState);\n \
     this.conditionUpdateObserver.groupChanges();\n      let \
columnStackPosition = \
this.conditionCollection.getColumnStackPosition(physicalIndex);\n      if \
(columnStackPosition === -1) {\n        columnStackPosition = void 0;\n      \
}\n      this.conditionCollection.removeConditions(physicalIndex);\n      if \
(byConditionState1.command.key !== CONDITION_NAME) {\n        \
this.conditionCollection.addCondition(physicalIndex, byConditionState1, \
operation, columnStackPosition);\n        if (byConditionState2.command.key \
!== CONDITION_NAME) {\n          \
this.conditionCollection.addCondition(physicalIndex, byConditionState2, \
operation, columnStackPosition);\n        }\n      }\n      if \
(byValueState.command.key !== CONDITION_NAME) {\n        \
this.conditionCollection.addCondition(physicalIndex, byValueState, operation, \
columnStackPosition);\n      }\n      this.conditionUpdateObserver.flush();\n \
     this.components.forEach((component) => \
component.saveState(physicalIndex));\n      this.filtersRowsMap.clear();\n    \
  this.filter();\n    }\n    (_this$dropdownMenuPlu3 = \
this.dropdownMenuPlugin) === null || _this$dropdownMenuPlu3 === void 0 || \
_this$dropdownMenuPlu3.close();\n  }\n  /**\n   * On component change \
listener.\n   *\n   * @private\n   * @param {BaseComponent} component \
Component inheriting BaseComponent.\n   * @param {object} command Menu item \
object (command).\n   */\n  onComponentChange(component, command) {\n    \
this.updateDependentComponentsVisibility();\n    if (component.constructor \
=== condition_default && !command.inputsCount) {\n      \
this.setListeningDropdownMenu();\n    }\n  }\n  /**\n   * On component \
SelectUI closed listener.\n   *\n   * @private\n   */\n  onSelectUIClosed() \
{\n    this.setListeningDropdownMenu();\n  }\n  /**\n   * Listen to the \
keyboard input on document body and forward events to instance of \
Handsontable\n   * created by DropdownMenu plugin.\n   *\n   * @private\n   \
*/\n  setListeningDropdownMenu() {\n    if (this.dropdownMenuPlugin) {\n      \
this.dropdownMenuPlugin.setListening();\n    }\n  }\n  /**\n   * Updates \
visibility of some of the components, based on the state of the parent \
component.\n   *\n   * @private\n   */\n  \
updateDependentComponentsVisibility() {\n    const component = \
this.components.get(\"filter_by_condition\");\n    const {\n      command\n   \
 } = component.getState();\n    const componentsToShow = \
[this.components.get(\"filter_by_condition2\"), \
this.components.get(\"filter_operators\")];\n    if (command.showOperators) \
{\n      this.showComponents(...componentsToShow);\n    } else {\n      \
this.hideComponents(...componentsToShow);\n    }\n  }\n  /**\n   * On after \
get column header listener.\n   *\n   * @private\n   * @param {number} col \
Visual column index.\n   * @param {HTMLTableCellElement} TH Header's TH \
element.\n   */\n  onAfterGetColHeader(col, TH) {\n    const physicalColumn = \
this.hot.toPhysicalColumn(col);\n    if (this.enabled && \
this.conditionCollection.hasConditions(physicalColumn)) {\n      addClass(TH, \
\"htFiltersActive\");\n    } else {\n      removeClass(TH, \
\"htFiltersActive\");\n    }\n  }\n  /**\n   * Creates DataFilter instance \
based on condition collection.\n   *\n   * @private\n   * @param \
{ConditionCollection} conditionCollection Condition collection object.\n   * \
@returns {DataFilter}\n   */\n  _createDataFilter() {\n    let \
conditionCollection = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : this.conditionCollection;\n    return new \
dataFilter_default(conditionCollection, (physicalColumn) => \
this.getDataMapAtColumn(physicalColumn));\n  }\n  /**\n   * It updates the \
components state. The state is triggered by ConditionUpdateObserver, which\n  \
 * reacts to any condition added to the condition collection. It may be added \
through the UI\n   * components or by API call.\n   *\n   * @private\n   * \
@param {object} conditionsState An object with the state generated by UI \
components.\n   */\n  updateComponents(conditionsState) {\n    var \
_this$dropdownMenuPlu4;\n    if (!((_this$dropdownMenuPlu4 = \
this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu4 !== void 0 && \
_this$dropdownMenuPlu4.enabled)) {\n      return;\n    }\n    const {\n      \
editedConditionStack: {\n        conditions: conditions2,\n        column\n   \
   }\n    } = conditionsState;\n    const conditionsByValue = \
conditions2.filter((condition22) => condition22.name === CONDITION_NAME21);\n \
   const conditionsWithoutByValue = conditions2.filter((condition22) => \
condition22.name !== CONDITION_NAME21);\n    if (conditionsByValue.length >= \
2 || conditionsWithoutByValue.length >= 3) {\n      warn(toSingleLine`The \
filter conditions have been applied properly, but couldn\[AHat]\200\231t be \
displayed visually.\\x20\n        The overall amount of conditions exceed the \
capability of the dropdown menu.\\x20\n        For more details see the \
documentation.`);\n    } else {\n      const operationType = \
this.conditionCollection.getOperation(column);\n      \
this.components.get(\"filter_by_condition\").updateState(conditionsWithoutByV\
alue[0], column);\n      \
this.components.get(\"filter_by_condition2\").updateState(conditionsWithoutBy\
Value[1], column);\n      \
this.components.get(\"filter_operators\").updateState(operationType, \
column);\n      \
this.components.get(\"filter_by_value\").updateState(conditionsState);\n    \
}\n  }\n  /**\n   * Returns indexes of passed components inside list of \
`dropdownMenu` items.\n   *\n   * @private\n   * @param {...BaseComponent} \
components List of components.\n   * @returns {Array}\n   */\n  \
getIndexesOfComponents() {\n    const indexes = [];\n    if \
(!this.dropdownMenuPlugin) {\n      return indexes;\n    }\n    const menu = \
this.dropdownMenuPlugin.menu;\n    for (var _len = arguments.length, \
components = new Array(_len), _key = 0; _key < _len; _key++) {\n      \
components[_key] = arguments[_key];\n    }\n    arrayEach(components, \
(component) => {\n      arrayEach(menu.menuItems, (item, index2) => {\n       \
 if (item.key === component.getMenuItemDescriptor().key) {\n          \
indexes.push(index2);\n        }\n      });\n    });\n    return indexes;\n  \
}\n  /**\n   * Changes visibility of component.\n   *\n   * @private\n   * \
@param {boolean} visible Determine if components should be visible.\n   * \
@param {...BaseComponent} components List of components.\n   */\n  \
changeComponentsVisibility() {\n    let visible = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : true;\n    if \
(!this.dropdownMenuPlugin) {\n      return;\n    }\n    const menu = \
this.dropdownMenuPlugin.menu;\n    const hotMenu = menu.hotMenu;\n    const \
hiddenRows = hotMenu.getPlugin(\"hiddenRows\");\n    for (var _len2 = \
arguments.length, components = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = \
1; _key2 < _len2; _key2++) {\n      components[_key2 - 1] = \
arguments[_key2];\n    }\n    const indexes = \
this.getIndexesOfComponents(...components);\n    if (visible) {\n      \
hiddenRows.showRows(indexes);\n    } else {\n      \
hiddenRows.hideRows(indexes);\n    }\n    hotMenu.render();\n  }\n  /**\n   * \
Hides components of filters `dropdownMenu`.\n   *\n   * @private\n   * @param \
{...BaseComponent} components List of components.\n   */\n  hideComponents() \
{\n    for (var _len3 = arguments.length, components = new Array(_len3), \
_key3 = 0; _key3 < _len3; _key3++) {\n      components[_key3] = \
arguments[_key3];\n    }\n    this.changeComponentsVisibility(false, \
...components);\n  }\n  /**\n   * Shows components of filters \
`dropdownMenu`.\n   *\n   * @private\n   * @param {...BaseComponent} \
components List of components.\n   */\n  showComponents() {\n    for (var \
_len4 = arguments.length, components = new Array(_len4), _key4 = 0; _key4 < \
_len4; _key4++) {\n      components[_key4] = arguments[_key4];\n    }\n    \
this.changeComponentsVisibility(true, ...components);\n  }\n  /**\n   * \
Destroys the plugin instance.\n   */\n  destroy() {\n    if (this.enabled) \
{\n      this.components.forEach((component, key) => {\n        if (component \
!== null) {\n          component.destroy();\n          \
this.components.set(key, null);\n        }\n      });\n      \
this.conditionCollection.destroy();\n      \
this.conditionUpdateObserver.destroy();\n      \
this.hot.rowIndexMapper.unregisterMap(this.pluginName);\n    }\n    \
super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/formulas/engine/settings.mjs\nvar \
DEFAULT_LICENSE_KEY = \"internal-use-in-handsontable\";\nvar DEFAULT_SETTINGS \
= {\n  licenseKey: DEFAULT_LICENSE_KEY,\n  useArrayArithmetic: true,\n  \
useColumnIndex: false,\n  useStats: false,\n  evaluateNullToZero: true,\n  \
precisionEpsilon: 1e-13,\n  precisionRounding: 14,\n  smartRounding: true,\n  \
leapYear1900: false,\n  nullDate: {\n    year: 1899,\n    month: 12,\n    \
day: 30\n  },\n  nullYear: 30,\n  dateFormats: [\"DD/MM/YYYY\", \
\"DD/MM/YY\"],\n  timeFormats: [\"hh:mm\", \"hh:mm:ss.sss\"],\n  \
matchWholeCell: true,\n  useRegularExpressions: false,\n  useWildcards: \
true,\n  functionArgSeparator: \",\",\n  thousandSeparator: \"\",\n  \
decimalSeparator: \".\",\n  language: \"enGB\"\n};\nfunction \
getEngineSettingsOverrides(hotSettings) {\n  var _hotSettings$PLUGIN_K;\n  \
return {\n    maxColumns: hotSettings.maxColumns,\n    maxRows: \
hotSettings.maxRows,\n    language: (_hotSettings$PLUGIN_K = \
hotSettings[PLUGIN_KEY17]) === null || _hotSettings$PLUGIN_K === void 0 || \
(_hotSettings$PLUGIN_K = _hotSettings$PLUGIN_K.language) === null || \
_hotSettings$PLUGIN_K === void 0 ? void 0 : _hotSettings$PLUGIN_K.langCode\n  \
};\n}\nfunction cleanEngineSettings(pluginSettings) {\n  return \
Object.keys(pluginSettings).reduce((obj, key) => {\n    if (key !== \
\"hyperformula\") {\n      obj[key] = pluginSettings[key];\n    }\n    return \
obj;\n  }, {});\n}\nfunction \
getEngineSettingsWithDefaultsAndOverrides(hotSettings) {\n  var \
_pluginSettings$engin;\n  const pluginSettings = hotSettings[PLUGIN_KEY17];\n \
 const userSettings = cleanEngineSettings(pluginSettings !== null && \
pluginSettings !== void 0 && (_pluginSettings$engin = pluginSettings.engine) \
!== null && _pluginSettings$engin !== void 0 && \
_pluginSettings$engin.hyperformula ? pluginSettings.engine : {});\n  const \
overrides = getEngineSettingsOverrides(hotSettings);\n  return {\n    \
...DEFAULT_SETTINGS,\n    ...userSettings,\n    ...overrides\n  \
};\n}\nfunction getEngineSettingsWithOverrides(hotSettings) {\n  var \
_pluginSettings$engin2;\n  const pluginSettings = \
hotSettings[PLUGIN_KEY17];\n  const userSettings = \
cleanEngineSettings(pluginSettings !== null && pluginSettings !== void 0 && \
(_pluginSettings$engin2 = pluginSettings.engine) !== null && \
_pluginSettings$engin2 !== void 0 && _pluginSettings$engin2.hyperformula ? \
pluginSettings.engine : {});\n  const overrides = \
getEngineSettingsOverrides(hotSettings);\n  return {\n    ...userSettings,\n  \
  ...overrides\n  };\n}\nfunction \
haveEngineSettingsChanged(currentEngineSettings, newEngineSettings) {\n  \
return Object.keys(newEngineSettings).some((settingOption) => {\n    return \
newEngineSettings[settingOption] !== void 0 && \
newEngineSettings[settingOption] !== currentEngineSettings[settingOption];\n  \
});\n}\n\n// \
node_modules/handsontable/plugins/formulas/engine/register.mjs\nfunction \
getEngineRelationshipRegistry() {\n  const registryKey = \
\"engine_relationship\";\n  const pluginStaticRegistry = \
staticRegister(PLUGIN_KEY17);\n  if \
(!pluginStaticRegistry.hasItem(registryKey)) {\n    \
pluginStaticRegistry.register(registryKey, /* @__PURE__ */ new Map());\n  }\n \
 return pluginStaticRegistry.getItem(registryKey);\n}\nfunction \
getSharedEngineUsageRegistry() {\n  const registryKey = \
\"shared_engine_usage\";\n  const pluginStaticRegistry = \
staticRegister(PLUGIN_KEY17);\n  if \
(!pluginStaticRegistry.hasItem(registryKey)) {\n    \
pluginStaticRegistry.register(registryKey, /* @__PURE__ */ new Map());\n  }\n \
 return pluginStaticRegistry.getItem(registryKey);\n}\nfunction \
setupEngine(hotInstance) {\n  const hotSettings = \
hotInstance.getSettings();\n  const pluginSettings = \
hotSettings[PLUGIN_KEY17];\n  const engineConfigItem = pluginSettings === \
null || pluginSettings === void 0 ? void 0 : pluginSettings.engine;\n  if \
(pluginSettings === true) {\n    return null;\n  }\n  if \
(isUndefined(engineConfigItem)) {\n    return null;\n  }\n  if (typeof \
engineConfigItem.hyperformula === \"function\" || typeof engineConfigItem === \
\"function\") {\n    var _engineConfigItem$hyp;\n    return \
registerEngine((_engineConfigItem$hyp = engineConfigItem.hyperformula) !== \
null && _engineConfigItem$hyp !== void 0 ? _engineConfigItem$hyp : \
engineConfigItem, hotSettings, hotInstance);\n  } else if (typeof \
engineConfigItem === \"object\" && \
isUndefined(engineConfigItem.hyperformula)) {\n    const engineRelationship = \
getEngineRelationshipRegistry();\n    const sharedEngineUsage = \
getSharedEngineUsageRegistry().get(engineConfigItem);\n    if \
(!engineRelationship.has(engineConfigItem)) {\n      \
engineRelationship.set(engineConfigItem, []);\n    }\n    \
engineRelationship.get(engineConfigItem).push(hotInstance);\n    if \
(sharedEngineUsage) {\n      sharedEngineUsage.push(hotInstance.guid);\n    \
}\n    if (!engineConfigItem.getConfig().licenseKey) {\n      \
engineConfigItem.updateConfig({\n        licenseKey: DEFAULT_LICENSE_KEY\n    \
  });\n    }\n    if (engineConfigItem.getConfig().leapYear1900 !== \
DEFAULT_SETTINGS.leapYear1900 || \
isObjectEqual(engineConfigItem.getConfig().nullDate, \
DEFAULT_SETTINGS.nullDate) === false) {\n      warn(toSingleLine`If you use \
HyperFormula with Handsontable, keep the default \\`leapYear1900\\` and \
\\`nullDate\\` \n      settings. Otherwise, HyperFormula's dates may not sync \
correctly with Handsontable's dates.`);\n    }\n    return \
engineConfigItem;\n  }\n  return null;\n}\nfunction \
registerEngine(engineClass, hotSettings, hotInstance) {\n  const \
pluginSettings = hotSettings[PLUGIN_KEY17];\n  const engineSettings = \
getEngineSettingsWithDefaultsAndOverrides(hotSettings);\n  const \
engineRegistry = getEngineRelationshipRegistry();\n  const \
sharedEngineRegistry = getSharedEngineUsageRegistry();\n  \
registerCustomFunctions(engineClass, pluginSettings.functions);\n  \
registerLanguage(engineClass, pluginSettings.language);\n  const \
engineInstance = engineClass.buildEmpty(engineSettings);\n  \
engineRegistry.set(engineInstance, [hotInstance]);\n  \
sharedEngineRegistry.set(engineInstance, [hotInstance.guid]);\n  \
registerNamedExpressions(engineInstance, pluginSettings.namedExpressions);\n  \
engineInstance.on(\"sheetAdded\", () => {\n    \
engineInstance.rebuildAndRecalculate();\n  });\n  \
engineInstance.on(\"sheetRemoved\", () => {\n    \
engineInstance.rebuildAndRecalculate();\n  });\n  return \
engineInstance;\n}\nfunction getRegisteredHotInstances(engine) {\n  var \
_engineRegistry$get;\n  const engineRegistry = \
getEngineRelationshipRegistry();\n  const hotInstances = engineRegistry.size \
=== 0 ? [] : Array.from((_engineRegistry$get = engineRegistry.get(engine)) \
!== null && _engineRegistry$get !== void 0 ? _engineRegistry$get : []);\n  \
return new Map(hotInstances.map((hot2) => \
[hot2.getPlugin(\"formulas\").sheetId, hot2]));\n}\nfunction \
unregisterEngine(engine, hotInstance) {\n  if (engine) {\n    const \
engineRegistry = getEngineRelationshipRegistry();\n    const \
engineHotRelationship = engineRegistry.get(engine);\n    const \
sharedEngineRegistry = getSharedEngineUsageRegistry();\n    const \
sharedEngineUsage = sharedEngineRegistry.get(engine);\n    if \
(engineHotRelationship && engineHotRelationship.includes(hotInstance)) {\n    \
  engineHotRelationship.splice(engineHotRelationship.indexOf(hotInstance), \
1);\n      if (engineHotRelationship.length === 0) {\n        \
engineRegistry.delete(engine);\n      }\n    }\n    if (sharedEngineUsage && \
sharedEngineUsage.includes(hotInstance.guid)) {\n      \
sharedEngineUsage.splice(sharedEngineUsage.indexOf(hotInstance.guid), 1);\n   \
   if (sharedEngineUsage.length === 0) {\n        \
sharedEngineRegistry.delete(engine);\n        engine.destroy();\n      }\n    \
}\n  }\n}\nfunction registerCustomFunctions(engineClass, customFunctions) {\n \
 if (customFunctions) {\n    customFunctions.forEach((func) => {\n      const \
{\n        name,\n        plugin,\n        translations\n      } = func;\n    \
  try {\n        engineClass.registerFunction(name, plugin, translations);\n  \
    } catch (e) {\n        warn(e.message);\n      }\n    });\n  \
}\n}\nfunction registerLanguage(engineClass, languageSetting) {\n  if \
(languageSetting) {\n    const {\n      langCode\n    } = languageSetting;\n  \
  try {\n      engineClass.registerLanguage(langCode, languageSetting);\n    \
} catch (e) {\n      warn(e.message);\n    }\n  }\n}\nfunction \
registerNamedExpressions(engineInstance, namedExpressions) {\n  if \
(namedExpressions) {\n    engineInstance.suspendEvaluation();\n    \
namedExpressions.forEach((namedExp) => {\n      const {\n        name,\n      \
  expression,\n        scope,\n        options\n      } = namedExp;\n      \
try {\n        engineInstance.addNamedExpression(name, expression, scope, \
options);\n      } catch (e) {\n        warn(e.message);\n      }\n    });\n  \
  engineInstance.resumeEvaluation();\n  }\n}\nfunction \
setupSheet(engineInstance, sheetName) {\n  if (isUndefined(sheetName) || \
!engineInstance.doesSheetExist(sheetName)) {\n    sheetName = \
engineInstance.addSheet(sheetName);\n  }\n  return sheetName;\n}\n\n// \
node_modules/handsontable/plugins/formulas/utils.mjs\nvar import_moment11 = \
__toESM(require_moment(), 1);\nvar DEFAULT_DATE_FORMAT_HYPERFORMULA = \
\"DD/MM/YYYY\";\nfunction isEscapedFormulaExpression(expression) {\n  return \
typeof expression === \"string\" && expression.charAt(0) === \"'\" && \
expression.charAt(1) === \"=\";\n}\nfunction \
unescapeFormulaExpression(expression) {\n  return \
isEscapedFormulaExpression(expression) ? expression.substr(1) : \
expression;\n}\nfunction isFormula(value) {\n  return typeof value === \
\"string\" && value.startsWith(\"=\");\n}\nfunction isDate(value, cellType) \
{\n  return typeof value === \"string\" && cellType === \
\"date\";\n}\nfunction isDateValid(date, dateFormat) {\n  return (0, \
import_moment11.default)(date, dateFormat, true).isValid();\n}\nfunction \
getDateInHfFormat(date, dateFormat) {\n  return (0, \
import_moment11.default)(date, dateFormat, \
true).format(DEFAULT_DATE_FORMAT_HYPERFORMULA);\n}\nfunction \
getDateInHotFormat(date, dateFormat) {\n  return (0, \
import_moment11.default)(date, DEFAULT_DATE_FORMAT_HYPERFORMULA, \
true).format(dateFormat);\n}\nfunction getDateFromExcelDate(numericDate, \
dateFormat) {\n  const dateOffset = -1;\n  const dateForFormatting = new \
Date(Date.UTC(0, 0, numericDate + dateOffset));\n  return (0, \
import_moment11.default)(dateForFormatting).format(dateFormat);\n}\n\n// \
node_modules/handsontable/plugins/formulas/indexSyncer/axisSyncer.mjs\nfuncti\
on _classPrivateFieldInitSpec9(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration10(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration10(obj, privateCollection) {\n \
 if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_classPrivateFieldGet9(receiver, privateMap) {\n  var descriptor = \
_classExtractFieldDescriptor9(receiver, privateMap, \"get\");\n  return \
_classApplyDescriptorGet9(receiver, descriptor);\n}\nfunction \
_classApplyDescriptorGet9(receiver, descriptor) {\n  if (descriptor.get) {\n  \
  return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nfunction _classPrivateFieldSet9(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor9(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet9(receiver, descriptor, \
value);\n  return value;\n}\nfunction _classExtractFieldDescriptor9(receiver, \
privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorSet9(receiver, descriptor, value) {\n  if \
(descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n   \
 if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set \
read only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\nvar _axis = /* @__PURE__ */ new WeakMap();\nvar _indexMapper = /* \
@__PURE__ */ new WeakMap();\nvar _indexSyncer = /* @__PURE__ */ new \
WeakMap();\nvar _indexesSequence = /* @__PURE__ */ new WeakMap();\nvar \
_movedIndexes = /* @__PURE__ */ new WeakMap();\nvar _finalIndex = /* \
@__PURE__ */ new WeakMap();\nvar _removedIndexes = /* @__PURE__ */ new \
WeakMap();\nvar AxisSyncer = class {\n  constructor(axis, indexMapper, \
indexSyncer) {\n    _classPrivateFieldInitSpec9(this, _axis, {\n      \
writable: true,\n      value: void 0\n    });\n    \
_classPrivateFieldInitSpec9(this, _indexMapper, {\n      writable: true,\n    \
  value: void 0\n    });\n    _classPrivateFieldInitSpec9(this, _indexSyncer, \
{\n      writable: true,\n      value: void 0\n    });\n    \
_classPrivateFieldInitSpec9(this, _indexesSequence, {\n      writable: \
true,\n      value: []\n    });\n    _classPrivateFieldInitSpec9(this, \
_movedIndexes, {\n      writable: true,\n      value: []\n    });\n    \
_classPrivateFieldInitSpec9(this, _finalIndex, {\n      writable: true,\n     \
 value: void 0\n    });\n    _classPrivateFieldInitSpec9(this, \
_removedIndexes, {\n      writable: true,\n      value: []\n    });\n    \
_classPrivateFieldSet9(this, _axis, axis);\n    _classPrivateFieldSet9(this, \
_indexMapper, indexMapper);\n    _classPrivateFieldSet9(this, _indexSyncer, \
indexSyncer);\n  }\n  /**\n   * Sets removed HF indexes (it should be done \
right before performing move on HOT).\n   *\n   * @param {Array<number>} \
removedIndexes List of removed physical indexes.\n   * @returns \
{Array<number>} List of removed visual indexes.\n   */\n  \
setRemovedHfIndexes(removedIndexes) {\n    _classPrivateFieldSet9(this, \
_removedIndexes, removedIndexes.map((physicalIndex) => {\n      const \
visualIndex = _classPrivateFieldGet9(this, \
_indexMapper).getVisualFromPhysicalIndex(physicalIndex);\n      return \
this.getHfIndexFromVisualIndex(visualIndex);\n    }));\n    return \
_classPrivateFieldGet9(this, _removedIndexes);\n  }\n  /**\n   * Gets removed \
HF indexes (right before performing removal on HOT).\n   *\n   * @returns \
{Array<number>} List of removed HF indexes.\n   */\n  getRemovedHfIndexes() \
{\n    return _classPrivateFieldGet9(this, _removedIndexes);\n  }\n  /**\n   \
* Gets corresponding HyperFormula index for particular visual index. It's \
respecting the idea that HF's engine\n   * is fed also with trimmed indexes \
(business requirements for formula result calculation also for trimmed \
elements).\n   *\n   * @param {number} visualIndex Visual index.\n   * \
@returns {number}\n   */\n  getHfIndexFromVisualIndex(visualIndex) {\n    \
const indexesSequence = _classPrivateFieldGet9(this, \
_indexMapper).getIndexesSequence();\n    const notTrimmedIndexes = \
_classPrivateFieldGet9(this, _indexMapper).getNotTrimmedIndexes();\n    \
return indexesSequence.indexOf(notTrimmedIndexes[visualIndex]);\n  }\n  /**\n \
  * Synchronizes moves done on HOT to HF engine (based on previously \
calculated positions).\n   *\n   * @private\n   * @param {Array<{from: \
number, to: number}>} moves Calculated HF's move positions.\n   */\n  \
syncMoves(moves) {\n    const NUMBER_OF_MOVED_INDEXES = 1;\n    const \
SYNC_MOVE_METHOD_NAME = `move${toUpperCaseFirst(_classPrivateFieldGet9(this, \
_axis))}s`;\n    _classPrivateFieldGet9(this, \
_indexSyncer).getEngine().batch(() => {\n      moves.forEach((move) => {\n    \
    const moveToTheSamePosition = move.from !== move.to;\n        const \
anotherMoveWithoutEffect = move.from + 1 !== move.to;\n        if \
(moveToTheSamePosition && anotherMoveWithoutEffect) {\n          \
_classPrivateFieldGet9(this, \
_indexSyncer).getEngine()[SYNC_MOVE_METHOD_NAME](_classPrivateFieldGet9(this, \
_indexSyncer).getSheetId(), move.from, NUMBER_OF_MOVED_INDEXES, move.to);\n   \
     }\n      });\n    });\n  }\n  /**\n   * Stores information about \
performed HOT moves for purpose of calculating where to move HF elements.\n   \
*\n   * @param {Array<number>} movedVisualIndexes Sequence of moved visual \
indexes for certain axis.\n   * @param {number} visualFinalIndex Final visual \
place where to move HOT indexes.\n   * @param {boolean} movePossible \
Indicates if it's possible to move HOT indexes to the desired position.\n   \
*/\n  storeMovesInformation(movedVisualIndexes, visualFinalIndex, \
movePossible) {\n    if (movePossible === false) {\n      return;\n    }\n    \
_classPrivateFieldSet9(this, _movedIndexes, movedVisualIndexes.map((index2) \
=> this.getHfIndexFromVisualIndex(index2)));\n    \
_classPrivateFieldSet9(this, _finalIndex, \
this.getHfIndexFromVisualIndex(visualFinalIndex));\n  }\n  /**\n   * Gets \
first position where to move element (respecting the fact that some element \
will be sooner or later\n   * taken out of the dataset in order to move \
them).\n   *\n   * @param {Array<number>} movedHfIndexes Sequence of moved HF \
indexes for certain axis.\n   * @param {number} finalHfIndex Final HF place \
where to move rows.\n   * @returns {number} HF's index informing where to \
move the first element.\n   * @private\n   */\n  getMoveLine(movedHfIndexes, \
finalHfIndex) {\n    const numberOfElements = _classPrivateFieldGet9(this, \
_indexMapper).getNumberOfIndexes();\n    const notMovedElements = \
Array.from(Array(numberOfElements).keys()).filter((index2) => \
movedHfIndexes.includes(index2) === false);\n    if (finalHfIndex === 0) {\n  \
    var _notMovedElements$fin;\n      return (_notMovedElements$fin = \
notMovedElements[finalHfIndex]) !== null && _notMovedElements$fin !== void 0 \
? _notMovedElements$fin : 0;\n    }\n    return notMovedElements[finalHfIndex \
- 1] + 1;\n  }\n  /**\n   * Gets initially calculated HF's move positions.\n  \
 *\n   * @private\n   * @param {Array<number>} movedHfIndexes Sequence of \
moved HF indexes for certain axis.\n   * @param {number} finalHfIndex Final \
HF place where to move rows.\n   * @returns {Array<{from: number, to: \
number}>} Initially calculated HF's move positions.\n   */\n  \
getInitiallyCalculatedMoves(movedHfIndexes, finalHfIndex) {\n    let moveLine \
= this.getMoveLine(movedHfIndexes, finalHfIndex);\n    const moves = [];\n    \
movedHfIndexes.forEach((movedHfIndex) => {\n      const move = {\n        \
from: movedHfIndex,\n        to: moveLine\n      };\n      \
moves.forEach((previouslyMovedIndex) => {\n        const \
isMovingFromEndToStart = previouslyMovedIndex.from > \
previouslyMovedIndex.to;\n        const isMovingElementBefore = \
previouslyMovedIndex.to <= move.from;\n        const isMovingAfterElement = \
previouslyMovedIndex.from > move.from;\n        if (isMovingAfterElement && \
isMovingElementBefore && isMovingFromEndToStart) {\n          move.from += \
1;\n        }\n      });\n      if (move.from >= moveLine) {\n        \
moveLine += 1;\n      }\n      moves.push(move);\n    });\n    return \
moves;\n  }\n  /**\n   * Gets finally calculated HF's move positions (after \
adjusting).\n   *\n   * @private\n   * @param {Array<{from: number, to: \
number}>} moves Initially calculated HF's move positions.\n   * @returns \
{Array<{from: number, to: number}>} Finally calculated HF's move positions \
(after adjusting).\n   */\n  adjustedCalculatedMoves(moves) {\n    \
moves.forEach((move, index2) => {\n      const nextMoved = moves.slice(index2 \
+ 1);\n      nextMoved.forEach((nextMovedIndex) => {\n        const \
isMovingFromStartToEnd = nextMovedIndex.from < nextMovedIndex.to;\n        if \
(nextMovedIndex.from > move.from && isMovingFromStartToEnd) {\n          \
nextMovedIndex.from -= 1;\n        }\n      });\n    });\n    return moves;\n \
 }\n  /**\n   * Calculating where to move HF elements and performing already \
calculated moves.\n   *\n   * @param {boolean} movePossible Indicates if it \
was possible to move HOT indexes to the desired position.\n   * @param \
{boolean} orderChanged Indicates if order of HOT indexes was changed by \
move.\n   */\n  calculateAndSyncMoves(movePossible, orderChanged) {\n    if \
(_classPrivateFieldGet9(this, _indexSyncer).isPerformingUndoRedo()) {\n      \
return;\n    }\n    if (movePossible === false || orderChanged === false) {\n \
     return;\n    }\n    const calculatedMoves = \
this.adjustedCalculatedMoves(this.getInitiallyCalculatedMoves(_classPrivateFi\
eldGet9(this, _movedIndexes), _classPrivateFieldGet9(this, _finalIndex)));\n  \
  if (_classPrivateFieldGet9(this, _indexSyncer).getSheetId() === null) {\n   \
   _classPrivateFieldGet9(this, _indexSyncer).getPostponeAction(() => \
this.syncMoves(calculatedMoves));\n    } else {\n      \
this.syncMoves(calculatedMoves);\n    }\n  }\n  /**\n   * Gets callback for \
hook triggered after performing change of indexes order.\n   *\n   * @returns \
{Function}\n   */\n  getIndexesChangeSyncMethod() {\n    const \
SYNC_ORDER_CHANGE_METHOD_NAME = \
`set${toUpperCaseFirst(_classPrivateFieldGet9(this, _axis))}Order`;\n    \
return (source) => {\n      if (_classPrivateFieldGet9(this, \
_indexSyncer).isPerformingUndoRedo()) {\n        return;\n      }\n      \
const newSequence = _classPrivateFieldGet9(this, \
_indexMapper).getIndexesSequence();\n      if (source === \"update\") {\n     \
   const relativeTransformation = _classPrivateFieldGet9(this, \
_indexesSequence).map((index2) => newSequence.indexOf(index2));\n        \
const sheetDimensions = _classPrivateFieldGet9(this, \
_indexSyncer).getEngine().getSheetDimensions(_classPrivateFieldGet9(this, \
_indexSyncer).getSheetId());\n        let sizeForAxis;\n        if \
(_classPrivateFieldGet9(this, _axis) === \"row\") {\n          sizeForAxis = \
sheetDimensions.height;\n        } else {\n          sizeForAxis = \
sheetDimensions.width;\n        }\n        const numberOfReorganisedIndexes = \
relativeTransformation.length;\n        for (let i = \
numberOfReorganisedIndexes; i < sizeForAxis; i += 1) {\n          \
relativeTransformation.push(i);\n        }\n        \
_classPrivateFieldGet9(this, \
_indexSyncer).getEngine()[SYNC_ORDER_CHANGE_METHOD_NAME](_classPrivateFieldGe\
t9(this, _indexSyncer).getSheetId(), relativeTransformation);\n      }\n      \
_classPrivateFieldSet9(this, _indexesSequence, newSequence);\n    };\n  }\n  \
/**\n   * Initialize the AxisSyncer.\n   */\n  init() {\n    \
_classPrivateFieldSet9(this, _indexesSequence, _classPrivateFieldGet9(this, \
_indexMapper).getIndexesSequence());\n  }\n};\nvar axisSyncer_default = \
AxisSyncer;\n\n// \
node_modules/handsontable/plugins/formulas/indexSyncer/index.mjs\nfunction \
_classPrivateFieldInitSpec10(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration11(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration11(obj, privateCollection) {\n \
 if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_classPrivateFieldGet10(receiver, privateMap) {\n  var descriptor = \
_classExtractFieldDescriptor10(receiver, privateMap, \"get\");\n  return \
_classApplyDescriptorGet10(receiver, descriptor);\n}\nfunction \
_classApplyDescriptorGet10(receiver, descriptor) {\n  if (descriptor.get) {\n \
   return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nfunction _classPrivateFieldSet10(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor10(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet10(receiver, descriptor, \
value);\n  return value;\n}\nfunction \
_classExtractFieldDescriptor10(receiver, privateMap, action) {\n  if \
(!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + \
action + \" private field on non-instance\");\n  }\n  return \
privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet10(receiver, \
descriptor, value) {\n  if (descriptor.set) {\n    \
descriptor.set.call(receiver, value);\n  } else {\n    if \
(!descriptor.writable) {\n      throw new TypeError(\"attempted to set read \
only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nvar \
_rowIndexSyncer = /* @__PURE__ */ new WeakMap();\nvar _columnIndexSyncer = /* \
@__PURE__ */ new WeakMap();\nvar _postponeAction = /* @__PURE__ */ new \
WeakMap();\nvar _isPerformingUndo = /* @__PURE__ */ new WeakMap();\nvar \
_isPerformingRedo = /* @__PURE__ */ new WeakMap();\nvar _engine = /* \
@__PURE__ */ new WeakMap();\nvar _sheetId = /* @__PURE__ */ new \
WeakMap();\nvar IndexSyncer = class {\n  constructor(rowIndexMapper, \
columnIndexMapper, postponeAction) {\n    _classPrivateFieldInitSpec10(this, \
_rowIndexSyncer, {\n      writable: true,\n      value: void 0\n    });\n    \
_classPrivateFieldInitSpec10(this, _columnIndexSyncer, {\n      writable: \
true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec10(this, \
_postponeAction, {\n      writable: true,\n      value: void 0\n    });\n    \
_classPrivateFieldInitSpec10(this, _isPerformingUndo, {\n      writable: \
true,\n      value: false\n    });\n    _classPrivateFieldInitSpec10(this, \
_isPerformingRedo, {\n      writable: true,\n      value: false\n    });\n    \
_classPrivateFieldInitSpec10(this, _engine, {\n      writable: true,\n      \
value: null\n    });\n    _classPrivateFieldInitSpec10(this, _sheetId, {\n    \
  writable: true,\n      value: null\n    });\n    \
_classPrivateFieldSet10(this, _rowIndexSyncer, new \
axisSyncer_default(\"row\", rowIndexMapper, this));\n    \
_classPrivateFieldSet10(this, _columnIndexSyncer, new \
axisSyncer_default(\"column\", columnIndexMapper, this));\n    \
_classPrivateFieldSet10(this, _postponeAction, postponeAction);\n  }\n  /**\n \
  * Gets index synchronizer for a particular axis.\n   *\n   * @param \
{'row'|'column'} indexType Type of indexes.\n   * @returns {AxisSyncer}\n   \
*/\n  getForAxis(indexType) {\n    if (indexType === \"row\") {\n      return \
_classPrivateFieldGet10(this, _rowIndexSyncer);\n    }\n    return \
_classPrivateFieldGet10(this, _columnIndexSyncer);\n  }\n  /**\n   * Sets \
flag informing whether an undo action is already performed (we don't execute \
synchronization in such case).\n   *\n   * @param {boolean} flagValue Boolean \
value for the flag.\n   */\n  setPerformUndo(flagValue) {\n    \
_classPrivateFieldSet10(this, _isPerformingUndo, flagValue);\n  }\n  /**\n   \
* Sets flag informing whether a redo action is already performed (we don't \
execute synchronization in such case).\n   *\n   * @param {boolean} flagValue \
Boolean value for the flag.\n   */\n  setPerformRedo(flagValue) {\n    \
_classPrivateFieldSet10(this, _isPerformingRedo, flagValue);\n  }\n  /**\n   \
* Gets information whether redo or undo action is already performed (we don't \
execute synchronization in such case).\n   *\n   * @private\n   * @returns \
{boolean}\n   */\n  isPerformingUndoRedo() {\n    return \
_classPrivateFieldGet10(this, _isPerformingUndo) || \
_classPrivateFieldGet10(this, _isPerformingRedo);\n  }\n  /**\n   * Gets \
HyperFormula's sheet id.\n   *\n   * @returns {string|null}\n   */\n  \
getSheetId() {\n    return _classPrivateFieldGet10(this, _sheetId);\n  }\n  \
/**\n   * Gets engine instance that will be used for handled instance of \
Handsontable.\n   *\n   * @type {HyperFormula|null}\n   */\n  getEngine() {\n \
   return _classPrivateFieldGet10(this, _engine);\n  }\n  /**\n   * Gets \
method which will postpone execution of some action (needed when \
synchronization endpoint isn't setup yet).\n   *\n   * @returns {Function}\n  \
 */\n  getPostponeAction() {\n    return _classPrivateFieldGet10(this, \
_postponeAction);\n  }\n  /**\n   * Setups a synchronization endpoint.\n   \
*\n   * @param {HyperFormula|null} engine The HF's engine instance which will \
be synced.\n   * @param {string|null} sheetId HyperFormula's sheet name.\n   \
*/\n  setupSyncEndpoint(engine, sheetId) {\n    _classPrivateFieldSet10(this, \
_engine, engine);\n    _classPrivateFieldSet10(this, _sheetId, sheetId);\n    \
_classPrivateFieldGet10(this, _rowIndexSyncer).init();\n    \
_classPrivateFieldGet10(this, _columnIndexSyncer).init();\n  }\n};\nvar \
indexSyncer_default = IndexSyncer;\n\n// \
node_modules/handsontable/plugins/formulas/formulas.mjs\nfunction \
_defineProperty20(obj, key, value) {\n  key = _toPropertyKey20(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey20(arg) {\n  var key = \
_toPrimitive20(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive20(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nfunction _classPrivateFieldInitSpec11(obj, privateMap, \
value) {\n  _checkPrivateRedeclaration12(obj, privateMap);\n  \
privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration12(obj, \
privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new \
TypeError(\"Cannot initialize the same private elements twice on an \
object\");\n  }\n}\nfunction _classPrivateFieldSet11(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor11(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet11(receiver, descriptor, \
value);\n  return value;\n}\nfunction _classApplyDescriptorSet11(receiver, \
descriptor, value) {\n  if (descriptor.set) {\n    \
descriptor.set.call(receiver, value);\n  } else {\n    if \
(!descriptor.writable) {\n      throw new TypeError(\"attempted to set read \
only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\nfunction _classPrivateFieldGet11(receiver, privateMap) {\n  var \
descriptor = _classExtractFieldDescriptor11(receiver, privateMap, \"get\");\n \
 return _classApplyDescriptorGet11(receiver, descriptor);\n}\nfunction \
_classExtractFieldDescriptor11(receiver, privateMap, action) {\n  if \
(!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + \
action + \" private field on non-instance\");\n  }\n  return \
privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet11(receiver, \
descriptor) {\n  if (descriptor.get) {\n    return \
descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nvar \
PLUGIN_KEY17 = \"formulas\";\nvar SETTING_KEYS4 = [\"maxRows\", \
\"maxColumns\", \"language\"];\nvar PLUGIN_PRIORITY16 = \
260;\npluginHooks_default.getSingleton().register(\"afterNamedExpressionAdded\
\");\npluginHooks_default.getSingleton().register(\"afterNamedExpressionRemov\
ed\");\npluginHooks_default.getSingleton().register(\"afterSheetAdded\");\npl\
uginHooks_default.getSingleton().register(\"afterSheetRemoved\");\npluginHook\
s_default.getSingleton().register(\"afterSheetRenamed\");\npluginHooks_defaul\
t.getSingleton().register(\"afterFormulasValuesUpdate\");\nvar \
isBlockedSource = (source) => source === \"UndoRedo.undo\" || source === \
\"UndoRedo.redo\" || source === \"auto\";\nvar _internalOperationPending = /* \
@__PURE__ */ new WeakMap();\nvar _hotWasInitializedWithEmptyData = /* \
@__PURE__ */ new WeakMap();\nvar _engineListeners = /* @__PURE__ */ new \
WeakMap();\nvar Formulas = class extends BasePlugin {\n  constructor() {\n    \
var _this;\n    super(...arguments);\n    _this = this;\n    \
_classPrivateFieldInitSpec11(this, _internalOperationPending, {\n      \
writable: true,\n      value: false\n    });\n    \
_classPrivateFieldInitSpec11(this, _hotWasInitializedWithEmptyData, {\n      \
writable: true,\n      value: false\n    });\n    \
_classPrivateFieldInitSpec11(this, _engineListeners, {\n      writable: \
true,\n      value: [[\"valuesUpdated\", function() {\n        return \
_this.onEngineValuesUpdated(...arguments);\n      }], \
[\"namedExpressionAdded\", function() {\n        return \
_this.onEngineNamedExpressionsAdded(...arguments);\n      }], \
[\"namedExpressionRemoved\", function() {\n        return \
_this.onEngineNamedExpressionsRemoved(...arguments);\n      }], \
[\"sheetAdded\", function() {\n        return \
_this.onEngineSheetAdded(...arguments);\n      }], [\"sheetRenamed\", \
function() {\n        return _this.onEngineSheetRenamed(...arguments);\n      \
}], [\"sheetRemoved\", function() {\n        return \
_this.onEngineSheetRemoved(...arguments);\n      }]]\n    });\n    \
_defineProperty20(this, \"staticRegister\", staticRegister(\"formulas\"));\n  \
  _defineProperty20(this, \"engine\", null);\n    _defineProperty20(this, \
\"sheetName\", null);\n    _defineProperty20(this, \"indexSyncer\", null);\n  \
  _defineProperty20(this, \"rowAxisSyncer\", null);\n    \
_defineProperty20(this, \"columnAxisSyncer\", null);\n  }\n  static get \
PLUGIN_KEY() {\n    return PLUGIN_KEY17;\n  }\n  static get PLUGIN_PRIORITY() \
{\n    return PLUGIN_PRIORITY16;\n  }\n  static get SETTING_KEYS() {\n    \
return [PLUGIN_KEY17, ...SETTING_KEYS4];\n  }\n  /**\n   * HyperFormula's \
sheet id.\n   *\n   * @type {number|null}\n   */\n  get sheetId() {\n    \
return this.sheetName === null ? null : \
this.engine.getSheetId(this.sheetName);\n  }\n  /**\n   * Checks if the \
plugin is enabled in the handsontable settings. This method is executed in \
{@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link \
Formulas#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   \
*/\n  isEnabled() {\n    return this.hot.getSettings()[PLUGIN_KEY17] ? true : \
false;\n  }\n  /**\n   * Enables the plugin functionality for this \
Handsontable instance.\n   */\n  enablePlugin() {\n    var _setupEngine, \
_this2 = this;\n    if (this.enabled) {\n      return;\n    }\n    \
this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine \
!== void 0 ? _setupEngine : this.engine;\n    if (!this.engine) {\n      \
warn(\"Missing the required `engine` key in the Formulas settings. Please \
fill it with either an engine class or an engine instance.\");\n      \
return;\n    }\n    if (this.sheetName !== null && \
!this.engine.doesSheetExist(this.sheetName)) {\n      const newSheetName = \
this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n      if \
(newSheetName !== false) {\n        this.sheetName = newSheetName;\n      }\n \
   }\n    this.addHook(\"beforeLoadData\", function() {\n      return \
_this2.onBeforeLoadData(...arguments);\n    });\n    \
this.addHook(\"afterLoadData\", function() {\n      return \
_this2.onAfterLoadData(...arguments);\n    });\n    \
this.addHook(\"beforeUpdateData\", function() {\n      return \
_this2.onBeforeLoadData(...arguments);\n    });\n    \
this.addHook(\"afterUpdateData\", function() {\n      return \
_this2.onAfterLoadData(...arguments);\n    });\n    \
this.addHook(\"modifyData\", function() {\n      return \
_this2.onModifyData(...arguments);\n    });\n    \
this.addHook(\"modifySourceData\", function() {\n      return \
_this2.onModifySourceData(...arguments);\n    });\n    \
this.addHook(\"beforeValidate\", function() {\n      return \
_this2.onBeforeValidate(...arguments);\n    });\n    \
this.addHook(\"afterSetSourceDataAtCell\", function() {\n      return \
_this2.onAfterSetSourceDataAtCell(...arguments);\n    });\n    \
this.addHook(\"afterSetDataAtCell\", function() {\n      return \
_this2.onAfterSetDataAtCell(...arguments);\n    });\n    \
this.addHook(\"afterSetDataAtRowProp\", function() {\n      return \
_this2.onAfterSetDataAtCell(...arguments);\n    });\n    \
this.addHook(\"beforeCreateRow\", function() {\n      return \
_this2.onBeforeCreateRow(...arguments);\n    });\n    \
this.addHook(\"beforeCreateCol\", function() {\n      return \
_this2.onBeforeCreateCol(...arguments);\n    });\n    \
this.addHook(\"afterCreateRow\", function() {\n      return \
_this2.onAfterCreateRow(...arguments);\n    });\n    \
this.addHook(\"afterCreateCol\", function() {\n      return \
_this2.onAfterCreateCol(...arguments);\n    });\n    \
this.addHook(\"beforeRemoveRow\", function() {\n      return \
_this2.onBeforeRemoveRow(...arguments);\n    });\n    \
this.addHook(\"beforeRemoveCol\", function() {\n      return \
_this2.onBeforeRemoveCol(...arguments);\n    });\n    \
this.addHook(\"afterRemoveRow\", function() {\n      return \
_this2.onAfterRemoveRow(...arguments);\n    });\n    \
this.addHook(\"afterRemoveCol\", function() {\n      return \
_this2.onAfterRemoveCol(...arguments);\n    });\n    this.indexSyncer = new \
indexSyncer_default(this.hot.rowIndexMapper, this.hot.columnIndexMapper, \
(postponedAction) => {\n      this.hot.addHookOnce(\"init\", () => {\n        \
postponedAction();\n      });\n    });\n    this.rowAxisSyncer = \
this.indexSyncer.getForAxis(\"row\");\n    this.columnAxisSyncer = \
this.indexSyncer.getForAxis(\"column\");\n    \
this.hot.addHook(\"afterRowSequenceChange\", \
this.rowAxisSyncer.getIndexesChangeSyncMethod());\n    \
this.hot.addHook(\"afterColumnSequenceChange\", \
this.columnAxisSyncer.getIndexesChangeSyncMethod());\n    \
this.hot.addHook(\"beforeRowMove\", (movedRows, finalIndex, _, movePossible) \
=> {\n      this.rowAxisSyncer.storeMovesInformation(movedRows, finalIndex, \
movePossible);\n    });\n    this.hot.addHook(\"beforeColumnMove\", \
(movedColumns, finalIndex, _, movePossible) => {\n      \
this.columnAxisSyncer.storeMovesInformation(movedColumns, finalIndex, \
movePossible);\n    });\n    this.hot.addHook(\"afterRowMove\", (movedRows, \
finalIndex, dropIndex, movePossible, orderChanged) => {\n      \
this.rowAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    \
});\n    this.hot.addHook(\"afterColumnMove\", (movedColumns, finalIndex, \
dropIndex, movePossible, orderChanged) => {\n      \
this.columnAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    \
});\n    this.hot.addHook(\"beforeColumnFreeze\", (column, freezePerformed) \
=> {\n      this.columnAxisSyncer.storeMovesInformation([column], \
this.hot.getSettings().fixedColumnsStart, freezePerformed);\n    });\n    \
this.hot.addHook(\"afterColumnFreeze\", (_, freezePerformed) => {\n      \
this.columnAxisSyncer.calculateAndSyncMoves(freezePerformed, \
freezePerformed);\n    });\n    this.hot.addHook(\"beforeColumnUnfreeze\", \
(column, unfreezePerformed) => {\n      \
this.columnAxisSyncer.storeMovesInformation([column], \
this.hot.getSettings().fixedColumnsStart - 1, unfreezePerformed);\n    });\n  \
  this.hot.addHook(\"afterColumnUnfreeze\", (_, unfreezePerformed) => {\n     \
 this.columnAxisSyncer.calculateAndSyncMoves(unfreezePerformed, \
unfreezePerformed);\n    });\n    this.addHook(\"afterCellMetaReset\", \
function() {\n      return _this2.onAfterCellMetaReset(...arguments);\n    \
});\n    this.addHook(\"beforeUndo\", () => {\n      \
this.indexSyncer.setPerformUndo(true);\n      this.engine.undo();\n    });\n  \
  this.addHook(\"beforeRedo\", () => {\n      \
this.indexSyncer.setPerformRedo(true);\n      this.engine.redo();\n    });\n  \
  this.addHook(\"afterUndo\", () => {\n      \
this.indexSyncer.setPerformUndo(false);\n    });\n    \
this.addHook(\"afterUndo\", () => {\n      \
this.indexSyncer.setPerformRedo(false);\n    });\n    \
this.addHook(\"afterDetachChild\", function() {\n      return \
_this2.onAfterDetachChild(...arguments);\n    });\n    \
this.addHook(\"beforeAutofill\", function() {\n      return \
_this2.onBeforeAutofill(...arguments);\n    });\n    \
_classPrivateFieldGet11(this, _engineListeners).forEach((_ref) => {\n      \
let [eventName, listener] = _ref;\n      return this.engine.on(eventName, \
listener);\n    });\n    super.enablePlugin();\n  }\n  /**\n   * Disables the \
plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    _classPrivateFieldGet11(this, \
_engineListeners).forEach((_ref2) => {\n      let [eventName, listener] = \
_ref2;\n      return this.engine.off(eventName, listener);\n    });\n    \
unregisterEngine(this.engine, this.hot);\n    this.engine = null;\n    \
super.disablePlugin();\n  }\n  /**\n   * Triggered on `updateSettings`.\n   \
*\n   * @private\n   * @param {object} newSettings New set of settings passed \
to the `updateSettings` method.\n   */\n  updatePlugin(newSettings) {\n    \
const newEngineSettings = \
getEngineSettingsWithOverrides(this.hot.getSettings());\n    if \
(haveEngineSettingsChanged(this.engine.getConfig(), newEngineSettings)) {\n   \
   this.engine.updateConfig(newEngineSettings);\n    }\n    const \
pluginSettings = this.hot.getSettings()[PLUGIN_KEY17];\n    if \
(isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && \
pluginSettings.sheetName !== this.sheetName) {\n      \
this.switchSheet(pluginSettings.sheetName);\n    }\n    if (!newSettings.data \
&& this.sheetName === null) {\n      const sheetName = \
this.hot.getSettings()[PLUGIN_KEY17].sheetName;\n      if (sheetName && \
this.engine.doesSheetExist(sheetName)) {\n        \
this.switchSheet(this.sheetName);\n      } else {\n        this.sheetName = \
this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void \
0, this.hot.getSourceDataArray());\n      }\n    }\n    \
super.updatePlugin(newSettings);\n  }\n  /**\n   * Destroys the plugin \
instance.\n   */\n  destroy() {\n    _classPrivateFieldGet11(this, \
_engineListeners).forEach((_ref3) => {\n      var _this$engine;\n      let \
[eventName, listener] = _ref3;\n      return (_this$engine = this.engine) === \
null || _this$engine === void 0 ? void 0 : _this$engine.off(eventName, \
listener);\n    });\n    _classPrivateFieldSet11(this, _engineListeners, \
null);\n    unregisterEngine(this.engine, this.hot);\n    this.engine = \
null;\n    super.destroy();\n  }\n  /**\n   * Add a sheet to the shared \
HyperFormula instance.\n   *\n   * @param {string|null} [sheetName] The new \
sheet name. If not provided (or a null is passed), will be\n   * \
auto-generated by HyperFormula.\n   * @param {Array} [sheetData] Data passed \
to the shared HyperFormula instance. Has to be declared as an array of\n   * \
arrays - array of objects is not supported in this scenario.\n   * @returns \
{boolean|string} `false` if the data format is unusable or it is impossible \
to add a new sheet to the\n   * engine, the created sheet name otherwise.\n   \
*/\n  addSheet(sheetName, sheetData) {\n    if (isDefined(sheetData) && \
!isArrayOfArrays(sheetData)) {\n      warn(\"The provided data should be an \
array of arrays.\");\n      return false;\n    }\n    if (sheetName !== void \
0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n      \
warn(\"Sheet with the provided name already exists.\");\n      return \
false;\n    }\n    try {\n      const actualSheetName = \
this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : \
void 0);\n      if (sheetData) {\n        \
this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), \
sheetData);\n      }\n      return actualSheetName;\n    } catch (e) {\n      \
warn(e.message);\n      return false;\n    }\n  }\n  /**\n   * Switch the \
sheet used as data in the Handsontable instance (it loads the data from the \
shared HyperFormula\n   * instance).\n   *\n   * @param {string} sheetName \
Sheet name used in the shared HyperFormula instance.\n   */\n  \
switchSheet(sheetName) {\n    if (!this.engine.doesSheetExist(sheetName)) {\n \
     error(`The sheet named \\`${sheetName}\\` does not exist, switch \
aborted.`);\n      return;\n    }\n    this.sheetName = sheetName;\n    const \
serialized = this.engine.getSheetSerialized(this.sheetId);\n    if \
(serialized.length > 0) {\n      this.hot.loadData(serialized, \
`${toUpperCaseFirst(PLUGIN_KEY17)}.switchSheet`);\n    }\n  }\n  /**\n   * \
Get the cell type under specified visual coordinates.\n   *\n   * @param \
{number} row Visual row index.\n   * @param {number} column Visual column \
index.\n   * @param {number} [sheet] The target sheet id, defaults to the \
current sheet.\n   * @returns {string} Possible values: 'FORMULA' | 'VALUE' | \
'ARRAYFORMULA' | 'EMPTY'.\n   */\n  getCellType(row, column) {\n    let sheet \
= arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \
this.sheetId;\n    const physicalRow = this.hot.toPhysicalRow(row);\n    \
const physicalColumn = this.hot.toPhysicalColumn(column);\n    if \
(physicalRow !== null && physicalColumn !== null) {\n      return \
this.engine.getCellType({\n        sheet,\n        row: \
this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n        col: \
this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n      });\n    } \
else {\n      return \"EMPTY\";\n    }\n  }\n  /**\n   * Returns `true` if \
under specified visual coordinates is formula.\n   *\n   * @param {number} \
row Visual row index.\n   * @param {number} column Visual column index.\n   * \
@param {number} [sheet] The target sheet id, defaults to the current sheet.\n \
  * @returns {boolean}\n   */\n  isFormulaCellType(row, column) {\n    let \
sheet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \
this.sheetId;\n    return this.engine.doesCellHaveFormula({\n      sheet,\n   \
   row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n      col: \
this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n    });\n  }\n  \
/**\n   * Renders dependent sheets (handsontable instances) based on the \
changes - list of the\n   * recalculated dependent cells.\n   *\n   * \
@private\n   * @param {object[]} dependentCells The values and location of \
applied changes within HF engine.\n   * @param {boolean} [renderSelf] `true` \
if it's supposed to render itself, `false` otherwise.\n   */\n  \
renderDependentSheets(dependentCells) {\n    let renderSelf = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    \
const affectedSheetIds = /* @__PURE__ */ new Set();\n    \
dependentCells.forEach((change) => {\n      var _change$address;\n      const \
sheetId = change === null || change === void 0 || (_change$address = \
change.address) === null || _change$address === void 0 ? void 0 : \
_change$address.sheet;\n      if (sheetId !== void 0) {\n        if \
(!affectedSheetIds.has(sheetId)) {\n          \
affectedSheetIds.add(sheetId);\n        }\n      }\n    });\n    \
getRegisteredHotInstances(this.engine).forEach((relatedHot, sheetId) => {\n   \
   if ((renderSelf || sheetId !== this.sheetId) && \
affectedSheetIds.has(sheetId)) {\n        var _relatedHot$view;\n        \
relatedHot.render();\n        (_relatedHot$view = relatedHot.view) === null \
|| _relatedHot$view === void 0 || _relatedHot$view.adjustElementsSize();\n    \
  }\n    });\n  }\n  /**\n   * Validates dependent cells based on the cells \
that are modified by the change.\n   *\n   * @private\n   * @param {object[]} \
dependentCells The values and location of applied changes within HF engine.\n \
  * @param {object[]} [changedCells] The values and location of applied \
changes by developer (through API or UI).\n   */\n  \
validateDependentCells(dependentCells) {\n    let changedCells = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    \
const stringifyAddress = (change) => {\n      var _change$address2;\n      \
const {\n        row,\n        col,\n        sheet\n      } = \
(_change$address2 = change === null || change === void 0 ? void 0 : \
change.address) !== null && _change$address2 !== void 0 ? _change$address2 : \
{};\n      return isDefined(sheet) ? `${sheet}:${row}x${col}` : \"\";\n    \
};\n    const changedCellsSet = new Set(changedCells.map((change) => \
stringifyAddress(change)));\n    dependentCells.forEach((change) => {\n      \
var _change$address3, _change$address4;\n      const {\n        row,\n        \
col\n      } = (_change$address3 = change.address) !== null && \
_change$address3 !== void 0 ? _change$address3 : {};\n      if \
(isDefined(row) === false || isDefined(col) === false || row >= \
this.hot.countRows() || col >= this.hot.countCols()) {\n        return;\n     \
 }\n      const sheetId = change === null || change === void 0 || \
(_change$address4 = change.address) === null || _change$address4 === void 0 ? \
void 0 : _change$address4.sheet;\n      const addressId = \
stringifyAddress(change);\n      if (sheetId !== void 0 && \
!changedCellsSet.has(addressId)) {\n        const boundHot = \
getRegisteredHotInstances(this.engine).get(sheetId);\n        if (!boundHot) \
{\n          return;\n        }\n        \
boundHot.validateCell(boundHot.getDataAtCell(row, col), \
boundHot.getCellMeta(row, col), () => {\n        });\n      }\n    });\n  }\n \
 /**\n   * Sync a change from the change-related hooks with the engine.\n   \
*\n   * @private\n   * @param {number} row Visual row index.\n   * @param \
{number} column Visual column index.\n   * @param {Handsontable.CellValue} \
newValue New value.\n   * @returns {Array} Array of changes exported from the \
engine.\n   */\n  syncChangeWithEngine(row, column, newValue) {\n    const \
address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n  \
    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column),\n      \
sheet: this.sheetId\n    };\n    if \
(!this.engine.isItPossibleToSetCellContents(address)) {\n      warn(`Not \
possible to set cell data at ${JSON.stringify(address)}`);\n      return;\n   \
 }\n    const cellMeta = this.hot.getCellMeta(row, column);\n    if \
(isDate(newValue, cellMeta.type)) {\n      if (isDateValid(newValue, \
cellMeta.dateFormat)) {\n        newValue = getDateInHfFormat(newValue, \
cellMeta.dateFormat);\n      } else if (isFormula(newValue) === false) {\n    \
    newValue = `'${newValue}`;\n      }\n    }\n    return \
this.engine.setCellContents(address, newValue);\n  }\n  /**\n   * The hook \
allows to translate the formula value to calculated value before it goes to \
the\n   * validator function.\n   *\n   * @private\n   * @param {*} value The \
cell value to validate.\n   * @param {number} visualRow The visual row \
index.\n   * @param {number|string} prop The visual column index or property \
name of the column.\n   * @returns {*} Returns value to validate.\n   */\n  \
onBeforeValidate(value, visualRow, prop) {\n    const visualColumn = \
this.hot.propToCol(prop);\n    if (this.isFormulaCellType(visualRow, \
visualColumn)) {\n      const address = {\n        row: \
this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n        col: \
this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n        \
sheet: this.sheetId\n      };\n      const cellMeta = \
this.hot.getCellMeta(visualRow, visualColumn);\n      let cellValue = \
this.engine.getCellValue(address);\n      if (cellMeta.type === \"date\" && \
isNumeric(cellValue)) {\n        cellValue = getDateFromExcelDate(cellValue, \
cellMeta.dateFormat);\n      }\n      return typeof cellValue === \"object\" \
&& cellValue !== null ? cellValue.value : cellValue;\n    }\n    return \
value;\n  }\n  /**\n   * `onBeforeAutofill` hook callback.\n   *\n   * \
@private\n   * @param {Array[]} fillData The data that was used to fill the \
`targetRange`. If `beforeAutofill` was used\n   * and returned `[[]]`, this \
will be the same object that was returned from `beforeAutofill`.\n   * @param \
{CellRange} sourceRange The range values will be filled from.\n   * @param \
{CellRange} targetRange The range new values will be filled into.\n   * \
@returns {boolean|*}\n   */\n  onBeforeAutofill(fillData, sourceRange, \
targetRange) {\n    const {\n      row: sourceTopStartRow,\n      col: \
sourceTopStartColumn\n    } = sourceRange.getTopStartCorner();\n    const {\n \
     row: sourceBottomEndRow,\n      col: sourceBottomEndColumn\n    } = \
sourceRange.getBottomEndCorner();\n    const {\n      row: \
targetTopStartRow,\n      col: targetTopStartColumn\n    } = \
targetRange.getTopStartCorner();\n    const {\n      row: \
targetBottomEndRow,\n      col: targetBottomEndColumn\n    } = \
targetRange.getBottomEndCorner();\n    const engineSourceRange = {\n      \
start: {\n        row: \
this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartRow),\n        \
col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartColumn),\n \
       sheet: this.sheetId\n      },\n      end: {\n        row: \
this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndRow),\n        \
col: \
this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndColumn),\n     \
   sheet: this.sheetId\n      }\n    };\n    const engineTargetRange = {\n    \
  start: {\n        row: \
this.rowAxisSyncer.getHfIndexFromVisualIndex(targetTopStartRow),\n        \
col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetTopStartColumn),\n \
       sheet: this.sheetId\n      },\n      end: {\n        row: \
this.rowAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndRow),\n        \
col: \
this.columnAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndColumn),\n     \
   sheet: this.sheetId\n      }\n    };\n    if \
(this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n  \
    return false;\n    }\n    const fillRangeData = \
this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n    \
const {\n      row: sourceStartRow,\n      col: sourceStartColumn\n    } = \
engineSourceRange.start;\n    const {\n      row: sourceEndRow,\n      col: \
sourceEndColumn\n    } = engineSourceRange.end;\n    const \
populationRowLength = sourceEndRow - sourceStartRow + 1;\n    const \
populationColumnLength = sourceEndColumn - sourceStartColumn + 1;\n    for \
(let populatedRowIndex = 0; populatedRowIndex < fillRangeData.length; \
populatedRowIndex += 1) {\n      for (let populatedColumnIndex = 0; \
populatedColumnIndex < fillRangeData[populatedRowIndex].length; \
populatedColumnIndex += 1) {\n        const populatedValue = \
fillRangeData[populatedRowIndex][populatedColumnIndex];\n        const \
sourceRow = populatedRowIndex % populationRowLength;\n        const \
sourceColumn = populatedColumnIndex % populationColumnLength;\n        const \
sourceCellMeta = this.hot.getCellMeta(sourceRow, sourceColumn);\n        if \
(isDate(populatedValue, sourceCellMeta.type)) {\n          if \
(populatedValue.startsWith(\"'\")) {\n            \
fillRangeData[populatedRowIndex][populatedColumnIndex] = \
populatedValue.slice(1);\n          } else if \
(this.isFormulaCellType(sourceRow, sourceColumn, this.sheetId) === false) {\n \
           fillRangeData[populatedRowIndex][populatedColumnIndex] = \
getDateInHotFormat(populatedValue, sourceCellMeta.dateFormat);\n          }\n \
       }\n      }\n    }\n    return fillRangeData;\n  }\n  /**\n   * \
`beforeLoadData` hook callback.\n   *\n   * @param {Array} sourceData Array \
of arrays or array of objects containing data.\n   * @param {boolean} \
initialLoad Flag that determines whether the data has been loaded during the \
initialization.\n   * @param {string} [source] Source of the call.\n   * \
@private\n   */\n  onBeforeLoadData(sourceData, initialLoad) {\n    let \
source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \
\"\";\n    if (source.includes(toUpperCaseFirst(PLUGIN_KEY17))) {\n      \
return;\n    }\n    _classPrivateFieldSet11(this, \
_hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n \
 }\n  /**\n   * Callback to `afterCellMetaReset` hook which is triggered \
after setting cell meta.\n   *\n   * @private\n   */\n  \
onAfterCellMetaReset() {\n    const sourceDataArray = \
this.hot.getSourceDataArray();\n    let valueChanged = false;\n    \
sourceDataArray.forEach((rowData, rowIndex) => {\n      \
rowData.forEach((cellValue, columnIndex) => {\n        const cellMeta = \
this.hot.getCellMeta(rowIndex, columnIndex);\n        const dateFormat = \
cellMeta.dateFormat;\n        if (isDate(cellValue, cellMeta.type)) {\n       \
   valueChanged = true;\n          if (isDateValid(cellValue, dateFormat)) \
{\n            sourceDataArray[rowIndex][columnIndex] = \
getDateInHfFormat(cellValue, dateFormat);\n          } else if \
(this.isFormulaCellType(rowIndex, columnIndex) === false) {\n            \
sourceDataArray[rowIndex][columnIndex] = `'${cellValue}`;\n          }\n      \
  }\n      });\n    });\n    if (valueChanged === true) {\n      \
_classPrivateFieldSet11(this, _internalOperationPending, true);\n      \
this.engine.setSheetContent(this.sheetId, sourceDataArray);\n      \
_classPrivateFieldSet11(this, _internalOperationPending, false);\n    }\n  \
}\n  /**\n   * `afterLoadData` hook callback.\n   *\n   * @param {Array} \
sourceData Array of arrays or array of objects containing data.\n   * @param \
{boolean} initialLoad Flag that determines whether the data has been loaded \
during the initialization.\n   * @param {string} [source] Source of the \
call.\n   * @private\n   */\n  onAfterLoadData(sourceData, initialLoad) {\n   \
 let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] \
: \"\";\n    if (source.includes(toUpperCaseFirst(PLUGIN_KEY17))) {\n      \
return;\n    }\n    this.sheetName = setupSheet(this.engine, \
this.hot.getSettings()[PLUGIN_KEY17].sheetName);\n    if \
(!_classPrivateFieldGet11(this, _hotWasInitializedWithEmptyData)) {\n      \
const sourceDataArray = this.hot.getSourceDataArray();\n      if \
(this.engine.isItPossibleToReplaceSheetContent(this.sheetId, \
sourceDataArray)) {\n        _classPrivateFieldSet11(this, \
_internalOperationPending, true);\n        const dependentCells = \
this.engine.setSheetContent(this.sheetId, sourceDataArray);\n        \
this.indexSyncer.setupSyncEndpoint(this.engine, this.sheetId);\n        \
this.renderDependentSheets(dependentCells);\n        \
_classPrivateFieldSet11(this, _internalOperationPending, false);\n      }\n   \
 } else {\n      this.switchSheet(this.sheetName);\n    }\n  }\n  /**\n   * \
`modifyData` hook callback.\n   *\n   * @private\n   * @param {number} \
physicalRow Physical row index.\n   * @param {number} visualColumn Visual \
column index.\n   * @param {object} valueHolder Object which contains \
original value which can be modified by overwriting `.value`\n   *   \
property.\n   * @param {string} ioMode String which indicates for what \
operation hook is fired (`get` or `set`).\n   */\n  onModifyData(physicalRow, \
visualColumn, valueHolder, ioMode) {\n    if (ioMode !== \"get\" || \
_classPrivateFieldGet11(this, _internalOperationPending) || this.sheetName \
=== null || !this.engine.doesSheetExist(this.sheetName)) {\n      return;\n   \
 }\n    const visualRow = this.hot.toVisualRow(physicalRow);\n    if \
(visualRow === null || visualColumn === null) {\n      return;\n    }\n    \
const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n  \
  if (!isFormulaCellType) {\n      const cellType = \
this.getCellType(visualRow, visualColumn);\n      if (cellType !== \"ARRAY\") \
{\n        if (isEscapedFormulaExpression(valueHolder.value)) {\n          \
valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n        \
}\n        return;\n      }\n    }\n    const address = {\n      row: \
this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: \
this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: \
this.sheetId\n    };\n    let cellValue = \
this.engine.getCellValue(address);\n    const cellMeta = \
this.hot.getCellMeta(visualRow, visualColumn);\n    if (cellMeta.type === \
\"date\" && isNumeric(cellValue)) {\n      cellValue = \
getDateFromExcelDate(cellValue, cellMeta.dateFormat);\n    }\n    const value \
= typeof cellValue === \"object\" && cellValue !== null ? cellValue.value : \
cellValue;\n    valueHolder.value = value;\n  }\n  /**\n   * \
`modifySourceData` hook callback.\n   *\n   * @private\n   * @param {number} \
row Physical row index.\n   * @param {number|string} columnOrProp Physical \
column index or prop.\n   * @param {object} valueHolder Object which contains \
original value which can be modified by overwriting `.value`\n   *   \
property.\n   * @param {string} ioMode String which indicates for what \
operation hook is fired (`get` or `set`).\n   */\n  onModifySourceData(row, \
columnOrProp, valueHolder, ioMode) {\n    if (ioMode !== \"get\" || \
_classPrivateFieldGet11(this, _internalOperationPending) || this.sheetName \
=== null || !this.engine.doesSheetExist(this.sheetName)) {\n      return;\n   \
 }\n    const visualRow = this.hot.toVisualRow(row);\n    const visualColumn \
= this.hot.propToCol(columnOrProp);\n    if (visualRow === null || \
visualColumn === null) {\n      return;\n    }\n    const isFormulaCellType = \
this.isFormulaCellType(visualRow, visualColumn);\n    if (!isFormulaCellType) \
{\n      const cellType = this.getCellType(visualRow, visualColumn);\n      \
if (cellType !== \"ARRAY\") {\n        return;\n      }\n    }\n    const \
dimensions = \
this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));\n    \
if (dimensions.width === 0 && dimensions.height === 0) {\n      return;\n    \
}\n    const address = {\n      row: \
this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: \
this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: \
this.sheetId\n    };\n    valueHolder.value = \
this.engine.getCellSerialized(address);\n  }\n  /**\n   * \
`onAfterSetDataAtCell` hook callback.\n   *\n   * @private\n   * @param \
{Array[]} changes An array of changes in format [[row, prop, oldValue, \
value], ...].\n   * @param {string} [source] String that identifies source of \
hook call\n   *                          ([list of all available \
sources]{@link \
https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsont\
able-hooks}).\n   */\n  onAfterSetDataAtCell(changes, source) {\n    if \
(isBlockedSource(source)) {\n      return;\n    }\n    const \
outOfBoundsChanges = [];\n    const changedCells = [];\n    const \
dependentCells = this.engine.batch(() => {\n      changes.forEach((_ref4) => \
{\n        let [visualRow, prop, , newValue] = _ref4;\n        const \
visualColumn = this.hot.propToCol(prop);\n        const physicalRow = \
this.hot.toPhysicalRow(visualRow);\n        const physicalColumn = \
this.hot.toPhysicalColumn(visualColumn);\n        const address = {\n         \
 row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n          \
col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n         \
 sheet: this.sheetId\n        };\n        if (physicalRow !== null && \
physicalColumn !== null) {\n          this.syncChangeWithEngine(visualRow, \
visualColumn, newValue);\n        } else {\n          \
outOfBoundsChanges.push([visualRow, visualColumn, newValue]);\n        }\n    \
    changedCells.push({\n          address\n        });\n      });\n    });\n \
   if (outOfBoundsChanges.length) {\n      \
this.hot.addHookOnce(\"afterChange\", () => {\n        const \
outOfBoundsDependentCells = this.engine.batch(() => {\n          \
outOfBoundsChanges.forEach((_ref5) => {\n            let [row, column, \
newValue] = _ref5;\n            this.syncChangeWithEngine(row, column, \
newValue);\n          });\n        });\n        \
this.renderDependentSheets(outOfBoundsDependentCells, true);\n      });\n    \
}\n    this.renderDependentSheets(dependentCells);\n    \
this.validateDependentCells(dependentCells, changedCells);\n  }\n  /**\n   * \
`onAfterSetSourceDataAtCell` hook callback.\n   *\n   * @private\n   * @param \
{Array[]} changes An array of changes in format [[row, column, oldValue, \
value], ...].\n   * @param {string} [source] String that identifies source of \
hook call\n   *                          ([list of all available \
sources]{@link \
https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsont\
able-hooks}).\n   */\n  onAfterSetSourceDataAtCell(changes, source) {\n    if \
(isBlockedSource(source)) {\n      return;\n    }\n    const dependentCells = \
[];\n    const changedCells = [];\n    changes.forEach((_ref6) => {\n      \
let [visualRow, prop, , newValue] = _ref6;\n      const visualColumn = \
this.hot.propToCol(prop);\n      if (!isNumeric(visualColumn)) {\n        \
return;\n      }\n      const address = {\n        row: \
this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n        col: \
this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n        \
sheet: this.sheetId\n      };\n      if \
(!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(`Not \
possible to set source cell data at ${JSON.stringify(address)}`);\n        \
return;\n      }\n      changedCells.push({\n        address\n      });\n     \
 dependentCells.push(...this.engine.setCellContents(address, newValue));\n    \
});\n    this.renderDependentSheets(dependentCells);\n    \
this.validateDependentCells(dependentCells, changedCells);\n  }\n  /**\n   * \
`beforeCreateRow` hook callback.\n   *\n   * @private\n   * @param {number} \
visualRow Represents the visual index of first newly created row in the data \
source array.\n   * @param {number} amount Number of newly created rows in \
the data source array.\n   * @returns {*|boolean} If false is returned the \
action is canceled.\n   */\n  onBeforeCreateRow(visualRow, amount) {\n    let \
hfRowIndex = this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow);\n    if \
(visualRow >= this.hot.countRows()) {\n      hfRowIndex = visualRow;\n    }\n \
   if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) \
|| !this.engine.isItPossibleToAddRows(this.sheetId, [hfRowIndex, amount])) \
{\n      return false;\n    }\n  }\n  /**\n   * `beforeCreateCol` hook \
callback.\n   *\n   * @private\n   * @param {number} visualColumn Represents \
the visual index of first newly created column in the data source.\n   * \
@param {number} amount Number of newly created columns in the data source.\n  \
 * @returns {*|boolean} If false is returned the action is canceled.\n   */\n \
 onBeforeCreateCol(visualColumn, amount) {\n    let hfColumnIndex = \
this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn);\n    if \
(visualColumn >= this.hot.countCols()) {\n      hfColumnIndex = \
visualColumn;\n    }\n    if (this.sheetId === null || \
!this.engine.doesSheetExist(this.sheetName) || \
!this.engine.isItPossibleToAddColumns(this.sheetId, [hfColumnIndex, amount])) \
{\n      return false;\n    }\n  }\n  /**\n   * `beforeRemoveRow` hook \
callback.\n   *\n   * @private\n   * @param {number} row Visual index of \
starter row.\n   * @param {number} amount Amount of rows to be removed.\n   * \
@param {number[]} physicalRows An array of physical rows removed from the \
data source.\n   * @returns {*|boolean} If false is returned the action is \
canceled.\n   */\n  onBeforeRemoveRow(row, amount, physicalRows) {\n    const \
hfRows = this.rowAxisSyncer.setRemovedHfIndexes(physicalRows);\n    const \
possible = hfRows.every((hfRow) => {\n      return \
this.engine.isItPossibleToRemoveRows(this.sheetId, [hfRow, 1]);\n    });\n    \
return possible === false ? false : void 0;\n  }\n  /**\n   * \
`beforeRemoveCol` hook callback.\n   *\n   * @private\n   * @param {number} \
col Visual index of starter column.\n   * @param {number} amount Amount of \
columns to be removed.\n   * @param {number[]} physicalColumns An array of \
physical columns removed from the data source.\n   * @returns {*|boolean} If \
false is returned the action is canceled.\n   */\n  onBeforeRemoveCol(col, \
amount, physicalColumns) {\n    const hfColumns = \
this.columnAxisSyncer.setRemovedHfIndexes(physicalColumns);\n    const \
possible = hfColumns.every((hfColumn) => {\n      return \
this.engine.isItPossibleToRemoveColumns(this.sheetId, [hfColumn, 1]);\n    \
});\n    return possible === false ? false : void 0;\n  }\n  /**\n   * \
`afterCreateRow` hook callback.\n   *\n   * @private\n   * @param {number} \
visualRow Represents the visual index of first newly created row in the data \
source array.\n   * @param {number} amount Number of newly created rows in \
the data source array.\n   * @param {string} [source] String that identifies \
source of hook call\n   *                          ([list of all available \
sources]{@link \
https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsont\
able-hooks}).\n   */\n  onAfterCreateRow(visualRow, amount, source) {\n    if \
(isBlockedSource(source)) {\n      return;\n    }\n    const changes = \
this.engine.addRows(this.sheetId, \
[this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow), amount]);\n    \
this.renderDependentSheets(changes);\n  }\n  /**\n   * `afterCreateCol` hook \
callback.\n   *\n   * @private\n   * @param {number} visualColumn Represents \
the visual index of first newly created column in the data source.\n   * \
@param {number} amount Number of newly created columns in the data source.\n  \
 * @param {string} [source] String that identifies source of hook call\n   *  \
                        ([list of all available sources]{@link \
https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsont\
able-hooks}).\n   */\n  onAfterCreateCol(visualColumn, amount, source) {\n    \
if (isBlockedSource(source)) {\n      return;\n    }\n    const changes = \
this.engine.addColumns(this.sheetId, \
[this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn), amount]);\n   \
 this.renderDependentSheets(changes);\n  }\n  /**\n   * `afterRemoveRow` hook \
callback.\n   *\n   * @private\n   * @param {number} row Visual index of \
starter row.\n   * @param {number} amount An amount of removed rows.\n   * \
@param {number[]} physicalRows An array of physical rows removed from the \
data source.\n   * @param {string} [source] String that identifies source of \
hook call\n   *                          ([list of all available \
sources]{@link \
https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsont\
able-hooks}).\n   */\n  onAfterRemoveRow(row, amount, physicalRows, source) \
{\n    if (isBlockedSource(source)) {\n      return;\n    }\n    const \
descendingHfRows = \
this.rowAxisSyncer.getRemovedHfIndexes().sort().reverse();\n    const changes \
= this.engine.batch(() => {\n      descendingHfRows.forEach((hfRow) => {\n    \
    this.engine.removeRows(this.sheetId, [hfRow, 1]);\n      });\n    });\n   \
 this.renderDependentSheets(changes);\n  }\n  /**\n   * `afterRemoveCol` hook \
callback.\n   *\n   * @private\n   * @param {number} col Visual index of \
starter column.\n   * @param {number} amount An amount of removed columns.\n  \
 * @param {number[]} physicalColumns An array of physical columns removed \
from the data source.\n   * @param {string} [source] String that identifies \
source of hook call\n   *                          ([list of all available \
sources]{@link \
https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsont\
able-hooks}).\n   */\n  onAfterRemoveCol(col, amount, physicalColumns, \
source) {\n    if (isBlockedSource(source)) {\n      return;\n    }\n    \
const descendingHfColumns = \
this.columnAxisSyncer.getRemovedHfIndexes().sort().reverse();\n    const \
changes = this.engine.batch(() => {\n      \
descendingHfColumns.forEach((hfColumn) => {\n        \
this.engine.removeColumns(this.sheetId, [hfColumn, 1]);\n      });\n    });\n \
   this.renderDependentSheets(changes);\n  }\n  /**\n   * `afterDetachChild` \
hook callback.\n   * Used to sync the data of the rows detached in the Nested \
Rows plugin with the engine's dataset.\n   *\n   * @private\n   * @param \
{object} parent An object representing the parent from which the element was \
detached.\n   * @param {object} element The detached element.\n   * @param \
{number} finalElementRowIndex The final row index of the detached element.\n  \
 */\n  onAfterDetachChild(parent2, element, finalElementRowIndex) {\n    var \
_element$__children;\n    _classPrivateFieldSet11(this, \
_internalOperationPending, true);\n    const rowsData = \
this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + \
(((_element$__children = element.__children) === null || _element$__children \
=== void 0 ? void 0 : _element$__children.length) || 0), \
this.hot.countSourceCols());\n    _classPrivateFieldSet11(this, \
_internalOperationPending, false);\n    rowsData.forEach((row, \
relativeRowIndex) => {\n      row.forEach((value, colIndex) => {\n        \
this.engine.setCellContents({\n          col: colIndex,\n          row: \
finalElementRowIndex + relativeRowIndex,\n          sheet: this.sheetId\n     \
   }, [[value]]);\n      });\n    });\n  }\n  /**\n   * Called when a value \
is updated in the engine.\n   *\n   * @private\n   * @fires \
Hooks#afterFormulasValuesUpdate\n   * @param {Array} changes The values and \
location of applied changes.\n   */\n  onEngineValuesUpdated(changes) {\n    \
this.hot.runHooks(\"afterFormulasValuesUpdate\", changes);\n  }\n  /**\n   * \
Called when a named expression is added to the engine instance.\n   *\n   * \
@private\n   * @fires Hooks#afterNamedExpressionAdded\n   * @param {string} \
namedExpressionName The name of the added expression.\n   * @param {Array} \
changes The values and location of applied changes.\n   */\n  \
onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n    \
this.hot.runHooks(\"afterNamedExpressionAdded\", namedExpressionName, \
changes);\n  }\n  /**\n   * Called when a named expression is removed from \
the engine instance.\n   *\n   * @private\n   * @fires \
Hooks#afterNamedExpressionRemoved\n   * @param {string} namedExpressionName \
The name of the removed expression.\n   * @param {Array} changes The values \
and location of applied changes.\n   */\n  \
onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n    \
this.hot.runHooks(\"afterNamedExpressionRemoved\", namedExpressionName, \
changes);\n  }\n  /**\n   * Called when a new sheet is added to the engine \
instance.\n   *\n   * @private\n   * @fires Hooks#afterSheetAdded\n   * \
@param {string} addedSheetDisplayName The name of the added sheet.\n   */\n  \
onEngineSheetAdded(addedSheetDisplayName) {\n    \
this.hot.runHooks(\"afterSheetAdded\", addedSheetDisplayName);\n  }\n  /**\n  \
 * Called when a sheet in the engine instance is renamed.\n   *\n   * \
@private\n   * @fires Hooks#afterSheetRenamed\n   * @param {string} \
oldDisplayName The old name of the sheet.\n   * @param {string} \
newDisplayName The new name of the sheet.\n   */\n  \
onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n    \
this.hot.runHooks(\"afterSheetRenamed\", oldDisplayName, newDisplayName);\n  \
}\n  /**\n   * Called when a sheet is removed from the engine instance.\n   \
*\n   * @private\n   * @fires Hooks#afterSheetRemoved\n   * @param {string} \
removedSheetDisplayName The removed sheet name.\n   * @param {Array} changes \
The values and location of applied changes.\n   */\n  \
onEngineSheetRemoved(removedSheetDisplayName, changes) {\n    \
this.hot.runHooks(\"afterSheetRemoved\", removedSheetDisplayName, changes);\n \
 }\n};\n\n// \
node_modules/handsontable/plugins/hiddenColumns/contextMenuItem/hideColumn.mj\
s\nfunction hideColumnItem(hiddenColumnsPlugin) {\n  return {\n    key: \
\"hidden_columns_hide\",\n    name() {\n      const selection = \
this.getSelectedLast();\n      let pluralForm = 0;\n      if \
(Array.isArray(selection)) {\n        const [, fromColumn, , toColumn] = \
selection;\n        if (fromColumn - toColumn !== 0) {\n          pluralForm \
= 1;\n        }\n      }\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_COLUMN, pluralForm);\n    \
},\n    callback() {\n      const {\n        from,\n        to\n      } = \
this.getSelectedRangeLast();\n      const start = Math.max(Math.min(from.col, \
to.col), 0);\n      const end = Math.max(from.col, to.col);\n      const \
columnsToHide = [];\n      for (let visualColumn = start; visualColumn <= \
end; visualColumn += 1) {\n        columnsToHide.push(visualColumn);\n      \
}\n      hiddenColumnsPlugin.hideColumns(columnsToHide);\n      const \
lastHiddenColumn = columnsToHide[columnsToHide.length - 1];\n      const \
columnToSelect = \
this.columnIndexMapper.getNearestNotHiddenIndex(lastHiddenColumn, 1, true);\n \
     if (Number.isInteger(columnToSelect) && columnToSelect >= 0) {\n        \
this.selectColumns(columnToSelect);\n      } else {\n        \
this.deselectCell();\n      }\n      this.render();\n      \
this.view.adjustElementsSize(true);\n    },\n    disabled: false,\n    \
hidden() {\n      return !(this.selection.isSelectedByColumnHeader() || \
this.selection.isSelectedByCorner());\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/hiddenColumns/contextMenuItem/showColumn.mj\
s\nfunction showColumnItem(hiddenColumnsPlugin) {\n  const columns = [];\n  \
return {\n    key: \"hidden_columns_show\",\n    name() {\n      const \
pluralForm = columns.length > 1 ? 1 : 0;\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_COLUMN, pluralForm);\n    \
},\n    callback() {\n      var _this$columnIndexMapp, \
_this$columnIndexMapp2;\n      if (columns.length === 0) {\n        return;\n \
     }\n      let startVisualColumn = columns[0];\n      let endVisualColumn \
= columns[columns.length - 1];\n      startVisualColumn = \
(_this$columnIndexMapp = \
this.columnIndexMapper.getNearestNotHiddenIndex(startVisualColumn - 1, -1)) \
!== null && _this$columnIndexMapp !== void 0 ? _this$columnIndexMapp : 0;\n   \
   endVisualColumn = (_this$columnIndexMapp2 = \
this.columnIndexMapper.getNearestNotHiddenIndex(endVisualColumn + 1, 1)) !== \
null && _this$columnIndexMapp2 !== void 0 ? _this$columnIndexMapp2 : \
this.countCols() - 1;\n      hiddenColumnsPlugin.showColumns(columns);\n      \
this.render();\n      this.view.adjustElementsSize(true);\n      const \
allColumnsSelected = endVisualColumn - startVisualColumn + 1 === \
this.countCols();\n      if (!allColumnsSelected) {\n        \
this.selectColumns(startVisualColumn, endVisualColumn);\n      }\n    },\n    \
disabled: false,\n    hidden() {\n      const hiddenPhysicalColumns = \
arrayMap(hiddenColumnsPlugin.getHiddenColumns(), (visualColumnIndex) => {\n   \
     return this.toPhysicalColumn(visualColumnIndex);\n      });\n      if \
(!(this.selection.isSelectedByColumnHeader() || \
this.selection.isSelectedByCorner()) || hiddenPhysicalColumns.length < 1) {\n \
       return true;\n      }\n      columns.length = 0;\n      const \
selectedRangeLast = this.getSelectedRangeLast();\n      const \
visualStartColumn = selectedRangeLast.getTopStartCorner().col;\n      const \
visualEndColumn = selectedRangeLast.getBottomEndCorner().col;\n      const \
columnIndexMapper = this.columnIndexMapper;\n      const \
renderableStartColumn = \
columnIndexMapper.getRenderableFromVisualIndex(visualStartColumn);\n      \
const renderableEndColumn = \
columnIndexMapper.getRenderableFromVisualIndex(visualEndColumn);\n      const \
notTrimmedColumnIndexes = columnIndexMapper.getNotTrimmedIndexes();\n      \
const physicalColumnIndexes = [];\n      if (visualStartColumn !== \
visualEndColumn) {\n        const visualColumnsInRange = visualEndColumn - \
visualStartColumn + 1;\n        const renderedColumnsInRange = \
renderableEndColumn - renderableStartColumn + 1;\n        if \
(visualColumnsInRange > renderedColumnsInRange) {\n          const \
physicalIndexesInRange = notTrimmedColumnIndexes.slice(visualStartColumn, \
visualEndColumn + 1);\n          \
physicalColumnIndexes.push(...physicalIndexesInRange.filter((physicalIndex) \
=> hiddenPhysicalColumns.includes(physicalIndex)));\n        }\n      } else \
if (renderableStartColumn === 0 && renderableStartColumn < visualStartColumn) \
{\n        physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, \
visualStartColumn));\n      } else if (renderableStartColumn === null) {\n    \
    physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, \
this.countCols()));\n      } else {\n        const lastVisualIndex = \
this.countCols() - 1;\n        const lastRenderableIndex = \
columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNo\
tHiddenIndex(lastVisualIndex, -1));\n        if (renderableEndColumn === \
lastRenderableIndex && lastVisualIndex > visualEndColumn) {\n          \
physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(visualEndColumn + \
1));\n        }\n      }\n      arrayEach(physicalColumnIndexes, \
(physicalColumnIndex) => {\n        \
columns.push(this.toVisualColumn(physicalColumnIndex));\n      });\n      \
return columns.length === 0;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/hiddenColumns/hiddenColumns.mjs\nfunction \
_classPrivateFieldInitSpec12(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration13(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration13(obj, privateCollection) {\n \
 if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_classPrivateFieldGet12(receiver, privateMap) {\n  var descriptor = \
_classExtractFieldDescriptor12(receiver, privateMap, \"get\");\n  return \
_classApplyDescriptorGet12(receiver, descriptor);\n}\nfunction \
_classApplyDescriptorGet12(receiver, descriptor) {\n  if (descriptor.get) {\n \
   return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nfunction _classPrivateFieldSet12(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor12(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet12(receiver, descriptor, \
value);\n  return value;\n}\nfunction \
_classExtractFieldDescriptor12(receiver, privateMap, action) {\n  if \
(!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + \
action + \" private field on non-instance\");\n  }\n  return \
privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet12(receiver, \
descriptor, value) {\n  if (descriptor.set) {\n    \
descriptor.set.call(receiver, value);\n  } else {\n    if \
(!descriptor.writable) {\n      throw new TypeError(\"attempted to set read \
only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\npluginHooks_default.getSingleton().register(\"beforeHideColumns\");\npl\
uginHooks_default.getSingleton().register(\"afterHideColumns\");\npluginHooks\
_default.getSingleton().register(\"beforeUnhideColumns\");\npluginHooks_defau\
lt.getSingleton().register(\"afterUnhideColumns\");\nvar PLUGIN_KEY18 = \
\"hiddenColumns\";\nvar PLUGIN_PRIORITY17 = 310;\nvar _settings = /* \
@__PURE__ */ new WeakMap();\nvar _hiddenColumnsMap = /* @__PURE__ */ new \
WeakMap();\nvar HiddenColumns = class extends BasePlugin {\n  constructor() \
{\n    super(...arguments);\n    _classPrivateFieldInitSpec12(this, \
_settings, {\n      writable: true,\n      value: {}\n    });\n    \
_classPrivateFieldInitSpec12(this, _hiddenColumnsMap, {\n      writable: \
true,\n      value: null\n    });\n  }\n  static get PLUGIN_KEY() {\n    \
return PLUGIN_KEY18;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY17;\n  }\n  /**\n   * Checks if the plugin is enabled in the \
handsontable settings. This method is executed in {@link Hooks#beforeInit}\n  \
 * hook and if it returns `true` then the {@link HiddenColumns#enablePlugin} \
method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    \
return !!this.hot.getSettings()[PLUGIN_KEY18];\n  }\n  /**\n   * Enables the \
plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() \
{\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    \
const pluginSettings = this.hot.getSettings()[PLUGIN_KEY18];\n    if \
(isObject(pluginSettings)) {\n      _classPrivateFieldSet12(this, _settings, \
pluginSettings);\n      if (isUndefined(pluginSettings.copyPasteEnabled)) {\n \
       pluginSettings.copyPasteEnabled = true;\n      }\n    }\n    \
_classPrivateFieldSet12(this, _hiddenColumnsMap, new HidingMap());\n    \
_classPrivateFieldGet12(this, _hiddenColumnsMap).addLocalHook(\"init\", () => \
this.onMapInit());\n    \
this.hot.columnIndexMapper.registerMap(this.pluginName, \
_classPrivateFieldGet12(this, _hiddenColumnsMap));\n    \
this.addHook(\"afterContextMenuDefaultOptions\", function() {\n      return \
_this.onAfterContextMenuDefaultOptions(...arguments);\n    });\n    \
this.addHook(\"afterGetCellMeta\", (row, col, cellProperties) => \
this.onAfterGetCellMeta(row, col, cellProperties));\n    \
this.addHook(\"modifyColWidth\", (width, col) => this.onModifyColWidth(width, \
col));\n    this.addHook(\"afterGetColHeader\", function() {\n      return \
_this.onAfterGetColHeader(...arguments);\n    });\n    \
this.addHook(\"modifyCopyableRange\", (ranges) => \
this.onModifyCopyableRange(ranges));\n    super.enablePlugin();\n  }\n  /**\n \
  * Updates the plugin's state.\n   *\n   * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`hiddenColumns`](@/api/options.md#hiddencolumns)\n   */\n  updatePlugin() \
{\n    this.disablePlugin();\n    this.enablePlugin();\n    \
super.updatePlugin();\n  }\n  /**\n   * Disables the plugin functionality for \
this Handsontable instance.\n   */\n  disablePlugin() {\n    \
this.hot.columnIndexMapper.unregisterMap(this.pluginName);\n    \
_classPrivateFieldSet12(this, _settings, {});\n    super.disablePlugin();\n   \
 this.resetCellsMeta();\n  }\n  /**\n   * Shows the provided columns.\n   *\n \
  * @param {number[]} columns Array of visual column indexes.\n   */\n  \
showColumns(columns) {\n    const currentHideConfig = \
this.getHiddenColumns();\n    const isValidConfig = \
this.isValidConfig(columns);\n    let destinationHideConfig = \
currentHideConfig;\n    const hidingMapValues = _classPrivateFieldGet12(this, \
_hiddenColumnsMap).getValues().slice();\n    const isAnyColumnShowed = \
columns.length > 0;\n    if (isValidConfig && isAnyColumnShowed) {\n      \
const physicalColumns = columns.map((visualColumn) => \
this.hot.toPhysicalColumn(visualColumn));\n      arrayEach(physicalColumns, \
(physicalColumn) => {\n        hidingMapValues[physicalColumn] = false;\n     \
 });\n      destinationHideConfig = arrayReduce(hidingMapValues, \
(hiddenIndexes, isHidden, physicalIndex) => {\n        if (isHidden) {\n      \
    hiddenIndexes.push(this.hot.toVisualColumn(physicalIndex));\n        }\n  \
      return hiddenIndexes;\n      }, []);\n    }\n    const continueHiding = \
this.hot.runHooks(\"beforeUnhideColumns\", currentHideConfig, \
destinationHideConfig, isValidConfig && isAnyColumnShowed);\n    if \
(continueHiding === false) {\n      return;\n    }\n    if (isValidConfig && \
isAnyColumnShowed) {\n      _classPrivateFieldGet12(this, \
_hiddenColumnsMap).setValues(hidingMapValues);\n    }\n    \
this.hot.view.adjustElementsSize();\n    \
this.hot.runHooks(\"afterUnhideColumns\", currentHideConfig, \
destinationHideConfig, isValidConfig && isAnyColumnShowed, isValidConfig && \
destinationHideConfig.length < currentHideConfig.length);\n  }\n  /**\n   * \
Shows a single column.\n   *\n   * @param {...number} column Visual column \
index.\n   */\n  showColumn() {\n    for (var _len = arguments.length, column \
= new Array(_len), _key = 0; _key < _len; _key++) {\n      column[_key] = \
arguments[_key];\n    }\n    this.showColumns(column);\n  }\n  /**\n   * \
Hides the columns provided in the array.\n   *\n   * @param {number[]} \
columns Array of visual column indexes.\n   */\n  hideColumns(columns) {\n    \
const currentHideConfig = this.getHiddenColumns();\n    const isConfigValid = \
this.isValidConfig(columns);\n    let destinationHideConfig = \
currentHideConfig;\n    if (isConfigValid) {\n      destinationHideConfig = \
Array.from(new Set(currentHideConfig.concat(columns)));\n    }\n    const \
continueHiding = this.hot.runHooks(\"beforeHideColumns\", currentHideConfig, \
destinationHideConfig, isConfigValid);\n    if (continueHiding === false) {\n \
     return;\n    }\n    if (isConfigValid) {\n      \
this.hot.batchExecution(() => {\n        arrayEach(columns, (visualColumn) => \
{\n          _classPrivateFieldGet12(this, \
_hiddenColumnsMap).setValueAtIndex(this.hot.toPhysicalColumn(visualColumn), \
true);\n        });\n      }, true);\n    }\n    \
this.hot.runHooks(\"afterHideColumns\", currentHideConfig, \
destinationHideConfig, isConfigValid, isConfigValid && \
destinationHideConfig.length > currentHideConfig.length);\n  }\n  /**\n   * \
Hides a single column.\n   *\n   * @param {...number} column Visual column \
index.\n   */\n  hideColumn() {\n    for (var _len2 = arguments.length, \
column = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      \
column[_key2] = arguments[_key2];\n    }\n    this.hideColumns(column);\n  \
}\n  /**\n   * Returns an array of visual indexes of hidden columns.\n   *\n  \
 * @returns {number[]}\n   */\n  getHiddenColumns() {\n    return \
arrayMap(_classPrivateFieldGet12(this, _hiddenColumnsMap).getHiddenIndexes(), \
(physicalColumnIndex) => {\n      return \
this.hot.toVisualColumn(physicalColumnIndex);\n    });\n  }\n  /**\n   * \
Checks if the provided column is hidden.\n   *\n   * @param {number} column \
Visual column index.\n   * @returns {boolean}\n   */\n  isHidden(column) {\n  \
  return _classPrivateFieldGet12(this, \
_hiddenColumnsMap).getValueAtIndex(this.hot.toPhysicalColumn(column)) || \
false;\n  }\n  /**\n   * Get if trim config is valid. Check whether all of \
the provided column indexes are within the bounds of the table.\n   *\n   * \
@param {Array} hiddenColumns List of hidden column indexes.\n   * @returns \
{boolean}\n   */\n  isValidConfig(hiddenColumns) {\n    const nrOfColumns = \
this.hot.countCols();\n    if (Array.isArray(hiddenColumns) && \
hiddenColumns.length > 0) {\n      return hiddenColumns.every((visualColumn) \
=> Number.isInteger(visualColumn) && visualColumn >= 0 && visualColumn < \
nrOfColumns);\n    }\n    return false;\n  }\n  /**\n   * Reset all rendered \
cells meta.\n   *\n   * @private\n   */\n  resetCellsMeta() {\n    \
arrayEach(this.hot.getCellsMeta(), (meta) => {\n      if (meta) {\n        \
meta.skipColumnOnPaste = false;\n      }\n    });\n  }\n  /**\n   * Adds the \
additional column width for the hidden column indicators.\n   *\n   * \
@private\n   * @param {number|undefined} width Column width.\n   * @param \
{number} column Visual column index.\n   * @returns {number}\n   */\n  \
onModifyColWidth(width, column) {\n    if (this.isHidden(column)) {\n      \
return 0;\n    }\n    if (_classPrivateFieldGet12(this, _settings).indicators \
&& (this.isHidden(column + 1) || this.isHidden(column - 1))) {\n      if \
(typeof width === \"number\" && this.hot.hasColHeaders()) {\n        return \
width + 15;\n      }\n    }\n  }\n  /**\n   * Sets the copy-related cell \
meta.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * \
@param {number} column Visual column index.\n   * @param {object} \
cellProperties Object containing the cell properties.\n   */\n  \
onAfterGetCellMeta(row, column, cellProperties) {\n    if \
(_classPrivateFieldGet12(this, _settings).copyPasteEnabled === false && \
this.isHidden(column)) {\n      cellProperties.skipColumnOnPaste = true;\n    \
}\n    if (this.isHidden(column - 1)) {\n      cellProperties.className = \
cellProperties.className || \"\";\n      if \
(cellProperties.className.indexOf(\"afterHiddenColumn\") === -1) {\n        \
cellProperties.className += \" afterHiddenColumn\";\n      }\n    } else if \
(cellProperties.className) {\n      const classArr = \
cellProperties.className.split(\" \");\n      if (classArr.length > 0) {\n    \
    const containAfterHiddenColumn = \
classArr.indexOf(\"afterHiddenColumn\");\n        if \
(containAfterHiddenColumn > -1) {\n          \
classArr.splice(containAfterHiddenColumn, 1);\n        }\n        \
cellProperties.className = classArr.join(\" \");\n      }\n    }\n  }\n  \
/**\n   * Modifies the copyable range, accordingly to the provided config.\n  \
 *\n   * @private\n   * @param {Array} ranges An array of objects defining \
copyable cells.\n   * @returns {Array}\n   */\n  \
onModifyCopyableRange(ranges) {\n    if (_classPrivateFieldGet12(this, \
_settings).copyPasteEnabled) {\n      return ranges;\n    }\n    const \
newRanges = [];\n    const pushRange = (startRow, endRow, startCol, endCol) \
=> {\n      newRanges.push({\n        startRow,\n        endRow,\n        \
startCol,\n        endCol\n      });\n    };\n    arrayEach(ranges, (range) \
=> {\n      let isHidden = true;\n      let rangeStart = 0;\n      \
rangeEach(range.startCol, range.endCol, (visualColumn) => {\n        if \
(this.isHidden(visualColumn)) {\n          if (!isHidden) {\n            \
pushRange(range.startRow, range.endRow, rangeStart, visualColumn - 1);\n      \
    }\n          isHidden = true;\n        } else {\n          if (isHidden) \
{\n            rangeStart = visualColumn;\n          }\n          if \
(visualColumn === range.endCol) {\n            pushRange(range.startRow, \
range.endRow, rangeStart, visualColumn);\n          }\n          isHidden = \
false;\n        }\n      });\n    });\n    return newRanges;\n  }\n  /**\n   \
* Adds the needed classes to the headers.\n   *\n   * @private\n   * @param \
{number} column Visual column index.\n   * @param {HTMLElement} TH Header's \
TH element.\n   */\n  onAfterGetColHeader(column, TH) {\n    if \
(!_classPrivateFieldGet12(this, _settings).indicators || column < 0) {\n      \
return;\n    }\n    const classList = [];\n    if (column >= 1 && \
this.isHidden(column - 1)) {\n      classList.push(\"afterHiddenColumn\");\n  \
  }\n    if (column < this.hot.countCols() - 1 && this.isHidden(column + 1)) \
{\n      classList.push(\"beforeHiddenColumn\");\n    }\n    addClass(TH, \
classList);\n  }\n  /**\n   * Add Show-hide columns to context menu.\n   *\n  \
 * @private\n   * @param {object} options An array of objects containing \
information about the pre-defined Context Menu items.\n   */\n  \
onAfterContextMenuDefaultOptions(options) {\n    options.items.push({\n      \
name: KEY\n    }, hideColumnItem(this), showColumnItem(this));\n  }\n  /**\n  \
 * On map initialized hook callback.\n   *\n   * @private\n   */\n  \
onMapInit() {\n    if (Array.isArray(_classPrivateFieldGet12(this, \
_settings).columns)) {\n      this.hideColumns(_classPrivateFieldGet12(this, \
_settings).columns);\n    }\n  }\n  /**\n   * Destroys the plugin instance.\n \
  */\n  destroy() {\n    _classPrivateFieldSet12(this, _settings, null);\n    \
_classPrivateFieldSet12(this, _hiddenColumnsMap, null);\n    \
super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/hiddenRows/contextMenuItem/hideRow.mjs\nfun\
ction hideRowItem(hiddenRowsPlugin) {\n  return {\n    key: \
\"hidden_rows_hide\",\n    name() {\n      const selection = \
this.getSelectedLast();\n      let pluralForm = 0;\n      if \
(Array.isArray(selection)) {\n        const [fromRow, , toRow] = selection;\n \
       if (fromRow - toRow !== 0) {\n          pluralForm = 1;\n        }\n   \
   }\n      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_ROW, \
pluralForm);\n    },\n    callback() {\n      const {\n        from,\n        \
to\n      } = this.getSelectedRangeLast();\n      const start = \
Math.max(Math.min(from.row, to.row), 0);\n      const end = \
Math.max(from.row, to.row);\n      const rowsToHide = [];\n      for (let \
visualRow = start; visualRow <= end; visualRow += 1) {\n        \
rowsToHide.push(visualRow);\n      }\n      \
hiddenRowsPlugin.hideRows(rowsToHide);\n      const lastHiddenRow = \
rowsToHide[rowsToHide.length - 1];\n      const rowToSelect = \
this.rowIndexMapper.getNearestNotHiddenIndex(lastHiddenRow, 1, true);\n      \
if (Number.isInteger(rowToSelect) && rowToSelect >= 0) {\n        \
this.selectRows(rowToSelect);\n      } else {\n        this.deselectCell();\n \
     }\n      this.render();\n      this.view.adjustElementsSize(true);\n    \
},\n    disabled: false,\n    hidden() {\n      return \
!(this.selection.isSelectedByRowHeader() || \
this.selection.isSelectedByCorner());\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/hiddenRows/contextMenuItem/showRow.mjs\nfun\
ction showRowItem(hiddenRowsPlugin) {\n  const rows = [];\n  return {\n    \
key: \"hidden_rows_show\",\n    name() {\n      const pluralForm = \
rows.length > 1 ? 1 : 0;\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_ROW, pluralForm);\n    },\n   \
 callback() {\n      var _this$rowIndexMapper$, _this$rowIndexMapper$2;\n     \
 if (rows.length === 0) {\n        return;\n      }\n      let startVisualRow \
= rows[0];\n      let endVisualRow = rows[rows.length - 1];\n      \
startVisualRow = (_this$rowIndexMapper$ = \
this.rowIndexMapper.getNearestNotHiddenIndex(startVisualRow - 1, -1)) !== \
null && _this$rowIndexMapper$ !== void 0 ? _this$rowIndexMapper$ : 0;\n      \
endVisualRow = (_this$rowIndexMapper$2 = \
this.rowIndexMapper.getNearestNotHiddenIndex(endVisualRow + 1, 1)) !== null \
&& _this$rowIndexMapper$2 !== void 0 ? _this$rowIndexMapper$2 : \
this.countRows() - 1;\n      hiddenRowsPlugin.showRows(rows);\n      \
this.render();\n      this.view.adjustElementsSize(true);\n      const \
allRowsSelected = endVisualRow - startVisualRow + 1 === this.countRows();\n   \
   if (!allRowsSelected) {\n        this.selectRows(startVisualRow, \
endVisualRow);\n      }\n    },\n    disabled: false,\n    hidden() {\n      \
const hiddenPhysicalRows = arrayMap(hiddenRowsPlugin.getHiddenRows(), \
(visualRowIndex) => {\n        return this.toPhysicalRow(visualRowIndex);\n   \
   });\n      if (!(this.selection.isSelectedByRowHeader() || \
this.selection.isSelectedByCorner()) || hiddenPhysicalRows.length < 1) {\n    \
    return true;\n      }\n      rows.length = 0;\n      const \
selectedRangeLast = this.getSelectedRangeLast();\n      const visualStartRow \
= selectedRangeLast.getTopStartCorner().row;\n      const visualEndRow = \
selectedRangeLast.getBottomEndCorner().row;\n      const rowIndexMapper = \
this.rowIndexMapper;\n      const renderableStartRow = \
rowIndexMapper.getRenderableFromVisualIndex(visualStartRow);\n      const \
renderableEndRow = \
rowIndexMapper.getRenderableFromVisualIndex(visualEndRow);\n      const \
notTrimmedRowIndexes = rowIndexMapper.getNotTrimmedIndexes();\n      const \
physicalRowIndexes = [];\n      if (visualStartRow !== visualEndRow) {\n      \
  const visualRowsInRange = visualEndRow - visualStartRow + 1;\n        const \
renderedRowsInRange = renderableEndRow - renderableStartRow + 1;\n        if \
(visualRowsInRange > renderedRowsInRange) {\n          const \
physicalIndexesInRange = notTrimmedRowIndexes.slice(visualStartRow, \
visualEndRow + 1);\n          \
physicalRowIndexes.push(...physicalIndexesInRange.filter((physicalIndex) => \
hiddenPhysicalRows.includes(physicalIndex)));\n        }\n      } else if \
(renderableStartRow === 0 && renderableStartRow < visualStartRow) {\n        \
physicalRowIndexes.push(...notTrimmedRowIndexes.slice(0, visualStartRow));\n  \
    } else if (renderableStartRow === null) {\n        \
physicalRowIndexes.push(...notTrimmedRowIndexes.slice(0, \
this.countRows()));\n      } else {\n        const lastVisualIndex = \
this.countRows() - 1;\n        const lastRenderableIndex = \
rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHidde\
nIndex(lastVisualIndex, -1));\n        if (renderableEndRow === \
lastRenderableIndex && lastVisualIndex > visualEndRow) {\n          \
physicalRowIndexes.push(...notTrimmedRowIndexes.slice(visualEndRow + 1));\n   \
     }\n      }\n      arrayEach(physicalRowIndexes, (physicalRowIndex) => \
{\n        rows.push(this.toVisualRow(physicalRowIndex));\n      });\n      \
return rows.length === 0;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/hiddenRows/hiddenRows.mjs\nfunction \
_classPrivateFieldInitSpec13(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration14(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration14(obj, privateCollection) {\n \
 if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_classPrivateFieldGet13(receiver, privateMap) {\n  var descriptor = \
_classExtractFieldDescriptor13(receiver, privateMap, \"get\");\n  return \
_classApplyDescriptorGet13(receiver, descriptor);\n}\nfunction \
_classApplyDescriptorGet13(receiver, descriptor) {\n  if (descriptor.get) {\n \
   return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nfunction _classPrivateFieldSet13(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor13(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet13(receiver, descriptor, \
value);\n  return value;\n}\nfunction \
_classExtractFieldDescriptor13(receiver, privateMap, action) {\n  if \
(!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + \
action + \" private field on non-instance\");\n  }\n  return \
privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet13(receiver, \
descriptor, value) {\n  if (descriptor.set) {\n    \
descriptor.set.call(receiver, value);\n  } else {\n    if \
(!descriptor.writable) {\n      throw new TypeError(\"attempted to set read \
only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\npluginHooks_default.getSingleton().register(\"beforeHideRows\");\nplugi\
nHooks_default.getSingleton().register(\"afterHideRows\");\npluginHooks_defau\
lt.getSingleton().register(\"beforeUnhideRows\");\npluginHooks_default.getSin\
gleton().register(\"afterUnhideRows\");\nvar PLUGIN_KEY19 = \
\"hiddenRows\";\nvar PLUGIN_PRIORITY18 = 320;\nvar _settings2 = /* @__PURE__ \
*/ new WeakMap();\nvar _hiddenRowsMap = /* @__PURE__ */ new WeakMap();\nvar \
HiddenRows = class extends BasePlugin {\n  constructor() {\n    \
super(...arguments);\n    _classPrivateFieldInitSpec13(this, _settings2, {\n  \
    writable: true,\n      value: {}\n    });\n    \
_classPrivateFieldInitSpec13(this, _hiddenRowsMap, {\n      writable: true,\n \
     value: null\n    });\n  }\n  static get PLUGIN_KEY() {\n    return \
PLUGIN_KEY19;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY18;\n  }\n  /**\n   * Checks if the plugin is enabled in the \
handsontable settings. This method is executed in {@link Hooks#beforeInit}\n  \
 * hook and if it returns `true` then the {@link HiddenRows#enablePlugin} \
method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    \
return !!this.hot.getSettings()[PLUGIN_KEY19];\n  }\n  /**\n   * Enables the \
plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() \
{\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    \
const pluginSettings = this.hot.getSettings()[PLUGIN_KEY19];\n    if \
(isObject(pluginSettings)) {\n      _classPrivateFieldSet13(this, _settings2, \
pluginSettings);\n      if (isUndefined(pluginSettings.copyPasteEnabled)) {\n \
       pluginSettings.copyPasteEnabled = true;\n      }\n    }\n    \
_classPrivateFieldSet13(this, _hiddenRowsMap, new HidingMap());\n    \
_classPrivateFieldGet13(this, _hiddenRowsMap).addLocalHook(\"init\", () => \
this.onMapInit());\n    this.hot.rowIndexMapper.registerMap(this.pluginName, \
_classPrivateFieldGet13(this, _hiddenRowsMap));\n    \
this.addHook(\"afterContextMenuDefaultOptions\", function() {\n      return \
_this.onAfterContextMenuDefaultOptions(...arguments);\n    });\n    \
this.addHook(\"afterGetCellMeta\", (row, col, cellProperties) => \
this.onAfterGetCellMeta(row, col, cellProperties));\n    \
this.addHook(\"modifyRowHeight\", (height, row) => \
this.onModifyRowHeight(height, row));\n    \
this.addHook(\"afterGetRowHeader\", function() {\n      return \
_this.onAfterGetRowHeader(...arguments);\n    });\n    \
this.addHook(\"modifyCopyableRange\", (ranges) => \
this.onModifyCopyableRange(ranges));\n    super.enablePlugin();\n  }\n  /**\n \
  * Updates the plugin's state.\n   *\n   * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`hiddenRows`](@/api/options.md#hiddenrows)\n   */\n  updatePlugin() {\n    \
this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  \
}\n  /**\n   * Disables the plugin functionality for this Handsontable \
instance.\n   */\n  disablePlugin() {\n    \
this.hot.rowIndexMapper.unregisterMap(this.pluginName);\n    \
_classPrivateFieldSet13(this, _settings2, {});\n    super.disablePlugin();\n  \
  this.resetCellsMeta();\n  }\n  /**\n   * Shows the rows provided in the \
array.\n   *\n   * @param {number[]} rows Array of visual row indexes.\n   \
*/\n  showRows(rows) {\n    const currentHideConfig = this.getHiddenRows();\n \
   const isValidConfig = this.isValidConfig(rows);\n    let \
destinationHideConfig = currentHideConfig;\n    const hidingMapValues = \
_classPrivateFieldGet13(this, _hiddenRowsMap).getValues().slice();\n    const \
isAnyRowShowed = rows.length > 0;\n    if (isValidConfig && isAnyRowShowed) \
{\n      const physicalRows = rows.map((visualRow) => \
this.hot.toPhysicalRow(visualRow));\n      arrayEach(physicalRows, \
(physicalRow) => {\n        hidingMapValues[physicalRow] = false;\n      \
});\n      destinationHideConfig = arrayReduce(hidingMapValues, \
(hiddenIndexes, isHidden, physicalIndex) => {\n        if (isHidden) {\n      \
    hiddenIndexes.push(this.hot.toVisualRow(physicalIndex));\n        }\n     \
   return hiddenIndexes;\n      }, []);\n    }\n    const continueHiding = \
this.hot.runHooks(\"beforeUnhideRows\", currentHideConfig, \
destinationHideConfig, isValidConfig && isAnyRowShowed);\n    if \
(continueHiding === false) {\n      return;\n    }\n    if (isValidConfig && \
isAnyRowShowed) {\n      _classPrivateFieldGet13(this, \
_hiddenRowsMap).setValues(hidingMapValues);\n    }\n    \
this.hot.runHooks(\"afterUnhideRows\", currentHideConfig, \
destinationHideConfig, isValidConfig && isAnyRowShowed, isValidConfig && \
destinationHideConfig.length < currentHideConfig.length);\n  }\n  /**\n   * \
Shows the row provided as row index (counting from 0).\n   *\n   * @param \
{...number} row Visual row index.\n   */\n  showRow() {\n    for (var _len = \
arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {\n   \
   row[_key] = arguments[_key];\n    }\n    this.showRows(row);\n  }\n  /**\n \
  * Hides the rows provided in the array.\n   *\n   * @param {number[]} rows \
Array of visual row indexes.\n   */\n  hideRows(rows) {\n    const \
currentHideConfig = this.getHiddenRows();\n    const isConfigValid = \
this.isValidConfig(rows);\n    let destinationHideConfig = \
currentHideConfig;\n    if (isConfigValid) {\n      destinationHideConfig = \
Array.from(new Set(currentHideConfig.concat(rows)));\n    }\n    const \
continueHiding = this.hot.runHooks(\"beforeHideRows\", currentHideConfig, \
destinationHideConfig, isConfigValid);\n    if (continueHiding === false) {\n \
     return;\n    }\n    if (isConfigValid) {\n      \
this.hot.batchExecution(() => {\n        arrayEach(rows, (visualRow) => {\n   \
       _classPrivateFieldGet13(this, \
_hiddenRowsMap).setValueAtIndex(this.hot.toPhysicalRow(visualRow), true);\n   \
     });\n      }, true);\n    }\n    this.hot.runHooks(\"afterHideRows\", \
currentHideConfig, destinationHideConfig, isConfigValid, isConfigValid && \
destinationHideConfig.length > currentHideConfig.length);\n  }\n  /**\n   * \
Hides the row provided as row index (counting from 0).\n   *\n   * @param \
{...number} row Visual row index.\n   */\n  hideRow() {\n    for (var _len2 = \
arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) \
{\n      row[_key2] = arguments[_key2];\n    }\n    this.hideRows(row);\n  \
}\n  /**\n   * Returns an array of visual indexes of hidden rows.\n   *\n   * \
@returns {number[]}\n   */\n  getHiddenRows() {\n    return \
arrayMap(_classPrivateFieldGet13(this, _hiddenRowsMap).getHiddenIndexes(), \
(physicalRowIndex) => {\n      return \
this.hot.toVisualRow(physicalRowIndex);\n    });\n  }\n  /**\n   * Checks if \
the provided row is hidden.\n   *\n   * @param {number} row Visual row \
index.\n   * @returns {boolean}\n   */\n  isHidden(row) {\n    return \
_classPrivateFieldGet13(this, \
_hiddenRowsMap).getValueAtIndex(this.hot.toPhysicalRow(row)) || false;\n  }\n \
 /**\n   * Checks whether all of the provided row indexes are within the \
bounds of the table.\n   *\n   * @param {Array} hiddenRows List of hidden \
visual row indexes.\n   * @returns {boolean}\n   */\n  \
isValidConfig(hiddenRows) {\n    const nrOfRows = this.hot.countRows();\n    \
if (Array.isArray(hiddenRows) && hiddenRows.length > 0) {\n      return \
hiddenRows.every((visualRow) => Number.isInteger(visualRow) && visualRow >= 0 \
&& visualRow < nrOfRows);\n    }\n    return false;\n  }\n  /**\n   * Resets \
all rendered cells meta.\n   *\n   * @private\n   */\n  resetCellsMeta() {\n  \
  arrayEach(this.hot.getCellsMeta(), (meta) => {\n      if (meta) {\n        \
meta.skipRowOnPaste = false;\n      }\n    });\n  }\n  /**\n   * Adds the \
additional row height for the hidden row indicators.\n   *\n   * @private\n   \
* @param {number|undefined} height Row height.\n   * @param {number} row \
Visual row index.\n   * @returns {number}\n   */\n  onModifyRowHeight(height, \
row) {\n    if (this.isHidden(row)) {\n      return 0;\n    }\n    return \
height;\n  }\n  /**\n   * Sets the copy-related cell meta.\n   *\n   * \
@private\n   * @param {number} row Visual row index.\n   * @param {number} \
column Visual column index.\n   * @param {object} cellProperties Object \
containing the cell properties.\n   */\n  onAfterGetCellMeta(row, column, \
cellProperties) {\n    if (_classPrivateFieldGet13(this, \
_settings2).copyPasteEnabled === false && this.isHidden(row)) {\n      \
cellProperties.skipRowOnPaste = true;\n    }\n    if (this.isHidden(row - 1)) \
{\n      cellProperties.className = cellProperties.className || \"\";\n      \
if (cellProperties.className.indexOf(\"afterHiddenRow\") === -1) {\n        \
cellProperties.className += \" afterHiddenRow\";\n      }\n    } else if \
(cellProperties.className) {\n      const classArr = \
cellProperties.className.split(\" \");\n      if (classArr.length > 0) {\n    \
    const containAfterHiddenRow = classArr.indexOf(\"afterHiddenRow\");\n     \
   if (containAfterHiddenRow > -1) {\n          \
classArr.splice(containAfterHiddenRow, 1);\n        }\n        \
cellProperties.className = classArr.join(\" \");\n      }\n    }\n  }\n  \
/**\n   * Modifies the copyable range, accordingly to the provided config.\n  \
 *\n   * @private\n   * @param {Array} ranges An array of objects defining \
copyable cells.\n   * @returns {Array}\n   */\n  \
onModifyCopyableRange(ranges) {\n    if (_classPrivateFieldGet13(this, \
_settings2).copyPasteEnabled) {\n      return ranges;\n    }\n    const \
newRanges = [];\n    const pushRange = (startRow, endRow, startCol, endCol) \
=> {\n      newRanges.push({\n        startRow,\n        endRow,\n        \
startCol,\n        endCol\n      });\n    };\n    arrayEach(ranges, (range) \
=> {\n      let isHidden = true;\n      let rangeStart = 0;\n      \
rangeEach(range.startRow, range.endRow, (visualRow) => {\n        if \
(this.isHidden(visualRow)) {\n          if (!isHidden) {\n            \
pushRange(rangeStart, visualRow - 1, range.startCol, range.endCol);\n         \
 }\n          isHidden = true;\n        } else {\n          if (isHidden) {\n \
           rangeStart = visualRow;\n          }\n          if (visualRow === \
range.endRow) {\n            pushRange(rangeStart, visualRow, range.startCol, \
range.endCol);\n          }\n          isHidden = false;\n        }\n      \
});\n    });\n    return newRanges;\n  }\n  /**\n   * Adds the needed classes \
to the headers.\n   *\n   * @private\n   * @param {number} row Visual row \
index.\n   * @param {HTMLElement} TH Header's TH element.\n   */\n  \
onAfterGetRowHeader(row, TH) {\n    if (!_classPrivateFieldGet13(this, \
_settings2).indicators || row < 0) {\n      return;\n    }\n    const \
classList = [];\n    if (row >= 1 && this.isHidden(row - 1)) {\n      \
classList.push(\"afterHiddenRow\");\n    }\n    if (row < \
this.hot.countRows() - 1 && this.isHidden(row + 1)) {\n      \
classList.push(\"beforeHiddenRow\");\n    }\n    addClass(TH, classList);\n  \
}\n  /**\n   * Add Show-hide rows to context menu.\n   *\n   * @private\n   * \
@param {object} options An array of objects containing information about the \
pre-defined Context Menu items.\n   */\n  \
onAfterContextMenuDefaultOptions(options) {\n    options.items.push({\n      \
name: KEY\n    }, hideRowItem(this), showRowItem(this));\n  }\n  /**\n   * On \
map initialized hook callback.\n   *\n   * @private\n   */\n  onMapInit() {\n \
   if (Array.isArray(_classPrivateFieldGet13(this, _settings2).rows)) {\n     \
 this.hideRows(_classPrivateFieldGet13(this, _settings2).rows);\n    }\n  }\n \
 /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    \
_classPrivateFieldSet13(this, _settings2, null);\n    \
_classPrivateFieldSet13(this, _hiddenRowsMap, null);\n    super.destroy();\n  \
}\n};\n\n// \
node_modules/handsontable/plugins/manualColumnFreeze/contextMenuItem/freezeCo\
lumn.mjs\nfunction freezeColumnItem(manualColumnFreezePlugin) {\n  return {\n \
   key: \"freeze_column\",\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_FREEZE_COLUMN);\n    },\n    \
callback(key, selected) {\n      const [{\n        start: {\n          col: \
selectedColumn\n        }\n      }] = selected;\n      \
manualColumnFreezePlugin.freezeColumn(selectedColumn);\n      \
this.render();\n      this.view.adjustElementsSize(true);\n    },\n    \
hidden() {\n      const selection = this.getSelectedRange();\n      let hide \
= false;\n      if (selection === void 0) {\n        hide = true;\n      } \
else if (selection.length > 1) {\n        hide = true;\n      } else if \
(selection[0].from.col !== selection[0].to.col || selection[0].from.col <= \
this.getSettings().fixedColumnsStart - 1) {\n        hide = true;\n      }\n  \
    return hide;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/manualColumnFreeze/contextMenuItem/unfreeze\
Column.mjs\nfunction unfreezeColumnItem(manualColumnFreezePlugin) {\n  return \
{\n    key: \"unfreeze_column\",\n    name() {\n      return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNFREEZE_COLUMN);\n    },\n    \
callback(key, selected) {\n      const [{\n        start: {\n          col: \
selectedColumn\n        }\n      }] = selected;\n      \
manualColumnFreezePlugin.unfreezeColumn(selectedColumn);\n      \
this.render();\n      this.view.adjustElementsSize(true);\n    },\n    \
hidden() {\n      const selection = this.getSelectedRange();\n      let hide \
= false;\n      if (selection === void 0) {\n        hide = true;\n      } \
else if (selection.length > 1) {\n        hide = true;\n      } else if \
(selection[0].from.col !== selection[0].to.col || selection[0].from.col >= \
this.getSettings().fixedColumnsStart) {\n        hide = true;\n      }\n      \
return hide;\n    }\n  };\n}\n\n// \
node_modules/handsontable/plugins/manualColumnFreeze/manualColumnFreeze.mjs\n\
pluginHooks_default.getSingleton().register(\"beforeColumnFreeze\");\npluginH\
ooks_default.getSingleton().register(\"afterColumnFreeze\");\npluginHooks_def\
ault.getSingleton().register(\"beforeColumnUnfreeze\");\npluginHooks_default.\
getSingleton().register(\"afterColumnUnfreeze\");\nvar PLUGIN_KEY20 = \
\"manualColumnFreeze\";\nvar PLUGIN_PRIORITY19 = 110;\nvar privatePool14 = /* \
@__PURE__ */ new WeakMap();\nvar ManualColumnFreeze = class extends \
BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY20;\n  }\n  \
static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY19;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    \
privatePool14.set(this, {\n      afterFirstUse: false\n    });\n  }\n  /**\n  \
 * Checks if the plugin is enabled in the handsontable settings. This method \
is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` \
then the {@link ManualColumnFreeze#enablePlugin} method is called.\n   *\n   \
* @returns {boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY20];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
if (this.enabled) {\n      return;\n    }\n    \
this.addHook(\"afterContextMenuDefaultOptions\", (options) => \
this.addContextMenuEntry(options));\n    this.addHook(\"beforeColumnMove\", \
(columns, finalIndex) => this.onBeforeColumnMove(columns, finalIndex));\n    \
super.enablePlugin();\n  }\n  /**\n   * Disables the plugin functionality for \
this Handsontable instance.\n   */\n  disablePlugin() {\n    const priv = \
privatePool14.get(this);\n    priv.afterFirstUse = false;\n    \
super.disablePlugin();\n  }\n  /**\n   * Updates the plugin's state.\n   *\n  \
 * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`manualColumnFreeze`](@/api/options.md#manualcolumnfreeze)\n   */\n  \
updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    \
super.updatePlugin();\n  }\n  /**\n   * Freezes the specified column (adds it \
to fixed columns).\n   *\n   * `freezeColumn()` doesn't re-render the \
table,\n   * so you need to call the `render()` method afterward.\n   *\n   * \
@param {number} column Visual column index.\n   */\n  freezeColumn(column) \
{\n    const priv = privatePool14.get(this);\n    const settings = \
this.hot.getSettings();\n    const freezePerformed = \
settings.fixedColumnsStart < this.hot.countCols() && column > \
settings.fixedColumnsStart - 1;\n    if (!priv.afterFirstUse) {\n      \
priv.afterFirstUse = true;\n    }\n    const beforeColumnFreezeHook = \
this.hot.runHooks(\"beforeColumnFreeze\", column, freezePerformed);\n    if \
(beforeColumnFreezeHook === false) {\n      return;\n    }\n    if \
(freezePerformed) {\n      this.hot.columnIndexMapper.moveIndexes(column, \
settings.fixedColumnsStart);\n      settings._fixedColumnsStart += 1;\n    \
}\n    this.hot.runHooks(\"afterColumnFreeze\", column, freezePerformed);\n  \
}\n  /**\n   * Unfreezes the given column (remove it from fixed columns and \
bring to it's previous position).\n   *\n   * @param {number} column Visual \
column index.\n   */\n  unfreezeColumn(column) {\n    const priv = \
privatePool14.get(this);\n    const settings = this.hot.getSettings();\n    \
const unfreezePerformed = settings.fixedColumnsStart > 0 && column <= \
settings.fixedColumnsStart - 1;\n    if (!priv.afterFirstUse) {\n      \
priv.afterFirstUse = true;\n    }\n    const beforeColumnUnfreezeHook = \
this.hot.runHooks(\"beforeColumnUnfreeze\", column, unfreezePerformed);\n    \
if (beforeColumnUnfreezeHook === false) {\n      return;\n    }\n    if \
(unfreezePerformed) {\n      settings._fixedColumnsStart -= 1;\n      \
this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);\n \
   }\n    this.hot.runHooks(\"afterColumnUnfreeze\", column, \
unfreezePerformed);\n  }\n  /**\n   * Adds the manualColumnFreeze context \
menu entries.\n   *\n   * @private\n   * @param {object} options Context menu \
options.\n   */\n  addContextMenuEntry(options) {\n    options.items.push({\n \
     name: \"---------\"\n    }, freezeColumnItem(this), \
unfreezeColumnItem(this));\n  }\n  /**\n   * Prevents moving the columns \
from/to fixed area.\n   *\n   * @private\n   * @param {Array} columns Array \
of visual column indexes to be moved.\n   * @param {number} finalIndex Visual \
column index, being a start index for the moved columns. Points to where the \
elements will be placed after the moving action.\n   * @returns \
{boolean|undefined}\n   */\n  onBeforeColumnMove(columns, finalIndex) {\n    \
const priv = privatePool14.get(this);\n    if (priv.afterFirstUse) {\n      \
const freezeLine = this.hot.getSettings().fixedColumnsStart;\n      if \
(finalIndex < freezeLine) {\n        return false;\n      }\n      if \
(columns.some((column) => column < freezeLine)) {\n        return false;\n    \
  }\n    }\n  }\n};\n\n// \
node_modules/handsontable/plugins/manualColumnMove/ui/_base.mjs\nvar \
STATE_INITIALIZED = 0;\nvar STATE_BUILT2 = 1;\nvar STATE_APPENDED = 2;\nvar \
UNIT = \"px\";\nvar BaseUI2 = class {\n  constructor(hotInstance) {\n    \
this.hot = hotInstance;\n    this._element = null;\n    this.state = \
STATE_INITIALIZED;\n    this.inlineProperty = hotInstance.isRtl() ? \"right\" \
: \"left\";\n  }\n  /**\n   * Add created UI elements to table.\n   *\n   * \
@param {HTMLElement} wrapper Element which are parent for our UI element.\n   \
*/\n  appendTo(wrapper) {\n    wrapper.appendChild(this._element);\n    \
this.state = STATE_APPENDED;\n  }\n  /**\n   * Method for create UI element. \
Only create, without append to table.\n   */\n  build() {\n    if (this.state \
!== STATE_INITIALIZED) {\n      return;\n    }\n    this._element = \
this.hot.rootDocument.createElement(\"div\");\n    this.state = \
STATE_BUILT2;\n  }\n  /**\n   * Method for remove UI element.\n   */\n  \
destroy() {\n    if (this.isAppended()) {\n      \
this._element.parentElement.removeChild(this._element);\n    }\n    \
this._element = null;\n    this.state = STATE_INITIALIZED;\n  }\n  /**\n   * \
Check if UI element are appended.\n   *\n   * @returns {boolean}\n   */\n  \
isAppended() {\n    return this.state === STATE_APPENDED;\n  }\n  /**\n   * \
Check if UI element are built.\n   *\n   * @returns {boolean}\n   */\n  \
isBuilt() {\n    return this.state >= STATE_BUILT2;\n  }\n  /**\n   * Setter \
for position.\n   *\n   * @param {number} top New top position of the \
element.\n   * @param {number} inlinePosition New left/right (depends on \
LTR/RTL document mode) position of the element.\n   */\n  setPosition(top2, \
inlinePosition) {\n    if (isNumeric(top2)) {\n      this._element.style.top \
= top2 + UNIT;\n    }\n    if (isNumeric(inlinePosition)) {\n      \
this._element.style[this.inlineProperty] = inlinePosition + UNIT;\n    }\n  \
}\n  /**\n   * Getter for the element position.\n   *\n   * @returns {object} \
Object contains left and top position of the element.\n   */\n  getPosition() \
{\n    const style = this._element.style;\n    return {\n      top: style.top \
? parseInt(style.top, 10) : 0,\n      start: style[this.inlineProperty] ? \
parseInt(style[this.inlineProperty], 10) : 0\n    };\n  }\n  /**\n   * Setter \
for the element size.\n   *\n   * @param {number} width New width of the \
element.\n   * @param {number} height New height of the element.\n   */\n  \
setSize(width, height) {\n    if (isNumeric(width)) {\n      \
this._element.style.width = width + UNIT;\n    }\n    if (isNumeric(height)) \
{\n      this._element.style.height = height + UNIT;\n    }\n  }\n  /**\n   * \
Getter for the element position.\n   *\n   * @returns {object} Object \
contains height and width of the element.\n   */\n  getSize() {\n    return \
{\n      width: this._element.style.width ? \
parseInt(this._element.style.width, 10) : 0,\n      height: \
this._element.style.height ? parseInt(this._element.style.height, 10) : 0\n   \
 };\n  }\n  /**\n   * Setter for the element offset. Offset means marginTop \
and marginLeft of the element.\n   *\n   * @param {number} top New margin top \
of the element.\n   * @param {number} inlineOffset New margin left/right \
(depends on LTR/RTL document mode) of the element.\n   */\n  setOffset(top2, \
inlineOffset) {\n    if (isNumeric(top2)) {\n      \
this._element.style.marginTop = top2 + UNIT;\n    }\n    if \
(isNumeric(inlineOffset)) {\n      \
this._element.style[`margin${toUpperCaseFirst(this.inlineProperty)}`] = \
inlineOffset + UNIT;\n    }\n  }\n  /**\n   * Getter for the element \
offset.\n   *\n   * @returns {object} Object contains top and left offset of \
the element.\n   */\n  getOffset() {\n    const style = \
this._element.style;\n    const inlineProp = \
`margin${toUpperCaseFirst(this.inlineProperty)}`;\n    return {\n      top: \
style.marginTop ? parseInt(style.marginTop, 10) : 0,\n      start: \
style[inlineProp] ? parseInt(style[inlineProp], 10) : 0\n    };\n  }\n};\nvar \
base_default5 = BaseUI2;\n\n// \
node_modules/handsontable/plugins/manualColumnMove/ui/backlight.mjs\nvar \
CSS_CLASSNAME = \"ht__manualColumnMove--backlight\";\nvar BacklightUI = class \
extends base_default5 {\n  /**\n   * Custom className on build process.\n   \
*/\n  build() {\n    super.build();\n    addClass(this._element, \
CSS_CLASSNAME);\n  }\n};\nvar backlight_default = BacklightUI;\n\n// \
node_modules/handsontable/plugins/manualColumnMove/ui/guideline.mjs\nvar \
CSS_CLASSNAME2 = \"ht__manualColumnMove--guideline\";\nvar GuidelineUI = \
class extends base_default5 {\n  /**\n   * Custom className on build \
process.\n   */\n  build() {\n    super.build();\n    addClass(this._element, \
CSS_CLASSNAME2);\n  }\n};\nvar guideline_default = GuidelineUI;\n\n// \
node_modules/handsontable/plugins/manualColumnMove/manualColumnMove.mjs\nplug\
inHooks_default.getSingleton().register(\"beforeColumnMove\");\npluginHooks_d\
efault.getSingleton().register(\"afterColumnMove\");\nvar PLUGIN_KEY21 = \
\"manualColumnMove\";\nvar PLUGIN_PRIORITY20 = 120;\nvar privatePool15 = /* \
@__PURE__ */ new WeakMap();\nvar CSS_PLUGIN = \"ht__manualColumnMove\";\nvar \
CSS_SHOW_UI = \"show-ui\";\nvar CSS_ON_MOVING = \"on-moving--columns\";\nvar \
CSS_AFTER_SELECTION = \"after-selection--columns\";\nvar ManualColumnMove = \
class extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return \
PLUGIN_KEY21;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY20;\n  }\n  constructor(hotInstance) {\n    \
super(hotInstance);\n    privatePool15.set(this, {\n      columnsToMove: \
[],\n      countCols: 0,\n      fixedColumns: 0,\n      pressed: void 0,\n    \
  target: {\n        eventPageX: void 0,\n        coords: void 0,\n        \
TD: void 0,\n        col: void 0\n      },\n      cachedDropIndex: void 0\n   \
 });\n    this.eventManager = new eventManager_default(this);\n    \
this.backlight = new backlight_default(hotInstance);\n    this.guideline = \
new guideline_default(hotInstance);\n  }\n  /**\n   * Checks if the plugin is \
enabled in the handsontable settings. This method is executed in {@link \
Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link \
ManualColumnMove#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY21];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    \
this.addHook(\"beforeOnCellMouseDown\", function() {\n      return \
_this.onBeforeOnCellMouseDown(...arguments);\n    });\n    \
this.addHook(\"beforeOnCellMouseOver\", function() {\n      return \
_this.onBeforeOnCellMouseOver(...arguments);\n    });\n    \
this.addHook(\"afterScrollVertically\", () => \
this.onAfterScrollVertically());\n    this.addHook(\"afterLoadData\", \
function() {\n      return _this.onAfterLoadData(...arguments);\n    });\n    \
this.buildPluginUI();\n    this.registerEvents();\n    \
addClass(this.hot.rootElement, CSS_PLUGIN);\n    super.enablePlugin();\n  }\n \
 /**\n   * Updates the plugin's state.\n   *\n   * This method is executed \
when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any \
of the following configuration options:\n   *  - \
[`manualColumnMove`](@/api/options.md#manualcolumnmove)\n   */\n  \
updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    \
this.moveBySettingsOrLoad();\n    super.updatePlugin();\n  }\n  /**\n   * \
Disables the plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    removeClass(this.hot.rootElement, CSS_PLUGIN);\n    \
this.unregisterEvents();\n    this.backlight.destroy();\n    \
this.guideline.destroy();\n    super.disablePlugin();\n  }\n  /**\n   * Moves \
a single column.\n   *\n   * @param {number} column Visual column index to be \
moved.\n   * @param {number} finalIndex Visual column index, being a start \
index for the moved columns. Points to where the elements will be placed \
after the moving action.\n   * To check the visualization of the final index, \
please take a look at \
[documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-ma\
nualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires \
Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  moveColumn(column, \
finalIndex) {\n    return this.moveColumns([column], finalIndex);\n  }\n  \
/**\n   * Moves a multiple columns.\n   *\n   * @param {Array} columns Array \
of visual column indexes to be moved.\n   * @param {number} finalIndex Visual \
column index, being a start index for the moved columns. Points to where the \
elements will be placed after the moving action.\n   * To check the \
visualization of the final index, please take a look at \
[documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-ma\
nualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires \
Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  moveColumns(columns, \
finalIndex) {\n    const priv = privatePool15.get(this);\n    const dropIndex \
= priv.cachedDropIndex;\n    const movePossible = \
this.isMovePossible(columns, finalIndex);\n    const beforeMoveHook = \
this.hot.runHooks(\"beforeColumnMove\", columns, finalIndex, dropIndex, \
movePossible);\n    priv.cachedDropIndex = void 0;\n    if (beforeMoveHook \
=== false) {\n      return;\n    }\n    if (movePossible) {\n      \
this.hot.columnIndexMapper.moveIndexes(columns, finalIndex);\n    }\n    \
const movePerformed = movePossible && this.isColumnOrderChanged(columns, \
finalIndex);\n    this.hot.runHooks(\"afterColumnMove\", columns, finalIndex, \
dropIndex, movePossible, movePerformed);\n    return movePerformed;\n  }\n  \
/**\n   * Drag a single column to drop index position.\n   *\n   * @param \
{number} column Visual column index to be dragged.\n   * @param {number} \
dropIndex Visual column index, being a drop index for the moved columns. \
Points to where we are going to drop the moved elements.\n   * To check \
visualization of drop index please take a look at \
[documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-ma\
nualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires \
Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  dragColumn(column, \
dropIndex) {\n    return this.dragColumns([column], dropIndex);\n  }\n  /**\n \
  * Drag multiple columns to drop index position.\n   *\n   * @param {Array} \
columns Array of visual column indexes to be dragged.\n   * @param {number} \
dropIndex Visual column index, being a drop index for the moved columns. \
Points to where we are going to drop the moved elements.\n   * To check \
visualization of drop index please take a look at \
[documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-ma\
nualcolumnmove-plugin).\n   * @fires Hooks#beforeColumnMove\n   * @fires \
Hooks#afterColumnMove\n   * @returns {boolean}\n   */\n  dragColumns(columns, \
dropIndex) {\n    const finalIndex = this.countFinalIndex(columns, \
dropIndex);\n    const priv = privatePool15.get(this);\n    \
priv.cachedDropIndex = dropIndex;\n    return this.moveColumns(columns, \
finalIndex);\n  }\n  /**\n   * Indicates if it's possible to move columns to \
the desired position. Some of the actions aren't\n   * possible, i.e. You \
can\[AHat]\200\231t move more than one element to the last position.\n   *\n  \
 * @param {Array} movedColumns Array of visual column indexes to be moved.\n  \
 * @param {number} finalIndex Visual column index, being a start index for \
the moved columns. Points to where the elements will be placed after the \
moving action.\n   * To check the visualization of the final index, please \
take a look at \
[documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-ma\
nualcolumnmove-plugin).\n   * @returns {boolean}\n   */\n  \
isMovePossible(movedColumns, finalIndex) {\n    const length = \
this.hot.columnIndexMapper.getNotTrimmedIndexesLength();\n    const \
tooHighDestinationIndex = movedColumns.length + finalIndex > length;\n    \
const tooLowDestinationIndex = finalIndex < 0;\n    const \
tooLowMovedColumnIndex = movedColumns.some((movedColumn) => movedColumn < \
0);\n    const tooHighMovedColumnIndex = movedColumns.some((movedColumn) => \
movedColumn >= length);\n    if (tooHighDestinationIndex || \
tooLowDestinationIndex || tooLowMovedColumnIndex || tooHighMovedColumnIndex) \
{\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Indicates \
if order of columns was changed.\n   *\n   * @private\n   * @param {Array} \
movedColumns Array of visual column indexes to be moved.\n   * @param \
{number} finalIndex Visual column index, being a start index for the moved \
columns. Points to where the elements will be placed after the moving \
action.\n   * To check the visualization of the final index, please take a \
look at \
[documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-ma\
nualcolumnmove-plugin).\n   * @returns {boolean}\n   */\n  \
isColumnOrderChanged(movedColumns, finalIndex) {\n    return \
movedColumns.some((column, nrOfMovedElement) => column - nrOfMovedElement !== \
finalIndex);\n  }\n  /**\n   * Count the final column index from the drop \
index.\n   *\n   * @private\n   * @param {Array} movedColumns Array of visual \
column indexes to be moved.\n   * @param {number} dropIndex Visual column \
index, being a drop index for the moved columns.\n   * @returns {number} \
Visual column index, being a start index for the moved columns.\n   */\n  \
countFinalIndex(movedColumns, dropIndex) {\n    const \
numberOfColumnsLowerThanDropIndex = arrayReduce(movedColumns, \
(numberOfColumns, currentColumnIndex) => {\n      if (currentColumnIndex < \
dropIndex) {\n        numberOfColumns += 1;\n      }\n      return \
numberOfColumns;\n    }, 0);\n    return dropIndex - \
numberOfColumnsLowerThanDropIndex;\n  }\n  /**\n   * Gets the sum of the \
widths of columns in the provided range.\n   *\n   * @private\n   * @param \
{number} fromColumn Visual column index.\n   * @param {number} toColumn \
Visual column index.\n   * @returns {number}\n   */\n  \
getColumnsWidth(fromColumn, toColumn) {\n    const columnMapper = \
this.hot.columnIndexMapper;\n    let columnsWidth = 0;\n    for (let \
visualColumnIndex = fromColumn; visualColumnIndex <= toColumn; \
visualColumnIndex += 1) {\n      const renderableIndex = \
columnMapper.getRenderableFromVisualIndex(visualColumnIndex);\n      if \
(visualColumnIndex < 0) {\n        columnsWidth += \
this.hot.view._wt.wtViewport.getRowHeaderWidth() || 0;\n      } else if \
(renderableIndex !== null) {\n        columnsWidth += \
this.hot.view._wt.wtTable.getStretchedColumnWidth(renderableIndex) || 0;\n    \
  }\n    }\n    return columnsWidth;\n  }\n  /**\n   * Loads initial settings \
when persistent state is saved or when plugin was initialized as an array.\n  \
 *\n   * @private\n   */\n  moveBySettingsOrLoad() {\n    const \
pluginSettings = this.hot.getSettings()[PLUGIN_KEY21];\n    if \
(Array.isArray(pluginSettings)) {\n      this.moveColumns(pluginSettings, \
0);\n    } else if (pluginSettings !== void 0) {\n      const persistentState \
= this.persistentStateLoad();\n      if (persistentState.length) {\n        \
this.moveColumns(persistentState, 0);\n      }\n    }\n  }\n  /**\n   * \
Checks if the provided column is in the fixedColumnsTop section.\n   *\n   * \
@private\n   * @param {number} column Visual column index to check.\n   * \
@returns {boolean}\n   */\n  isFixedColumnsStart(column) {\n    return column \
< this.hot.getSettings().fixedColumnsStart;\n  }\n  /**\n   * Saves the \
manual column positions to the persistent state (the {@link \
Options#persistentState} option has to be enabled).\n   *\n   * @private\n   \
* @fires Hooks#persistentStateSave\n   */\n  persistentStateSave() {\n    \
this.hot.runHooks(\"persistentStateSave\", \"manualColumnMove\", \
this.hot.columnIndexMapper.getIndexesSequence());\n  }\n  /**\n   * Loads the \
manual column positions from the persistent state (the {@link \
Options#persistentState} option has to be enabled).\n   *\n   * @private\n   \
* @fires Hooks#persistentStateLoad\n   * @returns {Array} Stored state.\n   \
*/\n  persistentStateLoad() {\n    const storedState = {};\n    \
this.hot.runHooks(\"persistentStateLoad\", \"manualColumnMove\", \
storedState);\n    return storedState.value ? storedState.value : [];\n  }\n  \
/**\n   * Prepares an array of indexes based on actual selection.\n   *\n   * \
@private\n   * @param {number} start The start index.\n   * @param {number} \
end The end index.\n   * @returns {Array}\n   */\n  \
prepareColumnsToMoving(start, end) {\n    const selectedColumns = [];\n    \
rangeEach(start, end, (i) => {\n      selectedColumns.push(i);\n    });\n    \
return selectedColumns;\n  }\n  /**\n   * Update the UI visual position.\n   \
*\n   * @private\n   */\n  refreshPositions() {\n    const priv = \
privatePool15.get(this);\n    const firstVisible = \
this.hot.view.getFirstFullyVisibleColumn();\n    if \
(this.isFixedColumnsStart(priv.hoveredColumn) && firstVisible > 0) {\n      \
this.hot.scrollViewportTo(void 0, \
this.hot.columnIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));\n \
   }\n    const wtTable = this.hot.view._wt.wtTable;\n    const \
scrollableElement = this.hot.view._wt.wtOverlays.scrollableElement;\n    \
const scrollStart = typeof scrollableElement.scrollX === \"number\" ? \
scrollableElement.scrollX : scrollableElement.scrollLeft;\n    let \
tdOffsetStart = this.hot.view.THEAD.offsetLeft + this.getColumnsWidth(0, \
priv.hoveredColumn - 1);\n    const hiderWidth = wtTable.hider.offsetWidth;\n \
   const tbodyOffsetLeft = wtTable.TBODY.offsetLeft;\n    const \
backlightElemMarginStart = this.backlight.getOffset().start;\n    const \
backlightElemWidth = this.backlight.getSize().width;\n    let rowHeaderWidth \
= 0;\n    let mouseOffsetStart = 0;\n    if (this.hot.isRtl()) {\n      const \
rootWindow = this.hot.rootWindow;\n      const containerWidth = \
outerWidth(this.hot.rootElement);\n      const gridMostRightPos = \
rootWindow.innerWidth - priv.rootElementOffset - containerWidth;\n      \
mouseOffsetStart = rootWindow.innerWidth - priv.target.eventPageX - \
gridMostRightPos - (scrollableElement.scrollX === void 0 ? scrollStart : \
0);\n    } else {\n      mouseOffsetStart = priv.target.eventPageX - \
(priv.rootElementOffset - (scrollableElement.scrollX === void 0 ? scrollStart \
: 0));\n    }\n    if (priv.hasRowHeaders) {\n      rowHeaderWidth = \
this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.wtTable.getColumnHeader\
(-1).offsetWidth;\n    }\n    if \
(this.isFixedColumnsStart(priv.hoveredColumn)) {\n      tdOffsetStart += \
scrollStart;\n    }\n    tdOffsetStart += rowHeaderWidth;\n    if \
(priv.hoveredColumn < 0) {\n      if (priv.fixedColumnsStart > 0) {\n        \
priv.target.col = 0;\n      } else {\n        priv.target.col = firstVisible \
> 0 ? firstVisible - 1 : firstVisible;\n      }\n    } else if \
(priv.target.TD.offsetWidth / 2 + tdOffsetStart <= mouseOffsetStart) {\n      \
const newCoordsCol = priv.hoveredColumn >= priv.countCols ? priv.countCols - \
1 : priv.hoveredColumn;\n      priv.target.col = newCoordsCol + 1;\n      \
tdOffsetStart += priv.target.TD.offsetWidth;\n    } else {\n      \
priv.target.col = priv.hoveredColumn;\n    }\n    let backlightStart = \
mouseOffsetStart;\n    let guidelineStart = tdOffsetStart;\n    if \
(mouseOffsetStart + backlightElemWidth + backlightElemMarginStart >= \
hiderWidth) {\n      backlightStart = hiderWidth - backlightElemWidth - \
backlightElemMarginStart;\n    } else if (mouseOffsetStart + \
backlightElemMarginStart < tbodyOffsetLeft + rowHeaderWidth) {\n      \
backlightStart = tbodyOffsetLeft + rowHeaderWidth + \
Math.abs(backlightElemMarginStart);\n    }\n    if (tdOffsetStart >= \
hiderWidth - 1) {\n      guidelineStart = hiderWidth - 1;\n    } else if \
(guidelineStart === 0) {\n      guidelineStart = 1;\n    } else if \
(scrollableElement.scrollX !== void 0 && priv.hoveredColumn < \
priv.fixedColumnsStart) {\n      guidelineStart -= priv.rootElementOffset <= \
scrollableElement.scrollX ? priv.rootElementOffset : 0;\n    }\n    \
this.backlight.setPosition(null, backlightStart);\n    \
this.guideline.setPosition(null, guidelineStart);\n  }\n  /**\n   * Binds the \
events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() \
{\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    \
this.eventManager.addEventListener(documentElement, \"mousemove\", (event2) \
=> this.onMouseMove(event2));\n    \
this.eventManager.addEventListener(documentElement, \"mouseup\", () => \
this.onMouseUp());\n  }\n  /**\n   * Unbinds the events used by the plugin.\n \
  *\n   * @private\n   */\n  unregisterEvents() {\n    \
this.eventManager.clear();\n  }\n  /**\n   * Change the behavior of selection \
/ dragging.\n   *\n   * @private\n   * @param {MouseEvent} event `mousedown` \
event properties.\n   * @param {CellCoords} coords Visual cell coordinates \
where was fired event.\n   * @param {HTMLElement} TD Cell represented as \
HTMLElement.\n   * @param {object} controller An object with properties \
`row`, `column` and `cell`. Each property contains\n   *                      \
      a boolean value that allows or disallows changing the selection for \
that particular area.\n   */\n  onBeforeOnCellMouseDown(event2, coords, TD, \
controller) {\n    const wtTable = this.hot.view._wt.wtTable;\n    const \
isHeaderSelection = this.hot.selection.isSelectedByColumnHeader();\n    const \
selection = this.hot.getSelectedRangeLast();\n    const priv = \
privatePool15.get(this);\n    const isSortingElement = \
hasClass(event2.target, \"sortAction\");\n    if (!selection || \
!isHeaderSelection || priv.pressed || event2.button !== 0 || \
isSortingElement) {\n      priv.pressed = false;\n      \
priv.columnsToMove.length = 0;\n      removeClass(this.hot.rootElement, \
[CSS_ON_MOVING, CSS_SHOW_UI]);\n      return;\n    }\n    const \
guidelineIsNotReady = this.guideline.isBuilt() && \
!this.guideline.isAppended();\n    const backlightIsNotReady = \
this.backlight.isBuilt() && !this.backlight.isAppended();\n    if \
(guidelineIsNotReady && backlightIsNotReady) {\n      \
this.guideline.appendTo(wtTable.hider);\n      \
this.backlight.appendTo(wtTable.hider);\n    }\n    const {\n      from,\n    \
  to\n    } = selection;\n    const start = Math.min(from.col, to.col);\n    \
const end = Math.max(from.col, to.col);\n    if (coords.row < 0 && coords.col \
>= start && coords.col <= end) {\n      controller.column = true;\n      \
priv.pressed = true;\n      priv.target.eventPageX = event2.pageX;\n      \
priv.target.eventOffsetX = event2.offsetX;\n      priv.hoveredColumn = \
coords.col;\n      priv.target.TD = TD;\n      priv.target.col = \
coords.col;\n      priv.columnsToMove = this.prepareColumnsToMoving(start, \
end);\n      priv.hasRowHeaders = !!this.hot.getSettings().rowHeaders;\n      \
priv.countCols = this.hot.countCols();\n      priv.fixedColumnsStart = \
this.hot.getSettings().fixedColumnsStart;\n      priv.rootElementOffset = \
offset(this.hot.rootElement).left;\n      const countColumnsFrom = \
priv.hasRowHeaders ? -1 : 0;\n      const topPos = wtTable.holder.scrollTop + \
wtTable.getColumnHeaderHeight(0) + 1;\n      const fixedColumnsStart = \
coords.col < priv.fixedColumnsStart;\n      const horizontalScrollPosition = \
Math.abs(this.hot.view._wt.wtOverlays.inlineStartOverlay.getScrollPosition())\
;\n      const offsetX = Math.abs(event2.offsetX - (this.hot.isRtl() ? \
event2.target.offsetWidth : 0));\n      const inlineOffset = \
this.getColumnsWidth(start, coords.col - 1) + offsetX;\n      const inlinePos \
= this.getColumnsWidth(countColumnsFrom, start - 1) + (fixedColumnsStart ? \
horizontalScrollPosition : 0) + inlineOffset;\n      \
this.backlight.setPosition(topPos, inlinePos);\n      \
this.backlight.setSize(this.getColumnsWidth(start, end), \
wtTable.hider.offsetHeight - topPos);\n      this.backlight.setOffset(null, \
-inlineOffset);\n      addClass(this.hot.rootElement, CSS_ON_MOVING);\n    } \
else {\n      removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n      \
priv.pressed = false;\n      priv.columnsToMove.length = 0;\n    }\n  }\n  \
/**\n   * 'mouseMove' event callback. Fired when pointer move on \
document.documentElement.\n   *\n   * @private\n   * @param {MouseEvent} \
event `mousemove` event properties.\n   */\n  onMouseMove(event2) {\n    \
const priv = privatePool15.get(this);\n    if (!priv.pressed) {\n      \
return;\n    }\n    if (event2.target === this.backlight.element) {\n      \
const width = this.backlight.getSize().width;\n      \
this.backlight.setSize(0);\n      setTimeout(function() {\n        \
this.backlight.setPosition(width);\n      });\n    }\n    \
priv.target.eventPageX = event2.pageX;\n    this.refreshPositions();\n  }\n  \
/**\n   * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over \
cell.\n   *\n   * @private\n   * @param {MouseEvent} event `mouseover` event \
properties.\n   * @param {CellCoords} coords Visual cell coordinates where \
was fired event.\n   * @param {HTMLElement} TD Cell represented as \
HTMLElement.\n   * @param {object} controller An object with properties \
`row`, `column` and `cell`. Each property contains\n   *                      \
      a boolean value that allows or disallows changing the selection for \
that particular area.\n   */\n  onBeforeOnCellMouseOver(event2, coords, TD, \
controller) {\n    const selectedRange = this.hot.getSelectedRangeLast();\n   \
 const priv = privatePool15.get(this);\n    if (!selectedRange || \
!priv.pressed) {\n      return;\n    }\n    if \
(priv.columnsToMove.indexOf(coords.col) > -1) {\n      \
removeClass(this.hot.rootElement, CSS_SHOW_UI);\n    } else {\n      \
addClass(this.hot.rootElement, CSS_SHOW_UI);\n    }\n    controller.row = \
true;\n    controller.column = true;\n    controller.cell = true;\n    \
priv.hoveredColumn = coords.col;\n    priv.target.TD = TD;\n  }\n  /**\n   * \
`onMouseUp` hook callback.\n   *\n   * @private\n   */\n  onMouseUp() {\n    \
const priv = privatePool15.get(this);\n    const target = priv.target.col;\n  \
  const columnsLen = priv.columnsToMove.length;\n    priv.hoveredColumn = \
void 0;\n    priv.pressed = false;\n    priv.backlightWidth = 0;\n    \
removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, \
CSS_AFTER_SELECTION]);\n    if \
(this.hot.selection.isSelectedByColumnHeader()) {\n      \
addClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n    }\n    if \
(columnsLen < 1 || target === void 0) {\n      return;\n    }\n    const \
firstMovedVisualColumn = priv.columnsToMove[0];\n    const \
firstMovedPhysicalColumn = \
this.hot.toPhysicalColumn(firstMovedVisualColumn);\n    const movePerformed = \
this.dragColumns(priv.columnsToMove, target);\n    priv.columnsToMove.length \
= 0;\n    if (movePerformed === true) {\n      this.persistentStateSave();\n  \
    this.hot.render();\n      this.hot.view.adjustElementsSize(true);\n      \
const selectionStart = this.hot.toVisualColumn(firstMovedPhysicalColumn);\n   \
   const selectionEnd = selectionStart + columnsLen - 1;\n      \
this.hot.selectColumns(selectionStart, selectionEnd);\n    }\n  }\n  /**\n   \
* `afterScrollHorizontally` hook callback. Fired the table was scrolled \
horizontally.\n   *\n   * @private\n   */\n  onAfterScrollVertically() {\n    \
const wtTable = this.hot.view._wt.wtTable;\n    const headerHeight = \
wtTable.getColumnHeaderHeight(0) + 1;\n    const scrollTop = \
wtTable.holder.scrollTop;\n    const posTop = headerHeight + scrollTop;\n    \
this.backlight.setPosition(posTop);\n    this.backlight.setSize(null, \
wtTable.hider.offsetHeight - posTop);\n  }\n  /**\n   * Builds the plugin's \
UI.\n   *\n   * @private\n   */\n  buildPluginUI() {\n    \
this.backlight.build();\n    this.guideline.build();\n  }\n  /**\n   * \
Callback for the `afterLoadData` hook.\n   *\n   * @private\n   */\n  \
onAfterLoadData() {\n    this.moveBySettingsOrLoad();\n  }\n  /**\n   * \
Destroys the plugin instance.\n   */\n  destroy() {\n    \
this.backlight.destroy();\n    this.guideline.destroy();\n    \
super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/manualColumnResize/manualColumnResize.mjs\n\
var PLUGIN_KEY22 = \"manualColumnResize\";\nvar PLUGIN_PRIORITY21 = 130;\nvar \
PERSISTENT_STATE_KEY = \"manualColumnWidths\";\nvar privatePool16 = /* \
@__PURE__ */ new WeakMap();\nvar ManualColumnResize = class extends \
BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY22;\n  }\n  \
static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY21;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    const {\n      \
rootDocument\n    } = this.hot;\n    this.currentTH = null;\n    \
this.currentCol = null;\n    this.selectedCols = [];\n    this.currentWidth = \
null;\n    this.newSize = null;\n    this.startY = null;\n    this.startWidth \
= null;\n    this.startOffset = null;\n    this.handle = \
rootDocument.createElement(\"DIV\");\n    this.guide = \
rootDocument.createElement(\"DIV\");\n    this.eventManager = new \
eventManager_default(this);\n    this.pressed = null;\n    \
this.isTriggeredByRMB = false;\n    this.dblclick = 0;\n    \
this.autoresizeTimeout = null;\n    this.columnWidthsMap = void 0;\n    \
privatePool16.set(this, {\n      config: void 0\n    });\n    \
addClass(this.handle, \"manualColumnResizer\");\n    addClass(this.guide, \
\"manualColumnResizerGuide\");\n  }\n  /**\n   * @private\n   * @returns \
{string}\n   */\n  get inlineDir() {\n    return this.hot.isRtl() ? \"right\" \
: \"left\";\n  }\n  /**\n   * Checks if the plugin is enabled in the \
handsontable settings. This method is executed in {@link Hooks#beforeInit}\n  \
 * hook and if it returns `true` then the {@link \
ManualColumnResize#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
this.hot.getSettings()[PLUGIN_KEY22];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
if (this.enabled) {\n      return;\n    }\n    this.columnWidthsMap = new \
PhysicalIndexToValueMap();\n    this.columnWidthsMap.addLocalHook(\"init\", \
() => this.onMapInit());\n    \
this.hot.columnIndexMapper.registerMap(this.pluginName, \
this.columnWidthsMap);\n    this.addHook(\"modifyColWidth\", (width, col) => \
this.onModifyColWidth(width, col));\n    \
this.addHook(\"beforeStretchingColumnWidth\", (stretchedWidth, column) => \
this.onBeforeStretchingColumnWidth(stretchedWidth, column));\n    \
this.addHook(\"beforeColumnResize\", (newSize, column, isDoubleClick) => \
this.onBeforeColumnResize(newSize, column, isDoubleClick));\n    \
this.bindEvents();\n    super.enablePlugin();\n  }\n  /**\n   * Updates the \
plugin's state.\n   *\n   * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`manualColumnResize`](@/api/options.md#manualcolumnresize)\n   */\n  \
updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    \
super.updatePlugin();\n  }\n  /**\n   * Disables the plugin functionality for \
this Handsontable instance.\n   */\n  disablePlugin() {\n    const priv = \
privatePool16.get(this);\n    priv.config = \
this.columnWidthsMap.getValues();\n    \
this.hot.columnIndexMapper.unregisterMap(this.pluginName);\n    \
super.disablePlugin();\n  }\n  /**\n   * Saves the current sizes using the \
persistentState plugin (the {@link Options#persistentState} option has to be \
enabled).\n   *\n   * @fires Hooks#persistentStateSave\n   */\n  \
saveManualColumnWidths() {\n    this.hot.runHooks(\"persistentStateSave\", \
PERSISTENT_STATE_KEY, this.columnWidthsMap.getValues());\n  }\n  /**\n   * \
Loads the previously saved sizes using the persistentState plugin (the {@link \
Options#persistentState} option has to be enabled).\n   *\n   * @returns \
{Array}\n   * @fires Hooks#persistentStateLoad\n   */\n  \
loadManualColumnWidths() {\n    const storedState = {};\n    \
this.hot.runHooks(\"persistentStateLoad\", PERSISTENT_STATE_KEY, \
storedState);\n    return storedState.value;\n  }\n  /**\n   * Sets the new \
width for specified column index.\n   *\n   * @param {number} column Visual \
column index.\n   * @param {number} width Column width (no less than 20px).\n \
  * @returns {number} Returns new width.\n   */\n  setManualSize(column, \
width) {\n    const newWidth = Math.max(width, 20);\n    const physicalColumn \
= this.hot.toPhysicalColumn(column);\n    \
this.columnWidthsMap.setValueAtIndex(physicalColumn, newWidth);\n    return \
newWidth;\n  }\n  /**\n   * Clears the cache for the specified column \
index.\n   *\n   * @param {number} column Visual column index.\n   */\n  \
clearManualSize(column) {\n    const physicalColumn = \
this.hot.toPhysicalColumn(column);\n    \
this.columnWidthsMap.setValueAtIndex(physicalColumn, null);\n  }\n  /**\n   * \
Callback to call on map's `init` local hook.\n   *\n   * @private\n   */\n  \
onMapInit() {\n    const priv = privatePool16.get(this);\n    const \
initialSetting = this.hot.getSettings()[PLUGIN_KEY22];\n    const \
loadedManualColumnWidths = this.loadManualColumnWidths();\n    if (typeof \
loadedManualColumnWidths !== \"undefined\") {\n      \
this.hot.batchExecution(() => {\n        \
loadedManualColumnWidths.forEach((width, physicalIndex) => {\n          \
this.columnWidthsMap.setValueAtIndex(physicalIndex, width);\n        });\n    \
  }, true);\n    } else if (Array.isArray(initialSetting)) {\n      \
this.hot.batchExecution(() => {\n        initialSetting.forEach((width, \
physicalIndex) => {\n          \
this.columnWidthsMap.setValueAtIndex(physicalIndex, width);\n        });\n    \
  }, true);\n      priv.config = initialSetting;\n    } else if \
(initialSetting === true && Array.isArray(priv.config)) {\n      \
this.hot.batchExecution(() => {\n        priv.config.forEach((width, \
physicalIndex) => {\n          \
this.columnWidthsMap.setValueAtIndex(physicalIndex, width);\n        });\n    \
  }, true);\n    }\n  }\n  /**\n   * Set the resize handle position.\n   *\n  \
 * @private\n   * @param {HTMLCellElement} TH TH HTML element.\n   */\n  \
setupHandlePosition(TH) {\n    if (!TH.parentNode) {\n      return;\n    }\n  \
  this.currentTH = TH;\n    const {\n      _wt: wt\n    } = this.hot.view;\n  \
  const cellCoords = wt.wtTable.getCoords(this.currentTH);\n    const col = \
cellCoords.col;\n    if (col < 0) {\n      return;\n    }\n    const \
headerHeight = outerHeight(this.currentTH);\n    const box = \
this.currentTH.getBoundingClientRect();\n    const fixedColumn = col < \
wt.getSetting(\"fixedColumnsStart\");\n    let relativeHeaderPosition;\n    \
if (fixedColumn) {\n      relativeHeaderPosition = \
wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(this.curren\
tTH, cellCoords.row, cellCoords.col);\n    }\n    if \
(!relativeHeaderPosition) {\n      relativeHeaderPosition = \
wt.wtOverlays.topOverlay.getRelativeCellPosition(this.currentTH, \
cellCoords.row, cellCoords.col);\n    }\n    this.currentCol = \
this.hot.columnIndexMapper.getVisualFromRenderableIndex(col);\n    \
this.selectedCols = [];\n    const isFullColumnSelected = \
this.hot.selection.isSelectedByCorner() || \
this.hot.selection.isSelectedByColumnHeader();\n    if \
(this.hot.selection.isSelected() && isFullColumnSelected) {\n      const \
selectionRanges = this.hot.getSelectedRange();\n      \
arrayEach(selectionRanges, (selectionRange) => {\n        const fromColumn = \
selectionRange.getTopStartCorner().col;\n        const toColumn = \
selectionRange.getBottomEndCorner().col;\n        rangeEach(fromColumn, \
toColumn, (columnIndex) => {\n          if \
(!this.selectedCols.includes(columnIndex)) {\n            \
this.selectedCols.push(columnIndex);\n          }\n        });\n      });\n   \
 }\n    if (!this.selectedCols.includes(this.currentCol)) {\n      \
this.selectedCols = [this.currentCol];\n    }\n    this.startOffset = \
relativeHeaderPosition.start - 6;\n    this.startWidth = parseInt(box.width, \
10);\n    this.handle.style.top = `${relativeHeaderPosition.top}px`;\n    \
this.handle.style[this.inlineDir] = `${this.startOffset + \
this.startWidth}px`;\n    this.handle.style.height = `${headerHeight}px`;\n   \
 this.hot.rootElement.appendChild(this.handle);\n  }\n  /**\n   * Refresh the \
resize handle position.\n   *\n   * @private\n   */\n  \
refreshHandlePosition() {\n    this.handle.style[this.inlineDir] = \
`${this.startOffset + this.currentWidth}px`;\n  }\n  /**\n   * Sets the \
resize guide position.\n   *\n   * @private\n   */\n  setupGuidePosition() \
{\n    const handleHeight = parseInt(outerHeight(this.handle), 10);\n    \
const handleBottomPosition = parseInt(this.handle.style.top, 10) + \
handleHeight;\n    const maximumVisibleElementHeight = \
parseInt(this.hot.view.maximumVisibleElementHeight(0), 10);\n    \
addClass(this.handle, \"active\");\n    addClass(this.guide, \"active\");\n   \
 this.guide.style.top = `${handleBottomPosition}px`;\n    \
this.refreshGuidePosition();\n    this.guide.style.height = \
`${maximumVisibleElementHeight - handleHeight}px`;\n    \
this.hot.rootElement.appendChild(this.guide);\n  }\n  /**\n   * Refresh the \
resize guide position.\n   *\n   * @private\n   */\n  refreshGuidePosition() \
{\n    this.guide.style[this.inlineDir] = \
this.handle.style[this.inlineDir];\n  }\n  /**\n   * Hides both the resize \
handle and resize guide.\n   *\n   * @private\n   */\n  hideHandleAndGuide() \
{\n    removeClass(this.handle, \"active\");\n    removeClass(this.guide, \
\"active\");\n  }\n  /**\n   * Checks if provided element is considered a \
column header.\n   *\n   * @private\n   * @param {HTMLElement} element HTML \
element.\n   * @returns {boolean}\n   */\n  checkIfColumnHeader(element) {\n  \
  return !!closest(element, [\"THEAD\"], this.hot.rootElement);\n  }\n  /**\n \
  * Gets the TH element from the provided element.\n   *\n   * @private\n   * \
@param {HTMLElement} element HTML element.\n   * @returns {HTMLElement}\n   \
*/\n  getClosestTHParent(element) {\n    if (element.tagName !== \"TABLE\") \
{\n      if (element.tagName === \"TH\") {\n        return element;\n      \
}\n      return this.getClosestTHParent(element.parentNode);\n    }\n    \
return null;\n  }\n  /**\n   * 'mouseover' event callback - set the handle \
position.\n   *\n   * @private\n   * @param {MouseEvent} event The mouse \
event.\n   */\n  onMouseOver(event2) {\n    if (isDetached(event2.target)) \
{\n      return;\n    }\n    if (this.isTriggeredByRMB === true) {\n      \
return;\n    }\n    if (this.checkIfColumnHeader(event2.target)) {\n      \
const th = this.getClosestTHParent(event2.target);\n      if (!th) {\n        \
return;\n      }\n      const colspan = th.getAttribute(\"colspan\");\n      \
if (th && (colspan === null || colspan === \"1\")) {\n        if \
(!this.pressed) {\n          this.setupHandlePosition(th);\n        }\n      \
}\n    }\n  }\n  /**\n   * Auto-size row after doubleclick - callback.\n   \
*\n   * @private\n   * @fires Hooks#beforeColumnResize\n   * @fires \
Hooks#afterColumnResize\n   */\n  afterMouseDownTimeout() {\n    const render \
= () => {\n      this.hot.forceFullRender = true;\n      \
this.hot.view.render();\n      this.hot.view.adjustElementsSize(true);\n    \
};\n    const resize = (column, forceRender) => {\n      const hookNewSize = \
this.hot.runHooks(\"beforeColumnResize\", this.newSize, column, true);\n      \
if (hookNewSize !== void 0) {\n        this.newSize = hookNewSize;\n      }\n \
     if (this.hot.getSettings().stretchH === \"all\") {\n        \
this.clearManualSize(column);\n      } else {\n        \
this.setManualSize(column, this.newSize);\n      }\n      \
this.saveManualColumnWidths();\n      \
this.hot.runHooks(\"afterColumnResize\", this.newSize, column, true);\n      \
if (forceRender) {\n        render();\n      }\n    };\n    if (this.dblclick \
>= 2) {\n      const selectedColsLength = this.selectedCols.length;\n      if \
(selectedColsLength > 1) {\n        arrayEach(this.selectedCols, \
(selectedCol) => {\n          resize(selectedCol);\n        });\n        \
render();\n      } else {\n        arrayEach(this.selectedCols, (selectedCol) \
=> {\n          resize(selectedCol, true);\n        });\n      }\n    }\n    \
this.dblclick = 0;\n    this.autoresizeTimeout = null;\n  }\n  /**\n   * \
'mousedown' event callback.\n   *\n   * @private\n   * @param {MouseEvent} \
event The mouse event.\n   */\n  onMouseDown(event2) {\n    if \
(hasClass(event2.target, \"manualColumnResizer\")) {\n      \
this.setupHandlePosition(this.currentTH);\n      this.setupGuidePosition();\n \
     this.pressed = true;\n      if (this.autoresizeTimeout === null) {\n     \
   this.autoresizeTimeout = setTimeout(() => this.afterMouseDownTimeout(), \
500);\n        this.hot._registerTimeout(this.autoresizeTimeout);\n      }\n  \
    this.dblclick += 1;\n      this.startX = event2.pageX;\n      \
this.newSize = this.startWidth;\n    }\n  }\n  /**\n   * 'mousemove' event \
callback - refresh the handle and guide positions, cache the new column \
width.\n   *\n   * @private\n   * @param {MouseEvent} event The mouse \
event.\n   */\n  onMouseMove(event2) {\n    if (this.pressed) {\n      const \
change = (event2.pageX - this.startX) * this.hot.getDirectionFactor();\n      \
this.currentWidth = this.startWidth + change;\n      \
arrayEach(this.selectedCols, (selectedCol) => {\n        this.newSize = \
this.setManualSize(selectedCol, this.currentWidth);\n      });\n      \
this.refreshHandlePosition();\n      this.refreshGuidePosition();\n    }\n  \
}\n  /**\n   * 'mouseup' event callback - apply the column resizing.\n   *\n  \
 * @private\n   *\n   * @fires Hooks#beforeColumnResize\n   * @fires \
Hooks#afterColumnResize\n   */\n  onMouseUp() {\n    const render = () => {\n \
     this.hot.forceFullRender = true;\n      this.hot.view.render();\n      \
this.hot.view.adjustElementsSize(true);\n    };\n    const resize = (column, \
forceRender) => {\n      this.hot.runHooks(\"beforeColumnResize\", \
this.newSize, column, false);\n      if (forceRender) {\n        render();\n  \
    }\n      this.saveManualColumnWidths();\n      \
this.hot.runHooks(\"afterColumnResize\", this.newSize, column, false);\n    \
};\n    if (this.pressed) {\n      this.hideHandleAndGuide();\n      \
this.pressed = false;\n      if (this.newSize !== this.startWidth) {\n        \
const selectedColsLength = this.selectedCols.length;\n        if \
(selectedColsLength > 1) {\n          arrayEach(this.selectedCols, \
(selectedCol) => {\n            resize(selectedCol);\n          });\n         \
 render();\n        } else {\n          arrayEach(this.selectedCols, \
(selectedCol) => {\n            resize(selectedCol, true);\n          });\n   \
     }\n      }\n      this.setupHandlePosition(this.currentTH);\n    }\n  \
}\n  /**\n   * Callback for \"contextmenu\" event triggered on element \
showing move handle. It removes handle and guide elements.\n   *\n   * \
@private\n   */\n  onContextMenu() {\n    this.hideHandleAndGuide();\n    \
this.hot.rootElement.removeChild(this.handle);\n    \
this.hot.rootElement.removeChild(this.guide);\n    this.pressed = false;\n    \
this.isTriggeredByRMB = true;\n    this.hot._registerImmediate(() => {\n      \
this.isTriggeredByRMB = false;\n    });\n  }\n  /**\n   * Binds the mouse \
events.\n   *\n   * @private\n   */\n  bindEvents() {\n    const {\n      \
rootWindow,\n      rootElement\n    } = this.hot;\n    \
this.eventManager.addEventListener(rootElement, \"mouseover\", (e) => \
this.onMouseOver(e));\n    this.eventManager.addEventListener(rootElement, \
\"mousedown\", (e) => this.onMouseDown(e));\n    \
this.eventManager.addEventListener(rootWindow, \"mousemove\", (e) => \
this.onMouseMove(e));\n    this.eventManager.addEventListener(rootWindow, \
\"mouseup\", () => this.onMouseUp());\n    \
this.eventManager.addEventListener(this.handle, \"contextmenu\", () => \
this.onContextMenu());\n  }\n  /**\n   * Modifies the provided column width, \
based on the plugin settings.\n   *\n   * @private\n   * @param {number} \
width Column width.\n   * @param {number} column Visual column index.\n   * \
@returns {number}\n   */\n  onModifyColWidth(width, column) {\n    let \
newWidth = width;\n    if (this.enabled) {\n      const physicalColumn = \
this.hot.toPhysicalColumn(column);\n      const columnWidth = \
this.columnWidthsMap.getValueAtIndex(physicalColumn);\n      if \
(this.hot.getSettings()[PLUGIN_KEY22] && columnWidth) {\n        newWidth = \
columnWidth;\n      }\n    }\n    return newWidth;\n  }\n  /**\n   * Modifies \
the provided column stretched width. This hook decides if specified column \
should be stretched or not.\n   *\n   * @private\n   * @param {number} \
stretchedWidth Stretched width.\n   * @param {number} column Visual column \
index.\n   * @returns {number}\n   */\n  \
onBeforeStretchingColumnWidth(stretchedWidth, column) {\n    let width = \
this.columnWidthsMap.getValueAtIndex(column);\n    if (width === null) {\n    \
  width = stretchedWidth;\n    }\n    return width;\n  }\n  /**\n   * \
`beforeColumnResize` hook callback.\n   *\n   * @private\n   */\n  \
onBeforeColumnResize() {\n    \
this.hot.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n  }\n  \
/**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    \
super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/manualRowMove/ui/_base.mjs\nvar \
STATE_INITIALIZED2 = 0;\nvar STATE_BUILT3 = 1;\nvar STATE_APPENDED2 = 2;\nvar \
UNIT2 = \"px\";\nvar BaseUI3 = class {\n  constructor(hotInstance) {\n    \
this.hot = hotInstance;\n    this._element = null;\n    this.state = \
STATE_INITIALIZED2;\n  }\n  /**\n   * Add created UI elements to table.\n   \
*\n   * @param {HTMLElement} wrapper Element which are parent for our UI \
element.\n   */\n  appendTo(wrapper) {\n    \
wrapper.appendChild(this._element);\n    this.state = STATE_APPENDED2;\n  }\n \
 /**\n   * Method for create UI element. Only create, without append to \
table.\n   */\n  build() {\n    if (this.state !== STATE_INITIALIZED2) {\n    \
  return;\n    }\n    this._element = \
this.hot.rootDocument.createElement(\"div\");\n    this.state = \
STATE_BUILT3;\n  }\n  /**\n   * Method for remove UI element.\n   */\n  \
destroy() {\n    if (this.isAppended()) {\n      \
this._element.parentElement.removeChild(this._element);\n    }\n    \
this._element = null;\n    this.state = STATE_INITIALIZED2;\n  }\n  /**\n   * \
Check if UI element are appended.\n   *\n   * @returns {boolean}\n   */\n  \
isAppended() {\n    return this.state === STATE_APPENDED2;\n  }\n  /**\n   * \
Check if UI element are built.\n   *\n   * @returns {boolean}\n   */\n  \
isBuilt() {\n    return this.state >= STATE_BUILT3;\n  }\n  /**\n   * Setter \
for position.\n   *\n   * @param {number} top New top position of the \
element.\n   * @param {number} left New left position of the element.\n   \
*/\n  setPosition(top2, left2) {\n    if (top2 !== void 0) {\n      \
this._element.style.top = top2 + UNIT2;\n    }\n    if (left2 !== void 0) {\n \
     this._element.style.left = left2 + UNIT2;\n    }\n  }\n  /**\n   * \
Getter for the element position.\n   *\n   * @returns {object} Object \
contains left and top position of the element.\n   */\n  getPosition() {\n    \
return {\n      top: this._element.style.top ? \
parseInt(this._element.style.top, 10) : 0,\n      left: \
this._element.style.left ? parseInt(this._element.style.left, 10) : 0\n    \
};\n  }\n  /**\n   * Setter for the element size.\n   *\n   * @param {number} \
width New width of the element.\n   * @param {number} height New height of \
the element.\n   */\n  setSize(width, height) {\n    if (width) {\n      \
this._element.style.width = width + UNIT2;\n    }\n    if (height) {\n      \
this._element.style.height = height + UNIT2;\n    }\n  }\n  /**\n   * Getter \
for the element position.\n   *\n   * @returns {object} Object contains \
height and width of the element.\n   */\n  getSize() {\n    return {\n      \
width: this._element.style.width ? parseInt(this._element.style.width, 10) : \
0,\n      height: this._element.style.height ? \
parseInt(this._element.style.height, 10) : 0\n    };\n  }\n  /**\n   * Setter \
for the element offset. Offset means marginTop and marginLeft of the \
element.\n   *\n   * @param {number} top New margin top of the element.\n   * \
@param {number} left New margin left of the element.\n   */\n  \
setOffset(top2, left2) {\n    if (top2) {\n      \
this._element.style.marginTop = top2 + UNIT2;\n    }\n    if (left2) {\n      \
this._element.style.marginLeft = left2 + UNIT2;\n    }\n  }\n  /**\n   * \
Getter for the element offset.\n   *\n   * @returns {object} Object contains \
top and left offset of the element.\n   */\n  getOffset() {\n    return {\n   \
   top: this._element.style.marginTop ? \
parseInt(this._element.style.marginTop, 10) : 0,\n      left: \
this._element.style.marginLeft ? parseInt(this._element.style.marginLeft, 10) \
: 0\n    };\n  }\n};\nvar base_default6 = BaseUI3;\n\n// \
node_modules/handsontable/plugins/manualRowMove/ui/backlight.mjs\nvar \
CSS_CLASSNAME3 = \"ht__manualRowMove--backlight\";\nvar BacklightUI2 = class \
extends base_default6 {\n  /**\n   * Custom className on build process.\n   \
*/\n  build() {\n    super.build();\n    addClass(this._element, \
CSS_CLASSNAME3);\n  }\n};\nvar backlight_default2 = BacklightUI2;\n\n// \
node_modules/handsontable/plugins/manualRowMove/ui/guideline.mjs\nvar \
CSS_CLASSNAME4 = \"ht__manualRowMove--guideline\";\nvar GuidelineUI2 = class \
extends base_default6 {\n  /**\n   * Custom className on build process.\n   \
*/\n  build() {\n    super.build();\n    addClass(this._element, \
CSS_CLASSNAME4);\n  }\n};\nvar guideline_default2 = GuidelineUI2;\n\n// \
node_modules/handsontable/plugins/manualRowMove/manualRowMove.mjs\npluginHook\
s_default.getSingleton().register(\"beforeRowMove\");\npluginHooks_default.ge\
tSingleton().register(\"afterRowMove\");\nvar PLUGIN_KEY23 = \
\"manualRowMove\";\nvar PLUGIN_PRIORITY22 = 140;\nvar privatePool17 = /* \
@__PURE__ */ new WeakMap();\nvar CSS_PLUGIN2 = \"ht__manualRowMove\";\nvar \
CSS_SHOW_UI2 = \"show-ui\";\nvar CSS_ON_MOVING2 = \"on-moving--rows\";\nvar \
CSS_AFTER_SELECTION2 = \"after-selection--rows\";\nvar ManualRowMove = class \
extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY23;\n \
 }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY22;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    \
privatePool17.set(this, {\n      rowsToMove: [],\n      pressed: void 0,\n    \
  target: {\n        eventPageY: void 0,\n        coords: void 0,\n        \
TD: void 0,\n        row: void 0\n      },\n      cachedDropIndex: void 0\n   \
 });\n    this.eventManager = new eventManager_default(this);\n    \
this.backlight = new backlight_default2(hotInstance);\n    this.guideline = \
new guideline_default2(hotInstance);\n  }\n  /**\n   * Checks if the plugin \
is enabled in the handsontable settings. This method is executed in {@link \
Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link \
ManualRowMove#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY23];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    \
this.addHook(\"beforeOnCellMouseDown\", function() {\n      return \
_this.onBeforeOnCellMouseDown(...arguments);\n    });\n    \
this.addHook(\"beforeOnCellMouseOver\", function() {\n      return \
_this.onBeforeOnCellMouseOver(...arguments);\n    });\n    \
this.addHook(\"afterScrollHorizontally\", () => \
this.onAfterScrollHorizontally());\n    this.addHook(\"afterLoadData\", \
function() {\n      return _this.onAfterLoadData(...arguments);\n    });\n    \
this.buildPluginUI();\n    this.registerEvents();\n    \
addClass(this.hot.rootElement, CSS_PLUGIN2);\n    super.enablePlugin();\n  \
}\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is \
executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked \
with any of the following configuration options:\n   *  - \
[`manualRowMove`](@/api/options.md#manualrowmove)\n   */\n  updatePlugin() \
{\n    this.disablePlugin();\n    this.enablePlugin();\n    \
this.moveBySettingsOrLoad();\n    super.updatePlugin();\n  }\n  /**\n   * \
Disables the plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    removeClass(this.hot.rootElement, CSS_PLUGIN2);\n    \
this.unregisterEvents();\n    this.backlight.destroy();\n    \
this.guideline.destroy();\n    super.disablePlugin();\n  }\n  /**\n   * Moves \
a single row.\n   *\n   * To see the outcome, rerender your grid by calling \
[`render()`](@/api/core.md#render).\n   *\n   * @param {number} row Visual \
row index to be moved.\n   * @param {number} finalIndex Visual row index, \
being a start index for the moved rows. Points to where the elements will be \
placed after the moving action.\n   * To check the visualization of the final \
index, please take a look at \
[documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualro\
wmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires \
Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRow(row, \
finalIndex) {\n    return this.moveRows([row], finalIndex);\n  }\n  /**\n   * \
Moves multiple rows.\n   *\n   * To see the outcome, rerender your grid by \
calling [`render()`](@/api/core.md#render).\n   *\n   * @param {Array} rows \
Array of visual row indexes to be moved.\n   * @param {number} finalIndex \
Visual row index, being a start index for the moved rows. Points to where the \
elements will be placed after the moving action.\n   * To check the \
visualization of the final index, please take a look at \
[documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualro\
wmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires \
Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRows(rows, \
finalIndex) {\n    const priv = privatePool17.get(this);\n    const dropIndex \
= priv.cachedDropIndex;\n    const movePossible = this.isMovePossible(rows, \
finalIndex);\n    const beforeMoveHook = this.hot.runHooks(\"beforeRowMove\", \
rows, finalIndex, dropIndex, movePossible);\n    priv.cachedDropIndex = void \
0;\n    if (beforeMoveHook === false) {\n      return;\n    }\n    if \
(movePossible) {\n      this.hot.rowIndexMapper.moveIndexes(rows, \
finalIndex);\n    }\n    const movePerformed = movePossible && \
this.isRowOrderChanged(rows, finalIndex);\n    \
this.hot.runHooks(\"afterRowMove\", rows, finalIndex, dropIndex, \
movePossible, movePerformed);\n    return movePerformed;\n  }\n  /**\n   * \
Drag a single row to drop index position.\n   *\n   * @param {number} row \
Visual row index to be dragged.\n   * @param {number} dropIndex Visual row \
index, being a drop index for the moved rows. Points to where we are going to \
drop the moved elements.\n   * To check visualization of drop index please \
take a look at \
[documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualro\
wmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires \
Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRow(row, dropIndex) \
{\n    return this.dragRows([row], dropIndex);\n  }\n  /**\n   * Drag \
multiple rows to drop index position.\n   *\n   * @param {Array} rows Array \
of visual row indexes to be dragged.\n   * @param {number} dropIndex Visual \
row index, being a drop index for the moved rows. Points to where we are \
going to drop the moved elements.\n   * To check visualization of drop index \
please take a look at \
[documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualro\
wmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires \
Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRows(rows, \
dropIndex) {\n    const finalIndex = this.countFinalIndex(rows, dropIndex);\n \
   const priv = privatePool17.get(this);\n    priv.cachedDropIndex = \
dropIndex;\n    return this.moveRows(rows, finalIndex);\n  }\n  /**\n   * \
Indicates if it's possible to move rows to the desired position. Some of the \
actions aren't possible, i.e. You can\[AHat]\200\231t move more than one \
element to the last position.\n   *\n   * @param {Array} movedRows Array of \
visual row indexes to be moved.\n   * @param {number} finalIndex Visual row \
index, being a start index for the moved rows. Points to where the elements \
will be placed after the moving action.\n   * To check the visualization of \
the final index, please take a look at \
[documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualro\
wmove-plugin).\n   * @returns {boolean}\n   */\n  isMovePossible(movedRows, \
finalIndex) {\n    const length = \
this.hot.rowIndexMapper.getNotTrimmedIndexesLength();\n    const \
tooHighDestinationIndex = movedRows.length + finalIndex > length;\n    const \
tooLowDestinationIndex = finalIndex < 0;\n    const tooLowMovedRowIndex = \
movedRows.some((movedRow) => movedRow < 0);\n    const tooHighMovedRowIndex = \
movedRows.some((movedRow) => movedRow >= length);\n    if \
(tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedRowIndex || \
tooHighMovedRowIndex) {\n      return false;\n    }\n    return true;\n  }\n  \
/**\n   * Indicates if order of rows was changed.\n   *\n   * @private\n   * \
@param {Array} movedRows Array of visual row indexes to be moved.\n   * \
@param {number} finalIndex Visual row index, being a start index for the \
moved rows. Points to where the elements will be placed after the moving \
action.\n   * To check the visualization of the final index, please take a \
look at \
[documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualro\
wmove-plugin).\n   * @returns {boolean}\n   */\n  \
isRowOrderChanged(movedRows, finalIndex) {\n    return movedRows.some((row, \
nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);\n  }\n  /**\n   \
* Count the final row index from the drop index.\n   *\n   * @private\n   * \
@param {Array} movedRows Array of visual row indexes to be moved.\n   * \
@param {number} dropIndex Visual row index, being a drop index for the moved \
rows.\n   * @returns {number} Visual row index, being a start index for the \
moved rows.\n   */\n  countFinalIndex(movedRows, dropIndex) {\n    const \
numberOfRowsLowerThanDropIndex = arrayReduce(movedRows, (numberOfRows, \
currentRowIndex) => {\n      if (currentRowIndex < dropIndex) {\n        \
numberOfRows += 1;\n      }\n      return numberOfRows;\n    }, 0);\n    \
return dropIndex - numberOfRowsLowerThanDropIndex;\n  }\n  /**\n   * Gets the \
sum of the heights of rows in the provided range.\n   *\n   * @private\n   * \
@param {number} fromRow Visual row index.\n   * @param {number} toRow Visual \
row index.\n   * @returns {number}\n   */\n  getRowsHeight(fromRow, toRow) \
{\n    const rowMapper = this.hot.rowIndexMapper;\n    let rowsHeight = 0;\n  \
  for (let visualRowIndex = fromRow; visualRowIndex <= toRow; \
visualRowIndex++) {\n      const renderableIndex = \
rowMapper.getRenderableFromVisualIndex(visualRowIndex);\n      if \
(renderableIndex !== null) {\n        rowsHeight += \
this.hot.view._wt.wtTable.getRowHeight(renderableIndex) || 23;\n      }\n    \
}\n    return rowsHeight;\n  }\n  /**\n   * Loads initial settings when \
persistent state is saved or when plugin was initialized as an array.\n   *\n \
  * @private\n   */\n  moveBySettingsOrLoad() {\n    const pluginSettings = \
this.hot.getSettings()[PLUGIN_KEY23];\n    if (Array.isArray(pluginSettings)) \
{\n      this.moveRows(pluginSettings, 0);\n    } else if (pluginSettings !== \
void 0) {\n      const persistentState = this.persistentStateLoad();\n      \
if (persistentState.length) {\n        this.moveRows(persistentState, 0);\n   \
   }\n    }\n  }\n  /**\n   * Checks if the provided row is in the \
fixedRowsTop section.\n   *\n   * @private\n   * @param {number} row Visual \
row index to check.\n   * @returns {boolean}\n   */\n  isFixedRowTop(row) {\n \
   return row < this.hot.getSettings().fixedRowsTop;\n  }\n  /**\n   * Checks \
if the provided row is in the fixedRowsBottom section.\n   *\n   * @private\n \
  * @param {number} row Visual row index to check.\n   * @returns {boolean}\n \
  */\n  isFixedRowBottom(row) {\n    return row > this.hot.countRows() - 1 - \
this.hot.getSettings().fixedRowsBottom;\n  }\n  /**\n   * Saves the manual \
row positions to the persistent state (the {@link Options#persistentState} \
option has to be enabled).\n   *\n   * @private\n   * @fires \
Hooks#persistentStateSave\n   */\n  persistentStateSave() {\n    \
this.hot.runHooks(\"persistentStateSave\", \"manualRowMove\", \
this.hot.rowIndexMapper.getIndexesSequence());\n  }\n  /**\n   * Loads the \
manual row positions from the persistent state (the {@link \
Options#persistentState} option has to be enabled).\n   *\n   * @private\n   \
* @fires Hooks#persistentStateLoad\n   * @returns {Array} Stored state.\n   \
*/\n  persistentStateLoad() {\n    const storedState = {};\n    \
this.hot.runHooks(\"persistentStateLoad\", \"manualRowMove\", storedState);\n \
   return storedState.value ? storedState.value : [];\n  }\n  /**\n   * \
Prepares an array of indexes based on actual selection.\n   *\n   * \
@private\n   * @returns {Array}\n   */\n  prepareRowsToMoving() {\n    const \
selection = this.hot.getSelectedRangeLast();\n    const selectedRows = [];\n  \
  if (!selection) {\n      return selectedRows;\n    }\n    const {\n      \
from,\n      to\n    } = selection;\n    const start = Math.min(from.row, \
to.row);\n    const end = Math.max(from.row, to.row);\n    rangeEach(start, \
end, (i) => {\n      selectedRows.push(i);\n    });\n    return \
selectedRows;\n  }\n  /**\n   * Update the UI visual position.\n   *\n   * \
@private\n   */\n  refreshPositions() {\n    const priv = \
privatePool17.get(this);\n    const coords = priv.target.coords;\n    const \
firstVisible = this.hot.view.getFirstFullyVisibleRow();\n    const \
lastVisible = this.hot.view.getLastFullyVisibleRow();\n    const countRows = \
this.hot.countRows();\n    if (this.isFixedRowTop(coords.row) && firstVisible \
> 0) {\n      \
this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(fi\
rstVisible - 1, -1));\n    }\n    if (this.isFixedRowBottom(coords.row) && \
lastVisible < countRows) {\n      \
this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(la\
stVisible + 1, 1), void 0, true);\n    }\n    const wtTable = \
this.hot.view._wt.wtTable;\n    const TD = priv.target.TD;\n    const \
rootElement = this.hot.rootElement;\n    const rootElementOffset = \
offset(rootElement);\n    const trimmingContainer = \
getTrimmingContainer(rootElement);\n    const tableScroll = \
wtTable.holder.scrollTop;\n    let trimmingContainerScroll;\n    if \
(this.hot.rootWindow === trimmingContainer) {\n      trimmingContainerScroll \
= trimmingContainer.scrollY;\n    } else {\n      trimmingContainerScroll = \
trimmingContainer.scrollTop;\n    }\n    const pixelsAbove = \
rootElementOffset.top - trimmingContainerScroll;\n    const \
pixelsRelToTableStart = priv.target.eventPageY - pixelsAbove + tableScroll;\n \
   const hiderHeight = wtTable.hider.offsetHeight;\n    const tbodyOffsetTop \
= wtTable.TBODY.offsetTop;\n    const backlightElemMarginTop = \
this.backlight.getOffset().top;\n    const backlightElemHeight = \
this.backlight.getSize().height;\n    const tdMiddle = TD.offsetHeight / 2;\n \
   const tdHeight = TD.offsetHeight;\n    let tdStartPixel = \
this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row - 1);\n   \
 const isBelowTable = pixelsRelToTableStart >= tdStartPixel + tdMiddle;\n    \
if (this.isFixedRowTop(coords.row)) {\n      tdStartPixel += \
wtTable.holder.scrollTop;\n    }\n    if (coords.row < 0) {\n      \
priv.target.row = firstVisible > 0 ? firstVisible - 1 : firstVisible;\n    } \
else if (isBelowTable) {\n      priv.target.row = coords.row + 1;\n      \
tdStartPixel += coords.row === 0 ? tdHeight - 1 : tdHeight;\n    } else {\n   \
   priv.target.row = coords.row;\n    }\n    let backlightTop = \
pixelsRelToTableStart;\n    let guidelineTop = tdStartPixel;\n    if \
(pixelsRelToTableStart + backlightElemHeight + backlightElemMarginTop >= \
hiderHeight) {\n      backlightTop = hiderHeight - backlightElemHeight - \
backlightElemMarginTop;\n    } else if (pixelsRelToTableStart + \
backlightElemMarginTop < tbodyOffsetTop) {\n      backlightTop = \
tbodyOffsetTop + Math.abs(backlightElemMarginTop);\n    }\n    if \
(tdStartPixel >= hiderHeight - 1) {\n      guidelineTop = hiderHeight - 1;\n  \
  }\n    this.backlight.setPosition(backlightTop);\n    \
this.guideline.setPosition(guidelineTop);\n  }\n  /**\n   * Binds the events \
used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    \
const {\n      documentElement\n    } = this.hot.rootDocument;\n    \
this.eventManager.addEventListener(documentElement, \"mousemove\", (event2) \
=> this.onMouseMove(event2));\n    \
this.eventManager.addEventListener(documentElement, \"mouseup\", () => \
this.onMouseUp());\n  }\n  /**\n   * Unbinds the events used by the plugin.\n \
  *\n   * @private\n   */\n  unregisterEvents() {\n    \
this.eventManager.clear();\n  }\n  /**\n   * Change the behavior of selection \
/ dragging.\n   *\n   * @private\n   * @param {MouseEvent} event `mousedown` \
event properties.\n   * @param {CellCoords} coords Visual cell coordinates \
where was fired event.\n   * @param {HTMLElement} TD Cell represented as \
HTMLElement.\n   * @param {object} controller An object with properties \
`row`, `column` and `cell`. Each property contains\n   *                      \
      a boolean value that allows or disallows changing the selection for \
that particular area.\n   */\n  onBeforeOnCellMouseDown(event2, coords, TD, \
controller) {\n    const {\n      wtTable,\n      wtViewport\n    } = \
this.hot.view._wt;\n    const isHeaderSelection = \
this.hot.selection.isSelectedByRowHeader();\n    const selection = \
this.hot.getSelectedRangeLast();\n    const priv = privatePool17.get(this);\n \
   if (!selection || !isHeaderSelection || priv.pressed || event2.button !== \
0) {\n      priv.pressed = false;\n      priv.rowsToMove.length = 0;\n      \
removeClass(this.hot.rootElement, [CSS_ON_MOVING2, CSS_SHOW_UI2]);\n      \
return;\n    }\n    const guidelineIsNotReady = this.guideline.isBuilt() && \
!this.guideline.isAppended();\n    const backlightIsNotReady = \
this.backlight.isBuilt() && !this.backlight.isAppended();\n    if \
(guidelineIsNotReady && backlightIsNotReady) {\n      \
this.guideline.appendTo(wtTable.hider);\n      \
this.backlight.appendTo(wtTable.hider);\n    }\n    const {\n      from,\n    \
  to\n    } = selection;\n    const start = Math.min(from.row, to.row);\n    \
const end = Math.max(from.row, to.row);\n    if (coords.col < 0 && coords.row \
>= start && coords.row <= end) {\n      controller.row = true;\n      \
priv.pressed = true;\n      priv.target.eventPageY = event2.pageY;\n      \
priv.target.coords = coords;\n      priv.target.TD = TD;\n      \
priv.rowsToMove = this.prepareRowsToMoving();\n      const leftPos = \
wtTable.holder.scrollLeft + wtViewport.getRowHeaderWidth();\n      \
this.backlight.setPosition(null, leftPos);\n      \
this.backlight.setSize(wtTable.hider.offsetWidth - leftPos, \
this.getRowsHeight(start, end));\n      \
this.backlight.setOffset((this.getRowsHeight(start, coords.row - 1) + \
event2.offsetY) * -1, null);\n      addClass(this.hot.rootElement, \
CSS_ON_MOVING2);\n      this.refreshPositions();\n    } else {\n      \
removeClass(this.hot.rootElement, CSS_AFTER_SELECTION2);\n      priv.pressed \
= false;\n      priv.rowsToMove.length = 0;\n    }\n  }\n  /**\n   * \
'mouseMove' event callback. Fired when pointer move on \
document.documentElement.\n   *\n   * @private\n   * @param {MouseEvent} \
event `mousemove` event properties.\n   */\n  onMouseMove(event2) {\n    \
const priv = privatePool17.get(this);\n    if (!priv.pressed) {\n      \
return;\n    }\n    if (event2.target === this.backlight.element) {\n      \
const height = this.backlight.getSize().height;\n      \
this.backlight.setSize(null, 0);\n      setTimeout(function() {\n        \
this.backlight.setPosition(null, height);\n      });\n    }\n    \
priv.target.eventPageY = event2.pageY;\n    this.refreshPositions();\n  }\n  \
/**\n   * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over \
cell.\n   *\n   * @private\n   * @param {MouseEvent} event `mouseover` event \
properties.\n   * @param {CellCoords} coords Visual cell coordinates where \
was fired event.\n   * @param {HTMLElement} TD Cell represented as \
HTMLElement.\n   * @param {object} controller An object with properties \
`row`, `column` and `cell`. Each property contains\n   *                      \
      a boolean value that allows or disallows changing the selection for \
that particular area.\n   */\n  onBeforeOnCellMouseOver(event2, coords, TD, \
controller) {\n    const selectedRange = this.hot.getSelectedRangeLast();\n   \
 const priv = privatePool17.get(this);\n    if (!selectedRange || \
!priv.pressed) {\n      return;\n    }\n    if \
(priv.rowsToMove.indexOf(coords.row) > -1) {\n      \
removeClass(this.hot.rootElement, CSS_SHOW_UI2);\n    } else {\n      \
addClass(this.hot.rootElement, CSS_SHOW_UI2);\n    }\n    controller.row = \
true;\n    controller.column = true;\n    controller.cell = true;\n    \
priv.target.coords = coords;\n    priv.target.TD = TD;\n  }\n  /**\n   * \
`onMouseUp` hook callback.\n   *\n   * @private\n   */\n  onMouseUp() {\n    \
const priv = privatePool17.get(this);\n    const target = priv.target.row;\n  \
  const rowsLen = priv.rowsToMove.length;\n    priv.pressed = false;\n    \
priv.backlightHeight = 0;\n    removeClass(this.hot.rootElement, \
[CSS_ON_MOVING2, CSS_SHOW_UI2, CSS_AFTER_SELECTION2]);\n    if \
(this.hot.selection.isSelectedByRowHeader()) {\n      \
addClass(this.hot.rootElement, CSS_AFTER_SELECTION2);\n    }\n    if (rowsLen \
< 1 || target === void 0) {\n      return;\n    }\n    const \
firstMovedVisualRow = priv.rowsToMove[0];\n    const firstMovedPhysicalRow = \
this.hot.toPhysicalRow(firstMovedVisualRow);\n    const movePerformed = \
this.dragRows(priv.rowsToMove, target);\n    priv.rowsToMove.length = 0;\n    \
if (movePerformed === true) {\n      this.persistentStateSave();\n      \
this.hot.render();\n      this.hot.view.adjustElementsSize(true);\n      \
const selectionStart = this.hot.toVisualRow(firstMovedPhysicalRow);\n      \
const selectionEnd = selectionStart + rowsLen - 1;\n      \
this.hot.selectRows(selectionStart, selectionEnd);\n    }\n  }\n  /**\n   * \
`afterScrollHorizontally` hook callback. Fired the table was scrolled \
horizontally.\n   *\n   * @private\n   */\n  onAfterScrollHorizontally() {\n  \
  const wtTable = this.hot.view._wt.wtTable;\n    const headerWidth = \
this.hot.view._wt.wtViewport.getRowHeaderWidth();\n    const scrollLeft = \
wtTable.holder.scrollLeft;\n    const posLeft = headerWidth + scrollLeft;\n   \
 this.backlight.setPosition(null, posLeft);\n    \
this.backlight.setSize(wtTable.hider.offsetWidth - posLeft);\n  }\n  /**\n   \
* Builds the plugin's UI.\n   *\n   * @private\n   */\n  buildPluginUI() {\n  \
  this.backlight.build();\n    this.guideline.build();\n  }\n  /**\n   * \
Callback for the `afterLoadData` hook.\n   *\n   * @private\n   */\n  \
onAfterLoadData() {\n    this.moveBySettingsOrLoad();\n  }\n  /**\n   * \
Destroys the plugin instance.\n   */\n  destroy() {\n    \
this.backlight.destroy();\n    this.guideline.destroy();\n    \
super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/manualRowResize/manualRowResize.mjs\nvar \
PLUGIN_KEY24 = \"manualRowResize\";\nvar PLUGIN_PRIORITY23 = 30;\nvar \
PERSISTENT_STATE_KEY2 = \"manualRowHeights\";\nvar privatePool18 = /* \
@__PURE__ */ new WeakMap();\nvar ManualRowResize = class extends BasePlugin \
{\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY24;\n  }\n  static get \
PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY23;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    const {\n      \
rootDocument\n    } = this.hot;\n    this.currentTH = null;\n    \
this.currentRow = null;\n    this.selectedRows = [];\n    this.currentHeight \
= null;\n    this.newSize = null;\n    this.startY = null;\n    \
this.startHeight = null;\n    this.startOffset = null;\n    this.handle = \
rootDocument.createElement(\"DIV\");\n    this.guide = \
rootDocument.createElement(\"DIV\");\n    this.eventManager = new \
eventManager_default(this);\n    this.pressed = null;\n    \
this.isTriggeredByRMB = false;\n    this.dblclick = 0;\n    \
this.autoresizeTimeout = null;\n    this.rowHeightsMap = void 0;\n    \
privatePool18.set(this, {\n      config: void 0\n    });\n    \
addClass(this.handle, \"manualRowResizer\");\n    addClass(this.guide, \
\"manualRowResizerGuide\");\n  }\n  /**\n   * @private\n   * @returns \
{string}\n   */\n  get inlineDir() {\n    return this.hot.isRtl() ? \"right\" \
: \"left\";\n  }\n  /**\n   * Checks if the plugin is enabled in the \
handsontable settings. This method is executed in {@link Hooks#beforeInit}\n  \
 * hook and if it returns `true` then the {@link \
ManualRowResize#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
this.hot.getSettings()[PLUGIN_KEY24];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
if (this.enabled) {\n      return;\n    }\n    this.rowHeightsMap = new \
PhysicalIndexToValueMap();\n    this.rowHeightsMap.addLocalHook(\"init\", () \
=> this.onMapInit());\n    \
this.hot.rowIndexMapper.registerMap(this.pluginName, this.rowHeightsMap);\n   \
 this.addHook(\"modifyRowHeight\", (height, row) => \
this.onModifyRowHeight(height, row));\n    this.bindEvents();\n    \
super.enablePlugin();\n  }\n  /**\n   * Updates the plugin's state.\n   *\n   \
* This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`manualRowResize`](@/api/options.md#manualrowresize)\n   */\n  \
updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    \
super.updatePlugin();\n  }\n  /**\n   * Disables the plugin functionality for \
this Handsontable instance.\n   */\n  disablePlugin() {\n    const priv = \
privatePool18.get(this);\n    priv.config = this.rowHeightsMap.getValues();\n \
   this.hot.rowIndexMapper.unregisterMap(this.pluginName);\n    \
super.disablePlugin();\n  }\n  /**\n   * Saves the current sizes using the \
persistentState plugin (the {@link Options#persistentState} option has to \
be\n   * enabled).\n   *\n   * @fires Hooks#persistentStateSave\n   */\n  \
saveManualRowHeights() {\n    this.hot.runHooks(\"persistentStateSave\", \
PERSISTENT_STATE_KEY2, this.rowHeightsMap.getValues());\n  }\n  /**\n   * \
Loads the previously saved sizes using the persistentState plugin (the {@link \
Options#persistentState} option\n   * has be enabled).\n   *\n   * @returns \
{Array}\n   * @fires Hooks#persistentStateLoad\n   */\n  \
loadManualRowHeights() {\n    const storedState = {};\n    \
this.hot.runHooks(\"persistentStateLoad\", PERSISTENT_STATE_KEY2, \
storedState);\n    return storedState.value;\n  }\n  /**\n   * Sets the new \
height for specified row index.\n   *\n   * @param {number} row Visual row \
index.\n   * @param {number} height Row height.\n   * @returns {number} \
Returns new height.\n   */\n  setManualSize(row, height) {\n    const \
physicalRow = this.hot.toPhysicalRow(row);\n    const newHeight = \
Math.max(height, viewportRows_default.DEFAULT_HEIGHT);\n    \
this.rowHeightsMap.setValueAtIndex(physicalRow, newHeight);\n    return \
newHeight;\n  }\n  /**\n   * Sets the resize handle position.\n   *\n   * \
@private\n   * @param {HTMLCellElement} TH TH HTML element.\n   */\n  \
setupHandlePosition(TH) {\n    this.currentTH = TH;\n    const {\n      \
view\n    } = this.hot;\n    const {\n      _wt: wt\n    } = view;\n    const \
cellCoords = wt.wtTable.getCoords(this.currentTH);\n    const row = \
cellCoords.row;\n    if (row < 0) {\n      return;\n    }\n    const \
headerWidth = outerWidth(this.currentTH);\n    const box = \
this.currentTH.getBoundingClientRect();\n    const fixedRowTop = row < \
wt.getSetting(\"fixedRowsTop\");\n    const fixedRowBottom = row >= \
view.countNotHiddenRowIndexes(0, 1) - wt.getSetting(\"fixedRowsBottom\");\n   \
 let relativeHeaderPosition;\n    if (fixedRowTop) {\n      \
relativeHeaderPosition = \
wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(this.curren\
tTH, cellCoords.row, cellCoords.col);\n    } else if (fixedRowBottom) {\n     \
 relativeHeaderPosition = \
wt.wtOverlays.bottomInlineStartCornerOverlay.getRelativeCellPosition(this.cur\
rentTH, cellCoords.row, cellCoords.col);\n    }\n    if \
(!relativeHeaderPosition) {\n      relativeHeaderPosition = \
wt.wtOverlays.inlineStartOverlay.getRelativeCellPosition(this.currentTH, \
cellCoords.row, cellCoords.col);\n    }\n    this.currentRow = \
this.hot.rowIndexMapper.getVisualFromRenderableIndex(row);\n    \
this.selectedRows = [];\n    const isFullRowSelected = \
this.hot.selection.isSelectedByCorner() || \
this.hot.selection.isSelectedByRowHeader();\n    if \
(this.hot.selection.isSelected() && isFullRowSelected) {\n      const \
selectionRanges = this.hot.getSelectedRange();\n      \
arrayEach(selectionRanges, (selectionRange) => {\n        const fromRow = \
selectionRange.getTopStartCorner().row;\n        const toRow = \
selectionRange.getBottomStartCorner().row;\n        rangeEach(fromRow, toRow, \
(rowIndex) => {\n          if (!this.selectedRows.includes(rowIndex)) {\n     \
       this.selectedRows.push(rowIndex);\n          }\n        });\n      \
});\n    }\n    if (!this.selectedRows.includes(this.currentRow)) {\n      \
this.selectedRows = [this.currentRow];\n    }\n    this.startOffset = \
relativeHeaderPosition.top - 6;\n    this.startHeight = parseInt(box.height, \
10);\n    this.handle.style.top = `${this.startOffset + \
this.startHeight}px`;\n    this.handle.style[this.inlineDir] = \
`${relativeHeaderPosition.start}px`;\n    this.handle.style.width = \
`${headerWidth}px`;\n    this.hot.rootElement.appendChild(this.handle);\n  \
}\n  /**\n   * Refresh the resize handle position.\n   *\n   * @private\n   \
*/\n  refreshHandlePosition() {\n    this.handle.style.top = \
`${this.startOffset + this.currentHeight}px`;\n  }\n  /**\n   * Sets the \
resize guide position.\n   *\n   * @private\n   */\n  setupGuidePosition() \
{\n    const handleWidth = parseInt(outerWidth(this.handle), 10);\n    const \
handleEndPosition = parseInt(this.handle.style[this.inlineDir], 10) + \
handleWidth;\n    const maximumVisibleElementWidth = \
parseInt(this.hot.view.maximumVisibleElementWidth(0), 10);\n    \
addClass(this.handle, \"active\");\n    addClass(this.guide, \"active\");\n   \
 this.guide.style.top = this.handle.style.top;\n    \
this.guide.style[this.inlineDir] = `${handleEndPosition}px`;\n    \
this.guide.style.width = `${maximumVisibleElementWidth - handleWidth}px`;\n   \
 this.hot.rootElement.appendChild(this.guide);\n  }\n  /**\n   * Refresh the \
resize guide position.\n   *\n   * @private\n   */\n  refreshGuidePosition() \
{\n    this.guide.style.top = this.handle.style.top;\n  }\n  /**\n   * Hides \
both the resize handle and resize guide.\n   *\n   * @private\n   */\n  \
hideHandleAndGuide() {\n    removeClass(this.handle, \"active\");\n    \
removeClass(this.guide, \"active\");\n  }\n  /**\n   * Checks if provided \
element is considered as a row header.\n   *\n   * @private\n   * @param \
{HTMLElement} element HTML element.\n   * @returns {boolean}\n   */\n  \
checkIfRowHeader(element) {\n    var _element$parentNode;\n    const \
thElement = closest(element, [\"TH\"], this.hot.rootElement);\n    return \
thElement && ((_element$parentNode = element.parentNode) === null || \
_element$parentNode === void 0 || (_element$parentNode = \
_element$parentNode.parentNode) === null || _element$parentNode === void 0 ? \
void 0 : _element$parentNode.tagName) === \"TBODY\";\n  }\n  /**\n   * Gets \
the TH element from the provided element.\n   *\n   * @private\n   * @param \
{HTMLElement} element HTML element.\n   * @returns {HTMLElement}\n   */\n  \
getClosestTHParent(element) {\n    if (element.tagName !== \"TABLE\") {\n     \
 if (element.tagName === \"TH\") {\n        return element;\n      }\n      \
return this.getClosestTHParent(element.parentNode);\n    }\n    return \
null;\n  }\n  /**\n   * Returns the actual height for the provided row \
index.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * \
@returns {number} Actual row height.\n   */\n  getActualRowHeight(row) {\n    \
const walkontableHeight = this.hot.view._wt.wtTable.getRowHeight(row);\n    \
if (walkontableHeight !== void 0 && this.newSize < walkontableHeight) {\n     \
 return walkontableHeight;\n    }\n    return this.newSize;\n  }\n  /**\n   * \
'mouseover' event callback - set the handle position.\n   *\n   * @private\n  \
 * @param {MouseEvent} event The mouse event.\n   */\n  onMouseOver(event2) \
{\n    if (isDetached(event2.target)) {\n      return;\n    }\n    if \
(this.isTriggeredByRMB === true) {\n      return;\n    }\n    if \
(this.checkIfRowHeader(event2.target)) {\n      const th = \
this.getClosestTHParent(event2.target);\n      if (th) {\n        if \
(!this.pressed) {\n          this.setupHandlePosition(th);\n        }\n      \
}\n    }\n  }\n  /**\n   * Auto-size row after doubleclick - callback.\n   \
*\n   * @private\n   * @fires Hooks#beforeRowResize\n   * @fires \
Hooks#afterRowResize\n   */\n  afterMouseDownTimeout() {\n    const render = \
() => {\n      this.hot.forceFullRender = true;\n      \
this.hot.view.render();\n      this.hot.view.adjustElementsSize(true);\n    \
};\n    const resize = (row, forceRender) => {\n      const hookNewSize = \
this.hot.runHooks(\"beforeRowResize\", this.getActualRowHeight(row), row, \
true);\n      if (hookNewSize !== void 0) {\n        this.newSize = \
hookNewSize;\n      }\n      this.setManualSize(row, this.newSize);\n      \
this.hot.runHooks(\"afterRowResize\", this.getActualRowHeight(row), row, \
true);\n      if (forceRender) {\n        render();\n      }\n    };\n    if \
(this.dblclick >= 2) {\n      const selectedRowsLength = \
this.selectedRows.length;\n      if (selectedRowsLength > 1) {\n        \
arrayEach(this.selectedRows, (selectedRow) => {\n          \
resize(selectedRow);\n        });\n        render();\n      } else {\n        \
arrayEach(this.selectedRows, (selectedRow) => {\n          \
resize(selectedRow, true);\n        });\n      }\n    }\n    this.dblclick = \
0;\n    this.autoresizeTimeout = null;\n  }\n  /**\n   * 'mousedown' event \
callback.\n   *\n   * @private\n   * @param {MouseEvent} event The mouse \
event.\n   */\n  onMouseDown(event2) {\n    if (hasClass(event2.target, \
\"manualRowResizer\")) {\n      this.setupHandlePosition(this.currentTH);\n   \
   this.setupGuidePosition();\n      this.pressed = true;\n      if \
(this.autoresizeTimeout === null) {\n        this.autoresizeTimeout = \
setTimeout(() => this.afterMouseDownTimeout(), 500);\n        \
this.hot._registerTimeout(this.autoresizeTimeout);\n      }\n      \
this.dblclick += 1;\n      this.startY = event2.pageY;\n      this.newSize = \
this.startHeight;\n    }\n  }\n  /**\n   * 'mousemove' event callback - \
refresh the handle and guide positions, cache the new row height.\n   *\n   * \
@private\n   * @param {MouseEvent} event The mouse event.\n   */\n  \
onMouseMove(event2) {\n    if (this.pressed) {\n      this.currentHeight = \
this.startHeight + (event2.pageY - this.startY);\n      \
arrayEach(this.selectedRows, (selectedRow) => {\n        this.newSize = \
this.setManualSize(selectedRow, this.currentHeight);\n      });\n      \
this.refreshHandlePosition();\n      this.refreshGuidePosition();\n    }\n  \
}\n  /**\n   * 'mouseup' event callback - apply the row resizing.\n   *\n   * \
@private\n   *\n   * @fires Hooks#beforeRowResize\n   * @fires \
Hooks#afterRowResize\n   */\n  onMouseUp() {\n    const render = () => {\n    \
  this.hot.forceFullRender = true;\n      this.hot.view.render();\n      \
this.hot.view.adjustElementsSize(true);\n    };\n    const runHooks = (row, \
forceRender) => {\n      this.hot.runHooks(\"beforeRowResize\", \
this.getActualRowHeight(row), row, false);\n      if (forceRender) {\n        \
render();\n      }\n      this.saveManualRowHeights();\n      \
this.hot.runHooks(\"afterRowResize\", this.getActualRowHeight(row), row, \
false);\n    };\n    if (this.pressed) {\n      this.hideHandleAndGuide();\n  \
    this.pressed = false;\n      if (this.newSize !== this.startHeight) {\n   \
     const selectedRowsLength = this.selectedRows.length;\n        if \
(selectedRowsLength > 1) {\n          arrayEach(this.selectedRows, \
(selectedRow) => {\n            runHooks(selectedRow);\n          });\n       \
   render();\n        } else {\n          arrayEach(this.selectedRows, \
(selectedRow) => {\n            runHooks(selectedRow, true);\n          });\n \
       }\n      }\n      this.setupHandlePosition(this.currentTH);\n    }\n  \
}\n  /**\n   * Callback for \"contextmenu\" event triggered on element \
showing move handle. It removes handle and guide elements.\n   *\n   * \
@private\n   */\n  onContextMenu() {\n    this.hideHandleAndGuide();\n    \
this.hot.rootElement.removeChild(this.handle);\n    \
this.hot.rootElement.removeChild(this.guide);\n    this.pressed = false;\n    \
this.isTriggeredByRMB = true;\n    this.hot._registerImmediate(() => {\n      \
this.isTriggeredByRMB = false;\n    });\n  }\n  /**\n   * Binds the mouse \
events.\n   *\n   * @private\n   */\n  bindEvents() {\n    const {\n      \
rootElement,\n      rootWindow\n    } = this.hot;\n    \
this.eventManager.addEventListener(rootElement, \"mouseover\", (e) => \
this.onMouseOver(e));\n    this.eventManager.addEventListener(rootElement, \
\"mousedown\", (e) => this.onMouseDown(e));\n    \
this.eventManager.addEventListener(rootWindow, \"mousemove\", (e) => \
this.onMouseMove(e));\n    this.eventManager.addEventListener(rootWindow, \
\"mouseup\", () => this.onMouseUp());\n    \
this.eventManager.addEventListener(this.handle, \"contextmenu\", () => \
this.onContextMenu());\n  }\n  /**\n   * Modifies the provided row height, \
based on the plugin settings.\n   *\n   * @private\n   * @param {number} \
height Row height.\n   * @param {number} row Visual row index.\n   * @returns \
{number}\n   */\n  onModifyRowHeight(height, row) {\n    let newHeight = \
height;\n    if (this.enabled) {\n      const physicalRow = \
this.hot.toPhysicalRow(row);\n      const rowHeight = \
this.rowHeightsMap.getValueAtIndex(physicalRow);\n      if \
(this.hot.getSettings()[PLUGIN_KEY24] && rowHeight) {\n        newHeight = \
rowHeight;\n      }\n    }\n    return newHeight;\n  }\n  /**\n   * Callback \
to call on map's `init` local hook.\n   *\n   * @private\n   */\n  \
onMapInit() {\n    const priv = privatePool18.get(this);\n    const \
initialSetting = this.hot.getSettings()[PLUGIN_KEY24];\n    const \
loadedManualRowHeights = this.loadManualRowHeights();\n    \
this.hot.batchExecution(() => {\n      if (typeof loadedManualRowHeights !== \
\"undefined\") {\n        loadedManualRowHeights.forEach((height, index2) => \
{\n          this.rowHeightsMap.setValueAtIndex(index2, height);\n        \
});\n      } else if (Array.isArray(initialSetting)) {\n        \
initialSetting.forEach((height, index2) => {\n          \
this.rowHeightsMap.setValueAtIndex(index2, height);\n        });\n        \
priv.config = initialSetting;\n      } else if (initialSetting === true && \
Array.isArray(priv.config)) {\n        priv.config.forEach((height, index2) \
=> {\n          this.rowHeightsMap.setValueAtIndex(index2, height);\n        \
});\n      }\n    }, true);\n  }\n  /**\n   * Destroys the plugin instance.\n \
  */\n  destroy() {\n    super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/mergeCells/cellCoords.mjs\nvar \
MergedCellCoords = class {\n  constructor(row, column, rowspan, colspan, \
cellCoordsFactory, cellRangeFactory) {\n    this.row = row;\n    this.col = \
column;\n    this.rowspan = rowspan;\n    this.colspan = colspan;\n    \
this.removed = false;\n    this.cellCoordsFactory = cellCoordsFactory;\n    \
this.cellRangeFactory = cellRangeFactory;\n  }\n  /**\n   * Get a warning \
message for when the declared merged cell data contains negative values.\n   \
*\n   * @param {object} newMergedCell Object containg information about the \
merged cells that was about to be added.\n   * @returns {string}\n   */\n  \
static NEGATIVE_VALUES_WARNING(newMergedCell) {\n    return toSingleLine`The \
merged cell declared with {row: ${newMergedCell.row}, col: \
${newMergedCell.col},\\x20\n      rowspan: ${newMergedCell.rowspan}, colspan: \
${newMergedCell.colspan}} contains negative values, which is\\x20\n      not \
supported. It will not be added to the collection.`;\n  }\n  /**\n   * Get a \
warning message for when the declared merged cell data contains values \
exceeding the table limits.\n   *\n   * @param {object} newMergedCell Object \
containg information about the merged cells that was about to be added.\n   * \
@returns {string}\n   */\n  static IS_OUT_OF_BOUNDS_WARNING(newMergedCell) \
{\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, \
${newMergedCell.col}] is positioned\\x20\n      (or positioned partially) \
outside of the table range. It was not added to the table, please fix your \
setup.`;\n  }\n  /**\n   * Get a warning message for when the declared merged \
cell data represents a single cell.\n   *\n   * @param {object} newMergedCell \
Object containg information about the merged cells that was about to be \
added.\n   * @returns {string}\n   */\n  static IS_SINGLE_CELL(newMergedCell) \
{\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, \
${newMergedCell.col}] has both \"rowspan\"\\x20\n      and \"colspan\" \
declared as \"1\", which makes it a single cell. It cannot be added to the \
collection.`;\n  }\n  /**\n   * Get a warning message for when the declared \
merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n   *\n  \
 * @param {object} newMergedCell Object containg information about the merged \
cells that was about to be added.\n   * @returns {string}\n   */\n  static \
ZERO_SPAN_WARNING(newMergedCell) {\n    return toSingleLine`The merged cell \
declared at [${newMergedCell.row}, ${newMergedCell.col}] has \
\"rowspan\"\\x20\n      or \"colspan\" declared as \"0\", which is not \
supported. It cannot be added to the collection.`;\n  }\n  /**\n   * Check \
whether the values provided for a merged cell contain any negative values.\n  \
 *\n   * @param {object} mergedCellInfo Object containing the `row`, `col`, \
`rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  static \
containsNegativeValues(mergedCellInfo) {\n    return mergedCellInfo.row < 0 \
|| mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || \
mergedCellInfo.colspan < 0;\n  }\n  /**\n   * Check whether the provided \
merged cell information object represents a single cell.\n   *\n   * \
@private\n   * @param {object} mergedCellInfo An object with `row`, `col`, \
`rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  static \
isSingleCell(mergedCellInfo) {\n    return mergedCellInfo.colspan === 1 && \
mergedCellInfo.rowspan === 1;\n  }\n  /**\n   * Check whether the provided \
merged cell information object contains a rowspan or colspan of 0.\n   *\n   \
* @private\n   * @param {object} mergedCellInfo An object with `row`, `col`, \
`rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  static \
containsZeroSpan(mergedCellInfo) {\n    return mergedCellInfo.colspan === 0 \
|| mergedCellInfo.rowspan === 0;\n  }\n  /**\n   * Check whether the provided \
merged cell object is to be declared out of bounds of the table.\n   *\n   * \
@param {object} mergeCell Object containing the `row`, `col`, `rowspan` and \
`colspan` properties.\n   * @param {number} rowCount Number of rows in the \
table.\n   * @param {number} columnCount Number of rows in the table.\n   * \
@returns {boolean}\n   */\n  static isOutOfBounds(mergeCell, rowCount, \
columnCount) {\n    return mergeCell.row < 0 || mergeCell.col < 0 || \
mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= \
rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan \
- 1 >= columnCount;\n  }\n  /**\n   * Sanitize (prevent from going outside \
the boundaries) the merged cell.\n   *\n   * @param {Core} hotInstance The \
Handsontable instance.\n   */\n  normalize(hotInstance) {\n    const \
totalRows = hotInstance.countRows();\n    const totalColumns = \
hotInstance.countCols();\n    if (this.row < 0) {\n      this.row = 0;\n    } \
else if (this.row > totalRows - 1) {\n      this.row = totalRows - 1;\n    \
}\n    if (this.col < 0) {\n      this.col = 0;\n    } else if (this.col > \
totalColumns - 1) {\n      this.col = totalColumns - 1;\n    }\n    if \
(this.row + this.rowspan > totalRows - 1) {\n      this.rowspan = totalRows - \
this.row;\n    }\n    if (this.col + this.colspan > totalColumns - 1) {\n     \
 this.colspan = totalColumns - this.col;\n    }\n  }\n  /**\n   * Returns \
`true` if the provided coordinates are inside the merged cell.\n   *\n   * \
@param {number} row The row index.\n   * @param {number} column The column \
index.\n   * @returns {boolean}\n   */\n  includes(row, column) {\n    return \
this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row \
&& this.col + this.colspan - 1 >= column;\n  }\n  /**\n   * Returns `true` if \
the provided `column` property is within the column span of the merged \
cell.\n   *\n   * @param {number} column The column index.\n   * @returns \
{boolean}\n   */\n  includesHorizontally(column) {\n    return this.col <= \
column && this.col + this.colspan - 1 >= column;\n  }\n  /**\n   * Returns \
`true` if the provided `row` property is within the row span of the merged \
cell.\n   *\n   * @param {number} row Row index.\n   * @returns {boolean}\n   \
*/\n  includesVertically(row) {\n    return this.row <= row && this.row + \
this.rowspan - 1 >= row;\n  }\n  /**\n   * Shift (and possibly resize, if \
needed) the merged cell.\n   *\n   * @param {Array} shiftVector 2-element \
array containing the information on the shifting in the `x` and `y` axis.\n   \
* @param {number} indexOfChange Index of the preceding change.\n   * @returns \
{boolean} Returns `false` if the whole merged cell was removed.\n   */\n  \
shift(shiftVector, indexOfChange) {\n    const shiftValue = shiftVector[0] || \
shiftVector[1];\n    const shiftedIndex = indexOfChange + \
Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n    const span = \
shiftVector[0] ? \"colspan\" : \"rowspan\";\n    const index2 = \
shiftVector[0] ? \"col\" : \"row\";\n    const changeStart = \
Math.min(indexOfChange, shiftedIndex);\n    const changeEnd = \
Math.max(indexOfChange, shiftedIndex);\n    const mergeStart = \
this[index2];\n    const mergeEnd = this[index2] + this[span] - 1;\n    if \
(mergeStart >= indexOfChange) {\n      this[index2] += shiftValue;\n    }\n   \
 if (shiftValue > 0) {\n      if (indexOfChange <= mergeEnd && indexOfChange \
> mergeStart) {\n        this[span] += shiftValue;\n      }\n    } else if \
(shiftValue < 0) {\n      if (changeStart <= mergeStart && changeEnd >= \
mergeEnd) {\n        this.removed = true;\n        return false;\n      } \
else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n        \
const removedOffset = changeEnd - mergeStart + 1;\n        const \
preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n        \
this[index2] -= preRemovedOffset + shiftValue;\n        this[span] -= \
removedOffset;\n      } else if (mergeStart <= changeStart && mergeEnd >= \
changeEnd) {\n        this[span] += shiftValue;\n      } else if (mergeStart \
<= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n        \
const removedPart = mergeEnd - changeStart + 1;\n        this[span] -= \
removedPart;\n      }\n    }\n    return true;\n  }\n  /**\n   * Check if the \
second provided merged cell is \"farther\" in the provided direction.\n   *\n \
  * @param {MergedCellCoords} mergedCell The merged cell to check.\n   * \
@param {string} direction Drag direction.\n   * @returns {boolean|null} \
`true` if the second provided merged cell is \"farther\".\n   */\n  \
isFarther(mergedCell, direction) {\n    if (!mergedCell) {\n      return \
true;\n    }\n    if (direction === \"down\") {\n      return mergedCell.row \
+ mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n    } else if \
(direction === \"up\") {\n      return mergedCell.row > this.row;\n    } else \
if (direction === \"right\") {\n      return mergedCell.col + \
mergedCell.colspan - 1 < this.col + this.colspan - 1;\n    } else if \
(direction === \"left\") {\n      return mergedCell.col > this.col;\n    }\n  \
  return null;\n  }\n  /**\n   * Get the bottom row index of the merged \
cell.\n   *\n   * @returns {number}\n   */\n  getLastRow() {\n    return \
this.row + this.rowspan - 1;\n  }\n  /**\n   * Get the rightmost column index \
of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastColumn() \
{\n    return this.col + this.colspan - 1;\n  }\n  /**\n   * Get the range \
coordinates of the merged cell.\n   *\n   * @returns {CellRange}\n   */\n  \
getRange() {\n    return \
this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), \
this.cellCoordsFactory(this.row, this.col), \
this.cellCoordsFactory(this.getLastRow(), this.getLastColumn()));\n  \
}\n};\nvar cellCoords_default = MergedCellCoords;\n\n// \
node_modules/handsontable/plugins/mergeCells/utils.mjs\nfunction \
applySpanProperties(TD, mergedCellInfo, row, col) {\n  if (mergedCellInfo) \
{\n    if (mergedCellInfo.row === row && mergedCellInfo.col === col) {\n      \
TD.setAttribute(\"rowspan\", mergedCellInfo.rowspan.toString());\n      \
TD.setAttribute(\"colspan\", mergedCellInfo.colspan.toString());\n    } else \
{\n      TD.removeAttribute(\"rowspan\");\n      \
TD.removeAttribute(\"colspan\");\n      TD.style.display = \"none\";\n    }\n \
 } else {\n    TD.removeAttribute(\"rowspan\");\n    \
TD.removeAttribute(\"colspan\");\n    TD.style.display = \"\";\n  }\n}\n\n// \
node_modules/handsontable/plugins/mergeCells/cellsCollection.mjs\nvar \
MergedCellsCollection = class _MergedCellsCollection {\n  constructor(plugin) \
{\n    this.plugin = plugin;\n    this.mergedCells = [];\n    this.hot = \
plugin.hot;\n  }\n  /**\n   * Get a warning message for when the declared \
merged cell data overlaps already existing merged cells.\n   *\n   * @param \
{object} newMergedCell Object containg information about the merged cells \
that was about to be added.\n   * @returns {string}\n   */\n  static \
IS_OVERLAPPING_WARNING(newMergedCell) {\n    return toSingleLine`The merged \
cell declared at [${newMergedCell.row}, ${newMergedCell.col}], \
overlaps\\x20\n      with the other declared merged cell. The overlapping \
merged cell was not added to the table, please\\x20\n      fix your \
setup.`;\n  }\n  /**\n   * Get a merged cell from the container, based on the \
provided arguments. You can provide either the \"starting coordinates\"\n   * \
of a merged cell, or any coordinates from the body of the merged cell.\n   \
*\n   * @param {number} row Row index.\n   * @param {number} column Column \
index.\n   * @returns {MergedCellCoords|boolean} Returns a wanted merged cell \
on success and `false` on failure.\n   */\n  get(row, column) {\n    const \
mergedCells = this.mergedCells;\n    let result = false;\n    \
arrayEach(mergedCells, (mergedCell) => {\n      if (mergedCell.row <= row && \
mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && \
mergedCell.col + mergedCell.colspan - 1 >= column) {\n        result = \
mergedCell;\n        return false;\n      }\n      return true;\n    });\n    \
return result;\n  }\n  /**\n   * Get a merged cell containing the provided \
range.\n   *\n   * @param {CellRange|object} range The range to search merged \
cells for.\n   * @returns {MergedCellCoords|boolean}\n   */\n  \
getByRange(range) {\n    const mergedCells = this.mergedCells;\n    let \
result = false;\n    arrayEach(mergedCells, (mergedCell) => {\n      if \
(mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 \
>= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + \
mergedCell.colspan - 1 >= range.to.col) {\n        result = mergedCell;\n     \
   return result;\n      }\n      return true;\n    });\n    return result;\n \
 }\n  /**\n   * Get a merged cell contained in the provided range.\n   *\n   \
* @param {CellRange|object} range The range to search merged cells in.\n   * \
@param {boolean} [countPartials=false] If set to `true`, all the merged cells \
overlapping the range will be taken into calculation.\n   * @returns \
{Array|boolean} Array of found merged cells of `false` if none were found.\n  \
 */\n  getWithinRange(range) {\n    let countPartials = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : false;\n    const mergedCells = \
this.mergedCells;\n    const foundMergedCells = [];\n    let testedRange = \
range;\n    if (!testedRange.includesRange) {\n      const from = \
this.hot._createCellCoords(testedRange.from.row, testedRange.from.col);\n     \
 const to = this.hot._createCellCoords(testedRange.to.row, \
testedRange.to.col);\n      testedRange = this.hot._createCellRange(from, \
from, to);\n    }\n    arrayEach(mergedCells, (mergedCell) => {\n      const \
mergedCellTopLeft = this.hot._createCellCoords(mergedCell.row, \
mergedCell.col);\n      const mergedCellBottomRight = \
this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, \
mergedCell.col + mergedCell.colspan - 1);\n      const mergedCellRange = \
this.hot._createCellRange(mergedCellTopLeft, mergedCellTopLeft, \
mergedCellBottomRight);\n      if (countPartials) {\n        if \
(testedRange.overlaps(mergedCellRange)) {\n          \
foundMergedCells.push(mergedCell);\n        }\n      } else if \
(testedRange.includesRange(mergedCellRange)) {\n        \
foundMergedCells.push(mergedCell);\n      }\n    });\n    return \
foundMergedCells.length ? foundMergedCells : false;\n  }\n  /**\n   * Add a \
merged cell to the container.\n   *\n   * @param {object} mergedCellInfo The \
merged cell information object. Has to contain `row`, `col`, `colspan` and \
`rowspan` properties.\n   * @returns {MergedCellCoords|boolean} Returns the \
new merged cell on success and `false` on failure.\n   */\n  \
add(mergedCellInfo) {\n    const mergedCells = this.mergedCells;\n    const \
row = mergedCellInfo.row;\n    const column = mergedCellInfo.col;\n    const \
rowspan = mergedCellInfo.rowspan;\n    const colspan = \
mergedCellInfo.colspan;\n    const newMergedCell = new \
cellCoords_default(row, column, rowspan, colspan, this.hot._createCellCoords, \
this.hot._createCellRange);\n    const alreadyExists = this.get(row, \
column);\n    const isOverlapping = this.isOverlapping(newMergedCell);\n    \
if (!alreadyExists && !isOverlapping) {\n      if (this.hot) {\n        \
newMergedCell.normalize(this.hot);\n      }\n      \
mergedCells.push(newMergedCell);\n      return newMergedCell;\n    }\n    \
warn(_MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n    \
return false;\n  }\n  /**\n   * Remove a merged cell from the container. You \
can provide either the \"starting coordinates\"\n   * of a merged cell, or \
any coordinates from the body of the merged cell.\n   *\n   * @param {number} \
row Row index.\n   * @param {number} column Column index.\n   * @returns \
{MergedCellCoords|boolean} Returns the removed merged cell on success and \
`false` on failure.\n   */\n  remove(row, column) {\n    const mergedCells = \
this.mergedCells;\n    const wantedCollection = this.get(row, column);\n    \
const wantedCollectionIndex = wantedCollection ? \
this.mergedCells.indexOf(wantedCollection) : -1;\n    if (wantedCollection && \
wantedCollectionIndex !== -1) {\n      \
mergedCells.splice(wantedCollectionIndex, 1);\n      return \
wantedCollection;\n    }\n    return false;\n  }\n  /**\n   * Clear all the \
merged cells.\n   */\n  clear() {\n    const mergedCells = \
this.mergedCells;\n    const mergedCellParentsToClear = [];\n    const \
hiddenCollectionElements = [];\n    arrayEach(mergedCells, (mergedCell) => \
{\n      const TD = this.hot.getCell(mergedCell.row, mergedCell.col);\n      \
if (TD) {\n        mergedCellParentsToClear.push([TD, \
this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n \
     }\n    });\n    this.mergedCells.length = 0;\n    \
arrayEach(mergedCellParentsToClear, (mergedCell, i) => {\n      rangeEach(0, \
mergedCell.rowspan - 1, (j) => {\n        rangeEach(0, mergedCell.colspan - \
1, (k) => {\n          if (k !== 0 || j !== 0) {\n            const TD = \
this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n            if \
(TD) {\n              hiddenCollectionElements.push([TD, null, null, \
null]);\n            }\n          }\n        });\n      });\n      \
mergedCellParentsToClear[i][1] = null;\n    });\n    \
arrayEach(mergedCellParentsToClear, (mergedCellParents) => {\n      \
applySpanProperties(...mergedCellParents);\n    });\n    \
arrayEach(hiddenCollectionElements, (hiddenCollectionElement) => {\n      \
applySpanProperties(...hiddenCollectionElement);\n    });\n  }\n  /**\n   * \
Check if the provided merged cell overlaps with the others in the \
container.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell \
to check against all others in the container.\n   * @returns {boolean} `true` \
if the provided merged cell overlaps with the others, `false` otherwise.\n   \
*/\n  isOverlapping(mergedCell) {\n    const mergedCellRange = \
this.hot._createCellRange(this.hot._createCellCoords(0, 0), \
this.hot._createCellCoords(mergedCell.row, mergedCell.col), \
this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, \
mergedCell.col + mergedCell.colspan - 1));\n    let result = false;\n    \
arrayEach(this.mergedCells, (col) => {\n      const currentRange = \
this.hot._createCellRange(this.hot._createCellCoords(0, 0), \
this.hot._createCellCoords(col.row, col.col), \
this.hot._createCellCoords(col.row + col.rowspan - 1, col.col + col.colspan - \
1));\n      if (currentRange.overlaps(mergedCellRange)) {\n        result = \
true;\n        return false;\n      }\n      return true;\n    });\n    \
return result;\n  }\n  /**\n   * Check whether the provided row/col \
coordinates direct to a first not hidden cell within merge area.\n   *\n   * \
@param {number} row Visual row index.\n   * @param {number} column Visual \
column index.\n   * @returns {boolean}\n   */\n  \
isFirstRenderableMergedCell(row, column) {\n    const mergeParent = \
this.get(row, column);\n    return mergeParent && \
this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row \
&& this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) \
=== column;\n  }\n  /**\n   * Get the first renderable coords of the merged \
cell at the provided coordinates.\n   *\n   * @param {number} row Visual row \
index.\n   * @param {number} column Visual column index.\n   * @returns \
{CellCoords} A `CellCoords` object with the coordinates to the first \
renderable cell within the\n   *                        merged cell.\n   */\n \
 getFirstRenderableCoords(row, column) {\n    const mergeParent = \
this.get(row, column);\n    if (!mergeParent || \
this.isFirstRenderableMergedCell(row, column)) {\n      return \
this.hot._createCellCoords(row, column);\n    }\n    const firstRenderableRow \
= this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);\n    \
const firstRenderableColumn = \
this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);\n    \
return this.hot._createCellCoords(firstRenderableRow, \
firstRenderableColumn);\n  }\n  /**\n   * Shift the merged cell in the \
direction and by an offset defined in the arguments.\n   *\n   * @param \
{string} direction `right`, `left`, `up` or `down`.\n   * @param {number} \
index Index where the change, which caused the shifting took place.\n   * \
@param {number} count Number of rows/columns added/removed in the preceding \
action.\n   */\n  shiftCollections(direction, index2, count) {\n    const \
shiftVector = [0, 0];\n    switch (direction) {\n      case \"right\":\n      \
  shiftVector[0] += count;\n        break;\n      case \"left\":\n        \
shiftVector[0] -= count;\n        break;\n      case \"down\":\n        \
shiftVector[1] += count;\n        break;\n      case \"up\":\n        \
shiftVector[1] -= count;\n        break;\n      default:\n    }\n    \
arrayEach(this.mergedCells, (currentMerge) => {\n      \
currentMerge.shift(shiftVector, index2);\n    });\n    \
rangeEachReverse(this.mergedCells.length - 1, 0, (i) => {\n      const \
currentMerge = this.mergedCells[i];\n      if (currentMerge && \
currentMerge.removed) {\n        \
this.mergedCells.splice(this.mergedCells.indexOf(currentMerge), 1);\n      \
}\n    });\n  }\n};\nvar cellsCollection_default = \
MergedCellsCollection;\n\n// \
node_modules/handsontable/plugins/mergeCells/calculations/autofill.mjs\nvar \
AutofillCalculations = class {\n  constructor(plugin) {\n    this.plugin = \
plugin;\n    this.mergedCellsCollection = \
this.plugin.mergedCellsCollection;\n    this.currentFillData = null;\n  }\n  \
/**\n   * Correct the provided selection area, so it's not selecting only a \
part of a merged cell.\n   *\n   * @param {Array} selectionArea The selection \
to correct.\n   */\n  correctSelectionAreaSize(selectionArea) {\n    if \
(selectionArea[0] === selectionArea[2] && selectionArea[1] === \
selectionArea[3]) {\n      const mergedCell = \
this.mergedCellsCollection.get(selectionArea[0], selectionArea[1]);\n      if \
(mergedCell) {\n        selectionArea[2] = selectionArea[0] + \
mergedCell.rowspan - 1;\n        selectionArea[3] = selectionArea[1] + \
mergedCell.colspan - 1;\n      }\n    }\n  }\n  /**\n   * Get the direction \
of the autofill process.\n   *\n   * @param {Array} selectionArea The \
selection area.\n   * @param {Array} finalArea The final area (base + \
drag).\n   * @returns {string} `up`, `down`, `left` or `right`.\n   */\n  \
getDirection(selectionArea, finalArea) {\n    let direction = null;\n    if \
(finalArea[0] === selectionArea[0] && finalArea[1] === selectionArea[1] && \
finalArea[3] === selectionArea[3]) {\n      direction = \"down\";\n    } else \
if (finalArea[2] === selectionArea[2] && finalArea[1] === selectionArea[1] && \
finalArea[3] === selectionArea[3]) {\n      direction = \"up\";\n    } else \
if (finalArea[1] === selectionArea[1] && finalArea[2] === selectionArea[2]) \
{\n      direction = \"right\";\n    } else {\n      direction = \"left\";\n  \
  }\n    return direction;\n  }\n  /**\n   * Snap the drag area to the \
farthest merged cell, so it won't clip any of the merged cells.\n   *\n   * \
@param {Array} baseArea The base selected area.\n   * @param {Array} dragArea \
The drag area.\n   * @param {string} dragDirection The autofill drag \
direction.\n   * @param {Array} foundMergedCells MergeCellCoords found in the \
base selection area.\n   * @returns {Array} The new drag area.\n   */\n  \
snapDragArea(baseArea, dragArea, dragDirection, foundMergedCells) {\n    \
const newDragArea = dragArea.slice(0);\n    const fillSize = \
this.getAutofillSize(baseArea, dragArea, dragDirection);\n    const \
[baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = \
baseArea;\n    const verticalDirection = [\"up\", \
\"down\"].indexOf(dragDirection) > -1;\n    const fullCycle = \
verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn \
- baseAreaStartColumn + 1;\n    const fulls = Math.floor(fillSize / \
fullCycle) * fullCycle;\n    const partials = fillSize - fulls;\n    const \
farthestCollection = this.getFarthestCollection(baseArea, dragArea, \
dragDirection, foundMergedCells);\n    if (farthestCollection) {\n      if \
(dragDirection === \"down\") {\n        const fill = farthestCollection.row + \
farthestCollection.rowspan - baseAreaStartRow - partials;\n        const \
newLimit = newDragArea[2] + fill;\n        if (newLimit >= \
this.plugin.hot.countRows()) {\n          newDragArea[2] -= partials;\n       \
 } else {\n          newDragArea[2] += partials ? fill : 0;\n        }\n      \
} else if (dragDirection === \"right\") {\n        const fill = \
farthestCollection.col + farthestCollection.colspan - baseAreaStartColumn - \
partials;\n        const newLimit = newDragArea[3] + fill;\n        if \
(newLimit >= this.plugin.hot.countCols()) {\n          newDragArea[3] -= \
partials;\n        } else {\n          newDragArea[3] += partials ? fill : \
0;\n        }\n      } else if (dragDirection === \"up\") {\n        const \
fill = baseAreaEndRow - partials - farthestCollection.row + 1;\n        const \
newLimit = newDragArea[0] + fill;\n        if (newLimit < 0) {\n          \
newDragArea[0] += partials;\n        } else {\n          newDragArea[0] -= \
partials ? fill : 0;\n        }\n      } else if (dragDirection === \"left\") \
{\n        const fill = baseAreaEndColumn - partials - farthestCollection.col \
+ 1;\n        const newLimit = newDragArea[1] + fill;\n        if (newLimit < \
0) {\n          newDragArea[1] += partials;\n        } else {\n          \
newDragArea[1] -= partials ? fill : 0;\n        }\n      }\n    }\n    \
this.updateCurrentFillCache({\n      baseArea,\n      dragDirection,\n      \
foundMergedCells,\n      fillSize,\n      dragArea: newDragArea,\n      \
cycleLength: fullCycle\n    });\n    return newDragArea;\n  }\n  /**\n   * \
Update the current fill cache with the provided object.\n   *\n   * \
@private\n   * @param {object} updateObject The current filled object \
cache.\n   */\n  updateCurrentFillCache(updateObject) {\n    if \
(!this.currentFillData) {\n      this.currentFillData = {};\n    }\n    \
extend(this.currentFillData, updateObject);\n  }\n  /**\n   * Get the \
\"length\" of the drag area.\n   *\n   * @private\n   * @param {Array} \
baseArea The base selection area.\n   * @param {Array} dragArea The drag area \
(containing the base area).\n   * @param {string} direction The drag \
direction.\n   * @returns {number|null} The \"length\" (height or width, \
depending on the direction) of the drag.\n   */\n  getAutofillSize(baseArea, \
dragArea, direction) {\n    const [baseAreaStartRow, baseAreaStartColumn, \
baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    const [dragAreaStartRow, \
dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;\n    \
switch (direction) {\n      case \"up\":\n        return baseAreaStartRow - \
dragAreaStartRow;\n      case \"down\":\n        return dragAreaEndRow - \
baseAreaEndRow;\n      case \"left\":\n        return baseAreaStartColumn - \
dragAreaStartColumn;\n      case \"right\":\n        return dragAreaEndColumn \
- baseAreaEndColumn;\n      default:\n        return null;\n    }\n  }\n  \
/**\n   * Trim the default drag area (containing the selection area) to the \
drag-only area.\n   *\n   * @private\n   * @param {Array} baseArea The base \
selection area.\n   * @param {Array} dragArea The base selection area \
extended by the drag area.\n   * @param {string} direction Drag direction.\n  \
 * @returns {Array|null} Array representing the drag area coordinates.\n   \
*/\n  getDragArea(baseArea, dragArea, direction) {\n    const \
[baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = \
baseArea;\n    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, \
dragAreaEndColumn] = dragArea;\n    switch (direction) {\n      case \
\"up\":\n        return [dragAreaStartRow, dragAreaStartColumn, \
baseAreaStartRow - 1, baseAreaEndColumn];\n      case \"down\":\n        \
return [baseAreaEndRow + 1, baseAreaStartColumn, dragAreaEndRow, \
baseAreaEndColumn];\n      case \"left\":\n        return [dragAreaStartRow, \
dragAreaStartColumn, baseAreaEndRow, baseAreaStartColumn - 1];\n      case \
\"right\":\n        return [baseAreaStartRow, baseAreaEndColumn + 1, \
dragAreaEndRow, dragAreaEndColumn];\n      default:\n        return null;\n   \
 }\n  }\n  /**\n   * Get the to-be-farthest merged cell in the newly filled \
area.\n   *\n   * @private\n   * @param {Array} baseArea The base selection \
area.\n   * @param {Array} dragArea The drag area (containing the base \
area).\n   * @param {string} direction The drag direction.\n   * @param \
{Array} mergedCellArray Array of the merged cells found in the base area.\n   \
* @returns {MergedCellCoords|null}\n   */\n  getFarthestCollection(baseArea, \
dragArea, direction, mergedCellArray) {\n    const [baseAreaStartRow, \
baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;\n    \
const verticalDirection = [\"up\", \"down\"].indexOf(direction) > -1;\n    \
const baseEnd = verticalDirection ? baseAreaEndRow : baseAreaEndColumn;\n    \
const baseStart = verticalDirection ? baseAreaStartRow : \
baseAreaStartColumn;\n    const fillSize = this.getAutofillSize(baseArea, \
dragArea, direction);\n    const fullCycle = verticalDirection ? \
baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - \
baseAreaStartColumn + 1;\n    const fulls = Math.floor(fillSize / fullCycle) \
* fullCycle;\n    const partials = fillSize - fulls;\n    let \
inclusionFunctionName = null;\n    let farthestCollection = null;\n    let \
endOfDragRecreationIndex = null;\n    switch (direction) {\n      case \
\"up\":\n        inclusionFunctionName = \"includesVertically\";\n        \
endOfDragRecreationIndex = baseEnd - partials + 1;\n        break;\n      \
case \"left\":\n        inclusionFunctionName = \"includesHorizontally\";\n   \
     endOfDragRecreationIndex = baseEnd - partials + 1;\n        break;\n     \
 case \"down\":\n        inclusionFunctionName = \"includesVertically\";\n    \
    endOfDragRecreationIndex = baseStart + partials - 1;\n        break;\n    \
  case \"right\":\n        inclusionFunctionName = \
\"includesHorizontally\";\n        endOfDragRecreationIndex = baseStart + \
partials - 1;\n        break;\n      default:\n    }\n    \
arrayEach(mergedCellArray, (currentCollection) => {\n      if \
(currentCollection[inclusionFunctionName](endOfDragRecreationIndex) && \
currentCollection.isFarther(farthestCollection, direction)) {\n        \
farthestCollection = currentCollection;\n      }\n    });\n    return \
farthestCollection;\n  }\n  /**\n   * Recreate the merged cells after the \
autofill process.\n   *\n   * @param {Array} changes Changes made.\n   */\n  \
recreateAfterDataPopulation(changes) {\n    if (!this.currentFillData) {\n    \
  return;\n    }\n    const fillRange = this.getRangeFromChanges(changes);\n  \
  const foundMergedCells = this.currentFillData.foundMergedCells;\n    const \
dragDirection = this.currentFillData.dragDirection;\n    const inBounds = \
(current2, offset3) => {\n      switch (dragDirection) {\n        case \
\"up\":\n          return current2.row - offset3 >= fillRange.from.row;\n     \
   case \"down\":\n          return current2.row + current2.rowspan - 1 + \
offset3 <= fillRange.to.row;\n        case \"left\":\n          return \
current2.col - offset3 >= fillRange.from.column;\n        case \"right\":\n   \
       return current2.col + current2.colspan - 1 + offset3 <= \
fillRange.to.column;\n        default:\n          return null;\n      }\n    \
};\n    let fillOffset = 0;\n    let current = null;\n    let multiplier = \
1;\n    do {\n      for (let j = 0; j < foundMergedCells.length; j += 1) {\n  \
      current = foundMergedCells[j];\n        fillOffset = multiplier * \
this.currentFillData.cycleLength;\n        if (inBounds(current, fillOffset)) \
{\n          switch (dragDirection) {\n            case \"up\":\n             \
 this.plugin.mergedCellsCollection.add({\n                row: current.row - \
fillOffset,\n                rowspan: current.rowspan,\n                col: \
current.col,\n                colspan: current.colspan\n              });\n   \
           break;\n            case \"down\":\n              \
this.plugin.mergedCellsCollection.add({\n                row: current.row + \
fillOffset,\n                rowspan: current.rowspan,\n                col: \
current.col,\n                colspan: current.colspan\n              });\n   \
           break;\n            case \"left\":\n              \
this.plugin.mergedCellsCollection.add({\n                row: current.row,\n  \
              rowspan: current.rowspan,\n                col: current.col - \
fillOffset,\n                colspan: current.colspan\n              });\n    \
          break;\n            case \"right\":\n              \
this.plugin.mergedCellsCollection.add({\n                row: current.row,\n  \
              rowspan: current.rowspan,\n                col: current.col + \
fillOffset,\n                colspan: current.colspan\n              });\n    \
          break;\n            default:\n          }\n        }\n        if (j \
=== foundMergedCells.length - 1) {\n          multiplier += 1;\n        }\n   \
   }\n    } while (inBounds(current, fillOffset));\n    this.currentFillData \
= null;\n    this.plugin.hot.render();\n    if (foundMergedCells.length > 0) \
{\n      this.plugin.ifChromeForceRepaint();\n    }\n  }\n  /**\n   * Get the \
drag range from the changes made.\n   *\n   * @private\n   * @param {Array} \
changes The changes made.\n   * @returns {object} Object with `from` and `to` \
properties, both containing `row` and `column` keys.\n   */\n  \
getRangeFromChanges(changes) {\n    const rows = {\n      min: null,\n      \
max: null\n    };\n    const columns = {\n      min: null,\n      max: null\n \
   };\n    arrayEach(changes, (change) => {\n      const rowIndex = \
change[0];\n      const columnIndex = this.plugin.hot.propToCol(change[1]);\n \
     if (rows.min === null || rowIndex < rows.min) {\n        rows.min = \
rowIndex;\n      }\n      if (rows.max === null || rowIndex > rows.max) {\n   \
     rows.max = rowIndex;\n      }\n      if (columns.min === null || \
columnIndex < columns.min) {\n        columns.min = columnIndex;\n      }\n   \
   if (columns.max === null || columnIndex > columns.max) {\n        \
columns.max = columnIndex;\n      }\n    });\n    return {\n      from: {\n   \
     row: rows.min,\n        column: columns.min\n      },\n      to: {\n     \
   row: rows.max,\n        column: columns.max\n      }\n    };\n  }\n  /**\n \
  * Check if the drag area contains any merged cells.\n   *\n   * @param \
{Array} baseArea The base selection area.\n   * @param {Array} fullArea The \
base area extended by the drag area.\n   * @param {string} direction Drag \
direction.\n   * @returns {boolean}\n   */\n  \
dragAreaOverlapsCollections(baseArea, fullArea, direction) {\n    const \
dragArea = this.getDragArea(baseArea, fullArea, direction);\n    const \
[dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = \
dragArea;\n    const topLeft = \
this.plugin.hot._createCellCoords(dragAreaStartRow, dragAreaStartColumn);\n   \
 const bottomRight = this.plugin.hot._createCellCoords(dragAreaEndRow, \
dragAreaEndColumn);\n    const dragRange = \
this.plugin.hot._createCellRange(topLeft, topLeft, bottomRight);\n    return \
!!this.mergedCellsCollection.getWithinRange(dragRange, true);\n  }\n};\nvar \
autofill_default = AutofillCalculations;\n\n// \
node_modules/handsontable/plugins/mergeCells/calculations/selection.mjs\nvar \
SelectionCalculations = class {\n  constructor(plugin) {\n    this.plugin = \
plugin;\n    this.hot = plugin.hot;\n    \
this.fullySelectedMergedCellClassName = \"fullySelectedMergedCell\";\n  }\n  \
/**\n   * \"Snap\" the delta value according to defined merged cells. (In \
other words, compensate the rowspan -\n   * e.g. Going up with `delta.row = \
-1` over a merged cell with `rowspan = 3`, `delta.row` should change to \
`-3`.).\n   *\n   * @param {object} delta The delta object containing `row` \
and `col` properties.\n   * @param {CellRange} selectionRange The selection \
range.\n   * @param {object} mergedCell A merged cell object.\n   */\n  \
snapDelta(delta, selectionRange, mergedCell) {\n    const cellCoords = \
selectionRange.to;\n    const newRow = cellCoords.row + delta.row;\n    const \
newColumn = cellCoords.col + delta.col;\n    if (delta.row) {\n      \
this.jumpOverMergedCell(delta, mergedCell, newRow);\n    } else if \
(delta.col) {\n      this.jumpOverMergedCell(delta, mergedCell, newColumn);\n \
   }\n  }\n  /**\n   * \"Jump\" over the merged cell (compensate for the \
indexes within the merged cell to get past it).\n   *\n   * @private\n   * \
@param {object} delta The delta object.\n   * @param {MergedCellCoords} \
mergedCell The merge cell object.\n   * @param {number} newIndex New \
row/column index, created with the delta.\n   */\n  jumpOverMergedCell(delta, \
mergedCell, newIndex) {\n    let flatDelta = delta.row || delta.col;\n    let \
includesIndex = null;\n    let firstIndex = null;\n    let lastIndex = \
null;\n    if (delta.row) {\n      includesIndex = \
mergedCell.includesVertically(newIndex);\n      firstIndex = \
mergedCell.row;\n      lastIndex = mergedCell.getLastRow();\n    } else if \
(delta.col) {\n      includesIndex = \
mergedCell.includesHorizontally(newIndex);\n      firstIndex = \
mergedCell.col;\n      lastIndex = mergedCell.getLastColumn();\n    }\n    if \
(flatDelta === 0) {\n      return;\n    } else if (flatDelta > 0) {\n      if \
(includesIndex && newIndex !== firstIndex) {\n        flatDelta += lastIndex \
- newIndex + 1;\n      }\n    } else if (includesIndex && newIndex !== \
lastIndex) {\n      flatDelta -= newIndex - firstIndex + 1;\n    }\n    if \
(delta.row) {\n      delta.row = flatDelta;\n    } else if (delta.col) {\n    \
  delta.col = flatDelta;\n    }\n  }\n  /**\n   * Get a selection range with \
`to` property incremented by the provided delta.\n   *\n   * @param \
{CellRange} oldSelectionRange The base selection range.\n   * @param {object} \
delta The delta object with `row` and `col` properties.\n   * @returns \
{CellRange} A new `CellRange` object.\n   */\n  \
getUpdatedSelectionRange(oldSelectionRange, delta) {\n    return \
this.hot._createCellRange(oldSelectionRange.highlight, \
oldSelectionRange.from, this.hot._createCellCoords(oldSelectionRange.to.row + \
delta.row, oldSelectionRange.to.col + delta.col));\n  }\n  /**\n   * Generate \
an additional class name for the entirely-selected merged cells.\n   *\n   * \
@param {number} currentRow Visual row index of the currently processed \
cell.\n   * @param {number} currentColumn Visual column index of the \
currently cell.\n   * @param {Array} cornersOfSelection Array of the current \
selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n   * \
@param {number|undefined} layerLevel Number indicating which layer of \
selection is currently processed.\n   * @returns {string|undefined} A \
`String`, which will act as an additional `className` to be added to the \
currently processed cell.\n   */\n  \
getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, \
layerLevel) {\n    const startRow = Math.min(cornersOfSelection[0], \
cornersOfSelection[2]);\n    const startColumn = \
Math.min(cornersOfSelection[1], cornersOfSelection[3]);\n    const endRow = \
Math.max(cornersOfSelection[0], cornersOfSelection[2]);\n    const endColumn \
= Math.max(cornersOfSelection[1], cornersOfSelection[3]);\n    if (layerLevel \
=== void 0) {\n      return;\n    }\n    const isFirstRenderableMergedCell = \
this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, \
currentColumn);\n    if (!isFirstRenderableMergedCell) {\n      return;\n    \
}\n    const mergedCell = this.plugin.mergedCellsCollection.get(currentRow, \
currentColumn);\n    if (!mergedCell) {\n      return;\n    }\n    const \
mergeRowEnd = mergedCell.getLastRow();\n    const mergeColumnEnd = \
mergedCell.getLastColumn();\n    const fullMergeAreaWithinSelection = \
startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= \
mergeRowEnd && endColumn >= mergeColumnEnd;\n    if \
(fullMergeAreaWithinSelection) {\n      return \
`${this.fullySelectedMergedCellClassName}-${layerLevel}`;\n    } else if \
(this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, \
this.plugin.hot.getSelectedRange())) {\n      return \
`${this.fullySelectedMergedCellClassName}-multiple`;\n    }\n  }\n  /**\n   * \
Check if the provided merged cell is fully selected (by one or many layers of \
selection).\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell \
to be processed.\n   * @param {CellRange[]} selectionRangesArray Array of \
selection ranges.\n   * @returns {boolean}\n   */\n  \
isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n    const \
mergedCellIndividualCoords = [];\n    if (!selectionRangesArray || \
!mergedCell) {\n      return false;\n    }\n    for (let r = 0; r < \
mergedCell.rowspan; r += 1) {\n      for (let c = 0; c < mergedCell.colspan; \
c += 1) {\n        \
mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + \
r, mergedCell.col + c));\n      }\n    }\n    for (let i = 0; i < \
mergedCellIndividualCoords.length; i += 1) {\n      const insideSelections = \
[];\n      for (let s = 0; s < selectionRangesArray.length; s += 1) {\n       \
 insideSelections[s] = \
selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n      }\n   \
   if (!insideSelections.includes(true)) {\n        return false;\n      }\n  \
  }\n    return true;\n  }\n  /**\n   * Generate an array of the \
entirely-selected merged cells' class names.\n   *\n   * @returns {string[]} \
An `Array` of `String`s. Each of these strings will act like class names to \
be removed from all the cells in the table.\n   */\n  \
getSelectedMergedCellClassNameToRemove() {\n    const classNames = [];\n    \
for (let i = 0; i <= 7; i += 1) {\n      \
classNames.push(`${this.fullySelectedMergedCellClassName}-${i}`);\n    }\n    \
classNames.push(`${this.fullySelectedMergedCellClassName}-multiple`);\n    \
return classNames;\n  }\n};\nvar selection_default3 = \
SelectionCalculations;\n\n// \
node_modules/handsontable/plugins/mergeCells/contextMenuItem/toggleMerge.mjs\
\nfunction toggleMergeItem(plugin) {\n  return {\n    key: \"mergeCells\",\n  \
  name() {\n      const sel = this.getSelectedLast();\n      if (sel) {\n     \
   const info = plugin.mergedCellsCollection.get(sel[0], sel[1]);\n        if \
(info.row === sel[0] && info.col === sel[1] && info.row + info.rowspan - 1 \
=== sel[2] && info.col + info.colspan - 1 === sel[3]) {\n          return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNMERGE_CELLS);\n        }\n      \
}\n      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_MERGE_CELLS);\n    \
},\n    callback() {\n      plugin.toggleMergeOnSelection();\n    },\n    \
disabled() {\n      const sel = this.getSelectedLast();\n      if (!sel) {\n  \
      return true;\n      }\n      const isSingleCell = \
cellCoords_default.isSingleCell({\n        row: sel[0],\n        col: \
sel[1],\n        rowspan: sel[2] - sel[0] + 1,\n        colspan: sel[3] - \
sel[1] + 1\n      });\n      return isSingleCell || \
this.selection.isSelectedByCorner();\n    },\n    hidden: false\n  \
};\n}\n\n// \
node_modules/handsontable/plugins/mergeCells/mergeCells.mjs\npluginHooks_defa\
ult.getSingleton().register(\"beforeMergeCells\");\npluginHooks_default.getSi\
ngleton().register(\"afterMergeCells\");\npluginHooks_default.getSingleton().\
register(\"beforeUnmergeCells\");\npluginHooks_default.getSingleton().registe\
r(\"afterUnmergeCells\");\nvar PLUGIN_KEY25 = \"mergeCells\";\nvar \
PLUGIN_PRIORITY24 = 150;\nvar privatePool19 = /* @__PURE__ */ new \
WeakMap();\nvar SHORTCUTS_GROUP8 = PLUGIN_KEY25;\nvar MergeCells = class \
extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY25;\n \
 }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY24;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    \
privatePool19.set(this, {\n      lastDesiredCoords: null\n    });\n    \
this.mergedCellsCollection = null;\n    this.autofillCalculations = null;\n   \
 this.selectionCalculations = null;\n  }\n  /**\n   * Checks if the plugin is \
enabled in the handsontable settings. This method is executed in {@link \
Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link \
MergeCells#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   \
*/\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY25];\n  \
}\n  /**\n   * Enables the plugin functionality for this Handsontable \
instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if \
(this.enabled) {\n      return;\n    }\n    this.mergedCellsCollection = new \
cellsCollection_default(this);\n    this.autofillCalculations = new \
autofill_default(this);\n    this.selectionCalculations = new \
selection_default3(this);\n    this.addHook(\"afterInit\", function() {\n     \
 return _this.onAfterInit(...arguments);\n    });\n    \
this.addHook(\"modifyTransformStart\", function() {\n      return \
_this.onModifyTransformStart(...arguments);\n    });\n    \
this.addHook(\"afterModifyTransformStart\", function() {\n      return \
_this.onAfterModifyTransformStart(...arguments);\n    });\n    \
this.addHook(\"modifyTransformEnd\", function() {\n      return \
_this.onModifyTransformEnd(...arguments);\n    });\n    \
this.addHook(\"modifyGetCellCoords\", function() {\n      return \
_this.onModifyGetCellCoords(...arguments);\n    });\n    \
this.addHook(\"beforeSetRangeStart\", function() {\n      return \
_this.onBeforeSetRangeStart(...arguments);\n    });\n    \
this.addHook(\"beforeSetRangeStartOnly\", function() {\n      return \
_this.onBeforeSetRangeStart(...arguments);\n    });\n    \
this.addHook(\"beforeSetRangeEnd\", function() {\n      return \
_this.onBeforeSetRangeEnd(...arguments);\n    });\n    \
this.addHook(\"afterIsMultipleSelection\", function() {\n      return \
_this.onAfterIsMultipleSelection(...arguments);\n    });\n    \
this.addHook(\"afterRenderer\", function() {\n      return \
_this.onAfterRenderer(...arguments);\n    });\n    \
this.addHook(\"afterContextMenuDefaultOptions\", function() {\n      return \
_this.addMergeActionsToContextMenu(...arguments);\n    });\n    \
this.addHook(\"afterGetCellMeta\", function() {\n      return \
_this.onAfterGetCellMeta(...arguments);\n    });\n    \
this.addHook(\"afterViewportRowCalculatorOverride\", function() {\n      \
return _this.onAfterViewportRowCalculatorOverride(...arguments);\n    });\n   \
 this.addHook(\"afterViewportColumnCalculatorOverride\", function() {\n      \
return _this.onAfterViewportColumnCalculatorOverride(...arguments);\n    \
});\n    this.addHook(\"modifyAutofillRange\", function() {\n      return \
_this.onModifyAutofillRange(...arguments);\n    });\n    \
this.addHook(\"afterCreateCol\", function() {\n      return \
_this.onAfterCreateCol(...arguments);\n    });\n    \
this.addHook(\"afterRemoveCol\", function() {\n      return \
_this.onAfterRemoveCol(...arguments);\n    });\n    \
this.addHook(\"afterCreateRow\", function() {\n      return \
_this.onAfterCreateRow(...arguments);\n    });\n    \
this.addHook(\"afterRemoveRow\", function() {\n      return \
_this.onAfterRemoveRow(...arguments);\n    });\n    \
this.addHook(\"afterChange\", function() {\n      return \
_this.onAfterChange(...arguments);\n    });\n    \
this.addHook(\"beforeDrawBorders\", function() {\n      return \
_this.onBeforeDrawAreaBorders(...arguments);\n    });\n    \
this.addHook(\"afterDrawSelection\", function() {\n      return \
_this.onAfterDrawSelection(...arguments);\n    });\n    \
this.addHook(\"beforeRemoveCellClassNames\", function() {\n      return \
_this.onBeforeRemoveCellClassNames(...arguments);\n    });\n    \
this.addHook(\"beforeUndoStackChange\", (action, source) => {\n      if \
(source === \"MergeCells\") {\n        return false;\n      }\n    });\n    \
this.registerShortcuts();\n    super.enablePlugin();\n  }\n  /**\n   * \
Disables the plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    this.clearCollections();\n    \
this.unregisterShortcuts();\n    this.hot.render();\n    \
super.disablePlugin();\n  }\n  /**\n   * Updates the plugin's state.\n   *\n  \
 * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of \
the\n   * following configuration options:\n   *  - \
[`mergeCells`](@/api/options.md#mergecells)\n   */\n  updatePlugin() {\n    \
const settings = this.hot.getSettings()[PLUGIN_KEY25];\n    \
this.disablePlugin();\n    this.enablePlugin();\n    \
this.generateFromSettings(settings);\n    super.updatePlugin();\n  }\n  /**\n \
  * If the browser is recognized as Chrome, force an additional repaint to \
prevent showing the effects of a Chrome bug.\n   *\n   * Issue described in \
https://github.com/handsontable/dev-handsontable/issues/521.\n   *\n   * \
@private\n   */\n  ifChromeForceRepaint() {\n    if (!isChrome()) {\n      \
return;\n    }\n    const rowsToRefresh = [];\n    let rowIndexesToRefresh = \
[];\n    this.mergedCellsCollection.mergedCells.forEach((mergedCell) => {\n   \
   const {\n        row,\n        rowspan\n      } = mergedCell;\n      for \
(let r = row + 1; r < row + rowspan; r++) {\n        \
rowIndexesToRefresh.push(r);\n      }\n    });\n    rowIndexesToRefresh = \
[...new Set(rowIndexesToRefresh)];\n    \
rowIndexesToRefresh.forEach((rowIndex) => {\n      const renderableRowIndex = \
this.hot.rowIndexMapper.getRenderableFromVisualIndex(rowIndex);\n      \
this.hot.view._wt.wtOverlays.getOverlays(true).map((overlay) => (overlay === \
null || overlay === void 0 ? void 0 : overlay.name) === \"master\" ? overlay \
: overlay.clone.wtTable).forEach((wtTableRef) => {\n        const \
rowToRefresh = wtTableRef.getRow(renderableRowIndex);\n        if \
(rowToRefresh) {\n          rowToRefresh.style.background = \
getStyle(rowToRefresh, \"backgroundColor\").replace(\")\", \", 0.99)\");\n    \
      rowsToRefresh.push(rowToRefresh);\n        }\n      });\n    });\n    \
this.hot._registerTimeout(() => {\n      rowsToRefresh.forEach((rowElement) \
=> {\n        rowElement.style.background = getStyle(rowElement, \
\"backgroundColor\").replace(\", 0.99)\", \")\");\n      });\n    }, 1);\n  \
}\n  /**\n   * Validates a single setting object, represented by a single \
merged cell information object.\n   *\n   * @private\n   * @param {object} \
setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n   \
* @returns {boolean}\n   */\n  validateSetting(setting) {\n    let valid = \
true;\n    if (!setting) {\n      return false;\n    }\n    if \
(cellCoords_default.containsNegativeValues(setting)) {\n      \
warn(cellCoords_default.NEGATIVE_VALUES_WARNING(setting));\n      valid = \
false;\n    } else if (cellCoords_default.isOutOfBounds(setting, \
this.hot.countRows(), this.hot.countCols())) {\n      \
warn(cellCoords_default.IS_OUT_OF_BOUNDS_WARNING(setting));\n      valid = \
false;\n    } else if (cellCoords_default.isSingleCell(setting)) {\n      \
warn(cellCoords_default.IS_SINGLE_CELL(setting));\n      valid = false;\n    \
} else if (cellCoords_default.containsZeroSpan(setting)) {\n      \
warn(cellCoords_default.ZERO_SPAN_WARNING(setting));\n      valid = false;\n  \
  }\n    return valid;\n  }\n  /**\n   * Generates the merged cells from the \
settings provided to the plugin.\n   *\n   * @private\n   * @param \
{Array|boolean} settings The settings provided to the plugin.\n   */\n  \
generateFromSettings(settings) {\n    if (Array.isArray(settings)) {\n      \
const populatedNulls = [];\n      arrayEach(settings, (setting) => {\n        \
if (!this.validateSetting(setting)) {\n          return;\n        }\n        \
const highlight = this.hot._createCellCoords(setting.row, setting.col);\n     \
   const rangeEnd = this.hot._createCellCoords(setting.row + setting.rowspan \
- 1, setting.col + setting.colspan - 1);\n        const mergeRange = \
this.hot._createCellRange(highlight, highlight, rangeEnd);\n        \
this.mergeRange(mergeRange, true, true);\n        rangeEach(setting.row, \
setting.row + setting.rowspan - 1, (rowIndex) => {\n          \
rangeEach(setting.col, setting.col + setting.colspan - 1, (columnIndex) => \
{\n            if ((rowIndex === setting.row && columnIndex === setting.col) \
=== false) {\n              populatedNulls.push([rowIndex, columnIndex, \
null]);\n            }\n          });\n        });\n      });\n      if \
(populatedNulls.length === 0) {\n        return;\n      }\n      \
this.hot.setDataAtCell(populatedNulls);\n    }\n  }\n  /**\n   * Clears the \
merged cells from the merged cell container.\n   */\n  clearCollections() {\n \
   this.mergedCellsCollection.clear();\n  }\n  /**\n   * Returns `true` if a \
range is mergeable.\n   *\n   * @private\n   * @param {object} \
newMergedCellInfo Merged cell information object to test.\n   * @param \
{boolean} [auto=false] `true` if triggered at initialization.\n   * @returns \
{boolean}\n   */\n  canMergeRange(newMergedCellInfo) {\n    let auto = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    \
return auto ? true : this.validateSetting(newMergedCellInfo);\n  }\n  /**\n   \
* Merge or unmerge, based on last selected range.\n   *\n   * @private\n   \
*/\n  toggleMergeOnSelection() {\n    const currentRange = \
this.hot.getSelectedRangeLast();\n    if (!currentRange) {\n      return;\n   \
 }\n    currentRange.setDirection(this.hot.isRtl() ? \"NE-SW\" : \
\"NW-SE\");\n    const {\n      from,\n      to\n    } = currentRange;\n    \
this.toggleMerge(currentRange);\n    this.hot.selectCell(from.row, from.col, \
to.row, to.col, false);\n  }\n  /**\n   * Merges the selection provided as a \
cell range.\n   *\n   * @param {CellRange} [cellRange] Selection cell \
range.\n   */\n  mergeSelection() {\n    let cellRange = arguments.length > 0 \
&& arguments[0] !== void 0 ? arguments[0] : \
this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      return;\n    \
}\n    cellRange.setDirection(this.hot.isRtl() ? \"NE-SW\" : \"NW-SE\");\n    \
const {\n      from,\n      to\n    } = cellRange;\n    \
this.unmergeRange(cellRange, true);\n    this.mergeRange(cellRange);\n    \
this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n  /**\n \
  * Unmerges the selection provided as a cell range.\n   *\n   * @param \
{CellRange} [cellRange] Selection cell range.\n   */\n  unmergeSelection() \
{\n    let cellRange = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      \
return;\n    }\n    const {\n      from,\n      to\n    } = cellRange;\n    \
this.unmergeRange(cellRange, true);\n    this.hot.selectCell(from.row, \
from.col, to.row, to.col, false);\n  }\n  /**\n   * Merges cells in the \
provided cell range.\n   *\n   * @private\n   * @param {CellRange} cellRange \
Cell range to merge.\n   * @param {boolean} [auto=false] `true` if is called \
automatically, e.g. At initialization.\n   * @param {boolean} \
[preventPopulation=false] `true`, if the method should not run \
`populateFromArray` at the end,\n   *   but rather return its arguments.\n   \
* @returns {Array|boolean} Returns an array of [row, column, \
dataUnderCollection] if preventPopulation is set to\n   *   true. If the the \
merging process went successful, it returns `true`, otherwise - `false`.\n   \
* @fires Hooks#beforeMergeCells\n   * @fires Hooks#afterMergeCells\n   */\n  \
mergeRange(cellRange) {\n    let auto = arguments.length > 1 && arguments[1] \
!== void 0 ? arguments[1] : false;\n    let preventPopulation = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    \
const topStart = cellRange.getTopStartCorner();\n    const bottomEnd = \
cellRange.getBottomEndCorner();\n    const mergeParent = {\n      row: \
topStart.row,\n      col: topStart.col,\n      rowspan: bottomEnd.row - \
topStart.row + 1,\n      colspan: bottomEnd.col - topStart.col + 1\n    };\n  \
  const clearedData = [];\n    let populationInfo = null;\n    if \
(!this.canMergeRange(mergeParent, auto)) {\n      return false;\n    }\n    \
this.hot.runHooks(\"beforeMergeCells\", cellRange, auto);\n    rangeEach(0, \
mergeParent.rowspan - 1, (i) => {\n      rangeEach(0, mergeParent.colspan - \
1, (j) => {\n        let clearedValue = null;\n        if (!clearedData[i]) \
{\n          clearedData[i] = [];\n        }\n        if (i === 0 && j === 0) \
{\n          clearedValue = \
this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(mergeParent.row), \
this.hot.toPhysicalColumn(mergeParent.col));\n        } else {\n          \
this.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, \"hidden\", \
true);\n        }\n        clearedData[i][j] = clearedValue;\n      });\n    \
});\n    this.hot.setCellMeta(mergeParent.row, mergeParent.col, \"spanned\", \
true);\n    const mergedCellAdded = \
this.mergedCellsCollection.add(mergeParent);\n    if (mergedCellAdded) {\n    \
  if (preventPopulation) {\n        populationInfo = [mergeParent.row, \
mergeParent.col, clearedData];\n      } else {\n        \
this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, \
void 0, void 0, this.pluginName);\n      }\n      if (!auto) {\n        \
this.ifChromeForceRepaint();\n      }\n      \
this.hot.runHooks(\"afterMergeCells\", cellRange, mergeParent, auto);\n      \
return populationInfo;\n    }\n    return true;\n  }\n  /**\n   * Unmerges \
the selection provided as a cell range. If no cell range is provided, it uses \
the current selection.\n   *\n   * @private\n   * @param {CellRange} \
cellRange Selection cell range.\n   * @param {boolean} [auto=false] `true` if \
called automatically by the plugin.\n   *\n   * @fires \
Hooks#beforeUnmergeCells\n   * @fires Hooks#afterUnmergeCells\n   */\n  \
unmergeRange(cellRange) {\n    let auto = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : false;\n    const mergedCells = \
this.mergedCellsCollection.getWithinRange(cellRange);\n    if (!mergedCells) \
{\n      return;\n    }\n    this.hot.runHooks(\"beforeUnmergeCells\", \
cellRange, auto);\n    arrayEach(mergedCells, (currentCollection) => {\n      \
this.mergedCellsCollection.remove(currentCollection.row, \
currentCollection.col);\n      rangeEach(0, currentCollection.rowspan - 1, \
(i) => {\n        rangeEach(0, currentCollection.colspan - 1, (j) => {\n      \
    this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col \
+ j, \"hidden\");\n          this.hot.removeCellMeta(currentCollection.row + \
i, currentCollection.col + j, \"copyable\");\n        });\n      });\n      \
this.hot.removeCellMeta(currentCollection.row, currentCollection.col, \
\"spanned\");\n    });\n    this.hot.runHooks(\"afterUnmergeCells\", \
cellRange, auto);\n    this.hot.render();\n  }\n  /**\n   * Merges or \
unmerges, based on the cell range provided as `cellRange`.\n   *\n   * \
@private\n   * @param {CellRange} cellRange The cell range to merge or \
unmerged.\n   */\n  toggleMerge(cellRange) {\n    const mergedCell = \
this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n    \
const mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && \
mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan \
- 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === \
cellRange.to.col;\n    if (mergedCellCoversWholeRange) {\n      \
this.unmergeRange(cellRange);\n    } else {\n      \
this.mergeSelection(cellRange);\n    }\n  }\n  /**\n   * Merges the specified \
range.\n   *\n   * @param {number} startRow Start row of the merged cell.\n   \
* @param {number} startColumn Start column of the merged cell.\n   * @param \
{number} endRow End row of the merged cell.\n   * @param {number} endColumn \
End column of the merged cell.\n   * @fires Hooks#beforeMergeCells\n   * \
@fires Hooks#afterMergeCells\n   */\n  merge(startRow, startColumn, endRow, \
endColumn) {\n    const start = this.hot._createCellCoords(startRow, \
startColumn);\n    const end = this.hot._createCellCoords(endRow, \
endColumn);\n    this.mergeRange(this.hot._createCellRange(start, start, \
end));\n  }\n  /**\n   * Unmerges the merged cell in the provided range.\n   \
*\n   * @param {number} startRow Start row of the merged cell.\n   * @param \
{number} startColumn Start column of the merged cell.\n   * @param {number} \
endRow End row of the merged cell.\n   * @param {number} endColumn End column \
of the merged cell.\n   * @fires Hooks#beforeUnmergeCells\n   * @fires \
Hooks#afterUnmergeCells\n   */\n  unmerge(startRow, startColumn, endRow, \
endColumn) {\n    const start = this.hot._createCellCoords(startRow, \
startColumn);\n    const end = this.hot._createCellCoords(endRow, \
endColumn);\n    this.unmergeRange(this.hot._createCellRange(start, start, \
end));\n  }\n  /**\n   * `afterInit` hook callback.\n   *\n   * @private\n   \
*/\n  onAfterInit() {\n    \
this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY25]);\n    \
this.hot.render();\n  }\n  /**\n   * Register shortcuts responsible for \
toggling a merge.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    \
const shortcutManager = this.hot.getShortcutManager();\n    const gridContext \
= shortcutManager.getContext(\"grid\");\n    gridContext.addShortcut({\n      \
keys: [[\"Control\", \"m\"]],\n      callback: () => {\n        \
this.toggleMerge(this.hot.getSelectedRangeLast());\n        \
this.hot.render();\n      },\n      runOnlyIf: (event2) => !event2.altKey,\n  \
    // right ALT in some systems triggers ALT+CTRL\n      group: \
SHORTCUTS_GROUP8\n    });\n  }\n  /**\n   * Unregister shortcuts responsible \
for toggling a merge.\n   *\n   * @private\n   */\n  unregisterShortcuts() \
{\n    const shortcutManager = this.hot.getShortcutManager();\n    const \
gridContext = shortcutManager.getContext(\"grid\");\n    \
gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP8);\n  }\n  /**\n   * \
Modifies the information on whether the current selection contains multiple \
cells. The `afterIsMultipleSelection`\n   * hook callback.\n   *\n   * \
@private\n   * @param {boolean} isMultiple Determines whether the current \
selection contains multiple cells.\n   * @returns {boolean}\n   */\n  \
onAfterIsMultipleSelection(isMultiple) {\n    if (isMultiple) {\n      const \
mergedCells = this.mergedCellsCollection.mergedCells;\n      const \
selectionRange = this.hot.getSelectedRangeLast();\n      for (let group = 0; \
group < mergedCells.length; group += 1) {\n        if \
(selectionRange.from.row === mergedCells[group].row && \
selectionRange.from.col === mergedCells[group].col && selectionRange.to.row \
=== mergedCells[group].row + mergedCells[group].rowspan - 1 && \
selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan \
- 1) {\n          return false;\n        }\n      }\n    }\n    return \
isMultiple;\n  }\n  /**\n   * `modifyTransformStart` hook callback.\n   *\n   \
* @private\n   * @param {object} delta The transformation delta.\n   */\n  \
onModifyTransformStart(delta) {\n    const priv = privatePool19.get(this);\n  \
  const currentlySelectedRange = this.hot.getSelectedRangeLast();\n    let \
newDelta = {\n      row: delta.row,\n      col: delta.col\n    };\n    let \
nextPosition = null;\n    const currentPosition = \
this.hot._createCellCoords(currentlySelectedRange.highlight.row, \
currentlySelectedRange.highlight.col);\n    const mergedParent = \
this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n   \
 if (!priv.lastDesiredCoords) {\n      priv.lastDesiredCoords = \
this.hot._createCellCoords(null, null);\n    }\n    if (mergedParent) {\n     \
 const mergeTopLeft = this.hot._createCellCoords(mergedParent.row, \
mergedParent.col);\n      const mergeBottomRight = \
this.hot._createCellCoords(mergedParent.row + mergedParent.rowspan - 1, \
mergedParent.col + mergedParent.colspan - 1);\n      const mergeRange = \
this.hot._createCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n    \
  if (!mergeRange.includes(priv.lastDesiredCoords)) {\n        \
priv.lastDesiredCoords = this.hot._createCellCoords(null, null);\n      }\n   \
   newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - \
currentPosition.row : newDelta.row;\n      newDelta.col = \
priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col \
: newDelta.col;\n      if (delta.row > 0) {\n        newDelta.row = \
mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + \
delta.row;\n      } else if (delta.row < 0) {\n        newDelta.row = \
currentPosition.row - mergedParent.row + delta.row;\n      }\n      if \
(delta.col > 0) {\n        newDelta.col = mergedParent.col + \
mergedParent.colspan - 1 - currentPosition.col + delta.col;\n      } else if \
(delta.col < 0) {\n        newDelta.col = currentPosition.col - \
mergedParent.col + delta.col;\n      }\n    }\n    nextPosition = \
this.hot._createCellCoords(currentlySelectedRange.highlight.row + \
newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n    \
const nextPositionMergedCell = \
this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n    if \
(nextPositionMergedCell) {\n      const firstRenderableCoords = \
this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.ro\
w, nextPositionMergedCell.col);\n      priv.lastDesiredCoords = \
nextPosition;\n      newDelta = {\n        row: firstRenderableCoords.row - \
currentPosition.row,\n        col: firstRenderableCoords.col - \
currentPosition.col\n      };\n    }\n    if (newDelta.row !== 0) {\n      \
delta.row = newDelta.row;\n    }\n    if (newDelta.col !== 0) {\n      \
delta.col = newDelta.col;\n    }\n  }\n  /**\n   * `modifyTransformEnd` hook \
callback. Needed to handle \"jumping over\" merged merged cells, while \
selecting.\n   *\n   * @private\n   * @param {object} delta The \
transformation delta.\n   */\n  onModifyTransformEnd(delta) {\n    const \
currentSelectionRange = this.hot.getSelectedRangeLast();\n    const newDelta \
= clone(delta);\n    const newSelectionRange = \
this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, \
delta);\n    let tempDelta = clone(newDelta);\n    const \
mergedCellsWithinRange = \
this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n    do \
{\n      tempDelta = clone(newDelta);\n      \
this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, \
newDelta);\n      arrayEach(mergedCellsWithinRange, (mergedCell) => {\n       \
 this.selectionCalculations.snapDelta(newDelta, currentSelectionRange, \
mergedCell);\n      });\n    } while (newDelta.row !== tempDelta.row || \
newDelta.col !== tempDelta.col);\n    delta.row = newDelta.row;\n    \
delta.col = newDelta.col;\n  }\n  /**\n   * `modifyGetCellCoords` hook \
callback. Swaps the `getCell` coords with the merged parent coords.\n   *\n   \
* @private\n   * @param {number} row Row index.\n   * @param {number} column \
Visual column index.\n   * @returns {Array|undefined} Visual coordinates of \
the merge.\n   */\n  onModifyGetCellCoords(row, column) {\n    if (row < 0 || \
column < 0) {\n      return;\n    }\n    const mergeParent = \
this.mergedCellsCollection.get(row, column);\n    if (!mergeParent) {\n      \
return;\n    }\n    const {\n      row: mergeRow,\n      col: mergeColumn,\n  \
    colspan,\n      rowspan\n    } = mergeParent;\n    return [\n      // \
Most top-left merged cell coords.\n      mergeRow,\n      mergeColumn,\n      \
// Most bottom-right merged cell coords.\n      mergeRow + rowspan - 1,\n     \
 mergeColumn + colspan - 1\n    ];\n  }\n  /**\n   * \
`afterContextMenuDefaultOptions` hook callback.\n   *\n   * @private\n   * \
@param {object} defaultOptions The default context menu options.\n   */\n  \
addMergeActionsToContextMenu(defaultOptions) {\n    \
defaultOptions.items.push({\n      name: \"---------\"\n    }, \
toggleMergeItem(this));\n  }\n  /**\n   * `afterRenderer` hook callback.\n   \
*\n   * @private\n   * @param {HTMLElement} TD The cell to be modified.\n   * \
@param {number} row Row index.\n   * @param {number} col Visual column \
index.\n   */\n  onAfterRenderer(TD, row, col) {\n    const mergedCell = \
this.mergedCellsCollection.get(row, col);\n    const mergedCellCopy = \
isObject(mergedCell) ? clone(mergedCell) : void 0;\n    if \
(isObject(mergedCellCopy)) {\n      const {\n        rowIndexMapper: \
rowMapper,\n        columnIndexMapper: columnMapper\n      } = this.hot;\n    \
  const {\n        row: mergeRow,\n        col: mergeColumn,\n        \
colspan,\n        rowspan\n      } = mergedCellCopy;\n      const \
[lastMergedRowIndex, lastMergedColumnIndex] = \
this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, \
colspan);\n      const renderedRowIndex = \
rowMapper.getRenderableFromVisualIndex(row);\n      const renderedColumnIndex \
= columnMapper.getRenderableFromVisualIndex(col);\n      const maxRowSpan = \
lastMergedRowIndex - renderedRowIndex + 1;\n      const maxColSpan = \
lastMergedColumnIndex - renderedColumnIndex + 1;\n      mergedCellCopy.row = \
rowMapper.getNearestNotHiddenIndex(mergedCellCopy.row, 1);\n      \
mergedCellCopy.col = \
columnMapper.getNearestNotHiddenIndex(mergedCellCopy.col, 1);\n      \
mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan);\n      \
mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);\n    \
}\n    applySpanProperties(TD, mergedCellCopy, row, col);\n  }\n  /**\n   * \
`beforeSetRangeStart` and `beforeSetRangeStartOnly` hook callback.\n   * A \
selection within merge area should be rewritten to the start of merge area.\n \
  *\n   * @private\n   * @param {object} coords Cell coords.\n   */\n  \
onBeforeSetRangeStart(coords) {\n    if \
(this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, \
coords.col)) {\n      const mergeParent = \
this.mergedCellsCollection.get(coords.row, coords.col);\n      [coords.row, \
coords.col] = [mergeParent.row, mergeParent.col];\n    }\n  }\n  /**\n   * \
`beforeSetRangeEnd` hook callback.\n   * While selecting cells with keyboard \
or mouse, make sure that rectangular area is expanded to the extent of the\n  \
 * merged cell.\n   *\n   * Note: Please keep in mind that callback may \
modify both start and end range coordinates by the reference.\n   *\n   * \
@private\n   * @param {object} coords Cell coords.\n   */\n  \
onBeforeSetRangeEnd(coords) {\n    const selRange = \
this.hot.getSelectedRangeLast();\n    selRange.highlight = \
this.hot._createCellCoords(selRange.highlight.row, selRange.highlight.col);\n \
   selRange.to = coords;\n    let rangeExpanded = false;\n    if \
(this.hot.selection.isSelectedByColumnHeader() || \
this.hot.selection.isSelectedByRowHeader()) {\n      return;\n    }\n    do \
{\n      rangeExpanded = false;\n      for (let i = 0; i < \
this.mergedCellsCollection.mergedCells.length; i += 1) {\n        const \
cellInfo = this.mergedCellsCollection.mergedCells[i];\n        const \
mergedCellRange = cellInfo.getRange();\n        if \
(selRange.expandByRange(mergedCellRange)) {\n          coords.row = \
selRange.to.row;\n          coords.col = selRange.to.col;\n          \
rangeExpanded = true;\n        }\n      }\n    } while (rangeExpanded);\n  \
}\n  /**\n   * The `afterGetCellMeta` hook callback.\n   *\n   * @private\n   \
* @param {number} row Row index.\n   * @param {number} col Column index.\n   \
* @param {object} cellProperties The cell properties object.\n   */\n  \
onAfterGetCellMeta(row, col, cellProperties) {\n    const mergeParent = \
this.mergedCellsCollection.get(row, col);\n    if (mergeParent) {\n      if \
(mergeParent.row !== row || mergeParent.col !== col) {\n        \
cellProperties.copyable = false;\n      } else {\n        \
cellProperties.rowspan = mergeParent.rowspan;\n        cellProperties.colspan \
= mergeParent.colspan;\n      }\n    }\n  }\n  /**\n   * \
`afterViewportRowCalculatorOverride` hook callback.\n   *\n   * @private\n   \
* @param {object} calc The row calculator object.\n   */\n  \
onAfterViewportRowCalculatorOverride(calc) {\n    const nrOfColumns = \
this.hot.countCols();\n    this.modifyViewportRowStart(calc, nrOfColumns);\n  \
  this.modifyViewportRowEnd(calc, nrOfColumns);\n  }\n  /**\n   * Modify \
viewport start when needed. We extend viewport when merged cells aren't fully \
visible.\n   *\n   * @private\n   * @param {object} calc The row calculator \
object.\n   * @param {number} nrOfColumns Number of visual columns.\n   */\n  \
modifyViewportRowStart(calc, nrOfColumns) {\n    const rowMapper = \
this.hot.rowIndexMapper;\n    const visualStartRow = \
rowMapper.getVisualFromRenderableIndex(calc.startRow);\n    for (let \
visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += \
1) {\n      const mergeParentForViewportStart = \
this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);\n      if \
(isObject(mergeParentForViewportStart)) {\n        const \
renderableIndexAtMergeStart = \
rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mer\
geParentForViewportStart.row, 1));\n        if (renderableIndexAtMergeStart < \
calc.startRow) {\n          calc.startRow = renderableIndexAtMergeStart;\n    \
      this.modifyViewportRowStart(calc, nrOfColumns);\n          return;\n    \
    }\n      }\n    }\n  }\n  /**\n   *  Modify viewport end when needed. We \
extend viewport when merged cells aren't fully visible.\n   *\n   * \
@private\n   * @param {object} calc The row calculator object.\n   * @param \
{number} nrOfColumns Number of visual columns.\n   */\n  \
modifyViewportRowEnd(calc, nrOfColumns) {\n    const rowMapper = \
this.hot.rowIndexMapper;\n    const visualEndRow = \
rowMapper.getVisualFromRenderableIndex(calc.endRow);\n    for (let \
visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += \
1) {\n      const mergeParentForViewportEnd = \
this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);\n      if \
(isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = \
mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;\n      \
  const renderableIndexAtMergeEnd = \
rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mer\
geEnd, -1));\n        if (renderableIndexAtMergeEnd > calc.endRow) {\n        \
  calc.endRow = renderableIndexAtMergeEnd;\n          \
this.modifyViewportRowEnd(calc, nrOfColumns);\n          return;\n        }\n \
     }\n    }\n  }\n  /**\n   * `afterViewportColumnCalculatorOverride` hook \
callback.\n   *\n   * @private\n   * @param {object} calc The column \
calculator object.\n   */\n  onAfterViewportColumnCalculatorOverride(calc) \
{\n    const nrOfRows = this.hot.countRows();\n    \
this.modifyViewportColumnStart(calc, nrOfRows);\n    \
this.modifyViewportColumnEnd(calc, nrOfRows);\n  }\n  /**\n   * Modify \
viewport start when needed. We extend viewport when merged cells aren't fully \
visible.\n   *\n   * @private\n   * @param {object} calc The column \
calculator object.\n   * @param {number} nrOfRows Number of visual rows.\n   \
*/\n  modifyViewportColumnStart(calc, nrOfRows) {\n    const columnMapper = \
this.hot.columnIndexMapper;\n    const visualStartCol = \
columnMapper.getVisualFromRenderableIndex(calc.startColumn);\n    for (let \
visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      \
const mergeParentForViewportStart = \
this.mergedCellsCollection.get(visualRowIndex, visualStartCol);\n      if \
(isObject(mergeParentForViewportStart)) {\n        const \
renderableIndexAtMergeStart = \
columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenInd\
ex(mergeParentForViewportStart.col, 1));\n        if \
(renderableIndexAtMergeStart < calc.startColumn) {\n          \
calc.startColumn = renderableIndexAtMergeStart;\n          \
this.modifyViewportColumnStart(calc, nrOfRows);\n          return;\n        \
}\n      }\n    }\n  }\n  /**\n   *  Modify viewport end when needed. We \
extend viewport when merged cells aren't fully visible.\n   *\n   * \
@private\n   * @param {object} calc The column calculator object.\n   * \
@param {number} nrOfRows Number of visual rows.\n   */\n  \
modifyViewportColumnEnd(calc, nrOfRows) {\n    const columnMapper = \
this.hot.columnIndexMapper;\n    const visualEndCol = \
columnMapper.getVisualFromRenderableIndex(calc.endColumn);\n    for (let \
visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      \
const mergeParentForViewportEnd = \
this.mergedCellsCollection.get(visualRowIndex, visualEndCol);\n      if \
(isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = \
mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;\n      \
  const renderableIndexAtMergeEnd = \
columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenInd\
ex(mergeEnd, -1));\n        if (renderableIndexAtMergeEnd > calc.endColumn) \
{\n          calc.endColumn = renderableIndexAtMergeEnd;\n          \
this.modifyViewportColumnEnd(calc, nrOfRows);\n          return;\n        }\n \
     }\n    }\n  }\n  /**\n   * Translates merged cell coordinates to \
renderable indexes.\n   *\n   * @private\n   * @param {number} parentRow \
Visual row index.\n   * @param {number} rowspan Rowspan which describes shift \
which will be applied to parent row\n   *                         to \
calculate renderable index which points to the most bottom\n   *              \
           index position. Pass rowspan as `0` to calculate the most top\n   \
*                         index position.\n   * @param {number} parentColumn \
Visual column index.\n   * @param {number} colspan Colspan which describes \
shift which will be applied to parent column\n   *                         to \
calculate renderable index which points to the most right\n   *               \
          index position. Pass colspan as `0` to calculate the most left\n   \
*                         index position.\n   * @returns {number[]}\n   */\n  \
translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) \
{\n    const {\n      rowIndexMapper: rowMapper,\n      columnIndexMapper: \
columnMapper\n    } = this.hot;\n    let firstNonHiddenRow;\n    let \
firstNonHiddenColumn;\n    if (rowspan === 0) {\n      firstNonHiddenRow = \
rowMapper.getNearestNotHiddenIndex(parentRow, 1);\n    } else {\n      \
firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow + rowspan - \
1, -1);\n    }\n    if (colspan === 0) {\n      firstNonHiddenColumn = \
columnMapper.getNearestNotHiddenIndex(parentColumn, 1);\n    } else {\n      \
firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn + \
colspan - 1, -1);\n    }\n    const renderableRow = parentRow >= 0 ? \
rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;\n    \
const renderableColumn = parentColumn >= 0 ? \
columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : \
parentColumn;\n    return [renderableRow, renderableColumn];\n  }\n  /**\n   \
* The `modifyAutofillRange` hook callback.\n   *\n   * @private\n   * @param \
{Array} drag The drag area coordinates.\n   * @param {Array} select The \
selection information.\n   * @returns {Array} The new drag area.\n   */\n  \
onModifyAutofillRange(drag, select) {\n    \
this.autofillCalculations.correctSelectionAreaSize(select);\n    const \
dragDirection = this.autofillCalculations.getDirection(select, drag);\n    \
let dragArea = drag;\n    if \
(this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, \
dragDirection)) {\n      dragArea = select;\n      return dragArea;\n    }\n  \
  const mergedCellsWithinSelectionArea = \
this.mergedCellsCollection.getWithinRange({\n      from: {\n        row: \
select[0],\n        col: select[1]\n      },\n      to: {\n        row: \
select[2],\n        col: select[3]\n      }\n    });\n    if \
(!mergedCellsWithinSelectionArea) {\n      return dragArea;\n    }\n    \
dragArea = this.autofillCalculations.snapDragArea(select, dragArea, \
dragDirection, mergedCellsWithinSelectionArea);\n    return dragArea;\n  }\n  \
/**\n   * `afterCreateCol` hook callback.\n   *\n   * @private\n   * @param \
{number} column Column index.\n   * @param {number} count Number of created \
columns.\n   */\n  onAfterCreateCol(column, count) {\n    \
this.mergedCellsCollection.shiftCollections(\"right\", column, count);\n  }\n \
 /**\n   * `afterRemoveCol` hook callback.\n   *\n   * @private\n   * @param \
{number} column Column index.\n   * @param {number} count Number of removed \
columns.\n   */\n  onAfterRemoveCol(column, count) {\n    \
this.mergedCellsCollection.shiftCollections(\"left\", column, count);\n  }\n  \
/**\n   * `afterCreateRow` hook callback.\n   *\n   * @private\n   * @param \
{number} row Row index.\n   * @param {number} count Number of created rows.\n \
  * @param {string} source Source of change.\n   */\n  onAfterCreateRow(row, \
count, source) {\n    if (source === \"auto\") {\n      return;\n    }\n    \
this.mergedCellsCollection.shiftCollections(\"down\", row, count);\n  }\n  \
/**\n   * `afterRemoveRow` hook callback.\n   *\n   * @private\n   * @param \
{number} row Row index.\n   * @param {number} count Number of removed rows.\n \
  */\n  onAfterRemoveRow(row, count) {\n    \
this.mergedCellsCollection.shiftCollections(\"up\", row, count);\n  }\n  \
/**\n   * `afterChange` hook callback. Used to propagate merged cells after \
using Autofill.\n   *\n   * @private\n   * @param {Array} changes The changes \
array.\n   * @param {string} source Determines the source of the change.\n   \
*/\n  onAfterChange(changes, source) {\n    if (source !== \"Autofill.fill\") \
{\n      return;\n    }\n    \
this.autofillCalculations.recreateAfterDataPopulation(changes);\n  }\n  /**\n \
  * `beforeDrawAreaBorders` hook callback.\n   *\n   * @private\n   * @param \
{Array} corners Visual coordinates of the area corners.\n   * @param {string} \
className Class name for the area.\n   */\n  onBeforeDrawAreaBorders(corners, \
className) {\n    if (className && className === \"area\") {\n      const \
selectedRange = this.hot.getSelectedRangeLast();\n      const \
mergedCellsWithinRange = \
this.mergedCellsCollection.getWithinRange(selectedRange);\n      \
arrayEach(mergedCellsWithinRange, (mergedCell) => {\n        if \
(selectedRange.getBottomEndCorner().row === mergedCell.getLastRow() && \
selectedRange.getBottomEndCorner().col === mergedCell.getLastColumn()) {\n    \
      corners[2] = mergedCell.row;\n          corners[3] = mergedCell.col;\n  \
      }\n      });\n    }\n  }\n  /**\n   * `afterModifyTransformStart` hook \
callback. Fixes a problem with navigating through merged cells at the edges \
of\n   * the table with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.\n   *\n   * \
@private\n   * @param {CellCoords} coords Coordinates of the to-be-selected \
cell.\n   * @param {number} rowTransformDir Row transformation direction \
(negative value = up, 0 = none, positive value =\n   *   down).\n   * @param \
{number} colTransformDir Column transformation direction (negative value = \
up, 0 = none, positive value =\n   *   down).\n   */\n  \
onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {\n    \
if (!this.enabled) {\n      return;\n    }\n    const mergedCellAtCoords = \
this.mergedCellsCollection.get(coords.row, coords.col);\n    if \
(!mergedCellAtCoords) {\n      return;\n    }\n    const goingDown = \
rowTransformDir > 0;\n    const goingUp = rowTransformDir < 0;\n    const \
goingLeft = colTransformDir < 0;\n    const goingRight = colTransformDir > \
0;\n    const mergedCellOnBottomEdge = mergedCellAtCoords.row + \
mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n    const \
mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n    const \
mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - \
1 === this.hot.countCols() - 1;\n    const mergedCellOnLeftEdge = \
mergedCellAtCoords.col === 0;\n    if (goingDown && mergedCellOnBottomEdge || \
goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || \
goingLeft && mergedCellOnLeftEdge) {\n      coords.row = \
mergedCellAtCoords.row;\n      coords.col = mergedCellAtCoords.col;\n    }\n  \
}\n  /**\n   * `afterDrawSelection` hook callback. Used to add the additional \
class name for the entirely-selected merged cells.\n   *\n   * @private\n   * \
@param {number} currentRow Visual row index of the currently processed \
cell.\n   * @param {number} currentColumn Visual column index of the \
currently cell.\n   * @param {Array} cornersOfSelection Array of the current \
selection in a form of `[startRow, startColumn, endRow,\n   *   \
endColumn]`.\n   * @param {number|undefined} layerLevel Number indicating \
which layer of selection is currently processed.\n   * @returns \
{string|undefined} A `String`, which will act as an additional `className` to \
be added to the currently\n   *   processed cell.\n   */\n  \
onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, \
layerLevel) {\n    if (!cornersOfSelection) {\n      return;\n    }\n    \
return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, \
currentColumn, cornersOfSelection, layerLevel);\n  }\n  /**\n   * \
`beforeRemoveCellClassNames` hook callback. Used to remove additional class \
name from all cells in the table.\n   *\n   * @private\n   * @returns \
{string[]} An `Array` of `String`s. Each of these strings will act like class \
names to be removed from\n   *   all the cells in the table.\n   */\n  \
onBeforeRemoveCellClassNames() {\n    return \
this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n  \
}\n};\n\n// \
node_modules/handsontable/plugins/multiColumnSorting/rootComparator.mjs\nfunc\
tion rootComparator2(sortingOrders, columnMetas) {\n  return \
function(rowIndexWithValues, nextRowIndexWithValues) {\n    const [, \
...values] = rowIndexWithValues;\n    const [, ...nextValues] = \
nextRowIndexWithValues;\n    return function getCompareResult(column) {\n     \
 const sortingOrder = sortingOrders[column];\n      const columnMeta = \
columnMetas[column];\n      const value = values[column];\n      const \
nextValue = nextValues[column];\n      const pluginSettings = \
columnMeta.multiColumnSorting;\n      const compareFunctionFactory5 = \
pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory \
: getCompareFunctionFactory(columnMeta.type);\n      const compareResult = \
compareFunctionFactory5(sortingOrder, columnMeta, pluginSettings)(value, \
nextValue);\n      if (compareResult === DO_NOT_SWAP) {\n        const \
nextSortedColumn = column + 1;\n        if (typeof \
columnMetas[nextSortedColumn] !== \"undefined\") {\n          return \
getCompareResult(nextSortedColumn);\n        }\n      }\n      return \
compareResult;\n    }(0);\n  };\n}\n\n// \
node_modules/handsontable/plugins/multiColumnSorting/utils.mjs\nfunction \
warnAboutPluginsConflict() {\n  warn(toSingleLine`Plugins \\`columnSorting\\` \
and \\`multiColumnSorting\\` should not be enabled simultaneously. \n    Only \
\\`multiColumnSorting\\` will work.`);\n}\n\n// \
node_modules/handsontable/plugins/multiColumnSorting/domHelpers.mjs\nvar \
COLUMN_ORDER_PREFIX = \"sort\";\nfunction \
getClassesToAdd2(columnStatesManager, column, showSortIndicator) {\n  const \
cssClasses = [];\n  if (showSortIndicator === false) {\n    return \
cssClasses;\n  }\n  if (columnStatesManager.isColumnSorted(column) && \
columnStatesManager.getNumberOfSortedColumns() > 1) {\n    \
cssClasses.push(`${COLUMN_ORDER_PREFIX}-${columnStatesManager.getIndexOfColum\
nInSortQueue(column) + 1}`);\n  }\n  return cssClasses;\n}\nfunction \
getClassesToRemove2(htmlElement) {\n  const cssClasses = \
htmlElement.className.split(\" \");\n  const sortSequenceRegExp = new \
RegExp(`^${COLUMN_ORDER_PREFIX}-[0-9]{1,2}$`);\n  return \
cssClasses.filter((cssClass) => sortSequenceRegExp.test(cssClass));\n}\n\n// \
node_modules/handsontable/plugins/multiColumnSorting/multiColumnSorting.mjs\n\
var PLUGIN_KEY26 = \"multiColumnSorting\";\nvar PLUGIN_PRIORITY25 = 170;\nvar \
APPEND_COLUMN_CONFIG_STRATEGY2 = \"append\";\nvar CONFLICTED_PLUGIN_KEY = \
\"columnSorting\";\nregisterRootComparator(PLUGIN_KEY26, \
rootComparator2);\nvar MultiColumnSorting = class extends ColumnSorting {\n  \
static get PLUGIN_KEY() {\n    return PLUGIN_KEY26;\n  }\n  static get \
PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY25;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.pluginKey = \
PLUGIN_KEY26;\n  }\n  /**\n   * Checks if the plugin is enabled in the \
Handsontable settings. This method is executed in {@link Hooks#beforeInit}\n  \
 * hook and if it returns `true` then the {@link \
MultiColumnSorting#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return super.isEnabled();\n  }\n  \
/**\n   * Enables the plugin functionality for this Handsontable instance.\n  \
 */\n  enablePlugin() {\n    if (!this.enabled && \
this.hot.getSettings()[this.pluginKey] && \
this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {\n      \
warnAboutPluginsConflict();\n    }\n    super.enablePlugin();\n  }\n  /**\n   \
* Disables the plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    super.disablePlugin();\n  }\n  /**\n   * Sorts the \
table by chosen columns and orders.\n   *\n   * @param \
{undefined|object|Array} sortConfig Single column sort configuration or full \
sort configuration (for all sorted columns).\n   * The configuration object \
contains `column` and `sortOrder` properties. First of them contains visual \
column index, the second one contains\n   * sort order (`asc` for ascending, \
`desc` for descending).\n   *\n   * **Note**: Please keep in mind that every \
call of `sort` function set an entirely new sort order. Previous sort configs \
aren't preserved.\n   *\n   * @example\n   * ```js\n   * // sort ascending \
first visual column\n   * hot.getPlugin('multiColumnSorting').sort({ column: \
0, sortOrder: 'asc' });\n   *\n   * // sort first two visual column in the \
defined sequence\n   * hot.getPlugin('multiColumnSorting').sort([{\n   *   \
column: 1, sortOrder: 'asc'\n   * }, {\n   *   column: 0, sortOrder: 'desc'\n \
  * }]);\n   * ```\n   *\n   * @fires Hooks#beforeColumnSort\n   * @fires \
Hooks#afterColumnSort\n   */\n  sort(sortConfig) {\n    \
super.sort(sortConfig);\n  }\n  /**\n   * Clear the sort performed on the \
table.\n   */\n  clearSort() {\n    super.clearSort();\n  }\n  /**\n   * \
Checks if the table is sorted (any column have to be sorted).\n   *\n   * \
@returns {boolean}\n   */\n  isSorted() {\n    return super.isSorted();\n  \
}\n  /**\n   * Get sort configuration for particular column or for all sorted \
columns. Objects contain `column` and `sortOrder` properties.\n   *\n   * \
**Note**: Please keep in mind that returned objects expose **visual** column \
index under the `column` key. They are handled by the `sort` function.\n   \
*\n   * @param {number} [column] Visual column index.\n   * @returns \
{undefined|object|Array}\n   */\n  getSortConfig(column) {\n    return \
super.getSortConfig(column);\n  }\n  /**\n   * @description\n   * Warn: \
Useful mainly for providing server side sort implementation (see in the \
example below). It doesn't sort the data set. It just sets sort configuration \
for all sorted columns.\n   * Note: Please keep in mind that this method \
doesn't re-render the table.\n   *\n   * @example\n   * ```js\n   * \
beforeColumnSort: function(currentSortConfig, destinationSortConfigs) {\n   * \
  const columnSortPlugin = this.getPlugin('multiColumnSorting');\n   *\n   *  \
 columnSortPlugin.setSortConfig(destinationSortConfigs);\n   *\n   *   // \
const newData = ... // Calculated data set, ie. from an AJAX call.\n   *\n   \
*   this.loadData(newData); // Load new data set and re-render the table.\n   \
*\n   *   return false; // The blockade for the default sort action.\n   * \
}\n   * ```\n   *\n   * @param {undefined|object|Array} sortConfig Single \
column sort configuration or full sort configuration (for all sorted \
columns).\n   * The configuration object contains `column` and `sortOrder` \
properties. First of them contains visual column index, the second one \
contains\n   * sort order (`asc` for ascending, `desc` for descending).\n   \
*/\n  setSortConfig(sortConfig) {\n    super.setSortConfig(sortConfig);\n  \
}\n  /**\n   * Get normalized sort configs.\n   *\n   * @private\n   * @param \
{object|Array} [sortConfig=[]] Single column sort configuration or full sort \
configuration (for all sorted columns).\n   * The configuration object \
contains `column` and `sortOrder` properties. First of them contains visual \
column index, the second one contains\n   * sort order (`asc` for ascending, \
`desc` for descending).\n   * @returns {Array}\n   */\n  \
getNormalizedSortConfigs() {\n    let sortConfig = arguments.length > 0 && \
arguments[0] !== void 0 ? arguments[0] : [];\n    if \
(Array.isArray(sortConfig)) {\n      return sortConfig;\n    }\n    return \
[sortConfig];\n  }\n  /**\n   * Update header classes.\n   *\n   * @private\n \
  * @param {HTMLElement} headerSpanElement Header span element.\n   * @param \
{...*} args Extra arguments for helpers.\n   */\n  \
updateHeaderClasses(headerSpanElement) {\n    for (var _len = \
arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < \
_len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    \
super.updateHeaderClasses(headerSpanElement, ...args);\n    \
removeClass(headerSpanElement, getClassesToRemove2(headerSpanElement));\n    \
if (this.enabled !== false) {\n      addClass(headerSpanElement, \
getClassesToAdd2(...args));\n    }\n  }\n  /**\n   * Overwriting base \
plugin's `onUpdateSettings` method. Please keep in mind that \
`onAfterUpdateSettings` isn't called\n   * for `updateSettings` in specific \
situations.\n   *\n   * @private\n   * @param {object} newSettings New \
settings object.\n   */\n  onUpdateSettings(newSettings) {\n    if \
(this.hot.getSettings()[this.pluginKey] && \
this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {\n      \
warnAboutPluginsConflict();\n    }\n    \
super.onUpdateSettings(newSettings);\n  }\n  /**\n   * Callback for the \
`onAfterOnCellMouseDown` hook.\n   *\n   * @private\n   * @param {Event} \
event Event which are provided by hook.\n   * @param {CellCoords} coords \
Visual coords of the selected cell.\n   */\n  onAfterOnCellMouseDown(event2, \
coords) {\n    if (wasHeaderClickedProperly(coords.row, coords.col, event2) \
=== false) {\n      return;\n    }\n    if \
(this.wasClickableHeaderClicked(event2, coords.col)) {\n      if \
(this.hot.getShortcutManager().isCtrlPressed()) {\n        \
this.hot.deselectCell();\n        this.hot.selectColumns(coords.col);\n       \
 this.sort(this.getNextSortConfig(coords.col, \
APPEND_COLUMN_CONFIG_STRATEGY2));\n      } else {\n        \
this.sort(this.getColumnNextConfig(coords.col));\n      }\n    }\n  \
}\n};\n\n// \
node_modules/handsontable/plugins/multipleSelectionHandles/multipleSelectionH\
andles.mjs\nvar PLUGIN_KEY27 = \"multipleSelectionHandles\";\nvar \
PLUGIN_PRIORITY26 = 160;\nvar MultipleSelectionHandles = class extends \
BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY27;\n  }\n  \
static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY26;\n  }\n  /**\n   \
* @param {object} hotInstance The handsontable instance.\n   */\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.dragged = [];\n \
   this.eventManager = null;\n    this.lastSetCell = null;\n  }\n  /**\n   * \
Check if the plugin is enabled in the handsontable settings.\n   *\n   * \
@returns {boolean}\n   */\n  isEnabled() {\n    return isMobileBrowser();\n  \
}\n  /**\n   * Enable plugin for this Handsontable instance.\n   */\n  \
enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    if \
(!this.eventManager) {\n      this.eventManager = new \
eventManager_default(this);\n    }\n    this.registerListeners();\n    \
super.enablePlugin();\n  }\n  /**\n   * Bind the touch events.\n   *\n   * \
@private\n   */\n  registerListeners() {\n    const _this = this;\n    const \
{\n      rootElement\n    } = this.hot;\n    function \
removeFromDragged(query) {\n      if (_this.dragged.length === 1) {\n        \
_this.dragged.splice(0, _this.dragged.length);\n        return true;\n      \
}\n      const entryPosition = _this.dragged.indexOf(query);\n      if \
(entryPosition === -1) {\n        return false;\n      } else if \
(entryPosition === 0) {\n        _this.dragged = _this.dragged.slice(0, 1);\n \
     } else if (entryPosition === 1) {\n        _this.dragged = \
_this.dragged.slice(-1);\n      }\n    }\n    \
this.eventManager.addEventListener(rootElement, \"touchstart\", (event2) => \
{\n      let selectedRange;\n      if (hasClass(event2.target, \
\"topSelectionHandle-HitArea\")) {\n        selectedRange = \
_this.hot.getSelectedRangeLast();\n        _this.dragged.push(\"top\");\n     \
   _this.touchStartRange = {\n          width: selectedRange.getWidth(),\n    \
      height: selectedRange.getHeight(),\n          direction: \
selectedRange.getDirection()\n        };\n        event2.preventDefault();\n  \
      return false;\n      } else if (hasClass(event2.target, \
\"bottomSelectionHandle-HitArea\")) {\n        selectedRange = \
_this.hot.getSelectedRangeLast();\n        _this.dragged.push(\"bottom\");\n  \
      _this.touchStartRange = {\n          width: selectedRange.getWidth(),\n \
         height: selectedRange.getHeight(),\n          direction: \
selectedRange.getDirection()\n        };\n        event2.preventDefault();\n  \
      return false;\n      }\n    });\n    \
this.eventManager.addEventListener(rootElement, \"touchend\", (event2) => {\n \
     if (hasClass(event2.target, \"topSelectionHandle-HitArea\")) {\n        \
removeFromDragged.call(_this, \"top\");\n        _this.touchStartRange = void \
0;\n        event2.preventDefault();\n        return false;\n      } else if \
(hasClass(event2.target, \"bottomSelectionHandle-HitArea\")) {\n        \
removeFromDragged.call(_this, \"bottom\");\n        _this.touchStartRange = \
void 0;\n        event2.preventDefault();\n        return false;\n      }\n   \
 });\n    this.eventManager.addEventListener(rootElement, \"touchmove\", \
(event2) => {\n      const {\n        rootDocument\n      } = this.hot;\n     \
 let targetCoords;\n      let selectedRange;\n      let rangeWidth;\n      \
let rangeHeight;\n      let rangeDirection;\n      let newRangeCoords;\n      \
if (_this.dragged.length === 0) {\n        return;\n      }\n      const \
endTarget = rootDocument.elementFromPoint(event2.touches[0].clientX, \
event2.touches[0].clientY);\n      if (!endTarget || endTarget === \
_this.lastSetCell) {\n        return;\n      }\n      if (endTarget.nodeName \
=== \"TD\" || endTarget.nodeName === \"TH\") {\n        targetCoords = \
_this.hot.getCoords(endTarget);\n        if (targetCoords.col === -1) {\n     \
     targetCoords.col = 0;\n        }\n        selectedRange = \
_this.hot.getSelectedRangeLast();\n        rangeWidth = \
selectedRange.getWidth();\n        rangeHeight = selectedRange.getHeight();\n \
       rangeDirection = selectedRange.getDirection();\n        if (rangeWidth \
=== 1 && rangeHeight === 1) {\n          \
_this.hot.selection.setRangeEnd(targetCoords);\n        }\n        \
newRangeCoords = _this.getCurrentRangeCoords(selectedRange, targetCoords, \
_this.touchStartRange.direction, rangeDirection, _this.dragged[0]);\n        \
if (newRangeCoords.start !== null) {\n          \
_this.hot.selection.setRangeStart(newRangeCoords.start);\n        }\n        \
_this.hot.selection.setRangeEnd(newRangeCoords.end);\n        \
_this.lastSetCell = endTarget;\n      }\n      event2.preventDefault();\n    \
});\n  }\n  getCurrentRangeCoords(selectedRange, currentTouch, \
touchStartDirection, currentDirection, draggedHandle) {\n    const \
topStartCorner = selectedRange.getTopStartCorner();\n    const \
bottomEndCorner = selectedRange.getBottomEndCorner();\n    const \
bottomStartCorner = selectedRange.getBottomStartCorner();\n    const \
topEndCorner = selectedRange.getTopEndCorner();\n    let newCoords = {\n      \
start: null,\n      end: null\n    };\n    switch (touchStartDirection) {\n   \
   case \"NE-SW\":\n        switch (currentDirection) {\n          case \
\"NE-SW\":\n          case \"NW-SE\":\n            if (draggedHandle === \
\"top\") {\n              newCoords = {\n                start: \
this.hot._createCellCoords(currentTouch.row, selectedRange.highlight.col),\n  \
              end: this.hot._createCellCoords(bottomStartCorner.row, \
currentTouch.col)\n              };\n            } else {\n              \
newCoords = {\n                start: \
this.hot._createCellCoords(selectedRange.highlight.row, currentTouch.col),\n  \
              end: this.hot._createCellCoords(currentTouch.row, \
topStartCorner.col)\n              };\n            }\n            break;\n    \
      case \"SE-NW\":\n            if (draggedHandle === \"bottom\") {\n      \
        newCoords = {\n                start: \
this.hot._createCellCoords(bottomEndCorner.row, currentTouch.col),\n          \
      end: this.hot._createCellCoords(currentTouch.row, topStartCorner.col)\n \
             };\n            }\n            break;\n          default:\n      \
      break;\n        }\n        break;\n      case \"NW-SE\":\n        \
switch (currentDirection) {\n          case \"NE-SW\":\n            if \
(draggedHandle === \"top\") {\n              newCoords = {\n                \
start: currentTouch,\n                end: bottomStartCorner\n              \
};\n            } else {\n              newCoords.end = currentTouch;\n       \
     }\n            break;\n          case \"NW-SE\":\n            if \
(draggedHandle === \"top\") {\n              newCoords = {\n                \
start: currentTouch,\n                end: bottomEndCorner\n              \
};\n            } else {\n              newCoords.end = currentTouch;\n       \
     }\n            break;\n          case \"SE-NW\":\n            if \
(draggedHandle === \"top\") {\n              newCoords = {\n                \
start: currentTouch,\n                end: topStartCorner\n              };\n \
           } else {\n              newCoords.end = currentTouch;\n            \
}\n            break;\n          case \"SW-NE\":\n            if \
(draggedHandle === \"top\") {\n              newCoords = {\n                \
start: currentTouch,\n                end: topEndCorner\n              };\n   \
         } else {\n              newCoords.end = currentTouch;\n            \
}\n            break;\n          default:\n            break;\n        }\n    \
    break;\n      case \"SW-NE\":\n        switch (currentDirection) {\n      \
    case \"NW-SE\":\n            if (draggedHandle === \"bottom\") {\n        \
      newCoords = {\n                start: \
this.hot._createCellCoords(currentTouch.row, topStartCorner.col),\n           \
     end: this.hot._createCellCoords(bottomStartCorner.row, \
currentTouch.col)\n              };\n            } else {\n              \
newCoords = {\n                start: \
this.hot._createCellCoords(topStartCorner.row, currentTouch.col),\n           \
     end: this.hot._createCellCoords(currentTouch.row, bottomEndCorner.col)\n \
             };\n            }\n            break;\n          case \
\"SW-NE\":\n            if (draggedHandle === \"top\") {\n              \
newCoords = {\n                start: \
this.hot._createCellCoords(selectedRange.highlight.row, currentTouch.col),\n  \
              end: this.hot._createCellCoords(currentTouch.row, \
bottomEndCorner.col)\n              };\n            } else {\n              \
newCoords = {\n                start: \
this.hot._createCellCoords(currentTouch.row, topStartCorner.col),\n           \
     end: this.hot._createCellCoords(topStartCorner.row, currentTouch.col)\n  \
            };\n            }\n            break;\n          case \
\"SE-NW\":\n            if (draggedHandle === \"bottom\") {\n              \
newCoords = {\n                start: \
this.hot._createCellCoords(currentTouch.row, topEndCorner.col),\n             \
   end: this.hot._createCellCoords(topStartCorner.row, currentTouch.col)\n    \
          };\n            } else if (draggedHandle === \"top\") {\n           \
   newCoords = {\n                start: bottomStartCorner,\n                \
end: currentTouch\n              };\n            }\n            break;\n      \
    default:\n            break;\n        }\n        break;\n      case \
\"SE-NW\":\n        switch (currentDirection) {\n          case \"NW-SE\":\n  \
        case \"NE-SW\":\n          case \"SW-NE\":\n            if \
(draggedHandle === \"top\") {\n              newCoords.end = currentTouch;\n  \
          }\n            break;\n          case \"SE-NW\":\n            if \
(draggedHandle === \"top\") {\n              newCoords.end = currentTouch;\n  \
          } else {\n              newCoords = {\n                start: \
currentTouch,\n                end: topStartCorner\n              };\n        \
    }\n            break;\n          default:\n            break;\n        \
}\n        break;\n      default:\n        break;\n    }\n    return \
newCoords;\n  }\n  /**\n   * Check if user is currently dragging the \
handle.\n   *\n   * @returns {boolean} Dragging state.\n   */\n  isDragged() \
{\n    return this.dragged.length > 0;\n  }\n};\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/utils.mjs\nfunct\
ion createDefaultHeaderSettings() {\n  let {\n    label = \"\",\n    colspan \
= 1,\n    origColspan = 1,\n    collapsible = false,\n    crossHiddenColumns \
= [],\n    isCollapsed = false,\n    isHidden = false,\n    isRoot = false,\n \
   isPlaceholder = false\n  } = arguments.length > 0 && arguments[0] !== void \
0 ? arguments[0] : {};\n  return {\n    label,\n    colspan,\n    \
origColspan,\n    collapsible,\n    isCollapsed,\n    crossHiddenColumns,\n   \
 isHidden,\n    isRoot,\n    isPlaceholder\n  };\n}\nfunction \
createPlaceholderHeaderSettings() {\n  return {\n    label: \"\",\n    \
isPlaceholder: true\n  };\n}\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/settingsNormaliz\
er.mjs\nfunction normalizeSettings(sourceSettings) {\n  let columnsLimit = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;\n  \
const normalizedSettings = [];\n  if (columnsLimit === 0) {\n    return \
normalizedSettings;\n  }\n  arrayEach(sourceSettings, (headersSettings) => \
{\n    const columns = [];\n    let columnIndex = 0;\n    \
normalizedSettings.push(columns);\n    arrayEach(headersSettings, \
(sourceHeaderSettings) => {\n      const headerSettings = \
createDefaultHeaderSettings();\n      if (isObject(sourceHeaderSettings)) {\n \
       const {\n          label,\n          colspan\n        } = \
sourceHeaderSettings;\n        headerSettings.label = stringify(label);\n     \
   if (typeof colspan === \"number\" && colspan > 1) {\n          \
headerSettings.colspan = colspan;\n          headerSettings.origColspan = \
colspan;\n        }\n      } else {\n        headerSettings.label = \
stringify(sourceHeaderSettings);\n      }\n      columnIndex += \
headerSettings.origColspan;\n      let cancelProcessing = false;\n      if \
(columnIndex >= columnsLimit) {\n        headerSettings.colspan = \
headerSettings.origColspan - (columnIndex - columnsLimit);\n        \
headerSettings.origColspan = headerSettings.colspan;\n        \
cancelProcessing = true;\n      }\n      columns.push(headerSettings);\n      \
if (headerSettings.colspan > 1) {\n        for (let i = 0; i < \
headerSettings.colspan - 1; i++) {\n          \
columns.push(createPlaceholderHeaderSettings());\n        }\n      }\n      \
return !cancelProcessing;\n    });\n  });\n  const columnsLength = \
Math.max(...arrayMap(normalizedSettings, (headersSettings) => \
headersSettings.length));\n  arrayEach(normalizedSettings, (headersSettings) \
=> {\n    if (headersSettings.length < columnsLength) {\n      const \
defaultSettings = arrayMap(new Array(columnsLength - headersSettings.length), \
() => createDefaultHeaderSettings());\n      \
headersSettings.splice(headersSettings.length, 0, ...defaultSettings);\n    \
}\n  });\n  return normalizedSettings;\n}\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/sourceSettings.m\
js\nfunction _classPrivateFieldInitSpec14(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration15(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration15(obj, privateCollection) {\n \
 if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_classPrivateFieldGet14(receiver, privateMap) {\n  var descriptor = \
_classExtractFieldDescriptor14(receiver, privateMap, \"get\");\n  return \
_classApplyDescriptorGet14(receiver, descriptor);\n}\nfunction \
_classApplyDescriptorGet14(receiver, descriptor) {\n  if (descriptor.get) {\n \
   return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nfunction _classPrivateFieldSet14(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor14(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet14(receiver, descriptor, \
value);\n  return value;\n}\nfunction \
_classExtractFieldDescriptor14(receiver, privateMap, action) {\n  if \
(!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + \
action + \" private field on non-instance\");\n  }\n  return \
privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet14(receiver, \
descriptor, value) {\n  if (descriptor.set) {\n    \
descriptor.set.call(receiver, value);\n  } else {\n    if \
(!descriptor.writable) {\n      throw new TypeError(\"attempted to set read \
only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nvar \
HEADER_CONFIGURABLE_PROPS = [\"label\", \"collapsible\"];\nvar _data = /* \
@__PURE__ */ new WeakMap();\nvar _dataLength = /* @__PURE__ */ new \
WeakMap();\nvar _columnsLimit2 = /* @__PURE__ */ new WeakMap();\nvar \
SourceSettings = class {\n  constructor() {\n    \
_classPrivateFieldInitSpec14(this, _data, {\n      writable: true,\n      \
value: []\n    });\n    _classPrivateFieldInitSpec14(this, _dataLength, {\n   \
   writable: true,\n      value: 0\n    });\n    \
_classPrivateFieldInitSpec14(this, _columnsLimit2, {\n      writable: true,\n \
     value: Infinity\n    });\n  }\n  /**\n   * Sets columns limit to the \
source settings will be trimmed. All headers which\n   * overlap the column \
limit will be reduced to keep the structure solid.\n   *\n   * @param \
{number} columnsCount The number of columns to limit to.\n   */\n  \
setColumnsLimit(columnsCount) {\n    _classPrivateFieldSet14(this, \
_columnsLimit2, columnsCount);\n  }\n  /**\n   * Sets a new nested header \
configuration.\n   *\n   * @param {Array[]} [nestedHeadersSettings=[]] The \
user-defined nested headers settings.\n   */\n  setData() {\n    let \
nestedHeadersSettings = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : [];\n    _classPrivateFieldSet14(this, _data, \
normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet14(this, \
_columnsLimit2)));\n    _classPrivateFieldSet14(this, _dataLength, \
_classPrivateFieldGet14(this, _data).length);\n  }\n  /**\n   * Gets \
normalized source settings.\n   *\n   * @returns {Array[]}\n   */\n  \
getData() {\n    return _classPrivateFieldGet14(this, _data);\n  }\n  /**\n   \
* Merges settings with current source settings.\n   *\n   * @param {object[]} \
additionalSettings An array of objects with `row`, `col` and additional\n   * \
                                     properties to merge with current source \
settings.\n   */\n  mergeWith(additionalSettings) {\n    \
arrayEach(additionalSettings, (_ref) => {\n      let {\n        row,\n        \
col,\n        ...rest\n      } = _ref;\n      const headerSettings = \
this.getHeaderSettings(row, col);\n      if (headerSettings !== null) {\n     \
   extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);\n      }\n    \
});\n  }\n  /**\n   * Maps the current state with a callback. For each source \
settings the callback function\n   * is called. If the function returns value \
that value is merged with the source settings.\n   *\n   * @param {Function} \
callback A function that is called for every header settings.\n   *           \
                 Each time the callback is called, the returned value \
extends\n   *                            header settings.\n   */\n  \
map(callback) {\n    arrayEach(_classPrivateFieldGet14(this, _data), (header) \
=> {\n      arrayEach(header, (headerSettings) => {\n        const \
propsToExtend = callback({\n          ...headerSettings\n        });\n        \
if (isObject(propsToExtend)) {\n          extend(headerSettings, \
propsToExtend, HEADER_CONFIGURABLE_PROPS);\n        }\n      });\n    });\n  \
}\n  /**\n   * Gets source column header settings for a specified header. The \
returned\n   * object contains information about the header label, its \
colspan length,\n   * or if it is hidden in the header renderers.\n   *\n   * \
@param {number} headerLevel Header level (0 = most distant to the table).\n   \
* @param {number} columnIndex A visual column index.\n   * @returns \
{object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    \
var _headersSettings$colu;\n    if (headerLevel >= \
_classPrivateFieldGet14(this, _dataLength) || headerLevel < 0) {\n      \
return null;\n    }\n    const headersSettings = \
_classPrivateFieldGet14(this, _data)[headerLevel];\n    if (columnIndex >= \
headersSettings.length) {\n      return null;\n    }\n    return \
(_headersSettings$colu = headersSettings[columnIndex]) !== null && \
_headersSettings$colu !== void 0 ? _headersSettings$colu : null;\n  }\n  \
/**\n   * Gets source of column headers settings for specified headers. If \
the retrieved column\n   * settings overlap the range \"box\" determined by \
\"columnIndex\" and \"columnsLength\"\n   * the exception will be thrown.\n   \
*\n   * @param {number} headerLevel Header level (0 = most distant to the \
table).\n   * @param {number} columnIndex A visual column index from which \
the settings will be extracted.\n   * @param {number} [columnsLength=1] The \
number of columns involved in the extraction of settings.\n   * @returns \
{object}\n   */\n  getHeadersSettings(headerLevel, columnIndex) {\n    let \
columnsLength = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : 1;\n    const headersSettingsChunks = [];\n    if (headerLevel \
>= _classPrivateFieldGet14(this, _dataLength) || headerLevel < 0) {\n      \
return headersSettingsChunks;\n    }\n    const headersSettings = \
_classPrivateFieldGet14(this, _data)[headerLevel];\n    let currentLength = \
0;\n    for (let i = columnIndex; i < headersSettings.length; i++) {\n      \
const headerSettings = headersSettings[i];\n      if \
(headerSettings.isPlaceholder) {\n        throw new Error(\"The first column \
settings cannot overlap the other header layers\");\n      }\n      \
currentLength += headerSettings.colspan;\n      \
headersSettingsChunks.push(headerSettings);\n      if (headerSettings.colspan \
> 1) {\n        i += headerSettings.colspan - 1;\n      }\n      if \
(currentLength === columnsLength) {\n        break;\n      }\n      if \
(currentLength > columnsLength) {\n        throw new Error(\"The last column \
settings cannot overlap the other header layers\");\n      }\n    }\n    \
return headersSettingsChunks;\n  }\n  /**\n   * Gets a total number of \
headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n  \
  return _classPrivateFieldGet14(this, _dataLength);\n  }\n  /**\n   * Gets a \
total number of columns count.\n   *\n   * @returns {number}\n   */\n  \
getColumnsCount() {\n    return _classPrivateFieldGet14(this, _dataLength) > \
0 ? _classPrivateFieldGet14(this, _data)[0].length : 0;\n  }\n  /**\n   * \
Clears the data.\n   */\n  clear() {\n    _classPrivateFieldSet14(this, \
_data, []);\n    _classPrivateFieldSet14(this, _dataLength, 0);\n  \
}\n};\n\n// node_modules/handsontable/utils/dataStructures/tree.mjs\nfunction \
_defineProperty21(obj, key, value) {\n  key = _toPropertyKey21(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey21(arg) {\n  var key = \
_toPrimitive21(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive21(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar TRAVERSAL_DF_PRE = \"DF-pre-order\";\nfunction \
depthFirstPreOrder(callback, context) {\n  let continueTraverse = \
callback.call(context, this);\n  for (let i = 0; i < this.childs.length; i++) \
{\n    if (continueTraverse === false) {\n      return false;\n    }\n    \
continueTraverse = depthFirstPreOrder.call(this.childs[i], callback, \
context);\n  }\n  return continueTraverse;\n}\nvar TRAVERSAL_DF_POST = \
\"DF-post-order\";\nfunction depthFirstPostOrder(callback, context) {\n  for \
(let i = 0; i < this.childs.length; i++) {\n    const continueTraverse = \
depthFirstPostOrder.call(this.childs[i], callback, context);\n    if \
(continueTraverse === false) {\n      return false;\n    }\n  }\n  return \
callback.call(context, this);\n}\nvar TRAVERSAL_BF = \"BF\";\nfunction \
breadthFirst(callback, context) {\n  const queue = [this];\n  function \
process2() {\n    if (queue.length === 0) {\n      return;\n    }\n    const \
node = queue.shift();\n    queue.push(...node.childs);\n    if \
(callback.call(context, node) !== false) {\n      process2();\n    }\n  }\n  \
process2();\n}\nvar DEFAULT_TRAVERSAL_STRATEGY = TRAVERSAL_BF;\nvar \
TRAVERSAL_STRATEGIES = /* @__PURE__ */ new Map([[TRAVERSAL_DF_PRE, \
depthFirstPreOrder], [TRAVERSAL_DF_POST, depthFirstPostOrder], [TRAVERSAL_BF, \
breadthFirst]]);\nvar TreeNode = class _TreeNode {\n  constructor(data2) {\n  \
  _defineProperty21(this, \"data\", {});\n    _defineProperty21(this, \
\"parent\", null);\n    _defineProperty21(this, \"childs\", []);\n    \
this.data = data2;\n  }\n  /**\n   * Adds a node to tree leaves. Added node \
is linked with the parent node through \"parent\" property.\n   *\n   * \
@param {TreeNode} node A TreeNode to add.\n   */\n  addChild(node) {\n    \
node.parent = this;\n    this.childs.push(node);\n  }\n  /* eslint-disable \
jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof \
TreeNode#\n   * @function cloneTree\n   *\n   * Clones a tree structure \
deeply.\n   *\n   * For example, for giving a tree structure:\n   *      \
.--(B1)--.\n   *   .-(C1)   .-(C2)-.----.\n   *  (D1)     (D2)   (D3) (D4)\n  \
 *\n   * Cloning a tree starting from C2 node creates a mirrored tree \
structure.\n   *     .-(C2')-.-----.\n   *    (D2')   (D3') (D4')\n   *\n   * \
The cloned tree can be safely modified without affecting the original \
structure.\n   * After modification, the clone can be merged with a tree \
using the \"replaceTreeWith\" method.\n   *\n   * @param {TreeNode} \
[nodeTree=this] A TreeNode to clone.\n   * @returns {TreeNode}\n   */\n  /* \
eslint-enable jsdoc/require-description-complete-sentence */\n  cloneTree() \
{\n    let nodeTree = arguments.length > 0 && arguments[0] !== void 0 ? \
arguments[0] : this;\n    const clonedNode = new _TreeNode({\n      \
...nodeTree.data\n    });\n    for (let i = 0; i < nodeTree.childs.length; \
i++) {\n      clonedNode.addChild(this.cloneTree(nodeTree.childs[i]));\n    \
}\n    return clonedNode;\n  }\n  /**\n   * Replaces the current node with a \
passed tree structure.\n   *\n   * @param {TreeNode} nodeTree A TreeNode to \
replace with.\n   */\n  replaceTreeWith(nodeTree) {\n    this.data = {\n      \
...nodeTree.data\n    };\n    this.childs = [];\n    for (let i = 0; i < \
nodeTree.childs.length; i++) {\n      this.addChild(nodeTree.childs[i]);\n    \
}\n  }\n  /**\n   * Traverses the tree structure through node childs. The \
walk down traversing supports\n   * a three different strategies.\n   *  - \
Depth-first pre-order strategy \
(https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR));\n   *  - \
Depth-first post-order strategy \
(https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR));\n   *  - \
Breadth-first traversal strategy \
(https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_or\
der).\n   *\n   * @param {Function} callback The callback function which will \
be called for each node.\n   * @param {string} \
[traversalStrategy=DEFAULT_TRAVERSAL_STRATEGY] Traversing strategy.\n   */\n  \
walkDown(callback) {\n    let traversalStrategy = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : DEFAULT_TRAVERSAL_STRATEGY;\n    if \
(!TRAVERSAL_STRATEGIES.has(traversalStrategy)) {\n      throw new \
Error(`Traversal strategy \"${traversalStrategy}\" does not exist`);\n    }\n \
   TRAVERSAL_STRATEGIES.get(traversalStrategy).call(this, callback, this);\n  \
}\n  /**\n   * Traverses the tree structure through node parents.\n   *\n   * \
@param {Function} callback The callback function which will be called for \
each node.\n   */\n  walkUp(callback) {\n    const context = this;\n    const \
process2 = (node) => {\n      const continueTraverse = callback.call(context, \
node);\n      if (continueTraverse !== false && node.parent !== null) {\n     \
   process2(node.parent);\n      }\n    };\n    process2(this);\n  \
}\n};\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/headersTree.mjs\
\nfunction _classPrivateFieldInitSpec15(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration16(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration16(obj, privateCollection) {\n \
 if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_classPrivateFieldGet15(receiver, privateMap) {\n  var descriptor = \
_classExtractFieldDescriptor15(receiver, privateMap, \"get\");\n  return \
_classApplyDescriptorGet15(receiver, descriptor);\n}\nfunction \
_classApplyDescriptorGet15(receiver, descriptor) {\n  if (descriptor.get) {\n \
   return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nfunction _classPrivateFieldSet15(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor15(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet15(receiver, descriptor, \
value);\n  return value;\n}\nfunction \
_classExtractFieldDescriptor15(receiver, privateMap, action) {\n  if \
(!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + \
action + \" private field on non-instance\");\n  }\n  return \
privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet15(receiver, \
descriptor, value) {\n  if (descriptor.set) {\n    \
descriptor.set.call(receiver, value);\n  } else {\n    if \
(!descriptor.writable) {\n      throw new TypeError(\"attempted to set read \
only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nvar \
_rootNodes = /* @__PURE__ */ new WeakMap();\nvar _rootsIndex = /* @__PURE__ \
*/ new WeakMap();\nvar _sourceSettings = /* @__PURE__ */ new WeakMap();\nvar \
HeadersTree = class {\n  constructor(sourceSettings) {\n    \
_classPrivateFieldInitSpec15(this, _rootNodes, {\n      writable: true,\n     \
 value: /* @__PURE__ */ new Map()\n    });\n    \
_classPrivateFieldInitSpec15(this, _rootsIndex, {\n      writable: true,\n    \
  value: /* @__PURE__ */ new Map()\n    });\n    \
_classPrivateFieldInitSpec15(this, _sourceSettings, {\n      writable: \
true,\n      value: null\n    });\n    _classPrivateFieldSet15(this, \
_sourceSettings, sourceSettings);\n  }\n  /**\n   * Gets an array of the all \
root nodes.\n   *\n   * @returns {TreeNode[]}\n   */\n  getRoots() {\n    \
return Array.from(_classPrivateFieldGet15(this, _rootNodes).values());\n  }\n \
 /**\n   * Gets a root node by specified visual column index.\n   *\n   * \
@param {number} columnIndex A visual column index.\n   * @returns \
{TreeNode|undefined}\n   */\n  getRootByColumn(columnIndex) {\n    let \
node;\n    if (_classPrivateFieldGet15(this, _rootsIndex).has(columnIndex)) \
{\n      node = _classPrivateFieldGet15(this, \
_rootNodes).get(_classPrivateFieldGet15(this, \
_rootsIndex).get(columnIndex));\n    }\n    return node;\n  }\n  /**\n   * \
Gets a tree node by its position in the grid settings.\n   *\n   * @param \
{number} headerLevel Header level index (there is support only for positive \
values).\n   * @param {number} columnIndex A visual column index.\n   * \
@returns {TreeNode|undefined}\n   */\n  getNode(headerLevel, columnIndex) {\n \
   const rootNode = this.getRootByColumn(columnIndex);\n    if (!rootNode) \
{\n      return;\n    }\n    const normColumnIndex = columnIndex - \
_classPrivateFieldGet15(this, _rootsIndex).get(columnIndex);\n    let \
columnCursor = 0;\n    let treeNode;\n    rootNode.walkDown((node) => {\n     \
 const {\n        data: {\n          origColspan,\n          headerLevel: \
nodeHeaderLevel\n        }\n      } = node;\n      if (headerLevel === \
nodeHeaderLevel) {\n        if (normColumnIndex >= columnCursor && \
normColumnIndex <= columnCursor + origColspan - 1) {\n          treeNode = \
node;\n          treeNode.data.isRoot = columnIndex === \
treeNode.data.columnIndex;\n          return false;\n        }\n        \
columnCursor += origColspan;\n      }\n    });\n    return treeNode;\n  }\n  \
/**\n   * Builds (or rebuilds if called again) root nodes indexes.\n   */\n  \
rebuildTreeIndex() {\n    let columnIndex = 0;\n    \
_classPrivateFieldGet15(this, _rootsIndex).clear();\n    \
arrayEach(_classPrivateFieldGet15(this, _rootNodes), (_ref) => {\n      let \
[, {\n        data: {\n          colspan\n        }\n      }] = _ref;\n      \
for (let i = columnIndex; i < columnIndex + colspan; i++) {\n        \
_classPrivateFieldGet15(this, _rootsIndex).set(i, columnIndex);\n      }\n    \
  columnIndex += colspan;\n    });\n  }\n  /**\n   * Builds trees based on \
SourceSettings class. Calling a method causes clearing the tree state built\n \
  * from the previous call.\n   */\n  buildTree() {\n    this.clear();\n    \
const columnsCount = _classPrivateFieldGet15(this, \
_sourceSettings).getColumnsCount();\n    let columnIndex = 0;\n    while \
(columnIndex < columnsCount) {\n      const columnSettings = \
_classPrivateFieldGet15(this, _sourceSettings).getHeaderSettings(0, \
columnIndex);\n      const rootNode = new TreeNode();\n      \
_classPrivateFieldGet15(this, _rootNodes).set(columnIndex, rootNode);\n      \
this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);\n     \
 columnIndex += columnSettings.origColspan;\n    }\n    \
this.rebuildTreeIndex();\n  }\n  /**\n   * Builds leaves for specified tree \
node.\n   *\n   * @param {TreeNode} parentNode A node to which the leaves \
applies.\n   * @param {number} columnIndex A visual column index.\n   * \
@param {number} headerLevel Currently processed header level.\n   * @param \
{number} [extractionLength=1] Determines column extraction length for node \
children.\n   */\n  buildLeaves(parentNode, columnIndex, headerLevel) {\n    \
let extractionLength = arguments.length > 3 && arguments[3] !== void 0 ? \
arguments[3] : 1;\n    const columnsSettings = _classPrivateFieldGet15(this, \
_sourceSettings).getHeadersSettings(headerLevel, columnIndex, \
extractionLength);\n    headerLevel += 1;\n    arrayEach(columnsSettings, \
(columnSettings) => {\n      const nodeData = {\n        ...columnSettings,\n \
       /**\n         * The header level (tree node depth level).\n         \
*\n         * @type {number}\n         */\n        headerLevel: headerLevel - \
1,\n        /**\n         * A visual column index.\n         *\n         * \
@type {number}\n         */\n        columnIndex\n      };\n      let node;\n \
     if (headerLevel === 1) {\n        parentNode.data = nodeData;\n        \
node = parentNode;\n      } else {\n        node = new TreeNode(nodeData);\n  \
      parentNode.addChild(node);\n      }\n      if (headerLevel < \
_classPrivateFieldGet15(this, _sourceSettings).getLayersCount()) {\n        \
this.buildLeaves(node, columnIndex, headerLevel, \
columnSettings.origColspan);\n      }\n      columnIndex += \
columnSettings.origColspan;\n    });\n  }\n  /**\n   * Clears the tree to the \
initial state.\n   */\n  clear() {\n    _classPrivateFieldGet15(this, \
_rootNodes).clear();\n    _classPrivateFieldGet15(this, \
_rootsIndex).clear();\n  }\n};\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/ut\
ils/tree.mjs\nfunction traverseHiddenNodeColumnIndexes(node, callback) {\n  \
node.walkDown((_ref) => {\n    let {\n      data: data2,\n      childs\n    } \
= _ref;\n    if (!data2.isHidden) {\n      callback(data2.columnIndex);\n     \
 if (childs.length === 0) {\n        for (let i = 1; i < data2.colspan; i++) \
{\n          callback(data2.columnIndex + i);\n        }\n      }\n    }\n  \
});\n}\nfunction getFirstChildProperty(_ref2, propertyName) {\n  let {\n    \
childs\n  } = _ref2;\n  if (childs.length === 0) {\n    return;\n  }\n  \
return childs[0].data[propertyName];\n}\nfunction \
isNodeReflectsFirstChildColspan(node) {\n  return getFirstChildProperty(node, \
\"origColspan\") === node.data.origColspan;\n}\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/ex\
pand.mjs\nfunction expandNode(nodeToProcess) {\n  const {\n    data: \
nodeData,\n    childs: nodeChilds\n  } = nodeToProcess;\n  if \
(!nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {\n \
   return {\n      rollbackModification: () => {\n      },\n      \
affectedColumns: [],\n      colspanCompensation: 0\n    };\n  }\n  const \
isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);\n  if \
(isNodeReflected) {\n    return expandNode(nodeChilds[0]);\n  }\n  \
nodeData.isCollapsed = false;\n  const allLeavesExceptMostLeft = \
nodeChilds.slice(1);\n  const affectedColumns = /* @__PURE__ */ new Set();\n  \
let colspanCompensation = 0;\n  if (allLeavesExceptMostLeft.length > 0) {\n   \
 arrayEach(allLeavesExceptMostLeft, (node) => {\n      \
node.replaceTreeWith(node.data.clonedTree);\n      node.data.clonedTree = \
null;\n      const leafData = node.data;\n      colspanCompensation += \
leafData.colspan;\n      traverseHiddenNodeColumnIndexes(node, \
(gridColumnIndex) => {\n        affectedColumns.add(gridColumnIndex);\n      \
});\n    });\n  } else {\n    const {\n      colspan,\n      origColspan,\n   \
   columnIndex\n    } = nodeData;\n    colspanCompensation = origColspan - \
colspan;\n    for (let i = 1; i < origColspan; i++) {\n      \
affectedColumns.add(columnIndex + i);\n    }\n  }\n  \
nodeToProcess.walkUp((node) => {\n    const {\n      data: data2\n    } = \
node;\n    data2.colspan += colspanCompensation;\n    if (data2.colspan >= \
data2.origColspan) {\n      data2.colspan = data2.origColspan;\n      \
data2.isCollapsed = false;\n    } else if \
(isNodeReflectsFirstChildColspan(node)) {\n      data2.isCollapsed = \
getFirstChildProperty(node, \"isCollapsed\");\n    }\n  });\n  return {\n    \
rollbackModification: () => collapseNode(nodeToProcess),\n    \
affectedColumns: Array.from(affectedColumns),\n    colspanCompensation\n  \
};\n}\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/co\
llapse.mjs\nfunction collapseNode(nodeToProcess) {\n  var \
_getFirstChildPropert;\n  const {\n    data: nodeData,\n    childs: \
nodeChilds\n  } = nodeToProcess;\n  if (nodeData.isCollapsed || \
nodeData.isHidden || nodeData.origColspan <= 1) {\n    return {\n      \
rollbackModification: () => {\n      },\n      affectedColumns: [],\n      \
colspanCompensation: 0\n    };\n  }\n  const isNodeReflected = \
isNodeReflectsFirstChildColspan(nodeToProcess);\n  if (isNodeReflected) {\n   \
 return collapseNode(nodeChilds[0]);\n  }\n  nodeData.isCollapsed = true;\n  \
const allLeavesExceptMostLeft = nodeChilds.slice(1);\n  const affectedColumns \
= /* @__PURE__ */ new Set();\n  if (allLeavesExceptMostLeft.length > 0) {\n   \
 arrayEach(allLeavesExceptMostLeft, (node) => {\n      \
traverseHiddenNodeColumnIndexes(node, (gridColumnIndex) => {\n        \
affectedColumns.add(gridColumnIndex);\n      });\n      node.data.clonedTree \
= node.cloneTree();\n      node.walkDown((_ref) => {\n        let {\n         \
 data: data2\n        } = _ref;\n        data2.isHidden = true;\n      });\n  \
  });\n  } else {\n    const {\n      origColspan,\n      columnIndex\n    } \
= nodeData;\n    for (let i = 1; i < origColspan; i++) {\n      const \
gridColumnIndex = columnIndex + i;\n      \
affectedColumns.add(gridColumnIndex);\n    }\n  }\n  const \
colspanCompensation = nodeData.colspan - ((_getFirstChildPropert = \
getFirstChildProperty(nodeToProcess, \"colspan\")) !== null && \
_getFirstChildPropert !== void 0 ? _getFirstChildPropert : 1);\n  \
nodeToProcess.walkUp((node) => {\n    const {\n      data: data2\n    } = \
node;\n    data2.colspan -= colspanCompensation;\n    if (data2.colspan <= 1) \
{\n      data2.colspan = 1;\n      data2.isCollapsed = true;\n    } else if \
(isNodeReflectsFirstChildColspan(node)) {\n      data2.isCollapsed = \
getFirstChildProperty(node, \"isCollapsed\");\n    }\n  });\n  return {\n    \
rollbackModification: () => expandNode(nodeToProcess),\n    affectedColumns: \
Array.from(affectedColumns),\n    colspanCompensation\n  };\n}\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/hi\
deColumn.mjs\nfunction hideColumn(nodeToProcess, gridColumnIndex) {\n  if \
(!Number.isInteger(gridColumnIndex)) {\n    throw new Error(\"The passed \
gridColumnIndex argument has invalid type.\");\n  }\n  if \
(nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine`The \
passed node is not the last node on the tree. Only for\\x20\nthe last node, \
the hide column modification can be applied.`);\n  }\n  const {\n    \
crossHiddenColumns\n  } = nodeToProcess.data;\n  if \
(crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  let \
isCollapsibleNode = false;\n  nodeToProcess.walkUp((node) => {\n    const {\n \
     data: {\n        collapsible\n      }\n    } = node;\n    if \
(collapsible) {\n      isCollapsibleNode = true;\n      return false;\n    \
}\n  });\n  if (isCollapsibleNode) {\n    return;\n  }\n  \
nodeToProcess.walkUp((node) => {\n    const {\n      data: data2\n    } = \
node;\n    data2.crossHiddenColumns.push(gridColumnIndex);\n    if \
(data2.colspan > 1) {\n      data2.colspan -= 1;\n    } else {\n      \
data2.isHidden = true;\n    }\n  });\n}\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/sh\
owColumn.mjs\nfunction showColumn(nodeToProcess, gridColumnIndex) {\n  if \
(!Number.isInteger(gridColumnIndex)) {\n    throw new Error(\"The passed \
gridColumnIndex argument has invalid type.\");\n  }\n  if \
(nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine`The \
passed node is not the last node on the tree. Only for\\x20\nthe last node, \
the show column modification can be applied.`);\n  }\n  const {\n    \
crossHiddenColumns\n  } = nodeToProcess.data;\n  if \
(!crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  let \
isCollapsibleNode = false;\n  nodeToProcess.walkUp((node) => {\n    const {\n \
     data: {\n        collapsible\n      }\n    } = node;\n    if \
(collapsible) {\n      isCollapsibleNode = true;\n      return false;\n    \
}\n  });\n  if (isCollapsibleNode) {\n    return;\n  }\n  \
nodeToProcess.walkUp((node) => {\n    const {\n      data: data2\n    } = \
node;\n    \
data2.crossHiddenColumns.splice(data2.crossHiddenColumns.indexOf(gridColumnIn\
dex), 1);\n    if (!data2.isHidden && data2.colspan < data2.origColspan) {\n  \
    data2.colspan += 1;\n    }\n    data2.isHidden = false;\n  });\n}\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/in\
dex.mjs\nvar availableModifiers = /* @__PURE__ */ new Map([[\"collapse\", \
collapseNode], [\"expand\", expandNode], [\"hide-column\", hideColumn], \
[\"show-column\", showColumn]]);\nfunction \
triggerNodeModification(actionName, nodeToProcess, gridColumnIndex) {\n  if \
(!availableModifiers.has(actionName)) {\n    throw new Error(`The node \
modifier action (\"${actionName}\") does not exist.`);\n  }\n  return \
availableModifiers.get(actionName)(nodeToProcess, gridColumnIndex);\n}\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/matrixGenerator.\
mjs\nfunction generateMatrix(headerRoots) {\n  const matrix = [];\n  \
arrayEach(headerRoots, (rootNode) => {\n    rootNode.walkDown((node) => {\n   \
   const nodeData = node.data;\n      const {\n        origColspan,\n        \
columnIndex,\n        headerLevel,\n        crossHiddenColumns\n      } = \
nodeData;\n      const colspanHeaderLayer = \
createNestedArrayIfNecessary(matrix, headerLevel);\n      let \
isRootSettingsFound = false;\n      for (let i = columnIndex; i < columnIndex \
+ origColspan; i++) {\n        const isColumnHidden = \
crossHiddenColumns.includes(i);\n        if (isColumnHidden || \
isRootSettingsFound) {\n          \
colspanHeaderLayer.push(createPlaceholderHeaderSettings(nodeData));\n        \
} else {\n          const headerRootSettings = \
createHeaderSettings(nodeData);\n          headerRootSettings.isRoot = \
true;\n          colspanHeaderLayer.push(headerRootSettings);\n          \
isRootSettingsFound = true;\n        }\n      }\n    });\n  });\n  return \
matrix;\n}\nfunction createHeaderSettings(nodeData) {\n  const {\n    \
crossHiddenColumns,\n    ...headerRootSettings\n  } = \
createDefaultHeaderSettings(nodeData);\n  return \
headerRootSettings;\n}\nfunction createNestedArrayIfNecessary(array, index2) \
{\n  let subArray;\n  if (Array.isArray(array[index2])) {\n    subArray = \
array[index2];\n  } else {\n    subArray = [];\n    array[index2] = \
subArray;\n  }\n  return subArray;\n}\n\n// \
node_modules/handsontable/plugins/nestedHeaders/stateManager/index.mjs\nfunct\
ion _classPrivateFieldInitSpec16(obj, privateMap, value) {\n  \
_checkPrivateRedeclaration17(obj, privateMap);\n  privateMap.set(obj, \
value);\n}\nfunction _checkPrivateRedeclaration17(obj, privateCollection) {\n \
 if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot \
initialize the same private elements twice on an object\");\n  }\n}\nfunction \
_classPrivateFieldSet16(receiver, privateMap, value) {\n  var descriptor = \
_classExtractFieldDescriptor16(receiver, privateMap, \"set\");\n  \
_classApplyDescriptorSet16(receiver, descriptor, value);\n  return \
value;\n}\nfunction _classApplyDescriptorSet16(receiver, descriptor, value) \
{\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } \
else {\n    if (!descriptor.writable) {\n      throw new \
TypeError(\"attempted to set read only private field\");\n    }\n    \
descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet16(receiver, \
privateMap) {\n  var descriptor = _classExtractFieldDescriptor16(receiver, \
privateMap, \"get\");\n  return _classApplyDescriptorGet16(receiver, \
descriptor);\n}\nfunction _classExtractFieldDescriptor16(receiver, \
privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new \
TypeError(\"attempted to \" + action + \" private field on non-instance\");\n \
 }\n  return privateMap.get(receiver);\n}\nfunction \
_classApplyDescriptorGet16(receiver, descriptor) {\n  if (descriptor.get) {\n \
   return descriptor.get.call(receiver);\n  }\n  return \
descriptor.value;\n}\nvar _sourceSettings2 = /* @__PURE__ */ new \
WeakMap();\nvar _headersTree = /* @__PURE__ */ new WeakMap();\nvar \
_stateMatrix = /* @__PURE__ */ new WeakMap();\nvar StateManager = class {\n  \
constructor() {\n    _classPrivateFieldInitSpec16(this, _sourceSettings2, {\n \
     writable: true,\n      value: new SourceSettings()\n    });\n    \
_classPrivateFieldInitSpec16(this, _headersTree, {\n      writable: true,\n   \
   value: new HeadersTree(_classPrivateFieldGet16(this, _sourceSettings2))\n  \
  });\n    _classPrivateFieldInitSpec16(this, _stateMatrix, {\n      \
writable: true,\n      value: [[]]\n    });\n  }\n  /**\n   * Sets a new \
state for the nested headers plugin based on settings passed\n   * directly \
to the plugin.\n   *\n   * @param {Array[]} nestedHeadersSettings The \
user-defined settings.\n   * @returns {boolean} Returns `true` if the \
settings are processed correctly, `false` otherwise.\n   */\n  \
setState(nestedHeadersSettings) {\n    _classPrivateFieldGet16(this, \
_sourceSettings2).setData(nestedHeadersSettings);\n    let hasError = \
false;\n    try {\n      _classPrivateFieldGet16(this, \
_headersTree).buildTree();\n    } catch (ex) {\n      \
_classPrivateFieldGet16(this, _headersTree).clear();\n      \
_classPrivateFieldGet16(this, _sourceSettings2).clear();\n      hasError = \
true;\n    }\n    _classPrivateFieldSet16(this, _stateMatrix, \
generateMatrix(_classPrivateFieldGet16(this, _headersTree).getRoots()));\n    \
return hasError;\n  }\n  /**\n   * Sets columns limit to the state will be \
trimmed. All headers (colspans) which\n   * overlap the column limit will be \
reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount \
The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) \
{\n    _classPrivateFieldGet16(this, \
_sourceSettings2).setColumnsLimit(columnsCount);\n  }\n  /**\n   * Merges \
settings with current plugin state.\n   *\n   * By default only foreign keys \
are merged with source state and passed to the tree. But only\n   * known \
keys are exported to matrix.\n   *\n   * @param {object[]} settings An array \
of objects to merge with the current source settings.\n   *                   \
         It is a requirement that every object has `row` and `col` \
properties\n   *                            which points to the specific \
header settings object.\n   */\n  mergeStateWith(settings) {\n    const \
transformedSettings = arrayMap(settings, (_ref) => {\n      let {\n        \
row,\n        ...rest\n      } = _ref;\n      return {\n        row: row < 0 \
? this.rowCoordsToLevel(row) : row,\n        ...rest\n      };\n    });\n    \
_classPrivateFieldGet16(this, \
_sourceSettings2).mergeWith(transformedSettings);\n    \
_classPrivateFieldGet16(this, _headersTree).buildTree();\n    \
_classPrivateFieldSet16(this, _stateMatrix, \
generateMatrix(_classPrivateFieldGet16(this, _headersTree).getRoots()));\n  \
}\n  /**\n   * Maps the current state with a callback. For each header \
settings the callback function\n   * is called. If the function returns value \
that value is merged with the state.\n   *\n   * By default only foreign keys \
are merged with source state and passed to the tree. But only\n   * known \
keys are exported to matrix.\n   *\n   * @param {Function} callback A \
function that is called for every header source settings.\n   *               \
             Each time the callback is called, the returned value extends\n   \
*                            header settings.\n   */\n  mapState(callback) \
{\n    _classPrivateFieldGet16(this, _sourceSettings2).map(callback);\n    \
_classPrivateFieldGet16(this, _headersTree).buildTree();\n    \
_classPrivateFieldSet16(this, _stateMatrix, \
generateMatrix(_classPrivateFieldGet16(this, _headersTree).getRoots()));\n  \
}\n  /**\n   * Maps the current tree nodes with a callback. For each node the \
callback function\n   * is called. If the function returns value that value \
is added to returned array.\n   *\n   * @param {Function} callback A function \
that is called for every tree node.\n   *                            Each \
time the callback is called, the returned value is\n   *                      \
      added to returned array.\n   * @returns {Array}\n   */\n  \
mapNodes(callback) {\n    return arrayReduce(_classPrivateFieldGet16(this, \
_headersTree).getRoots(), (acc, rootNode) => {\n      \
rootNode.walkDown((node) => {\n        const result = callback(node.data);\n  \
      if (result !== void 0) {\n          acc.push(result);\n        }\n      \
});\n      return acc;\n    }, []);\n  }\n  /**\n   * Triggers an action \
(e.g. \"collapse\") from the NodeModifiers module. The module\n   * modifies \
a tree structure in such a way as to obtain the correct structure consistent \
with the\n   * called action.\n   *\n   * @param {string} action An action \
name to trigger.\n   * @param {number} headerLevel Header level index (there \
is support for negative and positive values).\n   * @param {number} \
columnIndex A visual column index.\n   * @returns {object|undefined}\n   */\n \
 triggerNodeModification(action, headerLevel, columnIndex) {\n    if \
(headerLevel < 0) {\n      headerLevel = \
this.rowCoordsToLevel(headerLevel);\n    }\n    const nodeToProcess = \
_classPrivateFieldGet16(this, _headersTree).getNode(headerLevel, \
columnIndex);\n    let actionResult;\n    if (nodeToProcess) {\n      \
actionResult = triggerNodeModification(action, nodeToProcess, columnIndex);\n \
     _classPrivateFieldSet16(this, _stateMatrix, \
generateMatrix(_classPrivateFieldGet16(this, _headersTree).getRoots()));\n    \
}\n    return actionResult;\n  }\n  /**\n   * Triggers an action (e.g. \
\"hide-column\") from the NodeModifiers module. The action is\n   * triggered \
starting from the lowest header. The module modifies a tree structure in\n   \
* such a way as to obtain the correct structure consistent with the called \
action.\n   *\n   * @param {string} action An action name to trigger.\n   * \
@param {number} columnIndex A visual column index.\n   * @returns \
{object|undefined}\n   */\n  triggerColumnModification(action, columnIndex) \
{\n    return this.triggerNodeModification(action, -1, columnIndex);\n  }\n  \
/* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * \
@memberof StateManager#\n   * @function rowCoordsToLevel\n   *\n   * \
Translates row coordinates into header level. The row coordinates counts from \
-1 to -N\n   * and describes headers counting from most closest to most \
distant from the table.\n   * The header levels are counted from 0 to N where \
0 describes most distant header\n   * from the table.\n   *\n   *  Row coords \
            Header level\n   *           +--------------+\n   *       -3  \
\[AHat]\224\202 A1 \[AHat]\224\202 A1      \[AHat]\224\202  0\n   *           \
+--------------+\n   *       -2  \[AHat]\224\202 B1 \[AHat]\224\202 B2 \
\[AHat]\224\202 B3 \[AHat]\224\202  1\n   *           +--------------+\n   *  \
     -1  \[AHat]\224\202 C1 \[AHat]\224\202 C2 \[AHat]\224\202 C3 \
\[AHat]\224\202  2\n   *           +==============+\n   *           \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202\n   \
*           +--------------+\n   *           \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202\n   *\n   * @param \
{number} rowIndex A visual row index.\n   * @returns {number|null} Returns \
unsigned number.\n   */\n  /* eslint-enable \
jsdoc/require-description-complete-sentence */\n  rowCoordsToLevel(rowIndex) \
{\n    if (rowIndex >= 0) {\n      return null;\n    }\n    const headerLevel \
= rowIndex + Math.max(this.getLayersCount(), 1);\n    if (headerLevel < 0) \
{\n      return null;\n    }\n    return headerLevel;\n  }\n  /* \
eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * \
@memberof StateManager#\n   * @function levelToRowCoords\n   *\n   * \
Translates header level into row coordinates. The row coordinates counts from \
-1 to -N\n   * and describes headers counting from most closest to most \
distant from the table.\n   * The header levels are counted from 0 to N where \
0 describes most distant header\n   * from the table.\n   *\n   *  Header \
level            Row coords\n   *           +--------------+\n   *        0  \
\[AHat]\224\202 A1 \[AHat]\224\202 A1      \[AHat]\224\202  -3\n   *          \
 +--------------+\n   *        1  \[AHat]\224\202 B1 \[AHat]\224\202 B2 \
\[AHat]\224\202 B3 \[AHat]\224\202  -2\n   *           +--------------+\n   * \
       2  \[AHat]\224\202 C1 \[AHat]\224\202 C2 \[AHat]\224\202 C3 \
\[AHat]\224\202  -1\n   *           +==============+\n   *           \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202\n   \
*           +--------------+\n   *           \[AHat]\224\202    \
\[AHat]\224\202    \[AHat]\224\202    \[AHat]\224\202\n   *\n   * @param \
{number} headerLevel Header level index.\n   * @returns {number} Returns \
negative number.\n   */\n  /* eslint-enable \
jsdoc/require-description-complete-sentence */\n  \
levelToRowCoords(headerLevel) {\n    if (headerLevel < 0) {\n      return \
null;\n    }\n    const rowIndex = headerLevel - \
Math.max(this.getLayersCount(), 1);\n    if (rowIndex >= 0) {\n      return \
null;\n    }\n    return rowIndex;\n  }\n  /**\n   * Gets column header \
settings for a specified column and header index. The returned object \
contains\n   * all information necessary for header renderers. It contains \
header label, colspan length, or hidden\n   * flag.\n   *\n   * @param \
{number} headerLevel Header level (there is support for negative and positive \
values).\n   * @param {number} columnIndex A visual column index.\n   * \
@returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) \
{\n    var _classPrivateFieldGet22, _classPrivateFieldGet32;\n    if \
(headerLevel < 0) {\n      headerLevel = \
this.rowCoordsToLevel(headerLevel);\n    }\n    if (headerLevel === null || \
headerLevel >= this.getLayersCount()) {\n      return null;\n    }\n    \
return (_classPrivateFieldGet22 = (_classPrivateFieldGet32 = \
_classPrivateFieldGet16(this, _stateMatrix)[headerLevel]) === null || \
_classPrivateFieldGet32 === void 0 ? void 0 : \
_classPrivateFieldGet32[columnIndex]) !== null && _classPrivateFieldGet22 !== \
void 0 ? _classPrivateFieldGet22 : null;\n  }\n  /**\n   * Gets tree data \
that is connected to the column header. The returned object contains all \
information\n   * necessary for modifying tree structure (column collapsing, \
hiding, etc.). It contains a header\n   * label, colspan length, or visual \
column index that indicates which column index the node is rendered from.\n   \
*\n   * @param {number} headerLevel Header level (there is support for \
negative and positive values).\n   * @param {number} columnIndex A visual \
column index.\n   * @returns {object|null}\n   */\n  \
getHeaderTreeNodeData(headerLevel, columnIndex) {\n    if (headerLevel < 0) \
{\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    if \
(headerLevel === null || headerLevel >= this.getLayersCount()) {\n      \
return null;\n    }\n    const node = _classPrivateFieldGet16(this, \
_headersTree).getNode(headerLevel, columnIndex);\n    if (!node) {\n      \
return null;\n    }\n    return {\n      ...node.data\n    };\n  }\n  /**\n   \
* The method is helpful in cases where the column index targets in-between \
currently\n   * collapsed column. In that case, the method returns the \
left-most column index\n   * where the nested header begins.\n   *\n   * \
@param {number} headerLevel Header level (there is support for negative and \
positive values).\n   * @param {number} columnIndex A visual column index.\n  \
 * @returns {number}\n   */\n  findLeftMostColumnIndex(headerLevel, \
columnIndex) {\n    var _this$getHeaderSettin;\n    const {\n      isRoot\n   \
 } = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, \
columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? \
_this$getHeaderSettin : {\n      isRoot: true\n    };\n    if (isRoot) {\n    \
  return columnIndex;\n    }\n    let stepBackColumn = columnIndex - 1;\n    \
while (stepBackColumn >= 0) {\n      var _this$getHeaderSettin2;\n      const \
{\n        isRoot: isRootNode\n      } = (_this$getHeaderSettin2 = \
this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && \
_this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {\n        \
isRoot: true\n      };\n      if (isRootNode) {\n        break;\n      }\n    \
  stepBackColumn -= 1;\n    }\n    return stepBackColumn;\n  }\n  /**\n   * \
Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n \
 getLayersCount() {\n    return _classPrivateFieldGet16(this, \
_sourceSettings2).getLayersCount();\n  }\n  /**\n   * Gets a total number of \
columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n  \
  return _classPrivateFieldGet16(this, _sourceSettings2).getColumnsCount();\n \
 }\n  /**\n   * Clears the column state manager to the initial state.\n   \
*/\n  clear() {\n    _classPrivateFieldSet16(this, _stateMatrix, []);\n    \
_classPrivateFieldGet16(this, _sourceSettings2).clear();\n    \
_classPrivateFieldGet16(this, _headersTree).clear();\n  }\n};\n\n// \
node_modules/handsontable/plugins/nestedHeaders/utils/ghostTable.mjs\nfunctio\
n _defineProperty22(obj, key, value) {\n  key = _toPropertyKey22(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey22(arg) {\n  var key = \
_toPrimitive22(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive22(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nvar GhostTable2 = class {\n  constructor(hot2, \
nestedHeaderSettingsGetter) {\n    _defineProperty22(this, \"hot\", void \
0);\n    _defineProperty22(this, \"nestedHeaderSettingsGetter\", void 0);\n   \
 _defineProperty22(this, \"layersCount\", 0);\n    _defineProperty22(this, \
\"container\", void 0);\n    _defineProperty22(this, \"widthsMap\", void \
0);\n    this.hot = hot2;\n    this.nestedHeaderSettingsGetter = \
nestedHeaderSettingsGetter;\n    this.widthsMap = \
this.hot.columnIndexMapper.createAndRegisterIndexMap(\"nestedHeaders.widthsMa\
p\", \"physicalIndexToValue\");\n  }\n  /**\n   * Sets the number of nested \
headers layers count.\n   *\n   * @param {number} layersCount Total number of \
headers levels.\n   * @returns {GhostTable}\n   */\n  \
setLayersCount(layersCount) {\n    this.layersCount = layersCount;\n    \
return this;\n  }\n  /**\n   * Gets the column width based on the visual \
column index.\n   *\n   * @param {number} visualColumn Visual column index.\n \
  * @returns {number|null}\n   */\n  getWidth(visualColumn) {\n    return \
this.widthsMap.getValueAtIndex(this.hot.toPhysicalColumn(visualColumn));\n  \
}\n  /**\n   * Build cache of the headers widths.\n   */\n  buildWidthsMap() \
{\n    this.container = this.hot.rootDocument.createElement(\"div\");\n    \
this.container.classList.add(\"handsontable\", \"htGhostTable\", \
\"htAutoSize\");\n    this._buildGhostTable(this.container);\n    \
this.hot.rootDocument.body.appendChild(this.container);\n    const columns = \
this.container.querySelectorAll(\"tr:last-of-type th\");\n    const \
maxColumns = columns.length;\n    this.widthsMap.clear();\n    for (let \
column = 0; column < maxColumns; column++) {\n      const visualColumnsIndex \
= this.hot.columnIndexMapper.getVisualFromRenderableIndex(column);\n      \
const physicalColumnIndex = this.hot.toPhysicalColumn(visualColumnsIndex);\n  \
    this.widthsMap.setValueAtIndex(physicalColumnIndex, \
columns[column].offsetWidth);\n    }\n    \
this.container.parentNode.removeChild(this.container);\n    this.container = \
null;\n  }\n  /**\n   * Build temporary table for getting minimal columns \
widths.\n   *\n   * @private\n   * @param {HTMLElement} container The element \
where the DOM nodes are injected.\n   */\n  _buildGhostTable(container) {\n   \
 const {\n      rootDocument,\n      columnIndexMapper\n    } = this.hot;\n   \
 const fragment = rootDocument.createDocumentFragment();\n    const table = \
rootDocument.createElement(\"table\");\n    const isDropdownEnabled = \
!!this.hot.getSettings().dropdownMenu;\n    const maxRenderedCols = \
columnIndexMapper.getRenderableIndexesLength();\n    for (let row = 0; row < \
this.layersCount; row++) {\n      const tr = \
rootDocument.createElement(\"tr\");\n      for (let col = 0; col < \
maxRenderedCols; col++) {\n        let visualColumnsIndex = \
columnIndexMapper.getVisualFromRenderableIndex(col);\n        if \
(visualColumnsIndex === null) {\n          visualColumnsIndex = col;\n        \
}\n        const th = rootDocument.createElement(\"th\");\n        const \
headerSettings = this.nestedHeaderSettingsGetter(row, visualColumnsIndex);\n  \
      if (headerSettings && (!headerSettings.isPlaceholder || \
headerSettings.isHidden)) {\n          let label = headerSettings.label;\n    \
      if (isDropdownEnabled) {\n            label += '<button \
class=\"changeType\"></button>';\n          }\n          fastInnerHTML(th, \
label);\n          th.colSpan = headerSettings.colspan;\n          \
tr.appendChild(th);\n        }\n      }\n      table.appendChild(tr);\n    \
}\n    fragment.appendChild(table);\n    container.appendChild(fragment);\n  \
}\n  /**\n   * Clear the widths cache.\n   */\n  clear() {\n    \
this.widthsMap.clear();\n    this.container = null;\n  }\n};\nvar \
ghostTable_default2 = GhostTable2;\n\n// \
node_modules/handsontable/plugins/nestedHeaders/nestedHeaders.mjs\nfunction \
_defineProperty23(obj, key, value) {\n  key = _toPropertyKey23(key);\n  if \
(key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: \
true, configurable: true, writable: true });\n  } else {\n    obj[key] = \
value;\n  }\n  return obj;\n}\nfunction _toPropertyKey23(arg) {\n  var key = \
_toPrimitive23(arg, \"string\");\n  return typeof key === \"symbol\" ? key : \
String(key);\n}\nfunction _toPrimitive23(input, hint) {\n  if (typeof input \
!== \"object\" || input === null)\n    return input;\n  var prim = \
input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = \
prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\")\n  \
    return res;\n    throw new TypeError(\"@@toPrimitive must return a \
primitive value.\");\n  }\n  return (hint === \"string\" ? String : \
Number)(input);\n}\nfunction _classPrivateFieldInitSpec17(obj, privateMap, \
value) {\n  _checkPrivateRedeclaration18(obj, privateMap);\n  \
privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration18(obj, \
privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new \
TypeError(\"Cannot initialize the same private elements twice on an \
object\");\n  }\n}\nfunction _classPrivateFieldSet17(receiver, privateMap, \
value) {\n  var descriptor = _classExtractFieldDescriptor17(receiver, \
privateMap, \"set\");\n  _classApplyDescriptorSet17(receiver, descriptor, \
value);\n  return value;\n}\nfunction _classApplyDescriptorSet17(receiver, \
descriptor, value) {\n  if (descriptor.set) {\n    \
descriptor.set.call(receiver, value);\n  } else {\n    if \
(!descriptor.writable) {\n      throw new TypeError(\"attempted to set read \
only private field\");\n    }\n    descriptor.value = value;\n  \
}\n}\nfunction _classPrivateFieldGet17(receiver, privateMap) {\n  var \
descriptor = _classExtractFieldDescriptor17(receiver, privateMap, \"get\");\n \
 return _classApplyDescriptorGet17(receiver, descriptor);\n}\nfunction \
_classExtractFieldDescriptor17(receiver, privateMap, action) {\n  if \
(!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + \
action + \" private field on non-instance\");\n  }\n  return \
privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet17(receiver, \
descriptor) {\n  if (descriptor.get) {\n    return \
descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nvar \
PLUGIN_KEY28 = \"nestedHeaders\";\nvar PLUGIN_PRIORITY27 = 280;\nvar \
_stateManager = /* @__PURE__ */ new WeakMap();\nvar _hidingIndexMapObserver = \
/* @__PURE__ */ new WeakMap();\nvar NestedHeaders = class extends BasePlugin \
{\n  constructor() {\n    super(...arguments);\n    \
_classPrivateFieldInitSpec17(this, _stateManager, {\n      writable: true,\n  \
    value: new StateManager()\n    });\n    \
_classPrivateFieldInitSpec17(this, _hidingIndexMapObserver, {\n      \
writable: true,\n      value: null\n    });\n    _defineProperty23(this, \
\"ghostTable\", new ghostTable_default2(this.hot, (row, column) => \
this.getHeaderSettings(row, column)));\n    _defineProperty23(this, \
\"detectedOverlappedHeaders\", false);\n  }\n  static get PLUGIN_KEY() {\n    \
return PLUGIN_KEY28;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY27;\n  }\n  /**\n   * Check if plugin is enabled.\n   *\n   * \
@returns {boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY28];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const \
{\n      nestedHeaders\n    } = this.hot.getSettings();\n    if \
(!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {\n      \
warn(toSingleLine`Your Nested Headers plugin configuration is invalid. The \
settings has to be\\x20\n                        passed as an array of arrays \
e.q. [['A1', { label: 'A2', colspan: 2 }]]`);\n    }\n    \
this.addHook(\"init\", () => this.onInit());\n    \
this.addHook(\"afterLoadData\", function() {\n      return \
_this.onAfterLoadData(...arguments);\n    });\n    \
this.addHook(\"beforeOnCellMouseDown\", function() {\n      return \
_this.onBeforeOnCellMouseDown(...arguments);\n    });\n    \
this.addHook(\"afterOnCellMouseDown\", function() {\n      return \
_this.onAfterOnCellMouseDown(...arguments);\n    });\n    \
this.addHook(\"beforeOnCellMouseOver\", function() {\n      return \
_this.onBeforeOnCellMouseOver(...arguments);\n    });\n    \
this.addHook(\"afterGetColumnHeaderRenderers\", (array) => \
this.onAfterGetColumnHeaderRenderers(array));\n    \
this.addHook(\"modifyColWidth\", function() {\n      return \
_this.onModifyColWidth(...arguments);\n    });\n    \
this.addHook(\"modifyColumnHeaderValue\", function() {\n      return \
_this.onModifyColumnHeaderValue(...arguments);\n    });\n    \
this.addHook(\"beforeHighlightingColumnHeader\", function() {\n      return \
_this.onBeforeHighlightingColumnHeader(...arguments);\n    });\n    \
this.addHook(\"beforeCopy\", function() {\n      return \
_this.onBeforeCopy(...arguments);\n    });\n    \
this.addHook(\"afterViewportColumnCalculatorOverride\", function() {\n      \
return _this.onAfterViewportColumnCalculatorOverride(...arguments);\n    \
});\n    super.enablePlugin();\n    this.updatePlugin();\n  }\n  /**\n   * \
Updates the plugin's state.\n   *\n   * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`nestedHeaders`](@/api/options.md#nestedheaders)\n   */\n  updatePlugin() \
{\n    if (!this.hot.view) {\n      return;\n    }\n    const {\n      \
nestedHeaders\n    } = this.hot.getSettings();\n    \
_classPrivateFieldGet17(this, \
_stateManager).setColumnsLimit(this.hot.countCols());\n    if \
(Array.isArray(nestedHeaders)) {\n      this.detectedOverlappedHeaders = \
_classPrivateFieldGet17(this, _stateManager).setState(nestedHeaders);\n    \
}\n    if (this.detectedOverlappedHeaders) {\n      warn(toSingleLine`Your \
Nested Headers plugin setup contains overlapping headers. This kind of \
configuration\\x20\n                        is currently not supported.`);\n  \
  }\n    if (this.enabled) {\n      \
this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach((is\
ColumnHidden, physicalColumnIndex) => {\n        const actionName = \
isColumnHidden === true ? \"hide-column\" : \"show-column\";\n        \
_classPrivateFieldGet17(this, \
_stateManager).triggerColumnModification(actionName, physicalColumnIndex);\n  \
    });\n    }\n    if (!_classPrivateFieldGet17(this, \
_hidingIndexMapObserver) && this.enabled) {\n      \
_classPrivateFieldSet17(this, _hidingIndexMapObserver, \
this.hot.columnIndexMapper.createChangesObserver(\"hiding\").subscribe((chang\
es) => {\n        changes.forEach((_ref) => {\n          let {\n            \
op,\n            index: columnIndex,\n            newValue\n          } = \
_ref;\n          if (op === \"replace\") {\n            const actionName = \
newValue === true ? \"hide-column\" : \"show-column\";\n            \
_classPrivateFieldGet17(this, \
_stateManager).triggerColumnModification(actionName, columnIndex);\n          \
}\n        });\n        this.ghostTable.buildWidthsMap();\n      }));\n    \
}\n    \
this.ghostTable.setLayersCount(this.getLayersCount()).buildWidthsMap();\n    \
super.updatePlugin();\n  }\n  /**\n   * Disables the plugin functionality for \
this Handsontable instance.\n   */\n  disablePlugin() {\n    \
this.clearColspans();\n    _classPrivateFieldGet17(this, \
_stateManager).clear();\n    _classPrivateFieldGet17(this, \
_hidingIndexMapObserver).unsubscribe();\n    _classPrivateFieldSet17(this, \
_hidingIndexMapObserver, null);\n    this.ghostTable.clear();\n    \
super.disablePlugin();\n  }\n  /**\n   * Returns an instance of the internal \
state manager of the plugin.\n   *\n   * @private\n   * @returns \
{StateManager}\n   */\n  getStateManager() {\n    return \
_classPrivateFieldGet17(this, _stateManager);\n  }\n  /**\n   * Gets a total \
number of headers levels.\n   *\n   * @private\n   * @returns {number}\n   \
*/\n  getLayersCount() {\n    return _classPrivateFieldGet17(this, \
_stateManager).getLayersCount();\n  }\n  /**\n   * Gets column settings for a \
specified header. The returned object contains\n   * information about the \
header label, its colspan length, or if it is hidden\n   * in the header \
renderers.\n   *\n   * @private\n   * @param {number} headerLevel Header \
level (0 = most distant to the table).\n   * @param {number} columnIndex A \
visual column index.\n   * @returns {object}\n   */\n  \
getHeaderSettings(headerLevel, columnIndex) {\n    return \
_classPrivateFieldGet17(this, _stateManager).getHeaderSettings(headerLevel, \
columnIndex);\n  }\n  /**\n   * Clear the colspans remaining after plugin \
usage.\n   *\n   * @private\n   */\n  clearColspans() {\n    if \
(!this.hot.view) {\n      return;\n    }\n    const {\n      _wt: wt\n    } = \
this.hot.view;\n    const headerLevels = \
wt.getSetting(\"columnHeaders\").length;\n    const mainHeaders = \
wt.wtTable.THEAD;\n    const topHeaders = \
wt.wtOverlays.topOverlay.clone.wtTable.THEAD;\n    const topLeftCornerHeaders \
= wt.wtOverlays.topInlineStartCornerOverlay ? \
wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;\n    \
for (let i = 0; i < headerLevels; i++) {\n      const masterLevel = \
mainHeaders.childNodes[i];\n      if (!masterLevel) {\n        break;\n      \
}\n      const topLevel = topHeaders.childNodes[i];\n      const \
topLeftCornerLevel = topLeftCornerHeaders ? \
topLeftCornerHeaders.childNodes[i] : null;\n      for (let j = 0, masterNodes \
= masterLevel.childNodes.length; j < masterNodes; j++) {\n        \
masterLevel.childNodes[j].removeAttribute(\"colspan\");\n        \
removeClass(masterLevel.childNodes[j], \"hiddenHeader\");\n        if \
(topLevel && topLevel.childNodes[j]) {\n          \
topLevel.childNodes[j].removeAttribute(\"colspan\");\n          \
removeClass(topLevel.childNodes[j], \"hiddenHeader\");\n        }\n        if \
(topLeftCornerHeaders && topLeftCornerLevel && \
topLeftCornerLevel.childNodes[j]) {\n          \
topLeftCornerLevel.childNodes[j].removeAttribute(\"colspan\");\n          \
removeClass(topLeftCornerLevel.childNodes[j], \"hiddenHeader\");\n        }\n \
     }\n    }\n  }\n  /**\n   * Generates the appropriate header renderer for \
a header row.\n   *\n   * @private\n   * @param {number} headerLevel The \
index of header level counting from the top (positive\n   *                   \
          values counting from 0 to N).\n   * @returns {Function}\n   * \
@fires Hooks#afterGetColHeader\n   */\n  headerRendererFactory(headerLevel) \
{\n    var _this2 = this;\n    const fixedColumnsStart = \
this.hot.view._wt.getSetting(\"fixedColumnsStart\");\n    return \
(renderedColumnIndex, TH) => {\n      var _classPrivateFieldGet22;\n      \
const {\n        columnIndexMapper,\n        view\n      } = this.hot;\n      \
let visualColumnIndex = \
columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n      \
if (visualColumnIndex === null) {\n        visualColumnIndex = \
renderedColumnIndex;\n      }\n      TH.removeAttribute(\"colspan\");\n      \
removeClass(TH, \"hiddenHeader\");\n      const {\n        colspan,\n        \
isHidden,\n        isPlaceholder\n      } = (_classPrivateFieldGet22 = \
_classPrivateFieldGet17(this, _stateManager).getHeaderSettings(headerLevel, \
visualColumnIndex)) !== null && _classPrivateFieldGet22 !== void 0 ? \
_classPrivateFieldGet22 : {\n        label: \"\"\n      };\n      if \
(isPlaceholder || isHidden) {\n        addClass(TH, \"hiddenHeader\");\n      \
} else if (colspan > 1) {\n        var _wtOverlays$topInline, \
_wtOverlays$inlineSta;\n        const {\n          wtOverlays\n        } = \
view._wt;\n        const isTopInlineStartOverlay = (_wtOverlays$topInline = \
wtOverlays.topInlineStartCornerOverlay) === null || _wtOverlays$topInline === \
void 0 ? void 0 : _wtOverlays$topInline.clone.wtTable.THEAD.contains(TH);\n   \
     const isInlineStartOverlay = (_wtOverlays$inlineSta = \
wtOverlays.inlineStartOverlay) === null || _wtOverlays$inlineSta === void 0 ? \
void 0 : _wtOverlays$inlineSta.clone.wtTable.THEAD.contains(TH);\n        \
const correctedColspan = isTopInlineStartOverlay || isInlineStartOverlay ? \
Math.min(colspan, fixedColumnsStart - renderedColumnIndex) : colspan;\n       \
 if (correctedColspan > 1) {\n          TH.setAttribute(\"colspan\", \
correctedColspan);\n        }\n      }\n      \
this.hot.view.appendColHeader(visualColumnIndex, TH, function() {\n        \
return _this2.getColumnHeaderValue(...arguments);\n      }, headerLevel);\n   \
 };\n  }\n  /**\n   * Returns the column header value for specified column \
and header level index.\n   *\n   * @private\n   * @param {number} \
visualColumnIndex Visual column index.\n   * @param {number} headerLevel The \
index of header level. The header level accepts positive (0 to N)\n   *       \
                      and negative (-1 to -N) values. For positive values, 0 \
points to the\n   *                             top most header, and for \
negative direction, -1 points to the most bottom\n   *                        \
     header (the header closest to the cells).\n   * @returns {string} \
Returns the column header value to update.\n   */\n  \
getColumnHeaderValue(visualColumnIndex, headerLevel) {\n    var \
_classPrivateFieldGet32;\n    const {\n      isHidden,\n      isPlaceholder\n \
   } = (_classPrivateFieldGet32 = _classPrivateFieldGet17(this, \
_stateManager).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && \
_classPrivateFieldGet32 !== void 0 ? _classPrivateFieldGet32 : {};\n    if \
(isPlaceholder || isHidden) {\n      return \"\";\n    }\n    return \
this.hot.getColHeader(visualColumnIndex, headerLevel);\n  }\n  /**\n   * \
Allows to control which header DOM element will be used to highlight.\n   *\n \
  * @private\n   * @param {number} visualColumn A visual column index of the \
highlighted row header.\n   * @param {number} headerLevel A row header level \
that is currently highlighted.\n   * @param {object} highlightMeta An object \
with meta data that describes the highlight state.\n   * @returns {number}\n  \
 */\n  onBeforeHighlightingColumnHeader(visualColumn, headerLevel, \
highlightMeta) {\n    const headerNodeData = _classPrivateFieldGet17(this, \
_stateManager).getHeaderTreeNodeData(headerLevel, visualColumn);\n    if \
(!headerNodeData) {\n      return visualColumn;\n    }\n    const {\n      \
classNames,\n      columnCursor,\n      selectionType,\n      \
selectionWidth\n    } = highlightMeta;\n    const {\n      isRoot,\n      \
colspan\n    } = _classPrivateFieldGet17(this, \
_stateManager).getHeaderSettings(headerLevel, visualColumn);\n    if \
(selectionType === HEADER_TYPE) {\n      if (!isRoot) {\n        return \
headerNodeData.columnIndex;\n      }\n    } else if (selectionType === \
ACTIVE_HEADER_TYPE) {\n      if (colspan > selectionWidth - columnCursor || \
!isRoot) {\n        classNames.length = 0;\n      }\n    }\n    return \
visualColumn;\n  }\n  /**\n   * Listens the `beforeCopy` hook that allows \
processing the copied column headers so that the\n   * merged column headers \
do not propagate the value for each column but only once at the beginning\n   \
* of the column.\n   *\n   * @private\n   * @param {Array[]} data An array of \
arrays which contains data to copied.\n   * @param {object[]} copyableRanges \
An array of objects with ranges of the visual indexes (`startRow`, \
`startCol`, `endRow`, `endCol`)\n   *                                  which \
will copied.\n   * @param {{ columnHeadersCount: number }} copiedHeadersCount \
An object with keys that holds information with\n   *                         \
                                   the number of copied headers.\n   */\n  \
onBeforeCopy(data2, copyableRanges, _ref2) {\n    let {\n      \
columnHeadersCount\n    } = _ref2;\n    if (columnHeadersCount === 0) {\n     \
 return;\n    }\n    for (let rangeIndex = 0; rangeIndex < \
copyableRanges.length; rangeIndex++) {\n      const {\n        startRow,\n    \
    startCol,\n        endRow,\n        endCol\n      } = \
copyableRanges[rangeIndex];\n      const rowsCount = endRow - startRow + 1;\n \
     const columnsCount = startCol - endCol + 1;\n      if (startRow >= 0 || \
columnsCount === 1) {\n        break;\n      }\n      for (let column = \
startCol; column <= endCol; column++) {\n        for (let row = startRow; row \
<= endRow; row++) {\n          var _classPrivateFieldGet42;\n          const \
zeroBasedColumnHeaderLevel = rowsCount + row;\n          const \
zeroBasedColumnIndex = column - startCol;\n          if (zeroBasedColumnIndex \
=== 0) {\n            continue;\n          }\n          const isRoot = \
(_classPrivateFieldGet42 = _classPrivateFieldGet17(this, \
_stateManager).getHeaderTreeNodeData(row, column)) === null || \
_classPrivateFieldGet42 === void 0 ? void 0 : \
_classPrivateFieldGet42.isRoot;\n          if (isRoot === false) {\n          \
  data2[zeroBasedColumnHeaderLevel][zeroBasedColumnIndex] = \"\";\n          \
}\n        }\n      }\n    }\n  }\n  /**\n   * Allows blocking the column \
selection that is controlled by the core Selection module.\n   *\n   * \
@private\n   * @param {MouseEvent} event Mouse event.\n   * @param \
{CellCoords} coords Cell coords object containing the visual coordinates of \
the clicked cell.\n   * @param {CellCoords} TD The table cell or header \
element.\n   * @param {object} controller An object with properties `row`, \
`column` and `cell`. Each property contains\n   *                            \
a boolean value that allows or disallows changing the selection for that \
particular area.\n   */\n  onBeforeOnCellMouseDown(event2, coords, TD, \
controller) {\n    const headerNodeData = \
this._getHeaderTreeNodeDataByCoords(coords);\n    if (headerNodeData) {\n     \
 controller.column = true;\n    }\n  }\n  /**\n   * Allows to control how the \
column selection based on the coordinates and the nested headers is made.\n   \
*\n   * @private\n   * @param {MouseEvent} event Mouse event.\n   * @param \
{CellCoords} coords Cell coords object containing the visual coordinates of \
the clicked cell.\n   */\n  onAfterOnCellMouseDown(event2, coords) {\n    \
const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n    if \
(!headerNodeData) {\n      return;\n    }\n    const {\n      selection\n    \
} = this.hot;\n    const currentSelection = selection.isSelected() ? \
selection.getSelectedRange().current() : null;\n    const columnsToSelect = \
[];\n    const {\n      columnIndex,\n      origColspan\n    } = \
headerNodeData;\n    const allowRightClickSelection = \
!selection.inInSelection(coords);\n    if (event2.shiftKey && \
currentSelection) {\n      if (coords.col < currentSelection.from.col) {\n    \
    columnsToSelect.push(currentSelection.getTopEndCorner().col, columnIndex, \
coords.row);\n      } else if (coords.col > currentSelection.from.col) {\n    \
    columnsToSelect.push(currentSelection.getTopStartCorner().col, \
columnIndex + origColspan - 1, coords.row);\n      } else {\n        \
columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, \
coords.row);\n      }\n    } else if (isLeftClick(event2) || \
isRightClick(event2) && allowRightClickSelection) {\n      \
columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, \
coords.row);\n    }\n    selection.selectColumns(...columnsToSelect);\n  }\n  \
/**\n   * Makes the header-selection properly select the nested headers.\n   \
*\n   * @private\n   * @param {MouseEvent} event Mouse event.\n   * @param \
{CellCoords} coords Cell coords object containing the visual coordinates of \
the clicked cell.\n   * @param {HTMLElement} TD The cell element.\n   * \
@param {object} controller An object with properties `row`, `column` and \
`cell`. Each property contains\n   *                            a boolean \
value that allows or disallows changing the selection for that particular \
area.\n   */\n  onBeforeOnCellMouseOver(event2, coords, TD, controller) {\n   \
 if (!this.hot.view.isMouseDown()) {\n      return;\n    }\n    const \
headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n    if \
(!headerNodeData) {\n      return;\n    }\n    const {\n      columnIndex,\n  \
    origColspan\n    } = headerNodeData;\n    const selectedRange = \
this.hot.getSelectedRangeLast();\n    const topStartCoords = \
selectedRange.getTopStartCorner();\n    const bottomEndCoords = \
selectedRange.getBottomEndCorner();\n    const {\n      from\n    } = \
selectedRange;\n    controller.column = true;\n    controller.cell = true;\n  \
  const columnsToSelect = [];\n    if (coords.col < from.col) {\n      \
columnsToSelect.push(bottomEndCoords.col, columnIndex);\n    } else if \
(coords.col > from.col) {\n      columnsToSelect.push(topStartCoords.col, \
columnIndex + origColspan - 1);\n    } else {\n      \
columnsToSelect.push(columnIndex, columnIndex + origColspan - 1);\n    }\n    \
this.hot.selectColumns(...columnsToSelect);\n  }\n  /**\n   * \
`afterGetColumnHeader` hook callback - prepares the header structure.\n   *\n \
  * @private\n   * @param {Array} renderersArray Array of renderers.\n   */\n \
 onAfterGetColumnHeaderRenderers(renderersArray) {\n    renderersArray.length \
= 0;\n    for (let headerLayer = 0; headerLayer < \
_classPrivateFieldGet17(this, _stateManager).getLayersCount(); headerLayer++) \
{\n      renderersArray.push(this.headerRendererFactory(headerLayer));\n    \
}\n  }\n  /**\n   * Make the renderer render the first nested column in its \
entirety.\n   *\n   * @private\n   * @param {object} calc Viewport column \
calculator.\n   */\n  onAfterViewportColumnCalculatorOverride(calc) {\n    \
const headerLayersCount = _classPrivateFieldGet17(this, \
_stateManager).getLayersCount();\n    let newStartColumn = \
calc.startColumn;\n    let nonRenderable = !!headerLayersCount;\n    for (let \
headerLayer = 0; headerLayer < headerLayersCount; headerLayer++) {\n      \
const startColumn = _classPrivateFieldGet17(this, \
_stateManager).findLeftMostColumnIndex(headerLayer, calc.startColumn);\n      \
const renderedStartColumn = \
this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);\n      \
if (startColumn >= 0) {\n        nonRenderable = false;\n      }\n      if \
(isNumeric(renderedStartColumn) && renderedStartColumn < calc.startColumn) \
{\n        newStartColumn = renderedStartColumn;\n        break;\n      }\n   \
 }\n    calc.startColumn = nonRenderable ? _classPrivateFieldGet17(this, \
_stateManager).getHeaderTreeNodeData(0, newStartColumn).columnIndex : \
newStartColumn;\n  }\n  /**\n   * `modifyColWidth` hook callback - returns \
width from cache, when is greater than incoming from hook.\n   *\n   * \
@private\n   * @param {number} width Width from hook.\n   * @param {number} \
column Visual index of an column.\n   * @returns {number}\n   */\n  \
onModifyColWidth(width, column) {\n    const cachedWidth = \
this.ghostTable.getWidth(column);\n    return width > cachedWidth ? width : \
cachedWidth;\n  }\n  /**\n   * Listens the `modifyColumnHeaderValue` hook \
that overwrites the column headers values based on\n   * the internal state \
and settings of the plugin.\n   *\n   * @private\n   * @param {string} value \
The column header value.\n   * @param {number} visualColumnIndex The visual \
column index.\n   * @param {number} headerLevel The index of header level. \
The header level accepts positive (0 to N)\n   *                             \
and negative (-1 to -N) values. For positive values, 0 points to the\n   *    \
                         top most header, and for negative direction, -1 \
points to the most bottom\n   *                             header (the \
header closest to the cells).\n   * @returns {string} Returns the column \
header value to update.\n   */\n  onModifyColumnHeaderValue(value, \
visualColumnIndex, headerLevel) {\n    var _classPrivateFieldGet52;\n    \
const {\n      label\n    } = (_classPrivateFieldGet52 = \
_classPrivateFieldGet17(this, \
_stateManager).getHeaderTreeNodeData(headerLevel, visualColumnIndex)) !== \
null && _classPrivateFieldGet52 !== void 0 ? _classPrivateFieldGet52 : {\n    \
  label: \"\"\n    };\n    return label;\n  }\n  /**\n   * Updates the plugin \
state after HoT initialization.\n   *\n   * @private\n   */\n  onInit() {\n   \
 this.updatePlugin();\n  }\n  /**\n   * Updates the plugin state after new \
dataset load.\n   *\n   * @private\n   * @param {Array[]} sourceData Array of \
arrays or array of objects containing data.\n   * @param {boolean} \
initialLoad Flag that determines whether the data has been loaded\n   *       \
                       during the initialization.\n   */\n  \
onAfterLoadData(sourceData, initialLoad) {\n    if (!initialLoad) {\n      \
this.updatePlugin();\n    }\n  }\n  /**\n   * Destroys the plugin instance.\n \
  */\n  destroy() {\n    _classPrivateFieldSet17(this, _stateManager, \
null);\n    if (_classPrivateFieldGet17(this, _hidingIndexMapObserver) !== \
null) {\n      _classPrivateFieldGet17(this, \
_hidingIndexMapObserver).unsubscribe();\n      _classPrivateFieldSet17(this, \
_hidingIndexMapObserver, null);\n    }\n    super.destroy();\n  }\n  /**\n   \
* Gets the tree data that belongs to the column headers pointed by the passed \
coordinates.\n   *\n   * @private\n   * @param {CellCoords} coords The \
CellCoords instance.\n   * @returns {object|undefined}\n   */\n  \
_getHeaderTreeNodeDataByCoords(coords) {\n    if (coords.row >= 0 || \
coords.col < 0) {\n      return;\n    }\n    return \
_classPrivateFieldGet17(this, \
_stateManager).getHeaderTreeNodeData(coords.row, coords.col);\n  }\n};\n\n// \
node_modules/handsontable/plugins/nestedRows/data/dataManager.mjs\nvar \
DataManager = class {\n  constructor(nestedRowsPlugin, hotInstance) {\n    \
this.hot = hotInstance;\n    this.data = null;\n    this.plugin = \
nestedRowsPlugin;\n    this.parentReference = /* @__PURE__ */ new \
WeakMap();\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n     \
 rows: [],\n      nodeInfo: /* @__PURE__ */ new WeakMap()\n    };\n  }\n  \
/**\n   * Set the data for the manager.\n   *\n   * @param \
{Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the \
manager.\n   */\n  setData(data2) {\n    this.data = data2;\n  }\n  /**\n   * \
Get the data cached in the manager.\n   *\n   * @returns \
{Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  getData() {\n \
   return this.data;\n  }\n  /**\n   * Load the \"raw\" source data, without \
NestedRows' modifications.\n   *\n   * @returns \
{Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  \
getRawSourceData() {\n    let rawSourceData = null;\n    \
this.plugin.disableCoreAPIModifiers();\n    rawSourceData = \
this.hot.getSourceData();\n    this.plugin.enableCoreAPIModifiers();\n    \
return rawSourceData;\n  }\n  /**\n   * Update the Data Manager with new data \
and refresh cache.\n   *\n   * @param \
{Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the \
manager.\n   */\n  updateWithData(data2) {\n    this.setData(data2);\n    \
this.rewriteCache();\n  }\n  /**\n   * Rewrite the nested structure cache.\n  \
 *\n   * @private\n   */\n  rewriteCache() {\n    this.cache = {\n      \
levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: /* \
@__PURE__ */ new WeakMap()\n    };\n    rangeEach(0, this.data.length - 1, \
(i) => {\n      this.cacheNode(this.data[i], 0, null);\n    });\n  }\n  /**\n \
  * Cache a data node.\n   *\n   * @private\n   * @param {object} node Node \
to cache.\n   * @param {number} level Level of the node.\n   * @param \
{object} parent Parent of the node.\n   */\n  cacheNode(node, level, parent2) \
{\n    if (!this.cache.levels[level]) {\n      this.cache.levels[level] = \
[];\n      this.cache.levelCount += 1;\n    }\n    \
this.cache.levels[level].push(node);\n    this.cache.rows.push(node);\n    \
this.cache.nodeInfo.set(node, {\n      parent: parent2,\n      row: \
this.cache.rows.length - 1,\n      level\n    });\n    if \
(this.hasChildren(node)) {\n      arrayEach(node.__children, (elem) => {\n    \
    this.cacheNode(elem, level + 1, node);\n      });\n    }\n  }\n  /**\n   \
* Get the date for the provided visual row number.\n   *\n   * @param \
{number} row Row index.\n   * @returns {object}\n   */\n  getDataObject(row) \
{\n    return row === null || row === void 0 ? null : this.cache.rows[row];\n \
 }\n  /**\n   * Read the row tree in search for a specific row index or row \
object.\n   *\n   * @private\n   * @param {object} parent The initial parent \
object.\n   * @param {number} readCount Number of read nodes.\n   * @param \
{number} neededIndex The row index we search for.\n   * @param {object} \
neededObject The row object we search for.\n   * @returns {number|object}\n   \
*/\n  readTreeNodes(parent2, readCount, neededIndex, neededObject) {\n    let \
rootLevel = false;\n    let readNodesCount = readCount;\n    if \
(isNaN(readNodesCount) && readNodesCount.end) {\n      return \
readNodesCount;\n    }\n    let parentObj = parent2;\n    if (!parentObj) {\n \
     parentObj = {\n        __children: this.data\n      };\n      rootLevel \
= true;\n      readNodesCount -= 1;\n    }\n    if (neededIndex !== null && \
neededIndex !== void 0 && readNodesCount === neededIndex) {\n      return {\n \
       result: parentObj,\n        end: true\n      };\n    }\n    if \
(neededObject !== null && neededObject !== void 0 && parentObj === \
neededObject) {\n      return {\n        result: readNodesCount,\n        \
end: true\n      };\n    }\n    readNodesCount += 1;\n    if \
(parentObj.__children) {\n      arrayEach(parentObj.__children, (val) => {\n  \
      this.parentReference.set(val, rootLevel ? null : parentObj);\n        \
readNodesCount = this.readTreeNodes(val, readNodesCount, neededIndex, \
neededObject);\n        if (isNaN(readNodesCount) && readNodesCount.end) {\n  \
        return false;\n        }\n      });\n    }\n    return \
readNodesCount;\n  }\n  /**\n   * Mock a parent node.\n   *\n   * @private\n  \
 * @returns {*}\n   */\n  mockParent() {\n    const fakeParent = \
this.mockNode();\n    fakeParent.__children = this.data;\n    return \
fakeParent;\n  }\n  /**\n   * Mock a data node.\n   *\n   * @private\n   * \
@returns {{}}\n   */\n  mockNode() {\n    const fakeNode = {};\n    \
objectEach(this.data[0], (val, key) => {\n      fakeNode[key] = null;\n    \
});\n    return fakeNode;\n  }\n  /**\n   * Get the row index for the \
provided row object.\n   *\n   * @param {object} rowObj The row object.\n   * \
@returns {number} Row index.\n   */\n  getRowIndex(rowObj) {\n    return \
rowObj === null || rowObj === void 0 ? null : \
this.cache.nodeInfo.get(rowObj).row;\n  }\n  /**\n   * Get the index of the \
provided row index/row object within its parent.\n   *\n   * @param \
{number|object} row Row index / row object.\n   * @returns {number}\n   */\n  \
getRowIndexWithinParent(row) {\n    let rowObj = null;\n    if (isNaN(row)) \
{\n      rowObj = row;\n    } else {\n      rowObj = \
this.getDataObject(row);\n    }\n    const parent2 = \
this.getRowParent(row);\n    if (parent2 === null || parent2 === void 0) {\n  \
    return this.data.indexOf(rowObj);\n    }\n    return \
parent2.__children.indexOf(rowObj);\n  }\n  /**\n   * Count all rows \
(including all parents and children).\n   *\n   * @returns {number}\n   */\n  \
countAllRows() {\n    const rootNodeMock = {\n      __children: this.data\n   \
 };\n    return this.countChildren(rootNodeMock);\n  }\n  /**\n   * Count \
children of the provided parent.\n   *\n   * @param {object|number} parent \
Parent node.\n   * @returns {number} Children count.\n   */\n  \
countChildren(parent2) {\n    let rowCount = 0;\n    let parentNode = \
parent2;\n    if (!isNaN(parentNode)) {\n      parentNode = \
this.getDataObject(parentNode);\n    }\n    if (!parentNode || \
!parentNode.__children) {\n      return 0;\n    }\n    \
arrayEach(parentNode.__children, (elem) => {\n      rowCount += 1;\n      if \
(elem.__children) {\n        rowCount += this.countChildren(elem);\n      }\n \
   });\n    return rowCount;\n  }\n  /**\n   * Get the parent of the row at \
the provided index.\n   *\n   * @param {number|object} row Physical row \
index.\n   * @returns {object}\n   */\n  getRowParent(row) {\n    let \
rowObject;\n    if (isNaN(row)) {\n      rowObject = row;\n    } else {\n     \
 rowObject = this.getDataObject(row);\n    }\n    return \
this.getRowObjectParent(rowObject);\n  }\n  /**\n   * Get the parent of the \
provided row object.\n   *\n   * @private\n   * @param {object} rowObject The \
row object (tree node).\n   * @returns {object|null}\n   */\n  \
getRowObjectParent(rowObject) {\n    if (!rowObject || typeof rowObject !== \
\"object\") {\n      return null;\n    }\n    return \
this.cache.nodeInfo.get(rowObject).parent;\n  }\n  /**\n   * Get the nesting \
level for the row with the provided row index.\n   *\n   * @param {number} \
row Row index.\n   * @returns {number|null} Row level or null, when row \
doesn't exist.\n   */\n  getRowLevel(row) {\n    let rowObject = null;\n    \
if (isNaN(row)) {\n      rowObject = row;\n    } else {\n      rowObject = \
this.getDataObject(row);\n    }\n    return rowObject ? \
this.getRowObjectLevel(rowObject) : null;\n  }\n  /**\n   * Get the nesting \
level for the row with the provided row index.\n   *\n   * @private\n   * \
@param {object} rowObject Row object.\n   * @returns {number} Row level.\n   \
*/\n  getRowObjectLevel(rowObject) {\n    return rowObject === null || \
rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;\n  \
}\n  /**\n   * Check if the provided row/row element has children.\n   *\n   \
* @param {number|object} row Row number or row element.\n   * @returns \
{boolean}\n   */\n  hasChildren(row) {\n    let rowObj = row;\n    if \
(!isNaN(rowObj)) {\n      rowObj = this.getDataObject(rowObj);\n    }\n    \
return !!(rowObj.__children && rowObj.__children.length);\n  }\n  /**\n   * \
Returns `true` if the row at the provided index has a parent.\n   *\n   * \
@param {number} index Row index.\n   * @returns {boolean} `true` if the row \
at the provided index has a parent, `false` otherwise.\n   */\n  \
isChild(index2) {\n    return this.getRowParent(index2) !== null;\n  }\n  \
/**\n   * Get child at a provided index from the parent element.\n   *\n   * \
@param {object} parent The parent row object.\n   * @param {number} index \
Index of the child element to be retrieved.\n   * @returns {object|null} The \
child element or `null` if the child doesn't exist.\n   */\n  \
getChild(parent2, index2) {\n    var _parent$__children;\n    return \
((_parent$__children = parent2.__children) === null || _parent$__children === \
void 0 ? void 0 : _parent$__children[index2]) || null;\n  }\n  /**\n   * \
Return `true` of the row at the provided index is located at the topmost \
level.\n   *\n   * @param {number} index Row index.\n   * @returns {boolean} \
`true` of the row at the provided index is located at the topmost level, \
`false` otherwise.\n   */\n  isRowHighestLevel(index2) {\n    return \
!this.isChild(index2);\n  }\n  /**\n   * Return `true` if the provided row \
index / row object represents a parent in the nested structure.\n   *\n   * \
@param {number|object} row Row index / row object.\n   * @returns {boolean} \
`true` if the row is a parent, `false` otherwise.\n   */\n  isParent(row) {\n \
   var _rowObj$__children;\n    let rowObj = row;\n    if (!isNaN(rowObj)) \
{\n      rowObj = this.getDataObject(rowObj);\n    }\n    return rowObj && \
!!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || \
_rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;\n  \
}\n  /**\n   * Add a child to the provided parent. It's optional to add a row \
object as the \"element\".\n   *\n   * @param {object} parent The parent row \
object.\n   * @param {object} [element] The element to add as a child.\n   \
*/\n  addChild(parent2, element) {\n    let childElement = element;\n    \
this.hot.runHooks(\"beforeAddChild\", parent2, childElement);\n    let \
parentIndex = null;\n    if (parent2) {\n      parentIndex = \
this.getRowIndex(parent2);\n    }\n    this.hot.runHooks(\"beforeCreateRow\", \
parentIndex + this.countChildren(parent2) + 1, 1);\n    let functionalParent \
= parent2;\n    if (!parent2) {\n      functionalParent = \
this.mockParent();\n    }\n    if (!functionalParent.__children) {\n      \
functionalParent.__children = [];\n    }\n    if (!childElement) {\n      \
childElement = this.mockNode();\n    }\n    \
functionalParent.__children.push(childElement);\n    this.rewriteCache();\n   \
 const newRowIndex = this.getRowIndex(childElement);\n    \
this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);\n    \
this.hot.runHooks(\"afterCreateRow\", newRowIndex, 1);\n    \
this.hot.runHooks(\"afterAddChild\", parent2, childElement);\n  }\n  /**\n   \
* Add a child node to the provided parent at a specified index.\n   *\n   * \
@param {object} parent Parent node.\n   * @param {number} index Index to \
insert the child element at.\n   * @param {object} [element] Element (node) \
to insert.\n   */\n  addChildAtIndex(parent2, index2, element) {\n    let \
childElement = element;\n    let flattenedIndex;\n    if (!childElement) {\n  \
    childElement = this.mockNode();\n    }\n    \
this.hot.runHooks(\"beforeAddChild\", parent2, childElement, index2);\n    if \
(parent2) {\n      const parentIndex = this.getRowIndex(parent2);\n      \
const finalChildIndex = parentIndex + index2 + 1;\n      \
this.hot.runHooks(\"beforeCreateRow\", finalChildIndex, 1);\n      \
parent2.__children.splice(index2, null, childElement);\n      \
this.rewriteCache();\n      this.plugin.disableCoreAPIModifiers();\n      \
this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent2), \
\"__children\", parent2.__children, \"NestedRows.addChildAtIndex\");\n      \
this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);\n      \
this.plugin.enableCoreAPIModifiers();\n      \
this.hot.runHooks(\"afterCreateRow\", finalChildIndex, 1);\n      \
flattenedIndex = finalChildIndex;\n    } else {\n      \
this.plugin.disableCoreAPIModifiers();\n      \
this.hot.alter(\"insert_row_above\", index2, 1, \
\"NestedRows.addChildAtIndex\");\n      \
this.plugin.enableCoreAPIModifiers();\n      flattenedIndex = \
this.getRowIndex(this.data[index2]);\n    }\n    childElement = \
this.getDataObject(flattenedIndex);\n    this.hot.runHooks(\"afterAddChild\", \
parent2, childElement, index2);\n  }\n  /**\n   * Add a sibling element at \
the specified index.\n   *\n   * @param {number} index New element sibling's \
index.\n   * @param {('above'|'below')} where Direction in which the sibling \
is to be created.\n   */\n  addSibling(index2) {\n    let where = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"below\";\n \
   const translatedIndex = this.translateTrimmedRow(index2);\n    const \
parent2 = this.getRowParent(translatedIndex);\n    const indexWithinParent = \
this.getRowIndexWithinParent(translatedIndex);\n    switch (where) {\n      \
case \"below\":\n        this.addChildAtIndex(parent2, indexWithinParent + 1, \
null);\n        break;\n      case \"above\":\n        \
this.addChildAtIndex(parent2, indexWithinParent, null);\n        break;\n     \
 default:\n        break;\n    }\n  }\n  /**\n   * Detach the provided \
element from its parent and add it right after it.\n   *\n   * @param \
{object|Array} elements Row object or an array of selected coordinates.\n   * \
@param {boolean} [forceRender=true] If true (default), it triggers render \
after finished.\n   */\n  detachFromParent(elements) {\n    let forceRender = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    \
let element = null;\n    const rowObjects = [];\n    if \
(Array.isArray(elements)) {\n      rangeEach(elements[0], elements[2], (i) => \
{\n        const translatedIndex = this.translateTrimmedRow(i);\n        \
rowObjects.push(this.getDataObject(translatedIndex));\n      });\n      \
rangeEach(0, rowObjects.length - 2, (i) => {\n        \
this.detachFromParent(rowObjects[i], false);\n      });\n      element = \
rowObjects[rowObjects.length - 1];\n    } else {\n      element = elements;\n \
   }\n    const childRowIndex = this.getRowIndex(element);\n    const \
childCount = this.countChildren(element);\n    const indexWithinParent = \
this.getRowIndexWithinParent(element);\n    const parent2 = \
this.getRowParent(element);\n    const grandparent = \
this.getRowParent(parent2);\n    const grandparentRowIndex = \
this.getRowIndex(grandparent);\n    let movedElementRowIndex = null;\n    \
this.hot.runHooks(\"beforeDetachChild\", parent2, element);\n    if \
(indexWithinParent !== null && indexWithinParent !== void 0) {\n      const \
removedRowIndexes = Array.from(new Array(childRowIndex + childCount + \
1).keys()).splice(-1 * (childCount + 1));\n      \
this.hot.runHooks(\"beforeRemoveRow\", childRowIndex, childCount + 1, \
removedRowIndexes, this.plugin.pluginName);\n      \
parent2.__children.splice(indexWithinParent, 1);\n      \
this.rewriteCache();\n      this.hot.runHooks(\"afterRemoveRow\", \
childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n  \
    if (grandparent) {\n        movedElementRowIndex = grandparentRowIndex + \
this.countChildren(grandparent);\n        const lastGrandparentChild = \
this.getChild(grandparent, this.countChildren(grandparent) - 1);\n        \
const lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);\n   \
     this.hot.runHooks(\"beforeCreateRow\", lastGrandparentChildIndex + 1, \
childCount + 1, this.plugin.pluginName);\n        \
grandparent.__children.push(element);\n      } else {\n        \
movedElementRowIndex = this.hot.countRows() + 1;\n        \
this.hot.runHooks(\"beforeCreateRow\", movedElementRowIndex - 2, childCount + \
1, this.plugin.pluginName);\n        this.data.push(element);\n      }\n    \
}\n    this.rewriteCache();\n    this.hot.runHooks(\"afterCreateRow\", \
movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n    \
this.hot.runHooks(\"afterDetachChild\", parent2, element, \
this.getRowIndex(element));\n    if (forceRender) {\n      \
this.hot.render();\n    }\n  }\n  /**\n   * Filter the data by the \
`logicRows` array.\n   *\n   * @private\n   * @param {number} index Index of \
the first row to remove.\n   * @param {number} amount Number of elements to \
remove.\n   * @param {Array} logicRows Array of indexes to remove.\n   */\n  \
filterData(index2, amount, logicRows) {\n    const elementsToRemove = [];\n   \
 arrayEach(logicRows, (elem) => {\n      \
elementsToRemove.push(this.getDataObject(elem));\n    });\n    \
arrayEach(elementsToRemove, (elem) => {\n      const indexWithinParent = \
this.getRowIndexWithinParent(elem);\n      const tempParent = \
this.getRowParent(elem);\n      if (tempParent === null) {\n        \
this.data.splice(indexWithinParent, 1);\n      } else {\n        \
tempParent.__children.splice(indexWithinParent, 1);\n      }\n    });\n    \
this.rewriteCache();\n  }\n  /**\n   * Used to splice the source data. Needed \
to properly modify the nested structure, which wouldn't work with the\n   * \
default script.\n   *\n   * @private\n   * @param {number} index Physical \
index of the element at the splice beginning.\n   * @param {number} amount \
Number of elements to be removed.\n   * @param {object[]} elements Array of \
row objects to add.\n   */\n  spliceData(index2, amount, elements) {\n    \
const previousElement = this.getDataObject(index2 - 1);\n    let newRowParent \
= null;\n    let indexWithinParent = index2;\n    if (previousElement && \
previousElement.__children && previousElement.__children.length === 0) {\n    \
  newRowParent = previousElement;\n      indexWithinParent = 0;\n    } else \
if (index2 < this.countAllRows()) {\n      newRowParent = \
this.getRowParent(index2);\n      indexWithinParent = \
this.getRowIndexWithinParent(index2);\n    }\n    if (newRowParent) {\n      \
if (elements) {\n        newRowParent.__children.splice(indexWithinParent, \
amount, ...elements);\n      } else {\n        \
newRowParent.__children.splice(indexWithinParent, amount);\n      }\n    } \
else if (elements) {\n      this.data.splice(indexWithinParent, amount, \
...elements);\n    } else {\n      this.data.splice(indexWithinParent, \
amount);\n    }\n    this.rewriteCache();\n  }\n  /**\n   * Update the \
`__children` key of the upmost parent of the provided row object.\n   *\n   * \
@private\n   * @param {object} rowElement Row object.\n   */\n  \
syncRowWithRawSource(rowElement) {\n    let upmostParent = rowElement;\n    \
let tempParent = null;\n    do {\n      tempParent = \
this.getRowParent(tempParent);\n      if (tempParent !== null) {\n        \
upmostParent = tempParent;\n      }\n    } while (tempParent !== null);\n    \
this.plugin.disableCoreAPIModifiers();\n    \
this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), \"__children\", \
upmostParent.__children, \"NestedRows.syncRowWithRawSource\");\n    \
this.plugin.enableCoreAPIModifiers();\n  }\n  /* eslint-disable \
jsdoc/require-param */\n  /**\n   * Move a single row.\n   *\n   * @param \
{number} fromIndex Index of the row to be moved.\n   * @param {number} \
toIndex Index of the destination.\n   * @param {boolean} moveToCollapsed \
`true` if moving a row to a collapsed parent.\n   * @param {boolean} \
moveToLastChild `true` if moving a row to be a last child of the new \
parent.\n   */\n  /* eslint-enable jsdoc/require-param */\n  \
moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {\n    const \
moveToLastRow = toIndex === this.hot.countRows();\n    const fromParent = \
this.getRowParent(fromIndex);\n    const indexInFromParent = \
this.getRowIndexWithinParent(fromIndex);\n    const elemToMove = \
fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n    \
const movingUp = fromIndex > toIndex;\n    let toParent = moveToLastRow ? \
this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);\n    if \
(toParent === null || toParent === void 0) {\n      toParent = \
this.getRowParent(toIndex - 1);\n    }\n    if (toParent === null || toParent \
=== void 0) {\n      toParent = this.getDataObject(toIndex - 1);\n    }\n    \
if (!toParent) {\n      toParent = this.getDataObject(toIndex);\n      \
toParent.__children = [];\n    } else if (!toParent.__children) {\n      \
toParent.__children = [];\n    }\n    const indexInTargetParent = \
moveToLastRow || moveToCollapsed || moveToLastChild ? \
toParent.__children.length : this.getRowIndexWithinParent(toIndex);\n    \
const sameParent = fromParent === toParent;\n    \
toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);\n    \
fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 \
: 0), 1);\n    this.syncRowWithRawSource(fromParent);\n    if (!sameParent) \
{\n      this.syncRowWithRawSource(toParent);\n    }\n  }\n  /**\n   * \
Translate the visual row index to the physical index, taking into \
consideration the state of collapsed rows.\n   *\n   * @private\n   * @param \
{number} row Row index.\n   * @returns {number}\n   */\n  \
translateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      return \
this.plugin.collapsingUI.translateTrimmedRow(row);\n    }\n    return row;\n  \
}\n  /**\n   * Translate the physical row index to the visual index, taking \
into consideration the state of collapsed rows.\n   *\n   * @private\n   * \
@param {number} row Row index.\n   * @returns {number}\n   */\n  \
untranslateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      \
return this.plugin.collapsingUI.untranslateTrimmedRow(row);\n    }\n    \
return row;\n  }\n};\nvar dataManager_default = DataManager;\n\n// \
node_modules/handsontable/plugins/nestedRows/ui/_base.mjs\nvar BaseUI4 = \
class {\n  constructor(pluginInstance, hotInstance) {\n    this.hot = \
hotInstance;\n    this.plugin = pluginInstance;\n  }\n};\nvar base_default7 = \
BaseUI4;\n\n// \
node_modules/handsontable/plugins/nestedRows/ui/headers.mjs\nvar HeadersUI = \
class _HeadersUI extends base_default7 {\n  /**\n   * CSS classes used in the \
row headers.\n   *\n   * @type {object}\n   */\n  static get CSS_CLASSES() \
{\n    return {\n      indicatorContainer: \"ht_nestingLevels\",\n      \
parent: \"ht_nestingParent\",\n      indicator: \"ht_nestingLevel\",\n      \
emptyIndicator: \"ht_nestingLevel_empty\",\n      button: \
\"ht_nestingButton\",\n      expandButton: \"ht_nestingExpand\",\n      \
collapseButton: \"ht_nestingCollapse\"\n    };\n  }\n  \
constructor(nestedRowsPlugin, hotInstance) {\n    super(nestedRowsPlugin, \
hotInstance);\n    this.dataManager = this.plugin.dataManager;\n    \
this.collapsingUI = this.plugin.collapsingUI;\n    this.rowHeaderWidthCache = \
null;\n  }\n  /**\n   * Append nesting indicators and buttons to the row \
headers.\n   *\n   * @private\n   * @param {number} row Row index.\n   * \
@param {HTMLElement} TH TH 3element.\n   */\n  appendLevelIndicators(row, TH) \
{\n    const rowIndex = this.hot.toPhysicalRow(row);\n    const rowLevel = \
this.dataManager.getRowLevel(rowIndex);\n    const rowObject = \
this.dataManager.getDataObject(rowIndex);\n    const innerDiv = \
TH.getElementsByTagName(\"DIV\")[0];\n    const innerSpan = \
innerDiv.querySelector(\"span.rowHeader\");\n    const previousIndicators = \
innerDiv.querySelectorAll('[class^=\"ht_nesting\"]');\n    \
arrayEach(previousIndicators, (elem) => {\n      if (elem) {\n        \
innerDiv.removeChild(elem);\n      }\n    });\n    addClass(TH, \
_HeadersUI.CSS_CLASSES.indicatorContainer);\n    if (rowLevel) {\n      const \
{\n        rootDocument\n      } = this.hot;\n      const initialContent = \
innerSpan.cloneNode(true);\n      innerDiv.innerHTML = \"\";\n      \
rangeEach(0, rowLevel - 1, () => {\n        const levelIndicator = \
rootDocument.createElement(\"SPAN\");\n        addClass(levelIndicator, \
_HeadersUI.CSS_CLASSES.emptyIndicator);\n        \
innerDiv.appendChild(levelIndicator);\n      });\n      \
innerDiv.appendChild(initialContent);\n    }\n    if \
(this.dataManager.hasChildren(rowObject)) {\n      const buttonsContainer = \
this.hot.rootDocument.createElement(\"DIV\");\n      addClass(TH, \
_HeadersUI.CSS_CLASSES.parent);\n      if \
(this.collapsingUI.areChildrenCollapsed(rowIndex)) {\n        \
addClass(buttonsContainer, `${_HeadersUI.CSS_CLASSES.button} \
${_HeadersUI.CSS_CLASSES.expandButton}`);\n      } else {\n        \
addClass(buttonsContainer, `${_HeadersUI.CSS_CLASSES.button} \
${_HeadersUI.CSS_CLASSES.collapseButton}`);\n      }\n      \
innerDiv.appendChild(buttonsContainer);\n    }\n  }\n  /**\n   * Update the \
row header width according to number of levels in the dataset.\n   *\n   * \
@private\n   * @param {number} deepestLevel Cached deepest level of \
nesting.\n   */\n  updateRowHeaderWidth(deepestLevel) {\n    let \
deepestLevelIndex = deepestLevel;\n    if (!deepestLevelIndex) {\n      \
deepestLevelIndex = this.dataManager.cache.levelCount;\n    }\n    \
this.rowHeaderWidthCache = Math.max(50, 11 + 10 * deepestLevelIndex + 25);\n  \
  this.hot.render();\n  }\n};\nvar headers_default = HeadersUI;\n\n// \
node_modules/handsontable/plugins/nestedRows/ui/collapsing.mjs\nvar \
CollapsingUI = class extends base_default7 {\n  constructor(nestedRowsPlugin, \
hotInstance) {\n    var _this;\n    super(nestedRowsPlugin, hotInstance);\n   \
 _this = this;\n    this.dataManager = this.plugin.dataManager;\n    \
this.collapsedRows = [];\n    this.collapsedRowsStash = {\n      stash: \
function() {\n        let forceRender = arguments.length > 0 && arguments[0] \
!== void 0 ? arguments[0] : false;\n        _this.lastCollapsedRows = \
_this.collapsedRows.slice(0);\n        \
_this.expandMultipleChildren(_this.lastCollapsedRows, forceRender);\n      \
},\n      shiftStash: function(baseIndex, targetIndex) {\n        let delta = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        \
if (targetIndex === null || targetIndex === void 0) {\n          targetIndex \
= Infinity;\n        }\n        arrayEach(_this.lastCollapsedRows, (elem, i) \
=> {\n          if (elem >= baseIndex && elem < targetIndex) {\n            \
_this.lastCollapsedRows[i] = elem + delta;\n          }\n        });\n      \
},\n      applyStash: function() {\n        let forceRender = \
arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n      \
  _this.collapseMultipleChildren(_this.lastCollapsedRows, forceRender);\n     \
   _this.lastCollapsedRows = void 0;\n      },\n      trimStash: \
(realElementIndex, amount) => {\n        rangeEach(realElementIndex, \
realElementIndex + amount - 1, (i) => {\n          const indexOfElement = \
this.lastCollapsedRows.indexOf(i);\n          if (indexOfElement > -1) {\n    \
        this.lastCollapsedRows.splice(indexOfElement, 1);\n          }\n      \
  });\n      }\n    };\n  }\n  /**\n   * Collapse the children of the row \
passed as an argument.\n   *\n   * @param {number|object} row The parent \
row.\n   * @param {boolean} [forceRender=true] Whether to render the table \
after the function ends.\n   * @param {boolean} [doTrimming=true] I determine \
whether collapsing should envolve trimming rows.\n   * @returns {Array}\n   \
*/\n  collapseChildren(row) {\n    let forceRender = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : true;\n    let doTrimming = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    \
const rowsToCollapse = [];\n    let rowObject = null;\n    let rowIndex = \
null;\n    let rowsToTrim = null;\n    if (isNaN(row)) {\n      rowObject = \
row;\n      rowIndex = this.dataManager.getRowIndex(rowObject);\n    } else \
{\n      rowObject = this.dataManager.getDataObject(row);\n      rowIndex = \
row;\n    }\n    if (this.dataManager.hasChildren(rowObject)) {\n      \
arrayEach(rowObject.__children, (elem) => {\n        \
rowsToCollapse.push(this.dataManager.getRowIndex(elem));\n      });\n    }\n  \
  rowsToTrim = this.collapseRows(rowsToCollapse, true, false);\n    if \
(doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n    if (forceRender) \
{\n      this.renderAndAdjust();\n    }\n    if \
(this.collapsedRows.indexOf(rowIndex) === -1) {\n      \
this.collapsedRows.push(rowIndex);\n    }\n    return rowsToTrim;\n  }\n  \
/**\n   * Collapse multiple children.\n   *\n   * @param {Array} rows Rows to \
collapse (including their children).\n   * @param {boolean} \
[forceRender=true] `true` if the table should be rendered after finishing the \
function.\n   * @param {boolean} [doTrimming=true] I determine whether \
collapsing should envolve trimming rows.\n   */\n  \
collapseMultipleChildren(rows) {\n    let forceRender = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : true;\n    let doTrimming = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    \
const rowsToTrim = [];\n    arrayEach(rows, (elem) => {\n      \
rowsToTrim.push(...this.collapseChildren(elem, false, false));\n    });\n    \
if (doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n    if \
(forceRender) {\n      this.renderAndAdjust();\n    }\n  }\n  /**\n   * \
Collapse a single row.\n   *\n   * @param {number} rowIndex Index of the row \
to collapse.\n   * @param {boolean} [recursive=true] `true` if it should \
collapse the row's children.\n   */\n  collapseRow(rowIndex) {\n    let \
recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
true;\n    this.collapseRows([rowIndex], recursive);\n  }\n  /**\n   * \
Collapse multiple rows.\n   *\n   * @param {Array} rowIndexes Array of row \
indexes to collapse.\n   * @param {boolean} [recursive=true] `true` if it \
should collapse the rows' children.\n   * @param {boolean} [doTrimming=true] \
I determine whether collapsing should envolve trimming rows.\n   * @returns \
{Array} Rows prepared for trimming (or trimmed, if doTrimming == true).\n   \
*/\n  collapseRows(rowIndexes) {\n    let recursive = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : true;\n    let doTrimming = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    \
const rowsToTrim = [];\n    arrayEach(rowIndexes, (elem) => {\n      \
rowsToTrim.push(elem);\n      if (recursive) {\n        \
this.collapseChildRows(elem, rowsToTrim);\n      }\n    });\n    if \
(doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n    return \
rowsToTrim;\n  }\n  /**\n   * Collapse child rows of the row at the provided \
index.\n   *\n   * @param {number} parentIndex Index of the parent node.\n   \
* @param {Array} [rowsToTrim=[]] Array of rows to trim. Defaults to an empty \
array.\n   * @param {boolean} [recursive] `true` if the collapsing process \
should be recursive.\n   * @param {boolean} [doTrimming=true] I determine \
whether collapsing should envolve trimming rows.\n   */\n  \
collapseChildRows(parentIndex) {\n    let rowsToTrim = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : [];\n    let recursive = \
arguments.length > 2 ? arguments[2] : void 0;\n    let doTrimming = \
arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    \
if (this.dataManager.hasChildren(parentIndex)) {\n      const parentObject = \
this.dataManager.getDataObject(parentIndex);\n      \
arrayEach(parentObject.__children, (elem) => {\n        const elemIndex = \
this.dataManager.getRowIndex(elem);\n        rowsToTrim.push(elemIndex);\n    \
    this.collapseChildRows(elemIndex, rowsToTrim);\n      });\n    }\n    if \
(doTrimming) {\n      this.trimRows(rowsToTrim);\n    }\n  }\n  /**\n   * \
Expand a single row.\n   *\n   * @param {number} rowIndex Index of the row to \
expand.\n   * @param {boolean} [recursive=true] `true` if it should expand \
the row's children recursively.\n   */\n  expandRow(rowIndex) {\n    let \
recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \
true;\n    this.expandRows([rowIndex], recursive);\n  }\n  /**\n   * Expand \
multiple rows.\n   *\n   * @param {Array} rowIndexes Array of indexes of the \
rows to expand.\n   * @param {boolean} [recursive=true] `true` if it should \
expand the rows' children recursively.\n   * @param {boolean} \
[doTrimming=true] I determine whether collapsing should envolve trimming \
rows.\n   * @returns {Array} Array of row indexes to be untrimmed.\n   */\n  \
expandRows(rowIndexes) {\n    let recursive = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : true;\n    let doTrimming = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    \
const rowsToUntrim = [];\n    arrayEach(rowIndexes, (elem) => {\n      \
rowsToUntrim.push(elem);\n      if (recursive) {\n        \
this.expandChildRows(elem, rowsToUntrim);\n      }\n    });\n    if \
(doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n    return \
rowsToUntrim;\n  }\n  /**\n   * Expand child rows of the provided index.\n   \
*\n   * @param {number} parentIndex Index of the parent row.\n   * @param \
{Array} [rowsToUntrim=[]] Array of the rows to be untrimmed.\n   * @param \
{boolean} [recursive] `true` if it should expand the rows' children \
recursively.\n   * @param {boolean} [doTrimming=false] I determine whether \
collapsing should envolve trimming rows.\n   */\n  \
expandChildRows(parentIndex) {\n    let rowsToUntrim = arguments.length > 1 \
&& arguments[1] !== void 0 ? arguments[1] : [];\n    let recursive = \
arguments.length > 2 ? arguments[2] : void 0;\n    let doTrimming = \
arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    \
if (this.dataManager.hasChildren(parentIndex)) {\n      const parentObject = \
this.dataManager.getDataObject(parentIndex);\n      \
arrayEach(parentObject.__children, (elem) => {\n        if \
(!this.isAnyParentCollapsed(elem)) {\n          const elemIndex = \
this.dataManager.getRowIndex(elem);\n          \
rowsToUntrim.push(elemIndex);\n          this.expandChildRows(elemIndex, \
rowsToUntrim);\n        }\n      });\n    }\n    if (doTrimming) {\n      \
this.untrimRows(rowsToUntrim);\n    }\n  }\n  /**\n   * Expand the children \
of the row passed as an argument.\n   *\n   * @param {number|object} row \
Parent row.\n   * @param {boolean} [forceRender=true] Whether to render the \
table after the function ends.\n   * @param {boolean} [doTrimming=true] If \
set to `true`, the trimming will be applied when the function finishes.\n   * \
@returns {number[]}\n   */\n  expandChildren(row) {\n    let forceRender = \
arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    \
let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? \
arguments[2] : true;\n    const rowsToExpand = [];\n    let rowObject = \
null;\n    let rowIndex = null;\n    let rowsToUntrim = null;\n    if \
(isNaN(row)) {\n      rowObject = row;\n      rowIndex = \
this.dataManager.getRowIndex(row);\n    } else {\n      rowObject = \
this.dataManager.getDataObject(row);\n      rowIndex = row;\n    }\n    \
this.collapsedRows.splice(this.collapsedRows.indexOf(rowIndex), 1);\n    if \
(this.dataManager.hasChildren(rowObject)) {\n      \
arrayEach(rowObject.__children, (elem) => {\n        const childIndex = \
this.dataManager.getRowIndex(elem);\n        rowsToExpand.push(childIndex);\n \
     });\n    }\n    rowsToUntrim = this.expandRows(rowsToExpand, true, \
false);\n    if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n \
   if (forceRender) {\n      this.renderAndAdjust();\n    }\n    return \
rowsToUntrim;\n  }\n  /**\n   * Expand multiple rows' children.\n   *\n   * \
@param {Array} rows Array of rows which children are about to be expanded.\n  \
 * @param {boolean} [forceRender=true] `true` if the table should render \
after finishing the function.\n   * @param {boolean} [doTrimming=true] `true` \
if the rows should be untrimmed after finishing the function.\n   */\n  \
expandMultipleChildren(rows) {\n    let forceRender = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : true;\n    let doTrimming = \
arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    \
const rowsToUntrim = [];\n    arrayEach(rows, (elem) => {\n      \
rowsToUntrim.push(...this.expandChildren(elem, false, false));\n    });\n    \
if (doTrimming) {\n      this.untrimRows(rowsToUntrim);\n    }\n    if \
(forceRender) {\n      this.renderAndAdjust();\n    }\n  }\n  /**\n   * \
Collapse all collapsable rows.\n   */\n  collapseAll() {\n    const data2 = \
this.dataManager.getData();\n    const parentsToCollapse = [];\n    \
arrayEach(data2, (elem) => {\n      if (this.dataManager.hasChildren(elem)) \
{\n        parentsToCollapse.push(elem);\n      }\n    });\n    \
this.collapseMultipleChildren(parentsToCollapse);\n    \
this.renderAndAdjust();\n  }\n  /**\n   * Expand all collapsable rows.\n   \
*/\n  expandAll() {\n    const data2 = this.dataManager.getData();\n    const \
parentsToExpand = [];\n    arrayEach(data2, (elem) => {\n      if \
(this.dataManager.hasChildren(elem)) {\n        parentsToExpand.push(elem);\n \
     }\n    });\n    this.expandMultipleChildren(parentsToExpand);\n    \
this.renderAndAdjust();\n  }\n  /**\n   * Trim rows.\n   *\n   * @param \
{Array} rows Physical row indexes.\n   */\n  trimRows(rows) {\n    \
this.hot.batchExecution(() => {\n      arrayEach(rows, (physicalRow) => {\n   \
     this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, true);\n      \
});\n    }, true);\n  }\n  /**\n   * Untrim rows.\n   *\n   * @param {Array} \
rows Physical row indexes.\n   */\n  untrimRows(rows) {\n    \
this.hot.batchExecution(() => {\n      arrayEach(rows, (physicalRow) => {\n   \
     this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, false);\n      \
});\n    }, true);\n  }\n  /**\n   * Check if all child rows are collapsed.\n \
  *\n   * @private\n   * @param {number|object|null} row The parent row. \
`null` for the top level.\n   * @returns {boolean}\n   */\n  \
areChildrenCollapsed(row) {\n    let rowObj = isNaN(row) ? row : \
this.dataManager.getDataObject(row);\n    let allCollapsed = true;\n    if \
(rowObj === null) {\n      rowObj = {\n        __children: \
this.dataManager.data\n      };\n    }\n    if \
(this.dataManager.hasChildren(rowObj)) {\n      arrayEach(rowObj.__children, \
(elem) => {\n        const rowIndex = this.dataManager.getRowIndex(elem);\n   \
     if (!this.plugin.collapsedRowsMap.getValueAtIndex(rowIndex)) {\n         \
 allCollapsed = false;\n          return false;\n        }\n      });\n    \
}\n    return allCollapsed;\n  }\n  /**\n   * Check if any of the row object \
parents are collapsed.\n   *\n   * @private\n   * @param {object} rowObj Row \
object.\n   * @returns {boolean}\n   */\n  isAnyParentCollapsed(rowObj) {\n   \
 let parent2 = rowObj;\n    while (parent2 !== null) {\n      parent2 = \
this.dataManager.getRowParent(parent2);\n      const parentIndex = \
this.dataManager.getRowIndex(parent2);\n      if \
(this.collapsedRows.indexOf(parentIndex) > -1) {\n        return true;\n      \
}\n    }\n    return false;\n  }\n  /**\n   * Toggle collapsed state. \
Callback for the `beforeOnCellMousedown` hook.\n   *\n   * @private\n   * \
@param {MouseEvent} event `mousedown` event.\n   * @param {object} coords \
Coordinates of the clicked cell/header.\n   */\n  toggleState(event2, coords) \
{\n    if (coords.col >= 0) {\n      return;\n    }\n    const row = \
this.translateTrimmedRow(coords.row);\n    if (hasClass(event2.target, \
headers_default.CSS_CLASSES.button)) {\n      if \
(this.areChildrenCollapsed(row)) {\n        this.expandChildren(row);\n      \
} else {\n        this.collapseChildren(row);\n      }\n      \
stopImmediatePropagation(event2);\n    }\n  }\n  /**\n   * Translate visual \
row after trimming to physical base row index.\n   *\n   * @private\n   * \
@param {number} row Row index.\n   * @returns {number} Base row index.\n   \
*/\n  translateTrimmedRow(row) {\n    return this.hot.toPhysicalRow(row);\n  \
}\n  /**\n   * Translate physical row after trimming to visual base row \
index.\n   *\n   * @private\n   * @param {number} row Row index.\n   * \
@returns {number} Base row index.\n   */\n  untranslateTrimmedRow(row) {\n    \
return this.hot.toVisualRow(row);\n  }\n  /**\n   * Helper function to render \
the table and call the `adjustElementsSize` method.\n   *\n   * @private\n   \
*/\n  renderAndAdjust() {\n    this.hot.render();\n    \
this.hot.view.adjustElementsSize();\n  }\n};\nvar collapsing_default = \
CollapsingUI;\n\n// \
node_modules/handsontable/plugins/nestedRows/ui/contextMenu.mjs\nvar \
privatePool20 = /* @__PURE__ */ new WeakMap();\nvar ContextMenuUI = class \
extends base_default7 {\n  constructor(nestedRowsPlugin, hotInstance) {\n    \
super(nestedRowsPlugin, hotInstance);\n    privatePool20.set(this, {\n      \
row_above: (key, selection) => {\n        const lastSelection = \
selection[selection.length - 1];\n        \
this.dataManager.addSibling(lastSelection.start.row, \"above\");\n      },\n  \
    row_below: (key, selection) => {\n        const lastSelection = \
selection[selection.length - 1];\n        \
this.dataManager.addSibling(lastSelection.start.row, \"below\");\n      }\n   \
 });\n    this.dataManager = this.plugin.dataManager;\n  }\n  /**\n   * \
Append options to the context menu. (Propagated from the \
`afterContextMenuDefaultOptions` hook callback)\n   * f.\n   *\n   * \
@private\n   * @param {object} defaultOptions Default context menu options.\n \
  * @returns {*}\n   */\n  appendOptions(defaultOptions) {\n    const \
newEntries = [{\n      key: \"add_child\",\n      name() {\n        return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD);\n      \
},\n      callback: () => {\n        const translatedRowIndex = \
this.dataManager.translateTrimmedRow(this.hot.getSelectedLast()[0]);\n        \
const parent2 = this.dataManager.getDataObject(translatedRowIndex);\n        \
this.dataManager.addChild(parent2);\n      },\n      disabled: () => {\n      \
  const selected = this.hot.getSelectedLast();\n        return !selected || \
selected[0] < 0 || this.hot.selection.isSelectedByColumnHeader() || \
this.hot.countRows() >= this.hot.getSettings().maxRows;\n      }\n    }, {\n  \
    key: \"detach_from_parent\",\n      name() {\n        return \
this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD);\n      \
},\n      callback: () => {\n        \
this.dataManager.detachFromParent(this.hot.getSelectedLast());\n      },\n    \
  disabled: () => {\n        const selected = this.hot.getSelectedLast();\n   \
     const translatedRowIndex = \
this.dataManager.translateTrimmedRow(selected[0]);\n        const parent2 = \
this.dataManager.getRowParent(translatedRowIndex);\n        return !parent2 \
|| !selected || selected[0] < 0 || \
this.hot.selection.isSelectedByColumnHeader() || this.hot.countRows() >= \
this.hot.getSettings().maxRows;\n      }\n    }, {\n      name: \
\"---------\"\n    }];\n    rangeEach(0, defaultOptions.items.length - 1, (i) \
=> {\n      if (i === 0) {\n        arrayEach(newEntries, (val, j) => {\n     \
     defaultOptions.items.splice(i + j, 0, val);\n        });\n        return \
false;\n      }\n    });\n    return \
this.modifyRowInsertingOptions(defaultOptions);\n  }\n  /**\n   * Modify how \
the row inserting options work.\n   *\n   * @private\n   * @param {object} \
defaultOptions Default context menu items.\n   * @returns {*}\n   */\n  \
modifyRowInsertingOptions(defaultOptions) {\n    const priv = \
privatePool20.get(this);\n    rangeEach(0, defaultOptions.items.length - 1, \
(i) => {\n      const option = priv[defaultOptions.items[i].key];\n      if \
(option !== null && option !== void 0) {\n        \
defaultOptions.items[i].callback = option;\n      }\n    });\n    return \
defaultOptions;\n  }\n};\nvar contextMenu_default = ContextMenuUI;\n\n// \
node_modules/handsontable/plugins/nestedRows/utils/rowMoveController.mjs\nvar \
RowMoveController = class {\n  constructor(plugin) {\n    this.plugin = \
plugin;\n    this.hot = plugin.hot;\n    this.dataManager = \
plugin.dataManager;\n    this.collapsingUI = plugin.collapsingUI;\n  }\n  \
/**\n   * `beforeRowMove` hook callback.\n   *\n   * @param {Array} rows \
Array of visual row indexes to be moved.\n   * @param {number} finalIndex \
Visual row index, being a start index for the moved rows. Points to where the \
elements\n   *   will be placed after the moving action. To check the \
visualization of the final index, please take a look at\n   *   \
[documentation](@/guides/rows/row-moving.md).\n   * @param {undefined|number} \
dropIndex Visual row index, being a drop index for the moved rows. Points to \
where we\n   *   are going to drop the moved elements. To check visualization \
of drop index please take a look at\n   *   \
[documentation](@/guides/rows/row-moving.md).\n   * @param {boolean} \
movePossible Indicates if it's possible to move rows to the desired \
position.\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  \
onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n    const \
improperUsage = this.displayAPICompatibilityWarning({\n      rows,\n      \
finalIndex,\n      dropIndex,\n      movePossible\n    });\n    if \
(improperUsage) {\n      return false;\n    }\n    this.movedToCollapsed = \
false;\n    const dropToLastRow = dropIndex === this.hot.countRows();\n    \
const physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : \
this.dataManager.translateTrimmedRow(dropIndex);\n    let allowMove = true;\n \
   const physicalStartIndexes = rows.map((rowIndex) => {\n      if \
(!allowMove) {\n        return false;\n      }\n      const physicalRowIndex \
= this.dataManager.translateTrimmedRow(rowIndex);\n      allowMove = \
this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\n      return \
physicalRowIndex;\n    });\n    const willDataChange = \
physicalStartIndexes.indexOf(physicalDropIndex) === -1;\n    if (!allowMove \
|| !willDataChange) {\n      return false;\n    }\n    const baseParent = \
this.getBaseParent(physicalStartIndexes);\n    const targetParent = \
this.getTargetParent(dropToLastRow, physicalDropIndex);\n    const sameParent \
= baseParent === targetParent;\n    this.movedToCollapsed = \
this.collapsingUI.areChildrenCollapsed(targetParent);\n    \
this.collapsingUI.collapsedRowsStash.stash();\n    \
this.shiftCollapsibleParentsLocations(physicalStartIndexes, \
physicalDropIndex, sameParent);\n    this.moveRows(physicalStartIndexes, \
physicalDropIndex, targetParent);\n    this.dataManager.rewriteCache();\n    \
this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\n    \
this.collapsingUI.collapsedRowsStash.applyStash(false);\n    \
this.hot.runHooks(\"afterRowMove\", rows, finalIndex, dropIndex, \
movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));\n    \
this.hot.render();\n    this.selectCells(rows, dropIndex);\n    return \
false;\n  }\n  /**\n   * Display a `dragRows`/`moveRows` method compatibility \
warning if needed.\n   *\n   * @param {object} beforeMoveRowHookArgs A set of \
arguments from the `beforeMoveRow` hook.\n   * @returns {boolean} `true` if \
is a result of an improper usage of the moving API.\n   */\n  \
displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\n    const {\n      \
rows,\n      finalIndex,\n      dropIndex,\n      movePossible\n    } = \
beforeMoveRowHookArgs;\n    let shouldTerminate = false;\n    if \
(isUndefined(dropIndex)) {\n      warn(toSingleLine`Since version 8.0.0 of \
the Handsontable the 'moveRows' method isn't used for moving rows\\x20\n      \
when the NestedRows plugin is enabled. Please use the 'dragRows' method \
instead.`);\n      this.hot.runHooks(\"afterRowMove\", rows, finalIndex, \
dropIndex, movePossible, false);\n      shouldTerminate = true;\n    }\n    \
return shouldTerminate;\n  }\n  /**\n   * Check if the moving action should \
be allowed.\n   *\n   * @param {number} physicalRowIndex Physical start row \
index.\n   * @param {number} physicalDropIndex Physical drop index.\n   * \
@returns {boolean} `true` if it should continue with the moving action.\n   \
*/\n  shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\n    return \
!(this.dataManager.isParent(physicalRowIndex) || \
this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === \
physicalDropIndex || physicalDropIndex === 0);\n  }\n  /**\n   * Get the base \
row parent.\n   *\n   * @param {number} physicalStartIndexes Physical start \
row index.\n   * @returns {object|null} The base row parent.\n   */\n  \
getBaseParent(physicalStartIndexes) {\n    return \
this.dataManager.getRowParent(physicalStartIndexes[0]);\n  }\n  /**\n   * Get \
the target row parent.\n   *\n   * @param {boolean} dropToLastRow `true` if \
the row is moved to the last row of the table.\n   * @param {number} \
physicalDropIndex Physical drop row index.\n   * @returns {object|null} The \
target row parent.\n   */\n  getTargetParent(dropToLastRow, \
physicalDropIndex) {\n    let targetParent = \
this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : \
physicalDropIndex);\n    if (targetParent === null || targetParent === void \
0) {\n      targetParent = this.dataManager.getRowParent(physicalDropIndex - \
1);\n    }\n    return targetParent;\n  }\n  /**\n   * Shift the cached \
collapsible rows position according to the move action.\n   *\n   * @param \
{number[]} physicalStartIndexes Physical start row indexes.\n   * @param \
{number} physicalDropIndex Physical drop index.\n   * @param {boolean} \
sameParent `true` if the row's being moved between siblings of the same \
parent.\n   */\n  shiftCollapsibleParentsLocations(physicalStartIndexes, \
physicalDropIndex, sameParent) {\n    if (!sameParent) {\n      if \
(Math.max(...physicalStartIndexes) <= physicalDropIndex) {\n        \
this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], \
physicalDropIndex, -1 * physicalStartIndexes.length);\n      } else {\n       \
 this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, \
physicalStartIndexes[0], physicalStartIndexes.length);\n      }\n    }\n  }\n \
 /**\n   * Move the rows at the provided coordinates.\n   *\n   * @param \
{number[]} physicalStartIndexes Physical indexes of the rows about to be \
moved.\n   * @param {number} physicalDropIndex Physical drop index.\n   * \
@param {object} targetParent Parent of the destination row.\n   */\n  \
moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\n    const \
moveToLastChild = physicalDropIndex === \
this.dataManager.getRowIndex(targetParent) + \
this.dataManager.countChildren(targetParent) + 1;\n    \
this.hot.batchRender(() => {\n      \
physicalStartIndexes.forEach((physicalStartIndex) => {\n        \
this.dataManager.moveRow(physicalStartIndex, physicalDropIndex, \
this.movedToCollapsed, moveToLastChild);\n      });\n    });\n  }\n  /**\n   \
* Move the cell meta for multiple rows.\n   *\n   * @param {number[]} \
baseIndexes Array of indexes for the rows being moved.\n   * @param {number} \
targetIndex Index of the destination of the move.\n   */\n  \
moveCellsMeta(baseIndexes, targetIndex) {\n    const rowsOfMeta = [];\n    \
const movingDown = Math.max(...baseIndexes) < targetIndex;\n    \
baseIndexes.forEach((baseIndex) => {\n      \
rowsOfMeta.push(this.hot.getCellMetaAtRow(baseIndex));\n    });\n    \
this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\n    \
this.hot.spliceCellsMeta(targetIndex - (movingDown ? rowsOfMeta.length : 0), \
0, ...rowsOfMeta);\n  }\n  /**\n   * Select cells after the move.\n   *\n   * \
@param {Array} rows Array of visual row indexes to be moved.\n   * @param \
{undefined|number} dropIndex Visual row index, being a drop index for the \
moved rows. Points to where we\n   *   are going to drop the moved elements. \
To check visualization of drop index please take a look at\n   *   \
[documentation](@/guides/rows/row-moving.md).\n   */\n  selectCells(rows, \
dropIndex) {\n    const rowsLen = rows.length;\n    let startRow = 0;\n    \
let endRow = 0;\n    let selection = null;\n    let lastColIndex = null;\n    \
if (this.movedToCollapsed) {\n      let physicalDropIndex = null;\n      if \
(rows[rowsLen - 1] < dropIndex) {\n        physicalDropIndex = \
this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\n      } else {\n  \
      physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\n  \
    }\n      const parentObject = \
this.dataManager.getRowParent(physicalDropIndex === null ? \
this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\n      const \
parentIndex = this.dataManager.getRowIndex(parentObject);\n      startRow = \
this.dataManager.untranslateTrimmedRow(parentIndex);\n      endRow = \
startRow;\n    } else if (rows[rowsLen - 1] < dropIndex) {\n      endRow = \
dropIndex - 1;\n      startRow = endRow - rowsLen + 1;\n    } else {\n      \
startRow = dropIndex;\n      endRow = startRow + rowsLen - 1;\n    }\n    \
selection = this.hot.selection;\n    lastColIndex = this.hot.countCols() - \
1;\n    selection.setRangeStart(this.hot._createCellCoords(startRow, 0));\n   \
 selection.setRangeEnd(this.hot._createCellCoords(endRow, lastColIndex), \
true);\n  }\n  // TODO: Reimplementation of function which is inside the \
`ManualRowMove` plugin.\n  /**\n   * Indicates if order of rows was \
changed.\n   *\n   * @param {Array} movedRows Array of visual row indexes to \
be moved.\n   * @param {number} finalIndex Visual row index, being a start \
index for the moved rows. Points to where the elements\n   *   will be placed \
after the moving action. To check the visualization of the final index, \
please take a look at\n   *   [documentation](@/guides/rows/row-moving.md).\n \
  * @returns {boolean}\n   */\n  isRowOrderChanged(movedRows, finalIndex) {\n \
   return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement \
!== finalIndex);\n  }\n};\n\n// \
node_modules/handsontable/plugins/nestedRows/nestedRows.mjs\nvar PLUGIN_KEY29 \
= \"nestedRows\";\nvar PLUGIN_PRIORITY28 = 300;\nvar privatePool21 = /* \
@__PURE__ */ new WeakMap();\nvar WRONG_DATA_TYPE_ERROR = \"The Nested Rows \
plugin requires an Array of Objects as a dataset to be provided. The plugin \
has been disabled.\";\nvar NestedRows = class extends BasePlugin {\n  static \
get PLUGIN_KEY() {\n    return PLUGIN_KEY29;\n  }\n  static get \
PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY28;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.dataManager = \
null;\n    this.headersUI = null;\n    this.collapsedRowsMap = null;\n    \
privatePool21.set(this, {\n      movedToCollapsed: false,\n      skipRender: \
null,\n      skipCoreAPIModifiers: false\n    });\n  }\n  /**\n   * Checks if \
the plugin is enabled in the handsontable settings. This method is executed \
in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the \
{@link NestedRows#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY29];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    \
this.collapsedRowsMap = this.hot.rowIndexMapper.registerMap(\"nestedRows\", \
new TrimmingMap());\n    this.dataManager = new dataManager_default(this, \
this.hot);\n    this.collapsingUI = new collapsing_default(this, this.hot);\n \
   this.headersUI = new headers_default(this, this.hot);\n    \
this.contextMenuUI = new contextMenu_default(this, this.hot);\n    \
this.rowMoveController = new RowMoveController(this);\n    \
this.addHook(\"afterInit\", function() {\n      return \
_this.onAfterInit(...arguments);\n    });\n    \
this.addHook(\"beforeViewRender\", function() {\n      return \
_this.onBeforeViewRender(...arguments);\n    });\n    \
this.addHook(\"modifyRowData\", function() {\n      return \
_this.onModifyRowData(...arguments);\n    });\n    \
this.addHook(\"modifySourceLength\", function() {\n      return \
_this.onModifySourceLength(...arguments);\n    });\n    \
this.addHook(\"beforeDataSplice\", function() {\n      return \
_this.onBeforeDataSplice(...arguments);\n    });\n    \
this.addHook(\"filterData\", function() {\n      return \
_this.onFilterData(...arguments);\n    });\n    \
this.addHook(\"afterContextMenuDefaultOptions\", function() {\n      return \
_this.onAfterContextMenuDefaultOptions(...arguments);\n    });\n    \
this.addHook(\"afterGetRowHeader\", function() {\n      return \
_this.onAfterGetRowHeader(...arguments);\n    });\n    \
this.addHook(\"beforeOnCellMouseDown\", function() {\n      return \
_this.onBeforeOnCellMouseDown(...arguments);\n    });\n    \
this.addHook(\"beforeRemoveRow\", function() {\n      return \
_this.onBeforeRemoveRow(...arguments);\n    });\n    \
this.addHook(\"afterRemoveRow\", function() {\n      return \
_this.onAfterRemoveRow(...arguments);\n    });\n    \
this.addHook(\"beforeAddChild\", function() {\n      return \
_this.onBeforeAddChild(...arguments);\n    });\n    \
this.addHook(\"afterAddChild\", function() {\n      return \
_this.onAfterAddChild(...arguments);\n    });\n    \
this.addHook(\"beforeDetachChild\", function() {\n      return \
_this.onBeforeDetachChild(...arguments);\n    });\n    \
this.addHook(\"afterDetachChild\", function() {\n      return \
_this.onAfterDetachChild(...arguments);\n    });\n    \
this.addHook(\"modifyRowHeaderWidth\", function() {\n      return \
_this.onModifyRowHeaderWidth(...arguments);\n    });\n    \
this.addHook(\"afterCreateRow\", function() {\n      return \
_this.onAfterCreateRow(...arguments);\n    });\n    \
this.addHook(\"beforeRowMove\", function() {\n      return \
_this.onBeforeRowMove(...arguments);\n    });\n    \
this.addHook(\"beforeLoadData\", (data2) => this.onBeforeLoadData(data2));\n  \
  this.addHook(\"beforeUpdateData\", (data2) => \
this.onBeforeLoadData(data2));\n    super.enablePlugin();\n  }\n  /**\n   * \
Disables the plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    \
this.hot.rowIndexMapper.unregisterMap(\"nestedRows\");\n    \
super.disablePlugin();\n  }\n  /**\n   * Updates the plugin's state.\n   *\n  \
 * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`nestedRows`](@/api/options.md#nestedrows)\n   */\n  updatePlugin() {\n    \
this.disablePlugin();\n    const currentSourceData = \
this.dataManager.getData();\n    this.enablePlugin();\n    \
this.dataManager.updateWithData(currentSourceData);\n    \
super.updatePlugin();\n  }\n  /**\n   * `beforeRowMove` hook callback.\n   \
*\n   * @private\n   * @param {Array} rows Array of visual row indexes to be \
moved.\n   * @param {number} finalIndex Visual row index, being a start index \
for the moved rows. Points to where the elements\n   *   will be placed after \
the moving action. To check the visualization of the final index, please take \
a look at\n   *   [documentation](@/guides/rows/row-summary.md).\n   * @param \
{undefined|number} dropIndex Visual row index, being a drop index for the \
moved rows. Points to where we\n   *   are going to drop the moved elements. \
To check visualization of drop index please take a look at\n   *   \
[documentation](@/guides/rows/row-summary.md).\n   * @param {boolean} \
movePossible Indicates if it's possible to move rows to the desired \
position.\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  \
onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n    return \
this.rowMoveController.onBeforeRowMove(rows, finalIndex, dropIndex, \
movePossible);\n  }\n  /**\n   * Enable the modify hook skipping flag - \
allows retrieving the data from Handsontable without this plugin's\n   * \
modifications.\n   */\n  disableCoreAPIModifiers() {\n    const priv = \
privatePool21.get(this);\n    priv.skipCoreAPIModifiers = true;\n  }\n  /**\n \
  * Disable the modify hook skipping flag.\n   */\n  enableCoreAPIModifiers() \
{\n    const priv = privatePool21.get(this);\n    priv.skipCoreAPIModifiers = \
false;\n  }\n  /**\n   * `beforeOnCellMousedown` hook callback.\n   *\n   * \
@private\n   * @param {MouseEvent} event Mousedown event.\n   * @param \
{object} coords Cell coords.\n   * @param {HTMLElement} TD Clicked cell.\n   \
*/\n  onBeforeOnCellMouseDown(event2, coords, TD) {\n    \
this.collapsingUI.toggleState(event2, coords, TD);\n  }\n  /**\n   * The \
modifyRowData hook callback.\n   *\n   * @private\n   * @param {number} row \
Visual row index.\n   * @returns {boolean}\n   */\n  onModifyRowData(row) {\n \
   const priv = privatePool21.get(this);\n    if (priv.skipCoreAPIModifiers) \
{\n      return;\n    }\n    return this.dataManager.getDataObject(row);\n  \
}\n  /**\n   * Modify the source data length to match the length of the \
nested structure.\n   *\n   * @private\n   * @returns {number}\n   */\n  \
onModifySourceLength() {\n    const priv = privatePool21.get(this);\n    if \
(priv.skipCoreAPIModifiers) {\n      return;\n    }\n    return \
this.dataManager.countAllRows();\n  }\n  /**\n   * @private\n   * @param \
{number} index The index where the data was spliced.\n   * @param {number} \
amount An amount of items to remove.\n   * @param {object} element An element \
to add.\n   * @returns {boolean}\n   */\n  onBeforeDataSplice(index2, amount, \
element) {\n    const priv = privatePool21.get(this);\n    if \
(priv.skipCoreAPIModifiers || this.dataManager.isRowHighestLevel(index2)) {\n \
     return true;\n    }\n    this.dataManager.spliceData(index2, amount, \
element);\n    return false;\n  }\n  /**\n   * Provide custom source data \
filtering. It's handled by core method and replaces the native filtering.\n   \
*\n   * @private\n   * @param {number} index The index where the data \
filtering starts.\n   * @param {number} amount An amount of rows which \
filtering applies to.\n   * @param {number} physicalRows Physical row \
indexes.\n   * @returns {Array}\n   */\n  onFilterData(index2, amount, \
physicalRows) {\n    const priv = privatePool21.get(this);\n    \
this.collapsingUI.collapsedRowsStash.stash();\n    \
this.collapsingUI.collapsedRowsStash.trimStash(physicalRows[0], amount);\n    \
this.collapsingUI.collapsedRowsStash.shiftStash(physicalRows[0], null, -1 * \
amount);\n    this.dataManager.filterData(index2, amount, physicalRows);\n    \
priv.skipRender = true;\n    return this.dataManager.getData().slice();\n  \
}\n  /**\n   * `afterContextMenuDefaultOptions` hook callback.\n   *\n   * \
@private\n   * @param {object} defaultOptions The default context menu items \
order.\n   * @returns {boolean}\n   */\n  \
onAfterContextMenuDefaultOptions(defaultOptions) {\n    return \
this.contextMenuUI.appendOptions(defaultOptions);\n  }\n  /**\n   * \
`afterGetRowHeader` hook callback.\n   *\n   * @private\n   * @param {number} \
row Row index.\n   * @param {HTMLElement} TH Row header element.\n   */\n  \
onAfterGetRowHeader(row, TH) {\n    this.headersUI.appendLevelIndicators(row, \
TH);\n  }\n  /**\n   * `modifyRowHeaderWidth` hook callback.\n   *\n   * \
@private\n   * @param {number} rowHeaderWidth The initial row header \
width(s).\n   * @returns {number}\n   */\n  \
onModifyRowHeaderWidth(rowHeaderWidth) {\n    return \
this.headersUI.rowHeaderWidthCache || rowHeaderWidth;\n  }\n  /**\n   * \
`onAfterRemoveRow` hook callback.\n   *\n   * @private\n   * @param {number} \
index Removed row.\n   * @param {number} amount Amount of removed rows.\n   * \
@param {Array} logicRows An array of the removed physical rows.\n   * @param \
{string} source Source of action.\n   */\n  onAfterRemoveRow(index2, amount, \
logicRows, source) {\n    if (source === this.pluginName) {\n      return;\n  \
  }\n    const priv = privatePool21.get(this);\n    setTimeout(() => {\n      \
priv.skipRender = null;\n      this.headersUI.updateRowHeaderWidth();\n      \
this.collapsingUI.collapsedRowsStash.applyStash();\n    }, 0);\n  }\n  /**\n  \
 * Callback for the `beforeRemoveRow` change list of removed physical indexes \
by reference. Removing parent node\n   * has effect in removing children \
nodes.\n   *\n   * @private\n   * @param {number} index Visual index of \
starter row.\n   * @param {number} amount Amount of rows to be removed.\n   * \
@param {Array} physicalRows List of physical indexes.\n   */\n  \
onBeforeRemoveRow(index2, amount, physicalRows) {\n    const \
modifiedPhysicalRows = Array.from(physicalRows.reduce((removedRows, \
physicalIndex) => {\n      if (this.dataManager.isParent(physicalIndex)) {\n  \
      const children = \
this.dataManager.getDataObject(physicalIndex).__children;\n        \
removedRows.add(physicalIndex);\n        if (Array.isArray(children)) {\n     \
     children.forEach((child) => \
removedRows.add(this.dataManager.getRowIndex(child)));\n        }\n        \
return removedRows;\n      }\n      return removedRows.add(physicalIndex);\n  \
  }, /* @__PURE__ */ new Set()));\n    physicalRows.length = 0;\n    \
physicalRows.push(...modifiedPhysicalRows);\n  }\n  /**\n   * \
`beforeAddChild` hook callback.\n   *\n   * @private\n   */\n  \
onBeforeAddChild() {\n    this.collapsingUI.collapsedRowsStash.stash();\n  \
}\n  /**\n   * `afterAddChild` hook callback.\n   *\n   * @private\n   * \
@param {object} parent Parent element.\n   * @param {object} element New \
child element.\n   */\n  onAfterAddChild(parent2, element) {\n    \
this.collapsingUI.collapsedRowsStash.shiftStash(this.dataManager.getRowIndex(\
element));\n    this.collapsingUI.collapsedRowsStash.applyStash();\n    \
this.headersUI.updateRowHeaderWidth();\n  }\n  /**\n   * `beforeDetachChild` \
hook callback.\n   *\n   * @private\n   */\n  onBeforeDetachChild() {\n    \
this.collapsingUI.collapsedRowsStash.stash();\n  }\n  /**\n   * \
`afterDetachChild` hook callback.\n   *\n   * @private\n   * @param {object} \
parent Parent element.\n   * @param {object} element New child element.\n   * \
@param {number} finalElementRowIndex The final row index of the detached \
element.\n   */\n  onAfterDetachChild(parent2, element, finalElementRowIndex) \
{\n    this.collapsingUI.collapsedRowsStash.shiftStash(finalElementRowIndex, \
null, -1);\n    this.collapsingUI.collapsedRowsStash.applyStash();\n    \
this.headersUI.updateRowHeaderWidth();\n  }\n  /**\n   * `afterCreateRow` \
hook callback.\n   *\n   * @private\n   */\n  onAfterCreateRow() {\n    \
this.dataManager.rewriteCache();\n  }\n  /**\n   * `afterInit` hook \
callback.\n   *\n   * @private\n   */\n  onAfterInit() {\n    const \
deepestLevel = Math.max(...this.dataManager.cache.levels);\n    if \
(deepestLevel > 0) {\n      \
this.headersUI.updateRowHeaderWidth(deepestLevel);\n    }\n  }\n  /**\n   * \
`beforeViewRender` hook callback.\n   *\n   * @param {boolean} force \
Indicates if the render call was trigered by a change of settings or data.\n  \
 * @param {object} skipRender An object, holder for skipRender \
functionality.\n   * @private\n   */\n  onBeforeViewRender(force, skipRender) \
{\n    const priv = privatePool21.get(this);\n    if (priv.skipRender) {\n    \
  skipRender.skipRender = true;\n    }\n  }\n  /**\n   * Destroys the plugin \
instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n  /**\n   * \
`beforeLoadData` hook callback.\n   *\n   * @param {Array} data The source \
data.\n   * @private\n   */\n  onBeforeLoadData(data2) {\n    if \
(!isArrayOfObjects(data2)) {\n      error(WRONG_DATA_TYPE_ERROR);\n      \
this.hot.getSettings()[PLUGIN_KEY29] = false;\n      this.disablePlugin();\n  \
    return;\n    }\n    this.dataManager.setData(data2);\n    \
this.dataManager.rewriteCache();\n  }\n};\n\n// \
node_modules/handsontable/plugins/persistentState/storage.mjs\nvar Storage = \
class {\n  // eslint-disable-next-line no-restricted-globals\n  \
constructor(prefix) {\n    let rootWindow = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : window;\n    this.rootWindow = \
rootWindow;\n    this.prefix = prefix;\n    this.savedKeys = [];\n    \
this.loadSavedKeys();\n  }\n  /**\n   * Save data to localStorage.\n   *\n   \
* @param {string} key Key string.\n   * @param {Mixed} value Value to save.\n \
  */\n  saveValue(key, value) {\n    \
this.rootWindow.localStorage.setItem(`${this.prefix}_${key}`, \
JSON.stringify(value));\n    if (this.savedKeys.indexOf(key) === -1) {\n      \
this.savedKeys.push(key);\n      this.saveSavedKeys();\n    }\n  }\n  /**\n   \
* Load data from localStorage.\n   *\n   * @param {string} key Key string.\n  \
 * @param {object} defaultValue Object containing the loaded data.\n   *\n   \
* @returns {object|undefined}\n   */\n  loadValue(key, defaultValue) {\n    \
const itemKey = typeof key === \"undefined\" ? defaultValue : key;\n    const \
value = this.rootWindow.localStorage.getItem(`${this.prefix}_${itemKey}`);\n  \
  return value === null ? void 0 : JSON.parse(value);\n  }\n  /**\n   * Reset \
given data from localStorage.\n   *\n   * @param {string} key Key string.\n   \
*/\n  reset(key) {\n    \
this.rootWindow.localStorage.removeItem(`${this.prefix}_${key}`);\n  }\n  \
/**\n   * Reset all data from localStorage.\n   *\n   */\n  resetAll() {\n    \
arrayEach(this.savedKeys, (value, index2) => {\n      \
this.rootWindow.localStorage.removeItem(`${this.prefix}_${this.savedKeys[inde\
x2]}`);\n    });\n    this.clearSavedKeys();\n  }\n  /**\n   * Load and save \
all keys from localStorage.\n   *\n   * @private\n   */\n  loadSavedKeys() \
{\n    const keysJSON = \
this.rootWindow.localStorage.getItem(`${this.prefix}__persistentStateKeys`);\
\n    const keys = typeof keysJSON === \"string\" ? JSON.parse(keysJSON) : \
void 0;\n    this.savedKeys = keys || [];\n  }\n  /**\n   * Save saved key in \
localStorage.\n   *\n   * @private\n   */\n  saveSavedKeys() {\n    \
this.rootWindow.localStorage.setItem(`${this.prefix}__persistentStateKeys`, \
JSON.stringify(this.savedKeys));\n  }\n  /**\n   * Clear saved key from \
localStorage.\n   *\n   * @private\n   */\n  clearSavedKeys() {\n    \
this.savedKeys.length = 0;\n    this.saveSavedKeys();\n  }\n};\nvar \
storage_default = Storage;\n\n// \
node_modules/handsontable/plugins/persistentState/persistentState.mjs\nplugin\
Hooks_default.getSingleton().register(\"persistentStateSave\");\npluginHooks_\
default.getSingleton().register(\"persistentStateLoad\");\npluginHooks_defaul\
t.getSingleton().register(\"persistentStateReset\");\nvar PLUGIN_KEY30 = \
\"persistentState\";\nvar PLUGIN_PRIORITY29 = 0;\nvar PersistentState = class \
extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY30;\n \
 }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY29;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.storage = void \
0;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable \
settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and \
if it returns `true` then the {@link PersistentState#enablePlugin} method is \
called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY30];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
if (this.enabled) {\n      return;\n    }\n    if (!this.storage) {\n      \
this.storage = new storage_default(this.hot.rootElement.id, \
this.hot.rootWindow);\n    }\n    this.addHook(\"persistentStateSave\", (key, \
value) => this.saveValue(key, value));\n    \
this.addHook(\"persistentStateLoad\", (key, saveTo) => this.loadValue(key, \
saveTo));\n    this.addHook(\"persistentStateReset\", () => \
this.resetValue());\n    super.enablePlugin();\n  }\n  /**\n   * Disables the \
plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    this.storage = void 0;\n    super.disablePlugin();\n  \
}\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is \
executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked \
with any of the following configuration options:\n   *  - \
[`persistentState`](@/api/options.md#persistentstate)\n   */\n  \
updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    \
super.updatePlugin();\n  }\n  /**\n   * Loads the value from local storage.\n \
  *\n   * @param {string} key Storage key.\n   * @param {object} saveTo Saved \
value from local storage.\n   */\n  loadValue(key, saveTo) {\n    \
saveTo.value = this.storage.loadValue(key);\n  }\n  /**\n   * Saves the data \
to local storage.\n   *\n   * @param {string} key Storage key.\n   * @param \
{Mixed} value Value to save.\n   */\n  saveValue(key, value) {\n    \
this.storage.saveValue(key, value);\n  }\n  /**\n   * Resets the data or all \
data from local storage.\n   *\n   * @param {string} key [optional] Storage \
key.\n   */\n  resetValue(key) {\n    if (typeof key === \"undefined\") {\n   \
   this.storage.resetAll();\n    } else {\n      this.storage.reset(key);\n   \
 }\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    \
super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/search/search.mjs\nvar PLUGIN_KEY31 = \
\"search\";\nvar PLUGIN_PRIORITY30 = 190;\nvar DEFAULT_SEARCH_RESULT_CLASS = \
\"htSearchResult\";\nvar DEFAULT_CALLBACK = function(instance, row, col, \
data2, testResult) {\n  instance.getCellMeta(row, col).isSearchResult = \
testResult;\n};\nvar DEFAULT_QUERY_METHOD = function(query, value, \
cellProperties) {\n  if (isUndefined(query) || query === null || \
!query.toLocaleLowerCase || query.length === 0) {\n    return false;\n  }\n  \
if (isUndefined(value) || value === null) {\n    return false;\n  }\n  return \
value.toString().toLocaleLowerCase(cellProperties.locale).indexOf(query.toLoc\
aleLowerCase(cellProperties.locale)) !== -1;\n};\nvar Search = class extends \
BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY31;\n  }\n  \
static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY30;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.callback = \
DEFAULT_CALLBACK;\n    this.queryMethod = DEFAULT_QUERY_METHOD;\n    \
this.searchResultClass = DEFAULT_SEARCH_RESULT_CLASS;\n  }\n  /**\n   * \
Checks if the plugin is enabled in the handsontable settings. This method is \
executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then \
the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * @returns \
{boolean}\n   */\n  isEnabled() {\n    return \
this.hot.getSettings()[PLUGIN_KEY31];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const \
searchSettings = this.hot.getSettings()[PLUGIN_KEY31];\n    \
this.updatePluginSettings(searchSettings);\n    \
this.addHook(\"beforeRenderer\", function() {\n      return \
_this.onBeforeRenderer(...arguments);\n    });\n    super.enablePlugin();\n  \
}\n  /**\n   * Disables the plugin functionality for this Handsontable \
instance.\n   */\n  disablePlugin() {\n    var _this2 = this;\n    const \
beforeRendererCallback = function() {\n      return \
_this2.onBeforeRenderer(...arguments);\n    };\n    \
this.hot.addHook(\"beforeRenderer\", beforeRendererCallback);\n    \
this.hot.addHookOnce(\"afterViewRender\", () => {\n      \
this.hot.removeHook(\"beforeRenderer\", beforeRendererCallback);\n    });\n   \
 super.disablePlugin();\n  }\n  /**\n   * Updates the plugin's state.\n   *\n \
  * This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`search`](@/api/options.md#search)\n   */\n  updatePlugin() {\n    \
this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  \
}\n  /**\n   * Makes the query.\n   *\n   * @param {string} queryStr Value to \
be search.\n   * @param {Function} [callback] Callback function performed on \
cells with values which matches to the searched query.\n   * @param \
{Function} [queryMethod] Query function responsible for determining whether a \
query matches the value stored in a cell.\n   * @returns {object[]} Return an \
array of objects with `row`, `col`, `data` properties or empty array.\n   \
*/\n  query(queryStr) {\n    let callback = arguments.length > 1 && \
arguments[1] !== void 0 ? arguments[1] : this.getCallback();\n    let \
queryMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] \
: this.getQueryMethod();\n    const rowCount = this.hot.countRows();\n    \
const colCount = this.hot.countCols();\n    const queryResult = [];\n    \
const instance = this.hot;\n    rangeEach(0, rowCount - 1, (rowIndex) => {\n  \
    rangeEach(0, colCount - 1, (colIndex) => {\n        const cellData = \
this.hot.getDataAtCell(rowIndex, colIndex);\n        const cellProperties = \
this.hot.getCellMeta(rowIndex, colIndex);\n        const cellCallback = \
cellProperties.search.callback || callback;\n        const cellQueryMethod = \
cellProperties.search.queryMethod || queryMethod;\n        const testResult = \
cellQueryMethod(queryStr, cellData, cellProperties);\n        if (testResult) \
{\n          const singleResult = {\n            row: rowIndex,\n            \
col: colIndex,\n            data: cellData\n          };\n          \
queryResult.push(singleResult);\n        }\n        if (cellCallback) {\n     \
     cellCallback(instance, rowIndex, colIndex, cellData, testResult);\n      \
  }\n      });\n    });\n    return queryResult;\n  }\n  /**\n   * Gets the \
callback function.\n   *\n   * @returns {Function} Return the callback \
function.\n   */\n  getCallback() {\n    return this.callback;\n  }\n  /**\n  \
 * Sets the callback function. This function will be called during querying \
for each cell.\n   *\n   * @param {Function} newCallback A callback \
function.\n   */\n  setCallback(newCallback) {\n    this.callback = \
newCallback;\n  }\n  /**\n   * Gets the query method function.\n   *\n   * \
@returns {Function} Return the query method.\n   */\n  getQueryMethod() {\n   \
 return this.queryMethod;\n  }\n  /**\n   * Sets the query method function. \
The function is responsible for determining whether a query matches the value \
stored in a cell.\n   *\n   * @param {Function} newQueryMethod A function \
with specific match logic.\n   */\n  setQueryMethod(newQueryMethod) {\n    \
this.queryMethod = newQueryMethod;\n  }\n  /**\n   * Gets search result cells \
class name.\n   *\n   * @returns {string} Return the cell class name.\n   \
*/\n  getSearchResultClass() {\n    return this.searchResultClass;\n  }\n  \
/**\n   * Sets search result cells class name. This class name will be added \
to each cell that belongs to the searched query.\n   *\n   * @param {string} \
newElementClass CSS class name.\n   */\n  \
setSearchResultClass(newElementClass) {\n    this.searchResultClass = \
newElementClass;\n  }\n  /**\n   * Updates the settings of the plugin.\n   \
*\n   * @param {object} searchSettings The plugin settings, taken from \
Handsontable configuration.\n   * @private\n   */\n  \
updatePluginSettings(searchSettings) {\n    if (isObject(searchSettings)) {\n \
     if (searchSettings.searchResultClass) {\n        \
this.setSearchResultClass(searchSettings.searchResultClass);\n      }\n      \
if (searchSettings.queryMethod) {\n        \
this.setQueryMethod(searchSettings.queryMethod);\n      }\n      if \
(searchSettings.callback) {\n        \
this.setCallback(searchSettings.callback);\n      }\n    }\n  }\n  /**\n   * \
The `beforeRenderer` hook callback.\n   *\n   * @private\n   * @param \
{HTMLTableCellElement} TD The rendered `TD` element.\n   * @param {number} \
row Visual row index.\n   * @param {number} col Visual column index.\n   * \
@param {string|number} prop Column property name or a column index, if \
datasource is an array of arrays.\n   * @param {string} value Value of the \
rendered cell.\n   * @param {object} cellProperties Object containing the \
cell's properties.\n   */\n  onBeforeRenderer(TD, row, col, prop, value, \
cellProperties) {\n    const className = cellProperties.className || [];\n    \
let classArray = [];\n    if (typeof className === \"string\") {\n      \
classArray = className.split(\" \");\n    } else {\n      \
classArray.push(...className);\n    }\n    if (this.isEnabled() && \
cellProperties.isSearchResult) {\n      if \
(!classArray.includes(this.searchResultClass)) {\n        \
classArray.push(`${this.searchResultClass}`);\n      }\n    } else if \
(classArray.includes(this.searchResultClass)) {\n      \
classArray.splice(classArray.indexOf(this.searchResultClass), 1);\n    }\n    \
cellProperties.className = classArray.join(\" \");\n  }\n  /**\n   * Destroys \
the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  \
}\n};\n\n// \
node_modules/handsontable/plugins/touchScroll/touchScroll.mjs\nvar \
PLUGIN_KEY32 = \"touchScroll\";\nvar PLUGIN_PRIORITY31 = 200;\nvar \
TouchScroll = class extends BasePlugin {\n  static get PLUGIN_KEY() {\n    \
return PLUGIN_KEY32;\n  }\n  static get PLUGIN_PRIORITY() {\n    return \
PLUGIN_PRIORITY31;\n  }\n  static get SETTING_KEYS() {\n    return true;\n  \
}\n  constructor(hotInstance) {\n    super(hotInstance);\n    this.scrollbars \
= [];\n    this.clones = [];\n    this.lockedCollection = false;\n    \
this.freezeOverlays = false;\n  }\n  /**\n   * Check if plugin is enabled.\n  \
 *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return \
isTouchSupported();\n  }\n  /**\n   * Enable the plugin.\n   */\n  \
enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    \
this.addHook(\"afterViewRender\", () => this.onAfterViewRender());\n    \
this.registerEvents();\n    super.enablePlugin();\n  }\n  /**\n   * Updates \
the plugin to use the latest options you have specified.\n   */\n  \
updatePlugin() {\n    this.lockedCollection = false;\n    \
super.updatePlugin();\n  }\n  /**\n   * Disable plugin for this Handsontable \
instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n  }\n  \
/**\n   * Register all necessary events.\n   *\n   * @private\n   */\n  \
registerEvents() {\n    this.addHook(\"beforeTouchScroll\", () => \
this.onBeforeTouchScroll());\n    this.addHook(\"afterMomentumScroll\", () => \
this.onAfterMomentumScroll());\n  }\n  /**\n   * After view render \
listener.\n   *\n   * @private\n   */\n  onAfterViewRender() {\n    if \
(this.lockedCollection) {\n      return;\n    }\n    const {\n      \
topOverlay,\n      bottomOverlay,\n      inlineStartOverlay,\n      \
topInlineStartCornerOverlay,\n      bottomInlineStartCornerOverlay\n    } = \
this.hot.view._wt.wtOverlays;\n    this.lockedCollection = true;\n    \
this.scrollbars.length = 0;\n    this.scrollbars.push(topOverlay);\n    if \
(bottomOverlay.clone) {\n      this.scrollbars.push(bottomOverlay);\n    }\n  \
  this.scrollbars.push(inlineStartOverlay);\n    if \
(topInlineStartCornerOverlay) {\n      \
this.scrollbars.push(topInlineStartCornerOverlay);\n    }\n    if \
(bottomInlineStartCornerOverlay && bottomInlineStartCornerOverlay.clone) {\n  \
    this.scrollbars.push(bottomInlineStartCornerOverlay);\n    }\n    \
this.clones = [];\n    if (topOverlay.needFullRender) {\n      \
this.clones.push(topOverlay.clone.wtTable.holder.parentNode);\n    }\n    if \
(bottomOverlay.needFullRender) {\n      \
this.clones.push(bottomOverlay.clone.wtTable.holder.parentNode);\n    }\n    \
if (inlineStartOverlay.needFullRender) {\n      \
this.clones.push(inlineStartOverlay.clone.wtTable.holder.parentNode);\n    \
}\n    if (topInlineStartCornerOverlay) {\n      \
this.clones.push(topInlineStartCornerOverlay.clone.wtTable.holder.parentNode)\
;\n    }\n    if (bottomInlineStartCornerOverlay && \
bottomInlineStartCornerOverlay.clone) {\n      \
this.clones.push(bottomInlineStartCornerOverlay.clone.wtTable.holder.parentNo\
de);\n    }\n  }\n  /**\n   * Touch scroll listener.\n   *\n   * @private\n   \
*/\n  onBeforeTouchScroll() {\n    this.freezeOverlays = true;\n    \
arrayEach(this.clones, (clone2) => {\n      addClass(clone2, \
\"hide-tween\");\n    });\n  }\n  /**\n   * After momentum scroll listener.\n \
  *\n   * @private\n   */\n  onAfterMomentumScroll() {\n    \
this.freezeOverlays = false;\n    arrayEach(this.clones, (clone2) => {\n      \
removeClass(clone2, \"hide-tween\");\n      addClass(clone2, \
\"show-tween\");\n    });\n    this.hot._registerTimeout(() => {\n      \
arrayEach(this.clones, (clone2) => {\n        removeClass(clone2, \
\"show-tween\");\n      });\n    }, 400);\n    arrayEach(this.scrollbars, \
(scrollbar) => {\n      scrollbar.refresh();\n      \
scrollbar.resetFixedPosition();\n    });\n    \
this.hot.view._wt.wtOverlays.syncScrollWithMaster();\n  }\n};\n\n// \
node_modules/handsontable/plugins/trimRows/trimRows.mjs\nvar PLUGIN_KEY33 = \
\"trimRows\";\nvar PLUGIN_PRIORITY32 = 330;\nvar TrimRows = class extends \
BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY33;\n  }\n  \
static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY32;\n  }\n  \
constructor(hotInstance) {\n    super(hotInstance);\n    this.trimmedRowsMap \
= null;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable \
settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and \
if it returns `true` then the {@link AutoRowSize#enablePlugin} method is \
called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return \
!!this.hot.getSettings()[PLUGIN_KEY33];\n  }\n  /**\n   * Enables the plugin \
functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    \
if (this.enabled) {\n      return;\n    }\n    this.trimmedRowsMap = \
this.hot.rowIndexMapper.registerMap(\"trimRows\", new TrimmingMap());\n    \
this.trimmedRowsMap.addLocalHook(\"init\", () => this.onMapInit());\n    \
super.enablePlugin();\n  }\n  /**\n   * Updates the plugin's state.\n   *\n   \
* This method is executed when \
[`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the \
following configuration options:\n   *  - \
[`trimRows`](@/api/options.md#trimrows)\n   */\n  updatePlugin() {\n    const \
trimmedRows = this.hot.getSettings()[PLUGIN_KEY33];\n    if \
(Array.isArray(trimmedRows)) {\n      this.hot.batchExecution(() => {\n       \
 this.trimmedRowsMap.clear();\n        arrayEach(trimmedRows, (physicalRow) \
=> {\n          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n     \
   });\n      }, true);\n    }\n    super.updatePlugin();\n  }\n  /**\n   * \
Disables the plugin functionality for this Handsontable instance.\n   */\n  \
disablePlugin() {\n    this.hot.rowIndexMapper.unregisterMap(\"trimRows\");\n \
   super.disablePlugin();\n  }\n  /**\n   * Get list of trimmed rows.\n   *\n \
  * @returns {Array} Physical rows.\n   */\n  getTrimmedRows() {\n    return \
this.trimmedRowsMap.getTrimmedIndexes();\n  }\n  /**\n   * Trims the rows \
provided in the array.\n   *\n   * @param {number[]} rows Array of physical \
row indexes.\n   * @fires Hooks#beforeTrimRow\n   * @fires \
Hooks#afterTrimRow\n   */\n  trimRows(rows) {\n    const currentTrimConfig = \
this.getTrimmedRows();\n    const isValidConfig = this.isValidConfig(rows);\n \
   let destinationTrimConfig = currentTrimConfig;\n    if (isValidConfig) {\n \
     destinationTrimConfig = Array.from(new \
Set(currentTrimConfig.concat(rows)));\n    }\n    const allowTrimRow = \
this.hot.runHooks(\"beforeTrimRow\", currentTrimConfig, \
destinationTrimConfig, isValidConfig);\n    if (allowTrimRow === false) {\n   \
   return;\n    }\n    if (isValidConfig) {\n      this.hot.batchExecution(() \
=> {\n        arrayEach(rows, (physicalRow) => {\n          \
this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      \
}, true);\n    }\n    this.hot.runHooks(\"afterTrimRow\", currentTrimConfig, \
destinationTrimConfig, isValidConfig, isValidConfig && \
destinationTrimConfig.length > currentTrimConfig.length);\n  }\n  /**\n   * \
Trims the row provided as a physical row index (counting from 0).\n   *\n   * \
@param {...number} row Physical row index.\n   */\n  trimRow() {\n    for \
(var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; \
_key++) {\n      row[_key] = arguments[_key];\n    }\n    \
this.trimRows(row);\n  }\n  /**\n   * Untrims the rows provided in the \
array.\n   *\n   * @param {number[]} rows Array of physical row indexes.\n   \
* @fires Hooks#beforeUntrimRow\n   * @fires Hooks#afterUntrimRow\n   */\n  \
untrimRows(rows) {\n    const currentTrimConfig = this.getTrimmedRows();\n    \
const isValidConfig = this.isValidConfig(rows);\n    let \
destinationTrimConfig = currentTrimConfig;\n    const trimmingMapValues = \
this.trimmedRowsMap.getValues().slice();\n    const isAnyRowUntrimmed = \
rows.length > 0;\n    if (isValidConfig && isAnyRowUntrimmed) {\n      \
arrayEach(rows, (physicalRow) => {\n        trimmingMapValues[physicalRow] = \
false;\n      });\n      destinationTrimConfig = \
arrayReduce(trimmingMapValues, (trimmedIndexes, isTrimmed, physicalIndex) => \
{\n        if (isTrimmed) {\n          trimmedIndexes.push(physicalIndex);\n  \
      }\n        return trimmedIndexes;\n      }, []);\n    }\n    const \
allowUntrimRow = this.hot.runHooks(\"beforeUntrimRow\", currentTrimConfig, \
destinationTrimConfig, isValidConfig && isAnyRowUntrimmed);\n    if \
(allowUntrimRow === false) {\n      return;\n    }\n    if (isValidConfig && \
isAnyRowUntrimmed) {\n      \
this.trimmedRowsMap.setValues(trimmingMapValues);\n    }\n    \
this.hot.runHooks(\"afterUntrimRow\", currentTrimConfig, \
destinationTrimConfig, isValidConfig && isAnyRowUntrimmed, isValidConfig && \
destinationTrimConfig.length < currentTrimConfig.length);\n  }\n  /**\n   * \
Untrims the row provided as a physical row index (counting from 0).\n   *\n   \
* @param {...number} row Physical row index.\n   */\n  untrimRow() {\n    for \
(var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < \
_len2; _key2++) {\n      row[_key2] = arguments[_key2];\n    }\n    \
this.untrimRows(row);\n  }\n  /**\n   * Checks if given row is hidden.\n   \
*\n   * @param {number} physicalRow Physical row index.\n   * @returns \
{boolean}\n   */\n  isTrimmed(physicalRow) {\n    return \
this.trimmedRowsMap.getValueAtIndex(physicalRow) || false;\n  }\n  /**\n   * \
Untrims all trimmed rows.\n   */\n  untrimAll() {\n    \
this.untrimRows(this.getTrimmedRows());\n  }\n  /**\n   * Get if trim config \
is valid. Check whether all of the provided physical row indexes are within \
source data.\n   *\n   * @param {Array} trimmedRows List of physical row \
indexes.\n   * @returns {boolean}\n   */\n  isValidConfig(trimmedRows) {\n    \
const sourceRows = this.hot.countSourceRows();\n    return \
trimmedRows.every((trimmedRow) => Number.isInteger(trimmedRow) && trimmedRow \
>= 0 && trimmedRow < sourceRows);\n  }\n  /**\n   * On map initialized hook \
callback.\n   *\n   * @private\n   */\n  onMapInit() {\n    const trimmedRows \
= this.hot.getSettings()[PLUGIN_KEY33];\n    if (Array.isArray(trimmedRows)) \
{\n      this.hot.batchExecution(() => {\n        arrayEach(trimmedRows, \
(physicalRow) => {\n          \
this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      \
}, true);\n    }\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  \
destroy() {\n    super.destroy();\n  }\n};\n\n// \
node_modules/handsontable/plugins/undoRedo/undoRedo.mjs\nvar SHORTCUTS_GROUP9 \
= \"undoRedo\";\nvar PLUGIN_KEY34 = \"undoRedo\";\nfunction \
UndoRedo(instance) {\n  const plugin = this;\n  this.instance = instance;\n  \
this.doneActions = [];\n  this.undoneActions = [];\n  this.ignoreNewActions = \
false;\n  this.enabled = false;\n  instance.addHook(\"afterChange\", \
function(changes, source) {\n    const changesLen = changes && \
changes.length;\n    if (!changesLen) {\n      return;\n    }\n    const \
hasDifferences = changes.find((change) => {\n      const [, , oldValue, \
newValue] = change;\n      return oldValue !== newValue;\n    });\n    if \
(!hasDifferences) {\n      return;\n    }\n    const wrappedAction = () => \
{\n      const clonedChanges = changes.reduce((arr, change) => {\n        \
arr.push([...change]);\n        return arr;\n      }, []);\n      \
arrayEach(clonedChanges, (change) => {\n        change[1] = \
instance.propToCol(change[1]);\n      });\n      const selected = changesLen \
> 1 ? this.getSelected() : [[clonedChanges[0][0], clonedChanges[0][1]]];\n    \
  return new UndoRedo.ChangeAction(clonedChanges, selected);\n    };\n    \
plugin.done(wrappedAction, source);\n  });\n  \
instance.addHook(\"afterCreateRow\", (index2, amount, source) => {\n    \
plugin.done(() => new UndoRedo.CreateRowAction(index2, amount), source);\n  \
});\n  instance.addHook(\"beforeRemoveRow\", (index2, amount, logicRows, \
source) => {\n    const wrappedAction = () => {\n      const physicalRowIndex \
= instance.toPhysicalRow(index2);\n      const removedData = \
deepClone(plugin.instance.getSourceData(physicalRowIndex, 0, physicalRowIndex \
+ amount - 1, plugin.instance.countSourceCols() - 1));\n      return new \
UndoRedo.RemoveRowAction(physicalRowIndex, removedData, \
instance.getSettings().fixedRowsBottom, instance.getSettings().fixedRowsTop, \
instance.rowIndexMapper.getIndexesSequence());\n    };\n    \
plugin.done(wrappedAction, source);\n  });\n  \
instance.addHook(\"afterCreateCol\", (index2, amount, source) => {\n    \
plugin.done(() => new UndoRedo.CreateColumnAction(index2, amount), source);\n \
 });\n  instance.addHook(\"beforeRemoveCol\", (index2, amount, logicColumns, \
source) => {\n    const wrappedAction = () => {\n      const originalData = \
plugin.instance.getSourceDataArray();\n      const columnIndex = \
(plugin.instance.countCols() + index2) % plugin.instance.countCols();\n      \
const removedData = [];\n      const headers = [];\n      const indexes = \
[];\n      rangeEach(originalData.length - 1, (i) => {\n        const column \
= [];\n        const origRow = originalData[i];\n        \
rangeEach(columnIndex, columnIndex + (amount - 1), (j) => {\n          \
column.push(origRow[instance.toPhysicalColumn(j)]);\n        });\n        \
removedData.push(column);\n      });\n      rangeEach(amount - 1, (i) => {\n  \
      indexes.push(instance.toPhysicalColumn(columnIndex + i));\n      });\n  \
    if (Array.isArray(instance.getSettings().colHeaders)) {\n        \
rangeEach(amount - 1, (i) => {\n          \
headers.push(instance.getSettings().colHeaders[instance.toPhysicalColumn(colu\
mnIndex + i)] || null);\n        });\n      }\n      const columnsMap = \
instance.columnIndexMapper.getIndexesSequence();\n      const rowsMap = \
instance.rowIndexMapper.getIndexesSequence();\n      return new \
UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, \
columnsMap, rowsMap, instance.getSettings().fixedColumnsStart);\n    };\n    \
plugin.done(wrappedAction, source);\n  });\n  \
instance.addHook(\"beforeCellAlignment\", (stateBefore, range, type, \
alignment) => {\n    plugin.done(() => new \
UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment));\n  });\n  \
instance.addHook(\"beforeFilter\", (conditionsStack) => {\n    plugin.done(() \
=> new UndoRedo.FiltersAction(conditionsStack));\n  });\n  \
instance.addHook(\"beforeRowMove\", (rows, finalIndex) => {\n    if (rows === \
false) {\n      return;\n    }\n    plugin.done(() => new \
UndoRedo.RowMoveAction(rows, finalIndex));\n  });\n  \
instance.addHook(\"beforeMergeCells\", (cellRange, auto) => {\n    if (auto) \
{\n      return;\n    }\n    plugin.done(() => new \
UndoRedo.MergeCellsAction(instance, cellRange));\n  });\n  \
instance.addHook(\"afterUnmergeCells\", (cellRange, auto) => {\n    if (auto) \
{\n      return;\n    }\n    plugin.done(() => new \
UndoRedo.UnmergeCellsAction(instance, cellRange));\n  });\n  \
instance.addHook(\"afterInit\", () => {\n    plugin.init();\n  \
});\n}\nUndoRedo.prototype.done = function(wrappedAction, source) {\n  if \
(this.ignoreNewActions) {\n    return;\n  }\n  const isBlockedByDefault = \
source === \"UndoRedo.undo\" || source === \"UndoRedo.redo\" || source === \
\"auto\";\n  if (isBlockedByDefault) {\n    return;\n  }\n  const \
doneActionsCopy = this.doneActions.slice();\n  const continueAction = \
this.instance.runHooks(\"beforeUndoStackChange\", doneActionsCopy, source);\n \
 if (continueAction === false) {\n    return;\n  }\n  const newAction = \
wrappedAction();\n  const undoneActionsCopy = this.undoneActions.slice();\n  \
this.doneActions.push(newAction);\n  \
this.instance.runHooks(\"afterUndoStackChange\", doneActionsCopy, \
this.doneActions.slice());\n  \
this.instance.runHooks(\"beforeRedoStackChange\", undoneActionsCopy);\n  \
this.undoneActions.length = 0;\n  \
this.instance.runHooks(\"afterRedoStackChange\", undoneActionsCopy, \
this.undoneActions.slice());\n};\nUndoRedo.prototype.undo = function() {\n  \
if (this.isUndoAvailable()) {\n    const doneActionsCopy = \
this.doneActions.slice();\n    \
this.instance.runHooks(\"beforeUndoStackChange\", doneActionsCopy);\n    \
const action = this.doneActions.pop();\n    \
this.instance.runHooks(\"afterUndoStackChange\", doneActionsCopy, \
this.doneActions.slice());\n    const actionClone = deepClone(action);\n    \
const continueAction = this.instance.runHooks(\"beforeUndo\", actionClone);\n \
   if (continueAction === false) {\n      return;\n    }\n    \
this.ignoreNewActions = true;\n    const that = this;\n    const \
undoneActionsCopy = this.undoneActions.slice();\n    \
this.instance.runHooks(\"beforeRedoStackChange\", undoneActionsCopy);\n    \
action.undo(this.instance, () => {\n      that.ignoreNewActions = false;\n    \
  that.undoneActions.push(action);\n    });\n    \
this.instance.runHooks(\"afterRedoStackChange\", undoneActionsCopy, \
this.undoneActions.slice());\n    this.instance.runHooks(\"afterUndo\", \
actionClone);\n  }\n};\nUndoRedo.prototype.redo = function() {\n  if \
(this.isRedoAvailable()) {\n    const undoneActionsCopy = \
this.undoneActions.slice();\n    \
this.instance.runHooks(\"beforeRedoStackChange\", undoneActionsCopy);\n    \
const action = this.undoneActions.pop();\n    \
this.instance.runHooks(\"afterRedoStackChange\", undoneActionsCopy, \
this.undoneActions.slice());\n    const actionClone = deepClone(action);\n    \
const continueAction = this.instance.runHooks(\"beforeRedo\", actionClone);\n \
   if (continueAction === false) {\n      return;\n    }\n    \
this.ignoreNewActions = true;\n    const that = this;\n    const \
doneActionsCopy = this.doneActions.slice();\n    \
this.instance.runHooks(\"beforeUndoStackChange\", doneActionsCopy);\n    \
action.redo(this.instance, () => {\n      that.ignoreNewActions = false;\n    \
  that.doneActions.push(action);\n    });\n    \
this.instance.runHooks(\"afterUndoStackChange\", doneActionsCopy, \
this.doneActions.slice());\n    this.instance.runHooks(\"afterRedo\", \
actionClone);\n  }\n};\nUndoRedo.prototype.isUndoAvailable = function() {\n  \
return this.doneActions.length > 0;\n};\nUndoRedo.prototype.isRedoAvailable = \
function() {\n  return this.undoneActions.length > \
0;\n};\nUndoRedo.prototype.clear = function() {\n  this.doneActions.length = \
0;\n  this.undoneActions.length = 0;\n};\nUndoRedo.prototype.isEnabled = \
function() {\n  return this.enabled;\n};\nUndoRedo.prototype.enable = \
function() {\n  if (this.isEnabled()) {\n    return;\n  }\n  const hot2 = \
this.instance;\n  this.enabled = true;\n  exposeUndoRedoMethods(hot2);\n  \
this.registerShortcuts();\n  hot2.addHook(\"afterChange\", \
onAfterChange);\n};\nUndoRedo.prototype.disable = function() {\n  if \
(!this.isEnabled()) {\n    return;\n  }\n  const hot2 = this.instance;\n  \
this.enabled = false;\n  removeExposedUndoRedoMethods(hot2);\n  \
this.unregisterShortcuts();\n  hot2.removeHook(\"afterChange\", \
onAfterChange);\n};\nUndoRedo.prototype.destroy = function() {\n  \
this.clear();\n  this.instance = null;\n  this.doneActions = null;\n  \
this.undoneActions = null;\n};\nUndoRedo.Action = function() \
{\n};\nUndoRedo.Action.prototype.undo = function() \
{\n};\nUndoRedo.Action.prototype.redo = function() \
{\n};\nUndoRedo.ChangeAction = function(changes, selected) {\n  this.changes \
= changes;\n  this.selected = selected;\n  this.actionType = \
\"change\";\n};\ninherit(UndoRedo.ChangeAction, \
UndoRedo.Action);\nUndoRedo.ChangeAction.prototype.undo = function(instance, \
undoneCallback) {\n  const data2 = deepClone(this.changes);\n  const \
emptyRowsAtTheEnd = instance.countEmptyRows(true);\n  const emptyColsAtTheEnd \
= instance.countEmptyCols(true);\n  for (let i = 0, len = data2.length; i < \
len; i++) {\n    data2[i].splice(3, 1);\n  }\n  \
instance.addHookOnce(\"afterChange\", undoneCallback);\n  \
instance.setDataAtCell(data2, null, null, \"UndoRedo.undo\");\n  for (let i = \
0, len = data2.length; i < len; i++) {\n    const [row, column] = data2[i];\n \
   if (instance.getSettings().minSpareRows && row + 1 + \
instance.getSettings().minSpareRows === instance.countRows() && \
emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {\n      \
instance.alter(\"remove_row\", parseInt(row + 1, 10), \
instance.getSettings().minSpareRows);\n      \
instance.undoRedo.doneActions.pop();\n    }\n    if \
(instance.getSettings().minSpareCols && column + 1 + \
instance.getSettings().minSpareCols === instance.countCols() && \
emptyColsAtTheEnd === instance.getSettings().minSpareCols) {\n      \
instance.alter(\"remove_col\", parseInt(column + 1, 10), \
instance.getSettings().minSpareCols);\n      \
instance.undoRedo.doneActions.pop();\n    }\n  }\n  \
instance.selectCells(this.selected, false, \
false);\n};\nUndoRedo.ChangeAction.prototype.redo = function(instance, \
onFinishCallback) {\n  const data2 = deepClone(this.changes);\n  for (let i = \
0, len = data2.length; i < len; i++) {\n    data2[i].splice(2, 1);\n  }\n  \
instance.addHookOnce(\"afterChange\", onFinishCallback);\n  \
instance.setDataAtCell(data2, null, null, \"UndoRedo.redo\");\n  if \
(this.selected) {\n    instance.selectCells(this.selected, false, false);\n  \
}\n};\nUndoRedo.CreateRowAction = function(index2, amount) {\n  this.index = \
index2;\n  this.amount = amount;\n  this.actionType = \
\"insert_row\";\n};\ninherit(UndoRedo.CreateRowAction, \
UndoRedo.Action);\nUndoRedo.CreateRowAction.prototype.undo = \
function(instance, undoneCallback) {\n  const rowCount = \
instance.countRows();\n  const minSpareRows = \
instance.getSettings().minSpareRows;\n  if (this.index >= rowCount && \
this.index - minSpareRows < rowCount) {\n    this.index -= minSpareRows;\n  \
}\n  instance.addHookOnce(\"afterRemoveRow\", undoneCallback);\n  \
instance.alter(\"remove_row\", this.index, this.amount, \
\"UndoRedo.undo\");\n};\nUndoRedo.CreateRowAction.prototype.redo = \
function(instance, redoneCallback) {\n  \
instance.addHookOnce(\"afterCreateRow\", redoneCallback);\n  \
instance.alter(\"insert_row_above\", this.index, this.amount, \
\"UndoRedo.redo\");\n};\nUndoRedo.RemoveRowAction = function(index2, data2, \
fixedRowsBottom, fixedRowsTop, rowIndexesSequence) {\n  this.index = \
index2;\n  this.data = data2;\n  this.actionType = \"remove_row\";\n  \
this.fixedRowsBottom = fixedRowsBottom;\n  this.fixedRowsTop = \
fixedRowsTop;\n  this.rowIndexesSequence = \
rowIndexesSequence;\n};\ninherit(UndoRedo.RemoveRowAction, \
UndoRedo.Action);\nUndoRedo.RemoveRowAction.prototype.undo = \
function(instance, undoneCallback) {\n  const settings = \
instance.getSettings();\n  const changes = [];\n  settings.fixedRowsBottom = \
this.fixedRowsBottom;\n  settings.fixedRowsTop = this.fixedRowsTop;\n  \
this.data.forEach((dataRow, rowIndexDelta) => {\n    \
Object.keys(dataRow).forEach((columnProp) => {\n      const columnIndex = \
parseInt(columnProp, 10);\n      changes.push([this.index + rowIndexDelta, \
isNaN(columnIndex) ? columnProp : columnIndex, dataRow[columnProp]]);\n    \
});\n  });\n  instance.alter(\"insert_row_above\", this.index, \
this.data.length, \"UndoRedo.undo\");\n  \
instance.addHookOnce(\"afterViewRender\", undoneCallback);\n  \
instance.setSourceDataAtCell(changes, null, null, \"UndoRedo.undo\");\n  \
instance.rowIndexMapper.setIndexesSequence(this.rowIndexesSequence);\n};\nUnd\
oRedo.RemoveRowAction.prototype.redo = function(instance, redoneCallback) {\n \
 instance.addHookOnce(\"afterRemoveRow\", redoneCallback);\n  \
instance.alter(\"remove_row\", this.index, this.data.length, \
\"UndoRedo.redo\");\n};\nUndoRedo.CreateColumnAction = function(index2, \
amount) {\n  this.index = index2;\n  this.amount = amount;\n  this.actionType \
= \"insert_col\";\n};\ninherit(UndoRedo.CreateColumnAction, \
UndoRedo.Action);\nUndoRedo.CreateColumnAction.prototype.undo = \
function(instance, undoneCallback) {\n  \
instance.addHookOnce(\"afterRemoveCol\", undoneCallback);\n  \
instance.alter(\"remove_col\", this.index, this.amount, \
\"UndoRedo.undo\");\n};\nUndoRedo.CreateColumnAction.prototype.redo = \
function(instance, redoneCallback) {\n  \
instance.addHookOnce(\"afterCreateCol\", redoneCallback);\n  \
instance.alter(\"insert_col_start\", this.index, this.amount, \
\"UndoRedo.redo\");\n};\nUndoRedo.RemoveColumnAction = function(index2, \
indexes, data2, headers, columnPositions, rowPositions, fixedColumnsStart) \
{\n  this.index = index2;\n  this.indexes = indexes;\n  this.data = data2;\n  \
this.amount = this.data[0].length;\n  this.headers = headers;\n  \
this.columnPositions = columnPositions.slice(0);\n  this.rowPositions = \
rowPositions.slice(0);\n  this.actionType = \"remove_col\";\n  \
this.fixedColumnsStart = \
fixedColumnsStart;\n};\ninherit(UndoRedo.RemoveColumnAction, \
UndoRedo.Action);\nUndoRedo.RemoveColumnAction.prototype.undo = \
function(instance, undoneCallback) {\n  const settings = \
instance.getSettings();\n  settings.fixedColumnsStart = \
this.fixedColumnsStart;\n  const ascendingIndexes = \
this.indexes.slice(0).sort();\n  const sortByIndexes = (elem, j, arr) => \
arr[this.indexes.indexOf(ascendingIndexes[j])];\n  const removedDataLength = \
this.data.length;\n  const sortedData = [];\n  for (let rowIndex = 0; \
rowIndex < removedDataLength; rowIndex++) {\n    \
sortedData.push(arrayMap(this.data[rowIndex], sortByIndexes));\n  }\n  const \
sortedHeaders = arrayMap(this.headers, sortByIndexes);\n  const changes = \
[];\n  instance.alter(\"insert_col_start\", this.indexes[0], \
this.indexes.length, \"UndoRedo.undo\");\n  \
arrayEach(instance.getSourceDataArray(), (rowData, rowIndex) => {\n    \
arrayEach(ascendingIndexes, (changedIndex, contiquesIndex) => {\n      \
rowData[changedIndex] = sortedData[rowIndex][contiquesIndex];\n      \
changes.push([rowIndex, changedIndex, rowData[changedIndex]]);\n    });\n  \
});\n  instance.setSourceDataAtCell(changes, void 0, void 0, \
\"UndoRedo.undo\");\n  if (typeof this.headers !== \"undefined\") {\n    \
arrayEach(sortedHeaders, (headerData, columnIndex) => {\n      \
instance.getSettings().colHeaders[ascendingIndexes[columnIndex]] = \
headerData;\n    });\n  }\n  instance.batchExecution(() => {\n    \
instance.rowIndexMapper.setIndexesSequence(this.rowPositions);\n    \
instance.columnIndexMapper.setIndexesSequence(this.columnPositions);\n  }, \
true);\n  instance.addHookOnce(\"afterViewRender\", undoneCallback);\n  \
instance.render();\n};\nUndoRedo.RemoveColumnAction.prototype.redo = \
function(instance, redoneCallback) {\n  \
instance.addHookOnce(\"afterRemoveCol\", redoneCallback);\n  \
instance.alter(\"remove_col\", this.index, this.amount, \
\"UndoRedo.redo\");\n};\nUndoRedo.CellAlignmentAction = function(stateBefore, \
range, type, alignment) {\n  this.stateBefore = stateBefore;\n  this.range = \
range;\n  this.type = type;\n  this.alignment = \
alignment;\n};\nUndoRedo.CellAlignmentAction.prototype.undo = \
function(instance, undoneCallback) {\n  arrayEach(this.range, (range) => {\n  \
  range.forAll((row, col) => {\n      if (row >= 0 && col >= 0) {\n        \
instance.setCellMeta(row, col, \"className\", this.stateBefore[row][col] || \
\" htLeft\");\n      }\n    });\n  });\n  \
instance.addHookOnce(\"afterViewRender\", undoneCallback);\n  \
instance.render();\n};\nUndoRedo.CellAlignmentAction.prototype.redo = \
function(instance, undoneCallback) {\n  align(this.range, this.type, \
this.alignment, (row, col) => instance.getCellMeta(row, col), (row, col, key, \
value) => instance.setCellMeta(row, col, key, value));\n  \
instance.addHookOnce(\"afterViewRender\", undoneCallback);\n  \
instance.render();\n};\nUndoRedo.FiltersAction = function(conditionsStack) \
{\n  this.conditionsStack = conditionsStack;\n  this.actionType = \
\"filter\";\n};\ninherit(UndoRedo.FiltersAction, \
UndoRedo.Action);\nUndoRedo.FiltersAction.prototype.undo = function(instance, \
undoneCallback) {\n  const filters = instance.getPlugin(\"filters\");\n  \
instance.addHookOnce(\"afterViewRender\", undoneCallback);\n  \
filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, \
this.conditionsStack.length - 1));\n  \
filters.filter();\n};\nUndoRedo.FiltersAction.prototype.redo = \
function(instance, redoneCallback) {\n  const filters = \
instance.getPlugin(\"filters\");\n  instance.addHookOnce(\"afterViewRender\", \
redoneCallback);\n  \
filters.conditionCollection.importAllConditions(this.conditionsStack);\n  \
filters.filter();\n};\nvar MergeCellsAction = class extends UndoRedo.Action \
{\n  constructor(instance, cellRange) {\n    super();\n    this.cellRange = \
cellRange;\n    const topStartCorner = this.cellRange.getTopStartCorner();\n  \
  const bottomEndCorner = this.cellRange.getBottomEndCorner();\n    \
this.rangeData = instance.getData(topStartCorner.row, topStartCorner.col, \
bottomEndCorner.row, bottomEndCorner.col);\n  }\n  undo(instance, \
undoneCallback) {\n    const mergeCellsPlugin = \
instance.getPlugin(\"mergeCells\");\n    \
instance.addHookOnce(\"afterViewRender\", undoneCallback);\n    \
mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    const \
topStartCorner = this.cellRange.getTopStartCorner();\n    \
instance.populateFromArray(topStartCorner.row, topStartCorner.col, \
this.rangeData, void 0, void 0, \"MergeCells\");\n  }\n  redo(instance, \
redoneCallback) {\n    const mergeCellsPlugin = \
instance.getPlugin(\"mergeCells\");\n    \
instance.addHookOnce(\"afterViewRender\", redoneCallback);\n    \
mergeCellsPlugin.mergeRange(this.cellRange);\n  \
}\n};\nUndoRedo.MergeCellsAction = MergeCellsAction;\nvar UnmergeCellsAction \
= class extends UndoRedo.Action {\n  constructor(instance, cellRange) {\n    \
super();\n    this.cellRange = cellRange;\n  }\n  undo(instance, \
undoneCallback) {\n    const mergeCellsPlugin = \
instance.getPlugin(\"mergeCells\");\n    \
instance.addHookOnce(\"afterViewRender\", undoneCallback);\n    \
mergeCellsPlugin.mergeRange(this.cellRange, true);\n  }\n  redo(instance, \
redoneCallback) {\n    const mergeCellsPlugin = \
instance.getPlugin(\"mergeCells\");\n    \
instance.addHookOnce(\"afterViewRender\", redoneCallback);\n    \
mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    \
instance.render();\n  }\n};\nUndoRedo.UnmergeCellsAction = \
UnmergeCellsAction;\nUndoRedo.RowMoveAction = function(rows, finalIndex) {\n  \
this.rows = rows.slice();\n  this.finalIndex = finalIndex;\n  this.actionType \
= \"row_move\";\n};\ninherit(UndoRedo.RowMoveAction, \
UndoRedo.Action);\nUndoRedo.RowMoveAction.prototype.undo = function(instance, \
undoneCallback) {\n  const manualRowMove = \
instance.getPlugin(\"manualRowMove\");\n  const copyOfRows = \
[].concat(this.rows);\n  const rowsMovedUp = copyOfRows.filter((a) => a > \
this.finalIndex);\n  const rowsMovedDown = copyOfRows.filter((a) => a <= \
this.finalIndex);\n  const allMovedRows = rowsMovedUp.sort((a, b) => b - \
a).concat(rowsMovedDown.sort((a, b) => a - b));\n  \
instance.addHookOnce(\"afterViewRender\", undoneCallback);\n  for (let i = 0; \
i < allMovedRows.length; i += 1) {\n    const newPhysicalRow = \
instance.toVisualRow(allMovedRows[i]);\n    \
manualRowMove.moveRow(newPhysicalRow, allMovedRows[i]);\n  }\n  \
instance.render();\n  instance.deselectCell();\n  \
instance.selectRows(this.rows[0], this.rows[0] + this.rows.length - \
1);\n};\nUndoRedo.RowMoveAction.prototype.redo = function(instance, \
redoneCallback) {\n  const manualRowMove = \
instance.getPlugin(\"manualRowMove\");\n  \
instance.addHookOnce(\"afterViewRender\", redoneCallback);\n  \
manualRowMove.moveRows(this.rows.slice(), this.finalIndex);\n  \
instance.render();\n  instance.deselectCell();\n  \
instance.selectRows(this.finalIndex, this.finalIndex + this.rows.length - \
1);\n};\nUndoRedo.prototype.init = function() {\n  const settings = \
this.instance.getSettings().undo;\n  const pluginEnabled = typeof settings \
=== \"undefined\" || settings;\n  if (!this.instance.undoRedo) {\n    \
this.instance.undoRedo = this;\n  }\n  if (pluginEnabled) {\n    \
this.instance.undoRedo.enable();\n  } else {\n    \
this.instance.undoRedo.disable();\n  \
}\n};\nUndoRedo.prototype.registerShortcuts = function() {\n  const \
shortcutManager = this.instance.getShortcutManager();\n  const gridContext = \
shortcutManager.getContext(\"grid\");\n  const runOnlyIf = (event2) => {\n    \
return !event2.altKey;\n  };\n  const config = {\n    runOnlyIf,\n    group: \
SHORTCUTS_GROUP9\n  };\n  gridContext.addShortcuts([{\n    keys: \
[[\"Control/Meta\", \"z\"]],\n    callback: () => {\n      this.undo();\n    \
}\n  }, {\n    keys: [[\"Control/Meta\", \"y\"], [\"Control/Meta\", \
\"Shift\", \"z\"]],\n    callback: () => {\n      this.redo();\n    }\n  }], \
config);\n};\nUndoRedo.prototype.unregisterShortcuts = function() {\n  const \
shortcutManager = this.instance.getShortcutManager();\n  const gridContext = \
shortcutManager.getContext(\"grid\");\n  \
gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP9);\n};\nfunction \
onAfterChange(changes, source) {\n  const instance = this;\n  if (source === \
\"loadData\") {\n    return instance.undoRedo.clear();\n  }\n}\nfunction \
exposeUndoRedoMethods(instance) {\n  instance.undo = function() {\n    return \
instance.undoRedo.undo();\n  };\n  instance.redo = function() {\n    return \
instance.undoRedo.redo();\n  };\n  instance.isUndoAvailable = function() {\n  \
  return instance.undoRedo.isUndoAvailable();\n  };\n  \
instance.isRedoAvailable = function() {\n    return \
instance.undoRedo.isRedoAvailable();\n  };\n  instance.clearUndo = function() \
{\n    return instance.undoRedo.clear();\n  };\n}\nfunction \
removeExposedUndoRedoMethods(instance) {\n  delete instance.undo;\n  delete \
instance.redo;\n  delete instance.isUndoAvailable;\n  delete \
instance.isRedoAvailable;\n  delete instance.clearUndo;\n}\nvar hook = \
pluginHooks_default.getSingleton();\nhook.add(\"afterUpdateSettings\", \
function() {\n  var _this$getPlugin;\n  (_this$getPlugin = \
this.getPlugin(\"undoRedo\")) === null || _this$getPlugin === void 0 || \
_this$getPlugin.init();\n});\nhook.register(\"beforeUndo\");\nhook.register(\
\"afterUndo\");\nhook.register(\"beforeRedo\");\nhook.register(\"afterRedo\")\
;\nUndoRedo.PLUGIN_KEY = PLUGIN_KEY34;\nUndoRedo.SETTING_KEYS = true;\nvar \
undoRedo_default = UndoRedo;\n\n// \
node_modules/handsontable/plugins/index.mjs\nfunction registerAllPlugins() \
{\n  registerPlugin(AutoColumnSize);\n  registerPlugin(Autofill);\n  \
registerPlugin(AutoRowSize);\n  registerPlugin(BindRowsWithHeaders);\n  \
registerPlugin(CollapsibleColumns);\n  registerPlugin(ColumnSorting);\n  \
registerPlugin(ColumnSummary);\n  registerPlugin(Comments);\n  \
registerPlugin(ContextMenu);\n  registerPlugin(CopyPaste);\n  \
registerPlugin(CustomBorders);\n  registerPlugin(DragToScroll);\n  \
registerPlugin(DropdownMenu);\n  registerPlugin(ExportFile);\n  \
registerPlugin(Filters);\n  registerPlugin(Formulas);\n  \
registerPlugin(HiddenColumns);\n  registerPlugin(HiddenRows);\n  \
registerPlugin(ManualColumnFreeze);\n  registerPlugin(ManualColumnMove);\n  \
registerPlugin(ManualColumnResize);\n  registerPlugin(ManualRowMove);\n  \
registerPlugin(ManualRowResize);\n  registerPlugin(MergeCells);\n  \
registerPlugin(MultiColumnSorting);\n  \
registerPlugin(MultipleSelectionHandles);\n  registerPlugin(NestedHeaders);\n \
 registerPlugin(NestedRows);\n  registerPlugin(PersistentState);\n  \
registerPlugin(Search);\n  registerPlugin(TouchScroll);\n  \
registerPlugin(TrimRows);\n  registerPlugin(undoRedo_default);\n}\n\n// \
node_modules/handsontable/registry.mjs\nfunction registerAllModules() {\n  \
registerAllEditors();\n  registerAllRenderers();\n  \
registerAllValidators();\n  registerAllCellTypes();\n  \
registerAllPlugins();\n}\n\n// \
node_modules/handsontable/helpers/wrappers/jquery.mjs\nfunction \
jQueryWrapper(Handsontable2) {\n  const jQuery = typeof window === \
\"undefined\" ? false : window.jQuery;\n  if (!jQuery) {\n    return;\n  }\n  \
jQuery.fn.handsontable = function(action) {\n    const $this = \
this.first();\n    let instance = $this.data(\"handsontable\");\n    if \
(typeof action !== \"string\") {\n      const userSettings = action || {};\n  \
    if (instance) {\n        instance.updateSettings(userSettings);\n      } \
else {\n        instance = new Handsontable2.Core($this[0], userSettings);\n  \
      $this.data(\"handsontable\", instance);\n        instance.init();\n     \
 }\n      return $this;\n    }\n    let output;\n    if (instance) {\n      \
if (typeof instance[action] !== \"undefined\") {\n        for (var _len = \
arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < \
_len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n     \
   output = instance[action].call(instance, ...args);\n        if (action === \
\"destroy\") {\n          $this.removeData();\n        }\n      } else {\n    \
    throw new Error(`Handsontable do not provide action: ${action}`);\n      \
}\n    }\n    return output;\n  };\n}\n\n// \
node_modules/handsontable/index.mjs\nvar _Handsontable$cellTyp;\nvar \
_Handsontable$editors;\nvar _Handsontable$rendere;\nvar \
_Handsontable$validat;\nvar \
_Handsontable$plugins;\nregisterAllModules();\njQueryWrapper(base_default);\n\
base_default.__GhostTable = \
ghostTable_default;\nbase_default._getListenersCounter = \
getListenersCounter;\nbase_default._getRegisteredMapsCounter = \
getRegisteredMapsCounter;\nbase_default.EventManager = \
eventManager_default;\nvar HELPERS = [array_exports, browser_exports, \
data_exports, date_exports, feature_exports, function_exports, mixed_exports, \
number_exports, object_exports, string_exports, unicode_exports, \
parseTable_exports];\nvar DOM = [element_exports, \
event_exports];\nbase_default.helper = {};\nbase_default.dom = \
{};\narrayEach(HELPERS, (helper) => {\n  \
arrayEach(Object.getOwnPropertyNames(helper), (key) => {\n    if \
(key.charAt(0) !== \"_\") {\n      base_default.helper[key] = helper[key];\n  \
  }\n  });\n});\narrayEach(DOM, (helper) => {\n  \
arrayEach(Object.getOwnPropertyNames(helper), (key) => {\n    if \
(key.charAt(0) !== \"_\") {\n      base_default.dom[key] = helper[key];\n    \
}\n  });\n});\nbase_default.cellTypes = (_Handsontable$cellTyp = \
base_default.cellTypes) !== null && _Handsontable$cellTyp !== void 0 ? \
_Handsontable$cellTyp : {};\narrayEach(getNames4(), (cellTypeName) => {\n  \
base_default.cellTypes[cellTypeName] = \
_getItem4(cellTypeName);\n});\nbase_default.cellTypes.registerCellType = \
_register4;\nbase_default.cellTypes.getCellType = \
_getItem4;\nbase_default.editors = (_Handsontable$editors = \
base_default.editors) !== null && _Handsontable$editors !== void 0 ? \
_Handsontable$editors : {};\narrayEach(getNames(), (editorName) => {\n  \
base_default.editors[`${toUpperCaseFirst(editorName)}Editor`] = \
_getItem(editorName);\n});\nbase_default.editors.registerEditor = \
_register;\nbase_default.editors.getEditor = \
_getItem;\nbase_default.renderers = (_Handsontable$rendere = \
base_default.renderers) !== null && _Handsontable$rendere !== void 0 ? \
_Handsontable$rendere : {};\narrayEach(getNames2(), (rendererName) => {\n  \
const renderer = _getItem2(rendererName);\n  if (rendererName === \"base\") \
{\n    base_default.renderers.cellDecorator = renderer;\n  }\n  \
base_default.renderers[`${toUpperCaseFirst(rendererName)}Renderer`] = \
renderer;\n});\nbase_default.renderers.registerRenderer = \
_register2;\nbase_default.renderers.getRenderer = \
_getItem2;\nbase_default.validators = (_Handsontable$validat = \
base_default.validators) !== null && _Handsontable$validat !== void 0 ? \
_Handsontable$validat : {};\narrayEach(getNames3(), (validatorName) => {\n  \
base_default.validators[`${toUpperCaseFirst(validatorName)}Validator`] = \
_getItem3(validatorName);\n});\nbase_default.validators.registerValidator = \
_register3;\nbase_default.validators.getValidator = \
_getItem3;\nbase_default.plugins = (_Handsontable$plugins = \
base_default.plugins) !== null && _Handsontable$plugins !== void 0 ? \
_Handsontable$plugins : {};\narrayEach(getPluginsNames(), (pluginName) => {\n \
 base_default.plugins[pluginName] = \
getPlugin(pluginName);\n});\nbase_default.plugins[`${toUpperCaseFirst(BasePlu\
gin.PLUGIN_KEY)}Plugin`] = BasePlugin;\nbase_default.plugins.registerPlugin = \
registerPlugin;\nbase_default.plugins.getPlugin = getPlugin;\nvar \
handsontable_default = base_default;\n\n// <stdin>\nvar data = [];\nfor (let \
i = 0; i < 1500; ++i) {\n  data.push([i, Math.random(), \
Math.random()]);\n}\nvar loadData = (offset3, window2) => {\n  const res = \
[];\n  if (offset3 + window2 > data.length)\n    return \"EOF\";\n  const \
size = Math.min(offset3 + window2, data.length);\n  for (let i = offset3; i < \
size; ++i) {\n    res.push(data[i]);\n  }\n  return [size - offset3, \
res];\n};\nvar parent = \
document.getElementById(\"tab\");\nparent.style.maxHeight = \
\"400px\";\nparent.style.position = \"relative\";\nparent.style.display = \
\"block\";\nparent.innerHTML = \"\";\nvar example = \
document.createElement(\"div\");\nparent.appendChild(example);\nexample.posit\
ion = \"relative\";\nexample.display = \"block\";\nvar bufferMaxSize = \
150;\nvar initial = loadData(0, bufferMaxSize);\nvar bufferSize = \
initial[0];\nvar offset2 = 0;\nvar hot = new handsontable_default(example, \
{\n  data: initial[1],\n  height: \"100%\",\n  multiColumnSorting: true,\n  \
filters: true,\n  rowHeaders: (i) => {\n    return String(offset2 + i);\n  \
},\n  manualRowMove: true,\n  renderAllRows: false,\n  contextMenu: true,\n  \
licenseKey: \"non-commercial-and-evaluation\",\n  afterChange: \
function(change, source) {\n    if (source === \"loadData\") {\n      \
return;\n    }\n    console.log(change);\n  }\n});\nvar shift = \
50;\nhot.addHook(\"afterScrollVertically\", function() {\n  const last = \
hot.getPlugin(\"AutoRowSize\").getLastVisibleRow();\n  const first = \
hot.getPlugin(\"AutoRowSize\").getFirstVisibleRow();\n  if (last >= \
bufferSize - 1) {\n    const newData = loadData(offset2 + shift, \
bufferMaxSize);\n    if (newData === \"EOF\") {\n      \
console.log(\"EOF\");\n      return;\n    }\n    bufferSize = newData[0];\n   \
 offset2 += shift;\n    hot.suspendRender();\n    hot.updateSettings({\n      \
data: newData[1]\n    });\n    hot.scrollViewportTo(first - shift);\n    \
hot.resumeRender();\n  }\n  if (offset2 > 0 && first < 1) {\n    offset2 -= \
shift;\n    const newData = loadData(offset2, bufferMaxSize);\n    bufferSize \
= newData[0];\n    hot.suspendRender();\n    hot.updateSettings({\n      \
data: newData[1]\n    });\n    hot.scrollViewportTo(first + shift);\n    \
hot.resumeRender();\n  }\n});\n/*! Bundled license \
information:\n\ndompurify/dist/purify.js:\n  (*! @license DOMPurify 2.4.7 | \
(c) Cure53 and other contributors | Released under the Apache license 2.0 and \
Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE \
*)\n\nmoment/moment.js:\n  (*! moment.js *)\n  (*! version : 2.29.4 *)\n  (*! \
authors : Tim Wood, Iskren Chernev, Moment.js contributors *)\n  (*! license \
: MIT *)\n  (*! momentjs.com *)\n\npikaday/pikaday.js:\n  (*!\n   * Pikaday\n \
  *\n   * Copyright \[CapitalAHat]\[Copyright] 2014 David Bushell | BSD & MIT \
license | https://github.com/Pikaday/Pikaday\n   \
*)\n\nhandsontable/i18n/languages/en-US.mjs:\n  (**\n   * @preserve\n   * \
Authors: Handsoncode\n   * Last updated: Nov 15, 2017\n   *\n   * \
Description: Definition file for English - United States language-country.\n  \
 *)\n*/\n", "display" -> "esm", "sign" -> "outrun-5b9b9", 
    "props" -> <|"hidden" -> False|>|>}, "serializer" -> "jsfn3"|>
